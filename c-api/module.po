# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2021-12-09 10:51+0800\n"
"Last-Translator: Rodrigo Tobar <rtobarc@gmail.com>\n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.0\n"

#: ../Doc/c-api/module.rst:6
msgid "Module Objects"
msgstr "Objetos módulo"

#: ../Doc/c-api/module.rst:15
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python module type.  "
"This is exposed to Python programs as ``types.ModuleType``."
msgstr ""
"Esta instancia de :c:type:`PyTypeObject` representa el tipo de módulo "
"Python. Esto está expuesto a los programas de Python como ``types."
"ModuleType``."

#: ../Doc/c-api/module.rst:21
msgid ""
"Return true if *p* is a module object, or a subtype of a module object. This "
"function always succeeds."
msgstr ""
"Retorna verdadero si *p* es un objeto de módulo o un subtipo de un objeto de "
"módulo. Esta función siempre finaliza con éxito."

#: ../Doc/c-api/module.rst:27
msgid ""
"Return true if *p* is a module object, but not a subtype of :c:data:"
"`PyModule_Type`.  This function always succeeds."
msgstr ""
"Retorna verdadero si *p* es un objeto módulo, pero no un subtipo de :c:data:"
"`PyModule_Type`. Esta función siempre finaliza con éxito."

#: ../Doc/c-api/module.rst:40
msgid ""
"Return a new module object with the :attr:`__name__` attribute set to "
"*name*. The module's :attr:`__name__`, :attr:`__doc__`, :attr:`__package__`, "
"and :attr:`__loader__` attributes are filled in (all but :attr:`__name__` "
"are set to ``None``); the caller is responsible for providing a :attr:"
"`__file__` attribute."
msgstr ""
"Retorna un nuevo objeto módulo con el atributo :attr:`__name__` establecido "
"en *name*. Los atributos del módulo :attr:`__name__`, :attr:`__doc__`, :attr:"
"`__package__`, y :attr:`__loader__` se completan (todos menos :attr:"
"`__name__` están configurados en ``None``); quien llama es responsable de "
"proporcionar un atributo :attr:`__file__`."

#: ../Doc/c-api/module.rst:48
msgid ":attr:`__package__` and :attr:`__loader__` are set to ``None``."
msgstr ""
":attr:`__package__` y :attr:`__loader__` están configurados en ``None``."

#: ../Doc/c-api/module.rst:54
msgid ""
"Similar to :c:func:`PyModule_NewObject`, but the name is a UTF-8 encoded "
"string instead of a Unicode object."
msgstr ""
"Similar a :c:func:`PyModule_NewObject`, pero el nombre es una cadena de "
"caracteres codificada UTF-8 en lugar de un objeto Unicode."

#: ../Doc/c-api/module.rst:62
msgid ""
"Return the dictionary object that implements *module*'s namespace; this "
"object is the same as the :attr:`~object.__dict__` attribute of the module "
"object. If *module* is not a module object (or a subtype of a module "
"object), :exc:`SystemError` is raised and ``NULL`` is returned."
msgstr ""
"Retorna el objeto del diccionario que implementa el espacio de nombres de "
"*module*; este objeto es el mismo que el atributo :attr:`~object.__dict__` "
"del objeto módulo. Si *module* no es un objeto módulo (o un subtipo de un "
"objeto de módulo), se lanza :exc:`SystemError` y se retorna ``NULL``."

#: ../Doc/c-api/module.rst:67
#, fuzzy
msgid ""
"It is recommended extensions use other ``PyModule_*`` and ``PyObject_*`` "
"functions rather than directly manipulate a module's :attr:`~object."
"__dict__`."
msgstr ""
"Se recomienda que las extensiones utilicen otras funciones :c:func:"
"`PyModule_\\*` y :c:func:`PyObject_\\*` en lugar de manipular directamente "
"el módulo :attr:`~object.__dict__`."

#: ../Doc/c-api/module.rst:78
msgid ""
"Return *module*'s :attr:`__name__` value.  If the module does not provide "
"one, or if it is not a string, :exc:`SystemError` is raised and ``NULL`` is "
"returned."
msgstr ""
"Retorna el valor :attr:`__name__` del *module*. Si el módulo no proporciona "
"uno, o si no es una cadena de caracteres, :exc:`SystemError` se lanza y se "
"retorna ``NULL``."

#: ../Doc/c-api/module.rst:86
msgid ""
"Similar to :c:func:`PyModule_GetNameObject` but return the name encoded to "
"``'utf-8'``."
msgstr ""
"Similar a :c:func:`PyModule_GetNameObject` pero retorna el nombre codificado "
"a ``'utf-8'``."

#: ../Doc/c-api/module.rst:91
msgid ""
"Return the \"state\" of the module, that is, a pointer to the block of "
"memory allocated at module creation time, or ``NULL``.  See :c:member:"
"`PyModuleDef.m_size`."
msgstr ""
"Retorna el \"estado\" del módulo, es decir, un puntero al bloque de memoria "
"asignado en el momento de la creación del módulo, o ``NULL``. Ver :c:member:"
"`PyModuleDef.m_size`."

#: ../Doc/c-api/module.rst:98
msgid ""
"Return a pointer to the :c:type:`PyModuleDef` struct from which the module "
"was created, or ``NULL`` if the module wasn't created from a definition."
msgstr ""
"Retorna un puntero a la estructura :c:type:`PyModuleDef` a partir de la cual "
"se creó el módulo, o ``NULL`` si el módulo no se creó a partir de una "
"definición."

#: ../Doc/c-api/module.rst:108
msgid ""
"Return the name of the file from which *module* was loaded using *module*'s :"
"attr:`__file__` attribute.  If this is not defined, or if it is not a "
"unicode string, raise :exc:`SystemError` and return ``NULL``; otherwise "
"return a reference to a Unicode object."
msgstr ""
"Retorna el nombre del archivo desde el cual *module* se cargó utilizando el "
"atributo :attr:`__file__` del *module*. Si esto no está definido, o si no es "
"una cadena de caracteres unicode, lanza :exc:`SystemError` y retornar "
"``NULL``; de lo contrario, retorna una referencia a un objeto Unicode."

#: ../Doc/c-api/module.rst:118
msgid ""
"Similar to :c:func:`PyModule_GetFilenameObject` but return the filename "
"encoded to 'utf-8'."
msgstr ""
"Similar a :c:func:`PyModule_GetFilenameObject` pero retorna el nombre de "
"archivo codificado a 'utf-8'."

#: ../Doc/c-api/module.rst:121
#, fuzzy
msgid ""
":c:func:`PyModule_GetFilename` raises :exc:`UnicodeEncodeError` on "
"unencodable filenames, use :c:func:`PyModule_GetFilenameObject` instead."
msgstr ""
":c:func:`PyModule_GetFilename` lanza :c:type:`UnicodeEncodeError` en nombres "
"de archivo no codificables, use :c:func:`PyModule_GetFilenameObject` en su "
"lugar."

#: ../Doc/c-api/module.rst:129
msgid "Initializing C modules"
msgstr "Inicializando módulos en C"

#: ../Doc/c-api/module.rst:131
msgid ""
"Modules objects are usually created from extension modules (shared libraries "
"which export an initialization function), or compiled-in modules (where the "
"initialization function is added using :c:func:`PyImport_AppendInittab`). "
"See :ref:`building` or :ref:`extending-with-embedding` for details."
msgstr ""
"Los objetos módulos generalmente se crean a partir de módulos de extensión "
"(bibliotecas compartidas que exportan una función de inicialización) o "
"módulos compilados (donde la función de inicialización se agrega usando :c:"
"func:`PyImport_AppendInittab`). Consulte :ref:`building` o :ref:`extendiendo "
"con incrustación <extending-with-embedding>` para más detalles."

#: ../Doc/c-api/module.rst:136
msgid ""
"The initialization function can either pass a module definition instance to :"
"c:func:`PyModule_Create`, and return the resulting module object, or request "
"\"multi-phase initialization\" by returning the definition struct itself."
msgstr ""
"La función de inicialización puede pasar una instancia de definición de "
"módulo a :c:func:`PyModule_Create`, y retornar el objeto módulo resultante, "
"o solicitar una \"inicialización de múltiples fases\" retornando la "
"estructura de definición."

#: ../Doc/c-api/module.rst:142
msgid ""
"The module definition struct, which holds all information needed to create a "
"module object. There is usually only one statically initialized variable of "
"this type for each module."
msgstr ""
"La estructura de definición de módulo, que contiene toda la información "
"necesaria para crear un objeto módulo. Por lo general, solo hay una variable "
"estáticamente inicializada de este tipo para cada módulo."

#: ../Doc/c-api/module.rst:148
#, fuzzy
msgid "Always initialize this member to :c:macro:`PyModuleDef_HEAD_INIT`."
msgstr "Siempre inicialice este miembro a :const:`PyModuleDef_HEAD_INIT`."

#: ../Doc/c-api/module.rst:152
msgid "Name for the new module."
msgstr "Nombre para el nuevo módulo."

#: ../Doc/c-api/module.rst:156
msgid ""
"Docstring for the module; usually a docstring variable created with :c:macro:"
"`PyDoc_STRVAR` is used."
msgstr ""
"Docstring para el módulo; por lo general, se usa una variable docstring "
"creada con :c:macro:`PyDoc_STRVAR`."

#: ../Doc/c-api/module.rst:161
msgid ""
"Module state may be kept in a per-module memory area that can be retrieved "
"with :c:func:`PyModule_GetState`, rather than in static globals. This makes "
"modules safe for use in multiple sub-interpreters."
msgstr ""
"El estado del módulo se puede mantener en un área de memoria por módulo que "
"se puede recuperar con :c:func:`PyModule_GetState`, en lugar de en globales "
"estáticos. Esto hace que los módulos sean seguros para su uso en múltiples "
"sub-interpretadores."

#: ../Doc/c-api/module.rst:165
#, fuzzy
msgid ""
"This memory area is allocated based on *m_size* on module creation, and "
"freed when the module object is deallocated, after the :c:member:"
"`~PyModuleDef.m_free` function has been called, if present."
msgstr ""
"Esta área de memoria se asigna en base a *m_size* en la creación del módulo, "
"y se libera cuando el objeto del módulo se desasigna, después de que se haya "
"llamado a la función :c:member:`m_free`, si está presente."

#: ../Doc/c-api/module.rst:169
msgid ""
"Setting ``m_size`` to ``-1`` means that the module does not support sub-"
"interpreters, because it has global state."
msgstr ""
"Establecer ``m_size`` en ``-1`` significa que el módulo no admite sub-"
"interpretadores, porque tiene un estado global."

#: ../Doc/c-api/module.rst:172
msgid ""
"Setting it to a non-negative value means that the module can be re-"
"initialized and specifies the additional amount of memory it requires for "
"its state. Non-negative ``m_size`` is required for multi-phase "
"initialization."
msgstr ""
"Establecerlo en un valor no negativo significa que el módulo se puede "
"reinicializar y especifica la cantidad adicional de memoria que requiere "
"para su estado. Se requiere ``m_size`` no negativo para la inicialización de "
"múltiples fases."

#: ../Doc/c-api/module.rst:177
msgid "See :PEP:`3121` for more details."
msgstr "Ver :PEP:`3121` para más detalles."

#: ../Doc/c-api/module.rst:181
msgid ""
"A pointer to a table of module-level functions, described by :c:type:"
"`PyMethodDef` values.  Can be ``NULL`` if no functions are present."
msgstr ""
"Un puntero a una tabla de funciones de nivel de módulo, descrito por "
"valores :c:type:`PyMethodDef`. Puede ser ``NULL`` si no hay funciones "
"presentes."

#: ../Doc/c-api/module.rst:186
msgid ""
"An array of slot definitions for multi-phase initialization, terminated by a "
"``{0, NULL}`` entry. When using single-phase initialization, *m_slots* must "
"be ``NULL``."
msgstr ""
"Un conjunto de definiciones de ranura para la inicialización de múltiples "
"fases, terminadas por una entrada ``{0, NULL}``. Cuando se utiliza la "
"inicialización monofásica, *m_slots* debe ser ``NULL``."

#: ../Doc/c-api/module.rst:192
msgid ""
"Prior to version 3.5, this member was always set to ``NULL``, and was "
"defined as:"
msgstr ""
"Antes de la versión 3.5, este miembro siempre estaba configurado en ``NULL`` "
"y se definía como:"

#: ../Doc/c-api/module.rst:199
msgid ""
"A traversal function to call during GC traversal of the module object, or "
"``NULL`` if not needed."
msgstr ""
"Una función transversal para llamar durante el recorrido GC del objeto del "
"módulo, o ``NULL`` si no es necesario."

#: ../Doc/c-api/module.rst:202 ../Doc/c-api/module.rst:217
#: ../Doc/c-api/module.rst:238
#, fuzzy
msgid ""
"This function is not called if the module state was requested but is not "
"allocated yet. This is the case immediately after the module is created and "
"before the module is executed (:c:data:`Py_mod_exec` function). More "
"precisely, this function is not called if :c:member:`~PyModuleDef.m_size` is "
"greater than 0 and the module state (as returned by :c:func:"
"`PyModule_GetState`) is ``NULL``."
msgstr ""
"Esta función no se llama si se solicitó el estado del módulo pero aún no se "
"asignó. Este es el caso inmediatamente después de que se crea el módulo y "
"antes de que se ejecute (la función :c:data:`Py_mod_exec`). Más "
"precisamente, esta función no se llama si :c:member:`m_size` es mayor que 0 "
"y el estado del módulo (como lo retorna :c:func:`PyModule_GetState`) es "
"``NULL``."

#: ../Doc/c-api/module.rst:209 ../Doc/c-api/module.rst:230
#: ../Doc/c-api/module.rst:245
msgid "No longer called before the module state is allocated."
msgstr "Ya no se llama antes de que se asigne el estado del módulo."

#: ../Doc/c-api/module.rst:214
msgid ""
"A clear function to call during GC clearing of the module object, or "
"``NULL`` if not needed."
msgstr ""
"Una función clara para llamar durante la limpieza GC del objeto del módulo, "
"o ``NULL`` si no es necesario."

#: ../Doc/c-api/module.rst:224
msgid ""
"Like :c:member:`PyTypeObject.tp_clear`, this function is not *always* called "
"before a module is deallocated. For example, when reference counting is "
"enough to determine that an object is no longer used, the cyclic garbage "
"collector is not involved and :c:member:`~PyModuleDef.m_free` is called "
"directly."
msgstr ""
"Tal como :c:member:`PyTypeObject.tp_clear`, esta función no *siempre* es "
"llamada antes de la designación de un módulo. Por ejemplo, cuando el "
"recuento de referencias está  listo para determinar que un objeto no se usa "
"más, la recolección de basura cíclica no se involucra y se llama a :c:member:"
"`~PyModuleDef.m_free` directamente."

#: ../Doc/c-api/module.rst:235
msgid ""
"A function to call during deallocation of the module object, or ``NULL`` if "
"not needed."
msgstr ""
"Una función para llamar durante la desasignación del objeto del módulo, o "
"``NULL`` si no es necesario."

#: ../Doc/c-api/module.rst:249
msgid "Single-phase initialization"
msgstr "Inicialización monofásica"

#: ../Doc/c-api/module.rst:251
msgid ""
"The module initialization function may create and return the module object "
"directly. This is referred to as \"single-phase initialization\", and uses "
"one of the following two module creation functions:"
msgstr ""
"La función de inicialización del módulo puede crear y retornar el objeto "
"módulo directamente. Esto se conoce como \"inicialización monofásica\" y "
"utiliza una de las siguientes funciones de creación de dos módulos:"

#: ../Doc/c-api/module.rst:257
#, fuzzy
msgid ""
"Create a new module object, given the definition in *def*.  This behaves "
"like :c:func:`PyModule_Create2` with *module_api_version* set to :c:macro:"
"`PYTHON_API_VERSION`."
msgstr ""
"Crea un nuevo objeto módulo, dada la definición en *def*. Esto se comporta "
"como :c:func:`PyModule_Create2` con *module_api_version* establecido en :"
"const:`PYTHON_API_VERSION`."

#: ../Doc/c-api/module.rst:264
msgid ""
"Create a new module object, given the definition in *def*, assuming the API "
"version *module_api_version*.  If that version does not match the version of "
"the running interpreter, a :exc:`RuntimeWarning` is emitted."
msgstr ""
"Crea un nuevo objeto de módulo, dada la definición en *def*, asumiendo la "
"versión de API *module_api_version*. Si esa versión no coincide con la "
"versión del intérprete en ejecución, se emite un :exc:`RuntimeWarning`."

#: ../Doc/c-api/module.rst:270
msgid ""
"Most uses of this function should be using :c:func:`PyModule_Create` "
"instead; only use this if you are sure you need it."
msgstr ""
"La mayoría de los usos de esta función deberían usar :c:func:"
"`PyModule_Create` en su lugar; solo use esto si está seguro de que lo "
"necesita."

#: ../Doc/c-api/module.rst:273
msgid ""
"Before it is returned from in the initialization function, the resulting "
"module object is typically populated using functions like :c:func:"
"`PyModule_AddObjectRef`."
msgstr ""
"Antes de que se retorne desde la función de inicialización, el objeto del "
"módulo resultante normalmente se llena utilizando funciones como :c:func:"
"`PyModule_AddObjectRef`."

#: ../Doc/c-api/module.rst:279
msgid "Multi-phase initialization"
msgstr "Inicialización multifase"

#: ../Doc/c-api/module.rst:281
#, fuzzy
msgid ""
"An alternate way to specify extensions is to request \"multi-phase "
"initialization\". Extension modules created this way behave more like Python "
"modules: the initialization is split between the *creation phase*, when the "
"module object is created, and the *execution phase*, when it is populated. "
"The distinction is similar to the :py:meth:`!__new__` and :py:meth:`!"
"__init__` methods of classes."
msgstr ""
"Una forma alternativa de especificar extensiones es solicitar una "
"\"inicialización de múltiples fases\". Los módulos de extensión creados de "
"esta manera se comportan más como los módulos de Python: la inicialización "
"se divide entre la fase de creación (*creation phase*), cuando se crea el "
"objeto módulo, y la fase de ejecución (*execution phase*), cuando se llena. "
"La distinción es similar a los métodos de clases :py:meth:`__new__` y :py:"
"meth:`__init__`."

#: ../Doc/c-api/module.rst:288
#, fuzzy
msgid ""
"Unlike modules created using single-phase initialization, these modules are "
"not singletons: if the *sys.modules* entry is removed and the module is re-"
"imported, a new module object is created, and the old module is subject to "
"normal garbage collection -- as with Python modules. By default, multiple "
"modules created from the same definition should be independent: changes to "
"one should not affect the others. This means that all state should be "
"specific to the module object (using e.g. using :c:func:"
"`PyModule_GetState`), or its contents (such as the module's :attr:`~object."
"__dict__` or individual classes created with :c:func:`PyType_FromSpec`)."
msgstr ""
"A diferencia de los módulos creados con la inicialización monofásica, estos "
"módulos no son singletons: si se elimina la entrada *sys.modules* y el "
"módulo se vuelve a importar, se crea un nuevo objeto módulo y el módulo "
"anterior está sujeto a la recolección normal de basura -- Al igual que con "
"los módulos de Python. Por defecto, los módulos múltiples creados a partir "
"de la misma definición deberían ser independientes: los cambios en uno no "
"deberían afectar a los demás. Esto significa que todo el estado debe ser "
"específico para el objeto del módulo (usando, por ejemplo, usando :c:func:"
"`PyModule_GetState`), o su contenido (como el módulo :attr:`__dict__` o "
"clases individuales creadas con :c:func:`PyType_FromSpec`)."

#: ../Doc/c-api/module.rst:298
msgid ""
"All modules created using multi-phase initialization are expected to "
"support :ref:`sub-interpreters <sub-interpreter-support>`. Making sure "
"multiple modules are independent is typically enough to achieve this."
msgstr ""
"Se espera que todos los módulos creados mediante la inicialización de "
"múltiples fases admitan :ref:`sub-interpretadores <sub-interpreter-"
"support>`. Asegurándose de que varios módulos sean independientes suele ser "
"suficiente para lograr esto."

#: ../Doc/c-api/module.rst:302
msgid ""
"To request multi-phase initialization, the initialization function "
"(PyInit_modulename) returns a :c:type:`PyModuleDef` instance with non-empty :"
"c:member:`~PyModuleDef.m_slots`. Before it is returned, the ``PyModuleDef`` "
"instance must be initialized with the following function:"
msgstr ""
"Para solicitar la inicialización de múltiples fases, la función de "
"inicialización (*PyInit_modulename*) retorna una instancia de :c:type:"
"`PyModuleDef` con un :c:member:`~PyModuleDef.m_slots` no vacío. Antes de que "
"se retorna, la instancia ``PyModuleDef`` debe inicializarse con la siguiente "
"función:"

#: ../Doc/c-api/module.rst:309
msgid ""
"Ensures a module definition is a properly initialized Python object that "
"correctly reports its type and reference count."
msgstr ""
"Asegura que la definición de un módulo sea un objeto Python correctamente "
"inicializado que informe correctamente su tipo y conteo de referencias."

#: ../Doc/c-api/module.rst:312
msgid "Returns *def* cast to ``PyObject*``, or ``NULL`` if an error occurred."
msgstr ""
"Retorna *def* convertido a ``PyObject*`` o ``NULL`` si se produjo un error."

#: ../Doc/c-api/module.rst:316
msgid ""
"The *m_slots* member of the module definition must point to an array of "
"``PyModuleDef_Slot`` structures:"
msgstr ""
"El miembro *m_slots* de la definición del módulo debe apuntar a un arreglo "
"de estructuras ``PyModuleDef_Slot``:"

#: ../Doc/c-api/module.rst:323
msgid "A slot ID, chosen from the available values explained below."
msgstr ""
"Una ranura ID, elegida entre los valores disponibles que se explican a "
"continuación."

#: ../Doc/c-api/module.rst:327
msgid "Value of the slot, whose meaning depends on the slot ID."
msgstr "Valor de la ranura, cuyo significado depende de la ID de la ranura."

#: ../Doc/c-api/module.rst:331
msgid "The *m_slots* array must be terminated by a slot with id 0."
msgstr "El arreglo *m_slots* debe estar terminada por una ranura con id 0."

#: ../Doc/c-api/module.rst:333
msgid "The available slot types are:"
msgstr "Los tipos de ranura disponibles son:"

#: ../Doc/c-api/module.rst:337
msgid ""
"Specifies a function that is called to create the module object itself. The "
"*value* pointer of this slot must point to a function of the signature:"
msgstr ""
"Especifica una función que se llama para crear el objeto del módulo en sí. "
"El puntero *value* de este espacio debe apuntar a una función de la firma:"

#: ../Doc/c-api/module.rst:343
msgid ""
"The function receives a :py:class:`~importlib.machinery.ModuleSpec` "
"instance, as defined in :PEP:`451`, and the module definition. It should "
"return a new module object, or set an error and return ``NULL``."
msgstr ""
"La función recibe una instancia de :py:class:`~importlib.machinery."
"ModuleSpec`, como se define en :PEP:`451`, y la definición del módulo. "
"Debería retornar un nuevo objeto de módulo, o establecer un error y retornar "
"``NULL``."

#: ../Doc/c-api/module.rst:348
msgid ""
"This function should be kept minimal. In particular, it should not call "
"arbitrary Python code, as trying to import the same module again may result "
"in an infinite loop."
msgstr ""
"Esta función debe mantenerse mínima. En particular, no debería llamar a "
"código arbitrario de Python, ya que intentar importar el mismo módulo "
"nuevamente puede dar como resultado un bucle infinito."

#: ../Doc/c-api/module.rst:352
msgid ""
"Multiple ``Py_mod_create`` slots may not be specified in one module "
"definition."
msgstr ""
"Múltiples ranuras ``Py_mod_create`` no pueden especificarse en una "
"definición de módulo."

#: ../Doc/c-api/module.rst:355
msgid ""
"If ``Py_mod_create`` is not specified, the import machinery will create a "
"normal module object using :c:func:`PyModule_New`. The name is taken from "
"*spec*, not the definition, to allow extension modules to dynamically adjust "
"to their place in the module hierarchy and be imported under different names "
"through symlinks, all while sharing a single module definition."
msgstr ""
"Si no se especifica ``Py_mod_create``, la maquinaria de importación creará "
"un objeto de módulo normal usando :c:func:`PyModule_New`. El nombre se toma "
"de *spec*, no de la definición, para permitir que los módulos de extensión "
"se ajusten dinámicamente a su lugar en la jerarquía de módulos y se importen "
"bajo diferentes nombres a través de enlaces simbólicos, todo mientras se "
"comparte una definición de módulo único."

#: ../Doc/c-api/module.rst:361
msgid ""
"There is no requirement for the returned object to be an instance of :c:type:"
"`PyModule_Type`. Any type can be used, as long as it supports setting and "
"getting import-related attributes. However, only ``PyModule_Type`` instances "
"may be returned if the ``PyModuleDef`` has non-``NULL`` ``m_traverse``, "
"``m_clear``, ``m_free``; non-zero ``m_size``; or slots other than "
"``Py_mod_create``."
msgstr ""
"No es necesario que el objeto retornado sea una instancia de :c:type:"
"`PyModule_Type`. Se puede usar cualquier tipo, siempre que admita la "
"configuración y la obtención de atributos relacionados con la importación. "
"Sin embargo, solo se pueden retornar instancias ``PyModule_Type`` si el "
"``PyModuleDef`` no tiene ``NULL`` ``m_traverse``, ``m_clear``, ``m_free``; "
"``m_size`` distinto de cero; o ranuras que no sean ``Py_mod_create``."

#: ../Doc/c-api/module.rst:370
msgid ""
"Specifies a function that is called to *execute* the module. This is "
"equivalent to executing the code of a Python module: typically, this "
"function adds classes and constants to the module. The signature of the "
"function is:"
msgstr ""
"Especifica una función que se llama para ejecutar (*execute*) el módulo. "
"Esto es equivalente a ejecutar el código de un módulo Python: por lo "
"general, esta función agrega clases y constantes al módulo. La firma de la "
"función es:"

#: ../Doc/c-api/module.rst:378
msgid ""
"If multiple ``Py_mod_exec`` slots are specified, they are processed in the "
"order they appear in the *m_slots* array."
msgstr ""
"Si se especifican varias ranuras ``Py_mod_exec``, se procesan en el orden en "
"que aparecen en el arreglo *m_slots*."

#: ../Doc/c-api/module.rst:383
msgid "Specifies one of the following values:"
msgstr ""

#: ../Doc/c-api/module.rst:389
msgid "The module does not support being imported in subinterpreters."
msgstr ""

#: ../Doc/c-api/module.rst:393
msgid ""
"The module supports being imported in subinterpreters, but only when they "
"share the main interpreter's GIL. (See :ref:`isolating-extensions-howto`.)"
msgstr ""

#: ../Doc/c-api/module.rst:399
msgid ""
"The module supports being imported in subinterpreters, even when they have "
"their own GIL. (See :ref:`isolating-extensions-howto`.)"
msgstr ""

#: ../Doc/c-api/module.rst:403
msgid ""
"This slot determines whether or not importing this module in a "
"subinterpreter will fail."
msgstr ""

#: ../Doc/c-api/module.rst:406
#, fuzzy
msgid ""
"Multiple ``Py_mod_multiple_interpreters`` slots may not be specified in one "
"module definition."
msgstr ""
"Múltiples ranuras ``Py_mod_create`` no pueden especificarse en una "
"definición de módulo."

#: ../Doc/c-api/module.rst:409
msgid ""
"If ``Py_mod_multiple_interpreters`` is not specified, the import machinery "
"defaults to ``Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED``."
msgstr ""

#: ../Doc/c-api/module.rst:414
msgid "See :PEP:`489` for more details on multi-phase initialization."
msgstr ""
"Ver :PEP:`489` para más detalles sobre la inicialización de múltiples fases."

#: ../Doc/c-api/module.rst:417
msgid "Low-level module creation functions"
msgstr "Funciones de creación de módulos de bajo nivel"

#: ../Doc/c-api/module.rst:419
msgid ""
"The following functions are called under the hood when using multi-phase "
"initialization. They can be used directly, for example when creating module "
"objects dynamically. Note that both ``PyModule_FromDefAndSpec`` and "
"``PyModule_ExecDef`` must be called to fully initialize a module."
msgstr ""
"Las siguientes funciones se invocan en segundo plano cuando se utiliza la "
"inicialización de múltiples fases. Se pueden usar directamente, por ejemplo, "
"al crear objetos de módulo de forma dinámica. Tenga en cuenta que tanto "
"``PyModule_FromDefAndSpec`` como ``PyModule_ExecDef`` deben llamarse para "
"inicializar completamente un módulo."

#: ../Doc/c-api/module.rst:426
#, fuzzy
msgid ""
"Create a new module object, given the definition in *def* and the ModuleSpec "
"*spec*.  This behaves like :c:func:`PyModule_FromDefAndSpec2` with "
"*module_api_version* set to :c:macro:`PYTHON_API_VERSION`."
msgstr ""
"Cree un nuevo objeto módulo, dada la definición en *module* y ModuleSpec "
"*spec*. Esto se comporta como :c:func:`PyModule_FromDefAndSpec2` con "
"*module_api_version* establecido en :const:`PYTHON_API_VERSION`."

#: ../Doc/c-api/module.rst:434
#, fuzzy
msgid ""
"Create a new module object, given the definition in *def* and the ModuleSpec "
"*spec*, assuming the API version *module_api_version*. If that version does "
"not match the version of the running interpreter, a :exc:`RuntimeWarning` is "
"emitted."
msgstr ""
"Cree un nuevo objeto módulo, dada la definición en *module* y ModuleSpec "
"*spec*, asumiendo la versión de API *module_api_version*. Si esa versión no "
"coincide con la versión del intérprete en ejecución, se emite un :exc:"
"`RuntimeWarning`."

#: ../Doc/c-api/module.rst:441
msgid ""
"Most uses of this function should be using :c:func:`PyModule_FromDefAndSpec` "
"instead; only use this if you are sure you need it."
msgstr ""
"La mayoría de los usos de esta función deberían usar :c:func:"
"`PyModule_FromDefAndSpec` en su lugar; solo use esto si está seguro de que "
"lo necesita."

#: ../Doc/c-api/module.rst:448
msgid "Process any execution slots (:c:data:`Py_mod_exec`) given in *def*."
msgstr ""
"Procesa cualquier ranura de ejecución (:c:data:`Py_mod_exec`) dado en *def*."

#: ../Doc/c-api/module.rst:454
msgid ""
"Set the docstring for *module* to *docstring*. This function is called "
"automatically when creating a module from ``PyModuleDef``, using either "
"``PyModule_Create`` or ``PyModule_FromDefAndSpec``."
msgstr ""
"Establece la cadena de caracteres de documentación para *module* en "
"*docstring*. Esta función se llama automáticamente cuando se crea un módulo "
"desde ``PyModuleDef``, usando ``PyModule_Create`` o "
"``PyModule_FromDefAndSpec``."

#: ../Doc/c-api/module.rst:463
msgid ""
"Add the functions from the ``NULL`` terminated *functions* array to "
"*module*. Refer to the :c:type:`PyMethodDef` documentation for details on "
"individual entries (due to the lack of a shared module namespace, module "
"level \"functions\" implemented in C typically receive the module as their "
"first parameter, making them similar to instance methods on Python classes). "
"This function is called automatically when creating a module from "
"``PyModuleDef``, using either ``PyModule_Create`` or "
"``PyModule_FromDefAndSpec``."
msgstr ""
"Agrega las funciones del arreglo *functions* terminadas en ``NULL`` a "
"*module*. Consulte la documentación de :c:type:`PyMethodDef` para obtener "
"detalles sobre entradas individuales (debido a la falta de un espacio de "
"nombres de módulo compartido, las \"funciones\" de nivel de módulo "
"implementadas en C generalmente reciben el módulo como su primer parámetro, "
"haciéndolos similares a la instancia métodos en clases de Python). Esta "
"función se llama automáticamente cuando se crea un módulo desde "
"``PyModuleDef``, usando ``PyModule_Create`` o ``PyModule_FromDefAndSpec``."

#: ../Doc/c-api/module.rst:475
msgid "Support functions"
msgstr "Funciones de soporte"

#: ../Doc/c-api/module.rst:477
msgid ""
"The module initialization function (if using single phase initialization) or "
"a function called from a module execution slot (if using multi-phase "
"initialization), can use the following functions to help initialize the "
"module state:"
msgstr ""
"La función de inicialización del módulo (si usa la inicialización de fase "
"única) o una función llamada desde un intervalo de ejecución del módulo (si "
"usa la inicialización de múltiples fases), puede usar las siguientes "
"funciones para ayudar a inicializar el estado del módulo:"

#: ../Doc/c-api/module.rst:484
msgid ""
"Add an object to *module* as *name*.  This is a convenience function which "
"can be used from the module's initialization function."
msgstr ""
"Agrega un objeto a *module* como *name*. Esta es una función de conveniencia "
"que se puede usar desde la función de inicialización del módulo."

#: ../Doc/c-api/module.rst:487
msgid ""
"On success, return ``0``. On error, raise an exception and return ``-1``."
msgstr ""
"En caso de éxito, retorna ``0``. En caso de error, lanza una excepción y "
"retorna ``-1``."

#: ../Doc/c-api/module.rst:489
msgid ""
"Return ``NULL`` if *value* is ``NULL``. It must be called with an exception "
"raised in this case."
msgstr ""
"Retorna ``NULL`` si *value* es ``NULL``. Debe llamarse lanzando una "
"excepción en este caso."

#: ../Doc/c-api/module.rst:492 ../Doc/c-api/module.rst:541
msgid "Example usage::"
msgstr "Ejemplo de uso ::"

#: ../Doc/c-api/module.rst:506 ../Doc/c-api/module.rst:559
msgid ""
"The example can also be written without checking explicitly if *obj* is "
"``NULL``::"
msgstr ""
"El ejemplo puede también ser escrito sin verificar explicitamente si *obj* "
"es ``NULL``::"

#: ../Doc/c-api/module.rst:518 ../Doc/c-api/module.rst:575
msgid ""
"Note that ``Py_XDECREF()`` should be used instead of ``Py_DECREF()`` in this "
"case, since *obj* can be ``NULL``."
msgstr ""
"Note que ``Py_XDECREF()`` debería ser usado en vez de ``Py_DECREF()`` en "
"este caso, ya que *obj* puede ser ``NULL``."

#: ../Doc/c-api/module.rst:526
msgid ""
"Similar to :c:func:`PyModule_AddObjectRef`, but steals a reference to "
"*value* on success (if it returns ``0``)."
msgstr ""
"Similar a :c:func:`PyModule_AddObjectRef`, pero roba una referencia a "
"*value* en caso de éxito (en este caso retorna ``0``)."

#: ../Doc/c-api/module.rst:529
msgid ""
"The new :c:func:`PyModule_AddObjectRef` function is recommended, since it is "
"easy to introduce reference leaks by misusing the :c:func:"
"`PyModule_AddObject` function."
msgstr ""
"Se recomienda la nueva función :c:func:`PyModule_AddObjectRef`, ya que es "
"sencillo introducir fugas de referencias por un uso incorrecto de la "
"función :c:func:`PyModule_AddObject`."

#: ../Doc/c-api/module.rst:535
#, fuzzy
msgid ""
"Unlike other functions that steal references, ``PyModule_AddObject()`` only "
"releases the reference to *value* **on success**."
msgstr ""
"A diferencia de otras funciones que roban referencias, "
"``PyModule_AddObject()`` solo disminuye el conteo de referencias de *value* "
"**en caso de éxito**."

#: ../Doc/c-api/module.rst:538
msgid ""
"This means that its return value must be checked, and calling code must :c:"
"func:`Py_DECREF` *value* manually on error."
msgstr ""
"Esto significa que su valor de retorno debe ser verificado, y el código de "
"llamada debe :c:func:`Py_DECREF` *value* manualmente en caso de error."

#: ../Doc/c-api/module.rst:581
msgid ""
"Add an integer constant to *module* as *name*.  This convenience function "
"can be used from the module's initialization function. Return ``-1`` on "
"error, ``0`` on success."
msgstr ""
"Agrega una constante entera a *module* como *name*. Esta función de "
"conveniencia se puede usar desde la función de inicialización del módulo. "
"Retorna ``-1`` en caso de error, ``0`` en caso de éxito."

#: ../Doc/c-api/module.rst:588
msgid ""
"Add a string constant to *module* as *name*.  This convenience function can "
"be used from the module's initialization function.  The string *value* must "
"be ``NULL``-terminated.  Return ``-1`` on error, ``0`` on success."
msgstr ""
"Agrega una constante de cadena a *module* como *name*. Esta función de "
"conveniencia se puede usar desde la función de inicialización del módulo. La "
"cadena de caracteres *value* debe estar terminada en ``NULL``. Retorna "
"``-1`` en caso de error, ``0`` en caso de éxito."

#: ../Doc/c-api/module.rst:595
msgid ""
"Add an int constant to *module*. The name and the value are taken from "
"*macro*. For example ``PyModule_AddIntMacro(module, AF_INET)`` adds the int "
"constant *AF_INET* with the value of *AF_INET* to *module*. Return ``-1`` on "
"error, ``0`` on success."
msgstr ""
"Agrega una constante int a *module*. El nombre y el valor se toman de "
"*macro*. Por ejemplo, ``PyModule_AddIntMacro(module, AF_INET)`` agrega la "
"constante int *AF_INET* con el valor de *AF_INET* a *module*. Retorna ``-1`` "
"en caso de error, ``0`` en caso de éxito."

#: ../Doc/c-api/module.rst:603
msgid "Add a string constant to *module*."
msgstr "Agrega una constante de cadena de caracteres a *module*."

#: ../Doc/c-api/module.rst:607
msgid ""
"Add a type object to *module*. The type object is finalized by calling "
"internally :c:func:`PyType_Ready`. The name of the type object is taken from "
"the last component of :c:member:`~PyTypeObject.tp_name` after dot. Return "
"``-1`` on error, ``0`` on success."
msgstr ""
"Agrega un objeto tipo a *module*. El objeto tipo se finaliza llamando "
"internamente :c:func:`PyType_Ready`. El nombre del objeto tipo se toma del "
"último componente de :c:member:`~PyTypeObject.tp_name` después del punto. "
"Retorna ``-1`` en caso de error, ``0`` en caso de éxito."

#: ../Doc/c-api/module.rst:617
msgid "Module lookup"
msgstr "Búsqueda de módulos"

#: ../Doc/c-api/module.rst:619
msgid ""
"Single-phase initialization creates singleton modules that can be looked up "
"in the context of the current interpreter. This allows the module object to "
"be retrieved later with only a reference to the module definition."
msgstr ""
"La inicialización monofásica crea módulos singleton que se pueden buscar en "
"el contexto del intérprete actual. Esto permite que el objeto módulo se "
"recupere más tarde con solo una referencia a la definición del módulo."

#: ../Doc/c-api/module.rst:623
msgid ""
"These functions will not work on modules created using multi-phase "
"initialization, since multiple such modules can be created from a single "
"definition."
msgstr ""
"Estas funciones no funcionarán en módulos creados mediante la inicialización "
"de múltiples fases, ya que se pueden crear múltiples módulos de este tipo "
"desde una sola definición."

#: ../Doc/c-api/module.rst:628
msgid ""
"Returns the module object that was created from *def* for the current "
"interpreter. This method requires that the module object has been attached "
"to the interpreter state with :c:func:`PyState_AddModule` beforehand. In "
"case the corresponding module object is not found or has not been attached "
"to the interpreter state yet, it returns ``NULL``."
msgstr ""
"Retorna el objeto módulo que se creó a partir de *def* para el intérprete "
"actual. Este método requiere que el objeto módulo se haya adjuntado al "
"estado del intérprete con :c:func:`PyState_AddModule` de antemano. En caso "
"de que el objeto módulo correspondiente no se encuentre o no se haya "
"adjuntado al estado del intérprete, retornará ``NULL``."

#: ../Doc/c-api/module.rst:635
msgid ""
"Attaches the module object passed to the function to the interpreter state. "
"This allows the module object to be accessible via :c:func:"
"`PyState_FindModule`."
msgstr ""
"Adjunta el objeto del módulo pasado a la función al estado del intérprete. "
"Esto permite que se pueda acceder al objeto del módulo a través de :c:func:"
"`PyState_FindModule`."

#: ../Doc/c-api/module.rst:638
msgid "Only effective on modules created using single-phase initialization."
msgstr "Solo es efectivo en módulos creados con la inicialización monofásica."

#: ../Doc/c-api/module.rst:640
msgid ""
"Python calls ``PyState_AddModule`` automatically after importing a module, "
"so it is unnecessary (but harmless) to call it from module initialization "
"code. An explicit call is needed only if the module's own init code "
"subsequently calls ``PyState_FindModule``. The function is mainly intended "
"for implementing alternative import mechanisms (either by calling it "
"directly, or by referring to its implementation for details of the required "
"state updates)."
msgstr ""
"Python llama a ``PyState_AddModule`` automáticamente después de importar un "
"módulo, por lo que es innecesario (pero inofensivo) llamarlo desde el código "
"de inicialización del módulo. Solo se necesita una llamada explícita si el "
"propio código de inicio del módulo llama posteriormente "
"``PyState_FindModule``. La función está destinada principalmente a "
"implementar mecanismos de importación alternativos (ya sea llamándolo "
"directamente o refiriéndose a su implementación para obtener detalles de las "
"actualizaciones de estado requeridas)."

#: ../Doc/c-api/module.rst:648 ../Doc/c-api/module.rst:659
msgid "The caller must hold the GIL."
msgstr "La persona que llama debe retener el GIL."

#: ../Doc/c-api/module.rst:650
msgid "Return 0 on success or -1 on failure."
msgstr "Retorna 0 en caso de éxito o -1 en caso de error."

#: ../Doc/c-api/module.rst:656
msgid ""
"Removes the module object created from *def* from the interpreter state. "
"Return 0 on success or -1 on failure."
msgstr ""
"Elimina el objeto del módulo creado a partir de *def* del estado del "
"intérprete. Retorna 0 en caso de éxito o -1 en caso de error."

#: ../Doc/c-api/module.rst:8
#, fuzzy
msgid "object"
msgstr "Objetos módulo"

#: ../Doc/c-api/module.rst:8
#, fuzzy
msgid "module"
msgstr "Búsqueda de módulos"

#: ../Doc/c-api/module.rst:13
msgid "ModuleType (in module types)"
msgstr ""

#: ../Doc/c-api/module.rst:33 ../Doc/c-api/module.rst:74
msgid "__name__ (module attribute)"
msgstr ""

#: ../Doc/c-api/module.rst:33
msgid "__doc__ (module attribute)"
msgstr ""

#: ../Doc/c-api/module.rst:33 ../Doc/c-api/module.rst:104
msgid "__file__ (module attribute)"
msgstr ""

#: ../Doc/c-api/module.rst:33
msgid "__package__ (module attribute)"
msgstr ""

#: ../Doc/c-api/module.rst:33
msgid "__loader__ (module attribute)"
msgstr ""

#: ../Doc/c-api/module.rst:60
msgid "__dict__ (module attribute)"
msgstr ""

#: ../Doc/c-api/module.rst:74 ../Doc/c-api/module.rst:104
msgid "SystemError (built-in exception)"
msgstr ""
