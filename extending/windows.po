# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to get
# the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2020-06-24 22:59+0200\n"
"Last-Translator: Cristián Maureira-Fredes <cmaureirafredes@gmail.com>\n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.0\n"

#: ../Doc/extending/windows.rst:8
msgid "Building C and C++ Extensions on Windows"
msgstr "Creación de extensiones C y C++ en Windows"

#: ../Doc/extending/windows.rst:10
msgid ""
"This chapter briefly explains how to create a Windows extension module for "
"Python using Microsoft Visual C++, and follows with more detailed background "
"information on how it works.  The explanatory material is useful for both "
"the Windows programmer learning to build Python extensions and the Unix "
"programmer interested in producing software which can be successfully built "
"on both Unix and Windows."
msgstr ""
"Este capítulo explica brevemente cómo crear un módulo de extensión de "
"Windows para Python usando Microsoft Visual C++, y sigue con información de "
"fondo más detallada sobre cómo funciona. El material explicativo es útil "
"tanto para el programador de Windows que está aprendiendo a construir "
"extensiones de Python como para el programador de Unix interesado en "
"producir software que se pueda construir con éxito tanto en Unix como en "
"Windows."

#: ../Doc/extending/windows.rst:17
msgid ""
"Module authors are encouraged to use the distutils approach for building "
"extension modules, instead of the one described in this section. You will "
"still need the C compiler that was used to build Python; typically Microsoft "
"Visual C++."
msgstr ""
"Se alienta a los autores de módulos a utilizar el enfoque distutils para "
"construir módulos de extensión, en lugar del descrito en esta sección. Aún "
"necesitará el compilador de C que se utilizó para construir Python; "
"típicamente Microsoft Visual C++."

#: ../Doc/extending/windows.rst:24
msgid ""
"This chapter mentions a number of filenames that include an encoded Python "
"version number.  These filenames are represented with the version number "
"shown as ``XY``; in practice, ``'X'`` will be the major version number and "
"``'Y'`` will be the minor version number of the Python release you're "
"working with.  For example, if you are using Python 2.2.1, ``XY`` will "
"actually be ``22``."
msgstr ""
"Este capítulo menciona varios nombres de archivo que incluyen un número de "
"versión codificado de Python. Estos nombres de archivo se representan con el "
"número de versión que se muestra como ``XY``; en la práctica, ``'X'`` será "
"el número de versión principal y ``'Y'`` será el número de versión menor de "
"la versión de Python con la que está trabajando. Por ejemplo, si está "
"utilizando Python 2.2.1, ``XY`` en realidad será ``22``."

#: ../Doc/extending/windows.rst:34
msgid "A Cookbook Approach"
msgstr "Un enfoque de libro de cocina"

#: ../Doc/extending/windows.rst:36
#, fuzzy
msgid ""
"There are two approaches to building extension modules on Windows, just as "
"there are on Unix: use the ``setuptools`` package to control the build "
"process, or do things manually.  The setuptools approach works well for most "
"extensions; documentation on using ``setuptools`` to build and package "
"extension modules is available in :ref:`setuptools-index`.  If you find you "
"really need to do things manually, it may be instructive to study the "
"project file for the :source:`winsound <PCbuild/winsound.vcxproj>` standard "
"library module."
msgstr ""
"Hay dos enfoques para construir módulos de extensión en Windows, al igual "
"que en Unix: use el paquete :mod:`distutils` para controlar el proceso de "
"construcción, o haga las cosas manualmente. El enfoque distutils funciona "
"bien para la mayoría de las extensiones; La documentación sobre el uso de :"
"mod:`distutils` para compilar y empaquetar módulos de extensión está "
"disponible en :ref:`distutils-index`. Si encuentra que realmente necesita "
"hacer las cosas manualmente, puede ser instructivo estudiar el archivo del "
"proyecto para el módulo de biblioteca estándar :source:`winsound <PCbuild/"
"winsound.vcxproj>`."

#: ../Doc/extending/windows.rst:48
msgid "Differences Between Unix and Windows"
msgstr "Diferencias entre Unix y Windows"

#: ../Doc/extending/windows.rst:53
msgid ""
"Unix and Windows use completely different paradigms for run-time loading of "
"code.  Before you try to build a module that can be dynamically loaded, be "
"aware of how your system works."
msgstr ""
"Unix y Windows usan paradigmas completamente diferentes para la carga de "
"código en tiempo de ejecución. Antes de intentar construir un módulo que se "
"pueda cargar dinámicamente, tenga en cuenta cómo funciona su sistema."

#: ../Doc/extending/windows.rst:57
msgid ""
"In Unix, a shared object (:file:`.so`) file contains code to be used by the "
"program, and also the names of functions and data that it expects to find in "
"the program.  When the file is joined to the program, all references to "
"those functions and data in the file's code are changed to point to the "
"actual locations in the program where the functions and data are placed in "
"memory. This is basically a link operation."
msgstr ""
"En Unix, un archivo de objeto compartido (:file:`.so`) contiene código para "
"ser utilizado por el programa, y también los nombres de funciones y datos "
"que espera encontrar en el programa. Cuando el archivo se une al programa, "
"todas las referencias a esas funciones y datos en el código del archivo se "
"cambian para apuntar a las ubicaciones reales en el programa donde las "
"funciones y los datos se colocan en la memoria. Esto es básicamente una "
"operación de enlace."

#: ../Doc/extending/windows.rst:64
msgid ""
"In Windows, a dynamic-link library (:file:`.dll`) file has no dangling "
"references.  Instead, an access to functions or data goes through a lookup "
"table.  So the DLL code does not have to be fixed up at runtime to refer to "
"the program's memory; instead, the code already uses the DLL's lookup table, "
"and the lookup table is modified at runtime to point to the functions and "
"data."
msgstr ""
"En Windows, un archivo de biblioteca de enlace dinámico (:file:`.dll`) no "
"tiene referencias colgantes. En cambio, un acceso a funciones o datos pasa "
"por una tabla de búsqueda. Por lo tanto, el código DLL no tiene que "
"repararse en tiempo de ejecución para referirse a la memoria del programa; "
"en cambio, el código ya usa la tabla de búsqueda de la DLL, y la tabla de "
"búsqueda se modifica en tiempo de ejecución para apuntar a las funciones y "
"los datos."

#: ../Doc/extending/windows.rst:70
msgid ""
"In Unix, there is only one type of library file (:file:`.a`) which contains "
"code from several object files (:file:`.o`).  During the link step to create "
"a shared object file (:file:`.so`), the linker may find that it doesn't know "
"where an identifier is defined.  The linker will look for it in the object "
"files in the libraries; if it finds it, it will include all the code from "
"that object file."
msgstr ""
"En Unix, solo hay un tipo de archivo de biblioteca (:file:`.a`) que contiene "
"código de varios archivos de objeto (:file:`.o`). Durante el paso de enlace "
"para crear un archivo de objeto compartido (:file:`.so`), el enlazador puede "
"encontrar que no sabe dónde se define un identificador. El enlazador lo "
"buscará en los archivos de objetos en las bibliotecas; si lo encuentra, "
"incluirá todo el código de ese archivo de objeto."

#: ../Doc/extending/windows.rst:76
msgid ""
"In Windows, there are two types of library, a static library and an import "
"library (both called :file:`.lib`).  A static library is like a Unix :file:`."
"a` file; it contains code to be included as necessary. An import library is "
"basically used only to reassure the linker that a certain identifier is "
"legal, and will be present in the program when the DLL is loaded.  So the "
"linker uses the information from the import library to build the lookup "
"table for using identifiers that are not included in the DLL.  When an "
"application or a DLL is linked, an import library may be generated, which "
"will need to be used for all future DLLs that depend on the symbols in the "
"application or DLL."
msgstr ""
"En Windows, hay dos tipos de biblioteca, una biblioteca estática y una "
"biblioteca de importación (ambas llamadas :file:`.lib`). Una biblioteca "
"estática es como un archivo Unix :file:`.a`; Contiene código para ser "
"incluido según sea necesario. Una biblioteca de importación se usa "
"básicamente solo para asegurarle al enlazador que cierto identificador es "
"legal y estará presente en el programa cuando se cargue la DLL. Por lo "
"tanto, el enlazador utiliza la información de la biblioteca de importación "
"para crear la tabla de búsqueda para usar identificadores que no están "
"incluidos en la DLL. Cuando se vincula una aplicación o una DLL, se puede "
"generar una biblioteca de importación, que deberá usarse para todas las DLL "
"futuras que dependan de los símbolos en la aplicación o DLL."

#: ../Doc/extending/windows.rst:86
msgid ""
"Suppose you are building two dynamic-load modules, B and C, which should "
"share another block of code A.  On Unix, you would *not* pass :file:`A.a` to "
"the linker for :file:`B.so` and :file:`C.so`; that would cause it to be "
"included twice, so that B and C would each have their own copy.  In Windows, "
"building :file:`A.dll` will also build :file:`A.lib`.  You *do* pass :file:"
"`A.lib` to the linker for B and C.  :file:`A.lib` does not contain code; it "
"just contains information which will be used at runtime to access A's code."
msgstr ""
"Suponga que está creando dos módulos de carga dinámica, B y C, que deberían "
"compartir otro bloque de código A. En Unix, *no* pasaría :file:`A.a` al "
"enlazador para :file:`B.so` y :file:`C.so`; eso haría que se incluyera dos "
"veces, de modo que B y C tengan cada uno su propia copia. En Windows, "
"compilar :file:`A.dll` también compilará :file:`A.lib`. Usted *si* pasa :"
"file:`A.lib` al enlazador para B y C. :file:`A.lib` no contiene código; solo "
"contiene información que se usará en tiempo de ejecución para acceder al "
"código de A."

#: ../Doc/extending/windows.rst:94
msgid ""
"In Windows, using an import library is sort of like using ``import spam``; "
"it gives you access to spam's names, but does not create a separate copy.  "
"On Unix, linking with a library is more like ``from spam import *``; it does "
"create a separate copy."
msgstr ""
"En Windows, usar una biblioteca de importación es como usar ``importar "
"spam``; le da acceso a los nombres de spam, pero no crea una copia separada. "
"En Unix, vincular con una biblioteca es más como ``from spam import*``; crea "
"una copia separada."

#: ../Doc/extending/windows.rst:103
msgid "Using DLLs in Practice"
msgstr "Usar DLL en la práctica"

#: ../Doc/extending/windows.rst:108
#, fuzzy
msgid ""
"Windows Python is built in Microsoft Visual C++; using other compilers may "
"or may not work.  The rest of this section is MSVC++ specific."
msgstr ""
"Windows Python está construido en Microsoft Visual C++; el uso de otros "
"compiladores puede o no funcionar (aunque Borland parece funcionar). El "
"resto de esta sección es específica de MSVC++."

#: ../Doc/extending/windows.rst:111
msgid ""
"When creating DLLs in Windows, you must pass :file:`pythonXY.lib` to the "
"linker. To build two DLLs, spam and ni (which uses C functions found in "
"spam), you could use these commands::"
msgstr ""
"Al crear archivos DLL en Windows, debe pasar :file:`pythonXY.lib` al "
"enlazador. Para construir dos DLL, spam y ni (que usa funciones C que se "
"encuentran en el spam), puede usar estos comandos::"

#: ../Doc/extending/windows.rst:118
msgid ""
"The first command created three files: :file:`spam.obj`, :file:`spam.dll` "
"and :file:`spam.lib`.  :file:`Spam.dll` does not contain any Python "
"functions (such as :c:func:`PyArg_ParseTuple`), but it does know how to find "
"the Python code thanks to :file:`pythonXY.lib`."
msgstr ""
"El primer comando creó tres archivos: :file:`spam.obj`, :file:`spam.dll` y :"
"file:`spam.lib`. :file:`Spam.dll` no contiene ninguna función de Python "
"(como :c:func:`PyArg_ParseTuple`), pero sabe cómo encontrar el código de "
"Python gracias a :file:`pythonXY.lib`."

#: ../Doc/extending/windows.rst:123
msgid ""
"The second command created :file:`ni.dll` (and :file:`.obj` and :file:`."
"lib`), which knows how to find the necessary functions from spam, and also "
"from the Python executable."
msgstr ""
"El segundo comando creó :file:`ni.dll` (y :file:`.obj` y :file:`.lib`), que "
"sabe cómo encontrar las funciones necesarias del spam, y también del "
"ejecutable de Python."

#: ../Doc/extending/windows.rst:127
msgid ""
"Not every identifier is exported to the lookup table.  If you want any other "
"modules (including Python) to be able to see your identifiers, you have to "
"say ``_declspec(dllexport)``, as in ``void _declspec(dllexport) "
"initspam(void)`` or ``PyObject _declspec(dllexport) *NiGetSpamData(void)``."
msgstr ""
"No todos los identificadores se exportan a la tabla de búsqueda. Si desea "
"que cualquier otro módulo (incluido Python) pueda ver sus identificadores, "
"debe decir ``_declspec(dllexport)``, como en ``void _declspec(dllexport) "
"initspam(void)`` o ``PyObject_declspec(dllexport) *NiGetSpamData(void)``."

#: ../Doc/extending/windows.rst:132
#, fuzzy
msgid ""
"Developer Studio will throw in a lot of import libraries that you do not "
"really need, adding about 100K to your executable.  To get rid of them, use "
"the Project Settings dialog, Link tab, to specify *ignore default "
"libraries*.  Add the correct :file:`msvcrt{xx}.lib` to the list of libraries."
msgstr ""
"Developer Studio incluirá muchas bibliotecas de importación que realmente no "
"necesita, agregando aproximadamente 100K a su ejecutable. Para deshacerse de "
"ellos, use el cuadro de diálogo Configuración del proyecto, pestaña Enlace, "
"para especificar *ignorar las bibliotecas predeterminadas*. Agregue el "
"archivo correcto :file:`msvcrtxx.lib` a la lista de bibliotecas."
