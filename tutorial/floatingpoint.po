# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2019, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-06 11:59-0400\n"
"PO-Revision-Date: 2020-03-12 16:54+0100\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: Adrian Santos <martinezsantosadrian@gmail.com>\n"
"Language-Team: \n"
"Language: es_ES\n"
"X-Generator: Poedit 2.3\n"

#: ../Doc/tutorial/floatingpoint.rst:9
msgid "Floating Point Arithmetic:  Issues and Limitations"
msgstr "Aritmética de Punto Flotante: Problemas y Limitaciones"

#: ../Doc/tutorial/floatingpoint.rst:14
msgid ""
"Floating-point numbers are represented in computer hardware as base 2 "
"(binary) fractions.  For example, the decimal fraction ::"
msgstr ""
"Los números de punto flotante se representan en el hardware del equipo como "
"fracciones base 2 (binarias).  Por ejemplo, la fracción decimal ::"

#: ../Doc/tutorial/floatingpoint.rst:19
msgid ""
"has value 1/10 + 2/100 + 5/1000, and in the same way the binary fraction ::"
msgstr ""
"tiene valor 1/10 + 2/100 + 5/1000, y de la misma manera la fracción "
"binaria ::"

#: ../Doc/tutorial/floatingpoint.rst:23
msgid ""
"has value 0/2 + 0/4 + 1/8.  These two fractions have identical values, the "
"only real difference being that the first is written in base 10 fractional "
"notation, and the second in base 2."
msgstr ""
"tiene el valor 0/2 + 0/4 + 1/8.  Estas dos fracciones tienen valores "
"idénticos, la única diferencia real es que la primera está escrita en "
"notación fraccionaria base 10, y la segunda en la base 2."

#: ../Doc/tutorial/floatingpoint.rst:27
msgid ""
"Unfortunately, most decimal fractions cannot be represented exactly as "
"binary fractions.  A consequence is that, in general, the decimal floating-"
"point numbers you enter are only approximated by the binary floating-point "
"numbers actually stored in the machine."
msgstr ""
"Desafortunadamente, la mayoría de las fracciones decimales no se pueden "
"representar exactamente como fracciones binarias.  Una consecuencia es que, "
"en general, los números decimales de punto flotante que introduzca sólo se "
"aproximan por los números binarios de punto flotante realmente almacenados "
"en la máquina."

#: ../Doc/tutorial/floatingpoint.rst:32
msgid ""
"The problem is easier to understand at first in base 10.  Consider the "
"fraction 1/3.  You can approximate that as a base 10 fraction::"
msgstr ""
"El problema es más fácil de entender al principio en la base 10.  Considere "
"la fracción 1/3.  Puede aproximar eso como una fracción base 10::"

#: ../Doc/tutorial/floatingpoint.rst:37 ../Doc/tutorial/floatingpoint.rst:41
msgid "or, better, ::"
msgstr "o, mejor, ::"

#: ../Doc/tutorial/floatingpoint.rst:45
msgid ""
"and so on.  No matter how many digits you're willing to write down, the "
"result will never be exactly 1/3, but will be an increasingly better "
"approximation of 1/3."
msgstr ""
"y así sucesivamente.  No importa cuántos dígitos estés dispuesto a escribir, "
"el resultado nunca será exactamente 1/3, pero será una aproximación cada vez "
"mejor de 1/3."

#: ../Doc/tutorial/floatingpoint.rst:49
msgid ""
"In the same way, no matter how many base 2 digits you're willing to use, the "
"decimal value 0.1 cannot be represented exactly as a base 2 fraction.  In "
"base 2, 1/10 is the infinitely repeating fraction ::"
msgstr ""
"De la misma manera, no importa cuántos dígitos base 2 esté dispuesto a usar, "
"el valor decimal 0.1 no se puede representar exactamente como una fracción "
"base 2.  En la base 2, 1/10 es la fracción infinitamente repetitiva ::"

#: ../Doc/tutorial/floatingpoint.rst:55
msgid ""
"Stop at any finite number of bits, and you get an approximation.  On most "
"machines today, floats are approximated using a binary fraction with the "
"numerator using the first 53 bits starting with the most significant bit and "
"with the denominator as a power of two.  In the case of 1/10, the binary "
"fraction is ``3602879701896397 / 2 ** 55`` which is close to but not exactly "
"equal to the true value of 1/10."
msgstr ""
"Deténgase en cualquier número finito de bits, y obtendrá una aproximación.  "
"En la mayoría de las máquinas hoy en día, los flotadores se aproximan usando "
"una fracción binaria con el numerador usando los primeros 53 bits comenzando "
"con el bit más significativo y con el denominador como potencia de dos.  En "
"el caso de 1/10, la fracción binaria es ``3602879701896397 / 2 ** 55`` que "
"es casi pero no exactamente igual al valor verdadero de 1/10."

#: ../Doc/tutorial/floatingpoint.rst:62
msgid ""
"Many users are not aware of the approximation because of the way values are "
"displayed.  Python only prints a decimal approximation to the true decimal "
"value of the binary approximation stored by the machine.  On most machines, "
"if Python were to print the true decimal value of the binary approximation "
"stored for 0.1, it would have to display ::"
msgstr ""
"Muchos usuarios no son conscientes de la aproximación debido a la forma en "
"que se muestran los valores.  Python solo imprime una aproximación decimal "
"al valor decimal verdadero de la aproximación binaria almacenada por la "
"máquina.  En la mayoría de las máquinas, si Python imprimirá el valor "
"decimal verdadero de la aproximación binaria almacenada para 0.1, tendría "
"que mostrar ::"

#: ../Doc/tutorial/floatingpoint.rst:71
msgid ""
"That is more digits than most people find useful, so Python keeps the number "
"of digits manageable by displaying a rounded value instead ::"
msgstr ""
"Eso es más dígitos de lo que la mayoría de la gente encuentra útil, por lo "
"que Python mantiene el número de dígitos manejable mostrando un valor "
"redondeado en su lugar ::"

#: ../Doc/tutorial/floatingpoint.rst:77
msgid ""
"Just remember, even though the printed result looks like the exact value of "
"1/10, the actual stored value is the nearest representable binary fraction."
msgstr ""
"Recuerde que, aunque el resultado impreso parezca el valor exacto de 1/10, "
"el valor almacenado real es la fracción binaria representada más cercana."

#: ../Doc/tutorial/floatingpoint.rst:80
msgid ""
"Interestingly, there are many different decimal numbers that share the same "
"nearest approximate binary fraction.  For example, the numbers ``0.1`` and "
"``0.10000000000000001`` and "
"``0.1000000000000000055511151231257827021181583404541015625`` are all "
"approximated by ``3602879701896397 / 2 ** 55``.  Since all of these decimal "
"values share the same approximation, any one of them could be displayed "
"while still preserving the invariant ``eval(repr(x)) == x``."
msgstr ""
"Curiosamente, hay muchos números decimales diferentes que comparten la misma "
"fracción binaria aproximada más cercana.  Por ejemplo, los números ``0.1`` y "
"``0.100000000000000001`` y "
"``0.10000000000000055511151231257827021181583404541015625`` son aproximados "
"por ``3602879701896397 / 2 ** 55``.  Puesto que todos estos valores "
"decimales comparten la misma aproximación, cualquiera de ellos podría "
"mostrarse sin dejar de conservar el invariante ``eval(repr(x)) == x``."

#: ../Doc/tutorial/floatingpoint.rst:88
msgid ""
"Historically, the Python prompt and built-in :func:`repr` function would "
"choose the one with 17 significant digits, ``0.10000000000000001``.   "
"Starting with Python 3.1, Python (on most systems) is now able to choose the "
"shortest of these and simply display ``0.1``."
msgstr ""
"Históricamente, el símbolo del sistema de Python y la función integrada :"
"func:`repr` elegirían la que tiene 17 dígitos significativos, "
"``0.10000000000000001``.   A partir de Python 3.1, Python (en la mayoría de "
"los sistemas) ahora es capaz de elegir el más corto de estos y simplemente "
"mostrar ``0.1``."

#: ../Doc/tutorial/floatingpoint.rst:93
msgid ""
"Note that this is in the very nature of binary floating-point: this is not a "
"bug in Python, and it is not a bug in your code either.  You'll see the same "
"kind of thing in all languages that support your hardware's floating-point "
"arithmetic (although some languages may not *display* the difference by "
"default, or in all output modes)."
msgstr ""
"Tenga en cuenta que esto está en la naturaleza misma de punto flotante "
"binario: esto no es un error en Python, y tampoco es un error en el código.  "
"Verá el mismo tipo de cosa en todos los idiomas que admiten la aritmética de "
"punto flotante de su hardware (aunque algunos idiomas pueden no *mostrar* la "
"diferencia de forma predeterminada, o en todos los modos de salida)."

#: ../Doc/tutorial/floatingpoint.rst:99
msgid ""
"For more pleasant output, you may wish to use string formatting to produce a "
"limited number of significant digits::"
msgstr ""
"Para una salida más agradable, es posible que desee utilizar el formato de "
"cadena para producir un número limitado de dígitos significativos::"

#: ../Doc/tutorial/floatingpoint.rst:111
msgid ""
"It's important to realize that this is, in a real sense, an illusion: you're "
"simply rounding the *display* of the true machine value."
msgstr ""
"Es importante darse cuenta de que esto es, en un sentido real, una ilusión: "
"simplemente está redondeando la *pantalla* del verdadero valor de la máquina."

#: ../Doc/tutorial/floatingpoint.rst:114
msgid ""
"One illusion may beget another.  For example, since 0.1 is not exactly 1/10, "
"summing three values of 0.1 may not yield exactly 0.3, either::"
msgstr ""
"Una ilusión puede envolver a otra.  Por ejemplo, puesto que 0.1 no es "
"exactamente 1/10, sumar tres valores de 0.1 puede no producir exactamente "
"0.3, cualquiera de los dos::"

#: ../Doc/tutorial/floatingpoint.rst:120
msgid ""
"Also, since the 0.1 cannot get any closer to the exact value of 1/10 and 0.3 "
"cannot get any closer to the exact value of 3/10, then pre-rounding with :"
"func:`round` function cannot help::"
msgstr ""
"Además, dado que el 0.1 no puede acercarse más al valor exacto de 1/10 y 0.3 "
"no puede acercarse más al valor exacto de 3/10, entonces el redondeamiento "
"previo con la función :func:`round` no puede ayudar::"

#: ../Doc/tutorial/floatingpoint.rst:127
msgid ""
"Though the numbers cannot be made closer to their intended exact values, "
"the :func:`round` function can be useful for post-rounding so that results "
"with inexact values become comparable to one another::"
msgstr ""
"Aunque los números no se pueden acercar a sus valores exactos previstos, la "
"función :func:`round` puede ser útil para el redondeo posterior para que los "
"resultados con valores inexactos se vuelvan comparables entre sí::"

#: ../Doc/tutorial/floatingpoint.rst:134
msgid ""
"Binary floating-point arithmetic holds many surprises like this.  The "
"problem with \"0.1\" is explained in precise detail below, in the "
"\"Representation Error\" section.  See `The Perils of Floating Point <http://"
"www.lahey.com/float.htm>`_ for a more complete account of other common "
"surprises."
msgstr ""
"La aritmética de punto flotante binario contiene muchas sorpresas como "
"esta.  El problema con \"0.1\" se explica con detalle a continuación, en la "
"sección \"Error de representación\".  Consulte `Los peligros del punto "
"flotante <http://www.lahey.com/float.htm>`_ para obtener una explicación más "
"completa de otras sorpresas comunes."

#: ../Doc/tutorial/floatingpoint.rst:139
msgid ""
"As that says near the end, \"there are no easy answers.\"  Still, don't be "
"unduly wary of floating-point!  The errors in Python float operations are "
"inherited from the floating-point hardware, and on most machines are on the "
"order of no more than 1 part in 2\\*\\*53 per operation.  That's more than "
"adequate for most tasks, but you do need to keep in mind that it's not "
"decimal arithmetic and that every float operation can suffer a new rounding "
"error."
msgstr ""
"Como dice eso cerca del final, \"no hay respuestas fáciles\".  ¡Aún así, no "
"desconfíe indebidamente del punto flotante!  Los errores en las operaciones "
"flotantes de Python se heredan del hardware de punto flotante y en la "
"mayoría de las máquinas están en el orden de no más de 1 parte en 2 * * 53 "
"por operación.  Eso es más que adecuado para la mayoría de las tareas, pero "
"debe tener en cuenta que no es aritmética decimal y que cada operación "
"flotante puede sufrir un nuevo error de redondeo."

#: ../Doc/tutorial/floatingpoint.rst:146
msgid ""
"While pathological cases do exist, for most casual use of floating-point "
"arithmetic you'll see the result you expect in the end if you simply round "
"the display of your final results to the number of decimal digits you "
"expect. :func:`str` usually suffices, and for finer control see the :meth:"
"`str.format` method's format specifiers in :ref:`formatstrings`."
msgstr ""
"Aunque existen casos patológicos, para el uso más casual de la aritmética de "
"punto flotante verá el resultado que espera al final si simplemente redondea "
"la visualización de los resultados finales al número de dígitos decimales "
"que espera. :func:`str` por lo general es suficiente, y para un control más "
"preciso ver los especificadores de formato del método :meth:'str.format' en :"
"ref:`formatstrings`."

#: ../Doc/tutorial/floatingpoint.rst:152
msgid ""
"For use cases which require exact decimal representation, try using the :mod:"
"`decimal` module which implements decimal arithmetic suitable for accounting "
"applications and high-precision applications."
msgstr ""
"Para los casos de uso que requieren una representación decimal exacta, "
"intente utilizar el módulo :mod:`decimal` que implementa la aritmética "
"decimal adecuada para aplicaciones de contabilidad y aplicaciones de alta "
"precisión."

#: ../Doc/tutorial/floatingpoint.rst:156
msgid ""
"Another form of exact arithmetic is supported by the :mod:`fractions` module "
"which implements arithmetic based on rational numbers (so the numbers like "
"1/3 can be represented exactly)."
msgstr ""
"Otra forma de aritmética exacta es apoyada por el módulo :mod:`fractions` "
"que implementa la aritmética basada en números racionales (por lo que los "
"números como 1/3 se pueden representar exactamente)."

#: ../Doc/tutorial/floatingpoint.rst:160
msgid ""
"If you are a heavy user of floating point operations you should take a look "
"at the Numerical Python package and many other packages for mathematical and "
"statistical operations supplied by the SciPy project. See <https://scipy."
"org>."
msgstr ""
"Si usted es un usuario pesado de operaciones de punto flotante debe echar un "
"vistazo al paquete Numerical Python y muchos otros paquetes para las "
"operaciones matemáticas y estadísticas proporcionadas por el proyecto SciPy. "
"Ve a <https://scipy.org>."

#: ../Doc/tutorial/floatingpoint.rst:164
msgid ""
"Python provides tools that may help on those rare occasions when you really "
"*do* want to know the exact value of a float.  The :meth:`float."
"as_integer_ratio` method expresses the value of a float as a fraction::"
msgstr ""
"Python proporciona herramientas que pueden ayudar en esas raras ocasiones en "
"las que realmente *do* quiere saber el valor exacto de un float.  El método :"
"meth:`float.as_integer_ratio` expresa el valor de un float como una "
"fracción::"

#: ../Doc/tutorial/floatingpoint.rst:173
msgid ""
"Since the ratio is exact, it can be used to losslessly recreate the original "
"value::"
msgstr ""
"Dado que la relación es exacta, se puede utilizar para recrear sin pérdidas "
"el valor original::"

#: ../Doc/tutorial/floatingpoint.rst:179
msgid ""
"The :meth:`float.hex` method expresses a float in hexadecimal (base 16), "
"again giving the exact value stored by your computer::"
msgstr ""
"El método :meth:`float.hex` expresa un float en hexadecimal (base 16), dando "
"de nuevo el valor exacto almacenado por su ordenador::"

#: ../Doc/tutorial/floatingpoint.rst:185
msgid ""
"This precise hexadecimal representation can be used to reconstruct the float "
"value exactly::"
msgstr ""
"Esta representación hexadecimal precisa se puede utilizar para reconstruir "
"el valor float exactamente::"

#: ../Doc/tutorial/floatingpoint.rst:191
msgid ""
"Since the representation is exact, it is useful for reliably porting values "
"across different versions of Python (platform independence) and exchanging "
"data with other languages that support the same format (such as Java and "
"C99)."
msgstr ""
"Dado que la representación es exacta, es útil para migrar valores de forma "
"fiable a través de diferentes versiones de Python (independiente de la "
"plataforma) e intercambiar datos con otros lenguajes que admiten el mismo "
"formato (como Java y C99)."

#: ../Doc/tutorial/floatingpoint.rst:195
msgid ""
"Another helpful tool is the :func:`math.fsum` function which helps mitigate "
"loss-of-precision during summation.  It tracks \"lost digits\" as values are "
"added onto a running total.  That can make a difference in overall accuracy "
"so that the errors do not accumulate to the point where they affect the "
"final total:"
msgstr ""
"Otra herramienta útil es la función :func:`math.fsum` que ayuda a mitigar la "
"pérdida de precisión durante la suma.  Realiza un seguimiento de los "
"\"dígitos perdidos\" a medida que los valores se agregan a un total en "
"ejecución.  Esto puede marcar una diferencia en la precisión general para "
"que los errores no se acumulen hasta el punto en que afectan al total final:"

#: ../Doc/tutorial/floatingpoint.rst:209
msgid "Representation Error"
msgstr "Error de Representación"

#: ../Doc/tutorial/floatingpoint.rst:211
msgid ""
"This section explains the \"0.1\" example in detail, and shows how you can "
"perform an exact analysis of cases like this yourself.  Basic familiarity "
"with binary floating-point representation is assumed."
msgstr ""
"En esta sección se explica en detalle el ejemplo \"0.1\" y se muestra cómo "
"puede realizar un análisis exacto de casos como este usted mismo.  Se asume "
"la familiaridad básica con la representación de punto flotante binario."

#: ../Doc/tutorial/floatingpoint.rst:215
msgid ""
":dfn:`Representation error` refers to the fact that some (most, actually) "
"decimal fractions cannot be represented exactly as binary (base 2) "
"fractions. This is the chief reason why Python (or Perl, C, C++, Java, "
"Fortran, and many others) often won't display the exact decimal number you "
"expect."
msgstr ""
":dfn:`Representation error' se refiere al hecho de que algunas fracciones "
"decimales (la mayoría, en realidad) no se pueden representar exactamente "
"como fracciones binarias (base 2). Esta es la razón principal por la que "
"Python (o Perl, C, C++, Java, Fortran y muchos otros) a menudo no mostrará "
"el número decimal exacto que espera."

#: ../Doc/tutorial/floatingpoint.rst:220
msgid ""
"Why is that?  1/10 is not exactly representable as a binary fraction. Almost "
"all machines today (November 2000) use IEEE-754 floating point arithmetic, "
"and almost all platforms map Python floats to IEEE-754 \"double precision"
"\".  754 doubles contain 53 bits of precision, so on input the computer "
"strives to convert 0.1 to the closest fraction it can of the form *J*/2**\\ "
"*N* where *J* is an integer containing exactly 53 bits.  Rewriting ::"
msgstr ""
"¿Por qué?  1/10 no es exactamente representable como una fracción binaria. "
"Casi todas las máquinas hoy en día (noviembre de 2000) utilizan aritmética "
"de punto flotante IEEE-754, y casi todas las plataformas asignan flotadores "
"de Python a IEEE-754 de \"doble precisión\".  754 dobles contienen 53 bits "
"de precisión, por lo que en la entrada el equipo se esfuerza por convertir "
"0.1 a la fracción más cercana que puede de la forma *J*/2** *N* donde *J* es "
"un entero que contiene exactamente 53 bits.  Reescritura ::"

#: ../Doc/tutorial/floatingpoint.rst:229
msgid "as ::"
msgstr "como ::"

#: ../Doc/tutorial/floatingpoint.rst:233
msgid ""
"and recalling that *J* has exactly 53 bits (is ``>= 2**52`` but ``< "
"2**53``), the best value for *N* is 56::"
msgstr ""
"y recordando que *J* tiene exactamente 53 bits (es ``> 2**52'' pero ``< "
"2**53``), el mejor valor para *N* es 56::"

#: ../Doc/tutorial/floatingpoint.rst:239
msgid ""
"That is, 56 is the only value for *N* that leaves *J* with exactly 53 bits.  "
"The best possible value for *J* is then that quotient rounded::"
msgstr ""
"Es decir, 56 es el único valor para *N* que deja *J* con exactamente 53 "
"bits.  El mejor valor posible para *J* es entonces que el cociente "
"redondeado::"

#: ../Doc/tutorial/floatingpoint.rst:246
msgid ""
"Since the remainder is more than half of 10, the best approximation is "
"obtained by rounding up::"
msgstr ""
"Dado que el resto es más de la mitad de 10, la mejor aproximación se obtiene "
"redondeando::"

#: ../Doc/tutorial/floatingpoint.rst:252
msgid ""
"Therefore the best possible approximation to 1/10 in 754 double precision "
"is::"
msgstr ""
"Por lo tanto, la mejor aproximación posible a 1/10 en 754 doble precisión "
"es::"

#: ../Doc/tutorial/floatingpoint.rst:256
msgid ""
"Dividing both the numerator and denominator by two reduces the fraction to::"
msgstr ""
"La división del numerador y el denominador por dos reduce la fracción a::"

#: ../Doc/tutorial/floatingpoint.rst:260
msgid ""
"Note that since we rounded up, this is actually a little bit larger than "
"1/10; if we had not rounded up, the quotient would have been a little bit "
"smaller than 1/10.  But in no case can it be *exactly* 1/10!"
msgstr ""
"Tenga en cuenta que, dado que redondeamos, esto es en realidad un poco más "
"grande que 1/10; si no hubiéramos redondeado, el cociente habría sido un "
"poco más pequeño que 1/10.  Pero en ningún caso puede ser *exactamente * "
"1/10!"

#: ../Doc/tutorial/floatingpoint.rst:264
msgid ""
"So the computer never \"sees\" 1/10:  what it sees is the exact fraction "
"given above, the best 754 double approximation it can get::"
msgstr ""
"Así que el ordenador nunca \"ve\" 1/10: lo que ve es la fracción exacta dada "
"anteriormente, la mejor aproximación doble 754 que puede obtener::"

#: ../Doc/tutorial/floatingpoint.rst:270
msgid ""
"If we multiply that fraction by 10\\*\\*55, we can see the value out to 55 "
"decimal digits::"
msgstr ""
"Si multiplicamos esa fracción por 10\\*\\*55, podemos ver el valor a 55 "
"dígitos decimales:"

#: ../Doc/tutorial/floatingpoint.rst:276
msgid ""
"meaning that the exact number stored in the computer is equal to the decimal "
"value 0.1000000000000000055511151231257827021181583404541015625. Instead of "
"displaying the full decimal value, many languages (including older versions "
"of Python), round the result to 17 significant digits::"
msgstr ""
"lo que significa que el número exacto almacenado en el equipo es igual al "
"valor decimal 0.1000000000000000055511151231257827021181583404541015625. En "
"lugar de mostrar el valor decimal completo, muchos idiomas (incluidas las "
"versiones anteriores de Python), redondean el resultado a 17 dígitos "
"significativos::"

#: ../Doc/tutorial/floatingpoint.rst:284
msgid ""
"The :mod:`fractions` and :mod:`decimal` modules make these calculations "
"easy::"
msgstr ""
"Los módulos :mod:`fractions` y :mod:`decimal` facilitan estos cálculos::"
