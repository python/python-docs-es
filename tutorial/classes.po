# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-06 15:59+0200\n"
"PO-Revision-Date: 2020-05-09 13:38+0200\n"
"Last-Translator: Marco Richetta <marcorichetta@gmail.com>\n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"X-Generator: Poedit 2.3\n"

#: ../Doc/tutorial/classes.rst:5
msgid "Classes"
msgstr "Clases"

#: ../Doc/tutorial/classes.rst:7
msgid ""
"Classes provide a means of bundling data and functionality together.  "
"Creating a new class creates a new *type* of object, allowing new "
"*instances* of that type to be made.  Each class instance can have "
"attributes attached to it for maintaining its state.  Class instances can "
"also have methods (defined by its class) for modifying its state."
msgstr ""
"Las clases proveen una forma de empaquetar datos y funcionalidad juntos. Al "
"crear una nueva clase, se crea un nuevo *tipo* de objeto, permitiendo crear "
"nuevas *instancias* de ese tipo. Cada instancia de clase puede tener "
"atributos adjuntos para mantener su estado. Las instancias de clase también "
"pueden tener métodos (definidos por su clase) para modificar su estado."

#: ../Doc/tutorial/classes.rst:13
msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"Comparado con otros lenguajes de programación, el mecanismo de clases de "
"Python agrega clases con un mínimo de nuevas sintaxis y semánticas.  Es una "
"mezcla de los mecanismos de clases encontrados en C++ y Modula-3.  Las "
"clases de Python proveen todas las características normales de la "
"Programación Orientada a Objetos: el mecanismo de la herencia de clases "
"permite múltiples clases base, una clase derivada puede sobre escribir "
"cualquier método de su(s) clase(s) base, y un método puede llamar al método "
"de la clase base con el mismo nombre.  Los objetos pueden tener una cantidad "
"arbitraria de datos de cualquier tipo.  Igual que con los módulos, las "
"clases participan de la naturaleza dinámica de Python: se crean en tiempo de "
"ejecución, y pueden modificarse luego de la creación."

#: ../Doc/tutorial/classes.rst:23
msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are "
"*virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"En terminología de C++, normalmente los miembros de las clases (incluyendo "
"los miembros de datos), son *públicos* (excepto ver abajo :ref:`tut-"
"private`), y todas las funciones miembro son *virtuales*.  Como en Modula-3, "
"no hay atajos para hacer referencia a los miembros del objeto desde sus "
"métodos: la función método se declara con un primer argumento explícito que "
"representa al objeto, el cual se provee implícitamente por la llamada.  Como "
"en Smalltalk, las clases mismas son objetos.  Esto provee una semántica para "
"importar y renombrar.  A diferencia de C++ y Modula-3, los tipos de datos "
"integrados pueden usarse como clases base para que el usuario los extienda.  "
"También, como en C++ pero a diferencia de Modula-3, la mayoría de los "
"operadores integrados con sintaxis especial (operadores aritméticos, de sub-"
"índice, etc.) pueden volver a ser definidos por instancias de la clase."

#: ../Doc/tutorial/classes.rst:34
msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make "
"occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"(Sin haber una terminología universalmente aceptada sobre clases, haré uso "
"ocasional de términos de Smalltalk y C++.  Usaría términos de Modula-3, ya "
"que su semántica orientada a objetos es más cercana a Python que C++, pero "
"no espero que muchos lectores hayan escuchado hablar de él.)"

#: ../Doc/tutorial/classes.rst:43
msgid "A Word About Names and Objects"
msgstr "Unas palabras sobre nombres y objetos"

#: ../Doc/tutorial/classes.rst:45
msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"Los objetos tienen individualidad, y múltiples nombres (en muchos ámbitos) "
"pueden vincularse al mismo objeto.  Esto se conoce como *aliasing* en otros "
"lenguajes.  Normalmente no se aprecia esto a primera vista en Python, y "
"puede ignorarse sin problemas cuando se maneja tipos básicos inmutables "
"(números, cadenas, tuplas).  Sin embargo, el *aliasing*, o renombrado,  "
"tiene un efecto posiblemente sorpresivo sobre la semántica de código Python "
"que involucra objetos mutables como listas, diccionarios, y la mayoría de "
"otros tipos.  Esto se usa normalmente para beneficio del programa, ya que "
"los renombres funcionan como punteros en algunos aspectos.  Por ejemplo, "
"pasar un objeto es barato ya que la implementación solamente pasa el "
"puntero; y si una función modifica el objeto que fue pasado, el que la llama "
"verá el cambio; esto elimina la necesidad de tener dos formas diferentes de "
"pasar argumentos, como en Pascal."

#: ../Doc/tutorial/classes.rst:61
msgid "Python Scopes and Namespaces"
msgstr "Ámbitos y espacios de nombres en Python"

#: ../Doc/tutorial/classes.rst:63
msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"Antes de ver clases, primero debo decirte algo acerca de las reglas de "
"ámbito de Python.  Las definiciones de clases hacen unos lindos trucos con "
"los espacios de nombres, y necesitás saber cómo funcionan los alcances y "
"espacios de nombres para entender por completo cómo es la cosa.  De paso, "
"los conocimientos en este tema son útiles para cualquier programador Python "
"avanzado."

#: ../Doc/tutorial/classes.rst:69
msgid "Let's begin with some definitions."
msgstr "Comencemos con unas definiciones."

#: ../Doc/tutorial/classes.rst:71
msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense "
"the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"Un *espacio de nombres* es una relación de nombres a objetos.  Muchos "
"espacios de nombres están implementados en este momento como diccionarios de "
"Python, pero eso no se nota para nada (excepto por el desempeño), y puede "
"cambiar en el futuro.  Como ejemplos de espacios de nombres tenés: el "
"conjunto de nombres incluidos (conteniendo funciones como :func:`abs`, y los "
"nombres de excepciones integradas); los nombres globales en un módulo; y los "
"nombres locales en la invocación a una función.  Lo que es importante saber "
"de los espacios de nombres es que no hay relación en absoluto entre los "
"nombres de espacios de nombres distintos; por ejemplo, dos módulos "
"diferentes pueden tener definidos los dos una función ``maximizar`` sin "
"confusión; los usuarios de los módulos deben usar el nombre del módulo como "
"prefijo."

#: ../Doc/tutorial/classes.rst:82
msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is "
"a module object and ``funcname`` is an attribute of it.  In this case there "
"happens to be a straightforward mapping between the module's attributes and "
"the global names defined in the module: they share the same namespace!  [#]_"
msgstr ""
"Por cierto, yo uso la palabra *atributo* para cualquier cosa después de un "
"punto; por ejemplo, en la expresión ``z.real``, ``real`` es un atributo del "
"objeto ``z``.  Estrictamente hablando, las referencias a nombres en módulos "
"son referencias a atributos: en la expresión ``modulo.funcion``, ``modulo`` "
"es un objeto módulo y ``funcion`` es un atributo de éste.  En este caso hay "
"una relación directa entre los atributos del módulo y los nombres globales "
"definidos en el módulo: ¡están compartiendo el mismo espacio de nombres! [#]_"

#: ../Doc/tutorial/classes.rst:90
msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`the_answer` from the object named by ``modname``."
msgstr ""
"Los atributos pueden ser de sólo lectura, o de escritura.  En el último caso "
"es posible la asignación a atributos.  Los atributos de módulo pueden "
"escribirse: ``modulo.la_respuesta = 42``.  Los atributos de escritura se "
"pueden borrar también con la declaración :keyword:`del`.  Por ejemplo, ``del "
"modulo.la_respuesta`` va a eliminar el atributo :attr:`la_respuesta` del "
"objeto con nombre ``modulo``."

#: ../Doc/tutorial/classes.rst:96
msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called :mod:"
"`__main__`, so they have their own global namespace.  (The built-in names "
"actually also live in a module; this is called :mod:`builtins`.)"
msgstr ""
"Los espacios de nombres se crean en diferentes momentos y con diferentes "
"tiempos de vida.  El espacio de nombres que contiene los nombres incluidos "
"se crea cuando se inicia el intérprete, y nunca se borra.  El espacio de "
"nombres global de un módulo se crea cuando se lee la definición de un "
"módulo; normalmente, los espacios de nombres de módulos también duran hasta "
"que el intérprete finaliza.  Las instrucciones ejecutadas en el nivel de "
"llamadas superior del intérprete, ya sea desde un script o interactivamente, "
"se consideran parte del módulo llamado :mod:`__main__`, por lo tanto tienen "
"su propio espacio de nombres global.  (Los nombres incluidos en realidad "
"también viven en un módulo; este se llama :mod:`builtins`.)"

#: ../Doc/tutorial/classes.rst:106
msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to "
"describe what actually happens.)  Of course, recursive invocations each have "
"their own local namespace."
msgstr ""
"El espacio de nombres local a una función se crea cuando la función es "
"llamada, y se elimina cuando la función retorna o lanza una excepción que no "
"se maneje dentro de la función.  (Podríamos decir que lo que pasa en "
"realidad es que ese espacio de nombres se \"olvida\".)  Por supuesto, las "
"llamadas recursivas tienen cada una su propio espacio de nombres local."

#: ../Doc/tutorial/classes.rst:112
msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified "
"reference to a name attempts to find the name in the namespace."
msgstr ""
"Un *ámbito* es una región textual de un programa en Python donde un espacio "
"de nombres es accesible directamente.  \"Accesible directamente\" significa "
"que una referencia sin calificar a un nombre intenta encontrar dicho nombre "
"dentro del espacio de nombres."

#: ../Doc/tutorial/classes.rst:116
msgid ""
"Although scopes are determined statically, they are used dynamically. At any "
"time during execution, there are at least three nested scopes whose "
"namespaces are directly accessible:"
msgstr ""
"Aunque los alcances se determinan estáticamente, se usan dinámicamente. En "
"cualquier momento durante la ejecución hay por lo menos cuatro alcances "
"anidados cuyos espacios de nombres son directamente accesibles:"

#: ../Doc/tutorial/classes.rst:120
msgid "the innermost scope, which is searched first, contains the local names"
msgstr ""
"el alcance más interno, que es inspeccionado primero, contiene los nombres "
"locales"

#: ../Doc/tutorial/classes.rst:121
msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contains non-local, but also non-global names"
msgstr ""
"los alcances de las funciones que encierran a la función actual, que son "
"inspeccionados a partir del alcance más cercano, contienen nombres no "
"locales, pero también no globales"

#: ../Doc/tutorial/classes.rst:123
msgid "the next-to-last scope contains the current module's global names"
msgstr "el penúltimo alcance contiene nombres globales del módulo actual"

#: ../Doc/tutorial/classes.rst:124
msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr ""
"el alcance más externo (el último inspeccionado) es el espacio de nombres "
"que contiene los nombres integrados"

#: ../Doc/tutorial/classes.rst:126
msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the middle scope containing the module's global names.  To "
"rebind variables found outside of the innermost scope, the :keyword:"
"`nonlocal` statement can be used; if not declared nonlocal, those variables "
"are read-only (an attempt to write to such a variable will simply create a "
"*new* local variable in the innermost scope, leaving the identically named "
"outer variable unchanged)."
msgstr ""
"Si un nombre se declara como global, entonces todas las referencias y "
"asignaciones al mismo van directo al ámbito intermedio que contiene los "
"nombres globales del módulo.  Para reasignar nombres encontrados afuera del "
"ámbito más interno, se puede usar la declaración :keyword:`nonlocal`; si no "
"se declara nonlocal, esas variables serán de sólo lectura (un intento de "
"escribir a esas variables simplemente crea una *nueva* variable local en el "
"ámbito interno, dejando intacta la variable externa del mismo nombre)."

#: ../Doc/tutorial/classes.rst:133
msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"Habitualmente, el ámbito local referencia los nombres locales de la función "
"actual.  Fuera de una función, el ámbito local referencia al mismo espacio "
"de nombres que el ámbito global: el espacio de nombres del módulo. Las "
"definiciones de clases crean un espacio de nombres más en el ámbito local."

#: ../Doc/tutorial/classes.rst:138
msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution, "
"at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"Es importante notar que los alcances se determinan textualmente: el ámbito "
"global de una función definida en un módulo es el espacio de nombres de ese "
"módulo, no importa desde dónde o con qué alias se llame a la función.  Por "
"otro lado, la búsqueda de nombres se hace dinámicamente, en tiempo de "
"ejecución; sin embargo, la definición del lenguaje está evolucionando a "
"hacer resolución de nombres estáticamente, en tiempo de \"compilación\", "
"¡así que no te confíes de la resolución de nombres dinámica! (De hecho, las "
"variables locales ya se determinan estáticamente.)"

#: ../Doc/tutorial/classes.rst:146
msgid ""
"A special quirk of Python is that -- if no :keyword:`global` or :keyword:"
"`nonlocal` statement is in effect -- assignments to names always go into the "
"innermost scope. Assignments do not copy data --- they just bind names to "
"objects.  The same is true for deletions: the statement ``del x`` removes "
"the binding of ``x`` from the namespace referenced by the local scope.  In "
"fact, all operations that introduce new names use the local scope: in "
"particular, :keyword:`import` statements and function definitions bind the "
"module or function name in the local scope."
msgstr ""
"Una peculiaridad especial de Python es que, si no hay una declaración :"
"keyword:`global` o :keyword:`nonlocal` en efecto, las asignaciones a nombres "
"siempre van al ámbito interno.  Las asignaciones no copian datos, solamente "
"asocian nombres a objetos.  Lo mismo cuando se borra: la declaración ``del "
"x`` quita la asociación de ``x`` del espacio de nombres referenciado por el "
"ámbito local.  De hecho, todas las operaciones que introducen nuevos nombres "
"usan el ámbito local: en particular, las instrucciones :keyword:`import` y "
"las definiciones de funciones asocian el módulo o nombre de la función al "
"espacio de nombres en el ámbito local."

#: ../Doc/tutorial/classes.rst:154
msgid ""
"The :keyword:`global` statement can be used to indicate that particular "
"variables live in the global scope and should be rebound there; the :keyword:"
"`nonlocal` statement indicates that particular variables live in an "
"enclosing scope and should be rebound there."
msgstr ""
"La declaración :keyword:`global` puede usarse para indicar que ciertas "
"variables viven en el ámbito global y deberían reasignarse allí; la "
"declaración :keyword:`nonlocal` indica que ciertas variables viven en un "
"ámbito encerrado y deberían reasignarse allí."

#: ../Doc/tutorial/classes.rst:162
msgid "Scopes and Namespaces Example"
msgstr "Ejemplo de ámbitos y espacios de nombre"

#: ../Doc/tutorial/classes.rst:164
msgid ""
"This is an example demonstrating how to reference the different scopes and "
"namespaces, and how :keyword:`global` and :keyword:`nonlocal` affect "
"variable binding::"
msgstr ""
"Este es un ejemplo que muestra como hacer referencia a distintos ámbitos y "
"espacios de nombres, y cómo las declaraciones :keyword:`global` y :keyword:"
"`nonlocal` afectan la asignación de variables::"

#: ../Doc/tutorial/classes.rst:191
msgid "The output of the example code is:"
msgstr "El resultado del código ejemplo es:"

#: ../Doc/tutorial/classes.rst:200
msgid ""
"Note how the *local* assignment (which is default) didn't change *scope_test*"
"\\'s binding of *spam*.  The :keyword:`nonlocal` assignment changed "
"*scope_test*\\'s binding of *spam*, and the :keyword:`global` assignment "
"changed the module-level binding."
msgstr ""
"Notá como la asignación *local* (que es el comportamiento normal) no cambió "
"la vinculación de *algo* de *prueba_ambitos*.  La asignación :keyword:"
"`nonlocal` cambió la vinculación de *algo* de *prueba_ambitos*, y la "
"asignación :keyword:`global` cambió la vinculación a nivel de módulo."

#: ../Doc/tutorial/classes.rst:205
msgid ""
"You can also see that there was no previous binding for *spam* before the :"
"keyword:`global` assignment."
msgstr ""
"También podés ver que no había vinculación para *algo* antes de la "
"asignación :keyword:`global`."

#: ../Doc/tutorial/classes.rst:212
msgid "A First Look at Classes"
msgstr "Un primer vistazo a las clases"

#: ../Doc/tutorial/classes.rst:214
msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr ""
"Las clases introducen un poquito de sintaxis nueva, tres nuevos tipos de "
"objetos y algo de semántica nueva."

#: ../Doc/tutorial/classes.rst:221
msgid "Class Definition Syntax"
msgstr "Sintaxis de definición de clases"

#: ../Doc/tutorial/classes.rst:223
msgid "The simplest form of class definition looks like this::"
msgstr "La forma más sencilla de definición de una clase se ve así::"

#: ../Doc/tutorial/classes.rst:232
msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"Las definiciones de clases, al igual que las definiciones de funciones "
"(instrucciones :keyword:`def`) deben ejecutarse antes de que tengan efecto "
"alguno.  (Es concebible poner una definición de clase dentro de una rama de "
"un :keyword:`if`, o dentro de una función.)"

#: ../Doc/tutorial/classes.rst:236
msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful "
"--- we'll come back to this later.  The function definitions inside a class "
"normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"En la práctica, las declaraciones dentro de una clase son definiciones de "
"funciones, pero otras declaraciones son permitidas, y a veces resultan "
"útiles; veremos esto más adelante.  Las definiciones de funciones dentro de "
"una clase normalmente tienen una lista de argumentos peculiar, dictada por "
"las convenciones de invocación de métodos; a esto también lo veremos más "
"adelante."

#: ../Doc/tutorial/classes.rst:242
msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new "
"function here."
msgstr ""
"Cuando se ingresa una definición de clase, se crea un nuevo espacio de "
"nombres, el cual se usa como ámbito local; por lo tanto, todas las "
"asignaciones a variables locales van a este nuevo espacio de nombres.  En "
"particular, las definiciones de funciones asocian el nombre de las funciones "
"nuevas allí."

#: ../Doc/tutorial/classes.rst:247
msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the "
"next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header (:class:"
"`ClassName` in the example)."
msgstr ""
"Cuando una definición de clase se finaliza normalmente se crea un *objeto "
"clase*.  Básicamente, este objeto envuelve los contenidos del espacio de "
"nombres creado por la definición de la clase; aprenderemos más acerca de los "
"objetos clase en la sección siguiente.  El ámbito local original (el que "
"tenía efecto justo antes de que ingrese la definición de la clase) es "
"restablecido, y el objeto clase se asocia allí al nombre que se le puso a la "
"clase en el encabezado de su definición (:class:`Clase` en el ejemplo)."

#: ../Doc/tutorial/classes.rst:259
msgid "Class Objects"
msgstr "Objetos clase"

#: ../Doc/tutorial/classes.rst:261
msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"Los objetos clase soportan dos tipos de operaciones: hacer referencia a "
"atributos e instanciación."

#: ../Doc/tutorial/classes.rst:264
msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names "
"that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"Para *hacer referencia a atributos* se usa la sintaxis estándar de todas las "
"referencias a atributos en Python: ``objeto.nombre``.  Los nombres de "
"atributo válidos son todos los nombres que estaban en el espacio de nombres "
"de la clase cuando ésta se creó.  Por lo tanto, si la definición de la clase "
"es así::"

#: ../Doc/tutorial/classes.rst:276
msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""
"...entonces ``MiClase.i`` y ``MiClase.f`` son referencias de atributos "
"válidas, que retornan un entero y un objeto función respectivamente.  Los "
"atributos de clase también pueden ser asignados, o sea que podés cambiar el "
"valor de ``MiClase.i`` mediante asignación.  :attr:`__doc__` también es un "
"atributo válido, que retorna la documentación asociada a la clase: ``"
"\"Simple clase de ejemplo\"``."

#: ../Doc/tutorial/classes.rst:282
msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class. "
"For example (assuming the above class)::"
msgstr ""
"La *instanciación* de clases usa la notación de funciones.  Hacé de cuenta "
"que el objeto de clase es una función sin parámetros que retorna una nueva "
"instancia de la clase.  Por ejemplo (para la clase de más arriba)::"

#: ../Doc/tutorial/classes.rst:288
msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr ""
"...crea una nueva *instancia* de la clase y asigna este objeto a la variable "
"local ``x``."

#: ../Doc/tutorial/classes.rst:291
msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named :"
"meth:`__init__`, like this::"
msgstr ""
"La operación de instanciación (\"llamar\" a un objeto clase) crea un objeto "
"vacío.  Muchas clases necesitan crear objetos con instancias en un estado "
"inicial particular.  Por lo tanto una clase puede definir un método especial "
"llamado :meth:`__init__`, de esta forma::"

#: ../Doc/tutorial/classes.rst:299
msgid ""
"When a class defines an :meth:`__init__` method, class instantiation "
"automatically invokes :meth:`__init__` for the newly-created class "
"instance.  So in this example, a new, initialized instance can be obtained "
"by::"
msgstr ""
"Cuando una clase define un método :meth:`__init__`, la instanciación de la "
"clase automáticamente invoca a :meth:`__init__` para la instancia recién "
"creada.  Entonces, en este ejemplo, una instancia nueva e inicializada se "
"puede obtener haciendo::"

#: ../Doc/tutorial/classes.rst:305
msgid ""
"Of course, the :meth:`__init__` method may have arguments for greater "
"flexibility.  In that case, arguments given to the class instantiation "
"operator are passed on to :meth:`__init__`.  For example, ::"
msgstr ""
"Por supuesto, el método :meth:`__init__` puede tener argumentos para mayor "
"flexibilidad.  En ese caso, los argumentos que se pasen al operador de "
"instanciación de la clase van a parar al método :meth:`__init__`.  Por "
"ejemplo, ::"

#: ../Doc/tutorial/classes.rst:322
msgid "Instance Objects"
msgstr "Objetos instancia"

#: ../Doc/tutorial/classes.rst:324
msgid ""
"Now what can we do with instance objects?  The only operations understood by "
"instance objects are attribute references.  There are two kinds of valid "
"attribute names: data attributes and methods."
msgstr ""
"Ahora, ¿Qué podemos hacer con los objetos instancia?  La única operación que "
"es entendida por los objetos instancia es la referencia de atributos.  Hay "
"dos tipos de nombres de atributos válidos, atributos de datos y métodos."

#: ../Doc/tutorial/classes.rst:328
msgid ""
"*data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""
"Los *atributos de datos* se corresponden con las \"variables de instancia\" "
"en Smalltalk, y con las \"variables miembro\" en C++.  Los atributos de "
"datos no necesitan ser declarados; tal como las variables locales son "
"creados la primera vez que se les asigna algo.  Por ejemplo, si ``x`` es la "
"instancia de :class:`MiClase` creada más arriba, el siguiente pedazo de "
"código va a imprimir el valor ``16``, sin dejar ningún rastro::"

#: ../Doc/tutorial/classes.rst:340
msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object.  (In Python, the term method is not "
"unique to class instances: other object types can have methods as well.  For "
"example, list objects have methods called append, insert, remove, sort, and "
"so on. However, in the following discussion, we'll use the term method "
"exclusively to mean methods of class instance objects, unless explicitly "
"stated otherwise.)"
msgstr ""
"El otro tipo de atributo de instancia es el *método*.  Un método es una "
"función que \"pertenece a\" un objeto.  En Python, el término método no está "
"limitado a instancias de clase: otros tipos de objetos pueden tener métodos "
"también.  Por ejemplo, los objetos lista tienen métodos llamados append, "
"insert, remove, sort, y así sucesivamente.  Pero, en la siguiente "
"explicación, usaremos el término método para referirnos exclusivamente a "
"métodos de objetos instancia de clase, a menos que se especifique "
"explícitamente lo contrario."

#: ../Doc/tutorial/classes.rst:349
msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"Los nombres válidos de métodos de un objeto instancia dependen de su clase. "
"Por definición, todos los atributos de clase que son objetos funciones "
"definen métodos correspondientes de sus instancias.  Entonces, en nuestro "
"ejemplo, ``x.f`` es una referencia a un método válido, dado que ``MiClase."
"f`` es una función, pero ``x.i`` no lo es, dado que ``MiClase.i`` no lo es.  "
"Pero ``x.f`` no es la misma cosa que ``MiClase.f``; es un *objeto método*, "
"no un objeto función."

#: ../Doc/tutorial/classes.rst:360
msgid "Method Objects"
msgstr "Objetos método"

#: ../Doc/tutorial/classes.rst:362
msgid "Usually, a method is called right after it is bound::"
msgstr "Generalmente, un método es llamado luego de ser vinculado::"

#: ../Doc/tutorial/classes.rst:366
msgid ""
"In the :class:`MyClass` example, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""
"En el ejemplo :class:`MiClase`, esto retorna la cadena ``'hola mundo'``. "
"Pero no es necesario llamar al método justo en ese momento: ``x.f`` es un "
"objeto método, y puede ser guardado y llamado más tarde.  Por ejemplo::"

#: ../Doc/tutorial/classes.rst:374
msgid "will continue to print ``hello world`` until the end of time."
msgstr "...continuará imprimiendo ``hola mundo`` hasta el fin de los días."

#: ../Doc/tutorial/classes.rst:376
msgid ""
"What exactly happens when a method is called?  You may have noticed that ``x."
"f()`` was called without an argument above, even though the function "
"definition for :meth:`f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an "
"argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""
"¿Qué sucede exactamente cuando un método es llamado?  Debés haber notado que "
"``x.f()`` fue llamado más arriba sin ningún argumento, a pesar de que la "
"definición de función de :meth:`f` especificaba un argumento.  ¿Qué pasó con "
"ese argumento?  Seguramente Python levanta una excepción cuando una función "
"que requiere un argumento es llamada sin ninguno, aún si el argumento no es "
"utilizado..."

#: ../Doc/tutorial/classes.rst:382
msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the instance object is passed as the first argument of the "
"function.  In our example, the call ``x.f()`` is exactly equivalent to "
"``MyClass.f(x)``.  In general, calling a method with a list of *n* arguments "
"is equivalent to calling the corresponding function with an argument list "
"that is created by inserting the method's instance object before the first "
"argument."
msgstr ""
"De hecho, tal vez hayas adivinado la respuesta: lo que tienen de especial "
"los métodos es que el objeto es pasado como el primer argumento de la "
"función. En nuestro ejemplo, la llamada ``x.f()`` es exactamente equivalente "
"a ``MiClase.f(x)``.  En general, llamar a un método con una lista de *n* "
"argumentos es equivalente a llamar a la función correspondiente con una "
"lista de argumentos que es creada insertando el objeto del método antes del "
"primer argumento."

#: ../Doc/tutorial/classes.rst:389
msgid ""
"If you still don't understand how methods work, a look at the implementation "
"can perhaps clarify matters.  When a non-data attribute of an instance is "
"referenced, the instance's class is searched.  If the name denotes a valid "
"class attribute that is a function object, a method object is created by "
"packing (pointers to) the instance object and the function object just found "
"together in an abstract object: this is the method object.  When the method "
"object is called with an argument list, a new argument list is constructed "
"from the instance object and the argument list, and the function object is "
"called with this new argument list."
msgstr ""
"Si todavía no entiendes como funcionan los métodos, una mirada a su "
"implementación quizás pueda aclarar dudas. Cuando un atributo sin datos de "
"una instancia es referenciado, la clase de la instancia es accedida. Si el "
"nombre indica un atributo de clase válido que sea un objeto función, se crea "
"un objeto método empaquetando (apunta a) la instancia y al objeto función, "
"juntados en un objeto abstracto: este es el objeto método. Cuando el objeto "
"método es llamado con una lista de argumentos, se crea una nueva lista de "
"argumentos a partir del objeto instancia y la lista de argumentos. "
"Finalmente el objeto función es llamado con esta nueva lista de argumentos."

#: ../Doc/tutorial/classes.rst:403
msgid "Class and Instance Variables"
msgstr "Variables de clase y de instancia"

#: ../Doc/tutorial/classes.rst:405
msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""
"En general, las variables de instancia son para datos únicos de cada "
"instancia y las variables de clase son para atributos y métodos compartidos "
"por todas las instancias de la clase::"

#: ../Doc/tutorial/classes.rst:427
msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""
"Como se vio en :ref:`tut-object`, los datos compartidos pueden tener efectos "
"inesperados que involucren objetos :term:`mutable` como ser listas y "
"diccionarios. Por ejemplo, la lista *trucos* en el siguiente código no "
"debería ser usada como variable de clase porque una sola lista sería "
"compartida por todos las instancias de *Perro*::"

#: ../Doc/tutorial/classes.rst:450
msgid "Correct design of the class should use an instance variable instead::"
msgstr ""
"El diseño correcto de esta clase sería usando una variable de instancia::"

#: ../Doc/tutorial/classes.rst:474
msgid "Random Remarks"
msgstr "Algunas observaciones"

#: ../Doc/tutorial/classes.rst:478
msgid ""
"If the same attribute name occurs in both an instance and in a class, then "
"attribute lookup prioritizes the instance::"
msgstr ""
"Si el mismo nombre de atributo aparece tanto en la instancia como en la "
"clase, la búsqueda del atributo prioriza la instancia::"

#: ../Doc/tutorial/classes.rst:493
msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide "
"implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"A los atributos de datos los pueden hacer referencia tanto los métodos como "
"los usuarios (\"clientes\") ordinarios de un objeto.  En otras palabras, las "
"clases no se usan para implementar tipos de datos abstractos puros.  De "
"hecho, en Python no hay nada que haga cumplir el ocultar datos; todo se basa "
"en convención.  (Por otro lado, la implementación de Python, escrita en C, "
"puede ocultar por completo detalles de implementación y el control de acceso "
"a un objeto si es necesario; esto se puede usar en extensiones a Python "
"escritas en C.)"

#: ../Doc/tutorial/classes.rst:501
msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object "
"without affecting the validity of the methods, as long as name conflicts are "
"avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"Los clientes deben usar los atributos de datos con cuidado; éstos pueden "
"romper invariantes que mantienen los métodos si pisan los atributos de "
"datos. Observá que los clientes pueden añadir sus propios atributos de datos "
"a una instancia sin afectar la validez de sus métodos, siempre y cuando se "
"eviten conflictos de nombres; de nuevo, una convención de nombres puede "
"ahorrar un montón de dolores de cabeza."

#: ../Doc/tutorial/classes.rst:507
msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of "
"methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"No hay un atajo para hacer referencia a atributos de datos (¡u otros "
"métodos!) desde dentro de un método.  A mi parecer, esto en realidad aumenta "
"la legibilidad de los métodos: no existe posibilidad alguna de confundir "
"variables locales con variables de instancia cuando repasamos un método."

#: ../Doc/tutorial/classes.rst:512
msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable "
"that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"A menudo, el primer argumento de un método se llama ``self`` (uno mismo).  "
"Esto no es nada más que una convención: el nombre ``self`` no significa nada "
"en especial para Python.  Observá que, sin embargo, si no seguís la "
"convención tu código puede resultar menos legible a otros programadores de "
"Python, y puede llegar a pasar que un programa *navegador de clases* pueda "
"escribirse de una manera que dependa de dicha convención."

#: ../Doc/tutorial/classes.rst:518
msgid ""
"Any function object that is a class attribute defines a method for instances "
"of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a "
"local variable in the class is also ok.  For example::"
msgstr ""
"Cualquier objeto función que es un atributo de clase define un método para "
"instancias de esa clase.  No es necesario que el la definición de la función "
"esté textualmente dentro de la definición de la clase: asignando un objeto "
"función a una variable local en la clase también está bien.  Por ejemplo::"

#: ../Doc/tutorial/classes.rst:535
msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`C` that refer "
"to function objects, and consequently they are all methods of instances of :"
"class:`C` --- ``h`` being exactly equivalent to ``g``.  Note that this "
"practice usually only serves to confuse the reader of a program."
msgstr ""
"Ahora ``f``, ``g`` y ``h`` son todos atributos de la clase :class:`C` que "
"hacen referencia a objetos función, y consecuentemente son todos métodos de "
"las instancias de :class:`C`; ``h`` siendo exactamente equivalente a ``g``. "
"Fijate que esta práctica normalmente sólo sirve para confundir al que lea un "
"programa."

#: ../Doc/tutorial/classes.rst:540
msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr ""
"Los métodos pueden llamar a otros métodos de la instancia usando el "
"argumento ``self``::"

#: ../Doc/tutorial/classes.rst:554
msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some "
"good reasons why a method would want to reference its own class."
msgstr ""
"Los métodos pueden hacer referencia a nombres globales de la misma manera "
"que lo hacen las funciones comunes.  El ámbito global asociado a un método "
"es el módulo que contiene su definición.  (Una clase nunca se usa como un "
"ámbito global.)  Si bien es raro encontrar una buena razón para usar datos "
"globales en un método, hay muchos usos legítimos del ámbito global: por lo "
"menos, las funciones y módulos importados en el ámbito global pueden usarse "
"por los métodos, al igual que las funciones y clases definidas en él. "
"Habitualmente, la clase que contiene el método está definida en este ámbito "
"global, y en la siguiente sección veremos algunas buenas razones por las que "
"un método querría hacer referencia a su propia clase."

#: ../Doc/tutorial/classes.rst:564
msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"Todo valor es un objeto, y por lo tanto tiene una *clase* (también llamado "
"su *tipo*). Ésta se almacena como ``objeto.__class__``."

#: ../Doc/tutorial/classes.rst:571
msgid "Inheritance"
msgstr "Herencia"

#: ../Doc/tutorial/classes.rst:573
msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"Por supuesto, una característica del lenguaje no sería digna del nombre "
"\"clase\" si no soportara herencia.  La sintaxis para una definición de "
"clase derivada se ve así::"

#: ../Doc/tutorial/classes.rst:584
msgid ""
"The name :class:`BaseClassName` must be defined in a scope containing the "
"derived class definition.  In place of a base class name, other arbitrary "
"expressions are also allowed.  This can be useful, for example, when the "
"base class is defined in another module::"
msgstr ""
"El nombre :class:`ClaseBase` debe estar definido en un ámbito que contenga a "
"la definición de la clase derivada.  En el lugar del nombre de la clase base "
"se permiten otras expresiones arbitrarias.  Esto puede ser útil, por "
"ejemplo, cuando la clase base está definida en otro módulo::"

#: ../Doc/tutorial/classes.rst:591
msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is "
"not found in the class, the search proceeds to look in the base class.  This "
"rule is applied recursively if the base class itself is derived from some "
"other class."
msgstr ""
"La ejecución de una definición de clase derivada procede de la misma forma "
"que una clase base.  Cuando el objeto clase se construye, se tiene en cuenta "
"a la clase base.  Esto se usa para resolver referencias a atributos: si un "
"atributo solicitado no se encuentra en la clase, la búsqueda continúa por la "
"clase base. Esta regla se aplica recursivamente si la clase base misma "
"deriva de alguna otra clase."

#: ../Doc/tutorial/classes.rst:597
msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"No hay nada en especial en la instanciación de clases derivadas: "
"``ClaseDerivada()`` crea una nueva instancia de la clase.  Las referencias a "
"métodos se resuelven de la siguiente manera: se busca el atributo de clase "
"correspondiente, descendiendo por la cadena de clases base si es necesario, "
"y la referencia al método es válida si se entrega un objeto función."

#: ../Doc/tutorial/classes.rst:603
msgid ""
"Derived classes may override methods of their base classes.  Because methods "
"have no special privileges when calling other methods of the same object, a "
"method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"Las clases derivadas pueden redefinir métodos de su clase base.  Como los "
"métodos no tienen privilegios especiales cuando llaman a otros métodos del "
"mismo objeto, un método de la clase base que llame a otro método definido en "
"la misma clase base puede terminar llamando a un método de la clase derivada "
"que lo haya redefinido.  (Para los programadores de C++: en Python todos los "
"métodos son en efecto ``virtuales``.)"

#: ../Doc/tutorial/classes.rst:609
msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call ``BaseClassName."
"methodname(self, arguments)``.  This is occasionally useful to clients as "
"well.  (Note that this only works if the base class is accessible as "
"``BaseClassName`` in the global scope.)"
msgstr ""
"Un método redefinido en una clase derivada puede de hecho querer extender en "
"vez de simplemente reemplazar al método de la clase base con el mismo "
"nombre. Hay una manera simple de llamar al método de la clase base "
"directamente: simplemente llamás a ``ClaseBase.metodo(self, argumentos)``.  "
"En ocasiones esto es útil para los clientes también.  (Observá que esto sólo "
"funciona si la clase base es accesible como ``ClaseBase`` en el ámbito "
"global.)"

#: ../Doc/tutorial/classes.rst:616
msgid "Python has two built-in functions that work with inheritance:"
msgstr "Python tiene dos funciones integradas que funcionan con herencia:"

#: ../Doc/tutorial/classes.rst:618
msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)`` "
"will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""
"Usar :func:`isinstance` para verificar el tipo de una instancia: "
"``isinstance(obj, int)`` será ``True`` sólo si ``obj.__class__`` es :class:"
"`int` o alguna clase derivada de :class:`int`."

#: ../Doc/tutorial/classes.rst:622
msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)`` "
"is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(float, int)`` is ``False`` since :class:`float` is not a "
"subclass of :class:`int`."
msgstr ""
"Usar :func:`issubclass` para verificar la herencia de clases: "
"``issubclass(bool, int)`` es ``True`` ya que :class:`bool` es una subclase "
"de :class:`int`. Sin embargo, ``issubclass(float, int)`` es ``False`` ya "
"que :class:`float` no es una subclase de :class:`int`."

#: ../Doc/tutorial/classes.rst:632
msgid "Multiple Inheritance"
msgstr "Herencia múltiple"

#: ../Doc/tutorial/classes.rst:634
msgid ""
"Python supports a form of multiple inheritance as well.  A class definition "
"with multiple base classes looks like this::"
msgstr ""
"Python también soporta una forma de herencia múltiple.  Una definición de "
"clase con múltiples clases base se ve así::"

#: ../Doc/tutorial/classes.rst:644
msgid ""
"For most purposes, in the simplest cases, you can think of the search for "
"attributes inherited from a parent class as depth-first, left-to-right, not "
"searching twice in the same class where there is an overlap in the "
"hierarchy. Thus, if an attribute is not found in :class:`DerivedClassName`, "
"it is searched for in :class:`Base1`, then (recursively) in the base classes "
"of :class:`Base1`, and if it was not found there, it was searched for in :"
"class:`Base2`, and so on."
msgstr ""
"Para la mayoría de los propósitos, en los casos más simples, podés pensar en "
"la búsqueda de los atributos heredados de clases padres como primero en "
"profundidad, de izquierda a derecha, sin repetir la misma clase cuando está "
"dos veces en la jerarquía.  Por lo tanto, si un atributo no se encuentra en :"
"class:`ClaseDerivada`, se busca en :class:`Base1`, luego (recursivamente) en "
"las clases base de :class:`Base1`, y sólo si no se encuentra allí se lo "
"busca en :class:`Base2`, y así sucesivamente."

#: ../Doc/tutorial/classes.rst:651
msgid ""
"In fact, it is slightly more complex than that; the method resolution order "
"changes dynamically to support cooperative calls to :func:`super`.  This "
"approach is known in some other multiple-inheritance languages as call-next-"
"method and is more powerful than the super call found in single-inheritance "
"languages."
msgstr ""
"En realidad es un poco más complejo que eso; el orden de resolución de "
"métodos cambia dinámicamente para soportar las llamadas cooperativas a :func:"
"`super`.  Este enfoque es conocido en otros lenguajes con herencia múltiple "
"como \"llámese al siguiente método\" y es más poderoso que la llamada al "
"superior que se encuentra en lenguajes con sólo herencia simple."

#: ../Doc/tutorial/classes.rst:657
msgid ""
"Dynamic ordering is necessary because all cases of multiple inheritance "
"exhibit one or more diamond relationships (where at least one of the parent "
"classes can be accessed through multiple paths from the bottommost class).  "
"For example, all classes inherit from :class:`object`, so any case of "
"multiple inheritance provides more than one path to reach :class:`object`.  "
"To keep the base classes from being accessed more than once, the dynamic "
"algorithm linearizes the search order in a way that preserves the left-to-"
"right ordering specified in each class, that calls each parent only once, "
"and that is monotonic (meaning that a class can be subclassed without "
"affecting the precedence order of its parents). Taken together, these "
"properties make it possible to design reliable and extensible classes with "
"multiple inheritance.  For more detail, see https://www.python.org/download/"
"releases/2.3/mro/."
msgstr ""
"El ordenamiento dinámico es necesario porque todos los casos de herencia "
"múltiple exhiben una o más relaciones en diamante (cuando se puede llegar al "
"menos a una de las clases base por distintos caminos desde la clase de más "
"abajo).  Por ejemplo, todas las clases heredan de :class:`object`, por lo "
"tanto cualquier caso de herencia múltiple provee más de un camino para "
"llegar a :class:`object`.  Para que las clases base no sean accedidas más de "
"una vez, el algoritmo dinámico hace lineal el orden de búsqueda de manera "
"que se preserve el orden de izquierda a derecha especificado en cada clase, "
"que se llame a cada clase base sólo una vez, y que sea monótona (lo cual "
"significa que una clase puede tener clases derivadas sin afectar el orden de "
"precedencia de sus clases bases).  En conjunto, estas propiedades hacen "
"posible diseñar clases confiables y extensibles con herencia múltiple. Para "
"más detalles mirá  https://www.python.org/download/releases/2.3/mro/."

#: ../Doc/tutorial/classes.rst:674
msgid "Private Variables"
msgstr "Variables privadas"

#: ../Doc/tutorial/classes.rst:676
msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an "
"object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"Las variables \"privadas\" de instancia, que no pueden accederse excepto "
"desde dentro de un objeto, no existen en Python.  Sin embargo, hay una "
"convención que se sigue en la mayoría del código Python: un nombre prefijado "
"con un guión bajo (por ejemplo, ``_spam``) debería tratarse como una parte "
"no pública de la API (más allá de que sea una función, un método, o un "
"dato).  Debería considerarse un detalle de implementación y que está sujeto "
"a cambios sin aviso."

#: ../Doc/tutorial/classes.rst:686
msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) "
"stripped.  This mangling is done without regard to the syntactic position of "
"the identifier, as long as it occurs within the definition of a class."
msgstr ""
"Ya que hay un caso de uso válido para los identificadores privados de clase "
"(a saber: colisión de nombres con nombres definidos en las subclases), hay "
"un soporte limitado para este mecanismo.  Cualquier identificador con la "
"forma ``__spam`` (al menos dos guiones bajos al principio, como mucho un "
"guión bajo al final) es textualmente reemplazado por "
"``_nombredeclase__spam``, donde ``nombredeclase`` es el nombre de clase "
"actual al que se le sacan guiones bajos del comienzo (si los tuviera).  Se "
"modifica el nombre del identificador sin importar su posición sintáctica, "
"siempre y cuando ocurra dentro de la definición de una clase."

#: ../Doc/tutorial/classes.rst:695
msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""
"La modificación de nombres es útil para dejar que las subclases "
"sobreescriban los métodos sin romper las llamadas a los métodos desde la "
"misma clase.  Por ejemplo::"

#: ../Doc/tutorial/classes.rst:717
msgid ""
"The above example would work even if ``MappingSubclass`` were to introduce a "
"``__update`` identifier since it is replaced with ``_Mapping__update`` in "
"the ``Mapping`` class  and ``_MappingSubclass__update`` in the "
"``MappingSubclass`` class respectively."
msgstr ""
"El ejemplo de arriba funcionaría incluso si ``MappingSubclass`` introdujera "
"un identificador ``__update`` ya que se reemplaza con ``_Mapping__update`` "
"en la clase ``Mapping``  y ``_MappingSubclass__update`` en la clase "
"``MappingSubclass`` respectivamente."

#: ../Doc/tutorial/classes.rst:722
msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered "
"private.  This can even be useful in special circumstances, such as in the "
"debugger."
msgstr ""
"Hay que aclarar que las reglas de modificación de nombres están diseñadas "
"principalmente para evitar accidentes; es posible acceder o modificar una "
"variable que es considerada como privada.  Esto hasta puede resultar útil en "
"circunstancias especiales, tales como en el depurador."

#: ../Doc/tutorial/classes.rst:726
msgid ""
"Notice that code passed to ``exec()`` or ``eval()`` does not consider the "
"classname of the invoking class to be the current class; this is similar to "
"the effect of the ``global`` statement, the effect of which is likewise "
"restricted to code that is byte-compiled together.  The same restriction "
"applies to ``getattr()``, ``setattr()`` and ``delattr()``, as well as when "
"referencing ``__dict__`` directly."
msgstr ""
"Notar que el código pasado a ``exec`` o ``eval()`` no considera que el "
"nombre de clase de la clase que invoca sea la clase actual; esto es similar "
"al efecto de la sentencia ``global``, efecto que es de similar manera "
"restringido a código que es compilado en conjunto.  La misma restricción "
"aplica a ``getattr()``, ``setattr()`` y ``delattr()``, así como cuando se "
"referencia a ``__dict__`` directamente."

#: ../Doc/tutorial/classes.rst:737
msgid "Odds and Ends"
msgstr "Cambalache"

#: ../Doc/tutorial/classes.rst:739
msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items.  An empty class "
"definition will do nicely::"
msgstr ""
"A veces es útil tener un tipo de datos similar al \"registro\" de Pascal o "
"la \"estructura\" de C, que sirva para juntar algunos pocos ítems con "
"nombre.  Una definición de clase vacía funcionará perfecto::"

#: ../Doc/tutorial/classes.rst:753
msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type "
"instead.  For instance, if you have a function that formats some data from a "
"file object, you can define a class with methods :meth:`read` and :meth:`!"
"readline` that get the data from a string buffer instead, and pass it as an "
"argument."
msgstr ""
"Algún código Python que espera un tipo abstracto de datos en particular "
"puede frecuentemente recibir en cambio una clase que emula los métodos de "
"aquel tipo de datos.  Por ejemplo, si tenés una función que formatea algunos "
"datos a partir de un objeto archivo, podés definir una clase con métodos :"
"meth:`read` y :meth:`!readline` que obtengan los datos de alguna cadena en "
"memoria intermedia, y pasarlo como argumento."

#: ../Doc/tutorial/classes.rst:764
msgid ""
"Instance method objects have attributes, too: ``m.__self__`` is the instance "
"object with the method :meth:`m`, and ``m.__func__`` is the function object "
"corresponding to the method."
msgstr ""
"Los objetos método de instancia tienen atributos también: ``m.__self__`` es "
"el objeto instancia con el método :meth:`m`, y ``m.__func__`` es el objeto "
"función correspondiente al método."

#: ../Doc/tutorial/classes.rst:772
msgid "Iterators"
msgstr "Iteradores"

#: ../Doc/tutorial/classes.rst:774
msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"Es probable que hayas notado que la mayoría de los objetos contenedores "
"pueden ser recorridos usando una sentencia :keyword:`for`::"

#: ../Doc/tutorial/classes.rst:788
msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the :keyword:"
"`for` statement calls :func:`iter` on the container object.  The function "
"returns an iterator object that defines the method :meth:`~iterator."
"__next__` which accesses elements in the container one at a time.  When "
"there are no more elements, :meth:`~iterator.__next__` raises a :exc:"
"`StopIteration` exception which tells the :keyword:`!for` loop to "
"terminate.  You can call the :meth:`~iterator.__next__` method using the :"
"func:`next` built-in function; this example shows how it all works::"
msgstr ""
"Este estilo de acceso es limpio, conciso y conveniente.  El uso de "
"iteradores está impregnado y unifica a Python.  En bambalinas, la sentencia :"
"keyword:`for` llama a :func:`iter` en el objeto contenedor.  La función "
"retorna un objeto iterador que define el método :meth:`__next__` que accede "
"elementos en el contenedor de a uno por vez.  Cuando no hay más elementos, :"
"meth:`~iterator.__next__` levanta una excepción :exc:`StopIteration` que le "
"avisa al bucle del :keyword:`!for` que hay que terminar.  Podés llamar al "
"método :meth:`~iterator.__next__` usando la función integrada :func:`next`; "
"este ejemplo muestra como funciona todo esto::"

#: ../Doc/tutorial/classes.rst:813
msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`__iter__` method which "
"returns an object with a :meth:`~iterator.__next__` method.  If the class "
"defines :meth:`__next__`, then :meth:`__iter__` can just return ``self``::"
msgstr ""
"Habiendo visto la mecánica del protocolo de iteración, es fácil agregar "
"comportamiento de iterador a tus clases.  Definí un método :meth:`__iter__` "
"que retorne un objeto con un método :meth:`__next__`.  Si la clase define :"
"meth:`__next__`, entonces alcanza con que :meth:`__iter__` retorne ``self``::"

#: ../Doc/tutorial/classes.rst:850
msgid "Generators"
msgstr "Generadores"

#: ../Doc/tutorial/classes.rst:852
msgid ""
":term:`Generator`\\s are a simple and powerful tool for creating iterators.  "
"They are written like regular functions but use the :keyword:`yield` "
"statement whenever they want to return data.  Each time :func:`next` is "
"called on it, the generator resumes where it left off (it remembers all the "
"data values and which statement was last executed).  An example shows that "
"generators can be trivially easy to create::"
msgstr ""
"Los :term:`Generator` son una simple y poderosa herramienta para crear "
"iteradores.  Se escriben como funciones regulares pero usan la sentencia :"
"keyword:`yield` cuando quieren retornar datos.  Cada vez que se llama :func:"
"`next` sobre él, el generador continúa desde donde dejó (y recuerda todos "
"los valores de datos y cual sentencia fue ejecutada última).  Un ejemplo "
"muestra que los generadores pueden ser muy fáciles de crear::"

#: ../Doc/tutorial/classes.rst:873
msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`__iter__` and :meth:`~generator.__next__` methods "
"are created automatically."
msgstr ""
"Todo lo que puede ser hecho con generadores también puede ser hecho con "
"iteradores basados en clases, como se describe en la sección anterior.  Lo "
"que hace que los generadores sean tan compactos es que los métodos :meth:"
"`__iter__` y :meth:`__next__` son creados automáticamente."

#: ../Doc/tutorial/classes.rst:878
msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like ``self."
"index`` and ``self.data``."
msgstr ""
"Otra característica clave es que las variables locales y el estado de la "
"ejecución son guardados automáticamente entre llamadas.  Esto hace que la "
"función sea más fácil de escribir y quede mucho más claro que hacerlo usando "
"variables de instancia tales como ``self.indice`` y ``self.datos``."

#: ../Doc/tutorial/classes.rst:883
msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"Además de la creación automática de métodos y el guardar el estado del "
"programa, cuando los generadores terminan automáticamente levantan :exc:"
"`StopIteration`.  Combinadas, estas características facilitan la creación de "
"iteradores, y hacen que no sea más esfuerzo que escribir una función regular."

#: ../Doc/tutorial/classes.rst:892
msgid "Generator Expressions"
msgstr "Expresiones generadoras"

#: ../Doc/tutorial/classes.rst:894
msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax "
"similar to list comprehensions but with parentheses instead of square "
"brackets. These expressions are designed for situations where the generator "
"is used right away by an enclosing function.  Generator expressions are more "
"compact but less versatile than full generator definitions and tend to be "
"more memory friendly than equivalent list comprehensions."
msgstr ""
"Algunos generadores simples pueden ser escritos de manera concisa como "
"expresiones usando una sintaxis similar a las comprensiones de listas pero "
"con paréntesis en lugar de corchetes. Estas expresiones están hechas para "
"situaciones donde el generador es utilizado de inmediato por la función que "
"lo encierra. Las expresiones generadoras son más compactas pero menos "
"versátiles que las definiciones completas de generadores y tienden a ser más "
"amigables con la memoria que sus comprensiones de listas equivalentes."

#: ../Doc/tutorial/classes.rst:901
msgid "Examples::"
msgstr "Ejemplos::"

#: ../Doc/tutorial/classes.rst:922
msgid "Footnotes"
msgstr "Notas al pie"

#: ../Doc/tutorial/classes.rst:923
msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name :attr:`~object.__dict__` is an "
"attribute but not a global name. Obviously, using this violates the "
"abstraction of namespace implementation, and should be restricted to things "
"like post-mortem debuggers."
msgstr ""
"Excepto por una cosa. Los objetos módulo tienen un atributo de sólo lectura "
"secreto llamado :attr:`~object.__dict__` que retorna el diccionario usado "
"para implementar el espacio de nombres del módulo; el nombre :attr:`~object."
"__dict__` es un atributo pero no un nombre global. Obviamente, usar esto "
"viola la abstracción de la implementación del espacio de nombres, y debería "
"ser restringido a cosas como depuradores post-mortem."

#~ msgid ""
#~ "Data attributes override method attributes with the same name; to avoid "
#~ "accidental name conflicts, which may cause hard-to-find bugs in large "
#~ "programs, it is wise to use some kind of convention that minimizes the "
#~ "chance of conflicts.  Possible conventions include capitalizing method "
#~ "names, prefixing data attribute names with a small unique string (perhaps "
#~ "just an underscore), or using verbs for methods and nouns for data "
#~ "attributes."
#~ msgstr ""
#~ "Los atributos de datos tienen preferencia sobre los métodos con el mismo "
#~ "nombre; para evitar conflictos de nombre accidentales, que pueden causar "
#~ "errores difíciles de encontrar en programas grandes, es prudente usar "
#~ "algún tipo de convención que minimice las posibilidades de dichos "
#~ "conflictos. Algunas convenciones pueden ser poner los nombres de métodos "
#~ "con mayúsculas, prefijar los nombres de atributos de datos con una "
#~ "pequeña cadena única (a lo mejor sólo un guión bajo), o usar verbos para "
#~ "los métodos y sustantivos para los atributos."
