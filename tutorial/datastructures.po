# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2019, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-06 11:59-0400\n"
"PO-Revision-Date: 2020-03-12 10:59+0100\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: Adrian Santos <martinezsantosadrian@gmail.com>\n"
"Language-Team: es\n"
"Language: es_ES\n"
"X-Generator: Poedit 2.3\n"

#: ../Doc/tutorial/datastructures.rst:5
msgid "Data Structures"
msgstr "Estructuras de Datos"

#: ../Doc/tutorial/datastructures.rst:7
msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr ""
"Este capítulo describe algunas cosas que ya has aprendido en más detalle y "
"agrega algunas cosas nuevas también."

#: ../Doc/tutorial/datastructures.rst:13
msgid "More on Lists"
msgstr "Más sobre Listas"

#: ../Doc/tutorial/datastructures.rst:15
msgid ""
"The list data type has some more methods.  Here are all of the methods of "
"list objects:"
msgstr ""
"El tipo de dato lista tiene algunos métodos más. Aquí están todos los "
"métodos de los objetos lista:"

#: ../Doc/tutorial/datastructures.rst:22
msgid ""
"Add an item to the end of the list.  Equivalent to ``a[len(a):] = [x]``."
msgstr "Agrega un ítem al final de la lista. Equivale a ``a[len(a):] = [x]``."

#: ../Doc/tutorial/datastructures.rst:28
msgid ""
"Extend the list by appending all the items from the iterable.  Equivalent to "
"``a[len(a):] = iterable``."
msgstr ""
"Extiende la lista agregándole todos los ítems del iterable. Equivale a "
"``a[len(a):] = iterable``."

#: ../Doc/tutorial/datastructures.rst:35
msgid ""
"Insert an item at a given position.  The first argument is the index of the "
"element before which to insert, so ``a.insert(0, x)`` inserts at the front "
"of the list, and ``a.insert(len(a), x)`` is equivalent to ``a.append(x)``."
msgstr ""
"Inserta un ítem en una posición dada. El primer argumento es el índice del "
"ítem delante del cual se insertará, por lo tanto ``a.insert(0, x)`` inserta "
"al principio de la lista y ``a.insert(len(a), x)`` equivale a ``a."
"append(x)``."

#: ../Doc/tutorial/datastructures.rst:43
msgid ""
"Remove the first item from the list whose value is equal to *x*.  It raises "
"a :exc:`ValueError` if there is no such item."
msgstr ""
"Quita el primer ítem de la lista cuyo valor sea *x*. Lanza un :exc:"
"`ValueError` si no existe tal ítem."

#: ../Doc/tutorial/datastructures.rst:50
msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list.  (The square brackets around the *i* in the method signature denote "
"that the parameter is optional, not that you should type square brackets at "
"that position.  You will see this notation frequently in the Python Library "
"Reference.)"
msgstr ""
"Quita el ítem en la posición dada de la lista y lo devuelve. Si no se "
"especifica un índice, ``a.pop()`` quita y devuelve el último elemento de la "
"lista. (Los corchetes que encierran a *i* en la firma del método denotan que "
"el parámetro es opcional, no que deberías escribir corchetes en esa "
"posición. Verás esta notación con frecuencia en la Referencia de la "
"Biblioteca de Python.)"

#: ../Doc/tutorial/datastructures.rst:60
msgid "Remove all items from the list.  Equivalent to ``del a[:]``."
msgstr "Elimina todos los elementos de la lista. Equivalente a ``del a[:]``."

#: ../Doc/tutorial/datastructures.rst:66
msgid ""
"Return zero-based index in the list of the first item whose value is equal "
"to *x*. Raises a :exc:`ValueError` if there is no such item."
msgstr ""
"Devuelve el índice basado en cero del primer elemento cuyo valor sea igual a "
"*x*. Lanza una excepción :exc:`ValueError` si no existe tal elemento."

#: ../Doc/tutorial/datastructures.rst:69
msgid ""
"The optional arguments *start* and *end* are interpreted as in the slice "
"notation and are used to limit the search to a particular subsequence of the "
"list.  The returned index is computed relative to the beginning of the full "
"sequence rather than the *start* argument."
msgstr ""
"Los argumentos opcionales *start* y *end* son interpretados como la notación "
"de rebanadas y se usan para limitar la búsqueda a un segmento particular de "
"la lista. El índice devuelto se calcula de manera relativa al inicio de la "
"secuencia completa en lugar de con respecto al argumento *start*."

#: ../Doc/tutorial/datastructures.rst:78
msgid "Return the number of times *x* appears in the list."
msgstr "Devuelve el número de veces que *x* aparece en la lista."

#: ../Doc/tutorial/datastructures.rst:84
msgid ""
"Sort the items of the list in place (the arguments can be used for sort "
"customization, see :func:`sorted` for their explanation)."
msgstr ""
"Ordena los elementos de la lista in situ (los argumentos pueden ser usados "
"para personalizar el orden de la lista, ver :func:`sorted` para su "
"explicación)."

#: ../Doc/tutorial/datastructures.rst:91
msgid "Reverse the elements of the list in place."
msgstr "Invierte los elementos de la lista in situ."

#: ../Doc/tutorial/datastructures.rst:97
msgid "Return a shallow copy of the list.  Equivalent to ``a[:]``."
msgstr "Devuelve una copia superficial de la lista. Equivalente a ``a[:]``."

#: ../Doc/tutorial/datastructures.rst:100
msgid "An example that uses most of the list methods::"
msgstr "Un ejemplo que usa la mayoría de los métodos de la lista::"

#: ../Doc/tutorial/datastructures.rst:123
msgid ""
"You might have noticed that methods like ``insert``, ``remove`` or ``sort`` "
"that only modify the list have no return value printed -- they return the "
"default ``None``. [1]_  This is a design principle for all mutable data "
"structures in Python."
msgstr ""
"Quizás hayas notado que métodos como ``insert``, ``remove`` o ``sort`` que "
"únicamente modifican la lista no tienen impreso un valor de retorno -- "
"devuelven el valor por defecto ``None``. [1]_ Esto es un principio de diseño "
"para todas las estructuras de datos mutables en Python."

#: ../Doc/tutorial/datastructures.rst:132
msgid "Using Lists as Stacks"
msgstr "Usando listas como pilas"

#: ../Doc/tutorial/datastructures.rst:137
msgid ""
"The list methods make it very easy to use a list as a stack, where the last "
"element added is the first element retrieved (\"last-in, first-out\").  To "
"add an item to the top of the stack, use :meth:`append`.  To retrieve an "
"item from the top of the stack, use :meth:`pop` without an explicit index.  "
"For example::"
msgstr ""
"Los métodos de lista hacen que resulte muy fácil usar una lista como una "
"pila, donde el último elemento añadido es el primer elemento retirado "
"(\"último en entrar, primero en salir\"). Para agregar un elemento a la cima "
"de la pila, utiliza :meth:`append`. Para retirar un elemento de la cima de "
"la pila, utiliza :meth:`pop` sin un índice explícito. Por ejemplo:"

#: ../Doc/tutorial/datastructures.rst:162
msgid "Using Lists as Queues"
msgstr "Usando listas como colas"

#: ../Doc/tutorial/datastructures.rst:166
msgid ""
"It is also possible to use a list as a queue, where the first element added "
"is the first element retrieved (\"first-in, first-out\"); however, lists are "
"not efficient for this purpose.  While appends and pops from the end of list "
"are fast, doing inserts or pops from the beginning of a list is slow "
"(because all of the other elements have to be shifted by one)."
msgstr ""
"También es posible usar una lista como una cola, donde el primer elemento "
"añadido es el primer elemento retirado (\"primero en entrar, primero en salir"
"\"); sin embargo, las listas no son eficientes para este propósito. Agregar "
"y sacar del final de la lista es rápido, pero insertar o sacar del comienzo "
"de una lista es lento (porque todos los otros elementos tienen que ser "
"desplazados por uno)."

#: ../Doc/tutorial/datastructures.rst:172
msgid ""
"To implement a queue, use :class:`collections.deque` which was designed to "
"have fast appends and pops from both ends.  For example::"
msgstr ""
"Para implementar una cola, utiliza :class:`collections.deque` el cual fue "
"diseñado para añadir y quitar de ambas puntas de forma rápida. Por ejemplo::"

#: ../Doc/tutorial/datastructures.rst:190
msgid "List Comprehensions"
msgstr "Comprensión de listas"

#: ../Doc/tutorial/datastructures.rst:192
msgid ""
"List comprehensions provide a concise way to create lists. Common "
"applications are to make new lists where each element is the result of some "
"operations applied to each member of another sequence or iterable, or to "
"create a subsequence of those elements that satisfy a certain condition."
msgstr ""
"Las comprensiones de listas ofrecen una manera concisa de crear listas. Sus "
"usos comunes son para hacer nuevas listas donde cada elemento es el "
"resultado de algunas operaciones aplicadas a cada miembro de otra secuencia "
"o iterable, o para crear un segmento de la secuencia de esos elementos para "
"satisfacer una condición determinada."

#: ../Doc/tutorial/datastructures.rst:197
msgid "For example, assume we want to create a list of squares, like::"
msgstr ""
"Por ejemplo, supongamos que queremos crear una lista de cuadrados, como::"

#: ../Doc/tutorial/datastructures.rst:206
msgid ""
"Note that this creates (or overwrites) a variable named ``x`` that still "
"exists after the loop completes.  We can calculate the list of squares "
"without any side effects using::"
msgstr ""
"Tenga en cuenta que esto crea (o sobrescribe) una variable denominada ``x`` "
"que todavía existe después de que se complete el bucle.  Podemos calcular la "
"lista de cuadrados sin efectos secundarios usando::"

#: ../Doc/tutorial/datastructures.rst:212
msgid "or, equivalently::"
msgstr "o, equivalentemente::"

#: ../Doc/tutorial/datastructures.rst:216
msgid "which is more concise and readable."
msgstr "que es más conciso y legible."

#: ../Doc/tutorial/datastructures.rst:218
msgid ""
"A list comprehension consists of brackets containing an expression followed "
"by a :keyword:`!for` clause, then zero or more :keyword:`!for` or :keyword:`!"
"if` clauses.  The result will be a new list resulting from evaluating the "
"expression in the context of the :keyword:`!for` and :keyword:`!if` clauses "
"which follow it. For example, this listcomp combines the elements of two "
"lists if they are not equal::"
msgstr ""
"Una comprensión de lista consiste en corchetes que contienen una expresión "
"seguida de una cláusula :keyword:`!for` y, a continuación, cero o más "
"cláusulas :keyword:`!for` o :keyword:`!if`.  El resultado será una nueva "
"lista resultante de la evaluación de la expresión en el contexto de las "
"cláusulas :keyword:`!for` y :keyword:`!if` que la siguen. Por ejemplo, este "
"'listcomp' combina los elementos de dos listas si no son iguales::"

#: ../Doc/tutorial/datastructures.rst:228
msgid "and it's equivalent to::"
msgstr "y es equivalente a::"

#: ../Doc/tutorial/datastructures.rst:239
msgid ""
"Note how the order of the :keyword:`for` and :keyword:`if` statements is the "
"same in both these snippets."
msgstr ""
"Observe cómo el orden de las instrucciones :keyword:`for` y :keyword:`if` es "
"el mismo en ambos fragmentos."

#: ../Doc/tutorial/datastructures.rst:242
msgid ""
"If the expression is a tuple (e.g. the ``(x, y)`` in the previous example), "
"it must be parenthesized. ::"
msgstr ""
"Si la expresión es una tupla (por ejemplo el ``(x, y)`` en el ejemplo "
"anterior), debe estar entre paréntesis. ::"

#: ../Doc/tutorial/datastructures.rst:273
msgid ""
"List comprehensions can contain complex expressions and nested functions::"
msgstr ""
"Las comprensión de lista pueden contener expresiones complejas y funciones "
"anidadas::"

#: ../Doc/tutorial/datastructures.rst:280
msgid "Nested List Comprehensions"
msgstr "Comprensión de Lista Anidada"

#: ../Doc/tutorial/datastructures.rst:282
msgid ""
"The initial expression in a list comprehension can be any arbitrary "
"expression, including another list comprehension."
msgstr ""
"La expresión inicial de una comprensión de lista puede ser cualquier "
"expresión arbitraria, incluida otra comprensión de lista."

#: ../Doc/tutorial/datastructures.rst:285
msgid ""
"Consider the following example of a 3x4 matrix implemented as a list of 3 "
"lists of length 4::"
msgstr ""
"Considere el siguiente ejemplo de una matriz 3x4 implementada como una lista "
"de 3 listas de longitud 4::"

#: ../Doc/tutorial/datastructures.rst:294
msgid "The following list comprehension will transpose rows and columns::"
msgstr "La siguiente comprensión de lista transpondrá filas y columnas::"

#: ../Doc/tutorial/datastructures.rst:299
msgid ""
"As we saw in the previous section, the nested listcomp is evaluated in the "
"context of the :keyword:`for` that follows it, so this example is equivalent "
"to::"
msgstr ""
"Como vimos en la sección anterior, el 'listcomp' anidado se evalúa en el "
"contexto de la :keyword:`for` que le sigue, por lo que este ejemplo es "
"equivalente a::"

#: ../Doc/tutorial/datastructures.rst:310
msgid "which, in turn, is the same as::"
msgstr "que, a su vez, es lo mismo que::"

#: ../Doc/tutorial/datastructures.rst:323
msgid ""
"In the real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use case::"
msgstr ""
"En el mundo real, debe preferir las funciones integradas a instrucciones de "
"flujo complejas. La función :func:`zip` haría un gran trabajo para este caso "
"de uso::"

#: ../Doc/tutorial/datastructures.rst:329
msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this line."
msgstr ""
"Consulte :ref:`tut-unpacking-arguments` para obtener más información sobre "
"el asterisco de esta línea."

#: ../Doc/tutorial/datastructures.rst:334
msgid "The :keyword:`!del` statement"
msgstr "La declaración :keyword:`!del`"

#: ../Doc/tutorial/datastructures.rst:336
msgid ""
"There is a way to remove an item from a list given its index instead of its "
"value: the :keyword:`del` statement.  This differs from the :meth:`pop` "
"method which returns a value.  The :keyword:`!del` statement can also be "
"used to remove slices from a list or clear the entire list (which we did "
"earlier by assignment of an empty list to the slice).  For example::"
msgstr ""
"Hay una manera de quitar un elemento de una lista dado su índice en lugar de "
"su valor: la instrucción :keyword:`del`.  Esto difiere del método :"
"meth:'pop' que devuelve un valor.  La instrucción :keyword:`!del` también se "
"puede utilizar para eliminar sectores de una lista o borrar toda la lista "
"(lo que hicimos anteriormente por asignación de una lista vacía al sector).  "
"Por ejemplo::"

#: ../Doc/tutorial/datastructures.rst:353
msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ""
":keyword:`del` también se puede utilizar para eliminar variables enteras::"

#: ../Doc/tutorial/datastructures.rst:357
msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` later."
msgstr ""
"Hacer referencia al nombre ``a`` en adelante es un error (al menos hasta que "
"se le asigne otro valor).  Encontraremos otros usos para :keyword:`del` más "
"tarde."

#: ../Doc/tutorial/datastructures.rst:364
msgid "Tuples and Sequences"
msgstr "Tuplas y Secuencias"

#: ../Doc/tutorial/datastructures.rst:366
msgid ""
"We saw that lists and strings have many common properties, such as indexing "
"and slicing operations.  They are two examples of *sequence* data types "
"(see :ref:`typesseq`).  Since Python is an evolving language, other sequence "
"data types may be added.  There is also another standard sequence data type: "
"the *tuple*."
msgstr ""
"Vimos que las listas y las cadenas tienen muchas propiedades comunes, como "
"las operaciones de indexación y segmentación.  Son dos ejemplos de tipos de "
"datos *sequence* (consulte :ref:`typesseq`).  Dado que Python es un lenguaje "
"en evolución, se pueden agregar otros tipos de datos de secuencia.  También "
"hay otro tipo de datos de secuencia estándar: la*tupla*."

#: ../Doc/tutorial/datastructures.rst:372
msgid ""
"A tuple consists of a number of values separated by commas, for instance::"
msgstr ""
"Una tupla consta de un número de valores separados por comas, por ejemplo::"

#: ../Doc/tutorial/datastructures.rst:394
msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or without "
"surrounding parentheses, although often parentheses are necessary anyway (if "
"the tuple is part of a larger expression).  It is not possible to assign to "
"the individual items of a tuple, however it is possible to create tuples "
"which contain mutable objects, such as lists."
msgstr ""
"Como puede ver, en las tuplas de salida siempre se incluyen entre "
"paréntesis, de modo que las tuplas anidadas se interpretan correctamente; "
"pueden ser introducidos con o sin paréntesis circundantes, aunque a menudo "
"los paréntesis son necesarios de todos modos (si la tupla es parte de una "
"expresión más grande).  No es posible asignar a los elementos individuales "
"de una tupla, sin embargo, es posible crear tuplas que contengan objetos "
"mutables, como listas."

#: ../Doc/tutorial/datastructures.rst:401
msgid ""
"Though tuples may seem similar to lists, they are often used in different "
"situations and for different purposes. Tuples are :term:`immutable`, and "
"usually contain a heterogeneous sequence of elements that are accessed via "
"unpacking (see later in this section) or indexing (or even by attribute in "
"the case of :func:`namedtuples <collections.namedtuple>`). Lists are :term:"
"`mutable`, and their elements are usually homogeneous and are accessed by "
"iterating over the list."
msgstr ""
"Aunque las tuplas pueden parecer similares a las listas, a menudo se "
"utilizan en diferentes situaciones y para diferentes propósitos. Las tuplas "
"son :term:`inmutable`, y normalmente contienen una secuencia heterogénea de "
"elementos a los que se accede a través del desempaquetado (véase más "
"adelante en esta sección) o indización (o incluso por atributo en el caso "
"de :func:`namedtuples <collections.namedtuple>`). Las listas son :term:"
"`mutable`, y sus elementos suelen ser homogéneos y se accede a ellos "
"iterando sobre la lista."

#: ../Doc/tutorial/datastructures.rst:409
msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: the "
"syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For example::"
msgstr ""
"Un problema especial es la construcción de tuplas que contienen 0 o 1 "
"elementos: la sintaxis tiene algunas peculiaridades adicionales para "
"acomodar estos.  Las tuplas vacías se construyen mediante un par vacío de "
"paréntesis; una tupla con un elemento se construye siguiendo un valor con "
"una coma (no es suficiente incluir un solo valor entre paréntesis). Feo, "
"pero efectivo.  Por ejemplo::"

#: ../Doc/tutorial/datastructures.rst:424
msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""
"La declaración ``t = 12345, 54321, 'hello!'`` es un ejemplo de "
"*empaquetamiento de tupla*: los valores ``12345``, ``54321`` y ``'hello!'`` "
"se empaquetan juntos en una tupla. La operación inversa también es posible::"

#: ../Doc/tutorial/datastructures.rst:430
msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for any "
"sequence on the right-hand side.  Sequence unpacking requires that there are "
"as many variables on the left side of the equals sign as there are elements "
"in the sequence.  Note that multiple assignment is really just a combination "
"of tuple packing and sequence unpacking."
msgstr ""
"Esto se llama, apropiadamente, *desempaquetado de secuencia* y funciona para "
"cualquier secuencia en el lado derecho.  El desempaquetado de secuencia "
"requiere que haya tantas variables en el lado izquierdo del signo de igual "
"como elementos en la secuencia.  Tenga en cuenta que la asignación múltiple "
"es realmente sólo una combinación de empaquetado de tuplas y desembalaje de "
"secuencia."

#: ../Doc/tutorial/datastructures.rst:440
msgid "Sets"
msgstr "Sets"

#: ../Doc/tutorial/datastructures.rst:442
msgid ""
"Python also includes a data type for *sets*.  A set is an unordered "
"collection with no duplicate elements.  Basic uses include membership "
"testing and eliminating duplicate entries.  Set objects also support "
"mathematical operations like union, intersection, difference, and symmetric "
"difference."
msgstr ""
"Python también incluye un tipo de datos para *sets*.  Un conjunto es una "
"colección desordenada sin elementos duplicados.  Los usos básicos incluyen "
"pruebas de pertenencia y eliminación de entradas duplicadas.  Los objetos de "
"conjunto también admiten operaciones matemáticas como unión, intersección, "
"diferencia y diferencia simétrica."

#: ../Doc/tutorial/datastructures.rst:447
msgid ""
"Curly braces or the :func:`set` function can be used to create sets.  Note: "
"to create an empty set you have to use ``set()``, not ``{}``; the latter "
"creates an empty dictionary, a data structure that we discuss in the next "
"section."
msgstr ""
"Las llaves o la función :func:`set` se pueden utilizar para crear "
"conjuntos.  Nota: para crear un conjunto vacío tienes que usar ``set()``, no "
"``{}``; este último crea un diccionario vacío, una estructura de datos que "
"analizamos en la siguiente sección."

#: ../Doc/tutorial/datastructures.rst:451
msgid "Here is a brief demonstration::"
msgstr "Aquí hay una breve demostración::"

#: ../Doc/tutorial/datastructures.rst:476
msgid ""
"Similarly to :ref:`list comprehensions <tut-listcomps>`, set comprehensions "
"are also supported::"
msgstr ""
"De forma similar a :ref:`list comprehensions <tut-listcomps>', también se "
"admiten las comprensión de conjunto::"

#: ../Doc/tutorial/datastructures.rst:487
msgid "Dictionaries"
msgstr "Diccionarios"

#: ../Doc/tutorial/datastructures.rst:489
msgid ""
"Another useful data type built into Python is the *dictionary* (see :ref:"
"`typesmapping`). Dictionaries are sometimes found in other languages as "
"\"associative memories\" or \"associative arrays\".  Unlike sequences, which "
"are indexed by a range of numbers, dictionaries are indexed by *keys*, which "
"can be any immutable type; strings and numbers can always be keys.  Tuples "
"can be used as keys if they contain only strings, numbers, or tuples; if a "
"tuple contains any mutable object either directly or indirectly, it cannot "
"be used as a key. You can't use lists as keys, since lists can be modified "
"in place using index assignments, slice assignments, or methods like :meth:"
"`append` and :meth:`extend`."
msgstr ""
"Otro tipo de datos útil integrado en Python es *dictionary* (consulte :ref:"
"`typesmapping`). Los diccionarios se encuentran a veces en otros idiomas "
"como \"memorias asociativas\" o \"matrices asociativas\".  A diferencia de "
"las secuencias, que están indizadas por un rango de números, los "
"diccionarios se indizan mediante *keys*, que puede ser cualquier tipo "
"inmutable; cadenas y números siempre pueden ser claves.  Las tuplas se "
"pueden utilizar como claves si contienen solo cadenas, números o tuplas; si "
"una tupla contiene cualquier objeto mutable directa o indirectamente, no se "
"puede utilizar como clave. No se pueden usar listas como claves, ya que las "
"listas se pueden modificar en su lugar mediante asignaciones de índice, "
"asignaciones de sectores o métodos como :meth:`append` y :meth:`extend`."

#: ../Doc/tutorial/datastructures.rst:500
msgid ""
"It is best to think of a dictionary as a set of *key: value* pairs, with the "
"requirement that the keys are unique (within one dictionary). A pair of "
"braces creates an empty dictionary: ``{}``. Placing a comma-separated list "
"of key:value pairs within the braces adds initial key:value pairs to the "
"dictionary; this is also the way dictionaries are written on output."
msgstr ""
"Lo mejor es pensar en un diccionario como un conjunto de pares *key: value*, "
"con el requisito de que las claves sean únicas (dentro de un diccionario). "
"Un par de llaves crea un diccionario vacío: ``{}``. Colocar una lista "
"separada por comas de pares key:value dentro de las llaves agrega pares key:"
"value iniciales al diccionario; esta es también la forma en que los "
"diccionarios se escriben en la salida."

#: ../Doc/tutorial/datastructures.rst:506
msgid ""
"The main operations on a dictionary are storing a value with some key and "
"extracting the value given the key.  It is also possible to delete a key:"
"value pair with ``del``. If you store using a key that is already in use, "
"the old value associated with that key is forgotten.  It is an error to "
"extract a value using a non-existent key."
msgstr ""
"Las operaciones principales de un diccionario almacenan un valor con alguna "
"clave y extraen el valor dado la clave.  También es posible eliminar un par "
"key:value con ``del``. Si almacena con una clave que ya está en uso, se "
"olvida el valor antiguo asociado a esa clave.  Es un error extraer un valor "
"utilizando una clave inexistente."

#: ../Doc/tutorial/datastructures.rst:512
msgid ""
"Performing ``list(d)`` on a dictionary returns a list of all the keys used "
"in the dictionary, in insertion order (if you want it sorted, just use "
"``sorted(d)`` instead). To check whether a single key is in the dictionary, "
"use the :keyword:`in` keyword."
msgstr ""
"Realizar ``list(d)`` en un diccionario devuelve una lista de todas las "
"claves utilizadas en el diccionario, en orden de inserción (si lo desea "
"ordenar, sólo tiene que utilizar ``sorted(d)`` en su lugar). Para comprobar "
"si una sola clave está en el diccionario, utilice la palabra clave :keyword:"
"`in`."

#: ../Doc/tutorial/datastructures.rst:517
msgid "Here is a small example using a dictionary::"
msgstr "Aquí hay un pequeño ejemplo usando un diccionario::"

#: ../Doc/tutorial/datastructures.rst:538
msgid ""
"The :func:`dict` constructor builds dictionaries directly from sequences of "
"key-value pairs::"
msgstr ""
"El constructor :func:`dict` crea diccionarios directamente a partir de "
"secuencias de pares clave-valor::"

#: ../Doc/tutorial/datastructures.rst:544
msgid ""
"In addition, dict comprehensions can be used to create dictionaries from "
"arbitrary key and value expressions::"
msgstr ""
"Además, las comprensión dictado se pueden utilizar para crear diccionarios a "
"partir de expresiones arbitrarias de clave y valor::"

#: ../Doc/tutorial/datastructures.rst:550
msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs "
"using keyword arguments::"
msgstr ""
"Cuando las claves son cadenas simples, a veces es más fácil especificar "
"pares mediante argumentos de palabra clave::"

#: ../Doc/tutorial/datastructures.rst:560
msgid "Looping Techniques"
msgstr "Técnicas de Bucle"

#: ../Doc/tutorial/datastructures.rst:562
msgid ""
"When looping through dictionaries, the key and corresponding value can be "
"retrieved at the same time using the :meth:`items` method. ::"
msgstr ""
"Al recorrer en bucle los diccionarios, la clave y el valor correspondiente "
"se pueden recuperar al mismo tiempo mediante el método :meth:`items`. ::"

#: ../Doc/tutorial/datastructures.rst:572
msgid ""
"When looping through a sequence, the position index and corresponding value "
"can be retrieved at the same time using the :func:`enumerate` function. ::"
msgstr ""
"Al recorrer en bucle una secuencia, el índice de posición y el valor "
"correspondiente se pueden recuperar al mismo tiempo mediante la función :"
"func:`enumerate`. ::"

#: ../Doc/tutorial/datastructures.rst:582
msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""
"Para recorrer dos o más secuencias al mismo tiempo, las entradas se pueden "
"emparejar con la función :func:`zip`. ::"

#: ../Doc/tutorial/datastructures.rst:594
msgid ""
"To loop over a sequence in reverse, first specify the sequence in a forward "
"direction and then call the :func:`reversed` function. ::"
msgstr ""
"Para recorrer una secuencia en sentido inverso, especifique primero la "
"secuencia en una dirección de avance y, a continuación, llame a la función :"
"func:`reversed`. ::"

#: ../Doc/tutorial/datastructures.rst:606
msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""
"Para recorrer una secuencia ordenada, utilice la función :func:`sorted` que "
"devuelve una nueva lista ordenada sin modificar el origen. ::"

#: ../Doc/tutorial/datastructures.rst:618
msgid ""
"It is sometimes tempting to change a list while you are looping over it; "
"however, it is often simpler and safer to create a new list instead. ::"
msgstr ""
"A veces es tentador cambiar una lista mientras usted está colocando en bucle "
"sobre ella; sin embargo, a menudo es más simple y más seguro crear una nueva "
"lista en su lugar. ::"

#: ../Doc/tutorial/datastructures.rst:635
msgid "More on Conditions"
msgstr "Más sobre Condiciones"

#: ../Doc/tutorial/datastructures.rst:637
msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr ""
"Las condiciones utilizadas en las instrucciones ``while`` y ``if`` pueden "
"contener operadores, no solo comparaciones."

#: ../Doc/tutorial/datastructures.rst:640
msgid ""
"The comparison operators ``in`` and ``not in`` check whether a value occurs "
"(does not occur) in a sequence.  The operators ``is`` and ``is not`` compare "
"whether two objects are really the same object; this only matters for "
"mutable objects like lists.  All comparison operators have the same "
"priority, which is lower than that of all numerical operators."
msgstr ""
"Los operadores de comparación ``in`` y ``not in`` comprueban si se produce "
"un valor (no se produce) en una secuencia.  Los operadores ``is`` y ``is "
"not`` comparan si dos objetos son realmente el mismo objeto; esto sólo "
"importa para objetos mutables como listas.  Todos los operadores de "
"comparación tienen la misma prioridad, que es menor que la de todos los "
"operadores numéricos."

#: ../Doc/tutorial/datastructures.rst:646
msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether ``a`` "
"is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""
"Las comparaciones se pueden encadenar.  Por ejemplo, ``a < b == c`` prueba "
"si ``a`` es menor que ``b`` y, además, ``b`` es igual a ``c``."

#: ../Doc/tutorial/datastructures.rst:649
msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and ``or``, "
"and the outcome of a comparison (or of any other Boolean expression) may be "
"negated with ``not``.  These have lower priorities than comparison "
"operators; between them, ``not`` has the highest priority and ``or`` the "
"lowest, so that ``A and not B or C`` is equivalent to ``(A and (not B)) or "
"C``. As always, parentheses can be used to express the desired composition."
msgstr ""
"Las comparaciones se pueden combinar utilizando los operadores booleanos "
"``and`` y ``or``, y el resultado de una comparación (o de cualquier otra "
"expresión booleana) puede negarse con ``not``.  Estos tienen prioridades más "
"bajas que los operadores de comparación; entre ellos, ``not`` tiene la "
"prioridad más alta y ``or`` la más baja, de modo que ``A and not B or C`` es "
"equivalente a ``(A and (not B)) or C``. Como siempre, los paréntesis se "
"pueden utilizar para expresar la composición deseada."

#: ../Doc/tutorial/datastructures.rst:656
msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and evaluation "
"stops as soon as the outcome is determined.  For example, if ``A`` and ``C`` "
"are true but ``B`` is false, ``A and B and C`` does not evaluate the "
"expression ``C``.  When used as a general value and not as a Boolean, the "
"return value of a short-circuit operator is the last evaluated argument."
msgstr ""
"Los operadores booleanos ``and`` y ``or`` son los llamados operadores *short-"
"circuit*: sus argumentos se evalúan de izquierda a derecha y la evaluación "
"se detiene tan pronto como se determina el resultado.  Por ejemplo, si ``A`` "
"y ``C`` son verdaderos pero ``B`` es false, ``A and B and C`` no evalúa la "
"expresión ``C``.  Cuando se utiliza como un valor general y no como un valor "
"booleano, el valor devuelto de un operador de cortocircuito es el último "
"argumento evaluado."

#: ../Doc/tutorial/datastructures.rst:663
msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr ""
"Es posible asignar el resultado de una comparación u otra expresión booleana "
"a una variable.  Por ejemplo, ::"

#: ../Doc/tutorial/datastructures.rst:671
msgid ""
"Note that in Python, unlike C, assignment cannot occur inside expressions. C "
"programmers may grumble about this, but it avoids a common class of problems "
"encountered in C programs: typing ``=`` in an expression when ``==`` was "
"intended."
msgstr ""
"Tenga en cuenta que en Python, a diferencia de C, la asignación no puede "
"producirse dentro de las expresiones. Los programadores de C pueden quejarse "
"de esto, pero evita una clase común de problemas encontrados en los "
"programas de C: escribir ``=`` en una expresión cuando se pretendía ``==``."

#: ../Doc/tutorial/datastructures.rst:680
msgid "Comparing Sequences and Other Types"
msgstr "Comparación de Secuencias y Otros Tipos"

#: ../Doc/tutorial/datastructures.rst:682
msgid ""
"Sequence objects may be compared to other objects with the same sequence "
"type. The comparison uses *lexicographical* ordering: first the first two "
"items are compared, and if they differ this determines the outcome of the "
"comparison; if they are equal, the next two items are compared, and so on, "
"until either sequence is exhausted. If two items to be compared are "
"themselves sequences of the same type, the lexicographical comparison is "
"carried out recursively.  If all items of two sequences compare equal, the "
"sequences are considered equal. If one sequence is an initial sub-sequence "
"of the other, the shorter sequence is the smaller (lesser) one.  "
"Lexicographical ordering for strings uses the Unicode code point number to "
"order individual characters.  Some examples of comparisons between sequences "
"of the same type::"
msgstr ""
"Los objetos de secuencia se pueden comparar con otros objetos con el mismo "
"tipo de secuencia. La comparación utiliza el orden *lexicographical*: "
"primero se comparan los dos primeros elementos, y si difieren esto determina "
"el resultado de la comparación; si son iguales, se comparan los dos "
"elementos siguientes, y así sucesivamente, hasta que se agote cualquiera de "
"las secuencias. Si dos elementos a comparar son en sí mismos secuencias del "
"mismo tipo, la comparación lexicográfica se lleva a cabo de forma "
"recursiva.  Si todos los elementos de dos secuencias se comparan iguales, "
"las secuencias se consideran iguales. Si una secuencia es una subsecuencia "
"inicial de la otra, la secuencia más corta es la más pequeña (menor).  El "
"orden lexicográfico para cadenas utiliza el número de punto de código "
"Unicode para ordenar caracteres individuales.  Algunos ejemplos de "
"comparaciones entre secuencias del mismo tipo::"

#: ../Doc/tutorial/datastructures.rst:702
msgid ""
"Note that comparing objects of different types with ``<`` or ``>`` is legal "
"provided that the objects have appropriate comparison methods.  For example, "
"mixed numeric types are compared according to their numeric value, so 0 "
"equals 0.0, etc.  Otherwise, rather than providing an arbitrary ordering, "
"the interpreter will raise a :exc:`TypeError` exception."
msgstr ""
"Tenga en cuenta que la comparación de objetos de diferentes tipos con ``<`` "
"or ``>`` es legal siempre que los objetos tengan métodos de comparación "
"adecuados.  Por ejemplo, los tipos numéricos mixtos se comparan según su "
"valor numérico, por lo que 0 es igual a 0.0, etc.  De lo contrario, en lugar "
"de proporcionar un orden arbitrario, el intérprete generará una excepción :"
"exc:`TypeError'."

#: ../Doc/tutorial/datastructures.rst:710
msgid "Footnotes"
msgstr "Notas al pie"

#: ../Doc/tutorial/datastructures.rst:711
msgid ""
"Other languages may return the mutated object, which allows method chaining, "
"such as ``d->insert(\"a\")->remove(\"b\")->sort();``."
msgstr ""
"Otros lenguajes pueden devolver el objeto mutado, que permite el "
"encadenamiento de métodos, como ``d->insert(\"a\")->remove(\"b\")->sort();``."
