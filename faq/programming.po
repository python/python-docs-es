# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-25 19:47+0200\n"
"PO-Revision-Date: 2021-12-11 15:36-0300\n"
"Last-Translator: Juan C. Tello <juanctello@gmail.com>\n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../Doc/faq/programming.rst:5
msgid "Programming FAQ"
msgstr "Preguntas frecuentes de programación"

#: ../Doc/faq/programming.rst:8
msgid "Contents"
msgstr "Contenido"

#: ../Doc/faq/programming.rst:12
msgid "General Questions"
msgstr "Preguntas generales"

#: ../Doc/faq/programming.rst:15
msgid ""
"Is there a source code level debugger with breakpoints, single-stepping, "
"etc.?"
msgstr ""
"¿Existe un depurador a nivel de código fuente con puntos de interrupción, "
"depuración paso a paso, etc?"

#: ../Doc/faq/programming.rst:17 ../Doc/faq/programming.rst:57
msgid "Yes."
msgstr "Sí."

#: ../Doc/faq/programming.rst:19
msgid ""
"Several debuggers for Python are described below, and the built-in function :"
"func:`breakpoint` allows you to drop into any of them."
msgstr ""
"Debajo se describen algunos depuradores para Python y la función integrada :"
"func:`breakpoint` te permite ejecutar alguno de ellos."

#: ../Doc/faq/programming.rst:22
msgid ""
"The pdb module is a simple but adequate console-mode debugger for Python. It "
"is part of the standard Python library, and is :mod:`documented in the "
"Library Reference Manual <pdb>`. You can also write your own debugger by "
"using the code for pdb as an example."
msgstr ""
"El módulo pdb es en depurador en modo consola simple pero conveniente para "
"Python. Es parte de la biblioteca estándar de Python y está :mod:"
"`documentado en el manual de referencia de la biblioteca <pdb>`. Puedes "
"escribir tu propio depurador usando el código de pdb como ejemplo."

#: ../Doc/faq/programming.rst:27
msgid ""
"The IDLE interactive development environment, which is part of the standard "
"Python distribution (normally available as Tools/scripts/idle), includes a "
"graphical debugger."
msgstr ""
"El entorno interactivo de desarrollo IDLE, el cual es parte de la "
"distribución Python estándar (disponible, generalmente,  como Tools/scripts/"
"idle), incluye un depurador gráfico."

#: ../Doc/faq/programming.rst:31
msgid ""
"PythonWin is a Python IDE that includes a GUI debugger based on pdb.  The "
"PythonWin debugger colors breakpoints and has quite a few cool features such "
"as debugging non-PythonWin programs.  PythonWin is available as part of "
"`pywin32 <https://github.com/mhammond/pywin32>`_ project and as a part of "
"the `ActivePython <https://www.activestate.com/products/python/>`_ "
"distribution."
msgstr ""
"PythonWin es un IDE Python que incluye un depurador con GUI basado en pdb. "
"El depurador PythonWin colorea los puntos de interrupción y dispone de "
"características geniales como la depuración de programas no modificados "
"mediante PythonWin. PythonWin está disponible como parte del proyecto `Las "
"extensiones de Python para Windows <https://sourceforge.net/ projects/"
"pywin32/>`_ y como parte de la distribución `ActivePython <https://www."
"activestate.com/activepython>`_."

#: ../Doc/faq/programming.rst:38
#, fuzzy
msgid ""
"`Eric <https://eric-ide.python-projects.org/>`_ is an IDE built on PyQt and "
"the Scintilla editing component."
msgstr ""
"`Eric <http://eric-ide.python-projects.org/>`_ es un IDE creado usando PyQt "
"y el componente de edición Scintilla."

#: ../Doc/faq/programming.rst:41
msgid ""
"`trepan3k <https://github.com/rocky/python3-trepan/>`_ is a gdb-like "
"debugger."
msgstr ""
"`trepan3k <https://github.com/rocky/python3-trepan/>`_ es un depurador "
"similar a `gdb`."

#: ../Doc/faq/programming.rst:43
msgid ""
"`Visual Studio Code <https://code.visualstudio.com/>`_ is an IDE with "
"debugging tools that integrates with version-control software."
msgstr ""
"`Visual Studio Code <https://code.visualstudio.com/>`_ es un IDE con "
"herramientas de depuración que se integra con software de control de "
"versiones."

#: ../Doc/faq/programming.rst:46
msgid ""
"There are a number of commercial Python IDEs that include graphical "
"debuggers. They include:"
msgstr ""
"Existen varios IDEs comerciales para Python que incluyen depuradores "
"gráficos. Entre ellos tenemos:"

#: ../Doc/faq/programming.rst:49
msgid "`Wing IDE <https://wingware.com/>`_"
msgstr "`IDE Wing <https://wingware.com/>`_"

#: ../Doc/faq/programming.rst:50
msgid "`Komodo IDE <https://www.activestate.com/products/komodo-ide/>`_"
msgstr "`IDE Komodo <https://www.activestate.com/products/komodo-ide/>`_"

#: ../Doc/faq/programming.rst:51
msgid "`PyCharm <https://www.jetbrains.com/pycharm/>`_"
msgstr "`PyCharm <https://www.jetbrains.com/pycharm/>`_"

#: ../Doc/faq/programming.rst:55
msgid "Are there tools to help find bugs or perform static analysis?"
msgstr ""
"¿Existe alguna herramienta que ayude a encontrar errores o realizar análisis "
"estático?"

#: ../Doc/faq/programming.rst:59
#, fuzzy
msgid ""
"`Pylint <https://pylint.pycqa.org/en/latest/index.html>`_ and `Pyflakes "
"<https://github.com/PyCQA/pyflakes>`_ do basic checking that will help you "
"catch bugs sooner."
msgstr ""
"`Pylint <https://www.pylint.org/>`_ y `Pyflakes <https://github.com/PyCQA/"
"pyflakes>`_ realizan comprobaciones básicas que le ayudarán a detectar "
"errores antes."

#: ../Doc/faq/programming.rst:63
msgid ""
"Static type checkers such as `Mypy <http://mypy-lang.org/>`_, `Pyre <https://"
"pyre-check.org/>`_, and `Pytype <https://github.com/google/pytype>`_ can "
"check type hints in Python source code."
msgstr ""
"Inspectores estáticos de tipos como `Mypy <http://mypy-lang.org/>`_, `Pyre "
"<https://pyre-check.org/>`_, y `Pytype <https://github.com/google/pytype>`_ "
"pueden hacer comprobaciones de las anotaciones de tipos en código fuente "
"Python."

#: ../Doc/faq/programming.rst:72
msgid "How can I create a stand-alone binary from a Python script?"
msgstr ""
"¿Cómo puedo crear un binario independiente a partir de un programa Python?"

#: ../Doc/faq/programming.rst:74
msgid ""
"You don't need the ability to compile Python to C code if all you want is a "
"stand-alone program that users can download and run without having to "
"install the Python distribution first.  There are a number of tools that "
"determine the set of modules required by a program and bind these modules "
"together with a Python binary to produce a single executable."
msgstr ""
"No necesitas tener la habilidad de compilar Python a código C si lo único "
"que necesitas es un programa independiente que los usuarios puedan descargar "
"y ejecutar sin necesidad de instalar primero una distribución Python. Existe "
"una serie de herramientas que determinan el conjunto de módulos que necesita "
"un programa y une estos módulos conjuntamente con un binario Python para "
"generar un único ejecutable."

#: ../Doc/faq/programming.rst:80
#, fuzzy
msgid ""
"One is to use the freeze tool, which is included in the Python source tree "
"as ``Tools/freeze``. It converts Python byte code to C arrays; with a C "
"compiler you can embed all your modules into a new program, which is then "
"linked with the standard Python modules."
msgstr ""
"Una forma es usando la herramienta *freeze*, la cual viene incluida con el "
"árbol de código Python como ``Tools/freeze``. Convierte el byte code Python "
"a arrays C; un compilador C permite incrustar todos tus módulos en un nuevo "
"programa que, posteriormente se puede enlazar con los módulos estándar de "
"Python."

#: ../Doc/faq/programming.rst:85
msgid ""
"It works by scanning your source recursively for import statements (in both "
"forms) and looking for the modules in the standard Python path as well as in "
"the source directory (for built-in modules).  It then turns the bytecode for "
"modules written in Python into C code (array initializers that can be turned "
"into code objects using the marshal module) and creates a custom-made config "
"file that only contains those built-in modules which are actually used in "
"the program.  It then compiles the generated C code and links it with the "
"rest of the Python interpreter to form a self-contained binary which acts "
"exactly like your script."
msgstr ""
"Funciona escaneando su fuente de forma recursiva en busca de declaraciones "
"de importación (en ambas formas) y buscando los módulos en la ruta estándar "
"de Python, así como en el directorio de la fuente (para los módulos "
"incorporados).  Luego convierte el *bytecode* de los módulos escritos en "
"Python en código C (inicializadores de arrays que pueden ser convertidos en "
"objetos de código usando el módulo marshal) y crea un archivo de "
"configuración a medida que sólo contiene aquellos módulos incorporados que "
"se usan realmente en el programa.  A continuación, compila el código C "
"generado y lo enlaza con el resto del intérprete de Python para formar un "
"binario autónomo que actúa exactamente igual que su script."

#: ../Doc/faq/programming.rst:94
msgid ""
"The following packages can help with the creation of console and GUI "
"executables:"
msgstr ""
"Los siguientes paquetes pueden ayudar con la creación de ejecutables de "
"consola y GUI:"

#: ../Doc/faq/programming.rst:97
msgid "`Nuitka <https://nuitka.net/>`_ (Cross-platform)"
msgstr "`Nuitka <https://nuitka.net/>`_ (Multiplataforma)"

#: ../Doc/faq/programming.rst:98
#, fuzzy
msgid "`PyInstaller <https://pyinstaller.org/>`_ (Cross-platform)"
msgstr "`PyInstaller <http://www.pyinstaller.org/>`_ (Multiplataforma)"

#: ../Doc/faq/programming.rst:99
msgid ""
"`PyOxidizer <https://pyoxidizer.readthedocs.io/en/stable/>`_ (Cross-platform)"
msgstr ""
"`PyOxidizer <https://pyoxidizer.readthedocs.io/en/stable/>`_ "
"(Multiplataforma)"

#: ../Doc/faq/programming.rst:100
msgid ""
"`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ (Cross-platform)"
msgstr ""
"`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ (Multiplataforma)"

#: ../Doc/faq/programming.rst:101
msgid "`py2app <https://github.com/ronaldoussoren/py2app>`_ (macOS only)"
msgstr "`py2app <https://github.com/ronaldoussoren/py2app>`_ (macOS solamente)"

#: ../Doc/faq/programming.rst:102
#, fuzzy
msgid "`py2exe <https://www.py2exe.org/>`_ (Windows only)"
msgstr "`py2exe <http://www.py2exe.org/>`_ (solo Windows)"

#: ../Doc/faq/programming.rst:105
msgid "Are there coding standards or a style guide for Python programs?"
msgstr ""
"¿Existen estándares de código o una guía de estilo para programas Python?"

#: ../Doc/faq/programming.rst:107
msgid ""
"Yes.  The coding style required for standard library modules is documented "
"as :pep:`8`."
msgstr ""
"Sí. El estilo de código requerido para los módulos de la biblioteca estándar "
"se encuentra documentado como :pep:`8`."

#: ../Doc/faq/programming.rst:112
msgid "Core Language"
msgstr "Núcleo del lenguaje"

#: ../Doc/faq/programming.rst:115
msgid "Why am I getting an UnboundLocalError when the variable has a value?"
msgstr ""
"¿Por qué obtengo un *UnboundLocalError* cuando la variable tiene un valor?"

#: ../Doc/faq/programming.rst:117
msgid ""
"It can be a surprise to get the UnboundLocalError in previously working code "
"when it is modified by adding an assignment statement somewhere in the body "
"of a function."
msgstr ""
"Puede ser una sorpresa el hecho de obtener un UnboundLocalError en código "
"que había estado funcionando previamente cuando se modifica mediante el "
"añadido de una declaración de asignación en alguna parte del cuerpo de una "
"función."

#: ../Doc/faq/programming.rst:121
msgid "This code:"
msgstr "Este código:"

#: ../Doc/faq/programming.rst:129
msgid "works, but this code:"
msgstr "funciona, pero este código:"

#: ../Doc/faq/programming.rst:136
msgid "results in an UnboundLocalError:"
msgstr "resulta en un UnboundLocalError:"

#: ../Doc/faq/programming.rst:143
msgid ""
"This is because when you make an assignment to a variable in a scope, that "
"variable becomes local to that scope and shadows any similarly named "
"variable in the outer scope.  Since the last statement in foo assigns a new "
"value to ``x``, the compiler recognizes it as a local variable.  "
"Consequently when the earlier ``print(x)`` attempts to print the "
"uninitialized local variable and an error results."
msgstr ""
"Esto es debido a que cuando realizas una asignación a una variable en un  "
"ámbito de aplicación, esa variable se convierte en local y enmascara "
"cualquier variable llamada de forma similar en un ámbito de aplicación "
"exterior. Desde la última declaración en foo asigna un nuevo valor a ``x``, "
"el compilador la reconoce como una variable local. Consecuentemente, cuando "
"el ``print(x)`` más próximo intenta mostrar la variable local no "
"inicializada se muestra un error."

#: ../Doc/faq/programming.rst:150
msgid ""
"In the example above you can access the outer scope variable by declaring it "
"global:"
msgstr ""
"En el ejemplo anterior puedes acceder al ámbito de aplicación exterior a la "
"variable declarándola como global:"

#: ../Doc/faq/programming.rst:161
msgid ""
"This explicit declaration is required in order to remind you that (unlike "
"the superficially analogous situation with class and instance variables) you "
"are actually modifying the value of the variable in the outer scope:"
msgstr ""
"Esta declaración explícita es necesaria de cara a recordarte que (a "
"diferencia de la situación superficialmente análoga con las variables de "
"clase e instancia) estás modificando el valor de la variable en un ámbito de "
"aplicación más externo:"

#: ../Doc/faq/programming.rst:168
msgid ""
"You can do a similar thing in a nested scope using the :keyword:`nonlocal` "
"keyword:"
msgstr ""
"Puedes hacer algo similar en un ámbito de aplicación anidado usando la "
"palabra clave :keyword:`nonlocal`:"

#: ../Doc/faq/programming.rst:185
msgid "What are the rules for local and global variables in Python?"
msgstr ""
"¿Cuáles son las reglas para las variables locales y globales en Python?"

#: ../Doc/faq/programming.rst:187
msgid ""
"In Python, variables that are only referenced inside a function are "
"implicitly global.  If a variable is assigned a value anywhere within the "
"function's body, it's assumed to be a local unless explicitly declared as "
"global."
msgstr ""
"En Python, las variables que solo se encuentran referenciadas dentro de una "
"función son globales implícitamente.  Si a una variable se le asigna un "
"valor en cualquier lugar dentro del cuerpo de una función, se asumirá que es "
"local a no ser que explícitamente se la declare como global."

#: ../Doc/faq/programming.rst:191
msgid ""
"Though a bit surprising at first, a moment's consideration explains this.  "
"On one hand, requiring :keyword:`global` for assigned variables provides a "
"bar against unintended side-effects.  On the other hand, if ``global`` was "
"required for all global references, you'd be using ``global`` all the time.  "
"You'd have to declare as global every reference to a built-in function or to "
"a component of an imported module.  This clutter would defeat the usefulness "
"of the ``global`` declaration for identifying side-effects."
msgstr ""
"Aunque, inicialmente, puede parecer sorprendente, un momento de "
"consideración permite explicar esto.  Por una parte, requerir :keyword:"
"`global` para variables asignadas proporciona una barrera frente a efectos "
"secundarios indeseados.  Por otra parte, si ``global`` es requerido para "
"todas las referencias globales, deberás usar ``global`` en todo momento. "
"Deberías declarar como global cualquier referencia a una función integrada o "
"a un componente de un módulo importado. Este embrollo arruinaría la utilidad "
"de la declaración \"global\" para identificar los efectos secundarios."

#: ../Doc/faq/programming.rst:201
msgid ""
"Why do lambdas defined in a loop with different values all return the same "
"result?"
msgstr ""
"¿Por qué las funciones lambda definidas en un bucle con diferentes valores "
"devuelven todas el mismo resultado?"

#: ../Doc/faq/programming.rst:203
msgid ""
"Assume you use a for loop to define a few different lambdas (or even plain "
"functions), e.g.::"
msgstr ""
"Considera que usas un bucle *for* para crear unas pocas funciones lambda (o, "
"incluso, funciones normales), por ejemplo.::"

#: ../Doc/faq/programming.rst:210
msgid ""
"This gives you a list that contains 5 lambdas that calculate ``x**2``.  You "
"might expect that, when called, they would return, respectively, ``0``, "
"``1``, ``4``, ``9``, and ``16``.  However, when you actually try you will "
"see that they all return ``16``::"
msgstr ""
"Lo siguiente proporciona una lista que contiene 5 funciones lambda que "
"calculan ``x**2``. Esperarías que, cuando se les invoca, retornaran, "
"respectivamente, ``0``, ``1``, ``4``, ``9`` y ``16``. Sin embargo, cuando lo "
"ejecutes verás que todas devuelven ``16``::"

#: ../Doc/faq/programming.rst:220
msgid ""
"This happens because ``x`` is not local to the lambdas, but is defined in "
"the outer scope, and it is accessed when the lambda is called --- not when "
"it is defined.  At the end of the loop, the value of ``x`` is ``4``, so all "
"the functions now return ``4**2``, i.e. ``16``.  You can also verify this by "
"changing the value of ``x`` and see how the results of the lambdas change::"
msgstr ""
"Esto sucede porque ``x`` no es una función lambda local pero se encuentra "
"definida en un ámbito de aplicación externo y se accede cuando la lambda es "
"invocada --- no cuando ha sido definida.  Al final del bucle, el valor de "
"``x`` es ``4``, por tanto, ahora todas las funciones devuelven ``4**2``, i."
"e. ``16``. También puedes verificar esto mediante el cambio del valor de "
"``x`` y ver como los resultados de las lambdas cambian::"

#: ../Doc/faq/programming.rst:230
msgid ""
"In order to avoid this, you need to save the values in variables local to "
"the lambdas, so that they don't rely on the value of the global ``x``::"
msgstr ""
"De cara a evitar esto necesitas guardar los valores en variables locales a "
"las funciones lambda de tal forma que no dependan del valor de la  ``x`` "
"global::"

#: ../Doc/faq/programming.rst:237
msgid ""
"Here, ``n=x`` creates a new variable ``n`` local to the lambda and computed "
"when the lambda is defined so that it has the same value that ``x`` had at "
"that point in the loop.  This means that the value of ``n`` will be ``0`` in "
"the first lambda, ``1`` in the second, ``2`` in the third, and so on. "
"Therefore each lambda will now return the correct result::"
msgstr ""
"Aquí, ``n=x`` crea una nueva variable ``n`` local a la función lambda y "
"ejecutada cuando la función lambda se define de tal forma que tiene el mismo "
"valor que tenía ``x`` en ese punto en el bucle.  Esto significa que el valor "
"de ``n`` será ``0`` en la primera función lambda, ``1`` en la segunda, ``2`` "
"en la tercera y así sucesivamente. Por tanto, ahora cada lambda retornará el "
"resultado correcto::"

#: ../Doc/faq/programming.rst:248
msgid ""
"Note that this behaviour is not peculiar to lambdas, but applies to regular "
"functions too."
msgstr ""
"Es de destacar que este comportamiento no es peculiar de las funciones "
"lambda sino que aplica también a las funciones regulares."

#: ../Doc/faq/programming.rst:253
msgid "How do I share global variables across modules?"
msgstr "¿Cómo puedo compartir variables globales entre módulos?"

#: ../Doc/faq/programming.rst:255
msgid ""
"The canonical way to share information across modules within a single "
"program is to create a special module (often called config or cfg).  Just "
"import the config module in all modules of your application; the module then "
"becomes available as a global name.  Because there is only one instance of "
"each module, any changes made to the module object get reflected "
"everywhere.  For example:"
msgstr ""
"La forma canónica de compartir información entre módulos dentro de un mismo "
"programa sería creando un módulo especial (a menudo llamado config o cfg).  "
"Simplemente importa el módulo config  en todos los módulos de tu aplicación; "
"el módulo estará disponible como un nombre global.  Debido a que solo hay "
"una instancia de cada módulo, cualquier cambio hecho en el objeto módulo se "
"reflejará en todos los sitios.  Por ejemplo:"

#: ../Doc/faq/programming.rst:261
msgid "config.py::"
msgstr "config.py::"

#: ../Doc/faq/programming.rst:265
msgid "mod.py::"
msgstr "mod.py::"

#: ../Doc/faq/programming.rst:270
msgid "main.py::"
msgstr "main.py::"

#: ../Doc/faq/programming.rst:276
msgid ""
"Note that using a module is also the basis for implementing the Singleton "
"design pattern, for the same reason."
msgstr ""
"Ten en cuenta que usar un módulo es también la base para la implementación "
"del patrón de diseño Singleton, por la misma razón."

#: ../Doc/faq/programming.rst:281
msgid "What are the \"best practices\" for using import in a module?"
msgstr "¿Cuáles son las \"buenas prácticas\" para usar import en un módulo?"

#: ../Doc/faq/programming.rst:283
msgid ""
"In general, don't use ``from modulename import *``.  Doing so clutters the "
"importer's namespace, and makes it much harder for linters to detect "
"undefined names."
msgstr ""
"En general, no uses ``from modulename import *``.  Haciendo eso embarulla el "
"espacio de nombres del importador y hace que sea más difícil para los "
"*linters* el detectar los nombres sin definir."

#: ../Doc/faq/programming.rst:287
msgid ""
"Import modules at the top of a file.  Doing so makes it clear what other "
"modules your code requires and avoids questions of whether the module name "
"is in scope. Using one import per line makes it easy to add and delete "
"module imports, but using multiple imports per line uses less screen space."
msgstr ""
"Importar los módulos en la parte inicial del fichero. Haciéndolo así  deja "
"claro los módulos que son necesarios para tu código y evita preguntas sobre "
"si el nombre del módulo se encuentra en el ámbito de la aplicación. Usar una "
"importación por línea hace que sea sencillo añadir y eliminar módulos "
"importados pero usar múltiples importaciones por línea usa menos espacio de "
"pantalla."

#: ../Doc/faq/programming.rst:292
msgid "It's good practice if you import modules in the following order:"
msgstr "Es una buena práctica si importas los módulos en el orden siguiente:"

#: ../Doc/faq/programming.rst:294
msgid "standard library modules -- e.g. ``sys``, ``os``, ``getopt``, ``re``"
msgstr ""
"módulos de la biblioteca estándar -- por ejemplo, ``sys``, ``os``, "
"``getopt``, ``re``"

#: ../Doc/faq/programming.rst:295
msgid ""
"third-party library modules (anything installed in Python's site-packages "
"directory) -- e.g. mx.DateTime, ZODB, PIL.Image, etc."
msgstr ""
"módulos de bibliotecas de terceros (cualquier cosa instalada en el "
"directorio *site-packages* de Python) -- por ejemplo, mx.DateTime, ZODB, PIL."
"Image, etc."

#: ../Doc/faq/programming.rst:297
#, fuzzy
msgid "locally developed modules"
msgstr "módulos desarrollados localmente"

#: ../Doc/faq/programming.rst:299
msgid ""
"It is sometimes necessary to move imports to a function or class to avoid "
"problems with circular imports.  Gordon McMillan says:"
msgstr ""
"Hay veces en que es necesario mover las importaciones a una función o clase "
"para evitar problemas de importaciones circulares.  Gordon McMillan dice:"

#: ../Doc/faq/programming.rst:302
msgid ""
"Circular imports are fine where both modules use the \"import <module>\" "
"form of import.  They fail when the 2nd module wants to grab a name out of "
"the first (\"from module import name\") and the import is at the top level.  "
"That's because names in the 1st are not yet available, because the first "
"module is busy importing the 2nd."
msgstr ""
"No hay problema con las importaciones circulares cuando ambos módulos usan "
"la forma de importación \"import <module>\".  Fallará cuando el segundo "
"módulo quiera coger un nombre del primer módulo (\"from module import "
"name\") y la importación se encuentre en el nivel superior.  Esto sucede "
"porque los nombres en el primero todavía no se encuentran disponibles debido "
"a que el primer módulo se encuentra ocupado importando al segundo."

#: ../Doc/faq/programming.rst:308
msgid ""
"In this case, if the second module is only used in one function, then the "
"import can easily be moved into that function.  By the time the import is "
"called, the first module will have finished initializing, and the second "
"module can do its import."
msgstr ""
"En este caso, si el segundo módulo se usa solamente desde una función, la "
"importación se puede mover de forma sencilla dentro de la función. En el "
"momento en que se invoca a la importación el primer módulo habrá terminado "
"de inicializarse y el segundo módulo podrá hacer la importación."

#: ../Doc/faq/programming.rst:313
msgid ""
"It may also be necessary to move imports out of the top level of code if "
"some of the modules are platform-specific.  In that case, it may not even be "
"possible to import all of the modules at the top of the file.  In this case, "
"importing the correct modules in the corresponding platform-specific code is "
"a good option."
msgstr ""
"También podría ser necesario mover importaciones fuera del nivel superior "
"del código si alguno de loa módulos son específicos a la plataforma. En ese "
"caso podría, incluso, no ser posible importar todos los módulos en la parte "
"superior del fichero. Para esos casos, la importación correcta de los "
"módulos en el código correspondiente específico de la plataforma es una "
"buena opción."

#: ../Doc/faq/programming.rst:318
msgid ""
"Only move imports into a local scope, such as inside a function definition, "
"if it's necessary to solve a problem such as avoiding a circular import or "
"are trying to reduce the initialization time of a module.  This technique is "
"especially helpful if many of the imports are unnecessary depending on how "
"the program executes.  You may also want to move imports into a function if "
"the modules are only ever used in that function.  Note that loading a module "
"the first time may be expensive because of the one time initialization of "
"the module, but loading a module multiple times is virtually free, costing "
"only a couple of dictionary lookups.  Even if the module name has gone out "
"of scope, the module is probably available in :data:`sys.modules`."
msgstr ""
"Solo debes mover importaciones a un ámbito de aplicación local, como dentro "
"de la definición de una función, si es necesario resolver problemas como una "
"importación circular o al intentar reducir el tiempo de inicialización de un "
"módulo. Esta técnica es especialmente útil si muchas de las importaciones no "
"son necesarias dependiendo de cómo se ejecute el programa. También podrías "
"mover importaciones a una función si los módulos solo se usan dentro de esa "
"función. Nótese que la primera carga de un módulo puede ser costosa debido "
"al tiempo necesario para la inicialización del módulo,pero la carga de un "
"módulo múltiples veces está prácticamente libre de coste ya que solo es "
"necesario hacer búsquedas en un diccionario. Incluso si el nombre del módulo "
"ha salido del ámbito de aplicación el módulo se encuentre, probablemente, "
"en :data:`sys.modules`."

#: ../Doc/faq/programming.rst:331
msgid "Why are default values shared between objects?"
msgstr "¿Por qué los valores por defecto se comparten entre objetos?"

#: ../Doc/faq/programming.rst:333
msgid ""
"This type of bug commonly bites neophyte programmers.  Consider this "
"function::"
msgstr ""
"Este tipo de error golpea a menudo a programadores novatos. Considera esta "
"función::"

#: ../Doc/faq/programming.rst:340
msgid ""
"The first time you call this function, ``mydict`` contains a single item.  "
"The second time, ``mydict`` contains two items because when ``foo()`` begins "
"executing, ``mydict`` starts out with an item already in it."
msgstr ""
"La primera vez que llamas a esta función, ``mydict`` solamente contiene un "
"único elemento. La segunda vez, ``mydict`` contiene dos elementos debido a "
"que cuando comienza la ejecución de ``foo()``, ``mydict`` comienza "
"conteniendo un elemento de partida."

#: ../Doc/faq/programming.rst:344
msgid ""
"It is often expected that a function call creates new objects for default "
"values. This is not what happens. Default values are created exactly once, "
"when the function is defined.  If that object is changed, like the "
"dictionary in this example, subsequent calls to the function will refer to "
"this changed object."
msgstr ""
"A menudo se esperaría que una invocación a una función cree nuevos objetos "
"para valores por defecto. Eso no es lo que realmente sucede. Los valores por "
"defecto se crean exactamente una sola vez, cuando se define la función. Se "
"se cambia el objeto, como el diccionario en este ejemplo, posteriores "
"invocaciones a la función estarán referidas al objeto cambiado."

#: ../Doc/faq/programming.rst:349
msgid ""
"By definition, immutable objects such as numbers, strings, tuples, and "
"``None``, are safe from change. Changes to mutable objects such as "
"dictionaries, lists, and class instances can lead to confusion."
msgstr ""
"Por definición, los objetos inmutables como números, cadenas, tuplas y "
"``None`` están asegurados frente al cambio. Cambios en objetos mutables como "
"diccionarios, listas e instancias de clase pueden llevar a confusión."

#: ../Doc/faq/programming.rst:353
msgid ""
"Because of this feature, it is good programming practice to not use mutable "
"objects as default values.  Instead, use ``None`` as the default value and "
"inside the function, check if the parameter is ``None`` and create a new "
"list/dictionary/whatever if it is.  For example, don't write::"
msgstr ""
"Debido a esta característica es una buena práctica de programación el no "
"usar valores mutables como valores por defecto. En su lugar usa ``None`` "
"como valor por defecto dentro de la función, comprueba si el parámetro es "
"``None`` y crea una nueva lista/un nuevo diccionario/cualquier otras cosa "
"que necesites.  Por ejemplo, no escribas::"

#: ../Doc/faq/programming.rst:361
msgid "but::"
msgstr "pero::"

#: ../Doc/faq/programming.rst:367
msgid ""
"This feature can be useful.  When you have a function that's time-consuming "
"to compute, a common technique is to cache the parameters and the resulting "
"value of each call to the function, and return the cached value if the same "
"value is requested again.  This is called \"memoizing\", and can be "
"implemented like this::"
msgstr ""
"Esta característica puede ser útil. Cuando tienes una función que es muy "
"costosa de ejecutar, una técnica común es *cachear* sus parámetros y el "
"valor resultante de cada invocación a la función y retornar el valor "
"*cacheado* si se solicita nuevamente el mismo valor.  A esto se le llama "
"\"memoizing\" y se puede implementar de la siguiente forma::"

#: ../Doc/faq/programming.rst:382
msgid ""
"You could use a global variable containing a dictionary instead of the "
"default value; it's a matter of taste."
msgstr ""
"Podrías usar una variable global conteniendo un diccionario en lugar de un "
"valor por defecto; es una cuestión de gustos."

#: ../Doc/faq/programming.rst:387
msgid ""
"How can I pass optional or keyword parameters from one function to another?"
msgstr ""
"¿Cómo puedo pasar parámetros por palabra clave u opcionales de una función a "
"otra?"

#: ../Doc/faq/programming.rst:389
msgid ""
"Collect the arguments using the ``*`` and ``**`` specifiers in the "
"function's parameter list; this gives you the positional arguments as a "
"tuple and the keyword arguments as a dictionary.  You can then pass these "
"arguments when calling another function by using ``*`` and ``**``::"
msgstr ""
"Recopila los argumentos usando los especificadores ``*`` y ``**`` en la "
"lista de parámetros de la función; esto te proporciona los argumentos "
"posicionales como una tupla y los argumentos con palabras clave como un "
"diccionario.  Puedes, entonces, pasar estos argumentos cuando invoques a "
"otra función usando ``*`` y ``**``::"

#: ../Doc/faq/programming.rst:408
msgid "What is the difference between arguments and parameters?"
msgstr "¿Cuál es la diferencia entre argumentos y parámetros?"

#: ../Doc/faq/programming.rst:410
#, fuzzy
msgid ""
":term:`Parameters <parameter>` are defined by the names that appear in a "
"function definition, whereas :term:`arguments <argument>` are the values "
"actually passed to a function when calling it.  Parameters define what :term:"
"`kind of arguments <parameter>` a function can accept.  For example, given "
"the function definition::"
msgstr ""
":term:`Parámetros <parameter>` se definen mediante los nombres que aparecen "
"en la definición de una función mientras que :term:`argumentos <argument>` "
"son los valores que se pasan a la función cuando la invocamos.  Los "
"Parámetros definen qué tipos de argumentos puede aceptar una función.  por "
"ejemplo, dada la definición de la función::"

#: ../Doc/faq/programming.rst:419
msgid ""
"*foo*, *bar* and *kwargs* are parameters of ``func``.  However, when calling "
"``func``, for example::"
msgstr ""
"*foo*, *bar* y *kwargs* son parámetros de ``func``.  Sin embargo, cuando "
"invocamos a ``func``, por ejemplo::"

#: ../Doc/faq/programming.rst:424
msgid "the values ``42``, ``314``, and ``somevar`` are arguments."
msgstr "los valores ``42``, ``314`` y ``somevar`` son argumentos."

#: ../Doc/faq/programming.rst:428
msgid "Why did changing list 'y' also change list 'x'?"
msgstr "¿Por qué cambiando la lista 'y' cambia, también, la lista 'x'?"

#: ../Doc/faq/programming.rst:430
msgid "If you wrote code like::"
msgstr "Si escribes código como::"

#: ../Doc/faq/programming.rst:440
msgid ""
"you might be wondering why appending an element to ``y`` changed ``x`` too."
msgstr ""
"te estarás preguntando porque añadir un elemento a ``y`` ha cambiado también "
"a ``x``."

#: ../Doc/faq/programming.rst:442
msgid "There are two factors that produce this result:"
msgstr "Hay dos factores que provocan este resultado:"

#: ../Doc/faq/programming.rst:444
msgid ""
"Variables are simply names that refer to objects.  Doing ``y = x`` doesn't "
"create a copy of the list -- it creates a new variable ``y`` that refers to "
"the same object ``x`` refers to.  This means that there is only one object "
"(the list), and both ``x`` and ``y`` refer to it."
msgstr ""
"Las variables son simplemente nombres que referencian a objetos.  Haciendo "
"``y = x`` no crea una copia de la lista -- crea una nueva variable ``y`` que "
"referencia al mismo objeto al que referencia ``x`` .  Esto significa que "
"solo existe un objeto (la lista) y tanto ``x`` como ``y`` hacen referencia "
"al mismo."

#: ../Doc/faq/programming.rst:448
msgid ""
"Lists are :term:`mutable`, which means that you can change their content."
msgstr ""
"Las listas son :term:`mutable`, lo que significa que puedes cambiar su "
"contenido."

#: ../Doc/faq/programming.rst:450
msgid ""
"After the call to :meth:`~list.append`, the content of the mutable object "
"has changed from ``[]`` to ``[10]``.  Since both the variables refer to the "
"same object, using either name accesses the modified value ``[10]``."
msgstr ""
"Después de la invocación a :meth:`~list.append`, el contenido del objeto "
"mutable ha cambiado de ``[]`` a ``[10]``.  Ya que ambas variables "
"referencian al mismo objeto, el usar cualquiera de los nombres accederá al "
"valor modificado ``[10]``."

#: ../Doc/faq/programming.rst:454
msgid "If we instead assign an immutable object to ``x``::"
msgstr "Si, por otra parte, asignamos un objeto inmutable a ``x``::"

#: ../Doc/faq/programming.rst:464
msgid ""
"we can see that in this case ``x`` and ``y`` are not equal anymore.  This is "
"because integers are :term:`immutable`, and when we do ``x = x + 1`` we are "
"not mutating the int ``5`` by incrementing its value; instead, we are "
"creating a new object (the int ``6``) and assigning it to ``x`` (that is, "
"changing which object ``x`` refers to).  After this assignment we have two "
"objects (the ints ``6`` and ``5``) and two variables that refer to them "
"(``x`` now refers to ``6`` but ``y`` still refers to ``5``)."
msgstr ""
"podemos ver que ``x`` e ``y`` ya no son iguales.  Esto es debido a que los "
"enteros son :term:`immutable`, y cuando hacemos ``x = x + 1`` no estamos "
"mutando el entero ``5`` incrementando su valor; en su lugar, estamos creando "
"un nuevo objeto (el entero ``6``) y se lo asignamos a ``x`` (esto es, "
"cambiando el objeto al cual referencia ``x``).  Después de esta asignación "
"tenemos dos objetos (los enteros ``6`` y ``5``) y dos variables que "
"referencian a ellos (``x`` ahora referencia a  ``6`` pero ``y`` todavía "
"referencia a ``5``)."

#: ../Doc/faq/programming.rst:472
msgid ""
"Some operations (for example ``y.append(10)`` and ``y.sort()``) mutate the "
"object, whereas superficially similar operations (for example ``y = y + "
"[10]`` and ``sorted(y)``) create a new object.  In general in Python (and in "
"all cases in the standard library) a method that mutates an object will "
"return ``None`` to help avoid getting the two types of operations confused.  "
"So if you mistakenly write ``y.sort()`` thinking it will give you a sorted "
"copy of ``y``, you'll instead end up with ``None``, which will likely cause "
"your program to generate an easily diagnosed error."
msgstr ""
"Algunas operaciones (por ejemplo ``y.append(10)`` y ``y.sort()``) mutan al "
"objeto mientras que operaciones que podrían parecer similares (por ejemplo "
"``y = y + [10]`` y ``sorted(y)``) crean un nuevo objeto.  En general, en "
"Python (y en todo momento en la biblioteca estándar) un método que muta un "
"objeto retornará ``None`` para evitar tener dos tipos de operaciones que "
"puedan ser confusas.  Por tanto, si escribes accidentalmente ``y.sort()`` "
"pensando que te retornará una copia ordenada de ``y``, obtendrás, en su "
"lugar, ``None``, lo cual ayudará a que tu programa genera un error que pueda "
"ser diagnosticado fácilmente."

#: ../Doc/faq/programming.rst:481
msgid ""
"However, there is one class of operations where the same operation sometimes "
"has different behaviors with different types:  the augmented assignment "
"operators.  For example, ``+=`` mutates lists but not tuples or ints "
"(``a_list += [1, 2, 3]`` is equivalent to ``a_list.extend([1, 2, 3])`` and "
"mutates ``a_list``, whereas ``some_tuple += (1, 2, 3)`` and ``some_int += "
"1`` create new objects)."
msgstr ""
"Sin embargo, existe una clase de operaciones en las cuales la misma "
"operación tiene, a veces, distintos comportamientos con diferentes tipos:  "
"los operadores de asignación aumentada.  Por ejemplo, ``+=`` muta listas "
"pero no tuplas o enteros (``a_list += [1, 2, 3]`` es equivalente a ``a_list."
"extend([1, 2, 3])`` y muta ``a_list``, mientras que ``some_tuple += (1, 2, "
"3)`` y ``some_int += 1`` crea nuevos objetos)."

#: ../Doc/faq/programming.rst:488
msgid "In other words:"
msgstr "En otras palabras:"

#: ../Doc/faq/programming.rst:490
msgid ""
"If we have a mutable object (:class:`list`, :class:`dict`, :class:`set`, "
"etc.), we can use some specific operations to mutate it and all the "
"variables that refer to it will see the change."
msgstr ""
"Si tenemos un objeto mutable (:class:`list`, :class:`dict`, :class:`set`, "
"etc.), podemos usar algunas operaciones específicas para mutarlo y todas las "
"variables que referencian al mismo verán el cambio reflejado."

#: ../Doc/faq/programming.rst:493
msgid ""
"If we have an immutable object (:class:`str`, :class:`int`, :class:`tuple`, "
"etc.), all the variables that refer to it will always see the same value, "
"but operations that transform that value into a new value always return a "
"new object."
msgstr ""
"Si tenemos un objeto inmutable (:class:`str`, :class:`int`, :class:`tuple`, "
"etc.), todas las variables que referencian al mismo verán siempre el mismo "
"valor pero las operaciones que transforman ese valor en un nuevo valor "
"siempre retornan un nuevo objeto."

#: ../Doc/faq/programming.rst:498
msgid ""
"If you want to know if two variables refer to the same object or not, you "
"can use the :keyword:`is` operator, or the built-in function :func:`id`."
msgstr ""
"Si deseas saber si dos variables referencian o no al mismo objeto puedes "
"usar el operador :keyword:`is` o la función incorporada :func:`id`."

#: ../Doc/faq/programming.rst:503
msgid "How do I write a function with output parameters (call by reference)?"
msgstr ""
"¿Cómo puedo escribir una función sin parámetros (invocación mediante "
"referencia)?"

#: ../Doc/faq/programming.rst:505
msgid ""
"Remember that arguments are passed by assignment in Python.  Since "
"assignment just creates references to objects, there's no alias between an "
"argument name in the caller and callee, and so no call-by-reference per se.  "
"You can achieve the desired effect in a number of ways."
msgstr ""
"Recuerda que los argumentos son pasados mediante asignación en Python.  Ya "
"que las asignaciones simplemente crean referencias a objetos, no hay alias "
"entre el nombre de un argumento en el invocador y el invocado y, por tanto, "
"no hay invocación por referencia per se.  Puedes obtener el mismo efecto "
"deseado de formas distintas."

#: ../Doc/faq/programming.rst:510
msgid "By returning a tuple of the results::"
msgstr "Mediante el retorno de una tupla de resultados::"

#: ../Doc/faq/programming.rst:521
msgid "This is almost always the clearest solution."
msgstr "Esta es, casi siempre, la solución más clara."

#: ../Doc/faq/programming.rst:523
msgid ""
"By using global variables.  This isn't thread-safe, and is not recommended."
msgstr ""
"Mediante el uso de variables globales.  No es thread-safe y no se recomienda."

#: ../Doc/faq/programming.rst:525
msgid "By passing a mutable (changeable in-place) object::"
msgstr "Pasando un objeto mutable (intercambiable en el mismo sitio)::"

#: ../Doc/faq/programming.rst:536
msgid "By passing in a dictionary that gets mutated::"
msgstr "Pasando un diccionario que muta::"

#: ../Doc/faq/programming.rst:547
msgid "Or bundle up values in a class instance::"
msgstr "O empaquetar valores en una instancia de clase::"

#: ../Doc/faq/programming.rst:564
msgid "There's almost never a good reason to get this complicated."
msgstr "Casi nunca existe una buena razón para hacer esto tan complicado."

#: ../Doc/faq/programming.rst:566
msgid "Your best choice is to return a tuple containing the multiple results."
msgstr ""
"Tu mejor opción es retornar una tupla que contenga los múltiples resultados."

#: ../Doc/faq/programming.rst:570
msgid "How do you make a higher order function in Python?"
msgstr "¿Cómo se puede hacer una función de orden superior en Python?"

#: ../Doc/faq/programming.rst:572
msgid ""
"You have two choices: you can use nested scopes or you can use callable "
"objects. For example, suppose you wanted to define ``linear(a,b)`` which "
"returns a function ``f(x)`` that computes the value ``a*x+b``.  Using nested "
"scopes::"
msgstr ""
"Tienes dos opciones: puedes usar ámbitos de aplicación anidados o puedes "
"usar objetos invocables. Por ejemplo, supón que querías definir ``linear(a,"
"b)`` que devuelve una función ``f(x)`` que calcula el valor ``a*x+b``.  Usar "
"ámbitos de aplicación anidados::"

#: ../Doc/faq/programming.rst:581
msgid "Or using a callable object::"
msgstr "O usar un objeto invocable::"

#: ../Doc/faq/programming.rst:591
msgid "In both cases, ::"
msgstr "En ambos casos, ::"

#: ../Doc/faq/programming.rst:595
msgid "gives a callable object where ``taxes(10e6) == 0.3 * 10e6 + 2``."
msgstr "nos da un objeto invocable donde ``taxes(10e6) == 0.3 * 10e6 + 2``."

#: ../Doc/faq/programming.rst:597
msgid ""
"The callable object approach has the disadvantage that it is a bit slower "
"and results in slightly longer code.  However, note that a collection of "
"callables can share their signature via inheritance::"
msgstr ""
"El enfoque del objeto invocable tiene la desventaja que es un ligeramente "
"más lento y el resultado es un código levemente más largo.  Sin embargo, "
"destacar que una colección de invocables pueden compartir su firma vía "
"herencia::"

#: ../Doc/faq/programming.rst:606
msgid "Object can encapsulate state for several methods::"
msgstr "Los objetos pueden encapsular el estado de varios métodos::"

#: ../Doc/faq/programming.rst:624
msgid ""
"Here ``inc()``, ``dec()`` and ``reset()`` act like functions which share the "
"same counting variable."
msgstr ""
"Aquí ``inc()``, ``dec()`` y ``reset()`` se comportan como funciones las "
"cuales comparten la misma variable de conteo."

#: ../Doc/faq/programming.rst:629
msgid "How do I copy an object in Python?"
msgstr "¿Cómo copio un objeto en Python?"

#: ../Doc/faq/programming.rst:631
msgid ""
"In general, try :func:`copy.copy` or :func:`copy.deepcopy` for the general "
"case. Not all objects can be copied, but most can."
msgstr ""
"En general, prueba :func:`copy.copy` o :func:`copy.deepcopy` para el caso "
"general. No todos los objetos se pueden copiar pero la mayoría sí que pueden "
"copiarse."

#: ../Doc/faq/programming.rst:634
msgid ""
"Some objects can be copied more easily.  Dictionaries have a :meth:`~dict."
"copy` method::"
msgstr ""
"Algunas objetos se pueden copiar de forma más sencilla. Los diccionarios "
"disponen de un método :meth:`~dict.copy`::"

#: ../Doc/faq/programming.rst:639
msgid "Sequences can be copied by slicing::"
msgstr "Las secuencias se pueden copiar usando un rebanado::"

#: ../Doc/faq/programming.rst:645
msgid "How can I find the methods or attributes of an object?"
msgstr "¿Cómo puedo encontrar los métodos o atributos de un objeto?"

#: ../Doc/faq/programming.rst:647
msgid ""
"For an instance x of a user-defined class, ``dir(x)`` returns an "
"alphabetized list of the names containing the instance attributes and "
"methods and attributes defined by its class."
msgstr ""
"Para la instancia x de una clase definida por el usuario, ``dir(x)`` "
"devuelve una lista de nombres ordenados alfabéticamente que contiene los "
"atributos y métodos de la instancia y los atributos definidos mediante su "
"clase."

#: ../Doc/faq/programming.rst:653
msgid "How can my code discover the name of an object?"
msgstr "¿Cómo puede mi código descubrir el nombre de un objeto?"

#: ../Doc/faq/programming.rst:655
msgid ""
"Generally speaking, it can't, because objects don't really have names. "
"Essentially, assignment always binds a name to a value; the same is true of "
"``def`` and ``class`` statements, but in that case the value is a callable. "
"Consider the following code::"
msgstr ""
"Hablando de forma general no podrían puesto que los objetos no disponen, "
"realmente, de un nombre. Esencialmente, las asignaciones relacionan un "
"nombre con su valor; Lo mismo se cumple con las declaraciones ``def`` y "
"``class`` pero, en este caso, el valor es un invocable. Considera el "
"siguiente código::"

#: ../Doc/faq/programming.rst:671
msgid ""
"Arguably the class has a name: even though it is bound to two names and "
"invoked through the name B the created instance is still reported as an "
"instance of class A.  However, it is impossible to say whether the "
"instance's name is a or b, since both names are bound to the same value."
msgstr ""
"Podría decirse que la clase tiene un nombre: aunque está ligada a dos "
"nombres y se invoca a través del nombre B, la instancia creada se sigue "
"reportando como una instancia de la clase A. Sin embargo, es imposible decir "
"si el nombre de la instancia es a o b, ya que ambos nombres están ligados al "
"mismo valor."

#: ../Doc/faq/programming.rst:676
msgid ""
"Generally speaking it should not be necessary for your code to \"know the "
"names\" of particular values. Unless you are deliberately writing "
"introspective programs, this is usually an indication that a change of "
"approach might be beneficial."
msgstr ""
"En términos generales, no debería ser necesario que tu código \"conozca los "
"nombres\" de determinados valores. A menos que estés escribiendo "
"deliberadamente programas introspectivos, esto suele ser una indicación de "
"que un cambio de enfoque podría ser beneficioso."

#: ../Doc/faq/programming.rst:681
msgid ""
"In comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer "
"to this question:"
msgstr ""
"En comp.lang.python, Fredrik Lundh proporcionó una vez una excelente "
"analogía en respuesta a esta pregunta:"

#: ../Doc/faq/programming.rst:684
msgid ""
"The same way as you get the name of that cat you found on your porch: the "
"cat (object) itself cannot tell you its name, and it doesn't really care -- "
"so the only way to find out what it's called is to ask all your neighbours "
"(namespaces) if it's their cat (object)..."
msgstr ""
"De la misma forma que obtienes el nombre de ese gato que te has encontrado "
"en tu porche el propio gato (objeto) no te puede indicar su nombre y, "
"realmente, no importa -- por tanto, la única forma de encontrar cómo se "
"llama sería preguntando a todos los vecinos (espacios de nombres) si es su "
"gato (objeto)..."

#: ../Doc/faq/programming.rst:689
msgid ""
"....and don't be surprised if you'll find that it's known by many names, or "
"no name at all!"
msgstr ""
"...y no te sorprendas si encuentras que se le conoce mediante diferentes "
"nombres o ¡nadie conoce su nombre!"

#: ../Doc/faq/programming.rst:694
msgid "What's up with the comma operator's precedence?"
msgstr "¿Qué ocurre con la precedencia del operador coma?"

#: ../Doc/faq/programming.rst:696
msgid "Comma is not an operator in Python.  Consider this session::"
msgstr "La coma no es un operador en Python. Considera la sesión::"

#: ../Doc/faq/programming.rst:701
msgid ""
"Since the comma is not an operator, but a separator between expressions the "
"above is evaluated as if you had entered::"
msgstr ""
"Debido a que la coma no es un operador sino un  separador entre expresiones "
"lo anterior se evalúe como se ha introducido::"

#: ../Doc/faq/programming.rst:706
msgid "not::"
msgstr "no::"

#: ../Doc/faq/programming.rst:710
msgid ""
"The same is true of the various assignment operators (``=``, ``+=`` etc).  "
"They are not truly operators but syntactic delimiters in assignment "
"statements."
msgstr ""
"Lo mismo sucede con varios operadores de asignación (``=``, ``+=``, etc).  "
"No son realmente operadores sino delimitadores sintácticos en declaraciones "
"de asignación."

#: ../Doc/faq/programming.rst:715
msgid "Is there an equivalent of C's \"?:\" ternary operator?"
msgstr "¿Existe un equivalente al operador ternario de C \"?:\"?"

#: ../Doc/faq/programming.rst:717
msgid "Yes, there is. The syntax is as follows::"
msgstr "Sí, existe. La sintaxis es como sigue::"

#: ../Doc/faq/programming.rst:724
msgid ""
"Before this syntax was introduced in Python 2.5, a common idiom was to use "
"logical operators::"
msgstr ""
"Antes de que esta sintaxis se introdujera en Python 2.5 una expresión común "
"fue el uso de operadores lógicos::"

#: ../Doc/faq/programming.rst:729
msgid ""
"However, this idiom is unsafe, as it can give wrong results when *on_true* "
"has a false boolean value.  Therefore, it is always better to use the ``... "
"if ... else ...`` form."
msgstr ""
"Sin embargo, esa expresión no es segura ya que puede retornar valores "
"erróneos cuando *on_true* tiene un valor booleano falso.  Por tanto, siempre "
"es mejor usar la forma ``... if ... else ...``."

#: ../Doc/faq/programming.rst:735
msgid "Is it possible to write obfuscated one-liners in Python?"
msgstr ""
"¿Es posible escribir expresiones en una línea de forma ofuscada en Python?"

#: ../Doc/faq/programming.rst:737
#, fuzzy
msgid ""
"Yes.  Usually this is done by nesting :keyword:`lambda` within :keyword:`!"
"lambda`.  See the following three examples, slightly adapted from Ulf "
"Bartelt::"
msgstr ""
"Sí.  Normalmente se puede hacer anidando :keyword:`lambda` dentro de :"
"keyword:`!lambda`.  Examina los siguientes tres ejemplos, creados por Ulf "
"Bartelt::"

#: ../Doc/faq/programming.rst:764
msgid "Don't try this at home, kids!"
msgstr "¡No probéis esto en casa, personitas!"

#: ../Doc/faq/programming.rst:770
msgid "What does the slash(/) in the parameter list of a function mean?"
msgstr ""
"¿Qué hace la barra (/) en medio de la lista de parámetros de una función?"

#: ../Doc/faq/programming.rst:772
#, fuzzy
msgid ""
"A slash in the argument list of a function denotes that the parameters prior "
"to it are positional-only.  Positional-only parameters are the ones without "
"an externally usable name.  Upon calling a function that accepts positional-"
"only parameters, arguments are mapped to parameters based solely on their "
"position. For example, :func:`divmod` is a function that accepts positional-"
"only parameters. Its documentation looks like this::"
msgstr ""
"Un *slash* en la lista de argumentos de una función denota que los "
"parámetros previos al mismo son únicamente posicionales.  Parámetros "
"únicamente posicionales son aquellos cuyos nombres no son usables "
"internamente.  Mediante la llamada a una función que acepta parámetros "
"únicamente posicionales, los argumentos se mapean a parámetros basados "
"únicamente en su posición. Por ejemplo, :func:`pow` es una función que "
"acepta parámetros únicamente posicionales. Su documentación es de la "
"siguiente forma::"

#: ../Doc/faq/programming.rst:785
msgid ""
"The slash at the end of the parameter list means that both parameters are "
"positional-only. Thus, calling :func:`divmod` with keyword arguments would "
"lead to an error::"
msgstr ""
"El *slash* al final de la lista de parámetros indica que los tres parámetros "
"son únicamente posicionales. Por tanto, invocar a  :func:`pow` con "
"argumentos con palabra clave podría derivar en un error::"

#: ../Doc/faq/programming.rst:796
msgid "Numbers and strings"
msgstr "Números y cadenas"

#: ../Doc/faq/programming.rst:799
msgid "How do I specify hexadecimal and octal integers?"
msgstr "¿Cómo puedo especificar enteros hexadecimales y octales?"

#: ../Doc/faq/programming.rst:801
msgid ""
"To specify an octal digit, precede the octal value with a zero, and then a "
"lower or uppercase \"o\".  For example, to set the variable \"a\" to the "
"octal value \"10\" (8 in decimal), type::"
msgstr ""
"Para especificar un dígito octal, prefija el valor octal con un cero y una "
"\"o\" en minúscula o mayúscula.  Por ejemplo, para definir la variable \"a\" "
"con el valor octal \"10\" (8 en decimal), escribe::"

#: ../Doc/faq/programming.rst:809
msgid ""
"Hexadecimal is just as easy.  Simply precede the hexadecimal number with a "
"zero, and then a lower or uppercase \"x\".  Hexadecimal digits can be "
"specified in lower or uppercase.  For example, in the Python interpreter::"
msgstr ""
"Un hexadecimal es igual de simple.  Simplemente añade un cero y una \"x\", "
"en minúscula o mayúscula, antes del número hexadecimal . Los dígitos "
"hexadecimales se pueden especificar en minúsculas o mayúsculas.  Por "
"ejemplo, en el intérprete de Python::"

#: ../Doc/faq/programming.rst:822
msgid "Why does -22 // 10 return -3?"
msgstr "¿Por qué -22 // 10 devuelve -3?"

#: ../Doc/faq/programming.rst:824
msgid ""
"It's primarily driven by the desire that ``i % j`` have the same sign as "
"``j``. If you want that, and also want::"
msgstr ""
"Es debido, principalmente al deseo que ``i % j`` tenga el mismo signo que "
"``j``. Si quieres eso y, además, quieres::"

#: ../Doc/faq/programming.rst:829
msgid ""
"then integer division has to return the floor.  C also requires that "
"identity to hold, and then compilers that truncate ``i // j`` need to make "
"``i % j`` have the same sign as ``i``."
msgstr ""
"entonces la división entera debe retornar el valor base más bajo.  C también "
"requiere que esa esa identidad se mantenga de tal forma que cuando los "
"compiladores truncan ``i // j`` necesitan que ``i % j`` tenga el mismo signo "
"que ``i``."

#: ../Doc/faq/programming.rst:833
msgid ""
"There are few real use cases for ``i % j`` when ``j`` is negative.  When "
"``j`` is positive, there are many, and in virtually all of them it's more "
"useful for ``i % j`` to be ``>= 0``.  If the clock says 10 now, what did it "
"say 200 hours ago?  ``-190 % 12 == 2`` is useful; ``-190 % 12 == -10`` is a "
"bug waiting to bite."
msgstr ""
"Existen unos pocos casos para ``i % j`` cuando ``j`` es negativo.  Cuando "
"``j`` es positivo, existen muchos casos y, virtualmente, en todos ellos es "
"más útil para ``i % j`` que sea ``>= 0``.  Si el reloj dice que ahora son "
"las 10, ¿qué dijo hace 200 horas?  ``-190 % 12 == 2`` es útil; ``-190 % 12 "
"== -10`` es un error listo para morderte."

#: ../Doc/faq/programming.rst:841
msgid "How do I get int literal attribute instead of SyntaxError?"
msgstr "¿Cómo puedo obtener un atributo int literal en lugar de SyntaxError?"

#: ../Doc/faq/programming.rst:843
msgid ""
"Trying to lookup an ``int`` literal attribute in the normal manner gives a "
"syntax error because the period is seen as a decimal point::"
msgstr ""
"Al intentar buscar un atributo literal ``int`` de la manera normal se "
"obtiene un error de sintaxis porque el punto es interpretado como un punto "
"decimal::"

#: ../Doc/faq/programming.rst:852
msgid ""
"The solution is to separate the literal from the period with either a space "
"or parentheses."
msgstr ""
"La solución es separar el literal del punto con un espacio o un paréntesis."

#: ../Doc/faq/programming.rst:862
msgid "How do I convert a string to a number?"
msgstr "¿Cómo convierto una cadena a un número?"

#: ../Doc/faq/programming.rst:864
msgid ""
"For integers, use the built-in :func:`int` type constructor, e.g. "
"``int('144') == 144``.  Similarly, :func:`float` converts to floating-point, "
"e.g. ``float('144') == 144.0``."
msgstr ""
"Para enteros puedes usar la función incorporada constructor de tipos :func:"
"`int`, por ejemplo ``int('144') == 144``.  De forma similar, :func:`float` "
"convierte a un número de coma flotante, por ejemplo ``float('144') == "
"144.0``."

#: ../Doc/faq/programming.rst:868
msgid ""
"By default, these interpret the number as decimal, so that ``int('0144') == "
"144`` holds true, and ``int('0x144')`` raises :exc:`ValueError`. "
"``int(string, base)`` takes the base to convert from as a second optional "
"argument, so ``int( '0x144', 16) == 324``.  If the base is specified as 0, "
"the number is interpreted using Python's rules: a leading '0o' indicates "
"octal, and '0x' indicates a hex number."
msgstr ""
"Por defecto, estas interpretan el número como decimal de tal forma que "
"``int('0144') == 144`` y ``int('0x144')`` lanzará :exc:`ValueError`. "
"``int(string, base)`` toma la base para convertirlo desde un segundo "
"parámetro opcional, por tanto ``int('0x144', 16) == 324``. Si la base se "
"especifica como 0, el número se interpreta usando las reglas de Python's "
"rules: un prefijo '0o' indica octal y un prefijo '0x' indica un número "
"hexadecimal."

#: ../Doc/faq/programming.rst:875
msgid ""
"Do not use the built-in function :func:`eval` if all you need is to convert "
"strings to numbers.  :func:`eval` will be significantly slower and it "
"presents a security risk: someone could pass you a Python expression that "
"might have unwanted side effects.  For example, someone could pass "
"``__import__('os').system(\"rm -rf $HOME\")`` which would erase your home "
"directory."
msgstr ""
"No uses la función incorporada :func:`eval` si todo lo que necesitas es "
"convertir cadenas a números.  :func:`eval` será considerablemente más lento "
"y presenta riesgos de seguridad: cualquiera podría introducir una expresión "
"Python que presentara efectos indeseados.  Por ejemplo, alguien podría pasar "
"``__import__('os').system(\"rm -rf $HOME\")`` lo cual borraría el directorio "
"home al completo."

#: ../Doc/faq/programming.rst:882
msgid ""
":func:`eval` also has the effect of interpreting numbers as Python "
"expressions, so that e.g. ``eval('09')`` gives a syntax error because Python "
"does not allow leading '0' in a decimal number (except '0')."
msgstr ""
":func:`eval` también tiene el efecto de interpretar números como expresiones "
"Python , de tal forma que, por ejemplo, ``eval('09')`` dará un error de "
"sintaxis porque Python no permite un '0' inicial en un número decimal "
"(excepto '0')."

#: ../Doc/faq/programming.rst:888
msgid "How do I convert a number to a string?"
msgstr "¿Cómo puedo convertir un número a una cadena?"

#: ../Doc/faq/programming.rst:890
msgid ""
"To convert, e.g., the number 144 to the string '144', use the built-in type "
"constructor :func:`str`.  If you want a hexadecimal or octal representation, "
"use the built-in functions :func:`hex` or :func:`oct`.  For fancy "
"formatting, see the :ref:`f-strings` and :ref:`formatstrings` sections, e.g. "
"``\"{:04d}\".format(144)`` yields ``'0144'`` and ``\"{:.3f}\"."
"format(1.0/3.0)`` yields ``'0.333'``."
msgstr ""
"Para convertir, por ejemplo, el número 144 a la cadena '144', usa el "
"constructor de tipos incorporado :func:`str`.  Si deseas una representación "
"hexadecimal o octal usa la función incorporada :func:`hex` o :func:`oct`.  "
"Para un formateado elaborado puedes ver las secciones de :ref:`f-strings` y :"
"ref:`formatstrings`, por ejemplo ``\"{:04d}\".format(144)`` produce "
"``'0144'`` y ``\"{:.3f}\".format(1.0/3.0)`` produce ``'0.333'``."

#: ../Doc/faq/programming.rst:899
msgid "How do I modify a string in place?"
msgstr "¿Cómo puedo modificar una cadena in situ?"

#: ../Doc/faq/programming.rst:901
msgid ""
"You can't, because strings are immutable.  In most situations, you should "
"simply construct a new string from the various parts you want to assemble it "
"from.  However, if you need an object with the ability to modify in-place "
"unicode data, try using an :class:`io.StringIO` object or the :mod:`array` "
"module::"
msgstr ""
"No puedes debido a que las cadenas son inmutables.  En la mayoría de "
"situaciones solo deberías crear una nueva cadena a partir de varias partes "
"que quieras usar para crearla.  Sin embargo, si necesitas un objeto con la "
"habilidad de modificar en el mismo lugar datos unicode prueba usando el "
"objeto :class:`io.StringIO` o el módulo :mod:`array`::"

#: ../Doc/faq/programming.rst:931
msgid "How do I use strings to call functions/methods?"
msgstr "¿Cómo puedo usar cadenas para invocar funciones/métodos?"

#: ../Doc/faq/programming.rst:933
msgid "There are various techniques."
msgstr "Existen varias técnicas."

#: ../Doc/faq/programming.rst:935
msgid ""
"The best is to use a dictionary that maps strings to functions.  The primary "
"advantage of this technique is that the strings do not need to match the "
"names of the functions.  This is also the primary technique used to emulate "
"a case construct::"
msgstr ""
"Lo mejor sería usar un diccionario que mapee cadenas a funciones.  La "
"principal ventaja de esta técnica es que las cadenas no necesitan ser "
"iguales que los nombres de las funciones.  Esta es también la principal "
"técnica que se usa para emular un constructo *case*::"

#: ../Doc/faq/programming.rst:950
msgid "Use the built-in function :func:`getattr`::"
msgstr "Usa la función incorporada :func:`getattr`::"

#: ../Doc/faq/programming.rst:955
msgid ""
"Note that :func:`getattr` works on any object, including classes, class "
"instances, modules, and so on."
msgstr ""
"Nótese que :func:`getattr` funciona en cualquier objeto, incluido clases, "
"instancias de clases, módulos, etc."

#: ../Doc/faq/programming.rst:958
msgid "This is used in several places in the standard library, like this::"
msgstr "Esto se usa en varios lugares de la biblioteca estándar, como esto::"

#: ../Doc/faq/programming.rst:971
msgid "Use :func:`locals` to resolve the function name::"
msgstr "Use :func:`locals` para resolver el nombre de la función::"

#: ../Doc/faq/programming.rst:983
msgid ""
"Is there an equivalent to Perl's chomp() for removing trailing newlines from "
"strings?"
msgstr ""
"¿Existe un equivalente a chomp() en Perl para eliminar nuevas líneas al "
"final de las cadenas?"

#: ../Doc/faq/programming.rst:985
msgid ""
"You can use ``S.rstrip(\"\\r\\n\")`` to remove all occurrences of any line "
"terminator from the end of the string ``S`` without removing other trailing "
"whitespace.  If the string ``S`` represents more than one line, with several "
"empty lines at the end, the line terminators for all the blank lines will be "
"removed::"
msgstr ""
"Puedes usar ``S.rstrip(\"\\r\\n\")`` para eliminar todas las ocurrencias de "
"cualquier terminación de línea desde el final de la cadena ``S`` sin "
"eliminar el resto de espacios en blanco que le siguen. Si la cadena ``S`` "
"representa más de una línea con varias líneas vacías al final, las "
"terminaciones de línea para todas las líneas vacías se eliminarán::"

#: ../Doc/faq/programming.rst:997
msgid ""
"Since this is typically only desired when reading text one line at a time, "
"using ``S.rstrip()`` this way works well."
msgstr ""
"Ya que esto solo sería deseable, típicamente, cuando lees texto línea a "
"línea, usar ``S.rstrip()`` de esta forma funcionaría bien."

#: ../Doc/faq/programming.rst:1002
msgid "Is there a scanf() or sscanf() equivalent?"
msgstr "¿Existe un equivalente a scanf() o a sscanf() ?"

#: ../Doc/faq/programming.rst:1004
msgid "Not as such."
msgstr "No de la misma forma."

#: ../Doc/faq/programming.rst:1006
msgid ""
"For simple input parsing, the easiest approach is usually to split the line "
"into whitespace-delimited words using the :meth:`~str.split` method of "
"string objects and then convert decimal strings to numeric values using :"
"func:`int` or :func:`float`.  ``split()`` supports an optional \"sep\" "
"parameter which is useful if the line uses something other than whitespace "
"as a separator."
msgstr ""
"Para análisis sintáctico simple de la entrada, el método más sencillo es, "
"usualmente, el separar la línea en palabras delimitadas por espacios usando "
"el método :meth:`~str.split` de los objetos *string* y, posteriormente, "
"convertir cadenas decimales a valores usando :func:`int` o :func:`float`.  "
"``split()`` permite un parámetro opcional \"sep\" que es útil si la línea "
"usa algo diferente a espacios en blanco como separador."

#: ../Doc/faq/programming.rst:1012
msgid ""
"For more complicated input parsing, regular expressions are more powerful "
"than C's :c:func:`sscanf` and better suited for the task."
msgstr ""
"Para análisis sintáctico de la entrada más complejo, las expresiones "
"regulares son más poderosas que :c:func:`sscanf` de C  y se ajustan mejor a "
"esta tarea."

#: ../Doc/faq/programming.rst:1017
msgid "What does 'UnicodeDecodeError' or 'UnicodeEncodeError' error  mean?"
msgstr "¿Qué significa 'UnicodeDecodeError' o 'UnicodeEncodeError'?"

#: ../Doc/faq/programming.rst:1019
msgid "See the :ref:`unicode-howto`."
msgstr "Ver :ref:`unicode-howto`."

#: ../Doc/faq/programming.rst:1023
msgid "Performance"
msgstr "Rendimiento"

#: ../Doc/faq/programming.rst:1026
msgid "My program is too slow. How do I speed it up?"
msgstr "Mi programa es muy lento. ¿Cómo puedo acelerarlo?"

#: ../Doc/faq/programming.rst:1028
msgid ""
"That's a tough one, in general.  First, here are a list of things to "
"remember before diving further:"
msgstr ""
"Esa es una pregunta difícil, en general.  Primero, aquí tienes una lista de "
"cosas a recordar antes de ir más allá:"

#: ../Doc/faq/programming.rst:1031
msgid ""
"Performance characteristics vary across Python implementations.  This FAQ "
"focuses on :term:`CPython`."
msgstr ""
"Las características del rendimiento varían entre las distintas "
"implementaciones de Python.  Estas preguntas frecuentes se enfocan en :term:"
"`CPython`."

#: ../Doc/faq/programming.rst:1033
msgid ""
"Behaviour can vary across operating systems, especially when talking about I/"
"O or multi-threading."
msgstr ""
"El comportamiento puede variar entre distintos sistemas operativos, "
"especialmente cuando se habla de tareas I/O o multi-tarea."

#: ../Doc/faq/programming.rst:1035
msgid ""
"You should always find the hot spots in your program *before* attempting to "
"optimize any code (see the :mod:`profile` module)."
msgstr ""
"Siempre deberías encontrar las partes importantes en tu programa *antes* de "
"intentar optimizar el código (ver el módulo :mod:`profile`)."

#: ../Doc/faq/programming.rst:1037
msgid ""
"Writing benchmark scripts will allow you to iterate quickly when searching "
"for improvements (see the :mod:`timeit` module)."
msgstr ""
"Escribir programas de comparación del rendimiento te permitirá iterar "
"rápidamente cuando te encuentres buscando mejoras (ver el módulo :mod:"
"`timeit`)."

#: ../Doc/faq/programming.rst:1039
msgid ""
"It is highly recommended to have good code coverage (through unit testing or "
"any other technique) before potentially introducing regressions hidden in "
"sophisticated optimizations."
msgstr ""
"Es altamente recomendable disponer de una buena cobertura de código (a "
"partir de pruebas unitarias o cualquier otra técnica) antes de introducir "
"potenciales regresiones ocultas en sofisticadas optimizaciones."

#: ../Doc/faq/programming.rst:1043
msgid ""
"That being said, there are many tricks to speed up Python code.  Here are "
"some general principles which go a long way towards reaching acceptable "
"performance levels:"
msgstr ""
"Dicho lo anterior, existen muchos trucos para acelerar código Python.  Aquí "
"tienes algunos principios generales que te permitirán llegar a alcanzar "
"niveles de rendimiento aceptables:"

#: ../Doc/faq/programming.rst:1047
msgid ""
"Making your algorithms faster (or changing to faster ones) can yield much "
"larger benefits than trying to sprinkle micro-optimization tricks all over "
"your code."
msgstr ""
"El hacer más rápido tu algoritmo (o cambiarlo por alguno más rápido) puede "
"provocar mayores beneficios que intentar unos pocos trucos de micro-"
"optimización a través de todo tu código."

#: ../Doc/faq/programming.rst:1051
msgid ""
"Use the right data structures.  Study documentation for the :ref:`bltin-"
"types` and the :mod:`collections` module."
msgstr ""
"Utiliza las estructuras de datos correctas.  Estudia la documentación para "
"los :ref:`bltin-types` y el módulo :mod:`collections`."

#: ../Doc/faq/programming.rst:1054
msgid ""
"When the standard library provides a primitive for doing something, it is "
"likely (although not guaranteed) to be faster than any alternative you may "
"come up with.  This is doubly true for primitives written in C, such as "
"builtins and some extension types.  For example, be sure to use either the :"
"meth:`list.sort` built-in method or the related :func:`sorted` function to "
"do sorting (and see the :ref:`sortinghowto` for examples of moderately "
"advanced usage)."
msgstr ""
"Cuando la biblioteca estándar proporciona una primitiva de hacer algo, esta "
"supuestamente será (aunque no se garantiza) más rápida que cualquier otra "
"alternativa que se te ocurra.  Esto es doblemente cierto si las primitivas "
"han sido escritas en C, como los *builtins* y algunos tipos extendidos.  Por "
"ejemplo, asegúrate de usar el método integrado :meth:`list.sort` o la "
"función relacionada :func:`sorted` para ordenar (y ver :ref:`sortinghowto` "
"para ver ejemplos de uso moderadamente avanzados)."

#: ../Doc/faq/programming.rst:1062
msgid ""
"Abstractions tend to create indirections and force the interpreter to work "
"more.  If the levels of indirection outweigh the amount of useful work done, "
"your program will be slower.  You should avoid excessive abstraction, "
"especially under the form of tiny functions or methods (which are also often "
"detrimental to readability)."
msgstr ""
"Las abstracciones tienden a crear rodeos y fuerzan al intérprete a trabajar "
"más.  Si el nivel de rodeos sobrepasa el trabajo útil realizado tu programa "
"podría ser más lento.  Deberías evitar abstracciones excesivas, "
"especialmente, en forma de pequeñas funciones o métodos (que también va en "
"detrimento de la legibilidad)."

#: ../Doc/faq/programming.rst:1068
#, fuzzy
msgid ""
"If you have reached the limit of what pure Python can allow, there are tools "
"to take you further away.  For example, `Cython <https://cython.org>`_ can "
"compile a slightly modified version of Python code into a C extension, and "
"can be used on many different platforms.  Cython can take advantage of "
"compilation (and optional type annotations) to make your code significantly "
"faster than when interpreted.  If you are confident in your C programming "
"skills, you can also :ref:`write a C extension module <extending-index>` "
"yourself."
msgstr ""
"Si has alcanzado el límite  de lo que permite el uso de Python puro, existen "
"otras herramientas que te permiten ir más allá.  Por ejemplo, `Cython "
"<http://cython.org>`_ puede compilar una versión ligeramente modificada del "
"código Python en una extensión en C y se podría usar en muchas plataformas "
"diferentes.  Cython puede obtener ventaja de la compilación (y anotaciones "
"de tipos opcionales) para hacer que tu código sea significativamente más "
"rápido cuando se ejecuta.  Si confías en tus habilidades de programar en C "
"también puedes escribir :ref:`un módulo de extensión en C <extending-index>` "
"tú mismo."

#: ../Doc/faq/programming.rst:1078
msgid ""
"The wiki page devoted to `performance tips <https://wiki.python.org/moin/"
"PythonSpeed/PerformanceTips>`_."
msgstr ""
"La página de la wiki dedicada a `trucos de rendimiento <https://wiki.python."
"org/moin/PythonSpeed/PerformanceTips>`_."

#: ../Doc/faq/programming.rst:1084
msgid "What is the most efficient way to concatenate many strings together?"
msgstr ""
"¿Cuál es la forma más eficiente de concatenar muchas cadenas conjuntamente?"

#: ../Doc/faq/programming.rst:1086
msgid ""
":class:`str` and :class:`bytes` objects are immutable, therefore "
"concatenating many strings together is inefficient as each concatenation "
"creates a new object.  In the general case, the total runtime cost is "
"quadratic in the total string length."
msgstr ""
"Los objetos :class:`str` y :class:`bytes` son inmutables, por tanto, "
"concatenar muchas cadenas en una sola es ineficiente debido a que cada "
"concatenación crea un nuevo objeto. En el caso más general, el coste total "
"en tiempo de ejecución es cuadrático en relación a la longitud de la cadena "
"final."

#: ../Doc/faq/programming.rst:1091
msgid ""
"To accumulate many :class:`str` objects, the recommended idiom is to place "
"them into a list and call :meth:`str.join` at the end::"
msgstr ""
"Para acumular muchos objetos :class:`str`, la forma recomendada sería "
"colocarlos en una lista y llamar al método :meth:`str.join` al final::"

#: ../Doc/faq/programming.rst:1099
msgid "(another reasonably efficient idiom is to use :class:`io.StringIO`)"
msgstr ""
"(otra forma que sería razonable en términos de eficiencia sería usar :class:"
"`io.StringIO`)"

#: ../Doc/faq/programming.rst:1101
msgid ""
"To accumulate many :class:`bytes` objects, the recommended idiom is to "
"extend a :class:`bytearray` object using in-place concatenation (the ``+=`` "
"operator)::"
msgstr ""
"Para acumular muchos objetos :class:`bytes`, la forma recomendada sería "
"extender un objeto :class:`bytearray` usando el operador de concatenación   "
"in situ (el operador ``+=``)::"

#: ../Doc/faq/programming.rst:1110
msgid "Sequences (Tuples/Lists)"
msgstr "Secuencias (Tuplas/Listas)"

#: ../Doc/faq/programming.rst:1113
msgid "How do I convert between tuples and lists?"
msgstr "¿Cómo convertir entre tuplas y listas?"

#: ../Doc/faq/programming.rst:1115
msgid ""
"The type constructor ``tuple(seq)`` converts any sequence (actually, any "
"iterable) into a tuple with the same items in the same order."
msgstr ""
"El constructor ``tuple(seq)`` convierte cualquier secuencia (en realidad, "
"cualquier iterable) en una tupla con los mismos elementos y en el mismo "
"orden."

#: ../Doc/faq/programming.rst:1118
msgid ""
"For example, ``tuple([1, 2, 3])`` yields ``(1, 2, 3)`` and ``tuple('abc')`` "
"yields ``('a', 'b', 'c')``.  If the argument is a tuple, it does not make a "
"copy but returns the same object, so it is cheap to call :func:`tuple` when "
"you aren't sure that an object is already a tuple."
msgstr ""
"Por ejemplo, ``tuple([1, 2, 3])`` lo convierte en ``(1, 2, 3)`` y "
"``tuple('abc')`` lo convierte en ``('a', 'b', 'c')``.  Si el argumento es "
"una tupla no creará una nueva copia y retornará el mismo objeto, por tanto, "
"llamar a :func:`tuple` no tendrá mucho coste si no estás seguro si un objeto "
"ya es una tupla."

#: ../Doc/faq/programming.rst:1123
msgid ""
"The type constructor ``list(seq)`` converts any sequence or iterable into a "
"list with the same items in the same order.  For example, ``list((1, 2, "
"3))`` yields ``[1, 2, 3]`` and ``list('abc')`` yields ``['a', 'b', 'c']``.  "
"If the argument is a list, it makes a copy just like ``seq[:]`` would."
msgstr ""
"El constructor ``list(seq)`` convierte cualquier secuencia o iterable en una "
"lista con los mismos elementos y en el mismo orden.  Por ejemplo, ``list((1, "
"2, 3))`` lo convierte a ``[1, 2, 3]`` y ``list('abc')`` lo convierte a "
"``['a', 'b', 'c']``.  Si el argumento es una lista, hará una copia como lo "
"haría ``seq[:]``."

#: ../Doc/faq/programming.rst:1130
msgid "What's a negative index?"
msgstr "¿Qué es un índice negativo?"

#: ../Doc/faq/programming.rst:1132
msgid ""
"Python sequences are indexed with positive numbers and negative numbers.  "
"For positive numbers 0 is the first index 1 is the second index and so "
"forth.  For negative indices -1 is the last index and -2 is the penultimate "
"(next to last) index and so forth.  Think of ``seq[-n]`` as the same as "
"``seq[len(seq)-n]``."
msgstr ""
"Las secuencias en Python están indexadas con números positivos y negativos.  "
"Para los números positivos el  0 será el primer índice, el 1 el segundo y "
"así en adelante.  Para los índices negativos el -1 el último índice, el -2 "
"el penúltimo, etc.  Piensa en ``seq[-n]`` como si fuera ``seq[len(seq)-n]``."

#: ../Doc/faq/programming.rst:1137
msgid ""
"Using negative indices can be very convenient.  For example ``S[:-1]`` is "
"all of the string except for its last character, which is useful for "
"removing the trailing newline from a string."
msgstr ""
"El uso de índices negativos puede ser muy conveniente.  Por ejemplo "
"``S[:-1]`` se usa para todo la cadena excepto para su último carácter, lo "
"cual es útil para eliminar el salto de línea final de una cadena."

#: ../Doc/faq/programming.rst:1143
msgid "How do I iterate over a sequence in reverse order?"
msgstr "¿Cómo puedo iterar sobre una secuencia en orden inverso?"

#: ../Doc/faq/programming.rst:1145
msgid "Use the :func:`reversed` built-in function::"
msgstr "Usa la función incorporada :func:`reversed`::"

#: ../Doc/faq/programming.rst:1150
msgid ""
"This won't touch your original sequence, but build a new copy with reversed "
"order to iterate over."
msgstr ""
"Esto no transformará la secuencia original sino que creará una nueva copia "
"en orden inverso por la que se puede iterar."

#: ../Doc/faq/programming.rst:1155
msgid "How do you remove duplicates from a list?"
msgstr "¿Cómo eliminar duplicados de una lista?"

#: ../Doc/faq/programming.rst:1157
msgid "See the Python Cookbook for a long discussion of many ways to do this:"
msgstr ""
"Puedes echar un vistazo al recetario de Python para ver una gran discusión "
"mostrando muchas formas de hacer esto:"

#: ../Doc/faq/programming.rst:1159
msgid "https://code.activestate.com/recipes/52560/"
msgstr "https://code.activestate.com/recipes/52560/"

#: ../Doc/faq/programming.rst:1161
msgid ""
"If you don't mind reordering the list, sort it and then scan from the end of "
"the list, deleting duplicates as you go::"
msgstr ""
"Si no te preocupa que la lista se reordene la puedes ordenar y, después, y "
"después escanearla desde el final borrando duplicados a medida que avanzas::"

#: ../Doc/faq/programming.rst:1173
msgid ""
"If all elements of the list may be used as set keys (i.e. they are all :term:"
"`hashable`) this is often faster ::"
msgstr ""
"Si todos los elementos de la lista pueden ser usados como claves (por "
"ejemplo son todos :term:`hashable`) esto será, en general, más rápido ::"

#: ../Doc/faq/programming.rst:1178
msgid ""
"This converts the list into a set, thereby removing duplicates, and then "
"back into a list."
msgstr ""
"Esto convierte la lista en un conjunto eliminando, por tanto, los duplicados "
"y, posteriormente, puedes volver a una lista."

#: ../Doc/faq/programming.rst:1183
msgid "How do you remove multiple items from a list"
msgstr "Cómo eliminar duplicados de una lista"

#: ../Doc/faq/programming.rst:1185
msgid ""
"As with removing duplicates, explicitly iterating in reverse with a delete "
"condition is one possibility.  However, it is easier and faster to use slice "
"replacement with an implicit or explicit forward iteration. Here are three "
"variations.::"
msgstr ""
"Al igual que con la eliminación de duplicados, una posibilidad es iterar "
"explícitamente a la inversa con una condición de eliminación. Sin embargo, "
"es más fácil y rápido utilizar el reemplazo de sectores con una iteración "
"directa implícita o explícita. Aquí hay tres variaciones.::"

#: ../Doc/faq/programming.rst:1194
msgid "The list comprehension may be fastest."
msgstr "Esta comprensión de lista puede ser la más rápida."

#: ../Doc/faq/programming.rst:1198
msgid "How do you make an array in Python?"
msgstr "¿Cómo se puede hacer un array en Python?"

#: ../Doc/faq/programming.rst:1200
msgid "Use a list::"
msgstr "Usa una lista::"

#: ../Doc/faq/programming.rst:1204
msgid ""
"Lists are equivalent to C or Pascal arrays in their time complexity; the "
"primary difference is that a Python list can contain objects of many "
"different types."
msgstr ""
"Las listas son equivalentes en complejidad temporal a arrays en C o Pascal; "
"La principal diferencia es que una lista en Python puede contener objetos de "
"diferentes tipos."

#: ../Doc/faq/programming.rst:1207
msgid ""
"The ``array`` module also provides methods for creating arrays of fixed "
"types with compact representations, but they are slower to index than "
"lists.  Also note that NumPy and other third party packages define array-"
"like structures with various characteristics as well."
msgstr ""
"El módulo ``array`` proporciona, también, métodos para crear arrays de tipo "
"fijo con representaciones compactas pero son más lentos de indexar que las "
"listas.  Además, debes tener en cuenta que las extensiones Numpy y otras "
"definen estructuras de tipo array con diversas características también."

#: ../Doc/faq/programming.rst:1212
msgid ""
"To get Lisp-style linked lists, you can emulate cons cells using tuples::"
msgstr ""
"Para obtener listas enlazadas al estilo de las de Lisp, puedes emular celdas "
"cons usando tuplas::"

#: ../Doc/faq/programming.rst:1216
msgid ""
"If mutability is desired, you could use lists instead of tuples.  Here the "
"analogue of lisp car is ``lisp_list[0]`` and the analogue of cdr is "
"``lisp_list[1]``.  Only do this if you're sure you really need to, because "
"it's usually a lot slower than using Python lists."
msgstr ""
"Si deseas que haya mutabilidad podrías usar listas en lugar de tuplas.  El "
"análogo a un car de Lisp es ``lisp_list[0]`` y al análogo a cdr es "
"``lisp_list[1]``.  Haz esto solo si estás seguro que es lo que necesitas "
"debido a que, normalmente, será bastante más lento que el usar listas  "
"Python."

#: ../Doc/faq/programming.rst:1225
msgid "How do I create a multidimensional list?"
msgstr "¿Cómo puedo crear una lista multidimensional?"

#: ../Doc/faq/programming.rst:1227
msgid "You probably tried to make a multidimensional array like this::"
msgstr ""
"Seguramente hayas intentado crear un array multidimensional de la siguiente "
"forma::"

#: ../Doc/faq/programming.rst:1231
msgid "This looks correct if you print it:"
msgstr "Esto parece correcto si lo muestras en pantalla:"

#: ../Doc/faq/programming.rst:1242
msgid "But when you assign a value, it shows up in multiple places:"
msgstr "Pero cuando asignas un valor, se muestra en múltiples sitios:"

#: ../Doc/faq/programming.rst:1254
msgid ""
"The reason is that replicating a list with ``*`` doesn't create copies, it "
"only creates references to the existing objects.  The ``*3`` creates a list "
"containing 3 references to the same list of length two.  Changes to one row "
"will show in all rows, which is almost certainly not what you want."
msgstr ""
"La razón es que replicar una lista con ``*`` no crea copias, solo crea "
"referencias a los objetos existentes.  El ``*3`` crea una lista conteniendo "
"3 referencias a la misma lista de longitud dos.  Cambios a una fila se "
"mostrarán en todas las filas, lo cual, seguramente, no es lo que deseas."

#: ../Doc/faq/programming.rst:1259
msgid ""
"The suggested approach is to create a list of the desired length first and "
"then fill in each element with a newly created list::"
msgstr ""
"El enfoque recomendado sería crear, primero, una lista de la longitud "
"deseada y, después, rellenar cada elemento con una lista creada en ese "
"momento::"

#: ../Doc/faq/programming.rst:1266
msgid ""
"This generates a list containing 3 different lists of length two.  You can "
"also use a list comprehension::"
msgstr ""
"Esto genera una lista conteniendo 3 listas distintas de longitud dos.  "
"También puedes usar una comprensión de lista::"

#: ../Doc/faq/programming.rst:1272
#, fuzzy
msgid ""
"Or, you can use an extension that provides a matrix datatype; `NumPy "
"<https://numpy.org/>`_ is the best known."
msgstr ""
"O puedes usar una extensión que proporcione un tipo de dato para matrices; "
"`NumPy <http://www.numpy.org/>`_ es la más conocida."

#: ../Doc/faq/programming.rst:1277
msgid "How do I apply a method to a sequence of objects?"
msgstr "¿Cómo puedo aplicar un método a una secuencia de objetos?"

#: ../Doc/faq/programming.rst:1279
msgid "Use a list comprehension::"
msgstr "Usa una comprensión de listas::"

#: ../Doc/faq/programming.rst:1286
msgid ""
"Why does a_tuple[i] += ['item'] raise an exception when the addition works?"
msgstr ""
"¿Por qué hacer lo siguiente, ``a_tuple[i] += ['item']``, lanza una excepción "
"cuando la suma funciona?"

#: ../Doc/faq/programming.rst:1288
msgid ""
"This is because of a combination of the fact that augmented assignment "
"operators are *assignment* operators, and the difference between mutable and "
"immutable objects in Python."
msgstr ""
"Esto es debido a la combinación del hecho de que un operador de asignación "
"aumentada es un operador de *asignación* y a la diferencia entre objetos "
"mutables e inmutable en Python."

#: ../Doc/faq/programming.rst:1292
msgid ""
"This discussion applies in general when augmented assignment operators are "
"applied to elements of a tuple that point to mutable objects, but we'll use "
"a ``list`` and ``+=`` as our exemplar."
msgstr ""
"Esta discusión aplica, en general, cuando los operadores de asignación "
"aumentada se aplican a elementos de una tupla que apuntan a objetos "
"mutables. Pero vamos a usar una ``lista`` y ``+=`` para el ejemplo."

#: ../Doc/faq/programming.rst:1296
msgid "If you wrote::"
msgstr "Si escribes::"

#: ../Doc/faq/programming.rst:1304
msgid ""
"The reason for the exception should be immediately clear: ``1`` is added to "
"the object ``a_tuple[0]`` points to (``1``), producing the result object, "
"``2``, but when we attempt to assign the result of the computation, ``2``, "
"to element ``0`` of the tuple, we get an error because we can't change what "
"an element of a tuple points to."
msgstr ""
"La razón por la que se produce la excepción debería ser evidente: ``1`` se "
"añade al objeto ``a_tuple[0]`` que apunta a (``1``), creando el objeto "
"resultante, ``2``, pero cuando intentamos asignar el resultado del cálculo, "
"``2``, al elemento ``0`` de la tupla, obtenemos un error debido a que no "
"podemos cambiar el elemento al que apunta la tupla."

#: ../Doc/faq/programming.rst:1310
msgid ""
"Under the covers, what this augmented assignment statement is doing is "
"approximately this::"
msgstr ""
"En realidad, lo que esta declaración de asignación aumentada está haciendo "
"es, aproximadamente, lo siguiente::"

#: ../Doc/faq/programming.rst:1319
msgid ""
"It is the assignment part of the operation that produces the error, since a "
"tuple is immutable."
msgstr ""
"Es la parte de asignación de la operación la que provoca el error, debido a "
"que una tupla es inmutable."

#: ../Doc/faq/programming.rst:1322
msgid "When you write something like::"
msgstr "Cuando escribes algo como lo siguiente::"

#: ../Doc/faq/programming.rst:1330
msgid ""
"The exception is a bit more surprising, and even more surprising is the fact "
"that even though there was an error, the append worked::"
msgstr ""
"La excepción es un poco más sorprendente e, incluso, más sorprendente es el "
"hecho que aunque hubo un error, la agregación funcionó::"

#: ../Doc/faq/programming.rst:1336
msgid ""
"To see why this happens, you need to know that (a) if an object implements "
"an ``__iadd__`` magic method, it gets called when the ``+=`` augmented "
"assignment is executed, and its return value is what gets used in the "
"assignment statement; and (b) for lists, ``__iadd__`` is equivalent to "
"calling ``extend`` on the list and returning the list.  That's why we say "
"that for lists, ``+=`` is a \"shorthand\" for ``list.extend``::"
msgstr ""
"Para ver lo que sucede necesitas saber que (a) si un objeto implementa un "
"método mágico ``__iadd__`` , se le llama cuando se ejecuta la asignación "
"aumentada ``+=`` y el valor devuelto es lo que se usa en la declaración de "
"asignación; y (b) para listas, ``__iadd__`` es equivalente a llamar a "
"``extend`` en la lista y retornar la lista.  Es por esto que decimos que "
"para listas, ``+=`` es un atajo para ``list.extend``::"

#: ../Doc/faq/programming.rst:1348
msgid "This is equivalent to::"
msgstr "Esto es equivalente a ::"

#: ../Doc/faq/programming.rst:1353
msgid ""
"The object pointed to by a_list has been mutated, and the pointer to the "
"mutated object is assigned back to ``a_list``.  The end result of the "
"assignment is a no-op, since it is a pointer to the same object that "
"``a_list`` was previously pointing to, but the assignment still happens."
msgstr ""
"El objeto al que apunta a_list ha mutado y el puntero al objeto mutado es "
"asignado de vuelta a ``a_list``.  El resultado final de la asignación no es "
"opción debido a que es un puntero al mismo objeto al que estaba apuntando "
"``a_list``  pero la asignación sí que ocurre."

#: ../Doc/faq/programming.rst:1358
msgid "Thus, in our tuple example what is happening is equivalent to::"
msgstr ""
"Por tanto, en nuestro ejemplo con tupla lo que está pasando es equivalente "
"a::"

#: ../Doc/faq/programming.rst:1366
msgid ""
"The ``__iadd__`` succeeds, and thus the list is extended, but even though "
"``result`` points to the same object that ``a_tuple[0]`` already points to, "
"that final assignment still results in an error, because tuples are "
"immutable."
msgstr ""
"El ``__iadd__`` se realiza con éxito y la lista se extiende pero, incluso "
"aunque ``result`` apunta al mismo objeto al que ya está apuntando "
"``a_tuple[0]`` la asignación final sigue resultando en un error, debido a "
"que las tuplas son inmutables."

#: ../Doc/faq/programming.rst:1372
msgid ""
"I want to do a complicated sort: can you do a Schwartzian Transform in "
"Python?"
msgstr ""
"Quiero hacer una ordenación compleja: ¿Puedes hacer una transformada "
"Schwartziana (Schwartzian Transform) en Python?"

#: ../Doc/faq/programming.rst:1374
msgid ""
"The technique, attributed to Randal Schwartz of the Perl community, sorts "
"the elements of a list by a metric which maps each element to its \"sort "
"value\". In Python, use the ``key`` argument for the :meth:`list.sort` "
"method::"
msgstr ""
"La técnica, atribuida a Randal Schwartz, miembro de la comunidad Perl, "
"ordena los elementos de una lista mediante una métrica que mapea cada "
"elemento a su \"valor orden\". En Python, usa el argumento ``key`` par el "
"método :meth:`list.sort`::"

#: ../Doc/faq/programming.rst:1383
msgid "How can I sort one list by values from another list?"
msgstr "¿Cómo puedo ordenar una lista a partir de valores de otra lista?"

#: ../Doc/faq/programming.rst:1385
msgid ""
"Merge them into an iterator of tuples, sort the resulting list, and then "
"pick out the element you want. ::"
msgstr ""
"Las puedes unir en un iterador de tuplas, ordena la lista resultando y "
"después extrae el elemento que deseas. ::"

#: ../Doc/faq/programming.rst:1400
msgid "Objects"
msgstr "Objetos"

#: ../Doc/faq/programming.rst:1403
msgid "What is a class?"
msgstr "¿Qué es una clase?"

#: ../Doc/faq/programming.rst:1405
msgid ""
"A class is the particular object type created by executing a class "
"statement. Class objects are used as templates to create instance objects, "
"which embody both the data (attributes) and code (methods) specific to a "
"datatype."
msgstr ""
"Una clase es un tipo de objeto particular creado mediante la ejecución de la "
"declaración class. Los objetos class se usan como plantillas para crear "
"instancias de objetos que son tanto los datos (atributos) como el código "
"(métodos) específicos para un tipo de dato."

#: ../Doc/faq/programming.rst:1409
msgid ""
"A class can be based on one or more other classes, called its base "
"class(es). It then inherits the attributes and methods of its base classes. "
"This allows an object model to be successively refined by inheritance.  You "
"might have a generic ``Mailbox`` class that provides basic accessor methods "
"for a mailbox, and subclasses such as ``MboxMailbox``, ``MaildirMailbox``, "
"``OutlookMailbox`` that handle various specific mailbox formats."
msgstr ""
"Una clase puede estar basada en una o más clases diferentes, llamadas su(s) "
"clase(s). Hereda los atributos y métodos de sus clases base. Esto permite "
"que se pueda refinar un objeto modelo de forma sucesiva mediante herencia.  "
"Puedes tener una clase genérica ``Mailbox``  que proporciona métodos de "
"acceso básico para un buzón de correo y subclases como ``MboxMailbox``, "
"``MaildirMailbox``, ``OutlookMailbox`` que gestionan distintos formatos "
"específicos de buzón de correos."

#: ../Doc/faq/programming.rst:1418
msgid "What is a method?"
msgstr "¿Qué es un método?"

#: ../Doc/faq/programming.rst:1420
msgid ""
"A method is a function on some object ``x`` that you normally call as ``x."
"name(arguments...)``.  Methods are defined as functions inside the class "
"definition::"
msgstr ""
"Un método es una función de un objeto ``x`` que puedes llamar, normalmente, "
"de la forma ``x.name(arguments...)``.  Los métodos  se definen como "
"funciones dentro de la definición de la clase::"

#: ../Doc/faq/programming.rst:1430
msgid "What is self?"
msgstr "¿Qué es self?"

#: ../Doc/faq/programming.rst:1432
msgid ""
"Self is merely a conventional name for the first argument of a method.  A "
"method defined as ``meth(self, a, b, c)`` should be called as ``x.meth(a, b, "
"c)`` for some instance ``x`` of the class in which the definition occurs; "
"the called method will think it is called as ``meth(x, a, b, c)``."
msgstr ""
"Self es, básicamente, un nombre que se usa de forma convencional como primer "
"argumento de un método.  Un método definido como ``meth(self, a, b, c)`` se "
"le llama como ``x.meth(a, b, c)`` para una instancia ``x`` de la clase es "
"que se definió; el método invocado pensará que se le ha invocado como "
"``meth(x, a, b, c)``."

#: ../Doc/faq/programming.rst:1437
msgid "See also :ref:`why-self`."
msgstr "Ver también :ref:`why-self`."

#: ../Doc/faq/programming.rst:1441
msgid ""
"How do I check if an object is an instance of a given class or of a subclass "
"of it?"
msgstr ""
"¿Cómo puedo comprobar si un objeto es una instancia de una clase dada o de "
"una subclase de la misma?"

#: ../Doc/faq/programming.rst:1443
msgid ""
"Use the built-in function ``isinstance(obj, cls)``.  You can check if an "
"object is an instance of any of a number of classes by providing a tuple "
"instead of a single class, e.g. ``isinstance(obj, (class1, class2, ...))``, "
"and can also check whether an object is one of Python's built-in types, e.g. "
"``isinstance(obj, str)`` or ``isinstance(obj, (int, float, complex))``."
msgstr ""
"Usa la función incorporada ``isinstance(obj, cls)``.  Puedes comprobar si un "
"objeto es una instancia de cualquier número de clases proporcionando una "
"tupla en lugar de una sola clase, por ejemplo ``isinstance(obj, (class1, "
"class2, ...))`` y, también, puedes comprobar si un objeto es uno de los "
"tipos incorporados por ejemplo ``isinstance(obj, str)`` o ``isinstance(obj, "
"(int, float, complex))``."

#: ../Doc/faq/programming.rst:1449
msgid ""
"Note that :func:`isinstance` also checks for virtual inheritance from an :"
"term:`abstract base class`.  So, the test will return ``True`` for a "
"registered class even if hasn't directly or indirectly inherited from it.  "
"To test for \"true inheritance\", scan the :term:`MRO` of the class:"
msgstr ""
"Note que :func:`isinstance` también verifica la herencia virtual de una :"
"term:`abstract base class`. Entonces, la prueba retorna `True` para una "
"clase registrada incluso si no ha heredado directa o indirectamente de ella. "
"Para verificar \"herencia verdadera\", escanea el :term:`MRO` de la clase:"

#: ../Doc/faq/programming.rst:1484
msgid ""
"Note that most programs do not use :func:`isinstance` on user-defined "
"classes very often.  If you are developing the classes yourself, a more "
"proper object-oriented style is to define methods on the classes that "
"encapsulate a particular behaviour, instead of checking the object's class "
"and doing a different thing based on what class it is.  For example, if you "
"have a function that does something::"
msgstr ""
"Destacar que muchos programas no necesitan usar :func:`isinstance` de forma "
"frecuente en clases definidas por el usuario.  Si estás desarrollando clases "
"un mejor estilo orientado a objetos sería el de definir los métodos en las "
"clases que encapsulan un comportamiento en particular en lugar de ir "
"comprobando la clase del objeto e ir haciendo cosas en base a la clase que "
"es.  Por ejemplo, si tienes una función que hace lo siguiente::"

#: ../Doc/faq/programming.rst:1498
msgid ""
"A better approach is to define a ``search()`` method on all the classes and "
"just call it::"
msgstr ""
"Un enfoque más adecuado sería definir un método ``search()`` en todas las "
"clases e invocarlo::"

#: ../Doc/faq/programming.rst:1513
msgid "What is delegation?"
msgstr "¿Qué es la delegación?"

#: ../Doc/faq/programming.rst:1515
msgid ""
"Delegation is an object oriented technique (also called a design pattern). "
"Let's say you have an object ``x`` and want to change the behaviour of just "
"one of its methods.  You can create a new class that provides a new "
"implementation of the method you're interested in changing and delegates all "
"other methods to the corresponding method of ``x``."
msgstr ""
"La delegación es una técnica orientada a objetos (también llamado un patrón "
"de diseño). Digamos que tienes un objeto ``x`` y deseas cambiar el "
"comportamiento de solo uno de sus métodos.  Puedes crear una nueva clase que "
"proporciona una nueva implementación del método que te interesa cambiar y "
"delega el resto de métodos al método correspondiente de ``x``."

#: ../Doc/faq/programming.rst:1521
msgid ""
"Python programmers can easily implement delegation.  For example, the "
"following class implements a class that behaves like a file but converts all "
"written data to uppercase::"
msgstr ""
"Los programadores Python pueden implementar la delegación de forma muy "
"sencilla.  Por ejemplo, la siguiente clase implementa una clase que se "
"comporta como un fichero pero convierte todos los datos escritos a "
"mayúsculas::"

#: ../Doc/faq/programming.rst:1536
msgid ""
"Here the ``UpperOut`` class redefines the ``write()`` method to convert the "
"argument string to uppercase before calling the underlying ``self._outfile."
"write()`` method.  All other methods are delegated to the underlying ``self."
"_outfile`` object.  The delegation is accomplished via the ``__getattr__`` "
"method; consult :ref:`the language reference <attribute-access>` for more "
"information about controlling attribute access."
msgstr ""
"Aquí, la clase ``UpperOut``  redefine el método ``write()`` para convertir "
"la cadena del argumento a mayúscula antes de invocar al método ``self."
"_outfile.write()``.  El resto de métodos han sido delegados al objeto ``self."
"_outfile``.  La delegación se consigue mediante el método ``__getattr__``; "
"consulta :ref:`la referencia del lenguaje <attribute-access>` para obtener "
"más información sobre cómo controlar el acceso a atributos."

#: ../Doc/faq/programming.rst:1543
msgid ""
"Note that for more general cases delegation can get trickier. When "
"attributes must be set as well as retrieved, the class must define a :meth:"
"`__setattr__` method too, and it must do so carefully.  The basic "
"implementation of :meth:`__setattr__` is roughly equivalent to the "
"following::"
msgstr ""
"Ten en cuenta que para casos más generales la delegación puede ser algo más "
"complicada. Cuando los atributos se deben colocar y recuperar la clase debe "
"definir, también, un método :meth:`__setattr__`  y hay que hacerlo con "
"cuidado.  La implementación básica de :meth:`__setattr__` es, "
"aproximadamente, equivalente a lo siguiente::"

#: ../Doc/faq/programming.rst:1554
msgid ""
"Most :meth:`__setattr__` implementations must modify ``self.__dict__`` to "
"store local state for self without causing an infinite recursion."
msgstr ""
"Muchas implementaciones de :meth:`__setattr__` deben modificar ``self."
"__dict__`` para almacenar el estado local para self sin provocar una "
"recursión infinita."

#: ../Doc/faq/programming.rst:1559
msgid ""
"How do I call a method defined in a base class from a derived class that "
"extends it?"
msgstr ""
"¿Cómo invoco a un método definido en una clase base desde una clase derivada "
"que la extiende?"

#: ../Doc/faq/programming.rst:1561
msgid "Use the built-in :func:`super` function::"
msgstr "Usa la función incorporada :func:`super`::"

#: ../Doc/faq/programming.rst:1567
msgid ""
"In the example, :func:`super` will automatically determine the instance from "
"which it was called (the ``self`` value), look up the :term:`method "
"resolution order` (MRO) with ``type(self).__mro__``, and return the next in "
"line after ``Derived`` in the MRO: ``Base``."
msgstr ""
"En el ejemplo, :func:`super` automáticamente determinará la instancia desde "
"la cual ha sido llamada (el valor ``self```), busca el :term:`method "
"resolution order` (MRO) con ``type(self).__mro__``, y devuelve el siguiente "
"en línea después de ``Derived`` en el MRO: ``Base``."

#: ../Doc/faq/programming.rst:1574
msgid "How can I organize my code to make it easier to change the base class?"
msgstr ""
"¿Cómo puedo organizar mi código para hacer que sea más sencillo modificar la "
"clase base?"

#: ../Doc/faq/programming.rst:1576
msgid ""
"You could assign the base class to an alias and derive from the alias.  Then "
"all you have to change is the value assigned to the alias.  Incidentally, "
"this trick is also handy if you want to decide dynamically (e.g. depending "
"on availability of resources) which base class to use.  Example::"
msgstr ""
"Puede asignar la clase base a un alias y derivar del alias. Entonces todo lo "
"que tiene que cambiar es el valor asignado al alias. Por cierto, este truco "
"también es útil si desea decidir dinámicamente (por ejemplo, dependiendo de "
"la disponibilidad de recursos) qué clase base usar. Ejemplo::"

#: ../Doc/faq/programming.rst:1591
msgid "How do I create static class data and static class methods?"
msgstr ""
"¿Cómo puedo crear datos estáticos de clase y métodos estáticos de clase?"

#: ../Doc/faq/programming.rst:1593
msgid ""
"Both static data and static methods (in the sense of C++ or Java) are "
"supported in Python."
msgstr ""
"Tanto los datos estáticos como los métodos estáticos (en el sentido de C++ o "
"Java) están permitidos en Python."

#: ../Doc/faq/programming.rst:1596
msgid ""
"For static data, simply define a class attribute.  To assign a new value to "
"the attribute, you have to explicitly use the class name in the assignment::"
msgstr ""
"Para datos estáticos simplemente define un atributo de clase.  Para asignar "
"un nuevo valor al atributo debes usar de forma explícita el nombre de la "
"clase en la asignación::"

#: ../Doc/faq/programming.rst:1608
msgid ""
"``c.count`` also refers to ``C.count`` for any ``c`` such that "
"``isinstance(c, C)`` holds, unless overridden by ``c`` itself or by some "
"class on the base-class search path from ``c.__class__`` back to ``C``."
msgstr ""
"``c.count`` también se refiere a ``C.count`` para cualquier ``c`` de tal "
"forma que se cumpla ``isinstance(c, C)``, a no ser que ``c`` sea "
"sobreescrita por si misma o por alguna clase contenida en la búsqueda de "
"clases base desde ``c.__class__`` hasta ``C``."

#: ../Doc/faq/programming.rst:1612
msgid ""
"Caution: within a method of C, an assignment like ``self.count = 42`` "
"creates a new and unrelated instance named \"count\" in ``self``'s own "
"dict.  Rebinding of a class-static data name must always specify the class "
"whether inside a method or not::"
msgstr ""
"Debes tener cuidado: dentro de un método de C, una asignación como ``self."
"count = 42`` creará una nueva instancia sin relación con la original que se "
"llamará \"count\" en el propio diccionario de ``self``.  El reunificar el "
"nombre de datos estáticos de una clase debería llevar, siempre, a "
"especificar la clase tanto si se produce desde dentro de un método como si "
"no::"

#: ../Doc/faq/programming.rst:1619
msgid "Static methods are possible::"
msgstr "Los métodos estáticos son posibles::"

#: ../Doc/faq/programming.rst:1627
msgid ""
"However, a far more straightforward way to get the effect of a static method "
"is via a simple module-level function::"
msgstr ""
"Sin embargo, una forma más directa de obtener el efecto de un método "
"estático sería mediante una simple función a nivel de módulo::"

#: ../Doc/faq/programming.rst:1633
msgid ""
"If your code is structured so as to define one class (or tightly related "
"class hierarchy) per module, this supplies the desired encapsulation."
msgstr ""
"Si has estructurado tu código para definir una clase única (o una jerarquía "
"de clases altamente relacionadas) por módulo, esto proporcionará la "
"encapsulación deseada."

#: ../Doc/faq/programming.rst:1638
msgid "How can I overload constructors (or methods) in Python?"
msgstr "¿Como puedo sobrecargar constructores (o métodos) en Python?"

#: ../Doc/faq/programming.rst:1640
msgid ""
"This answer actually applies to all methods, but the question usually comes "
"up first in the context of constructors."
msgstr ""
"Esta respuesta es aplicable, en realidad, a todos los métodos pero la "
"pregunta suele surgir primero en el contexto de los constructores."

#: ../Doc/faq/programming.rst:1643
msgid "In C++ you'd write"
msgstr "En C++ deberías escribir"

#: ../Doc/faq/programming.rst:1652
msgid ""
"In Python you have to write a single constructor that catches all cases "
"using default arguments.  For example::"
msgstr ""
"En Python solo debes escribir un único constructor que tenga en cuenta todos "
"los casos usando los argumentos por defecto.  Por ejemplo::"

#: ../Doc/faq/programming.rst:1662
msgid "This is not entirely equivalent, but close enough in practice."
msgstr ""
"Esto no es totalmente equivalente pero, en la práctica, es muy similar."

#: ../Doc/faq/programming.rst:1664
msgid "You could also try a variable-length argument list, e.g. ::"
msgstr ""
"Podrías intentar, también una lista de argumentos de longitud variable, por "
"ejemplo ::"

#: ../Doc/faq/programming.rst:1669
msgid "The same approach works for all method definitions."
msgstr "El mismo enfoque funciona para todas las definiciones de métodos."

#: ../Doc/faq/programming.rst:1673
msgid "I try to use __spam and I get an error about _SomeClassName__spam."
msgstr "Intento usar __spam y obtengo un error sobre _SomeClassName__spam."

#: ../Doc/faq/programming.rst:1675
msgid ""
"Variable names with double leading underscores are \"mangled\" to provide a "
"simple but effective way to define class private variables.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with any leading underscores "
"stripped."
msgstr ""
"Nombres de variable con doble guión prefijado se convierten, con una "
"modificación de nombres, para proporcionar una forma simple pero efectiva de "
"definir variables de clase privadas. Cualquier identificador de la forma "
"``__spam`` (como mínimo dos guiones bajos como prefijo, como máximo un guión "
"bajo como sufijo) se reemplaza con ``_classname__spam``, donde ``classname`` "
"es el nombre de la clase eliminando cualquier guión bajo prefijado."

#: ../Doc/faq/programming.rst:1681
msgid ""
"This doesn't guarantee privacy: an outside user can still deliberately "
"access the \"_classname__spam\" attribute, and private values are visible in "
"the object's ``__dict__``.  Many Python programmers never bother to use "
"private variable names at all."
msgstr ""
"Esto no garantiza la privacidad: un usuario externo puede acceder, de forma "
"deliberada y si así lo desea, al atributo \"_classname__spam\",  y los "
"valores privados son visibles en el ``__dict__`` del objeto.  Muchos "
"programadores Python no se suelen molestar en usar nombres privados de "
"variables."

#: ../Doc/faq/programming.rst:1688
msgid "My class defines __del__ but it is not called when I delete the object."
msgstr "Mi clase define __del__ pero no se le invoca cuando borro el objeto."

#: ../Doc/faq/programming.rst:1690
msgid "There are several possible reasons for this."
msgstr "Existen varias razones posibles para que suceda así."

#: ../Doc/faq/programming.rst:1692
msgid ""
"The del statement does not necessarily call :meth:`__del__` -- it simply "
"decrements the object's reference count, and if this reaches zero :meth:"
"`__del__` is called."
msgstr ""
"La declaración del no invoca, necesariamente, al método :meth:`__del__` -- "
"simplemente reduce el conteo de referencias del objeto y, si se reduce a "
"cero entonces es cuando se invoca a :meth:`__del__`."

#: ../Doc/faq/programming.rst:1696
msgid ""
"If your data structures contain circular links (e.g. a tree where each child "
"has a parent reference and each parent has a list of children) the reference "
"counts will never go back to zero.  Once in a while Python runs an algorithm "
"to detect such cycles, but the garbage collector might run some time after "
"the last reference to your data structure vanishes, so your :meth:`__del__` "
"method may be called at an inconvenient and random time. This is "
"inconvenient if you're trying to reproduce a problem. Worse, the order in "
"which object's :meth:`__del__` methods are executed is arbitrary.  You can "
"run :func:`gc.collect` to force a collection, but there *are* pathological "
"cases where objects will never be collected."
msgstr ""
"Si tus estructuras de datos contienen enlaces circulares (por ejemplo un "
"árbol en el cual cada hijo tiene una referencia al padre y cada padre tiene "
"una lista de hijos) el conteo de referencias no alcanzará nunca el valor de "
"cero.  De vez en cuando, Python ejecuta un algoritmo para detectar esos "
"ciclos pero el recolector de basura debe ejecutarse un rato después de que "
"se desvanezca la última referencia a tu estructura de datos, de tal forma "
"que tu método :meth:`__del__` se pueda invocar en un momento aleatorio que "
"no resulte inconveniente. Esto no es conveniente si estás intentando "
"reproducir un problema. Peor aún, el orden en el que se ejecutan los "
"métodos :meth:`__del__` del objeto es arbitrario.  Puedes ejecutar :func:`gc."
"collect` para forzar una recolección pero *existen* casos patológicos en los "
"cuales los objetos nunca serán recolectados."

#: ../Doc/faq/programming.rst:1707
msgid ""
"Despite the cycle collector, it's still a good idea to define an explicit "
"``close()`` method on objects to be called whenever you're done with them.  "
"The ``close()`` method can then remove attributes that refer to subobjects.  "
"Don't call :meth:`__del__` directly -- :meth:`__del__` should call "
"``close()`` and ``close()`` should make sure that it can be called more than "
"once for the same object."
msgstr ""
"A pesar del recolector de ciclos, siempre será buena idea definir un método "
"``close()`` de forma explícita en objetos que debe ser llamado en el momento "
"que has terminado con ellos.  El método ``close()`` puede, en ese momento, "
"eliminar atributos que se refieren a subobjetos.  No invoques directamente "
"a :meth:`__del__` -- :meth:`__del__` debe invocar a ``close()`` y "
"``close()`` debe asegurarse que puede ser invocado más de una vez en el "
"mismo objeto."

#: ../Doc/faq/programming.rst:1714
msgid ""
"Another way to avoid cyclical references is to use the :mod:`weakref` "
"module, which allows you to point to objects without incrementing their "
"reference count. Tree data structures, for instance, should use weak "
"references for their parent and sibling references (if they need them!)."
msgstr ""
"Otra forma de evitar referencias cíclicas sería usando el módulo :mod:"
"`weakref`, que permite apuntar hacia objetos sin incrementar su conteo de "
"referencias. Las estructuras de datos en árbol, por ejemplo, deberían usar "
"referencias débiles para las referencias del padre y hermanos (¡si es que "
"las necesitan!)."

#: ../Doc/faq/programming.rst:1727
msgid ""
"Finally, if your :meth:`__del__` method raises an exception, a warning "
"message is printed to :data:`sys.stderr`."
msgstr ""
"Finalmente, si tu método :meth:`__del__` lanza una excepción, se manda un "
"mensaje de alerta a :data:`sys.stderr`."

#: ../Doc/faq/programming.rst:1732
msgid "How do I get a list of all instances of a given class?"
msgstr ""
"¿Cómo puedo obtener una lista de todas las instancias de una clase dada?"

#: ../Doc/faq/programming.rst:1734
msgid ""
"Python does not keep track of all instances of a class (or of a built-in "
"type). You can program the class's constructor to keep track of all "
"instances by keeping a list of weak references to each instance."
msgstr ""
"Python no hace seguimiento de todas las instancias de una clase (o de los "
"tipos incorporados). Puedes programar el constructor de una clase para que "
"haga seguimiento de todas sus instancias manteniendo una lista de "
"referencias débiles a cada instancia."

#: ../Doc/faq/programming.rst:1740
msgid "Why does the result of ``id()`` appear to be not unique?"
msgstr "¿Por qué el resultado de ``id()`` no parece ser único?"

#: ../Doc/faq/programming.rst:1742
msgid ""
"The :func:`id` builtin returns an integer that is guaranteed to be unique "
"during the lifetime of the object.  Since in CPython, this is the object's "
"memory address, it happens frequently that after an object is deleted from "
"memory, the next freshly created object is allocated at the same position in "
"memory.  This is illustrated by this example:"
msgstr ""
"La función incorporada :func:`id` devuelve un entero que se garantiza que "
"sea único durante la vida del objeto.  Debido a que en CPython esta es la "
"dirección en memoria del objeto, sucede que, frecuentemente, después de que "
"un objeto se elimina de la memoria el siguiente objeto recién creado se "
"localiza en la misma posición en memoria.  Esto se puede ver ilustrado en "
"este ejemplo:"

#: ../Doc/faq/programming.rst:1753
msgid ""
"The two ids belong to different integer objects that are created before, and "
"deleted immediately after execution of the ``id()`` call.  To be sure that "
"objects whose id you want to examine are still alive, create another "
"reference to the object:"
msgstr ""
"Las dos ids pertenecen a dos objetos 'entero' diferentes que se crean antes "
"y se eliminan inmediatamente después de la ejecución de la invocación a "
"``id()``.  Para estar seguro que los objetos cuya id quieres examinar siguen "
"vivos crea otra referencia al objeto:"

#: ../Doc/faq/programming.rst:1766
msgid "When can I rely on identity tests with the *is* operator?"
msgstr "¿Cuándo puedo fiarme de pruebas de identidad con el operador *is*?"

#: ../Doc/faq/programming.rst:1768
msgid ""
"The ``is`` operator tests for object identity.  The test ``a is b`` is "
"equivalent to ``id(a) == id(b)``."
msgstr ""
"El operador ``is`` verifica la identidad de un objeto. La prueba ``a is b`` "
"es equivalente a ``id(a) == id(b)``."

#: ../Doc/faq/programming.rst:1771
msgid ""
"The most important property of an identity test is that an object is always "
"identical to itself, ``a is a`` always returns ``True``.  Identity tests are "
"usually faster than equality tests.  And unlike equality tests, identity "
"tests are guaranteed to return a boolean ``True`` or ``False``."
msgstr ""
"La propiedad más importante de una prueba de identidad es que un objeto "
"siempre es idéntico a si mismo, ``a is a`` siempre devuelve ``True``.  Las "
"pruebas de identidad suelen ser más rápidas que pruebas de igualdad.  Y a "
"diferencia de las pruebas de igualdad, las pruebas de identidad están "
"garantizadas de devolver un booleano ``True`` o ``False``."

#: ../Doc/faq/programming.rst:1776
msgid ""
"However, identity tests can *only* be substituted for equality tests when "
"object identity is assured.  Generally, there are three circumstances where "
"identity is guaranteed:"
msgstr ""
"Sin embargo, las pruebas de identidad *solo* pueden ser sustituidas por "
"pruebas de igualdad cuando la identidad de objeto está asegurada.  "
"Generalmente hay tres circunstancias en las que la identidad está "
"garantizada:"

#: ../Doc/faq/programming.rst:1780
msgid ""
"1) Assignments create new names but do not change object identity.  After "
"the assignment ``new = old``, it is guaranteed that ``new is old``."
msgstr ""
"1) Las asignaciones crean nuevos nombres pero no cambian la identidad del "
"objeto. Luego de la asignación ``new = old``, está garantizado que ``new is "
"old``."

#: ../Doc/faq/programming.rst:1783
msgid ""
"2) Putting an object in a container that stores object references does not "
"change object identity.  After the list assignment ``s[0] = x``, it is "
"guaranteed that ``s[0] is x``."
msgstr ""
"2) Poner un objeto en un contenedor que guarda referencias de objeto no "
"cambia la identidad del objeto.  Luego de la asignación de lista ``s[0] = "
"x``, está garantizado que ``s[0] is x``."

#: ../Doc/faq/programming.rst:1787
msgid ""
"3) If an object is a singleton, it means that only one instance of that "
"object can exist.  After the assignments ``a = None`` and ``b = None``, it "
"is guaranteed that ``a is b`` because ``None`` is a singleton."
msgstr ""
"3) Si un objeto es un singleton, significa que solo una instancia de ese "
"objeto puede existir.  Después de las asignaciones ``a = None`` y ``b = "
"None``, está garantizado que ``a is b`` porque ``None`` es un singleton."

#: ../Doc/faq/programming.rst:1791
msgid ""
"In most other circumstances, identity tests are inadvisable and equality "
"tests are preferred.  In particular, identity tests should not be used to "
"check constants such as :class:`int` and :class:`str` which aren't "
"guaranteed to be singletons::"
msgstr ""
"En la mayoría de las demás circunstancias, no se recomiendan las pruebas de "
"identidad y las pruebas de igualdad son preferidas.  En particular, las "
"pruebas de identidad no deben ser usadas para verificar constantes como :"
"class:`int` y :class:`str` que no están garantizadas a ser singletons::"

#: ../Doc/faq/programming.rst:1808
msgid "Likewise, new instances of mutable containers are never identical::"
msgstr ""
"De la misma manera, nuevas instancias de contenedores mutables nunca son "
"idénticas::"

#: ../Doc/faq/programming.rst:1815
msgid ""
"In the standard library code, you will see several common patterns for "
"correctly using identity tests:"
msgstr ""
"En la librería estándar de código, verás varios patrones comunes para usar "
"correctamente pruebas de identidad:"

#: ../Doc/faq/programming.rst:1818
msgid ""
"1) As recommended by :pep:`8`, an identity test is the preferred way to "
"check for ``None``.  This reads like plain English in code and avoids "
"confusion with other objects that may have boolean values that evaluate to "
"false."
msgstr ""
"1) Como es recomendado por :pep:`8`, una prueba de identidad es el método "
"preferido para verificar si es ``None``.  Esto se lee como lenguaje normal "
"en el código y evita confusión con otros objetos que puedan tener valores "
"booleanos que se evalúen como falsos."

#: ../Doc/faq/programming.rst:1822
#, fuzzy
msgid ""
"2) Detecting optional arguments can be tricky when ``None`` is a valid input "
"value.  In those situations, you can create a singleton sentinel object "
"guaranteed to be distinct from other objects.  For example, here is how to "
"implement a method that behaves like :meth:`dict.pop`::"
msgstr ""
"2) La detección de argumentos opcionales puede resultar complicada cuando "
"``None`` es un valor de entrada válido. En esas situaciones, puede crear un "
"objeto centinela singleton garantizado para ser distinto de otros objetos. "
"Por ejemplo, aquí se explica cómo implementar un método que se comporta "
"como :meth:`dict.pop`:"

#: ../Doc/faq/programming.rst:1838
msgid ""
"3) Container implementations sometimes need to augment equality tests with "
"identity tests.  This prevents the code from being confused by objects such "
"as ``float('NaN')`` that are not equal to themselves."
msgstr ""
"3) Las implementaciones de contenedor a veces necesitan aumentar pruebas de "
"igualdad con pruebas de identidad.  Esto previene que el código sea "
"confundido con objetos como ``float('NaN')`` que no son iguales que si "
"mismos."

#: ../Doc/faq/programming.rst:1842
msgid ""
"For example, here is the implementation of :meth:`collections.abc.Sequence."
"__contains__`::"
msgstr ""
"Por ejemplo, acá está la implementación de :meth:`collections.abc.Sequence."
"__contains__`::"

#: ../Doc/faq/programming.rst:1853
msgid ""
"How can a subclass control what data is stored in an immutable instance?"
msgstr ""
"¿Cómo puede una subclase controlar qué datos se almacenan en una instancia "
"inmutable?"

#: ../Doc/faq/programming.rst:1855
msgid ""
"When subclassing an immutable type, override the :meth:`__new__` method "
"instead of the :meth:`__init__` method.  The latter only runs *after* an "
"instance is created, which is too late to alter data in an immutable "
"instance."
msgstr ""
"Cuando se subclasifica un tipo inmutable, se debe anular el método :meth:"
"`__new__` en lugar del método :meth:`__init__`.  El último solo corre "
"*después* de que una instancia es creada, y entonces ya es muy tarde para "
"alterar datos en una instancia inmutable."

#: ../Doc/faq/programming.rst:1860
msgid ""
"All of these immutable classes have a different signature than their parent "
"class:"
msgstr ""
"Todas estas clases inmutables tienen una firma distinta que su clase padre:"

#: ../Doc/faq/programming.rst:1886
msgid "The classes can be used like this:"
msgstr "Las clases pueden ser utilizadas así:"

#: ../Doc/faq/programming.rst:1903
msgid "How do I cache method calls?"
msgstr "¿Cómo cacheo llamadas de método?"

#: ../Doc/faq/programming.rst:1905
msgid ""
"The two principal tools for caching methods are :func:`functools."
"cached_property` and :func:`functools.lru_cache`.  The former stores results "
"at the instance level and the latter at the class level."
msgstr ""
"Las dos herramientas principales para cachear métodos son :func:`functools."
"cached_property` y :func:`functools.lru_cache`.  El primero guarda "
"resultados a nivel de instancia y el último a nivel de clase."

#: ../Doc/faq/programming.rst:1910
msgid ""
"The *cached_property* approach only works with methods that do not take any "
"arguments.  It does not create a reference to the instance.  The cached "
"method result will be kept only as long as the instance is alive."
msgstr ""
"La función *cached_property* sólo funciona con métodos que no acepten "
"argumentos.  No crea una referencia a la instancia.  El resultado del método "
"cacheado se mantendrá solo mientras que la instancia esté activa."

#: ../Doc/faq/programming.rst:1914
#, fuzzy
msgid ""
"The advantage is that when an instance is no longer used, the cached method "
"result will be released right away.  The disadvantage is that if instances "
"accumulate, so too will the accumulated method results.  They can grow "
"without bound."
msgstr ""
"La ventaja es que cuando una instancia ya no está siendo usada, el método "
"cacheado será liberado inmediatamente.  La desventaja es que si las "
"instancias se acumulan, también se acumularán los métodos resultantes.  "
"Pueden crecer sin límite."

#: ../Doc/faq/programming.rst:1919
msgid ""
"The *lru_cache* approach works with methods that have hashable arguments.  "
"It creates a reference to the instance unless special efforts are made to "
"pass in weak references."
msgstr ""
"La función *lru_cache* funciona con métodos que tienen argumentos "
"hashables.  Crea una referencia a la instancia a menos que esfuerzos "
"especiales sean realizados para pasar en referencias débiles."

#: ../Doc/faq/programming.rst:1923
msgid ""
"The advantage of the least recently used algorithm is that the cache is "
"bounded by the specified *maxsize*.  The disadvantage is that instances are "
"kept alive until they age out of the cache or until the cache is cleared."
msgstr ""
"La ventaja del algoritmo usado menos recientemente es que el cache está "
"limitado por el *maxsize* especificado.  La desventaja es que las instancias "
"se mantienen activas hasta que sean eliminadas del cache por edad o que el "
"cache sea borrado."

#: ../Doc/faq/programming.rst:1928
msgid "This example shows the various techniques::"
msgstr "Este ejemplo muestra las diversas técnicas::"

#: ../Doc/faq/programming.rst:1952
msgid ""
"The above example assumes that the *station_id* never changes.  If the "
"relevant instance attributes are mutable, the *cached_property* approach "
"can't be made to work because it cannot detect changes to the attributes."
msgstr ""
"El ejemplo anterior asume que la *station_id* nunca cambia.  Si los "
"atributos de la instancia relevante son mutables, el método de "
"*cached_property* no puede funcionar porque no puede detectar cambios en los "
"atributos."

#: ../Doc/faq/programming.rst:1957
#, fuzzy
msgid ""
"To make the *lru_cache* approach work when the *station_id* is mutable, the "
"class needs to define the *__eq__* and *__hash__* methods so that the cache "
"can detect relevant attribute updates::"
msgstr ""
"Se puede hacer que el método *lru_cache* funcione, pero la clase debe "
"definir los métodos *__eq__* y *__hash__* para que el cache pueda detectar "
"cambios relevantes de atributo::"

#: ../Doc/faq/programming.rst:1983
msgid "Modules"
msgstr "Módulos"

#: ../Doc/faq/programming.rst:1986
msgid "How do I create a .pyc file?"
msgstr "¿Cómo creo un fichero .pyc?"

#: ../Doc/faq/programming.rst:1988
msgid ""
"When a module is imported for the first time (or when the source file has "
"changed since the current compiled file was created) a ``.pyc`` file "
"containing the compiled code should be created in a ``__pycache__`` "
"subdirectory of the directory containing the ``.py`` file.  The ``.pyc`` "
"file will have a filename that starts with the same name as the ``.py`` "
"file, and ends with ``.pyc``, with a middle component that depends on the "
"particular ``python`` binary that created it.  (See :pep:`3147` for details.)"
msgstr ""
"Cuando se importa un módulo por primera vez (o cuando el código fuente ha "
"cambiado desde que el fichero compilado se creó) un fichero ``.pyc`` que "
"contiene el código compilado se debería crear en la subcarpeta "
"``__pycache__`` del directorio que contiene al fichero ``.py``.  El fichero "
"``.pyc`` tendrá un nombre que empezará con el mismo nombre que el del "
"fichero  ``.py`` y terminará con ``.pyc``, con un componente intermedio que "
"dependerá del binario ``python`` en particular que lo creó.  (Ver :pep:"
"`3147` para detalles.)"

#: ../Doc/faq/programming.rst:1996
msgid ""
"One reason that a ``.pyc`` file may not be created is a permissions problem "
"with the directory containing the source file, meaning that the "
"``__pycache__`` subdirectory cannot be created. This can happen, for "
"example, if you develop as one user but run as another, such as if you are "
"testing with a web server."
msgstr ""
"Una razón por la que no se cree un fichero ``.pyc`` podría ser debido a un "
"problema de permisos del directorio que contiene al fichero fuente, lo que "
"significa que el subdirectorio ``__pycache__`` no se puede crear. Esto puede "
"suceder, por ejemplo, si desarrollas como un usuario pero lo ejecutas como "
"otro, como si estuvieras probando en un servidor web."

#: ../Doc/faq/programming.rst:2001
msgid ""
"Unless the :envvar:`PYTHONDONTWRITEBYTECODE` environment variable is set, "
"creation of a .pyc file is automatic if you're importing a module and Python "
"has the ability (permissions, free space, etc...) to create a "
"``__pycache__`` subdirectory and write the compiled module to that "
"subdirectory."
msgstr ""
"Hasta que no definas la variable de entorno :envvar:"
"`PYTHONDONTWRITEBYTECODE`, la creación de un fichero .pyc se hará "
"automáticamente si importas un módulo y Python dispone de la habilidad "
"(permisos, espacio libre, etc...) para crear un subdirectorio "
"``__pycache__`` y escribir un módulo compilado en ese subdirectorio."

#: ../Doc/faq/programming.rst:2006
msgid ""
"Running Python on a top level script is not considered an import and no ``."
"pyc`` will be created.  For example, if you have a top-level module ``foo."
"py`` that imports another module ``xyz.py``, when you run ``foo`` (by typing "
"``python foo.py`` as a shell command), a ``.pyc`` will be created for "
"``xyz`` because ``xyz`` is imported, but no ``.pyc`` file will be created "
"for ``foo`` since ``foo.py`` isn't being imported."
msgstr ""
"La ejecución de un script principal Python no se considera una importación y "
"no se crea el fichero ``.pyc``.  Por ejemplo, Si tienes un módulo principal "
"``foo.py`` que importa a otro módulo ``xyz.py``, cuando ejecutas ``foo`` "
"(mediante un comando de la shell ``python foo.py``), se creará un fichero ``."
"pyc`` para ``xyz`` porque ``xyz`` ha sido importado, pero no se creará un "
"fichero ``.pyc`` para ``foo`` ya que ``foo.py`` no ha sido importado."

#: ../Doc/faq/programming.rst:2013
msgid ""
"If you need to create a ``.pyc`` file for ``foo`` -- that is, to create a ``."
"pyc`` file for a module that is not imported -- you can, using the :mod:"
"`py_compile` and :mod:`compileall` modules."
msgstr ""
"Si necesitas crear un fichero ``.pyc`` también para ``foo`` -- es decir, "
"crear un fichero ``.pyc`` para un módulo que no ha sido importado -- puedes "
"usar los módulos :mod:`py_compile` y :mod:`compileall`."

#: ../Doc/faq/programming.rst:2017
msgid ""
"The :mod:`py_compile` module can manually compile any module.  One way is to "
"use the ``compile()`` function in that module interactively::"
msgstr ""
"El módulo :mod:`py_compile` puede compilar manualmente cualquier módulo.  "
"Una forma sería usando la función ``compile()`` de ese módulo de forma "
"interactiva::"

#: ../Doc/faq/programming.rst:2023
msgid ""
"This will write the ``.pyc`` to a ``__pycache__`` subdirectory in the same "
"location as ``foo.py`` (or you can override that with the optional parameter "
"``cfile``)."
msgstr ""
"Esto escribirá ``.pyc`` en el subdirectorio ``__pycache__`` en la misma "
"localización en la que se encuentre ``foo.py`` (o, puedes sobreescribir ese "
"comportamiento con el parámetro opcional ``cfile``)."

#: ../Doc/faq/programming.rst:2027
msgid ""
"You can also automatically compile all files in a directory or directories "
"using the :mod:`compileall` module.  You can do it from the shell prompt by "
"running ``compileall.py`` and providing the path of a directory containing "
"Python files to compile::"
msgstr ""
"Puedes compilar automáticamente todos los ficheros en un directorio o "
"directorios usando el módulo :mod:`compileall`.  Lo puedes hacer desde la "
"línea de comandos ejecutando ``compileall.py`` y proporcionando una ruta al "
"directorio que contiene los ficheros Python a compilar::"

#: ../Doc/faq/programming.rst:2036
msgid "How do I find the current module name?"
msgstr "¿Cómo puedo encontrar el nombre del módulo en uso?"

#: ../Doc/faq/programming.rst:2038
msgid ""
"A module can find out its own module name by looking at the predefined "
"global variable ``__name__``.  If this has the value ``'__main__'``, the "
"program is running as a script.  Many modules that are usually used by "
"importing them also provide a command-line interface or a self-test, and "
"only execute this code after checking ``__name__``::"
msgstr ""
"Un módulo puede encontrar su propio nombre mirando en la variable global "
"predeterminada ``__name__``.  Si tiene el valor ``'__main__'``, el programa "
"se está ejecutando como un script.  Muchos módulos que se usan, "
"generalmente, importados en otro script proporcionan, además, una interfaz "
"para la línea de comandos o para probarse a si mismos y solo ejecutan código "
"después de comprobar ``__name__``::"

#: ../Doc/faq/programming.rst:2053
msgid "How can I have modules that mutually import each other?"
msgstr "¿Cómo podría tener módulos que se importan mutuamente entre ellos?"

#: ../Doc/faq/programming.rst:2055
msgid "Suppose you have the following modules:"
msgstr "Supón que tienes los siguientes módulos:"

#: ../Doc/faq/programming.rst:2057
msgid ":file:`foo.py`::"
msgstr ":file:`foo.py`::"

#: ../Doc/faq/programming.rst:2062
msgid ":file:`bar.py`::"
msgstr ":file:`bar.py`::"

#: ../Doc/faq/programming.rst:2067
msgid "The problem is that the interpreter will perform the following steps:"
msgstr "El problema es que el intérprete realizará los siguientes pasos:"

#: ../Doc/faq/programming.rst:2069
msgid "main imports ``foo``"
msgstr "main importa a ``foo``"

#: ../Doc/faq/programming.rst:2070
msgid "Empty globals for ``foo`` are created"
msgstr "Se crean *globals* vacíos para foo"

#: ../Doc/faq/programming.rst:2071
msgid "``foo`` is compiled and starts executing"
msgstr "``foo`` se compila y se comienza a ejecutar"

#: ../Doc/faq/programming.rst:2072
msgid "``foo`` imports ``bar``"
msgstr "``foo`` importa a ``bar``"

#: ../Doc/faq/programming.rst:2073
msgid "Empty globals for ``bar`` are created"
msgstr "Se crean *globals* vacíos para ``bar``"

#: ../Doc/faq/programming.rst:2074
msgid "``bar`` is compiled and starts executing"
msgstr "``bar`` se compila y se comienza a ejecutar"

#: ../Doc/faq/programming.rst:2075
msgid ""
"``bar`` imports ``foo`` (which is a no-op since there already is a module "
"named ``foo``)"
msgstr ""
"``bar`` importa a ``foo`` (lo cual es un no-op ya que ya hay un módulo que "
"se llama ``foo``)"

#: ../Doc/faq/programming.rst:2076
msgid ""
"The import mechanism tries to read ``foo_var`` from ``foo`` globals, to set "
"``bar.foo_var = foo.foo_var``"
msgstr ""
"El mecanismo de importado intenta leer ``foo_var`` de globales de ``foo``, "
"para establecer ``bar.foo_var = foo.foo_var``"

#: ../Doc/faq/programming.rst:2078
msgid ""
"The last step fails, because Python isn't done with interpreting ``foo`` yet "
"and the global symbol dictionary for ``foo`` is still empty."
msgstr ""
"El último paso falla debido a que Python todavía no ha terminado de "
"interpretar a ``foo`` y el diccionario de símbolos global para ``foo`` "
"todavía se encuentra vacío."

#: ../Doc/faq/programming.rst:2081
msgid ""
"The same thing happens when you use ``import foo``, and then try to access "
"``foo.foo_var`` in global code."
msgstr ""
"Lo mismo ocurre cuando usas ``import foo`` y luego tratas de acceder a ``foo."
"foo_var`` en un código global."

#: ../Doc/faq/programming.rst:2084
msgid "There are (at least) three possible workarounds for this problem."
msgstr "Existen (al menos) tres posibles soluciones para este problema."

#: ../Doc/faq/programming.rst:2086
msgid ""
"Guido van Rossum recommends avoiding all uses of ``from <module> import ..."
"``, and placing all code inside functions.  Initializations of global "
"variables and class variables should use constants or built-in functions "
"only.  This means everything from an imported module is referenced as "
"``<module>.<name>``."
msgstr ""
"Guido van Rossum recomienda evitar todos los usos de ``from <module> "
"import ...``, y colocar todo el código dentro de funciones.  La "
"inicialización de variables globales y variables de clase debería usar "
"únicamente constantes o funciones incorporadas .  Esto significa que todo se "
"referenciará como ``<module>.<name>`` desde un módulo importado."

#: ../Doc/faq/programming.rst:2091
msgid ""
"Jim Roskind suggests performing steps in the following order in each module:"
msgstr ""
"Jim Roskind sugiere realizar los siguientes pasos en el siguiente orden en "
"cada módulo:"

#: ../Doc/faq/programming.rst:2093
msgid ""
"exports (globals, functions, and classes that don't need imported base "
"classes)"
msgstr ""
"exportar (*globals*, funciones y clases que no necesitan clases bases "
"importadas)"

#: ../Doc/faq/programming.rst:2095
msgid "``import`` statements"
msgstr "``import`` declaraciones"

#: ../Doc/faq/programming.rst:2096
msgid ""
"active code (including globals that are initialized from imported values)."
msgstr ""
"código activo (incluyendo *globals* que han sido inicializados desde valores "
"importados)."

#: ../Doc/faq/programming.rst:2098
#, fuzzy
msgid ""
"Van Rossum doesn't like this approach much because the imports appear in a "
"strange place, but it does work."
msgstr ""
"este enfoque no le gusta mucho a van Rossum debido a que los import aparecen "
"en lugares extraños, pero funciona."

#: ../Doc/faq/programming.rst:2101
msgid ""
"Matthias Urlichs recommends restructuring your code so that the recursive "
"import is not necessary in the first place."
msgstr ""
"Matthias Urlichs recomienda reestructurar tu código de tal forma que un "
"import recursivo no sea necesario."

#: ../Doc/faq/programming.rst:2104
msgid "These solutions are not mutually exclusive."
msgstr "Estas soluciones no son mutuamente excluyentes."

#: ../Doc/faq/programming.rst:2108
msgid "__import__('x.y.z') returns <module 'x'>; how do I get z?"
msgstr "__import__('x.y.z') devuelve <module 'x'>; ¿cómo puedo obtener z?"

#: ../Doc/faq/programming.rst:2110
msgid ""
"Consider using the convenience function :func:`~importlib.import_module` "
"from :mod:`importlib` instead::"
msgstr ""
"Considera, en su lugar, usa la función de conveniencia :func:`~importlib."
"import_module` de :mod:`importlib`::"

#: ../Doc/faq/programming.rst:2117
msgid ""
"When I edit an imported module and reimport it, the changes don't show up.  "
"Why does this happen?"
msgstr ""
"Cuando edito un módulo importado y lo reimporto los cambios no tienen "
"efecto. ¿Por qué sucede esto?"

#: ../Doc/faq/programming.rst:2119
msgid ""
"For reasons of efficiency as well as consistency, Python only reads the "
"module file on the first time a module is imported.  If it didn't, in a "
"program consisting of many modules where each one imports the same basic "
"module, the basic module would be parsed and re-parsed many times.  To force "
"re-reading of a changed module, do this::"
msgstr ""
"Por razones de eficiencia además de por consistencia, Python solo lee el "
"fichero del módulo la primera vez que el módulo se importa.  Si no lo "
"hiciera así, un programa escrito en muchos módulos donde cada módulo importa "
"al mismo módulo básico estaría analizando sintácticamente el mismo módulo "
"básico muchas veces.  Para forzar una relectura de un módulo que ha sido "
"modificado haz lo siguiente::"

#: ../Doc/faq/programming.rst:2129
#, python-format
msgid ""
"Warning: this technique is not 100% fool-proof.  In particular, modules "
"containing statements like ::"
msgstr ""
"Alerta: esta técnica no es 100% segura.  En particular, los módulos que "
"contienen declaraciones como ::"

#: ../Doc/faq/programming.rst:2134
msgid ""
"will continue to work with the old version of the imported objects.  If the "
"module contains class definitions, existing class instances will *not* be "
"updated to use the new class definition.  This can result in the following "
"paradoxical behaviour::"
msgstr ""
"continuarán funcionando con la versión antigua de los objetos importados.  "
"Si el módulo contiene definiciones de clase, instancias de clase ya "
"existentes *no* se actualizarán para usar la nueva definición de la clase.  "
"Esto podría resultar en el comportamiento paradójico siguiente::"

#: ../Doc/faq/programming.rst:2147
msgid ""
"The nature of the problem is made clear if you print out the \"identity\" of "
"the class objects::"
msgstr ""
"La naturaleza del problema se hace evidente si muestras la \"identity\" de "
"los objetos clase::"
