# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
# Translation started and completed partially by:
# Marcos Sánchez Provencio <raptopassion@gmail.com>, 2020.
# Translation finished by:
# Claudia Millán (clacri), 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-25 19:47+0200\n"
"PO-Revision-Date: 2022-10-31 01:06-0300\n"
"Last-Translator: Claudia Millán (@clacri)\n"
"Language-Team: python-doc-es\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.10.3\n"
"X-Generator: Poedit 3.2\n"

#: ../Doc/library/unittest.rst:2
msgid ":mod:`unittest` --- Unit testing framework"
msgstr ":mod:`unittest` --- Infraestructura de tests unitarios"

#: ../Doc/library/unittest.rst:12
msgid "**Source code:** :source:`Lib/unittest/__init__.py`"
msgstr "**Código fuente:** :source:`Lib/unittest/__init__.py`"

#: ../Doc/library/unittest.rst:16
msgid ""
"(If you are already familiar with the basic concepts of testing, you might "
"want to skip to :ref:`the list of assert methods <assert-methods>`.)"
msgstr ""
"(Si ya estás familiarizado con los conceptos básicos de realización de "
"tests, puedes saltar a :ref:`la lista de métodos de aserción <assert-"
"methods>`.)"

#: ../Doc/library/unittest.rst:19
msgid ""
"The :mod:`unittest` unit testing framework was originally inspired by JUnit "
"and has a similar flavor as major unit testing frameworks in other "
"languages.  It supports test automation, sharing of setup and shutdown code "
"for tests, aggregation of tests into collections, and independence of the "
"tests from the reporting framework."
msgstr ""
"La infraestructura de tests unitarios :mod:`unittest` se inspiró en primera "
"instancia en JUnit y ofrece aspectos similares a las principales estructuras "
"de tests unitarios más importantes de otros lenguajes.  Da soporte a "
"automatización de tests, inicialización compartida, código de cierre de los "
"tests, agregación de los tests en colecciones e independencia de los tests "
"de la infraestructura que los reporta."

#: ../Doc/library/unittest.rst:25
msgid ""
"To achieve this, :mod:`unittest` supports some important concepts in an "
"object-oriented way:"
msgstr ""
"Para conseguir esto, :mod:`unittest` da soporte a ciertos conceptos "
"importantes de una forma orientada a objetos:"

#: ../Doc/library/unittest.rst:32
msgid "test fixture"
msgstr "configuración de prueba (*fixture*)"

#: ../Doc/library/unittest.rst:29
msgid ""
"A :dfn:`test fixture` represents the preparation needed to perform one or "
"more tests, and any associated cleanup actions.  This may involve, for "
"example, creating temporary or proxy databases, directories, or starting a "
"server process."
msgstr ""
"Un :dfn:`test fixture` representa los preparativos para realizar una o más "
"pruebas y las acciones de limpieza asociadas. Esto puede incluir, por "
"ejemplo, la creación de bases de datos temporales, directorios o el arranque "
"de procesos del servidor."

#: ../Doc/library/unittest.rst:37
msgid "test case"
msgstr "caso de prueba"

#: ../Doc/library/unittest.rst:35
msgid ""
"A :dfn:`test case` is the individual unit of testing.  It checks for a "
"specific response to a particular set of inputs.  :mod:`unittest` provides a "
"base class, :class:`TestCase`, which may be used to create new test cases."
msgstr ""
"Un :dfn:`test case` es la unidad mínima de prueba. Verifica la respuesta "
"específica a un juego particular de entradas. :mod:`unittest` proporciona "
"una clase base, :class:`TestCase`, que se puede utilizar para crear nuevos "
"casos de uso."

#: ../Doc/library/unittest.rst:41
msgid "test suite"
msgstr "conjunto de pruebas"

#: ../Doc/library/unittest.rst:40
msgid ""
"A :dfn:`test suite` is a collection of test cases, test suites, or both.  It "
"is used to aggregate tests that should be executed together."
msgstr ""
"Un :dfn:`test suite` es una colección de casos de prueba, juegos de prueba o "
"ambos. Se usa para agrupar pruebas que se han de ejecutar juntas."

#: ../Doc/library/unittest.rst:48
msgid "test runner"
msgstr "ejecutor de pruebas"

#: ../Doc/library/unittest.rst:44
msgid ""
"A :dfn:`test runner` is a component which orchestrates the execution of "
"tests and provides the outcome to the user.  The runner may use a graphical "
"interface, a textual interface, or return a special value to indicate the "
"results of executing the tests."
msgstr ""
"Un :dfn:`test runner` es un componente que dirige la ejecución de las "
"pruebas y proporciona un resultado. El ejecutor puede disponer de una "
"interfaz gráfica, de texto o devolver un valor especial que indique el "
"resultado de la ejecución de las pruebas."

#: ../Doc/library/unittest.rst:53
msgid "Module :mod:`doctest`"
msgstr "Módulo :mod:`doctest`"

#: ../Doc/library/unittest.rst:53
msgid "Another test-support module with a very different flavor."
msgstr "Otro módulo de soporte a pruebas con una solución muy diferente."

#: ../Doc/library/unittest.rst:57
msgid ""
"`Simple Smalltalk Testing: With Patterns <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"
msgstr ""
"`Simple Smalltalk Testing: With Patterns <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"

#: ../Doc/library/unittest.rst:56
msgid ""
"Kent Beck's original paper on testing frameworks using the pattern shared "
"by :mod:`unittest`."
msgstr ""
"El documento original de Kent Beck sobre infraestructuras de prueba mediante "
"el patrón que utiliza :mod:`unittest`."

#: ../Doc/library/unittest.rst:61
msgid "`pytest <https://docs.pytest.org/>`_"
msgstr "`pytest <https://docs.pytest.org/>`_"

#: ../Doc/library/unittest.rst:60
msgid ""
"Third-party unittest framework with a lighter-weight syntax for writing "
"tests.  For example, ``assert func(10) == 42``."
msgstr ""
"Una infraestructura de pruebas unitarias de otro proveedor con una sintaxis "
"más ligera de escritura de pruebas, por ejemplo: ``assert func(10) == 42``."

#: ../Doc/library/unittest.rst:65
msgid ""
"`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"
msgstr ""
"`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"

#: ../Doc/library/unittest.rst:64
msgid ""
"An extensive list of Python testing tools including functional testing "
"frameworks and mock object libraries."
msgstr ""
"Una lista extensa de herramientas de prueba para Python incluyendo "
"infraestructuras de pruebas funcionales y librerías de objetos sucedáneos."

#: ../Doc/library/unittest.rst:69
msgid ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"
msgstr ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"

#: ../Doc/library/unittest.rst:68
msgid ""
"A special-interest-group for discussion of testing, and testing tools, in "
"Python."
msgstr ""
"Grupo especializado en debate sobre las pruebas y las herramientas de prueba "
"de Python."

#: ../Doc/library/unittest.rst:71
msgid ""
"The script :file:`Tools/unittestgui/unittestgui.py` in the Python source "
"distribution is a GUI tool for test discovery and execution.  This is "
"intended largely for ease of use for those new to unit testing.  For "
"production environments it is recommended that tests be driven by a "
"continuous integration system such as `Buildbot <https://buildbot.net/>`_, "
"`Jenkins <https://jenkins.io/>`_, `GitHub Actions <https://github.com/"
"features/actions>`_, or `AppVeyor <https://www.appveyor.com/>`_."
msgstr ""
"El script :file:`Tools/unittestgui/unittestgui.py` de la distribución de "
"fuentes de Python es una herramienta gráfica para el descubrimiento y "
"ejecución de pruebas. Está orientado sobre todo a principiantes en el tema "
"de pruebas. Para entornos de producción se recomienda que las pruebas sean "
"dirigidas por un sistema de integración continua como `Buildbot <https://"
"buildbot.net/>`_, `Jenkins <https://jenkins.io/>`_, `GitHub Actions <https://"
"github.com/features/actions>`_ o `AppVeyor <https://www.appveyor.com/>`_."

#: ../Doc/library/unittest.rst:83
msgid "Basic example"
msgstr "Ejemplo sencillo"

#: ../Doc/library/unittest.rst:85
msgid ""
"The :mod:`unittest` module provides a rich set of tools for constructing and "
"running tests.  This section demonstrates that a small subset of the tools "
"suffice to meet the needs of most users."
msgstr ""
"El módulo :mod:`unittest` proporciona un conjunto de herramientas para "
"construir y ejecutar pruebas. Esta sección demuestra que un pequeño "
"subconjunto de las herramientas es suficiente para satisfacer las "
"necesidades de la mayoría."

#: ../Doc/library/unittest.rst:89
msgid "Here is a short script to test three string methods::"
msgstr "He aquí un breve script para probar estros tres métodos de cadena::"

#: ../Doc/library/unittest.rst:113
msgid ""
"A testcase is created by subclassing :class:`unittest.TestCase`.  The three "
"individual tests are defined with methods whose names start with the letters "
"``test``.  This naming convention informs the test runner about which "
"methods represent tests."
msgstr ""
"Para crear un caso de prueba se genera una subclase de :class:`unittest."
"TestCase`. Las tres pruebas se definen con métodos cuyos nombres comienzan "
"por las letras ``test``. Esta convención sobre nombres indica al ejecutor de "
"pruebas qué métodos representan pruebas."

#: ../Doc/library/unittest.rst:118
msgid ""
"The crux of each test is a call to :meth:`~TestCase.assertEqual` to check "
"for an expected result; :meth:`~TestCase.assertTrue` or :meth:`~TestCase."
"assertFalse` to verify a condition; or :meth:`~TestCase.assertRaises` to "
"verify that a specific exception gets raised.  These methods are used "
"instead of the :keyword:`assert` statement so the test runner can accumulate "
"all test results and produce a report."
msgstr ""
"El quid de cada test es la llamada a  :meth:`~TestCase.assertEqual` para "
"verificar un resultado esperado; :meth:`~TestCase.assertTrue` o :meth:"
"`~TestCase.assertFalse` para verificar una condición; o :meth:`~TestCase."
"assertRaises` para asegurar que se lanza una excepción específica. Se "
"utilizan estos métodos en lugar de la sentencia :keyword:`assert` para que "
"el ejecutor de pruebas pueda acumular todos los resultados de la prueba de "
"cara a realizar un informe."

#: ../Doc/library/unittest.rst:125
msgid ""
"The :meth:`~TestCase.setUp` and :meth:`~TestCase.tearDown` methods allow you "
"to define instructions that will be executed before and after each test "
"method. They are covered in more detail in the section :ref:`organizing-"
"tests`."
msgstr ""
"Los métodos :meth:`~TestCase.setUp` y :meth:`~TestCase.tearDown` permiten "
"definir instrucciones que han de ser ejecutadas antes y después, "
"respectivamente, de cada método de prueba. Se describen con mas detalle en "
"la sección :ref:`organizing-tests`."

#: ../Doc/library/unittest.rst:129
msgid ""
"The final block shows a simple way to run the tests. :func:`unittest.main` "
"provides a command-line interface to the test script.  When run from the "
"command line, the above script produces an output that looks like this::"
msgstr ""
"El bloque final muestra un modo sencillo de ejecutar las pruebas. :func:"
"`unittest.main` proporciona una interfaz de línea de órdenes para el script "
"de prueba. Cuando se ejecuta desde la línea de órdenes, el script anterior "
"produce una salida como::"

#: ../Doc/library/unittest.rst:139
msgid ""
"Passing the ``-v`` option to your test script will instruct :func:`unittest."
"main` to enable a higher level of verbosity, and produce the following "
"output::"
msgstr ""
"Si se le pasa una opción ``-v`` al script de prueba, se establecerá un nivel "
"mayor de detalle del proceso de :func:`unittest.main` y se obtendrá la "
"siguiente salida::"

#: ../Doc/library/unittest.rst:151
msgid ""
"The above examples show the most commonly used :mod:`unittest` features "
"which are sufficient to meet many everyday testing needs.  The remainder of "
"the documentation explores the full feature set from first principles."
msgstr ""
"Los ejemplos anteriores muestra las características más usuales de :mod:"
"`unittest`, que son suficientes para solventar las necesidades cotidianas de "
"pruebas. El resto de la documentación explora el juego completo de "
"características, que abundan en los mismos principios."

#: ../Doc/library/unittest.rst:155
msgid ""
"The behavior of returning a value from a test method (other than the default "
"``None`` value), is now deprecated."
msgstr ""
"El comportamiento de retornar un valor de un método de prueba (que no sea el "
"valor por defecto ``None``), ahora está obsoleto."

#: ../Doc/library/unittest.rst:163
msgid "Command-Line Interface"
msgstr "Interfaz de línea de comandos"

#: ../Doc/library/unittest.rst:165
msgid ""
"The unittest module can be used from the command line to run tests from "
"modules, classes or even individual test methods::"
msgstr ""
"Se puede usar el módulo `unittest` desde la línea de órdenes para ejecutar "
"pruebas de módulos, clases o hasta métodos de prueba individuales::"

#: ../Doc/library/unittest.rst:172
msgid ""
"You can pass in a list with any combination of module names, and fully "
"qualified class or method names."
msgstr ""
"Se puede pasar una lista con cualquier combinación de nombres de módulo, así "
"como clases o métodos completamente cualificados."

#: ../Doc/library/unittest.rst:175
msgid "Test modules can be specified by file path as well::"
msgstr ""
"Se puede especificar los módulos de prueba por ruta de fichero también::"

#: ../Doc/library/unittest.rst:179
msgid ""
"This allows you to use the shell filename completion to specify the test "
"module. The file specified must still be importable as a module. The path is "
"converted to a module name by removing the '.py' and converting path "
"separators into '.'. If you want to execute a test file that isn't "
"importable as a module you should execute the file directly instead."
msgstr ""
"Esto permite usar el completado automático de nombre de fichero de la shell "
"para especificar el módulo de pruebas. El fichero especificado aún debe ser "
"susceptible de importarse como módulo. La ruta se convierte en nombre de "
"módulo eliminando '.py' y convirtiendo el separador de directorios por '.'. "
"Si se desea ejecutar un fichero de prueba que no se puede importar como "
"módulo, se ha de ejecutar el fichero directamente."

#: ../Doc/library/unittest.rst:185
msgid ""
"You can run tests with more detail (higher verbosity) by passing in the -v "
"flag::"
msgstr ""
"Se pueden ejecutar las pruebas con más nivel de detalle (mayor verbosidad) "
"pasando el parámetro `-v`::"

#: ../Doc/library/unittest.rst:189
msgid ""
"When executed without arguments :ref:`unittest-test-discovery` is started::"
msgstr ""
"Cuando se ejecuta sin argumentos, se inicia :ref:`unittest-test-discovery`::"

#: ../Doc/library/unittest.rst:193
msgid "For a list of all the command-line options::"
msgstr "Para obtener una lista de todas las opciones de línea de órdenes::"

#: ../Doc/library/unittest.rst:197
msgid ""
"In earlier versions it was only possible to run individual test methods and "
"not modules or classes."
msgstr ""
"En versiones anteriores sólo era posible ejecutar métodos de prueba "
"individuales, pero no módulos ni clases."

#: ../Doc/library/unittest.rst:203
msgid "Command-line options"
msgstr "Opciones de la línea de órdenes"

#: ../Doc/library/unittest.rst:205
msgid ":program:`unittest` supports these command-line options:"
msgstr ""
":program:`unittest` da soporte a las siguientes opciones de línea de órdenes:"

#: ../Doc/library/unittest.rst:211
msgid ""
"The standard output and standard error streams are buffered during the test "
"run. Output during a passing test is discarded. Output is echoed normally on "
"test fail or error and is added to the failure messages."
msgstr ""
"Los flujos de datos de salida estándar y error estándar se acumulan en un "
"búfer durante la ejecución de pruebas. La salida de las pruebas correctas se "
"descarta. La salida de las pruebas que fallan o devuelven un error se añade "
"a los mensajes de fallo."

#: ../Doc/library/unittest.rst:217
msgid ""
":kbd:`Control-C` during the test run waits for the current test to end and "
"then reports all the results so far. A second :kbd:`Control-C` raises the "
"normal :exc:`KeyboardInterrupt` exception."
msgstr ""
"La pulsación de :kbd:`Control-C` durante la ejecución de pruebas espera a "
"que termine la prueba en curso y da un informe de los resultados hasta ese "
"momento. Una segunda pulsación de :kbd:`Control-C` lanza la excepción :exc:"
"`KeyboardInterrupt` usual."

#: ../Doc/library/unittest.rst:221
msgid ""
"See `Signal Handling`_ for the functions that provide this functionality."
msgstr ""
"Consultar  en `Gestión de señales`_ las funciones que proporcionan esta "
"funcionalidad."

#: ../Doc/library/unittest.rst:225
msgid "Stop the test run on the first error or failure."
msgstr "Finaliza la ejecución tras el primer error o fallo."

#: ../Doc/library/unittest.rst:229
msgid ""
"Only run test methods and classes that match the pattern or substring. This "
"option may be used multiple times, in which case all test cases that match "
"any of the given patterns are included."
msgstr ""
"Ejecutar solamente los métodos y clases de prueba que coincidan con el "
"patrón o subcadena de caracteres. Esta opción se puede usar más de una vez, "
"en cuyo caso se incluirán todos los casos de prueba que coincidan con "
"cualquiera de los patrones dados."

#: ../Doc/library/unittest.rst:233
msgid ""
"Patterns that contain a wildcard character (``*``) are matched against the "
"test name using :meth:`fnmatch.fnmatchcase`; otherwise simple case-sensitive "
"substring matching is used."
msgstr ""
"Los patrones que contengan un comodín (``*``) se comprueban contra el nombre "
"de la prueba usando :meth:`fnmatch.fnmatchcase`; si no lo contienen, se usa "
"una comprobación de contenido simple sensible a mayúsculas."

#: ../Doc/library/unittest.rst:237
msgid ""
"Patterns are matched against the fully qualified test method name as "
"imported by the test loader."
msgstr ""
"Los patrones se comprueban contra el nombre del método completamente "
"cualificado como lo importa el cargador de pruebas."

#: ../Doc/library/unittest.rst:240
msgid ""
"For example, ``-k foo`` matches ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``, but not ``bar_tests.FooTest."
"test_something``."
msgstr ""
"Por ejemplo, ``-k foo`` coincide con ``foo_tests.SomeTest.test_something`` y "
"con ``bar_tests.SomeTest.test_foo``, pero no con ``bar_tests.FooTest."
"test_something``."

#: ../Doc/library/unittest.rst:245
msgid "Show local variables in tracebacks."
msgstr "Mostrar las variables locales en las trazas."

#: ../Doc/library/unittest.rst:247
msgid "The command-line options ``-b``, ``-c`` and ``-f`` were added."
msgstr "Se añadieron las opciones de línea de órdenes ``-b``, ``-c`` y ``-f``."

#: ../Doc/library/unittest.rst:250
msgid "The command-line option ``--locals``."
msgstr "La opción de línea de órdenes ``--locals``."

#: ../Doc/library/unittest.rst:253
msgid "The command-line option ``-k``."
msgstr "La opción de línea de órdenes ``-k``."

#: ../Doc/library/unittest.rst:256
msgid ""
"The command line can also be used for test discovery, for running all of the "
"tests in a project or just a subset."
msgstr ""
"La línea de órdenes también se puede usar para descubrimiento de pruebas, "
"para ejecutar todas las pruebas de un proyecto o un subconjunto de éstas."

#: ../Doc/library/unittest.rst:263
msgid "Test Discovery"
msgstr "Descubrimiento de pruebas"

#: ../Doc/library/unittest.rst:267
msgid ""
"Unittest supports simple test discovery. In order to be compatible with test "
"discovery, all of the test files must be :ref:`modules <tut-modules>` or :"
"ref:`packages <tut-packages>` importable from the top-level directory of the "
"project (this means that their filenames must be valid :ref:`identifiers "
"<identifiers>`)."
msgstr ""
"Unittest da soporte al descubrimiento de pruebas simples. Para ser "
"compatible con el descubrimiento de pruebas, todos los ficheros de prueba "
"deben ser :ref:`módulos <tut-modules>` o :ref:`paquetes <tut-packages>` "
"importables desde el directorio superior del proyecto (por lo que sus "
"nombres han de ser :ref:`identificadores <identifiers>` válidos)."

#: ../Doc/library/unittest.rst:273
msgid ""
"Test discovery is implemented in :meth:`TestLoader.discover`, but can also "
"be used from the command line. The basic command-line usage is::"
msgstr ""
"El descubrimiento de pruebas está implementado en :meth:`TestLoader."
"discover`, pero también se puede usar desde la línea de órdenes. La línea de "
"órdenes básica es::"

#: ../Doc/library/unittest.rst:281
msgid ""
"As a shortcut, ``python -m unittest`` is the equivalent of ``python -m "
"unittest discover``. If you want to pass arguments to test discovery the "
"``discover`` sub-command must be used explicitly."
msgstr ""
"Como atajo, ``python -m unittest`` es el equivalente de ``python -m unittest "
"discover``. Si se desea pasar argumentos al descubrimiento de pruebas, hay "
"que pasar la sub-orden ``discover`` explícitamente."

#: ../Doc/library/unittest.rst:285
msgid "The ``discover`` sub-command has the following options:"
msgstr "La sub-orden ``discover`` cuenta con las siguientes opciones:"

#: ../Doc/library/unittest.rst:291
msgid "Verbose output"
msgstr "Salida verbosa"

#: ../Doc/library/unittest.rst:295
msgid "Directory to start discovery (``.`` default)"
msgstr "Directorio de inicio para el descubrimiento (``.`` si se omite)"

#: ../Doc/library/unittest.rst:299
msgid "Pattern to match test files (``test*.py`` default)"
msgstr ""
"Patrón para la búsqueda de ficheros de prueba (``test*.py`` si se omite)"

#: ../Doc/library/unittest.rst:303
msgid "Top level directory of project (defaults to start directory)"
msgstr "Directorio superior del proyecto (el directorio inicial si se omite)"

#: ../Doc/library/unittest.rst:305
msgid ""
"The :option:`-s`, :option:`-p`, and :option:`-t` options can be passed in as "
"positional arguments in that order. The following two command lines are "
"equivalent::"
msgstr ""
"Las opciones :option:`-s`, :option:`-p`, y :option:`-t` se pueden pasar por "
"posición en el orden mostrado. Las siguientes líneas de órdenes son "
"equivalentes::"

#: ../Doc/library/unittest.rst:312
msgid ""
"As well as being a path it is possible to pass a package name, for example "
"``myproject.subpackage.test``, as the start directory. The package name you "
"supply will then be imported and its location on the filesystem will be used "
"as the start directory."
msgstr ""
"Además de pasar una ruta, es posible pasar el nombre de un paquete, por "
"ejemplo ``myproject.subpackage.test``, como directorio de inicio. El nombre "
"de paquete proporcionado será importado y su ubicación en el sistema de "
"archivos será utilizada como directorio de inicio."

#: ../Doc/library/unittest.rst:319
msgid ""
"Test discovery loads tests by importing them. Once test discovery has found "
"all the test files from the start directory you specify it turns the paths "
"into package names to import. For example :file:`foo/bar/baz.py` will be "
"imported as ``foo.bar.baz``."
msgstr ""
"El descubrimiento de pruebas carga las pruebas importándolas. Una vez que el "
"descubrimiento ha encontrado todos los ficheros de prueba a partir del "
"directorio inicial, especificado, convierte las rutas en nombres de paquetes "
"a importar. Por ejemplo, :file:`foo/bar/baz.py` será importado como ``foo."
"bar.baz``."

#: ../Doc/library/unittest.rst:324
msgid ""
"If you have a package installed globally and attempt test discovery on a "
"different copy of the package then the import *could* happen from the wrong "
"place. If this happens test discovery will warn you and exit."
msgstr ""
"Si hay un paquete instalado globalmente y se intenta hacer un descubrimiento "
"sobre una copia diferente a la instalada del paquete, *podría* ocurrir que "
"se importe la versión incorrecta. Si ocurre esto, el descubrimiento lanza "
"una advertencia y abandona."

#: ../Doc/library/unittest.rst:328
msgid ""
"If you supply the start directory as a package name rather than a path to a "
"directory then discover assumes that whichever location it imports from is "
"the location you intended, so you will not get the warning."
msgstr ""
"Si se proporciona el directorio de inicio como nombre de paquete en lugar de "
"ruta a un directorio, el descubrimiento asume que la ubicación importada es "
"la deseada, así que no se da la advertencia descrita."

#: ../Doc/library/unittest.rst:333
msgid ""
"Test modules and packages can customize test loading and discovery by "
"through the `load_tests protocol`_."
msgstr ""
"Los módulos y paquetes de prueba pueden personalizar la carta y "
"descubrimiento de pruebas mediante el `protocolo load_tests`_."

#: ../Doc/library/unittest.rst:336
msgid ""
"Test discovery supports :term:`namespace packages <namespace package>` for "
"the start directory. Note that you need to specify the top level directory "
"too (e.g. ``python -m unittest discover -s root/namespace -t root``)."
msgstr ""
"El descubrimiento de pruebas admite :term:`paquetes nominales <namespace "
"package>` para el directorio de inicio. Tenga en cuenta que también se "
"necesita el directorio de nivel superior. (por ejemplo, ``python -m unittest "
"discover -s root/namespace -t root``)."

#: ../Doc/library/unittest.rst:342
msgid ""
"Python 3.11 dropped the :term:`namespace packages <namespace package>` "
"support. It has been broken since Python 3.7. Start directory and "
"subdirectories containing tests must be regular package that have ``__init__."
"py`` file."
msgstr ""
"Python 3.11 eliminó el soporte de los :term:`paquetes namespace <namespace "
"package>`. Ha estado roto desde Python 3.7. El directorio de inicio y los "
"subdirectorios que contengan pruebas deben ser paquetes regulares que tengan "
"el archivo ``__init__.py``."

#: ../Doc/library/unittest.rst:348
msgid ""
"Directories containing start directory still can be a namespace package. In "
"this case, you need to specify start directory as dotted package name, and "
"target directory explicitly. For example::"
msgstr ""
"Los directorios que contienen el directorio de inicio aún pueden ser un "
"paquete de espacio de nombres. En este caso, es necesario especificar el "
"directorio de inicio como nombre de paquete con puntos, y el directorio de "
"destino explícitamente. Por ejemplo::"

#: ../Doc/library/unittest.rst:364
msgid "Organizing test code"
msgstr "Organización del código de pruebas"

#: ../Doc/library/unittest.rst:366
msgid ""
"The basic building blocks of unit testing are :dfn:`test cases` --- single "
"scenarios that must be set up and checked for correctness.  In :mod:"
"`unittest`, test cases are represented by :class:`unittest.TestCase` "
"instances. To make your own test cases you must write subclasses of :class:"
"`TestCase` or use :class:`FunctionTestCase`."
msgstr ""
"Los bloques de construcción básicos de las pruebas unitarias son los :dfn:"
"`test cases`, escenarios simples que se han de configurar y cuya corrección "
"hay que comprobar. En :mod:`unittest`, los casos de prueba están "
"representados por instancias de :class:`unittest.TestCase`. Para crear "
"nuevos casos de prueba, hay que escribir subclases de :class:`TestCase` o "
"usar :class:`FunctionTestCase`."

#: ../Doc/library/unittest.rst:372
msgid ""
"The testing code of a :class:`TestCase` instance should be entirely self "
"contained, such that it can be run either in isolation or in arbitrary "
"combination with any number of other test cases."
msgstr ""
"El código de pruebas de una instancia de :class:`TestCase` debería ser "
"completamente autónomo, de tal modo que se pueda ejecutar aisladamente o en "
"una combinación arbitraria con otras clases de prueba."

#: ../Doc/library/unittest.rst:376
msgid ""
"The simplest :class:`TestCase` subclass will simply implement a test method "
"(i.e. a method whose name starts with ``test``) in order to perform specific "
"testing code::"
msgstr ""
"La subclase más simple de :class:`TestCase` se limita a implementar un "
"método test (o un método que empiece por ``test``) para realizar código de "
"prueba específico::"

#: ../Doc/library/unittest.rst:387
msgid ""
"Note that in order to test something, we use one of the :meth:`assert\\*` "
"methods provided by the :class:`TestCase` base class.  If the test fails, an "
"exception will be raised with an explanatory message, and :mod:`unittest` "
"will identify the test case as a :dfn:`failure`.  Any other exceptions will "
"be treated as :dfn:`errors`."
msgstr ""
"Adviértase que para probar algo, usamos uno de los métodos :meth:`assert\\*` "
"proporcionados por la clase base :class:`TestCase`. Si la prueba no tiene "
"éxito, se lanzará una excepción con un mensaje explicativo y :mod:`unittest` "
"identificará el caso como :dfn:`failure`. Cualquier otra excepción se "
"considerará un :dfn:`errors`."

#: ../Doc/library/unittest.rst:393
msgid ""
"Tests can be numerous, and their set-up can be repetitive.  Luckily, we can "
"factor out set-up code by implementing a method called :meth:`~TestCase."
"setUp`, which the testing framework will automatically call for every single "
"test we run::"
msgstr ""
"Las pruebas pueden ser muchas y su preparación puede ser repetitiva. Por "
"suerte, se puede \"sacar factor común\" a la preparación implementando un "
"método :meth:`~TestCase.setUp`, al que la infraestructura de prueba llamará "
"para cada prueba que se ejecute::"

#: ../Doc/library/unittest.rst:414
msgid ""
"The order in which the various tests will be run is determined by sorting "
"the test method names with respect to the built-in ordering for strings."
msgstr ""
"El orden en que se ejecutan las diversas pruebas se determina por orden "
"alfabético de los nombres de métodos de prueba."

#: ../Doc/library/unittest.rst:418
msgid ""
"If the :meth:`~TestCase.setUp` method raises an exception while the test is "
"running, the framework will consider the test to have suffered an error, and "
"the test method will not be executed."
msgstr ""
"Si el método :meth:`~TestCase.setUp` lanza una excepción mientras se ejecuta "
"la prueba, la infraestructura considerará que la prueba ha sufrido un error "
"y no se ejecutará el método de prueba propiamente dicho."

#: ../Doc/library/unittest.rst:422
msgid ""
"Similarly, we can provide a :meth:`~TestCase.tearDown` method that tidies up "
"after the test method has been run::"
msgstr ""
"Análogamente, se puede proporcionar un método :meth:`~TestCase.tearDown` que "
"haga limpieza después de que se ejecute el método de prueba::"

#: ../Doc/library/unittest.rst:434
msgid ""
"If :meth:`~TestCase.setUp` succeeded, :meth:`~TestCase.tearDown` will be run "
"whether the test method succeeded or not."
msgstr ""
"Si :meth:`~TestCase.setUp` se ejecuta sin errores, :meth:`~TestCase."
"tearDown` se ejecutará tanto si el método de prueba tuvo éxito como si no."

#: ../Doc/library/unittest.rst:437
msgid ""
"Such a working environment for the testing code is called a :dfn:`test "
"fixture`.  A new TestCase instance is created as a unique test fixture used "
"to execute each individual test method.  Thus :meth:`~TestCase.setUp`, :meth:"
"`~TestCase.tearDown`, and :meth:`~TestCase.__init__` will be called once per "
"test."
msgstr ""
"Un entorno de trabajo así para el código de pruebas se llama :dfn:`test "
"fixture` . Se crea una nueva instancia de TestCase como juego de datos de "
"prueba que se utiliza para cada método de prueba. De este modo, :meth:"
"`~TestCase.setUp`, :meth:`~TestCase.tearDown` y :meth:`~TestCase.__init__` "
"se llamarán una vez por prueba."

#: ../Doc/library/unittest.rst:443
msgid ""
"It is recommended that you use TestCase implementations to group tests "
"together according to the features they test.  :mod:`unittest` provides a "
"mechanism for this: the :dfn:`test suite`, represented by :mod:`unittest`'s :"
"class:`TestSuite` class.  In most cases, calling :func:`unittest.main` will "
"do the right thing and collect all the module's test cases for you and "
"execute them."
msgstr ""
"Se recomienda usar implementaciones de `TestCase` para agrupar las pruebas "
"de acuerdo con las características probadas. :mod:`unittest` proporciona una "
"mecanismo para esto: el :dfn:`test suite`, representado por la clase :class:"
"`TestSuite` de :mod:`unittest`. En la mayor parte de los casos, llamar a :"
"func:`unittest.main` hará lo correcto y recolectará todos los casos de "
"prueba del módulo para su ejecución."

#: ../Doc/library/unittest.rst:450
msgid ""
"However, should you want to customize the building of your test suite, you "
"can do it yourself::"
msgstr ""
"Sin embargo, si se desea personalizar la construcción del paquete de "
"pruebas, se puede hacer::"

#: ../Doc/library/unittest.rst:463
msgid ""
"You can place the definitions of test cases and test suites in the same "
"modules as the code they are to test (such as :file:`widget.py`), but there "
"are several advantages to placing the test code in a separate module, such "
"as :file:`test_widget.py`:"
msgstr ""
"Se puede poner las definiciones de los casos de prueba y de los paquetes de "
"prueba en los mismos módulos que el código que prueban.(tal como :file:"
"`widget.py`), pero sacarlos a un módulo aparte como :file:`test_widget.py` "
"tiene diversas ventajas:"

#: ../Doc/library/unittest.rst:468
msgid "The test module can be run standalone from the command line."
msgstr ""
"El módulo de pruebas se puede ejecutar aisladamente desde la línea de "
"órdenes."

#: ../Doc/library/unittest.rst:470
msgid "The test code can more easily be separated from shipped code."
msgstr ""
"El código de pruebas se puede separar con más facilidad del código de "
"producción."

#: ../Doc/library/unittest.rst:472
msgid ""
"There is less temptation to change test code to fit the code it tests "
"without a good reason."
msgstr ""
"Disminuye la tentación de cambiar el código de prueba para ajustarse al "
"código bajo prueba."

#: ../Doc/library/unittest.rst:475
msgid ""
"Test code should be modified much less frequently than the code it tests."
msgstr ""
"El código de pruebas debería modificarse con mucha menor frecuencia que el "
"código bajo prueba."

#: ../Doc/library/unittest.rst:477
msgid "Tested code can be refactored more easily."
msgstr "Es más sencillo refactorizar el código bajo prueba."

#: ../Doc/library/unittest.rst:479
msgid ""
"Tests for modules written in C must be in separate modules anyway, so why "
"not be consistent?"
msgstr ""
"El código para probar módulos escritos en C ha de estar en módulos aparte, "
"así que ¿por qué no mantener la consistencia?"

#: ../Doc/library/unittest.rst:482
msgid ""
"If the testing strategy changes, there is no need to change the source code."
msgstr ""
"Si cambia la estrategia de prueba, no hay razón para cambiar el código "
"fuente principal."

#: ../Doc/library/unittest.rst:488
msgid "Re-using old test code"
msgstr "Reutilización de código de prueba anterior"

#: ../Doc/library/unittest.rst:490
msgid ""
"Some users will find that they have existing test code that they would like "
"to run from :mod:`unittest`, without converting every old test function to "
"a :class:`TestCase` subclass."
msgstr ""
"Habrá personas que tengan código de prueba previo que deseen ejecutar desde :"
"mod:`unittest`, sin conversión previa de cada antigua función de prueba a "
"una subclase de :class:`TestCase`."

#: ../Doc/library/unittest.rst:494
msgid ""
"For this reason, :mod:`unittest` provides a :class:`FunctionTestCase` class. "
"This subclass of :class:`TestCase` can be used to wrap an existing test "
"function.  Set-up and tear-down functions can also be provided."
msgstr ""
"Por esto, :mod:`unittest` proporciona una clase :class:`FunctionTestCase`. "
"Se puede utilizar esta subclase de :class:`TestCase` para envolver una "
"función de prueba existente. Se pueden proporcionar también funciones de "
"preparación y desmontaje."

#: ../Doc/library/unittest.rst:498
msgid "Given the following test function::"
msgstr "Dada la siguiente función de prueba::"

#: ../Doc/library/unittest.rst:505
msgid ""
"one can create an equivalent test case instance as follows, with optional "
"set-up and tear-down methods::"
msgstr ""
"se puede crear una instancia de caso de prueba de la siguiente manera, con "
"métodos opcionales de preparación y desmontaje::"

#: ../Doc/library/unittest.rst:514
msgid ""
"Even though :class:`FunctionTestCase` can be used to quickly convert an "
"existing test base over to a :mod:`unittest`\\ -based system, this approach "
"is not recommended.  Taking the time to set up proper :class:`TestCase` "
"subclasses will make future test refactorings infinitely easier."
msgstr ""
"Aunque se puede usar :class:`FunctionTestCase` para convertir rápidamente "
"unas pruebas existentes a un sistema basado en :mod:`unittest`, no es una "
"vía recomendada. Tomarse el tiempo de construir subclases bien construidas "
"de :class:`TestCase` hará las futuras refactorizaciones de pruebas futura "
"considerablemente más fácil."

#: ../Doc/library/unittest.rst:519
msgid ""
"In some cases, the existing tests may have been written using the :mod:"
"`doctest` module.  If so, :mod:`doctest` provides a :class:`DocTestSuite` "
"class that can automatically build :class:`unittest.TestSuite` instances "
"from the existing :mod:`doctest`\\ -based tests."
msgstr ""
"En algunos casos, los tests existentes pueden haber sido escritos usando el "
"módulo :mod:`doctest`. En ese caso, :mod:`doctest` tiene una clase :class:"
"`DocTestSuite` que puede construir automáticamente instancias de :class:"
"`unittest.TestSuite` partiendo de los test basados en :mod:`doctest`."

#: ../Doc/library/unittest.rst:528
msgid "Skipping tests and expected failures"
msgstr "Omitir tests y fallos esperados"

#: ../Doc/library/unittest.rst:532
msgid ""
"Unittest supports skipping individual test methods and even whole classes of "
"tests.  In addition, it supports marking a test as an \"expected failure,\" "
"a test that is broken and will fail, but shouldn't be counted as a failure "
"on a :class:`TestResult`."
msgstr ""
"Unittest soporta omitir métodos individuales de tests e incluso clases "
"completas de tests. Además, soporta marcar un test como un \"fallo "
"esperado\", un test que está roto y va a fallar, pero no debería ser contado "
"como fallo en :class:`TestResult`."

#: ../Doc/library/unittest.rst:537
msgid ""
"Skipping a test is simply a matter of using the :func:`skip` :term:"
"`decorator` or one of its conditional variants, calling :meth:`TestCase."
"skipTest` within a :meth:`~TestCase.setUp` or test method, or raising :exc:"
"`SkipTest` directly."
msgstr ""
"Omitir un test es solo cuestión de emplear el :term:`decorator` :func:`skip` "
"o una de sus variantes condicionales, llamando a :meth:`TestCase.skipTest` "
"dentro de :meth:`~TestCase.setUp` o en un método de test, o lanzando :exc:"
"`SkipTest` directamente."

#: ../Doc/library/unittest.rst:541
msgid "Basic skipping looks like this::"
msgstr "La omisión más básica tiene la siguiente forma:"

#: ../Doc/library/unittest.rst:566
msgid "This is the output of running the example above in verbose mode::"
msgstr "Esta es la salida de ejecutar el ejemplo superior en modo verboso::"

#: ../Doc/library/unittest.rst:578
msgid "Classes can be skipped just like methods::"
msgstr "Las clases pueden ser omitidas igual que los métodos::"

#: ../Doc/library/unittest.rst:585
msgid ""
":meth:`TestCase.setUp` can also skip the test.  This is useful when a "
"resource that needs to be set up is not available."
msgstr ""
":meth:`TestCase.setUp` puede omitir también el test. Esto es útil cuando un "
"recurso que necesita ser puesto a punto no está disponible."

#: ../Doc/library/unittest.rst:588
msgid "Expected failures use the :func:`expectedFailure` decorator. ::"
msgstr "Los fallos esperados emplean el decorador :func:`expectedFailure`. ::"

#: ../Doc/library/unittest.rst:595
msgid ""
"It's easy to roll your own skipping decorators by making a decorator that "
"calls :func:`skip` on the test when it wants it to be skipped.  This "
"decorator skips the test unless the passed object has a certain attribute::"
msgstr ""
"Es fácil lanzar tus propios decoradores que omitan haciendo un decorador que "
"llame a :func:`skip`  en el test cuando quiere ser omitido. Este decorador "
"omite el test a menos que el objeto pasado tenga un cierto atributo::"

#: ../Doc/library/unittest.rst:604
msgid ""
"The following decorators and exception implement test skipping and expected "
"failures:"
msgstr ""
"Los siguientes decoradores y la excepción implementan la omisión de tests y "
"los fallos esperados:"

#: ../Doc/library/unittest.rst:608
msgid ""
"Unconditionally skip the decorated test.  *reason* should describe why the "
"test is being skipped."
msgstr ""
"Omitir incondicionalmente el test decorado. *reason* debe describir porqué "
"el test está siendo omitido."

#: ../Doc/library/unittest.rst:613
msgid "Skip the decorated test if *condition* is true."
msgstr "Omitir el test decorado si *condition* es verdadero."

#: ../Doc/library/unittest.rst:617
msgid "Skip the decorated test unless *condition* is true."
msgstr "Omitir el test decorado a menos que *condition* sea verdadero."

#: ../Doc/library/unittest.rst:621
msgid ""
"Mark the test as an expected failure or error.  If the test fails or errors "
"in the test function itself (rather than in one of the :dfn:`test fixture` "
"methods) then it will be considered a success.  If the test passes, it will "
"be considered a failure."
msgstr ""
"Marca el test como un fallo esperado.  Si falla el test o hay errores en la "
"función de test misma (en lugar de en alguno de los métodos :dfn:`test "
"fixture`) será considerado un éxito. Si el test pasa, será considerado un "
"fallo."

#: ../Doc/library/unittest.rst:628
msgid "This exception is raised to skip a test."
msgstr "Esta excepción es lanzada para omitir un test."

#: ../Doc/library/unittest.rst:630
msgid ""
"Usually you can use :meth:`TestCase.skipTest` or one of the skipping "
"decorators instead of raising this directly."
msgstr ""
"Normalmente puedes usar directamente :meth:`TestCase.skipTest` o uno de los "
"decoradores de omisión en vez de lanzar esta excepción."

#: ../Doc/library/unittest.rst:633
msgid ""
"Skipped tests will not have :meth:`~TestCase.setUp` or :meth:`~TestCase."
"tearDown` run around them. Skipped classes will not have :meth:`~TestCase."
"setUpClass` or :meth:`~TestCase.tearDownClass` run. Skipped modules will not "
"have :func:`setUpModule` or :func:`tearDownModule` run."
msgstr ""
"Los tests omitidos no ejecutarán :meth:`~TestCase.setUp` o :meth:`~TestCase."
"tearDown`. Las clases omitidas no ejecutarán :meth:`~TestCase.setUpClass` o :"
"meth:`~TestCase.tearDownClass`. Los módulos omitidos no ejecutarán :func:"
"`setUpModule` o :func:`tearDownModule`."

#: ../Doc/library/unittest.rst:641
msgid "Distinguishing test iterations using subtests"
msgstr "Distinguiendo iteraciones de tests empleando subtests"

#: ../Doc/library/unittest.rst:645
msgid ""
"When there are very small differences among your tests, for instance some "
"parameters, unittest allows you to distinguish them inside the body of a "
"test method using the :meth:`~TestCase.subTest` context manager."
msgstr ""
"Cuando hay diferencias muy pequeñas entre tus tests, por ejemplo algunos "
"parámetros, unittest te permite distinguirlos dentro del cuerpo de un método "
"de test empleando el administrador de contexto :meth:`~TestCase.subTest` ."

#: ../Doc/library/unittest.rst:649
msgid "For example, the following test::"
msgstr "Por ejemplo, el siguiente test::"

#: ../Doc/library/unittest.rst:661
msgid "will produce the following output::"
msgstr "producirá la siguiente salida:"

#: ../Doc/library/unittest.rst:693
msgid ""
"Without using a subtest, execution would stop after the first failure, and "
"the error would be less easy to diagnose because the value of ``i`` wouldn't "
"be displayed::"
msgstr ""
"Sin usar un subtest, la ejecución se pararía después del primer fallo, y el "
"error sería más difícil de diagnosticar porque el valor de  ``i`` no se "
"mostraría::"

#: ../Doc/library/unittest.rst:709
msgid "Classes and functions"
msgstr "Clases y funciones"

#: ../Doc/library/unittest.rst:711
msgid "This section describes in depth the API of :mod:`unittest`."
msgstr "Esta sección describe en detalle la API de :mod:`unittest`."

#: ../Doc/library/unittest.rst:717
msgid "Test cases"
msgstr "Casos de test"

#: ../Doc/library/unittest.rst:721
msgid ""
"Instances of the :class:`TestCase` class represent the logical test units in "
"the :mod:`unittest` universe.  This class is intended to be used as a base "
"class, with specific tests being implemented by concrete subclasses.  This "
"class implements the interface needed by the test runner to allow it to "
"drive the tests, and methods that the test code can use to check for and "
"report various kinds of failure."
msgstr ""
"Las instancias de la clase  :class:`TestCase` representan las unidades "
"lógicas de test en el universo de :mod:`unittest`. Esta clase está pensada "
"para ser utilizada como clase base, con los test específicos siendo "
"implementados por subclases concretas. Esta clase implementa la interfaz que "
"necesita el ejecutor de tests para permitirle llevar a cabo los tests, y "
"métodos que el código de test puede utilizar para chequear y reportar "
"distintos tipos de fallo."

#: ../Doc/library/unittest.rst:728
msgid ""
"Each instance of :class:`TestCase` will run a single base method: the method "
"named *methodName*. In most uses of :class:`TestCase`, you will neither "
"change the *methodName* nor reimplement the default ``runTest()`` method."
msgstr ""
"Cada instancia de :class:`TestCase`  ejecutará un solo método base: el "
"método llamado *methodName*. En la mayoría de usos de :class:`TestCase`, no "
"tendrás que cambiar el *methodName*  ni reimplementar el método por defecto  "
"``runTest()``."

#: ../Doc/library/unittest.rst:733
msgid ""
":class:`TestCase` can be instantiated successfully without providing a "
"*methodName*. This makes it easier to experiment with :class:`TestCase` from "
"the interactive interpreter."
msgstr ""
":class:`TestCase` puede instancias con éxito sin dar un *methodName*.  Esto "
"permite experimentar de manera sencilla con :class:`TestCase`  en el "
"intérprete interactivo."

#: ../Doc/library/unittest.rst:738
msgid ""
":class:`TestCase` instances provide three groups of methods: one group used "
"to run the test, another used by the test implementation to check conditions "
"and report failures, and some inquiry methods allowing information about the "
"test itself to be gathered."
msgstr ""
"Las instancias de :class:`TestCase`  proveen tres grupos de métodos: un "
"grupo empleado para ejecutar el test, otro usado para que la implementación "
"del test chequee condiciones y reporte fallos, y algunos métodos de "
"indagación que permiten recopilar información sobre el test en si mismo."

#: ../Doc/library/unittest.rst:743
msgid "Methods in the first group (running the test) are:"
msgstr "Los métodos en el primer grupo (ejecutando el test) son:"

#: ../Doc/library/unittest.rst:747
msgid ""
"Method called to prepare the test fixture.  This is called immediately "
"before calling the test method; other than :exc:`AssertionError` or :exc:"
"`SkipTest`, any exception raised by this method will be considered an error "
"rather than a test failure. The default implementation does nothing."
msgstr ""
"Método llamado para preparar el banco de test. Es invocado inmediatamente "
"antes de llamar al método de test; cualquier excepción lanzada por este "
"método que no sea :exc:`AssertionError` o :exc:`SkipTest` será considerada "
"un error en vez de un fallo del test. La implementación por defecto no hace "
"nada."

#: ../Doc/library/unittest.rst:755
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called even if the test method raised an "
"exception, so the implementation in subclasses may need to be particularly "
"careful about checking internal state.  Any exception, other than :exc:"
"`AssertionError` or :exc:`SkipTest`, raised by this method will be "
"considered an additional error rather than a test failure (thus increasing "
"the total number of reported errors). This method will only be called if "
"the :meth:`setUp` succeeds, regardless of the outcome of the test method. "
"The default implementation does nothing."
msgstr ""
"Método llamado inmediatamente después de que se haya llamado el método de "
"prueba y se haya registrado el resultado.  Se llama así aunque el método de "
"ensayo haya planteado una excepción, por lo que la aplicación en las "
"subclases puede tener que ser especialmente cuidadosa en cuanto a la "
"comprobación del estado interno.  Cualquier excepción, que no sea  :exc:"
"`AssertionError` o  :exc:`SkipTest`, planteada por este método se "
"considerará un error adicional en lugar de un fallo de la prueba (aumentando "
"así el número total de errores reportados). Este método sólo se llamará si :"
"meth:`setUp` tiene éxito, independientemente del resultado del método de "
"prueba. La implementación por defecto no hace nada."

#: ../Doc/library/unittest.rst:768
msgid ""
"A class method called before tests in an individual class are run. "
"``setUpClass`` is called with the class as the only argument and must be "
"decorated as a :func:`classmethod`::"
msgstr ""
"Un método de clase llamado antes de que los tests en una clase individual "
"sean ejecutados. ``setUpClass`` es llamado con la clase como el único "
"argumento y debe ser decorada como :func:`classmethod`::"

#: ../Doc/library/unittest.rst:776 ../Doc/library/unittest.rst:791
msgid "See `Class and Module Fixtures`_ for more details."
msgstr "Vea  `Class and Module Fixtures`_ para más detalles."

#: ../Doc/library/unittest.rst:783
msgid ""
"A class method called after tests in an individual class have run. "
"``tearDownClass`` is called with the class as the only argument and must be "
"decorated as a :meth:`classmethod`::"
msgstr ""
"Un método de clase llamado después de que se hayan realizado tests en una "
"clase individual. ``tearDownClass`` se llama con la clase como único "
"argumento y debe ser decorado como un :meth:`classmethod`::"

#: ../Doc/library/unittest.rst:798
msgid ""
"Run the test, collecting the result into the :class:`TestResult` object "
"passed as *result*.  If *result* is omitted or ``None``, a temporary result "
"object is created (by calling the :meth:`defaultTestResult` method) and "
"used. The result object is returned to :meth:`run`'s caller."
msgstr ""
"Ejecutar la prueba, recogiendo el resultado en el objeto  :class:"
"`TestResult`  pasado como *result*.  Si se omite *result* o ``None``, se "
"crea un objeto resultado temporal (llamando al método :meth:"
"`defaultTestResult`) y se emplea ese. El objeto resultante se devuelve al "
"invocador de :meth:`run`."

#: ../Doc/library/unittest.rst:804
msgid ""
"The same effect may be had by simply calling the :class:`TestCase` instance."
msgstr ""
"El mismo efecto puede conseguirse simplemente llamando a la instancia :class:"
"`TestCase`."

#: ../Doc/library/unittest.rst:807
msgid ""
"Previous versions of ``run`` did not return the result. Neither did calling "
"an instance."
msgstr ""
"Las versiones previas de ``run`` no retornaban el resultado. Tampoco lo "
"hacía la llamada a una instancia."

#: ../Doc/library/unittest.rst:813
msgid ""
"Calling this during a test method or :meth:`setUp` skips the current test.  "
"See :ref:`unittest-skipping` for more information."
msgstr ""
"Llamar a esto durante un método de prueba o :meth:`setUp` se salta el test "
"actual.  Ver  :ref:`unittest-skipping` para más información."

#: ../Doc/library/unittest.rst:821
msgid ""
"Return a context manager which executes the enclosed code block as a "
"subtest.  *msg* and *params* are optional, arbitrary values which are "
"displayed whenever a subtest fails, allowing you to identify them clearly."
msgstr ""
"Retorna un gestor de contexto que ejecuta el bloque de código adjunto como "
"un subtest.  *msg* y *params* son valores opcionales y arbitrarios que se "
"muestran cuando falla un subtest, permitiéndole identificarlos claramente."

#: ../Doc/library/unittest.rst:826
msgid ""
"A test case can contain any number of subtest declarations, and they can be "
"arbitrarily nested."
msgstr ""
"Un caso de test puede contener cualquier número de declaraciones de subtest, "
"y pueden anidarse arbitrariamente."

#: ../Doc/library/unittest.rst:829
msgid "See :ref:`subtests` for more information."
msgstr "Ver :ref:`subtests` para más información."

#: ../Doc/library/unittest.rst:836
msgid ""
"Run the test without collecting the result.  This allows exceptions raised "
"by the test to be propagated to the caller, and can be used to support "
"running tests under a debugger."
msgstr ""
"Realice el test sin recoger el resultado.  Esto permite que las excepciones "
"planteadas por el test se propaguen al invocado, y puede utilizarse para "
"apoyar la ejecución de tests bajo un depurador."

#: ../Doc/library/unittest.rst:842
msgid ""
"The :class:`TestCase` class provides several assert methods to check for and "
"report failures.  The following table lists the most commonly used methods "
"(see the tables below for more assert methods):"
msgstr ""
"La clase :class:`TestCase` proporciona varios métodos de afirmación para "
"comprobar y reportar fallos.  En la siguiente tabla se enumeran los métodos "
"más utilizados (consulte las tablas siguientes para ver más métodos de "
"afirmación):"

#: ../Doc/library/unittest.rst:847 ../Doc/library/unittest.rst:968
#: ../Doc/library/unittest.rst:1182 ../Doc/library/unittest.rst:1309
msgid "Method"
msgstr "Método"

#: ../Doc/library/unittest.rst:847 ../Doc/library/unittest.rst:968
#: ../Doc/library/unittest.rst:1182
msgid "Checks that"
msgstr "Comprueba que"

#: ../Doc/library/unittest.rst:847 ../Doc/library/unittest.rst:968
#: ../Doc/library/unittest.rst:1182 ../Doc/library/unittest.rst:1309
msgid "New in"
msgstr "Nuevo en"

#: ../Doc/library/unittest.rst:849
msgid ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"
msgstr ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"

#: ../Doc/library/unittest.rst:849
msgid "``a == b``"
msgstr "``a == b``"

#: ../Doc/library/unittest.rst:852
msgid ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"
msgstr ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"

#: ../Doc/library/unittest.rst:852
msgid "``a != b``"
msgstr "``a != b``"

#: ../Doc/library/unittest.rst:855
msgid ":meth:`assertTrue(x) <TestCase.assertTrue>`"
msgstr ":meth:`assertTrue(x) <TestCase.assertTrue>`"

#: ../Doc/library/unittest.rst:855
msgid "``bool(x) is True``"
msgstr "``bool(x) is True``"

#: ../Doc/library/unittest.rst:858
msgid ":meth:`assertFalse(x) <TestCase.assertFalse>`"
msgstr ":meth:`assertFalse(x) <TestCase.assertFalse>`"

#: ../Doc/library/unittest.rst:858
msgid "``bool(x) is False``"
msgstr "``bool(x) is False``"

#: ../Doc/library/unittest.rst:861
msgid ":meth:`assertIs(a, b) <TestCase.assertIs>`"
msgstr ":meth:`assertIs(a, b) <TestCase.assertIs>`"

#: ../Doc/library/unittest.rst:861
msgid "``a is b``"
msgstr "``a is b``"

#: ../Doc/library/unittest.rst:861 ../Doc/library/unittest.rst:864
#: ../Doc/library/unittest.rst:867 ../Doc/library/unittest.rst:870
#: ../Doc/library/unittest.rst:873 ../Doc/library/unittest.rst:876
#: ../Doc/library/unittest.rst:973 ../Doc/library/unittest.rst:1190
#: ../Doc/library/unittest.rst:1193 ../Doc/library/unittest.rst:1196
#: ../Doc/library/unittest.rst:1199 ../Doc/library/unittest.rst:1202
#: ../Doc/library/unittest.rst:1311 ../Doc/library/unittest.rst:1314
#: ../Doc/library/unittest.rst:1317 ../Doc/library/unittest.rst:1320
#: ../Doc/library/unittest.rst:1323 ../Doc/library/unittest.rst:1326
msgid "3.1"
msgstr "3.1"

#: ../Doc/library/unittest.rst:864
msgid ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"
msgstr ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"

#: ../Doc/library/unittest.rst:864
msgid "``a is not b``"
msgstr "``a is not b``"

#: ../Doc/library/unittest.rst:867
msgid ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"
msgstr ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"

#: ../Doc/library/unittest.rst:867
msgid "``x is None``"
msgstr "``x is None``"

#: ../Doc/library/unittest.rst:870
msgid ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"
msgstr ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"

#: ../Doc/library/unittest.rst:870
msgid "``x is not None``"
msgstr "``x is not None``"

#: ../Doc/library/unittest.rst:873
msgid ":meth:`assertIn(a, b) <TestCase.assertIn>`"
msgstr ":meth:`assertIn(a, b) <TestCase.assertIn>`"

#: ../Doc/library/unittest.rst:873
msgid "``a in b``"
msgstr "``a in b``"

#: ../Doc/library/unittest.rst:876
msgid ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"
msgstr ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"

#: ../Doc/library/unittest.rst:876
msgid "``a not in b``"
msgstr "``a not in b``"

#: ../Doc/library/unittest.rst:879
msgid ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"
msgstr ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"

#: ../Doc/library/unittest.rst:879
msgid "``isinstance(a, b)``"
msgstr "``isinstance(a, b)``"

#: ../Doc/library/unittest.rst:879 ../Doc/library/unittest.rst:882
#: ../Doc/library/unittest.rst:976 ../Doc/library/unittest.rst:979
#: ../Doc/library/unittest.rst:1205 ../Doc/library/unittest.rst:1208
msgid "3.2"
msgstr "3.2"

#: ../Doc/library/unittest.rst:882
msgid ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"
msgstr ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"

#: ../Doc/library/unittest.rst:882
msgid "``not isinstance(a, b)``"
msgstr "``not isinstance(a, b)``"

#: ../Doc/library/unittest.rst:886
msgid ""
"All the assert methods accept a *msg* argument that, if specified, is used "
"as the error message on failure (see also :data:`longMessage`). Note that "
"the *msg* keyword argument can be passed to :meth:`assertRaises`, :meth:"
"`assertRaisesRegex`, :meth:`assertWarns`, :meth:`assertWarnsRegex` only when "
"they are used as a context manager."
msgstr ""
"Todos los métodos de aserción aceptan un argumento *msg* que, si se "
"especifica, se utiliza como mensaje de error en caso de fallo (véase "
"también :data:`longMessage`). Tenga en cuenta que el argumento de la palabra "
"clave *msg* puede pasarse a :meth:`assertRaises`, :meth:"
"`assertRaisesRegex`, :meth:`assertWarns`, :meth:`assertWarnsRegex` sólo "
"cuando se utilizan como gestor de contexto."

#: ../Doc/library/unittest.rst:894
msgid ""
"Test that *first* and *second* are equal.  If the values do not compare "
"equal, the test will fail."
msgstr ""
"Testea que *first* y *second* son iguales. Si los valores no comparan como "
"iguales, el test fallará."

#: ../Doc/library/unittest.rst:897
msgid ""
"In addition, if *first* and *second* are the exact same type and one of "
"list, tuple, dict, set, frozenset or str or any type that a subclass "
"registers with :meth:`addTypeEqualityFunc` the type-specific equality "
"function will be called in order to generate a more useful default error "
"message (see also the :ref:`list of type-specific methods <type-specific-"
"methods>`)."
msgstr ""
"Además, si *first* y *second* son exactamente del mismo tipo y uno de lista, "
"tuple, dict, set, frozenset o str o cualquier tipo que una subclase registre "
"con :meth:`addTypeEqualityFunc` se llamará a la función de igualdad "
"específica del tipo para generar un mensaje de error por defecto más útil "
"(véase también la :ref:`lista de métodos específicos del tipo <type-specific-"
"methods>`)."

#: ../Doc/library/unittest.rst:904
msgid "Added the automatic calling of type-specific equality function."
msgstr ""
"Añadida la llamada automática de la función de igualdad de tipo específico."

#: ../Doc/library/unittest.rst:907
msgid ""
":meth:`assertMultiLineEqual` added as the default type equality function for "
"comparing strings."
msgstr ""
":meth:`assertMultiLineEqual` añadido como la función por defecto para "
"igualdad de tipos cuando se comparan cadenas."

#: ../Doc/library/unittest.rst:914
msgid ""
"Test that *first* and *second* are not equal.  If the values do compare "
"equal, the test will fail."
msgstr ""
"Testea que *first* y *second* no son iguales.  Si los valores son iguales, "
"el test fallará."

#: ../Doc/library/unittest.rst:920
msgid "Test that *expr* is true (or false)."
msgstr "Testea que *expr* es verdadero (o falso)."

#: ../Doc/library/unittest.rst:922
msgid ""
"Note that this is equivalent to ``bool(expr) is True`` and not to ``expr is "
"True`` (use ``assertIs(expr, True)`` for the latter).  This method should "
"also be avoided when more specific methods are available (e.g. "
"``assertEqual(a, b)`` instead of ``assertTrue(a == b)``), because they "
"provide a better error message in case of failure."
msgstr ""
"Note que esto es equivalente a ``bool(expr) is True`` y no a ``expr is "
"True`` (use ``assertIs(expr, True)`` para lo último).  Este método también "
"debe evitarse cuando se disponga de métodos más específicos (por ejemplo, "
"``assertEqual(a, b)`` en lugar de ``assertTrue(a == b)``), porque "
"proporcionan un mejor mensaje de error en caso de fallo."

#: ../Doc/library/unittest.rst:932
msgid "Test that *first* and *second* are (or are not) the same object."
msgstr "Testea si *first* y *second* son (o no) el mismo objeto."

#: ../Doc/library/unittest.rst:940
msgid "Test that *expr* is (or is not) ``None``."
msgstr "Testea que *expr*  es (o no es) ``None``."

#: ../Doc/library/unittest.rst:948
msgid "Test that *member* is (or is not) in *container*."
msgstr "Testea que *member* está (o no está) en *container*."

#: ../Doc/library/unittest.rst:956
msgid ""
"Test that *obj* is (or is not) an instance of *cls* (which can be a class or "
"a tuple of classes, as supported by :func:`isinstance`). To check for the "
"exact type, use :func:`assertIs(type(obj), cls) <assertIs>`."
msgstr ""
"Testea que *obj* es (o no es) una instancia de *cls* (que puede ser una "
"clase o una tupla de clases, de la misma forma que soporta :func:"
"`isinstance`). Para chequear por el tipo exacto, use :func:"
"`assertIs(type(obj), cls) <assertIs>`."

#: ../Doc/library/unittest.rst:964
msgid ""
"It is also possible to check the production of exceptions, warnings, and log "
"messages using the following methods:"
msgstr ""
"Es también posible chequear la producción de excepciones, advertencias y "
"mensajes de log usando los siguientes métodos:"

#: ../Doc/library/unittest.rst:970
msgid ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"
msgstr ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"

#: ../Doc/library/unittest.rst:970
msgid "``fun(*args, **kwds)`` raises *exc*"
msgstr "``fun(*args, **kwds)`` lanza *exc*"

#: ../Doc/library/unittest.rst:973
msgid ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"
msgstr ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"

#: ../Doc/library/unittest.rst:973
msgid "``fun(*args, **kwds)`` raises *exc* and the message matches regex *r*"
msgstr "``fun(*args, **kwds)`` lanza *exc* y el mensaje coincide con regex *r*"

#: ../Doc/library/unittest.rst:976
msgid ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"
msgstr ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"

#: ../Doc/library/unittest.rst:976
msgid "``fun(*args, **kwds)`` raises *warn*"
msgstr "``fun(*args, **kwds)`` lanza *warn*"

#: ../Doc/library/unittest.rst:979
msgid ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"
msgstr ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"

#: ../Doc/library/unittest.rst:979
msgid "``fun(*args, **kwds)`` raises *warn* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)`` lanza *warn* y el mensaje coincide con regex *r*"

#: ../Doc/library/unittest.rst:982
msgid ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"
msgstr ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"

#: ../Doc/library/unittest.rst:982
msgid "The ``with`` block logs on *logger* with minimum *level*"
msgstr "El bloque ``with`` vuelca sus logs a *logger* con el *level* mínimo"

#: ../Doc/library/unittest.rst:982
msgid "3.4"
msgstr "3.4"

#: ../Doc/library/unittest.rst:985
msgid ":meth:`assertNoLogs(logger, level) <TestCase.assertNoLogs>`"
msgstr ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"

#: ../Doc/library/unittest.rst:985
msgid "The ``with`` block does not log on"
msgstr "El bloque ``with`` no ingresa"

#: ../Doc/library/unittest.rst:986
msgid "*logger* with minimum *level*"
msgstr "El bloque ``with`` vuelca sus logs a *logger* con el *level* mínimo"

#: ../Doc/library/unittest.rst:985
msgid "3.10"
msgstr "3.10"

#: ../Doc/library/unittest.rst:992
msgid ""
"Test that an exception is raised when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertRaises`.  The test passes if *exception* is raised, is an error if "
"another exception is raised, or fails if no exception is raised. To catch "
"any of a group of exceptions, a tuple containing the exception classes may "
"be passed as *exception*."
msgstr ""
"Testea que se lanza una excepción cuando se llama a *callable* con cualquier "
"argumento posicional o de palabra clave que también se pasa a  :meth:"
"`assertRaises`. El test pasa si se lanza *exception*, es un error si se "
"lanza otra excepción, o falla si no se lanza ninguna excepción. Para tener "
"en cuenta cualquiera de un grupo de excepciones, una tupla que contenga las "
"clases de excepción puede ser pasada como *exception*."

#: ../Doc/library/unittest.rst:999
msgid ""
"If only the *exception* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"Si sólo se dan los argumentos de *exception* y posiblemente *msg*, retorna "
"un administrador de contexto para que el código testado pueda ser escrito en "
"línea en lugar de como una función::"

#: ../Doc/library/unittest.rst:1006
msgid ""
"When used as a context manager, :meth:`assertRaises` accepts the additional "
"keyword argument *msg*."
msgstr ""
"Cuando se emplea como un administrador de contexto, :meth:`assertRaises` "
"acepta el argumento por palabra clave adicional  *msg*."

#: ../Doc/library/unittest.rst:1009
msgid ""
"The context manager will store the caught exception object in its :attr:"
"`exception` attribute.  This can be useful if the intention is to perform "
"additional checks on the exception raised::"
msgstr ""
"El gestor de contexto almacenará el objeto de excepción capturado en su "
"atributo :attr:`exception` .  Esto puede ser útil si la intención es "
"realizar comprobaciones adicionales sobre la excepción planteada::"

#: ../Doc/library/unittest.rst:1019
msgid "Added the ability to use :meth:`assertRaises` as a context manager."
msgstr ""
"Añadió la capacidad de usar :meth:`assertRaises` como gestor de contexto."

#: ../Doc/library/unittest.rst:1022
msgid "Added the :attr:`exception` attribute."
msgstr "Añadido el atributo  :attr:`exception` ."

#: ../Doc/library/unittest.rst:1025 ../Doc/library/unittest.rst:1051
#: ../Doc/library/unittest.rst:1092 ../Doc/library/unittest.rst:1115
msgid "Added the *msg* keyword argument when used as a context manager."
msgstr ""
"Añadido el argumento por palabra clave *msg* cuando se emplea un gestor de "
"contexto."

#: ../Doc/library/unittest.rst:1032
msgid ""
"Like :meth:`assertRaises` but also tests that *regex* matches on the string "
"representation of the raised exception.  *regex* may be a regular expression "
"object or a string containing a regular expression suitable for use by :func:"
"`re.search`.  Examples::"
msgstr ""
"Como :meth:`assertRaises` pero también testea que *regex* coincide en la "
"representación de la cadena de la excepción planteada.  *regex* puede ser un "
"objeto de expresión regular o una cadena que contiene una expresión regular "
"adecuada para ser usada por :func:`re.search`.  Ejemplos::"

#: ../Doc/library/unittest.rst:1040 ../Doc/library/unittest.rst:1108
msgid "or::"
msgstr "o::"

#: ../Doc/library/unittest.rst:1045
msgid "Added under the name ``assertRaisesRegexp``."
msgstr "Añadido bajo el nombre de ``assertRaisesRegexp``."

#: ../Doc/library/unittest.rst:1048
msgid "Renamed to :meth:`assertRaisesRegex`."
msgstr "Renombrado a  :meth:`assertRaisesRegex`."

#: ../Doc/library/unittest.rst:1058
msgid ""
"Test that a warning is triggered when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertWarns`.  The test passes if *warning* is triggered and fails if it "
"isn't.  Any exception is an error. To catch any of a group of warnings, a "
"tuple containing the warning classes may be passed as *warnings*."
msgstr ""
"Testea que una advertencia se activa cuando se llama a *callable* con "
"cualquier argumento posicional o de palabra clave que también se pasa a :"
"meth:`assertWarns`. El test pasa si se activa el *warning* y falla si no lo "
"hace.  Cualquier excepción es un error. Para considerar cualquiera de un "
"grupo de advertencias, una tupla que contenga las clases de advertencia "
"puede ser pasada como *warnings*."

#: ../Doc/library/unittest.rst:1065
msgid ""
"If only the *warning* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"Si sólo se dan los argumentos de *advertencia* y  *msg*, retorna un gestor "
"de contexto para que el código testado pueda ser escrito en línea en lugar "
"de como una función::"

#: ../Doc/library/unittest.rst:1072
msgid ""
"When used as a context manager, :meth:`assertWarns` accepts the additional "
"keyword argument *msg*."
msgstr ""
"Cuando se usa como gestor de contexto, :meth:`assertWarns`  acepta el "
"argumento de palabra clave adicional *msg*."

#: ../Doc/library/unittest.rst:1075
msgid ""
"The context manager will store the caught warning object in its :attr:"
"`warning` attribute, and the source line which triggered the warnings in "
"the :attr:`filename` and :attr:`lineno` attributes. This can be useful if "
"the intention is to perform additional checks on the warning caught::"
msgstr ""
"El gestor de contexto almacenará el objeto de advertencia capturado en su "
"atributo :attr:`warning`, y la línea del código que disparó las advertencias "
"en los atributos  :attr:`filename`  y :attr:`lineno` . Esto puede ser útil "
"si la intención es realizar comprobaciones adicionales sobre la advertencia "
"capturada::"

#: ../Doc/library/unittest.rst:1087
msgid ""
"This method works regardless of the warning filters in place when it is "
"called."
msgstr ""
"Este método funciona independientemente de los filtros de aviso que estén en "
"su lugar cuando se llame."

#: ../Doc/library/unittest.rst:1099
msgid ""
"Like :meth:`assertWarns` but also tests that *regex* matches on the message "
"of the triggered warning.  *regex* may be a regular expression object or a "
"string containing a regular expression suitable for use by :func:`re."
"search`.  Example::"
msgstr ""
"Como :meth:`assertWarns` pero también testea que *regex* coincide en el "
"mensaje del aviso disparado.  *regex* puede ser un objeto de expresión "
"regular o una cadena que contiene una expresión regular adecuada para ser "
"usada por :func:`re.search`.  Ejemplo::"

#: ../Doc/library/unittest.rst:1120
msgid ""
"A context manager to test that at least one message is logged on the "
"*logger* or one of its children, with at least the given *level*."
msgstr ""
"Un gestor de contexto para comprobar que al menos un mensaje está registrado "
"en el *logger* o en uno de sus hijos, con al menos el *level* dado."

#: ../Doc/library/unittest.rst:1124
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages that were not blocked by a non-propagating "
"descendent logger."
msgstr ""
"Si se da, *logger* debería ser un objeto :class:`logging.Logger` o un :class:"
"`str` dando el nombre de un logger.  El valor por defecto es el root logger, "
"que captará todos los mensajes."

#: ../Doc/library/unittest.rst:1129 ../Doc/library/unittest.rst:1170
msgid ""
"If given, *level* should be either a numeric logging level or its string "
"equivalent (for example either ``\"ERROR\"`` or :attr:`logging.ERROR`).  The "
"default is :attr:`logging.INFO`."
msgstr ""
"Si se da, *level* debe ser un nivel de logging numérico o su equivalente en "
"cadena (por ejemplo, o bien ``”ERROR”`` o :attr:`logging.ERROR`).  El valor "
"por defecto es :attr:`logging.INFO`."

#: ../Doc/library/unittest.rst:1133
msgid ""
"The test passes if at least one message emitted inside the ``with`` block "
"matches the *logger* and *level* conditions, otherwise it fails."
msgstr ""
"El test pasa si al menos un mensaje emitido dentro del bloque ``with``  "
"coincide con las condiciones de *logger* y *level*, de lo contrario falla."

#: ../Doc/library/unittest.rst:1136
msgid ""
"The object returned by the context manager is a recording helper which keeps "
"tracks of the matching log messages.  It has two attributes:"
msgstr ""
"El objeto devuelto por el gestor de contexto es un ayudante de grabación que "
"lleva un registro de los mensajes de registro que coinciden.  Tiene dos "
"atributos:"

#: ../Doc/library/unittest.rst:1142
msgid ""
"A list of :class:`logging.LogRecord` objects of the matching log messages."
msgstr ""
"Una lista de objetos :class:`logging.LogRecord` de los mensajes de log "
"coincidentes."

#: ../Doc/library/unittest.rst:1147
msgid ""
"A list of :class:`str` objects with the formatted output of matching "
"messages."
msgstr ""
"Una lista de objetos :class:`str` con la salida forrajeada en los mensajes "
"coincidentes."

#: ../Doc/library/unittest.rst:1150
msgid "Example::"
msgstr "Ejemplo::"

#: ../Doc/library/unittest.rst:1162
msgid ""
"A context manager to test that no messages are logged on the *logger* or one "
"of its children, with at least the given *level*."
msgstr ""
"Un gestor de contexto para comprobar que al menos un mensaje está registrado "
"en el *logger* o en uno de sus hijos, con al menos el *level* dado."

#: ../Doc/library/unittest.rst:1166
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages."
msgstr ""
"Si se da, *logger* debería ser un objeto :class:`logging.Logger` o un :class:"
"`str` dándole el nombre de un logger.  El valor por defecto es el root "
"logger, que captará todos los mensajes."

#: ../Doc/library/unittest.rst:1174
msgid ""
"Unlike :meth:`assertLogs`, nothing will be returned by the context manager."
msgstr ""
"A diferencia de :meth:`assertLogs`, el gestor de contexto no devolverá nada."

#: ../Doc/library/unittest.rst:1179
msgid ""
"There are also other methods used to perform more specific checks, such as:"
msgstr ""
"Hay también otros métodos empleados para realizar comprobaciones más "
"específicas, tales como:"

#: ../Doc/library/unittest.rst:1184
msgid ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"
msgstr ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"

#: ../Doc/library/unittest.rst:1184
msgid "``round(a-b, 7) == 0``"
msgstr "``round(a-b, 7) == 0``"

#: ../Doc/library/unittest.rst:1187
msgid ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"
msgstr ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"

#: ../Doc/library/unittest.rst:1187
msgid "``round(a-b, 7) != 0``"
msgstr "``round(a-b, 7) != 0``"

#: ../Doc/library/unittest.rst:1190
msgid ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"
msgstr ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"

#: ../Doc/library/unittest.rst:1190
msgid "``a > b``"
msgstr "``a > b``"

#: ../Doc/library/unittest.rst:1193
msgid ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"
msgstr ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"

#: ../Doc/library/unittest.rst:1193
msgid "``a >= b``"
msgstr "``a >= b``"

#: ../Doc/library/unittest.rst:1196
msgid ":meth:`assertLess(a, b) <TestCase.assertLess>`"
msgstr ":meth:`assertLess(a, b) <TestCase.assertLess>`"

#: ../Doc/library/unittest.rst:1196
msgid "``a < b``"
msgstr "``a < b``"

#: ../Doc/library/unittest.rst:1199
msgid ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"
msgstr ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"

#: ../Doc/library/unittest.rst:1199
msgid "``a <= b``"
msgstr "``a <= b``"

#: ../Doc/library/unittest.rst:1202
msgid ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"
msgstr ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"

#: ../Doc/library/unittest.rst:1202
msgid "``r.search(s)``"
msgstr "``r.search(s)``"

#: ../Doc/library/unittest.rst:1205
msgid ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"
msgstr ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"

#: ../Doc/library/unittest.rst:1205
msgid "``not r.search(s)``"
msgstr "``not r.search(s)``"

#: ../Doc/library/unittest.rst:1208
msgid ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"
msgstr ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"

#: ../Doc/library/unittest.rst:1208
msgid ""
"*a* and *b* have the same elements in the same number, regardless of their "
"order."
msgstr ""
"*a* y *b* tienen los mismos elementos y en el mismo número, sin importar su "
"orden."

#: ../Doc/library/unittest.rst:1217
msgid ""
"Test that *first* and *second* are approximately (or not approximately) "
"equal by computing the difference, rounding to the given number of decimal "
"*places* (default 7), and comparing to zero.  Note that these methods round "
"the values to the given number of *decimal places* (i.e. like the :func:"
"`round` function) and not *significant digits*."
msgstr ""
"Testea que *first* y *second* son aproximadamente (o no aproximadamente) "
"iguales calculando su diferencia, redondeando al número dado de puntos "
"*places* decimales (por defecto 7), y comparado a cero. Nótese que estos "
"métodos redondean los valores al número dado de *puntos decimales* (por "
"ejemplo como la función :func:`round`) y no *cifras significativas*."

#: ../Doc/library/unittest.rst:1223
msgid ""
"If *delta* is supplied instead of *places* then the difference between "
"*first* and *second* must be less or equal to (or greater than) *delta*."
msgstr ""
"Si se suministra *delta* en vez de *places* que entonces la diferencia entre "
"*first* y *second* deba ser menor o igual a (o mayor que) *delta*."

#: ../Doc/library/unittest.rst:1226
msgid "Supplying both *delta* and *places* raises a :exc:`TypeError`."
msgstr "Suministrar tanto *delta* como *places* lanza un :exc:`TypeError`."

#: ../Doc/library/unittest.rst:1228
msgid ""
":meth:`assertAlmostEqual` automatically considers almost equal objects that "
"compare equal.  :meth:`assertNotAlmostEqual` automatically fails if the "
"objects compare equal.  Added the *delta* keyword argument."
msgstr ""
":meth:`assertAlmostEqual` considera automáticamente casi iguales a los "
"objetos que se comparan igual. :meth:`assertNotAlmostEqual` falla "
"automáticamente si los objetos comparan iguales.  Añadido el argumento de "
"palabra clave *delta*."

#: ../Doc/library/unittest.rst:1239
msgid ""
"Test that *first* is respectively >, >=, < or <= than *second* depending on "
"the method name.  If not, the test will fail::"
msgstr ""
"Prueba que *first* es respectivamente >, >=, < o <= que *second* dependiendo "
"del nombre del método.  Si no, el test fallará::"

#: ../Doc/library/unittest.rst:1251
msgid ""
"Test that a *regex* search matches (or does not match) *text*.  In case of "
"failure, the error message will include the pattern and the *text* (or the "
"pattern and the part of *text* that unexpectedly matched).  *regex* may be a "
"regular expression object or a string containing a regular expression "
"suitable for use by :func:`re.search`."
msgstr ""
"Testea que una búsqueda *regex* coincide (o no coincide) con el *text*.  En "
"caso de fallo, el mensaje de error incluirá el patrón y el *text* (o el "
"patrón y la parte de *text* que coincida inesperadamente).  *regex* puede "
"ser un objeto de expresión regular o una cadena que contiene una expresión "
"regular adecuada para ser utilizada por :func:`re.search`."

#: ../Doc/library/unittest.rst:1257
msgid "Added under the name ``assertRegexpMatches``."
msgstr "Añadido bajo el nombre de ``assertRegexpMatches``."

#: ../Doc/library/unittest.rst:1259
msgid ""
"The method ``assertRegexpMatches()`` has been renamed to :meth:`."
"assertRegex`."
msgstr ""
"El método ``assertRegexpMatches()`` ha sido renombrado a :meth:`."
"assertRegex`."

#: ../Doc/library/unittest.rst:1262
msgid ":meth:`.assertNotRegex`."
msgstr ":meth:`.assertNotRegex`."

#: ../Doc/library/unittest.rst:1264
msgid ""
"The name ``assertNotRegexpMatches`` is a deprecated alias for :meth:`."
"assertNotRegex`."
msgstr ""
"El nombre ``assertNotRegexpMatches`` es un alias obsoleto para  :meth:`."
"assertNotRegex`."

#: ../Doc/library/unittest.rst:1271
msgid ""
"Test that sequence *first* contains the same elements as *second*, "
"regardless of their order. When they don't, an error message listing the "
"differences between the sequences will be generated."
msgstr ""
"Testea que la secuencia *first* contiene los mismos elementos que *second*, "
"independientemente de su orden. Cuando no lo hagan, se generará un mensaje "
"de error con las diferencias entre las secuencias."

#: ../Doc/library/unittest.rst:1275
msgid ""
"Duplicate elements are *not* ignored when comparing *first* and *second*. It "
"verifies whether each element has the same count in both sequences. "
"Equivalent to: ``assertEqual(Counter(list(first)), Counter(list(second)))`` "
"but works with sequences of unhashable objects as well."
msgstr ""
"Los elementos duplicados *no* son ignorados cuando se comparan *first* y "
"*second*. Verifica si cada elemento tiene la misma cuenta en ambas "
"secuencias. Equivalente a: ``assertEqual(Counter(list(first)), "
"Counter(list(second)))`` pero funciona también con secuencias de objetos que "
"no son hashable."

#: ../Doc/library/unittest.rst:1286
msgid ""
"The :meth:`assertEqual` method dispatches the equality check for objects of "
"the same type to different type-specific methods.  These methods are already "
"implemented for most of the built-in types, but it's also possible to "
"register new methods using :meth:`addTypeEqualityFunc`:"
msgstr ""
"El método :meth:`assertEqual` envía la comprobación de igualdad de los "
"objetos del mismo tipo a diferentes métodos específicos de tipo.  Estos "
"métodos ya están implementados para la mayoría de los tipos incorporados, "
"pero también es posible registrar nuevos métodos usando :meth:"
"`addTypeEqualityFunc`:"

#: ../Doc/library/unittest.rst:1293
msgid ""
"Registers a type-specific method called by :meth:`assertEqual` to check if "
"two objects of exactly the same *typeobj* (not subclasses) compare equal.  "
"*function* must take two positional arguments and a third msg=None keyword "
"argument just as :meth:`assertEqual` does.  It must raise :data:`self."
"failureException(msg) <failureException>` when inequality between the first "
"two parameters is detected -- possibly providing useful information and "
"explaining the inequalities in details in the error message."
msgstr ""
"Registra un método específico de tipo llamado por :meth:`assertEqual` para "
"comprobar si dos objetos del mismo *typeobj* (no subclases) comparan como "
"iguales.  *function* debe tomar dos argumentos posicionales y un tercer "
"argumento de palabra clave msg=None tal y como lo hace :meth:`assertEqual`.  "
"Debe lanzar   :data:`self.failureException(msg) <failureException>` cuando "
"se detecta una desigualdad entre los dos primeros parámetros, posiblemente "
"proporcionando información útil y explicando las desigualdades en detalle en "
"el mensaje de error."

#: ../Doc/library/unittest.rst:1304
msgid ""
"The list of type-specific methods automatically used by :meth:`~TestCase."
"assertEqual` are summarized in the following table.  Note that it's usually "
"not necessary to invoke these methods directly."
msgstr ""
"La lista de métodos específicos de tipo utilizados automáticamente por :meth:"
"`~TestCase.assertEqual` se resumen en la siguiente tabla.  Tenga en cuenta "
"que normalmente no es necesario invocar estos métodos directamente."

#: ../Doc/library/unittest.rst:1309
msgid "Used to compare"
msgstr "Usado para comparar"

#: ../Doc/library/unittest.rst:1311
msgid ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"
msgstr ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"

#: ../Doc/library/unittest.rst:1311
msgid "strings"
msgstr "strings"

#: ../Doc/library/unittest.rst:1314
msgid ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"
msgstr ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"

#: ../Doc/library/unittest.rst:1314
msgid "sequences"
msgstr "sequences"

#: ../Doc/library/unittest.rst:1317
msgid ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"
msgstr ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"

#: ../Doc/library/unittest.rst:1317
msgid "lists"
msgstr "lists"

#: ../Doc/library/unittest.rst:1320
msgid ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"
msgstr ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"

#: ../Doc/library/unittest.rst:1320
msgid "tuples"
msgstr "tuples"

#: ../Doc/library/unittest.rst:1323
msgid ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"
msgstr ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"

#: ../Doc/library/unittest.rst:1323
msgid "sets or frozensets"
msgstr "sets or frozensets"

#: ../Doc/library/unittest.rst:1326
msgid ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"
msgstr ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"

#: ../Doc/library/unittest.rst:1326
msgid "dicts"
msgstr "dicts"

#: ../Doc/library/unittest.rst:1334
msgid ""
"Test that the multiline string *first* is equal to the string *second*. When "
"not equal a diff of the two strings highlighting the differences will be "
"included in the error message. This method is used by default when comparing "
"strings with :meth:`assertEqual`."
msgstr ""
"Testea que la cadena multilínea *first* es igual a la cadena *second*. "
"Cuando no sea igual, una diferencia de las dos cadenas que resalte las "
"diferencias se incluirá en el mensaje de error. Este método se utiliza por "
"defecto cuando se comparan cadenas con :meth:`assertEqual`."

#: ../Doc/library/unittest.rst:1344
msgid ""
"Tests that two sequences are equal.  If a *seq_type* is supplied, both "
"*first* and *second* must be instances of *seq_type* or a failure will be "
"raised.  If the sequences are different an error message is constructed that "
"shows the difference between the two."
msgstr ""
"Testea que dos secuencias son iguales.  Si se suministra un *seq_type*, "
"tanto *first* como  *second* deben ser instancias de *seq_type* o se lanzará "
"un fallo.  Si las secuencias son diferentes se construye un mensaje de error "
"que muestra la diferencia entre las dos."

#: ../Doc/library/unittest.rst:1349
msgid ""
"This method is not called directly by :meth:`assertEqual`, but it's used to "
"implement :meth:`assertListEqual` and :meth:`assertTupleEqual`."
msgstr ""
"Este método no es llamado directamente por :meth:`assertEqual`, pero se usa "
"para implementar :meth:`assertListEqual` y :meth:`assertTupleEqual`."

#: ../Doc/library/unittest.rst:1359
msgid ""
"Tests that two lists or tuples are equal.  If not, an error message is "
"constructed that shows only the differences between the two.  An error is "
"also raised if either of the parameters are of the wrong type. These methods "
"are used by default when comparing lists or tuples with :meth:`assertEqual`."
msgstr ""
"Testea que dos listas o tuplas son iguales.  Si no es así, se construye un "
"mensaje de error que muestra sólo las diferencias entre las dos.  También se "
"lanza un error si alguno de los parámetros es del tipo equivocado. Estos "
"métodos se utilizan por defecto cuando se comparan listas o tuplas con :meth:"
"`assertEqual`."

#: ../Doc/library/unittest.rst:1370
msgid ""
"Tests that two sets are equal.  If not, an error message is constructed that "
"lists the differences between the sets.  This method is used by default when "
"comparing sets or frozensets with :meth:`assertEqual`."
msgstr ""
"Testea que dos conjuntos son iguales.  Si no es así, se construye un mensaje "
"de error que enumera las diferencias entre los conjuntos.  Este método se "
"utiliza por defecto cuando se comparan los conjuntos o frozensets con :meth:"
"`assertEqual`."

#: ../Doc/library/unittest.rst:1374
msgid ""
"Fails if either of *first* or *second* does not have a :meth:`set."
"difference` method."
msgstr ""
"Falla si cualquiera de *first* o *second* no tiene un método de :meth:`set."
"difference`."

#: ../Doc/library/unittest.rst:1382
msgid ""
"Test that two dictionaries are equal.  If not, an error message is "
"constructed that shows the differences in the dictionaries. This method will "
"be used by default to compare dictionaries in calls to :meth:`assertEqual`."
msgstr ""
"Testea que dos diccionarios son iguales.  Si no es así, se construye un "
"mensaje de error que muestra las diferencias en los diccionarios. Este "
"método se usará por defecto para comparar los diccionarios en las llamadas "
"a :meth:`assertEqual`."

#: ../Doc/library/unittest.rst:1393
msgid ""
"Finally the :class:`TestCase` provides the following methods and attributes:"
msgstr ""
"Finalmente, :class:`TestCase` proporciona los siguientes métodos y atributos:"

#: ../Doc/library/unittest.rst:1398
msgid ""
"Signals a test failure unconditionally, with *msg* or ``None`` for the error "
"message."
msgstr ""
"Señala un fallo del test incondicionalmente, con *msg* o  ``None`` para el "
"mensaje de error."

#: ../Doc/library/unittest.rst:1404
msgid ""
"This class attribute gives the exception raised by the test method.  If a "
"test framework needs to use a specialized exception, possibly to carry "
"additional information, it must subclass this exception in order to \"play "
"fair\" with the framework.  The initial value of this attribute is :exc:"
"`AssertionError`."
msgstr ""
"Este atributo de clase da la excepción lanzada por el método de test.  Si un "
"marco de pruebas necesita utilizar una excepción especializada, posiblemente "
"para llevar información adicional, debe subclasificar esta excepción para "
"\"jugar limpio\" con el marco.  El valor inicial de este atributo es :exc:"
"`AssertionError`."

#: ../Doc/library/unittest.rst:1413
msgid ""
"This class attribute determines what happens when a custom failure message "
"is passed as the msg argument to an assertXYY call that fails. ``True`` is "
"the default value. In this case, the custom message is appended to the end "
"of the standard failure message. When set to ``False``, the custom message "
"replaces the standard message."
msgstr ""
"Este atributo de clase determina lo que ocurre cuando se pasa un mensaje de "
"fallo personalizado como el argumento msg a una llamada assertXYY que falla. "
"``True`` es el valor por defecto. En este caso, el mensaje personalizado se "
"añade al final del mensaje de fallo estándar. Cuando se establece en "
"``False``, el mensaje personalizado reemplaza al mensaje estándar."

#: ../Doc/library/unittest.rst:1419
msgid ""
"The class setting can be overridden in individual test methods by assigning "
"an instance attribute, self.longMessage, to ``True`` or ``False`` before "
"calling the assert methods."
msgstr ""
"La configuración de la clase puede ser anulada en los métodos de test "
"individuales asignando un atributo de instancia, self.longMessage, a "
"``True`` o ``False`` antes de llamar a los métodos assert."

#: ../Doc/library/unittest.rst:1423
msgid "The class setting gets reset before each test call."
msgstr ""
"La configuración de la clase se reajusta antes de cada llamada de test."

#: ../Doc/library/unittest.rst:1430
msgid ""
"This attribute controls the maximum length of diffs output by assert methods "
"that report diffs on failure. It defaults to 80*8 characters. Assert methods "
"affected by this attribute are :meth:`assertSequenceEqual` (including all "
"the sequence comparison methods that delegate to it), :meth:"
"`assertDictEqual` and :meth:`assertMultiLineEqual`."
msgstr ""
"Este atributo controla la longitud máxima de las diferencias de salida de "
"métodos assert que reportan diferencias en caso de fallo. El valor "
"predeterminado es de 80*8 caracteres. Los métodos assert afectados por este "
"atributo son :meth:`assertSequenceEqual` (incluyendo todos los métodos de "
"comparación de secuencias que le delegan), :meth:`assertDictEqual` y :meth:"
"`assertMultiLineEqual`."

#: ../Doc/library/unittest.rst:1437
msgid ""
"Setting ``maxDiff`` to ``None`` means that there is no maximum length of "
"diffs."
msgstr ""
"Poner ``maxDiff`` en ``None`` significa que no hay una longitud máxima de "
"diferencias."

#: ../Doc/library/unittest.rst:1443
msgid ""
"Testing frameworks can use the following methods to collect information on "
"the test:"
msgstr ""
"Los marcos de test pueden utilizar los siguientes métodos para reunir "
"información sobre el test:"

#: ../Doc/library/unittest.rst:1449
msgid ""
"Return the number of tests represented by this test object.  For :class:"
"`TestCase` instances, this will always be ``1``."
msgstr ""
"Retorna el número de tests representados por este objeto de test.  Para las "
"instancias de :class:`TestCase`, este siempre será ``1``."

#: ../Doc/library/unittest.rst:1455
msgid ""
"Return an instance of the test result class that should be used for this "
"test case class (if no other result instance is provided to the :meth:`run` "
"method)."
msgstr ""
"Retorna una instancia de la clase de resultado de test que debería "
"utilizarse para esta clase de caso de test (si no se proporciona otra "
"instancia de resultado al método :meth:`run`)."

#: ../Doc/library/unittest.rst:1459
msgid ""
"For :class:`TestCase` instances, this will always be an instance of :class:"
"`TestResult`; subclasses of :class:`TestCase` should override this as "
"necessary."
msgstr ""
"Para las instancias de :class:`TestCase`, ésta siempre será una instancia "
"de :class:`TestResult`; las subclases de :class:`TestCase` deben anular esto "
"según sea necesario."

#: ../Doc/library/unittest.rst:1466
msgid ""
"Return a string identifying the specific test case.  This is usually the "
"full name of the test method, including the module and class name."
msgstr ""
"Devuelva una cadena que identifique el caso de test específico.  Normalmente "
"es el nombre completo del método de test, incluyendo el nombre del módulo y "
"de la clase."

#: ../Doc/library/unittest.rst:1472
msgid ""
"Returns a description of the test, or ``None`` if no description has been "
"provided.  The default implementation of this method returns the first line "
"of the test method's docstring, if available, or ``None``."
msgstr ""
"Devuelve una descripción de la prueba, o ``None`` si no se ha proporcionado "
"ninguna descripción.  La implementación por defecto de este método devuelve "
"la primera línea de la docstring del método de test, si está disponible, o  "
"``None`` ."

#: ../Doc/library/unittest.rst:1477
msgid ""
"In 3.1 this was changed to add the test name to the short description even "
"in the presence of a docstring.  This caused compatibility issues with "
"unittest extensions and adding the test name was moved to the :class:"
"`TextTestResult` in Python 3.2."
msgstr ""
"En 3.1 esto se cambió para añadir el nombre del test a la descripción corta "
"incluso en presencia de una docstring.  Esto causó problemas de "
"compatibilidad con las extensiones de unittest y la adición del nombre de "
"test  fue movida a la :class:`TextTestResult` en Python 3.2."

#: ../Doc/library/unittest.rst:1486
msgid ""
"Add a function to be called after :meth:`tearDown` to cleanup resources used "
"during the test. Functions will be called in reverse order to the order they "
"are added (:abbr:`LIFO (last-in, first-out)`).  They are called with any "
"arguments and keyword arguments passed into :meth:`addCleanup` when they are "
"added."
msgstr ""
"Añade una función que se llamará después de :meth:`tearDown` a los recursos "
"de limpieza utilizados durante el test. Las funciones se llamarán en orden "
"inverso al orden en que se agregan (:abbr:`LIFO (last-in, first-out)`).  Se "
"llaman con cualquier argumento y argumentos de palabra clave que se pase a :"
"meth:`addCleanup` cuando se agregan."

#: ../Doc/library/unittest.rst:1492
msgid ""
"If :meth:`setUp` fails, meaning that :meth:`tearDown` is not called, then "
"any cleanup functions added will still be called."
msgstr ""
"Si :meth:`setUp` falla, lo que significa que :meth:`tearDown` no se llama, "
"entonces cualquier función de limpieza añadida seguirá siendo llamada."

#: ../Doc/library/unittest.rst:1500
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :meth:`addCleanup` "
"and return the result of the :meth:`~object.__enter__` method."
msgstr ""
"Introduce el gestor de contexto :meth:`context` suministrado. Si es exitoso, "
"añade también su método :meth:`~object.__exit__` como función de limpieza "
"mediante :meth:`addCleanup` y retorna el resultado del método :meth:`~object."
"__enter__`."

#: ../Doc/library/unittest.rst:1510
msgid ""
"This method is called unconditionally after :meth:`tearDown`, or after :meth:"
"`setUp` if :meth:`setUp` raises an exception."
msgstr ""
"Este método se llama incondicionalmente después de  :meth:`tearDown`,  o "
"después de :meth:`setUp`  si :meth:`setUp` lanza una excepción."

#: ../Doc/library/unittest.rst:1513
msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addCleanup`. If you need cleanup functions to be called *prior* to :meth:"
"`tearDown` then you can call :meth:`doCleanups` yourself."
msgstr ""
"Es responsable de llamar a todas las funciones de limpieza añadidas por :"
"meth:`addCleanup`. Si necesitas que las funciones de limpieza se llamen *con "
"anterioridad* a :meth:`tearDown` entonces puedes llamar a :meth:`doCleanups` "
"tú mismo."

#: ../Doc/library/unittest.rst:1518
msgid ""
":meth:`doCleanups` pops methods off the stack of cleanup functions one at a "
"time, so it can be called at any time."
msgstr ""
":meth:`doCleanups` saca los métodos de la pila de funciones de limpieza uno "
"a uno, así que se puede llamar en cualquier momento."

#: ../Doc/library/unittest.rst:1526
msgid ""
"Add a function to be called after :meth:`tearDownClass` to cleanup resources "
"used during the test class. Functions will be called in reverse order to the "
"order they are added (:abbr:`LIFO (last-in, first-out)`). They are called "
"with any arguments and keyword arguments passed into :meth:`addClassCleanup` "
"when they are added."
msgstr ""
"Añade una función que se llamará después de :meth:`tearDownClass` para "
"limpiar recursos utilizados durante la clase de test. Las funciones se "
"llamarán en orden inverso al orden en que se agregan (:abbr:`LIFO (last-in, "
"first-out)`). Se llaman con cualquier argumento y argumento de palabra clave "
"que se pase a :meth:`addClassCleanup` cuando se añadan."

#: ../Doc/library/unittest.rst:1532
msgid ""
"If :meth:`setUpClass` fails, meaning that :meth:`tearDownClass` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"Si :meth:`setUpClass` falla, lo que significa que :meth:`tearDownClass` no "
"se invoca, entonces cualquier función de limpieza añadida seguirá siendo "
"llamada."

#: ../Doc/library/unittest.rst:1540
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :meth:"
"`addClassCleanup` and return the result of the :meth:`~object.__enter__` "
"method."
msgstr ""
"Introduce el :term:`context manager` suministrado. Si es exitoso, añade "
"también su método :meth:`~object.__exit__` como función de limpieza "
"mediante :meth:`addClassCleanup` y retorna el resultado del método :meth:"
"`~object.__enter__`."

#: ../Doc/library/unittest.rst:1550
msgid ""
"This method is called unconditionally after :meth:`tearDownClass`, or after :"
"meth:`setUpClass` if :meth:`setUpClass` raises an exception."
msgstr ""
"Este método se llama incondicionalmente después de :meth:`tearDownClass`, o "
"después de :meth:`setUpClass`  si :meth:`setUpClass` lanza una excepción."

#: ../Doc/library/unittest.rst:1553
msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addClassCleanup`. If you need cleanup functions to be called *prior* to :"
"meth:`tearDownClass` then you can call :meth:`doClassCleanups` yourself."
msgstr ""
"Es responsable de llamar a todas las funciones de limpieza añadidas por :"
"meth:`addCleanupClass`. Si necesitas que las funciones de limpieza se llamen "
"*con anterioridad* a :meth:`tearDownClass` entonces puedes llamar a :meth:"
"`doCleanupsClass` tú mismo."

#: ../Doc/library/unittest.rst:1558
msgid ""
":meth:`doClassCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ""
":meth:`doCleanupsClass` saca los métodos de la pila de funciones de limpieza "
"de uno en uno, así que se puede llamar en cualquier momento."

#: ../Doc/library/unittest.rst:1566
msgid ""
"This class provides an API similar to :class:`TestCase` and also accepts "
"coroutines as test functions."
msgstr ""
"Esta clase proporciona una API similar a :class:`TestCase` y también acepta "
"corutinas como funciones de test."

#: ../Doc/library/unittest.rst:1573
msgid ""
"Method called to prepare the test fixture. This is called after :meth:"
"`setUp`. This is called immediately before calling the test method; other "
"than :exc:`AssertionError` or :exc:`SkipTest`, any exception raised by this "
"method will be considered an error rather than a test failure. The default "
"implementation does nothing."
msgstr ""
"Método llamado para preparar la configuración de test. Esto se llama después "
"de :meth:`setUp`. Se llama inmediatamente antes de llamar al método de test; "
"aparte de :exc:`AssertionError` o :exc:`SkipTest`, cualquier excepción "
"lanzada por este método se considerará un error más que un fallo del test. "
"La implementación por defecto no hace nada."

#: ../Doc/library/unittest.rst:1581
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called before :meth:`tearDown`. This is called "
"even if the test method raised an exception, so the implementation in "
"subclasses may need to be particularly careful about checking internal "
"state.  Any exception, other than :exc:`AssertionError` or :exc:`SkipTest`, "
"raised by this method will be considered an additional error rather than a "
"test failure (thus increasing the total number of reported errors). This "
"method will only be called if the :meth:`asyncSetUp` succeeds, regardless of "
"the outcome of the test method. The default implementation does nothing."
msgstr ""
"Método llamado inmediatamente después de que se haya llamado el método de "
"test y se haya registrado el resultado.  Esto se llama antes de :meth:"
"`tearDown`. Se llama así aunque el método de test haya lanzado una "
"excepción, por lo que la implementación en las subclases puede necesitar ser "
"particularmente cuidadosa en la comprobación del estado interno.  Cualquier "
"excepción, que no sea :exc:`AssertionError` o :exc:`SkipTest`, lanzada por "
"este método se considerará un error adicional en lugar de un fallo del test "
"(aumentando así el número total de errores reportados). Este método sólo se "
"llamará si :meth:`asyncSetUp` tiene éxito, independientemente del resultado "
"del método de test. La implementación por defecto no hace nada."

#: ../Doc/library/unittest.rst:1593
msgid "This method accepts a coroutine that can be used as a cleanup function."
msgstr ""
"Este método acepta una corutina que puede ser utilizada como función de "
"limpieza."

#: ../Doc/library/unittest.rst:1597
msgid ""
"Enter the supplied :term:`asynchronous context manager`.  If successful, "
"also add its :meth:`~object.__aexit__` method as a cleanup function by :meth:"
"`addAsyncCleanup` and return the result of the :meth:`~object.__aenter__` "
"method."
msgstr ""
"Introduce el :term:`asynchronous context manager` suministrado. Si es "
"exitoso, añade también su método :meth:`~object.__aexit__` como función de "
"limpieza mediante :meth:`addAsyncCleanup` y retorna el resultado del método :"
"meth:`~object.__aenter__`."

#: ../Doc/library/unittest.rst:1607
msgid ""
"Sets up a new event loop to run the test, collecting the result into the :"
"class:`TestResult` object passed as *result*.  If *result* is omitted or "
"``None``, a temporary result object is created (by calling the :meth:"
"`defaultTestResult` method) and used. The result object is returned to :meth:"
"`run`'s caller. At the end of the test all the tasks in the event loop are "
"cancelled."
msgstr ""
"Establece un nuevo bucle de eventos para ejecutar el test, recogiendo el "
"resultado en el objeto :class:`TestResult` pasado como *result*.  Si se "
"omite *result* o ``None``, se crea un objeto resultado temporal (llamando al "
"método :meth:`defaultTestResult`) y se utiliza. El objeto resultante se "
"devuelve al invocado de :meth:`run`. Al final del test se cancelan todas las "
"tareas del bucle de eventos."

#: ../Doc/library/unittest.rst:1615
msgid "An example illustrating the order::"
msgstr "Un ejemplo ilustrando el orden::"

#: ../Doc/library/unittest.rst:1651
msgid ""
"After running the test, ``events`` would contain ``[\"setUp\", "
"\"asyncSetUp\", \"test_response\", \"asyncTearDown\", \"tearDown\", "
"\"cleanup\"]``."
msgstr ""
"Después de ejecutar el test,  ``events`` contendría  ``[“setUp”, "
"“asyncSetUp”, “test_response”, “asyncTearDown”, “tearDown”, “cleanup”]``."

#: ../Doc/library/unittest.rst:1656
msgid ""
"This class implements the portion of the :class:`TestCase` interface which "
"allows the test runner to drive the test, but does not provide the methods "
"which test code can use to check and report errors.  This is used to create "
"test cases using legacy test code, allowing it to be integrated into a :mod:"
"`unittest`-based test framework."
msgstr ""
"Esta clase implementa la porción de la interfaz :class:`TestCase` que "
"permite al corredor de tests conducir los tests, pero no proporciona los "
"métodos que el código de test puede utilizar para comprobar e informar de "
"los errores.  Se utiliza para crear casos de test utilizando código de "
"prueba heredado, lo que permite que se integre en un marco de tests basado "
"en :mod:`unittest`."

#: ../Doc/library/unittest.rst:1666
msgid "Deprecated aliases"
msgstr "Alias obsoletos"

#: ../Doc/library/unittest.rst:1668
msgid ""
"For historical reasons, some of the :class:`TestCase` methods had one or "
"more aliases that are now deprecated.  The following table lists the correct "
"names along with their deprecated aliases:"
msgstr ""
"Por razones históricas, algunos de los métodos de :class:`TestCase` tenían "
"uno o más alias que ahora están obsoletos.  La siguiente tabla lista los "
"nombres correctos junto con sus alias obsoletos:"

#: ../Doc/library/unittest.rst:1673
msgid "Method Name"
msgstr "Nombre del método"

#: ../Doc/library/unittest.rst:1673
msgid "Deprecated alias"
msgstr "Alias deprecado"

#: ../Doc/library/unittest.rst:1675
msgid ":meth:`.assertEqual`"
msgstr ":meth:`.assertEqual`"

#: ../Doc/library/unittest.rst:1675
msgid "failUnlessEqual"
msgstr "failUnlessEqual"

#: ../Doc/library/unittest.rst:1675
msgid "assertEquals"
msgstr "assertEquals"

#: ../Doc/library/unittest.rst:1676
msgid ":meth:`.assertNotEqual`"
msgstr ":meth:`.assertNotEqual`"

#: ../Doc/library/unittest.rst:1676
msgid "failIfEqual"
msgstr "failIfEqual"

#: ../Doc/library/unittest.rst:1676
msgid "assertNotEquals"
msgstr "assertNotEquals"

#: ../Doc/library/unittest.rst:1677
msgid ":meth:`.assertTrue`"
msgstr ":meth:`.assertTrue`"

#: ../Doc/library/unittest.rst:1677
msgid "failUnless"
msgstr "failUnless"

#: ../Doc/library/unittest.rst:1677
msgid "assert\\_"
msgstr "assert\\_"

#: ../Doc/library/unittest.rst:1678
msgid ":meth:`.assertFalse`"
msgstr ":meth:`.assertFalse`"

#: ../Doc/library/unittest.rst:1678
msgid "failIf"
msgstr "failIf"

#: ../Doc/library/unittest.rst:1679
msgid ":meth:`.assertRaises`"
msgstr ":meth:`.assertRaises`"

#: ../Doc/library/unittest.rst:1679
msgid "failUnlessRaises"
msgstr "failUnlessRaises"

#: ../Doc/library/unittest.rst:1680
msgid ":meth:`.assertAlmostEqual`"
msgstr ":meth:`.assertAlmostEqual`"

#: ../Doc/library/unittest.rst:1680
msgid "failUnlessAlmostEqual"
msgstr "failUnlessAlmostEqual"

#: ../Doc/library/unittest.rst:1680
msgid "assertAlmostEquals"
msgstr "assertAlmostEquals"

#: ../Doc/library/unittest.rst:1681
msgid ":meth:`.assertNotAlmostEqual`"
msgstr ":meth:`.assertNotAlmostEqual`"

#: ../Doc/library/unittest.rst:1681
msgid "failIfAlmostEqual"
msgstr "failIfAlmostEqual"

#: ../Doc/library/unittest.rst:1681
msgid "assertNotAlmostEquals"
msgstr "assertNotAlmostEquals"

#: ../Doc/library/unittest.rst:1682
msgid ":meth:`.assertRegex`"
msgstr ":meth:`.assertRegex`"

#: ../Doc/library/unittest.rst:1682
msgid "assertRegexpMatches"
msgstr "assertRegexpMatches"

#: ../Doc/library/unittest.rst:1683
msgid ":meth:`.assertNotRegex`"
msgstr ":meth:`.assertNotRegex`"

#: ../Doc/library/unittest.rst:1683
msgid "assertNotRegexpMatches"
msgstr "assertNotRegexpMatches"

#: ../Doc/library/unittest.rst:1684
msgid ":meth:`.assertRaisesRegex`"
msgstr ":meth:`.assertRaisesRegex`"

#: ../Doc/library/unittest.rst:1684
msgid "assertRaisesRegexp"
msgstr "assertRaisesRegexp"

#: ../Doc/library/unittest.rst:1687
msgid "The fail* aliases listed in the second column have been deprecated."
msgstr ""
"Los alias de fail* que figuran en la segunda columna han sido declarados "
"obsoletos."

#: ../Doc/library/unittest.rst:1689
msgid "The assert* aliases listed in the third column have been deprecated."
msgstr ""
"Los alias de aserción* que figuran en la tercera columna han sido declarados "
"obsoletos."

#: ../Doc/library/unittest.rst:1691
msgid ""
"``assertRegexpMatches`` and ``assertRaisesRegexp`` have been renamed to :"
"meth:`.assertRegex` and :meth:`.assertRaisesRegex`."
msgstr ""
"``assertRegexpMatches`` y ``assertRaisesRegexp`` han sido renombrados a :"
"meth:`.assertRegex` y :meth:`.assertRaisesRegex`."

#: ../Doc/library/unittest.rst:1694
msgid ""
"The ``assertNotRegexpMatches`` name is deprecated in favor of :meth:`."
"assertNotRegex`."
msgstr ""
"El nombre ``assertNotRegexpMatches`` se ha declarado obsoleto en favor de :"
"meth:`.assertNotRegex`."

#: ../Doc/library/unittest.rst:1700
msgid "Grouping tests"
msgstr "Agrupando tests"

#: ../Doc/library/unittest.rst:1704
msgid ""
"This class represents an aggregation of individual test cases and test "
"suites. The class presents the interface needed by the test runner to allow "
"it to be run as any other test case.  Running a :class:`TestSuite` instance "
"is the same as iterating over the suite, running each test individually."
msgstr ""
"Esta clase representa una agregación de casos de test individuales y "
"conjuntos de tests. La clase presenta la interfaz que necesita el corredor "
"de tests para poder ser ejecutado como cualquier otro caso de test.  "
"Ejecutar una instancia :class:`TestSuite` es lo mismo que iterar sobre el "
"conjunto, ejecutando cada test individualmente."

#: ../Doc/library/unittest.rst:1709
msgid ""
"If *tests* is given, it must be an iterable of individual test cases or "
"other test suites that will be used to build the suite initially. Additional "
"methods are provided to add test cases and suites to the collection later on."
msgstr ""
"Si se indican *tests*, debe ser un iterable de casos de test individuales u "
"otros conjuntos de tests que se usarán para construir el conjunto "
"inicialmente. Se proporcionan métodos adicionales para añadir casos de test "
"y conjuntos a la colección más adelante."

#: ../Doc/library/unittest.rst:1713
msgid ""
":class:`TestSuite` objects behave much like :class:`TestCase` objects, "
"except they do not actually implement a test.  Instead, they are used to "
"aggregate tests into groups of tests that should be run together. Some "
"additional methods are available to add tests to :class:`TestSuite` "
"instances:"
msgstr ""
"Los objetos de :class:`TestSuite` se comportan de manera muy parecida a los "
"objetos de :class:`TestCase`, excepto que no implementan un test.  En "
"cambio, se usan para agregar tests en grupos de tests que deben ser "
"ejecutados juntos. Existen algunos métodos adicionales para agregar tests a "
"las instancias de :class:`TestSuite`:"

#: ../Doc/library/unittest.rst:1721
msgid "Add a :class:`TestCase` or :class:`TestSuite` to the suite."
msgstr "Añade un :class:`TestCase` o :class:`TestSuite` al conjunto."

#: ../Doc/library/unittest.rst:1726
msgid ""
"Add all the tests from an iterable of :class:`TestCase` and :class:"
"`TestSuite` instances to this test suite."
msgstr ""
"Añade todos los tests de un iterable de :class:`TestCase` y :class:"
"`TestSuite` a este conjunto de tests."

#: ../Doc/library/unittest.rst:1729
msgid ""
"This is equivalent to iterating over *tests*, calling :meth:`addTest` for "
"each element."
msgstr ""
"Esto equivale a iterar sobre *tests*, llamando a :meth:`addTest` para cada "
"elemento."

#: ../Doc/library/unittest.rst:1732
msgid ":class:`TestSuite` shares the following methods with :class:`TestCase`:"
msgstr ""
":class:`TestSuite` comparte los siguientes métodos con :class:`TestCase`:"

#: ../Doc/library/unittest.rst:1737
msgid ""
"Run the tests associated with this suite, collecting the result into the "
"test result object passed as *result*.  Note that unlike :meth:`TestCase."
"run`, :meth:`TestSuite.run` requires the result object to be passed in."
msgstr ""
"Ejecuta los tests asociados a este conjunto, recogiendo el resultado en el "
"objeto de resultado del test pasado como *result*.  Tenga en cuenta que a "
"diferencia de :meth:`TestCase.run`, :meth:`TestSuite.run` requiere que se "
"pase el objeto resultado."

#: ../Doc/library/unittest.rst:1745
msgid ""
"Run the tests associated with this suite without collecting the result. This "
"allows exceptions raised by the test to be propagated to the caller and can "
"be used to support running tests under a debugger."
msgstr ""
"Ejecuta los tests asociados con este conjunto sin recoger los resultados. "
"Esto permite que las excepciones lanzadas por este test sean propagadas al "
"invocador y puedes ser usadas para apoyar tests que están ejecutándose con "
"un debugger."

#: ../Doc/library/unittest.rst:1752
msgid ""
"Return the number of tests represented by this test object, including all "
"individual tests and sub-suites."
msgstr ""
"Retorna el numero de tests representados por este objeto de test, incluidos "
"todos los test individuales y los sub-conjuntos."

#: ../Doc/library/unittest.rst:1758
msgid ""
"Tests grouped by a :class:`TestSuite` are always accessed by iteration. "
"Subclasses can lazily provide tests by overriding :meth:`__iter__`. Note "
"that this method may be called several times on a single suite (for example "
"when counting tests or comparing for equality) so the tests returned by "
"repeated iterations before :meth:`TestSuite.run` must be the same for each "
"call iteration. After :meth:`TestSuite.run`, callers should not rely on the "
"tests returned by this method unless the caller uses a subclass that "
"overrides :meth:`TestSuite._removeTestAtIndex` to preserve test references."
msgstr ""
"Los tests agrupados por una :class:`TestSuite` se acceden siempre por "
"iteración. Las subclases pueden proporcionar tests anulando :meth:"
"`__iter__`. Tenga en cuenta que este método puede ser invocado varias veces "
"en un mismo conjunto (por ejemplo, cuando se cuentan los tests o se comparan "
"por igualdad), por lo que los tests retornados por iteraciones repetidas "
"antes de :meth:`TestSuite.run` deben ser los mismos para cada iteración de "
"invocación. Después de :meth:`TestSuite.run`, los invocados no deben confiar "
"en los tests retornados por este método a menos que el invocado utilice una "
"subclase que anule :meth:`TestSuite._removeTestAtIndex` para preservar las "
"referencias de los tests."

#: ../Doc/library/unittest.rst:1768
msgid ""
"In earlier versions the :class:`TestSuite` accessed tests directly rather "
"than through iteration, so overriding :meth:`__iter__` wasn't sufficient for "
"providing tests."
msgstr ""
"En versiones anteriores la :class:`TestSuite` accedía a los test "
"directamente en lugar de a través de la iteración, por lo que anular :meth:"
"`__iter__` no era suficiente para proporcionar los tests."

#: ../Doc/library/unittest.rst:1773
msgid ""
"In earlier versions the :class:`TestSuite` held references to each :class:"
"`TestCase` after :meth:`TestSuite.run`. Subclasses can restore that behavior "
"by overriding :meth:`TestSuite._removeTestAtIndex`."
msgstr ""
"En versiones anteriores, la :class:`TestSuite` tenía referencias a cada :"
"class:`TestCase` después de :meth:`TestSuite.run`. Las subclases pueden "
"restaurar ese comportamiento anulando :meth:`TestSuite._removeTestAtIndex`."

#: ../Doc/library/unittest.rst:1778
msgid ""
"In the typical usage of a :class:`TestSuite` object, the :meth:`run` method "
"is invoked by a :class:`TestRunner` rather than by the end-user test harness."
msgstr ""
"En el uso típico de un objeto :class:`TestSuite`, el método :meth:`run` es "
"invocado por un :class:`TestRunner` en lugar de por el marco de test de "
"pruebas automático del usuario final."

#: ../Doc/library/unittest.rst:1783
msgid "Loading and running tests"
msgstr "Cargando y ejecutando tests"

#: ../Doc/library/unittest.rst:1787
msgid ""
"The :class:`TestLoader` class is used to create test suites from classes and "
"modules.  Normally, there is no need to create an instance of this class; "
"the :mod:`unittest` module provides an instance that can be shared as :data:"
"`unittest.defaultTestLoader`.  Using a subclass or instance, however, allows "
"customization of some configurable properties."
msgstr ""
"La clase :class:`TestLoader` se utiliza para crear conjuntos de tests a "
"partir de clases y módulos.  Normalmente, no es necesario crear una "
"instancia de esta clase; el módulo :mod:`unittest` proporciona una instancia "
"que puede ser compartida como :data:`unittest.defaultTestLoader`.  Sin "
"embargo, el uso de una subclase o instancia permite la personalización de "
"algunas propiedades configurables."

#: ../Doc/library/unittest.rst:1793
msgid ":class:`TestLoader` objects have the following attributes:"
msgstr "Los objetos :class:`TestLoader`  tienen los siguientes atributos:"

#: ../Doc/library/unittest.rst:1798
msgid ""
"A list of the non-fatal errors encountered while loading tests. Not reset by "
"the loader at any point. Fatal errors are signalled by the relevant method "
"raising an exception to the caller. Non-fatal errors are also indicated by a "
"synthetic test that will raise the original error when run."
msgstr ""
"Una lista de los errores no fatales encontrados durante la carga de tests. "
"No reseteados por el cargador en ningún momento. Los errores fatales son "
"señalados por el método relevante que lanza una excepción al invocador. Los "
"errores no fatales también son indicados por una prueba sintética que "
"lanzará el error original cuando se ejecute."

#: ../Doc/library/unittest.rst:1807
msgid ":class:`TestLoader` objects have the following methods:"
msgstr "Los objetos :class:`TestLoader` tienen los siguientes métodos:"

#: ../Doc/library/unittest.rst:1812
msgid ""
"Return a suite of all test cases contained in the :class:`TestCase`\\ -"
"derived :class:`testCaseClass`."
msgstr ""
"Devuelve un conjunto de todos los casos de test contenidos en la :class:"
"`TestCase`\\ derivada de :class:`testCaseClass`."

#: ../Doc/library/unittest.rst:1815
msgid ""
"A test case instance is created for each method named by :meth:"
"`getTestCaseNames`. By default these are the method names beginning with "
"``test``. If :meth:`getTestCaseNames` returns no methods, but the :meth:"
"`runTest` method is implemented, a single test case is created for that "
"method instead."
msgstr ""
"Se crea una instancia de caso de test para cada método nombrado por :meth:"
"`getTestCaseNames`. Por defecto, estos son los nombres de los métodos que "
"comienzan con ``test``. Si :meth:`getTestCaseNames` no retorna ningún "
"método, pero se implementa el método :meth:`runTest`, se crea un único caso "
"de test para ese método."

#: ../Doc/library/unittest.rst:1824
msgid ""
"Return a suite of all test cases contained in the given module. This method "
"searches *module* for classes derived from :class:`TestCase` and creates an "
"instance of the class for each test method defined for the class."
msgstr ""
"Devuelva un conjunto de todos los casos de test contenidos en el módulo "
"dado. Este método busca en *module* clases derivadas de :class:`TestCase` y "
"crea una instancia de la clase para cada método de test definido para la "
"clase."

#: ../Doc/library/unittest.rst:1831
msgid ""
"While using a hierarchy of :class:`TestCase`\\ -derived classes can be "
"convenient in sharing fixtures and helper functions, defining test methods "
"on base classes that are not intended to be instantiated directly does not "
"play well with this method.  Doing so, however, can be useful when the "
"fixtures are different and defined in subclasses."
msgstr ""
"Aunque el uso de una jerarquía de clases derivadas de  :class:`TestCase`  "
"puede ser conveniente para compartir configuraciones y funciones de ayuda, "
"la definición de métodos de test en clases base que no están destinadas a "
"ser instanciadas directamente no complementa bien con este método.  Hacerlo, "
"sin embargo, puede ser útil cuando las configuraciones son diferentes y "
"están definidas en subclases."

#: ../Doc/library/unittest.rst:1837
msgid ""
"If a module provides a ``load_tests`` function it will be called to load the "
"tests. This allows modules to customize test loading. This is the "
"`load_tests protocol`_.  The *pattern* argument is passed as the third "
"argument to ``load_tests``."
msgstr ""
"Si un módulo proporciona una función ``load_tests`` será llamado para cargar "
"los tests. Esto permite a los módulos personalizar la carga de los tests. "
"Este es el `load_tests protocol`_.  El argumento *pattern* se pasa como "
"tercer argumento a ``load_tests``."

#: ../Doc/library/unittest.rst:1842
msgid "Support for ``load_tests`` added."
msgstr "Se ha añadido soporte para ``load_tests``."

#: ../Doc/library/unittest.rst:1845
msgid ""
"The undocumented and unofficial *use_load_tests* default argument is "
"deprecated and ignored, although it is still accepted for backward "
"compatibility.  The method also now accepts a keyword-only argument "
"*pattern* which is passed to ``load_tests`` as the third argument."
msgstr ""
"El argumento por defecto *use_load_tests* no documentado y no oficial es "
"obsoleto e ignorado, aunque sigue siendo aceptado por la "
"retrocompatibilidad.  El método también acepta ahora un argumento de sólo "
"palabra clave *pattern* que se pasa a ``load_tests`` como tercer argumento."

#: ../Doc/library/unittest.rst:1854
msgid "Return a suite of all test cases given a string specifier."
msgstr ""
"Retorna un conjunto de todos los casos de test dado un especificador de "
"cadena."

#: ../Doc/library/unittest.rst:1856
msgid ""
"The specifier *name* is a \"dotted name\" that may resolve either to a "
"module, a test case class, a test method within a test case class, a :class:"
"`TestSuite` instance, or a callable object which returns a :class:`TestCase` "
"or :class:`TestSuite` instance.  These checks are applied in the order "
"listed here; that is, a method on a possible test case class will be picked "
"up as \"a test method within a test case class\", rather than \"a callable "
"object\"."
msgstr ""
"El especificador *name* es un \"nombre punteado\" que puede resolverse ya "
"sea a un módulo, una clase de caso de test, un método de test dentro de una "
"clase de caso de test, una instancia :class:`TestSuite`, o un objeto "
"invocable que devuelve una instancia :class:`TestCase` o :class:"
"`TestSuite`.  Estas comprobaciones se aplican en el orden que se indica "
"aquí; es decir, un método en una posible clase de caso de test se recogerá "
"como \"un método de test dentro de una clase de caso de test”, en lugar de "
"\"un objeto invocable”."

#: ../Doc/library/unittest.rst:1864
msgid ""
"For example, if you have a module :mod:`SampleTests` containing a :class:"
"`TestCase`\\ -derived class :class:`SampleTestCase` with three test methods "
"(:meth:`test_one`, :meth:`test_two`, and :meth:`test_three`), the specifier "
"``'SampleTests.SampleTestCase'`` would cause this method to return a suite "
"which will run all three test methods. Using the specifier ``'SampleTests."
"SampleTestCase.test_two'`` would cause it to return a test suite which will "
"run only the :meth:`test_two` test method. The specifier can refer to "
"modules and packages which have not been imported; they will be imported as "
"a side-effect."
msgstr ""
"Por ejemplo, si tiene un módulo :mod:`SampleTests` que contiene una clase "
"derivada de :class:`TestCase` :class:`SampleTestCase` con tres métodos de "
"test (:meth:`test_one`, :meth:`test_two`, y :meth:`test_three`), el "
"especificador ``SampleTests.SampleTestCase'`` haría que este método "
"devolviera una suite que ejecutara los tres métodos de prueba. El uso del "
"especificador ``SampleTests.SampleTestCase.test_two'`` provocaría que este "
"método devolviera una suite de tests que ejecutaría sólo el método de test :"
"meth:`test_two`. El especificador puede referirse a los módulos y paquetes "
"que no han sido importados; serán importados como un efecto secundario."

#: ../Doc/library/unittest.rst:1874
msgid "The method optionally resolves *name* relative to the given *module*."
msgstr "El método opcionalmente resuelve *name* relativo al *module* dado."

#: ../Doc/library/unittest.rst:1876
msgid ""
"If an :exc:`ImportError` or :exc:`AttributeError` occurs while traversing "
"*name* then a synthetic test that raises that error when run will be "
"returned. These errors are included in the errors accumulated by self.errors."
msgstr ""
"Si un :exc:`ImportError` o :exc:`AttributeError` ocurre mientras atraviesa "
"*name* entonces se devolverá un test sintético que lanza ese error cuando se "
"ejecuta. Estos errores están incluidos en los errores acumulados por self."
"errors."

#: ../Doc/library/unittest.rst:1885
msgid ""
"Similar to :meth:`loadTestsFromName`, but takes a sequence of names rather "
"than a single name.  The return value is a test suite which supports all the "
"tests defined for each name."
msgstr ""
"Similar a :meth:`loadTestsFromName`, pero toma una secuencia de nombres en "
"lugar de un solo nombre.  El valor de retorno es una suite de tests que "
"soporta todos los test  definidos para cada nombre."

#: ../Doc/library/unittest.rst:1892
msgid ""
"Return a sorted sequence of method names found within *testCaseClass*; this "
"should be a subclass of :class:`TestCase`."
msgstr ""
"Devuelve una secuencia ordenada de nombres de métodos encontrados dentro de "
"*testCaseClass*; esta debería ser una subclase de :class:`TestCase`."

#: ../Doc/library/unittest.rst:1898
msgid ""
"Find all the test modules by recursing into subdirectories from the "
"specified start directory, and return a TestSuite object containing them. "
"Only test files that match *pattern* will be loaded. (Using shell style "
"pattern matching.) Only module names that are importable (i.e. are valid "
"Python identifiers) will be loaded."
msgstr ""
"Encuentra todos los módulos de prueba recurriendo a subdirectorios del "
"directorio de inicio especificado, y retorna un objeto de TestSuite que los "
"contenga. Sólo se cargarán los archivos de test que coincidan con el "
"*pattern*. (Utilizando la coincidencia de patrones de estilo de shell.) Sólo "
"se cargarán los nombres de los módulos que sean importables (es decir, que "
"sean identificadores Python válidos)."

#: ../Doc/library/unittest.rst:1904
msgid ""
"All test modules must be importable from the top level of the project. If "
"the start directory is not the top level directory then the top level "
"directory must be specified separately."
msgstr ""
"Todos los módulos de test deben ser importables desde el nivel superior del "
"proyecto. Si el directorio de inicio no es el directorio de nivel superior, "
"entonces el directorio de nivel superior debe ser especificado por separado."

#: ../Doc/library/unittest.rst:1908
msgid ""
"If importing a module fails, for example due to a syntax error, then this "
"will be recorded as a single error and discovery will continue.  If the "
"import failure is due to :exc:`SkipTest` being raised, it will be recorded "
"as a skip instead of an error."
msgstr ""
"Si la importación de un módulo falla, por ejemplo debido a un error de "
"sintaxis, entonces esto se registrará como un error único y el "
"descubrimiento continuará.  Si el fallo en la importación se debe a que :exc:"
"`SkipTest` se ha lanzado, se registrará como un salto en lugar de un error."

#: ../Doc/library/unittest.rst:1913
msgid ""
"If a package (a directory containing a file named :file:`__init__.py`) is "
"found, the package will be checked for a ``load_tests`` function. If this "
"exists then it will be called ``package.load_tests(loader, tests, "
"pattern)``. Test discovery takes care to ensure that a package is only "
"checked for tests once during an invocation, even if the load_tests function "
"itself calls ``loader.discover``."
msgstr ""
"Si se encuentra un paquete (un directorio que contiene un archivo llamado :"
"file:`__init__.py`), se comprobará si el paquete tiene una función "
"``load_tests``. Si existe, entonces se invocará ``package.load_tests(loader, "
"tests, pattern)``. Test discovery se encarga de asegurar que un paquete sólo "
"se comprueba una vez durante una invocación, incluso si la propia función "
"load_tests llama a ``loader.discover``."

#: ../Doc/library/unittest.rst:1921
msgid ""
"If ``load_tests`` exists then discovery does *not* recurse into the package, "
"``load_tests`` is responsible for loading all tests in the package."
msgstr ""
"Si ``load_tests`` existe, entonces el descubrimiento *no* recurre en el "
"paquete, ``load_tests`` es responsable de cargar todos los tests en el "
"paquete."

#: ../Doc/library/unittest.rst:1925
msgid ""
"The pattern is deliberately not stored as a loader attribute so that "
"packages can continue discovery themselves. *top_level_dir* is stored so "
"``load_tests`` does not need to pass this argument in to ``loader."
"discover()``."
msgstr ""
"El patrón no se almacena deliberadamente como atributo cargador para que los "
"paquetes puedan continuar descubriéndose a sí mismos. *top_level_dir* se "
"almacena de forma que ``load_tests`` no necesita pasar este argumento a "
"``loader.discover()``."

#: ../Doc/library/unittest.rst:1930
msgid "*start_dir* can be a dotted module name as well as a directory."
msgstr ""
"*start_dir* puede ser un nombre de módulo punteado así como un directorio."

#: ../Doc/library/unittest.rst:1934
msgid ""
"Modules that raise :exc:`SkipTest` on import are recorded as skips, not "
"errors."
msgstr ""
"Los módulos que lanzan :exc:`SkipTest` en la importación se registran como "
"saltos, no como errores."

#: ../Doc/library/unittest.rst:1938
msgid "*start_dir* can be a :term:`namespace packages <namespace package>`."
msgstr ""
"*start_dir* puede ser un :term:`paquete de espacios de nombres <namespace "
"package>`."

#: ../Doc/library/unittest.rst:1941
msgid ""
"Paths are sorted before being imported so that execution order is the same "
"even if the underlying file system's ordering is not dependent on file name."
msgstr ""
"Las rutas se ordenan antes de ser importadas para que el orden de ejecución "
"sea el mismo, incluso si el orden del sistema de archivos subyacente no "
"depende del nombre del archivo."

#: ../Doc/library/unittest.rst:1946
msgid ""
"Found packages are now checked for ``load_tests`` regardless of whether "
"their path matches *pattern*, because it is impossible for a package name to "
"match the default pattern."
msgstr ""
"Los paquetes encontrados son ahora comprobados para ``load_tests`` sin "
"importar si su ruta coincide con el *pattern*, porque es imposible que el "
"nombre de un paquete coincida con el patrón por defecto."

#: ../Doc/library/unittest.rst:1951
msgid ""
"*start_dir* can not be a :term:`namespace packages <namespace package>`. It "
"has been broken since Python 3.7 and Python 3.11 officially remove it."
msgstr ""
"*start_dir* no puede ser un :term:`paquete de espacios de nombres <namespace "
"package>`. Ha estado roto desde Python 3.7 y Python 3.11 lo elimina "
"oficialmente."

#: ../Doc/library/unittest.rst:1956
msgid ""
"The following attributes of a :class:`TestLoader` can be configured either "
"by subclassing or assignment on an instance:"
msgstr ""
"Los siguientes atributos de un :class:`TestLoader` pueden ser configurados "
"ya sea por subclasificación o asignación en una instancia:"

#: ../Doc/library/unittest.rst:1962
msgid ""
"String giving the prefix of method names which will be interpreted as test "
"methods.  The default value is ``'test'``."
msgstr ""
"Cadena que da el prefijo de los nombres de métodos que serán interpretados "
"como métodos de test.  El valor por defecto es ``'test'``."

#: ../Doc/library/unittest.rst:1965
msgid ""
"This affects :meth:`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` "
"methods."
msgstr ""
"Esto afecta a :meth:`getTestCaseNames` y a todos los métodos :meth:"
"`loadTestsFrom\\*` ."

#: ../Doc/library/unittest.rst:1971
msgid ""
"Function to be used to compare method names when sorting them in :meth:"
"`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` methods."
msgstr ""
"Función que se utiliza para comparar los nombres de los métodos al "
"clasificarlos en :meth:`getTestCaseNames` y todos los métodos :meth:"
"`loadTestsFrom\\*`."

#: ../Doc/library/unittest.rst:1977
msgid ""
"Callable object that constructs a test suite from a list of tests. No "
"methods on the resulting object are needed.  The default value is the :class:"
"`TestSuite` class."
msgstr ""
"Objeto invocable que construye un conjunto de pruebas a partir de una lista "
"de pruebas. No se necesitan métodos en el objeto resultante.  El valor por "
"defecto es la clase :class:`TestSuite`."

#: ../Doc/library/unittest.rst:1981 ../Doc/library/unittest.rst:1994
msgid "This affects all the :meth:`loadTestsFrom\\*` methods."
msgstr "Esto afecta a todos los métodos :meth:`loadTestsFrom\\*`."

#: ../Doc/library/unittest.rst:1985
msgid ""
"List of Unix shell-style wildcard test name patterns that test methods have "
"to match to be included in test suites (see ``-v`` option)."
msgstr ""
"Lista de patrones de nombres de test de comodines al estilo del shell de "
"Unix que los métodos de test tienen que coincidir con para ser incluidos en "
"las suites de test (ver opción ``-v``)."

#: ../Doc/library/unittest.rst:1988
msgid ""
"If this attribute is not ``None`` (the default), all test methods to be "
"included in test suites must match one of the patterns in this list. Note "
"that matches are always performed using :meth:`fnmatch.fnmatchcase`, so "
"unlike patterns passed to the ``-v`` option, simple substring patterns will "
"have to be converted using ``*`` wildcards."
msgstr ""
"Si este atributo no es ``None``  (el predeterminado), todos los métodos de "
"test que se incluyan en los paquetes de test deben coincidir con uno de los "
"patrones de esta lista. Tenga en cuenta que las coincidencias se realizan "
"siempre utilizando :meth:`fnmatch.fnmatchcase`, por lo que a diferencia de "
"los patrones pasados a la opción ``-v``, los patrones de subcadena simple "
"tendrán que ser convertidos utilizando los comodines ``*``."

#: ../Doc/library/unittest.rst:2001
msgid ""
"This class is used to compile information about which tests have succeeded "
"and which have failed."
msgstr ""
"Esta clase se utiliza para recopilar información sobre qué tests han tenido "
"éxito y cuáles han fracasado."

#: ../Doc/library/unittest.rst:2004
msgid ""
"A :class:`TestResult` object stores the results of a set of tests.  The :"
"class:`TestCase` and :class:`TestSuite` classes ensure that results are "
"properly recorded; test authors do not need to worry about recording the "
"outcome of tests."
msgstr ""
"Un objeto  :class:`TestResult`  almacena los resultados de una serie de "
"pruebas.  Las clases :class:`TestCase` y :class:`TestSuite` aseguran que los "
"resultados se registren correctamente; los autores de los tests no tienen "
"que preocuparse de registrar el resultado de las mismas."

#: ../Doc/library/unittest.rst:2009
msgid ""
"Testing frameworks built on top of :mod:`unittest` may want access to the :"
"class:`TestResult` object generated by running a set of tests for reporting "
"purposes; a :class:`TestResult` instance is returned by the :meth:"
"`TestRunner.run` method for this purpose."
msgstr ""
"Los marcos de pruebas construidos sobre :mod:`unittest` pueden querer "
"acceder al objeto :class:`TestResult` generado por la ejecución de un "
"conjunto de tests con fines de reporte; una instancia :class:`TestResult` es "
"devuelta por el método :meth:`TestRunner.run` para este propósito."

#: ../Doc/library/unittest.rst:2014
msgid ""
":class:`TestResult` instances have the following attributes that will be of "
"interest when inspecting the results of running a set of tests:"
msgstr ""
"Las instancias de :class:`TestResult` tienen los siguientes atributos que "
"serán de interés cuando se inspeccionen los resultados de la ejecución de un "
"conjunto de tests:"

#: ../Doc/library/unittest.rst:2020
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test which raised an "
"unexpected exception."
msgstr ""
"Una lista que contiene 2 tuplas de instancias :class:`TestCase` y cadenas "
"con formato de tracebacks. Cada tupla representa una prueba que lanzó una "
"excepción inesperada."

#: ../Doc/library/unittest.rst:2026
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test where a failure "
"was explicitly signalled using the :meth:`TestCase.assert\\*` methods."
msgstr ""
"Una lista que contiene 2 tuplas de instancias :class:`TestCase` y cadenas "
"con formato de traceback. Cada tupla representa un test en el que un fallo "
"fue explícitamente señalado usando los métodos :meth:`TestCase.assert\\*`."

#: ../Doc/library/unittest.rst:2032
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding the reason for skipping the test."
msgstr ""
"Una lista que contiene 2 tuplas de instancias de :class:`TestCase` y cadenas "
"que contienen la razón para saltarse el test."

#: ../Doc/library/unittest.rst:2039
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks.  Each tuple represents an expected failure or "
"error of the test case."
msgstr ""
"Una lista que contiene 2 tuplas de instancias :class:`TestCase` y cadenas "
"con formato de traceback.  Cada tupla representa un fallo esperado del caso "
"de test."

#: ../Doc/library/unittest.rst:2045
msgid ""
"A list containing :class:`TestCase` instances that were marked as expected "
"failures, but succeeded."
msgstr ""
"Una lista que contiene instancias de  :class:`TestCase`  que fueron marcadas "
"como fracasos esperados, pero tuvieron éxito."

#: ../Doc/library/unittest.rst:2050
msgid ""
"Set to ``True`` when the execution of tests should stop by :meth:`stop`."
msgstr ""
"Puesto en ``True`` cuando la ejecución de los tests se detenga por :meth:"
"`stop`."

#: ../Doc/library/unittest.rst:2054
msgid "The total number of tests run so far."
msgstr "El número total de tests realizados hasta ahora."

#: ../Doc/library/unittest.rst:2058
msgid ""
"If set to true, ``sys.stdout`` and ``sys.stderr`` will be buffered in "
"between :meth:`startTest` and :meth:`stopTest` being called. Collected "
"output will only be echoed onto the real ``sys.stdout`` and ``sys.stderr`` "
"if the test fails or errors. Any output is also attached to the failure / "
"error message."
msgstr ""
"Si se ajusta a true, ``sys.stdout`` y ``sys.stderr`` serán almacenados "
"entre :meth:`startTest` y :meth:`stopTest` siendo llamados. La salida "
"recolectada sólo tendrá eco en el verdadero ``sys.stdout`` y ``sys.stderr`` "
"si la prueba falla o se equivoca. Cualquier salida también se adjunta al "
"mensaje de fallo / error."

#: ../Doc/library/unittest.rst:2067
msgid ""
"If set to true :meth:`stop` will be called on the first failure or error, "
"halting the test run."
msgstr ""
"Si se ajusta a true :meth:`stop` se llamará al primer fallo o error, "
"deteniendo la ejecución de la prueba."

#: ../Doc/library/unittest.rst:2074
msgid "If set to true then local variables will be shown in tracebacks."
msgstr ""
"Si se ajusta a true entonces las variables locales se mostrarán en los "
"tracebacks."

#: ../Doc/library/unittest.rst:2080
msgid ""
"Return ``True`` if all tests run so far have passed, otherwise returns "
"``False``."
msgstr ""
"Devuelve ``True`` si todas las pruebas realizadas hasta ahora han pasado, de "
"lo contrario devuelve ``False``."

#: ../Doc/library/unittest.rst:2083
msgid ""
"Returns ``False`` if there were any :attr:`unexpectedSuccesses` from tests "
"marked with the :func:`expectedFailure` decorator."
msgstr ""
"Devuelve ``False`` si hubo algún :attr:`unexpectedSuccesses` de las pruebas "
"marcadas con el decorador :func:`expectedFailure`."

#: ../Doc/library/unittest.rst:2089
msgid ""
"This method can be called to signal that the set of tests being run should "
"be aborted by setting the :attr:`shouldStop` attribute to ``True``. :class:"
"`TestRunner` objects should respect this flag and return without running any "
"additional tests."
msgstr ""
"Este método puede ser llamado para señalar que el conjunto de pruebas que se "
"están ejecutando debe ser abortado poniendo el atributo :attr:`shouldStop` "
"en ``True``. :class:`TestRunner` los objetos deben respetar esta bandera y "
"regresar sin ejecutar ninguna prueba adicional."

#: ../Doc/library/unittest.rst:2094
msgid ""
"For example, this feature is used by the :class:`TextTestRunner` class to "
"stop the test framework when the user signals an interrupt from the "
"keyboard.  Interactive tools which provide :class:`TestRunner` "
"implementations can use this in a similar manner."
msgstr ""
"Por ejemplo, esta característica es utilizada por la clase :class:"
"`TextTestRunner` para detener el marco de pruebas cuando el usuario señala "
"una interrupción desde el teclado.  Las herramientas interactivas que "
"proporcionan implementaciones de :class:`TestRunner` pueden usar esto de "
"manera similar."

#: ../Doc/library/unittest.rst:2099
msgid ""
"The following methods of the :class:`TestResult` class are used to maintain "
"the internal data structures, and may be extended in subclasses to support "
"additional reporting requirements.  This is particularly useful in building "
"tools which support interactive reporting while tests are being run."
msgstr ""
"Los siguientes métodos de la clase :class:`TestResult` se utilizan para "
"mantener las estructuras de datos internos, y pueden ampliarse en subclases "
"para apoyar los requisitos de información adicionales.  Esto es "
"particularmente útil para construir herramientas que apoyen la presentación "
"de informes interactivos mientras se ejecutan las pruebas."

#: ../Doc/library/unittest.rst:2107
msgid "Called when the test case *test* is about to be run."
msgstr "Llamado cuando el caso de prueba *test* está a punto de ser ejecutado."

#: ../Doc/library/unittest.rst:2111
msgid ""
"Called after the test case *test* has been executed, regardless of the "
"outcome."
msgstr ""
"Llamado después de que el caso de prueba *prueba* haya sido ejecutado, "
"independientemente del resultado."

#: ../Doc/library/unittest.rst:2116
msgid "Called once before any tests are executed."
msgstr "Llamado una vez antes de que se ejecute cualquier prueba."

#: ../Doc/library/unittest.rst:2123
msgid "Called once after all tests are executed."
msgstr "Llamado una vez después de que se ejecuten todas las pruebas."

#: ../Doc/library/unittest.rst:2130
msgid ""
"Called when the test case *test* raises an unexpected exception. *err* is a "
"tuple of the form returned by :func:`sys.exc_info`: ``(type, value, "
"traceback)``."
msgstr ""
"Llamado cuando el caso de prueba *test* plantea una excepción inesperada. "
"*err* es una tupla de la forma devuelta por :func:`sys.exc_info`: ``(type, "
"value, traceback)``."

#: ../Doc/library/unittest.rst:2134
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`errors` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"La implementación por defecto añade una tupla ``(test, formatted_err)`` al "
"atributo :attr:`errors` de la instancia, donde *formatted_err* es una traza "
"formateada derivada de *err*."

#: ../Doc/library/unittest.rst:2141
msgid ""
"Called when the test case *test* signals a failure. *err* is a tuple of the "
"form returned by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"Llamado cuando el caso de prueba *test* señala un fallo. *err* es una tupla "
"de la forma devuelta por :func:`sys.exc_info`: ``(type, value, traceback)``."

#: ../Doc/library/unittest.rst:2144
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`failures` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"La implementación por defecto añade una tupla ``(test, formatted_err)`` al "
"atributo :attr:`failures` de la instancia, donde *formatted_err* es una "
"traza formateada derivada de *err*."

#: ../Doc/library/unittest.rst:2151
msgid "Called when the test case *test* succeeds."
msgstr "Llamado cuando el caso de prueba *test* tenga éxito."

#: ../Doc/library/unittest.rst:2153
msgid "The default implementation does nothing."
msgstr "La implementación por defecto no hace nada."

#: ../Doc/library/unittest.rst:2158
msgid ""
"Called when the test case *test* is skipped.  *reason* is the reason the "
"test gave for skipping."
msgstr ""
"Llamado cuando se salta el caso de prueba *test*. *reason* es la razón que "
"la prueba dio para saltarse."

#: ../Doc/library/unittest.rst:2161
msgid ""
"The default implementation appends a tuple ``(test, reason)`` to the "
"instance's :attr:`skipped` attribute."
msgstr ""
"La implementación por defecto añade una tupla ``(test, reason)`` al "
"atributo :attr:`skipped` de la instancia."

#: ../Doc/library/unittest.rst:2167
msgid ""
"Called when the test case *test* fails or errors, but was marked with the :"
"func:`expectedFailure` decorator."
msgstr ""
"Llamó cuando el caso de prueba *test* falla, pero fue marcado con el "
"decorador :func:`expectedFailure`."

#: ../Doc/library/unittest.rst:2170
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`expectedFailures` attribute, where *formatted_err* is a "
"formatted traceback derived from *err*."
msgstr ""
"La implementación por defecto añade una tupla ``(test, formatted_err)`` al "
"atributo :attr:`expectedFailures` de la instancia, donde *formatted_err* es "
"una traza formateada derivada de *err*."

#: ../Doc/library/unittest.rst:2177
msgid ""
"Called when the test case *test* was marked with the :func:`expectedFailure` "
"decorator, but succeeded."
msgstr ""
"Llamó cuando el caso de prueba *test* se marcó con el decorador :func:"
"`expectedFailure`, pero tuvo éxito."

#: ../Doc/library/unittest.rst:2180
msgid ""
"The default implementation appends the test to the instance's :attr:"
"`unexpectedSuccesses` attribute."
msgstr ""
"La implementación por defecto añade la prueba al atributo :attr:"
"`unexpectedSuccesses` de la instancia."

#: ../Doc/library/unittest.rst:2186
msgid ""
"Called when a subtest finishes.  *test* is the test case corresponding to "
"the test method.  *subtest* is a custom :class:`TestCase` instance "
"describing the subtest."
msgstr ""
"Llamado cuando termina una subtest.  *test* es el caso de prueba "
"correspondiente al método de test.  *subtest* es una instancia "
"personalizada :class:`TestCase` que describe el test."

#: ../Doc/library/unittest.rst:2190
msgid ""
"If *outcome* is :const:`None`, the subtest succeeded.  Otherwise, it failed "
"with an exception where *outcome* is a tuple of the form returned by :func:"
"`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"Si *outcome* es :const:`None`, el subtest tuvo éxito.  De lo contrario, "
"falló con una excepción en la que *outcome* es una tupla de la forma "
"devuelta por :func:`sys.exc_info`: ``(type, value, traceback)``."

#: ../Doc/library/unittest.rst:2194
msgid ""
"The default implementation does nothing when the outcome is a success, and "
"records subtest failures as normal failures."
msgstr ""
"La implementación por defecto no hace nada cuando el resultado es un éxito, "
"y registra los fallos del subtest como fallos normales."

#: ../Doc/library/unittest.rst:2202
msgid ""
"A concrete implementation of :class:`TestResult` used by the :class:"
"`TextTestRunner`."
msgstr ""
"Una implementación concreta de :class:`TestResult` utilizado por el :class:"
"`TextTestRunner`."

#: ../Doc/library/unittest.rst:2205
msgid ""
"This class was previously named ``_TextTestResult``. The old name still "
"exists as an alias but is deprecated."
msgstr ""
"Esta clase se llamaba anteriormente  ``_TextTestResult``. El antiguo nombre "
"todavía existe como un alias pero está obsoleto."

#: ../Doc/library/unittest.rst:2212
msgid ""
"Instance of the :class:`TestLoader` class intended to be shared.  If no "
"customization of the :class:`TestLoader` is needed, this instance can be "
"used instead of repeatedly creating new instances."
msgstr ""
"Instancia de la clase :class:`TestLoader` destinada a ser compartida.  Si no "
"es necesario personalizar la clase :class:`TestLoader`, esta instancia puede "
"utilizarse en lugar de crear repetidamente nuevas instancias."

#: ../Doc/library/unittest.rst:2220
msgid ""
"A basic test runner implementation that outputs results to a stream. If "
"*stream* is ``None``, the default, :data:`sys.stderr` is used as the output "
"stream. This class has a few configurable parameters, but is essentially "
"very simple.  Graphical applications which run test suites should provide "
"alternate implementations. Such implementations should accept ``**kwargs`` "
"as the interface to construct runners changes when features are added to "
"unittest."
msgstr ""
"Una implementación básica del test runner que produce resultados en una "
"corriente. Si *stream* es ``None``, el valor por defecto, :data:`sys.stderr` "
"se utiliza como flujo de salida. Esta clase tiene unos pocos parámetros "
"configurables, pero es esencialmente muy simple.  Las aplicaciones gráficas "
"que ejecutan las suites de prueba deben proporcionar implementaciones "
"alternativas. Tales implementaciones deberían aceptar ``**kwargs`` como "
"interfaz para construir los cambios de los corredores cuando se añaden "
"características a unittest."

#: ../Doc/library/unittest.rst:2227
msgid ""
"By default this runner shows :exc:`DeprecationWarning`, :exc:"
"`PendingDeprecationWarning`, :exc:`ResourceWarning` and :exc:`ImportWarning` "
"even if they are :ref:`ignored by default <warning-ignored>`. Deprecation "
"warnings caused by :ref:`deprecated unittest methods <deprecated-aliases>` "
"are also special-cased and, when the warning filters are ``'default'`` or "
"``'always'``, they will appear only once per-module, in order to avoid too "
"many warning messages.  This behavior can be overridden using Python's :"
"option:`!-Wd` or :option:`!-Wa` options (see :ref:`Warning control <using-on-"
"warnings>`) and leaving *warnings* to ``None``."
msgstr ""
"Por defecto este runner muestra :exc:`DeprecationWarning`, :exc:"
"`PendingDeprecationWarning`, :exc:`ResourceWarning` y :exc:`ImportWarning` "
"aunque estén :ref:`ignorados por defecto <warning-ignored>`. Las "
"advertencias de deprecación causadas por :ref:`métodos deprecated unittest "
"<deprecated-aliases>` también tienen un caso especial y, cuando los filtros "
"de advertencia están ``'default'`` o ``'always'``, aparecerán sólo una vez "
"por módulo, para evitar demasiados mensajes de advertencia.  Este "
"comportamiento puede ser anulado usando las opciones :option:`!-Wd` o :"
"option:`!-Wa` de Python (ver :ref:`Control de advertencias <using-on-"
"warnings>`) y dejando *warnings* a ``None``."

#: ../Doc/library/unittest.rst:2238
msgid "Added the ``warnings`` argument."
msgstr "Añadió el argumento ``warnings``."

#: ../Doc/library/unittest.rst:2241
msgid ""
"The default stream is set to :data:`sys.stderr` at instantiation time rather "
"than import time."
msgstr ""
"El flujo por defecto está configurado como :data:`sys.stderr` en tiempo de "
"instanciación en lugar de tiempo de importación."

#: ../Doc/library/unittest.rst:2245
msgid "Added the tb_locals parameter."
msgstr "Añadido el parámetro tb_locals."

#: ../Doc/library/unittest.rst:2250
msgid ""
"This method returns the instance of ``TestResult`` used by :meth:`run`. It "
"is not intended to be called directly, but can be overridden in subclasses "
"to provide a custom ``TestResult``."
msgstr ""
"Este método devuelve la instancia de ``TestResult`` usada por :meth:`run`. "
"No está destinado a ser llamado directamente, pero puede ser anulado en "
"subclases para proporcionar un ``TestResult`` personalizado."

#: ../Doc/library/unittest.rst:2254
msgid ""
"``_makeResult()`` instantiates the class or callable passed in the "
"``TextTestRunner`` constructor as the ``resultclass`` argument. It defaults "
"to :class:`TextTestResult` if no ``resultclass`` is provided. The result "
"class is instantiated with the following arguments::"
msgstr ""
"``_makeResult()`` instanciando la clase o el pasaje llamado en el "
"constructor ``TextTestRunner`` como el argumento de ``resultclass``. Por "
"defecto es :class:`TextTestResult` si no se proporciona ninguna "
"``resultclass``. La clase de resultado se instanciará con los siguientes "
"argumentos::"

#: ../Doc/library/unittest.rst:2263
msgid ""
"This method is the main public interface to the ``TextTestRunner``. This "
"method takes a :class:`TestSuite` or :class:`TestCase` instance. A :class:"
"`TestResult` is created by calling :func:`_makeResult` and the test(s) are "
"run and the results printed to stdout."
msgstr ""
"Este método es la principal interfaz pública del ``TextTestRunner``. Este "
"método toma una instancia :class:`TestSuite` o :class:`TestCase`. Se crea "
"una :class:`TestResult` llamando a :func:`_makeResult` y se ejecuta(n) la(s) "
"prueba(s) y se imprimen los resultados a stdout."

#: ../Doc/library/unittest.rst:2274
msgid ""
"A command-line program that loads a set of tests from *module* and runs "
"them; this is primarily for making test modules conveniently executable. The "
"simplest use for this function is to include the following line at the end "
"of a test script::"
msgstr ""
"Un programa de línea de comandos que carga un conjunto de pruebas de "
"*módulo* y las ejecuta; esto es principalmente para hacer los módulos de "
"prueba convenientemente ejecutables. El uso más simple de esta función es "
"incluir la siguiente línea al final de un guión de prueba::"

#: ../Doc/library/unittest.rst:2282
msgid ""
"You can run tests with more detailed information by passing in the verbosity "
"argument::"
msgstr ""
"Puedes hacer pruebas con información más detallada pasando el argumento de "
"la verbosity::"

#: ../Doc/library/unittest.rst:2288
msgid ""
"The *defaultTest* argument is either the name of a single test or an "
"iterable of test names to run if no test names are specified via *argv*.  If "
"not specified or ``None`` and no test names are provided via *argv*, all "
"tests found in *module* are run."
msgstr ""
"El argumento *defaultTest* es el nombre de una prueba única o un iterable de "
"nombres de pruebas a ejecutar si no se especifican nombres de pruebas a "
"través de *argv*.  Si no se especifica o ``Ninguno`` y no se proporcionan "
"nombres de pruebas vía *argv*, se ejecutan todas las pruebas encontradas en "
"*modulo*."

#: ../Doc/library/unittest.rst:2293
msgid ""
"The *argv* argument can be a list of options passed to the program, with the "
"first element being the program name.  If not specified or ``None``, the "
"values of :data:`sys.argv` are used."
msgstr ""
"El argumento *argv* puede ser una lista de opciones pasadas al programa, "
"siendo el primer elemento el nombre del programa.  Si no se especifica o "
"``Ninguno``, se utilizan los valores de :data:`sys.argv`."

#: ../Doc/library/unittest.rst:2297
msgid ""
"The *testRunner* argument can either be a test runner class or an already "
"created instance of it. By default ``main`` calls :func:`sys.exit` with an "
"exit code indicating success or failure of the tests run."
msgstr ""
"El argumento *testRunner* puede ser una clase de corredor de prueba o una "
"instancia ya creada de él. Por defecto ``main`` llama :func:`sys.exit` con "
"un código de salida que indica el éxito o el fracaso de la ejecución de las "
"pruebas."

#: ../Doc/library/unittest.rst:2301
msgid ""
"The *testLoader* argument has to be a :class:`TestLoader` instance, and "
"defaults to :data:`defaultTestLoader`."
msgstr ""
"El argumento *testLoader* tiene que ser una instancia :class:`TestLoader`, y "
"por defecto :data:`defaultTestLoader`."

#: ../Doc/library/unittest.rst:2304
msgid ""
"``main`` supports being used from the interactive interpreter by passing in "
"the argument ``exit=False``. This displays the result on standard output "
"without calling :func:`sys.exit`::"
msgstr ""
"``main`` apoya el uso del intérprete interactivo pasando el argumento "
"``exit=False``. Esto muestra el resultado en la salida estándar sin llamar "
"a :func:`sys.exit`::"

#: ../Doc/library/unittest.rst:2311
msgid ""
"The *failfast*, *catchbreak* and *buffer* parameters have the same effect as "
"the same-name `command-line options`_."
msgstr ""
"Los parámetros *failfast*, *catchbreak* y *buffer* tienen el mismo efecto "
"que las `command-line options`_ del mismo nombre."

#: ../Doc/library/unittest.rst:2314
msgid ""
"The *warnings* argument specifies the :ref:`warning filter <warning-filter>` "
"that should be used while running the tests.  If it's not specified, it will "
"remain ``None`` if a :option:`!-W` option is passed to :program:`python` "
"(see :ref:`Warning control <using-on-warnings>`), otherwise it will be set "
"to ``'default'``."
msgstr ""
"El argumento *warnings* especifica el :ref:`filtro de aviso <warning-"
"filter>` que debe ser usado mientras se realizan los tests.  Si no se "
"especifica, permanecerá como ``None`` si se pasa una opción :option:`!-W` a :"
"program:`python` (ver :ref:`Warning control <using-on-warnings>`), de lo "
"contrario se establecerá como ``’default’``."

#: ../Doc/library/unittest.rst:2320
msgid ""
"Calling ``main`` actually returns an instance of the ``TestProgram`` class. "
"This stores the result of the tests run as the ``result`` attribute."
msgstr ""
"Invocar ``main`` en realidad devuelve una instancia de la clase "
"``TestProgram``. Esto almacena el resultado de las pruebas ejecutadas como "
"el atributo ``result``."

#: ../Doc/library/unittest.rst:2323
msgid "The *exit* parameter was added."
msgstr "El parámetro *exit* fue añadido."

#: ../Doc/library/unittest.rst:2326
msgid ""
"The *verbosity*, *failfast*, *catchbreak*, *buffer* and *warnings* "
"parameters were added."
msgstr ""
"Los parámetros *verbosity*, *failfast*, *catchbreak*, *buffer* y *warnings* "
"fueron añadidos."

#: ../Doc/library/unittest.rst:2330
msgid ""
"The *defaultTest* parameter was changed to also accept an iterable of test "
"names."
msgstr ""
"El parámetro *defaultTest* fue cambiado para aceptar también un iterable de "
"nombres de pruebas."

#: ../Doc/library/unittest.rst:2336
msgid "load_tests Protocol"
msgstr "load_tests protocolo"

#: ../Doc/library/unittest.rst:2340
msgid ""
"Modules or packages can customize how tests are loaded from them during "
"normal test runs or test discovery by implementing a function called "
"``load_tests``."
msgstr ""
"Los módulos o paquetes pueden personalizar la forma en que se cargan las "
"pruebas a partir de ellos durante las ejecuciones de prueba normales o el "
"descubrimiento de pruebas mediante la implementación de una función llamada "
"``load_tests``."

#: ../Doc/library/unittest.rst:2343
msgid ""
"If a test module defines ``load_tests`` it will be called by :meth:"
"`TestLoader.loadTestsFromModule` with the following arguments::"
msgstr ""
"Si un módulo de tests define ``load_tests`` será llamado por :meth:"
"`TestLoader.loadTestsFromModule` con los siguientes argumentos::"

#: ../Doc/library/unittest.rst:2348
msgid ""
"where *pattern* is passed straight through from ``loadTestsFromModule``.  It "
"defaults to ``None``."
msgstr ""
"donde *pattern* se pasa directamente desde ``loadTestsFromModule``.  Por "
"defecto es ``None``."

#: ../Doc/library/unittest.rst:2351
msgid "It should return a :class:`TestSuite`."
msgstr "Debe retornar una :class:`TestSuite`."

#: ../Doc/library/unittest.rst:2353
msgid ""
"*loader* is the instance of :class:`TestLoader` doing the loading. "
"*standard_tests* are the tests that would be loaded by default from the "
"module. It is common for test modules to only want to add or remove tests "
"from the standard set of tests. The third argument is used when loading "
"packages as part of test discovery."
msgstr ""
"*loader* es la instancia de :class:`TestLoader` haciendo la carga. "
"*standard_tests* son los tests que se cargarían por defecto desde el módulo. "
"Es común que los módulos de test sólo quieran añadir o quitar tests del "
"conjunto de tests estándar. El tercer argumento se usa cuando se cargan "
"paquetes como parte del descubrimiento de tests."

#: ../Doc/library/unittest.rst:2359
msgid ""
"A typical ``load_tests`` function that loads tests from a specific set of :"
"class:`TestCase` classes may look like::"
msgstr ""
"Una típica función de ``load_tests`` que carga pruebas de un conjunto "
"específico de :class:`TestCase`class:`TestCase` puede ser como::"

#: ../Doc/library/unittest.rst:2371
msgid ""
"If discovery is started in a directory containing a package, either from the "
"command line or by calling :meth:`TestLoader.discover`, then the package :"
"file:`__init__.py` will be checked for ``load_tests``.  If that function "
"does not exist, discovery will recurse into the package as though it were "
"just another directory.  Otherwise, discovery of the package's tests will be "
"left up to ``load_tests`` which is called with the following arguments::"
msgstr ""
"Si discovery se inicia en un directorio que contiene un paquete, ya sea "
"desde la línea de comandos o llamando a :meth:`TestLoader.discover`, "
"entonces el paquete :file:`__init__.py` se comprobará por ``load_tests``.  "
"Si esa función no existe, discover se reincorporará al paquete como si fuera "
"un directorio más.  De lo contrario, el descubrimiento de los tests del "
"paquete se dejará en ``load_tests`` que se llama con los siguientes "
"argumentos::"

#: ../Doc/library/unittest.rst:2380
msgid ""
"This should return a :class:`TestSuite` representing all the tests from the "
"package. (``standard_tests`` will only contain tests collected from :file:"
"`__init__.py`.)"
msgstr ""
"Esto debería devolver un :class:`TestSuite` que represente todas las pruebas "
"del paquete. (``test_estándar`` sólo contendrá las pruebas recogidas de :"
"file:`__init__.py`.)"

#: ../Doc/library/unittest.rst:2384
msgid ""
"Because the pattern is passed into ``load_tests`` the package is free to "
"continue (and potentially modify) test discovery. A 'do nothing' "
"``load_tests`` function for a test package would look like::"
msgstr ""
"Debido a que el patrón se pasa a ``load_tests`` el paquete es libre de "
"continuar (y potencialmente modificar) el descubrimiento de pruebas. Una "
"función de 'no hace nada' ``load_test`` para un paquete de pruebas se vería "
"como::"

#: ../Doc/library/unittest.rst:2395
msgid ""
"Discovery no longer checks package names for matching *pattern* due to the "
"impossibility of package names matching the default pattern."
msgstr ""
"Discovery ya no comprueba si los nombres de los paquetes coinciden con el "
"*patrón* debido a la imposibilidad de que los nombres de los paquetes "
"coincidan con el patrón por defecto."

#: ../Doc/library/unittest.rst:2402
msgid "Class and Module Fixtures"
msgstr "Instalaciones para clases y módulos"

#: ../Doc/library/unittest.rst:2404
msgid ""
"Class and module level fixtures are implemented in :class:`TestSuite`. When "
"the test suite encounters a test from a new class then :meth:`tearDownClass` "
"from the previous class (if there is one) is called, followed by :meth:"
"`setUpClass` from the new class."
msgstr ""
"Los accesorios de nivel de clase y módulo se implementan en :class:"
"`TestSuite`. Cuando el conjunto de pruebas se encuentra con una prueba de "
"una nueva clase entonces se llama :meth:`tearDownClass` de la clase anterior "
"(si existe), seguido de :meth:`setUpClass` de la nueva clase."

#: ../Doc/library/unittest.rst:2409
msgid ""
"Similarly if a test is from a different module from the previous test then "
"``tearDownModule`` from the previous module is run, followed by "
"``setUpModule`` from the new module."
msgstr ""
"Del mismo modo, si una prueba es de un módulo diferente de la prueba "
"anterior, entonces se ejecuta ``DesmontarMódulo`` del módulo anterior, "
"seguido de ``DesmontarMódulo`` del nuevo módulo."

#: ../Doc/library/unittest.rst:2413
msgid ""
"After all the tests have run the final ``tearDownClass`` and "
"``tearDownModule`` are run."
msgstr ""
"Después de todas las pruebas, se ejecutan los últimos ``tearDownClass`` y "
"``tearDownModule``."

#: ../Doc/library/unittest.rst:2416
msgid ""
"Note that shared fixtures do not play well with [potential] features like "
"test parallelization and they break test isolation. They should be used with "
"care."
msgstr ""
"Tenga en cuenta que los accesorios compartidos no juegan bien con las "
"características [potenciales] como la paralelización de la prueba y rompen "
"el aislamiento de la prueba. Deben ser usados con cuidado."

#: ../Doc/library/unittest.rst:2419
msgid ""
"The default ordering of tests created by the unittest test loaders is to "
"group all tests from the same modules and classes together. This will lead "
"to ``setUpClass`` / ``setUpModule`` (etc) being called exactly once per "
"class and module. If you randomize the order, so that tests from different "
"modules and classes are adjacent to each other, then these shared fixture "
"functions may be called multiple times in a single test run."
msgstr ""
"El orden por defecto de las pruebas creadas por los cargadores de pruebas "
"unitarias es agrupar todas las pruebas de los mismos módulos y clases. Esto "
"llevará a que ``setUpClass`` / ``setUpModule`` (etc) sea llamado exactamente "
"una vez por clase y módulo. Si se aleatoriza el orden, de manera que las "
"pruebas de diferentes módulos y clases sean adyacentes entre sí, entonces "
"estas funciones compartidas de fixture pueden ser llamadas varias veces en "
"una sola ejecución de prueba."

#: ../Doc/library/unittest.rst:2426
msgid ""
"Shared fixtures are not intended to work with suites with non-standard "
"ordering. A ``BaseTestSuite`` still exists for frameworks that don't want to "
"support shared fixtures."
msgstr ""
"Los accesorios compartidos no están pensados para trabajar con suites con "
"pedidos no estándar. Todavía existe una ``BaseTestSuite`` para los marcos de "
"trabajo que no quieren soportar accesorios compartidos."

#: ../Doc/library/unittest.rst:2430
msgid ""
"If there are any exceptions raised during one of the shared fixture "
"functions the test is reported as an error. Because there is no "
"corresponding test instance an ``_ErrorHolder`` object (that has the same "
"interface as a :class:`TestCase`) is created to represent the error. If you "
"are just using the standard unittest test runner then this detail doesn't "
"matter, but if you are a framework author it may be relevant."
msgstr ""
"Si hay alguna excepción planteada durante una de las funciones compartidas "
"del aparato, la prueba se notifica como un error. Debido a que no hay una "
"instancia de prueba correspondiente, se crea un objeto ``_ErrorHolder`` (que "
"tiene la misma interfaz que un :class:`TestCase`) para representar el error. "
"Si sólo estás usando el standard unittest test runner entonces este detalle "
"no importa, pero si eres un autor de marcos de trabajo puede ser relevante."

#: ../Doc/library/unittest.rst:2439
msgid "setUpClass and tearDownClass"
msgstr "setUpClass y tearDownClass"

#: ../Doc/library/unittest.rst:2441
msgid "These must be implemented as class methods::"
msgstr "Estos deben ser implementados como métodos de clase::"

#: ../Doc/library/unittest.rst:2454
msgid ""
"If you want the ``setUpClass`` and ``tearDownClass`` on base classes called "
"then you must call up to them yourself. The implementations in :class:"
"`TestCase` are empty."
msgstr ""
"Si quieres que se invoque a ``SetUpClass`` y ``BreakdownClass`` en clases "
"base, debes llamarlos tú mismo. Las implementaciones en  :class:`TestCase`  "
"están vacías."

#: ../Doc/library/unittest.rst:2458
msgid ""
"If an exception is raised during a ``setUpClass`` then the tests in the "
"class are not run and the ``tearDownClass`` is not run. Skipped classes will "
"not have ``setUpClass`` or ``tearDownClass`` run. If the exception is a :exc:"
"`SkipTest` exception then the class will be reported as having been skipped "
"instead of as an error."
msgstr ""
"Si se lanza una excepción durante una ``setUpClass``, entonces los tests de "
"la clase no se ejecutan y la ``tearDownClass`` no se ejecuta. Las clases que "
"se salten no tendrán ``setUpClass`` o ``tearDownClass``. Si la excepción es "
"una :exc:`SkipTest`  entonces la clase será reportada como salteada en lugar "
"de como un error."

#: ../Doc/library/unittest.rst:2466
msgid "setUpModule and tearDownModule"
msgstr "setUpModule y tearDownModule"

#: ../Doc/library/unittest.rst:2468
msgid "These should be implemented as functions::"
msgstr "Estos deben ser implementados como funciones::"

#: ../Doc/library/unittest.rst:2476
msgid ""
"If an exception is raised in a ``setUpModule`` then none of the tests in the "
"module will be run and the ``tearDownModule`` will not be run. If the "
"exception is a :exc:`SkipTest` exception then the module will be reported as "
"having been skipped instead of as an error."
msgstr ""
"Si se lanza una excepción en un  ``setUpModule``, entonces no se ejecutará "
"ninguna de las pruebas del módulo y no se ejecutará el ``tearDownModule``. "
"Si la excepción es una :exc:`SkipTest`   entonces el módulo será reportado "
"como saltado en lugar de como un error."

#: ../Doc/library/unittest.rst:2481
msgid ""
"To add cleanup code that must be run even in the case of an exception, use "
"``addModuleCleanup``:"
msgstr ""
"Para agregar código de limpieza que se debe ejecutar incluso en el caso de "
"una excepción, utilice ``addModuleCleanup``::"

#: ../Doc/library/unittest.rst:2487
msgid ""
"Add a function to be called after :func:`tearDownModule` to cleanup "
"resources used during the test class. Functions will be called in reverse "
"order to the order they are added (:abbr:`LIFO (last-in, first-out)`). They "
"are called with any arguments and keyword arguments passed into :meth:"
"`addModuleCleanup` when they are added."
msgstr ""
"Añade una función que se llamará después de :func:`tearDownModule` para "
"limpiar los recursos utilizados durante la clase de test. Las funciones se "
"llamarán en orden inverso al orden en que se agregan (:abbr:`LIFO (last-in, "
"first-out)`). Se llaman con cualquier argumento y palabra clave que se pase "
"a :meth:`addModuleCleanup` cuando se añadan."

#: ../Doc/library/unittest.rst:2493
msgid ""
"If :meth:`setUpModule` fails, meaning that :func:`tearDownModule` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"Si :meth:`setUpModule` falla, lo que significa que :func:`tearDownModule` no "
"se invoca, entonces cualquier función de limpieza añadida seguirá siendo "
"invocada."

#: ../Doc/library/unittest.rst:2501
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :func:"
"`addModuleCleanup` and return the result of the :meth:`~object.__enter__` "
"method."
msgstr ""
"Introduce el :term:`context manager` suministrado. Si es exitoso, añade "
"también su método :meth:`~object.__exit__` como función de limpieza "
"mediante :func:`addModuleCleanup` y retorna el resultado del método :meth:"
"`~object.__enter__`."

#: ../Doc/library/unittest.rst:2511
msgid ""
"This function is called unconditionally after :func:`tearDownModule`, or "
"after :func:`setUpModule` if :func:`setUpModule` raises an exception."
msgstr ""
"Esta función se llama incondicionalmente después de :func:`tearDownModule`, "
"o después de :func:`setUpModule` si :func:`setUpModule` lanza una excepción."

#: ../Doc/library/unittest.rst:2514
msgid ""
"It is responsible for calling all the cleanup functions added by :func:"
"`addModuleCleanup`. If you need cleanup functions to be called *prior* to :"
"func:`tearDownModule` then you can call :func:`doModuleCleanups` yourself."
msgstr ""
"Es responsable de invocar a todas las funciones de limpieza añadidas por :"
"func:`addCleanupModule`. Si necesitas que las funciones de limpieza se "
"llamen *previamente* a :func:`tearDownModule` entonces puedes invocar a :"
"func:`doModuleCleanups` tú mismo."

#: ../Doc/library/unittest.rst:2519
msgid ""
":func:`doModuleCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ""
":func:`doModuleCleanups` saca los métodos de la pila de funciones de "
"limpieza uno a uno, así que se puede llamar en cualquier momento."

#: ../Doc/library/unittest.rst:2526
msgid "Signal Handling"
msgstr "Manejo de señales"

#: ../Doc/library/unittest.rst:2530
msgid ""
"The :option:`-c/--catch <unittest -c>` command-line option to unittest, "
"along with the ``catchbreak`` parameter to :func:`unittest.main()`, provide "
"more friendly handling of control-C during a test run. With catch break "
"behavior enabled control-C will allow the currently running test to "
"complete, and the test run will then end and report all the results so far. "
"A second control-c will raise a :exc:`KeyboardInterrupt` in the usual way."
msgstr ""
"La opción :option:`-c/--catch <unittest -c>` línea de comando para unittest, "
"junto con el parámetro ``catchbreak`` de :func:`unittest.main()`, "
"proporcionan un manejo más amigable del control-C durante una prueba. Con el "
"comportamiento catch break habilitado, control-C permitirá que se complete "
"la prueba que se está ejecutando actualmente, y la ejecución de la prueba "
"terminará y reportará todos los resultados hasta ahora. Un segundo control-C "
"lanzará una :exc:`KeyboardInterrupt` de la manera habitual."

#: ../Doc/library/unittest.rst:2537
msgid ""
"The control-c handling signal handler attempts to remain compatible with "
"code or tests that install their own :const:`signal.SIGINT` handler. If the "
"``unittest`` handler is called but *isn't* the installed :const:`signal."
"SIGINT` handler, i.e. it has been replaced by the system under test and "
"delegated to, then it calls the default handler. This will normally be the "
"expected behavior by code that replaces an installed handler and delegates "
"to it. For individual tests that need ``unittest`` control-c handling "
"disabled the :func:`removeHandler` decorator can be used."
msgstr ""
"El manejador de señales de manejo de control-c intenta permanecer compatible "
"con el código o las pruebas que instalan su propio manejador :const:`signal."
"SIGINT` . Si se llama al manejador ``unittest`` pero *no es* el manejador :"
"const:`signal.SIGINT` instalado, es decir, ha sido reemplazado por el "
"sistema bajo test y delegado, entonces llama al manejador por defecto. Este "
"será normalmente el comportamiento esperado por el código que reemplaza un "
"manejador instalado y delega en él. Para las pruebas individuales que "
"necesiten el manejo de control-c de ``unittest`` deshabilitado se puede usar "
"el decorador :func:`removeHandler`."

#: ../Doc/library/unittest.rst:2546
msgid ""
"There are a few utility functions for framework authors to enable control-c "
"handling functionality within test frameworks."
msgstr ""
"Hay algunas funciones de utilidad para que los autores de marcos de trabajo "
"habiliten la funcionalidad de control de control-c dentro de los marcos de "
"prueba."

#: ../Doc/library/unittest.rst:2551
msgid ""
"Install the control-c handler. When a :const:`signal.SIGINT` is received "
"(usually in response to the user pressing control-c) all registered results "
"have :meth:`~TestResult.stop` called."
msgstr ""
"Instala el controlador de control-c. Cuando se recibe una :const:`signal."
"SIGINT`  (normalmente en respuesta a que el usuario presione control-c) "
"todos los resultados registrados tienen :meth:`~TestResult.stop` llamado."

#: ../Doc/library/unittest.rst:2558
msgid ""
"Register a :class:`TestResult` object for control-c handling. Registering a "
"result stores a weak reference to it, so it doesn't prevent the result from "
"being garbage collected."
msgstr ""
"Registrar un objeto  :class:`TestResult`  para el manejo de control-c. El "
"registro de un resultado almacena una referencia débil a él, por lo que no "
"evita que el resultado sea recogido por el recolector de basura."

#: ../Doc/library/unittest.rst:2562
msgid ""
"Registering a :class:`TestResult` object has no side-effects if control-c "
"handling is not enabled, so test frameworks can unconditionally register all "
"results they create independently of whether or not handling is enabled."
msgstr ""
"El registro de un objeto :class:`TestResult` no tiene efectos secundarios si "
"el manejo de control-c no está habilitado, por lo que los marcos de pruebas "
"pueden registrar incondicionalmente todos los resultados que crean "
"independientemente de si el manejo está habilitado o no."

#: ../Doc/library/unittest.rst:2569
msgid ""
"Remove a registered result. Once a result has been removed then :meth:"
"`~TestResult.stop` will no longer be called on that result object in "
"response to a control-c."
msgstr ""
"Elimine un resultado registrado. Una vez que un resultado ha sido "
"eliminado, :meth:`~TestResult.stop` ya no se llamará en ese objeto de "
"resultado en respuesta a un control-c."

#: ../Doc/library/unittest.rst:2576
msgid ""
"When called without arguments this function removes the control-c handler if "
"it has been installed. This function can also be used as a test decorator to "
"temporarily remove the handler while the test is being executed::"
msgstr ""
"Cuando se llama sin argumentos, esta función quita el gestor control-c si se "
"ha instalado. Esta función también se puede utilizar como decorador de tests "
"para quitar temporalmente el controlador mientras se ejecuta el test::"
