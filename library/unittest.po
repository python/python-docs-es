# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/PyCampES/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
# Translation started and completed partially by:
# Marcos Sánchez Provencio <raptopassion@gmail.com>, 2020.
# Translation finished by:
# Claudia Millán (clacri), 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-05 12:54+0200\n"
"PO-Revision-Date: 2020-09-06 12:06+0200\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: Claudia Millán (@clacri)\n"
"Language: es\n"
"X-Generator: Poedit 2.3.1\n"

#: ../Doc/library/unittest.rst:2
msgid ":mod:`unittest` --- Unit testing framework"
msgstr ":mod:`unittest` --- Infraestructura de tests unitarios"

#: ../Doc/library/unittest.rst:12
msgid "**Source code:** :source:`Lib/unittest/__init__.py`"
msgstr "**Código fuente:** :source:`Lib/unittest/__init__.py`"

#: ../Doc/library/unittest.rst:16
msgid ""
"(If you are already familiar with the basic concepts of testing, you might "
"want to skip to :ref:`the list of assert methods <assert-methods>`.)"
msgstr ""
"(Si ya estás familiarizado con los conceptos básicos de realización de "
"pruebas, puedes saltar a  :ref:`la lista de métodos de aserción <assert-"
"methods>`.)"

#: ../Doc/library/unittest.rst:19
msgid ""
"The :mod:`unittest` unit testing framework was originally inspired by JUnit "
"and has a similar flavor as major unit testing frameworks in other "
"languages.  It supports test automation, sharing of setup and shutdown code "
"for tests, aggregation of tests into collections, and independence of the "
"tests from the reporting framework."
msgstr ""
"La infraestructura de pruebas unitarias :mod:`unittest` se inspiró en "
"primera instancia en JUnit y ofrece aspectos similares a las principales "
"estructuras de pruebas unitarias más importantes de otros lenguajes.  Da "
"soporte a automatización de pruebas, inicialización compartida, código de "
"cierre de las pruebas, agregación de las pruebas en colecciones e "
"independencia de los tests de la infraestructura que los reporta."

#: ../Doc/library/unittest.rst:25
msgid ""
"To achieve this, :mod:`unittest` supports some important concepts in an "
"object-oriented way:"
msgstr ""
"Para conseguir esto, :mod:`unittest` da soporte a ciertos conceptos "
"importantes de una forma orientada a objetos:"

#: ../Doc/library/unittest.rst:32
msgid "test fixture"
msgstr "configuración de prueba (*fixture*)"

#: ../Doc/library/unittest.rst:29
msgid ""
"A :dfn:`test fixture` represents the preparation needed to perform one or "
"more tests, and any associated cleanup actions.  This may involve, for "
"example, creating temporary or proxy databases, directories, or starting a "
"server process."
msgstr ""
"Un :dfn:`test fixture` representa los preparativos para realizar una o más "
"pruebas y las acciones de limpieza asociadas. Esto puede incluir, por "
"ejemplo, la creación de bases de datos temporales, directorios o el arranque "
"de procesos del servidor."

#: ../Doc/library/unittest.rst:37
msgid "test case"
msgstr "caso de prueba"

#: ../Doc/library/unittest.rst:35
msgid ""
"A :dfn:`test case` is the individual unit of testing.  It checks for a "
"specific response to a particular set of inputs.  :mod:`unittest` provides a "
"base class, :class:`TestCase`, which may be used to create new test cases."
msgstr ""
"Un :dfn:`test case` es la unidad mínima de prueba. Verifica la respuesta "
"específica a un juego particular de entradas. :mod:`unittest` proporciona "
"una clase base, :class:`TestCase`, que se puede utilizar para crear nuevos "
"casos de uso."

#: ../Doc/library/unittest.rst:41
msgid "test suite"
msgstr "conjunto de pruebas"

#: ../Doc/library/unittest.rst:40
msgid ""
"A :dfn:`test suite` is a collection of test cases, test suites, or both.  It "
"is used to aggregate tests that should be executed together."
msgstr ""
"Un :dfn:`test suite` es una colección de casos de prueba, juegos de prueba o "
"ambos. Se usa para agrupar pruebas que se han de ejecutar juntas."

#: ../Doc/library/unittest.rst:48
msgid "test runner"
msgstr "ejecutor de pruebas"

#: ../Doc/library/unittest.rst:44
msgid ""
"A :dfn:`test runner` is a component which orchestrates the execution of "
"tests and provides the outcome to the user.  The runner may use a graphical "
"interface, a textual interface, or return a special value to indicate the "
"results of executing the tests."
msgstr ""
"Un :dfn:`test runner` es un componente que dirige la ejecución de las "
"pruebas y proporciona un resultado. El ejecutor puede disponer de una "
"interfaz gráfica, de texto o devolver un valor especial que indique el "
"resultado de la ejecución de las pruebas."

#: ../Doc/library/unittest.rst:53
msgid "Module :mod:`doctest`"
msgstr "Módulo :mod:`doctest`"

#: ../Doc/library/unittest.rst:53
msgid "Another test-support module with a very different flavor."
msgstr "Otro módulo de soporte a pruebas con una solución muy diferente."

#: ../Doc/library/unittest.rst:57
msgid ""
"`Simple Smalltalk Testing: With Patterns <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"
msgstr ""
"`Simple Smalltalk Testing: With Patterns <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"

#: ../Doc/library/unittest.rst:56
msgid ""
"Kent Beck's original paper on testing frameworks using the pattern shared "
"by :mod:`unittest`."
msgstr ""
"El documento original de Kent Beck sobre infraestructuras de prueba mediante "
"el patrón que utiliza :mod:`unittest`."

#: ../Doc/library/unittest.rst:61
msgid "`pytest <https://docs.pytest.org/>`_"
msgstr "`pytest <https://docs.pytest.org/>`_"

#: ../Doc/library/unittest.rst:60
msgid ""
"Third-party unittest framework with a lighter-weight syntax for writing "
"tests.  For example, ``assert func(10) == 42``."
msgstr ""
"Una infraestructura de pruebas unitarias de otro proveedor con una sintaxis "
"más ligera de escritura de pruebas, por ejemplo: ``assert func(10) == 42``."

#: ../Doc/library/unittest.rst:65
msgid ""
"`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"
msgstr ""
"`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"

#: ../Doc/library/unittest.rst:64
msgid ""
"An extensive list of Python testing tools including functional testing "
"frameworks and mock object libraries."
msgstr ""
"Una lista extensa de herramientas de prueba para Python. incluyendo "
"infraestructuras de pruebas funcionales y librerías de objetos sucedáneos."

#: ../Doc/library/unittest.rst:69
msgid ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"
msgstr ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"

#: ../Doc/library/unittest.rst:68
msgid ""
"A special-interest-group for discussion of testing, and testing tools, in "
"Python."
msgstr ""
"Grupo especializado en debate sobre las pruebas y las herramientas de prueba "
"de Python."

#: ../Doc/library/unittest.rst:71
msgid ""
"The script :file:`Tools/unittestgui/unittestgui.py` in the Python source "
"distribution is a GUI tool for test discovery and execution.  This is "
"intended largely for ease of use for those new to unit testing.  For "
"production environments it is recommended that tests be driven by a "
"continuous integration system such as `Buildbot <https://buildbot.net/>`_, "
"`Jenkins <https://jenkins.io/>`_ or  `Hudson <http://hudson-ci.org/>`_."
msgstr ""
"El script :file:`Tools/unittestgui/unittestgui.py` de la distribución de "
"fuentes de Python es una herramienta gráfica para el descubrimiento y "
"ejecución de pruebas. Está orientado sobre todo a principiantes en el tema "
"de pruebas. Para entornos de producción se recomienda que las pruebas sean "
"dirigidas por un sistema de integración continua como `Buildbot <https://"
"buildbot.net/>`_, `Jenkins <https://jenkins.io/>`_ o  `Hudson <http://hudson-"
"ci.org/>`_."

#: ../Doc/library/unittest.rst:82
msgid "Basic example"
msgstr "Ejemplo sencillo"

#: ../Doc/library/unittest.rst:84
msgid ""
"The :mod:`unittest` module provides a rich set of tools for constructing and "
"running tests.  This section demonstrates that a small subset of the tools "
"suffice to meet the needs of most users."
msgstr ""
"El módulo :mod:`unittest` proporciona una panoplia de herramientas para "
"construir y ejecutar pruebas. Esta sección demuestra que un pequeño "
"subconjunto de las herramientas es suficiente para satisfacer las "
"necesidades de la mayoría."

#: ../Doc/library/unittest.rst:88
msgid "Here is a short script to test three string methods::"
msgstr "He aquí un breve script para probar estros tres métodos de cadena::"

#: ../Doc/library/unittest.rst:112
msgid ""
"A testcase is created by subclassing :class:`unittest.TestCase`.  The three "
"individual tests are defined with methods whose names start with the letters "
"``test``.  This naming convention informs the test runner about which "
"methods represent tests."
msgstr ""
"Para crear un caso de prueba se genera una subclase de :class:`unittest."
"TestCase`. Las tres pruebas se definen con métodos cuyos nombres comienzan "
"por las letras ``test``. Esta convención sobre nombres indica al ejecutor de "
"pruebas qué métodos representan pruebas."

#: ../Doc/library/unittest.rst:117
msgid ""
"The crux of each test is a call to :meth:`~TestCase.assertEqual` to check "
"for an expected result; :meth:`~TestCase.assertTrue` or :meth:`~TestCase."
"assertFalse` to verify a condition; or :meth:`~TestCase.assertRaises` to "
"verify that a specific exception gets raised.  These methods are used "
"instead of the :keyword:`assert` statement so the test runner can accumulate "
"all test results and produce a report."
msgstr ""
"El quid de cada test es la llamada a  :meth:`~TestCase.assertEqual` para "
"verificar un resultado esperado; :meth:`~TestCase.assertTrue` o :meth:"
"`~TestCase.assertFalse` para verificar una condición; o :meth:`~TestCase."
"assertRaises` para asegurar que se lanza una excepción específica. Se "
"utilizan estos métodos en lugar de la sentencia :keyword:`assert` para que "
"el ejecutor de pruebas pueda acumular todos los resultados de la prueba de "
"cara a realizar un informe."

#: ../Doc/library/unittest.rst:124
msgid ""
"The :meth:`~TestCase.setUp` and :meth:`~TestCase.tearDown` methods allow you "
"to define instructions that will be executed before and after each test "
"method. They are covered in more detail in the section :ref:`organizing-"
"tests`."
msgstr ""
"Los métodos :meth:`~TestCase.setUp` y :meth:`~TestCase.tearDown` permiten "
"definir instrucciones que han de ser ejecutadas antes y después, "
"respectivamente, de cada método de prueba. Se describen con mas detalle en "
"la sección :ref:`organizing-tests`."

#: ../Doc/library/unittest.rst:128
msgid ""
"The final block shows a simple way to run the tests. :func:`unittest.main` "
"provides a command-line interface to the test script.  When run from the "
"command line, the above script produces an output that looks like this::"
msgstr ""
"El bloque final muestra un modo sencillo de ejecutar las pruebas. :func:"
"`unittest.main` proporciona una interfaz de línea de órdenes para el script "
"de prueba. Cuando se ejecuta desde la línea de órdenes, el script anterior "
"produce una salida como::"

#: ../Doc/library/unittest.rst:138
msgid ""
"Passing the ``-v`` option to your test script will instruct :func:`unittest."
"main` to enable a higher level of verbosity, and produce the following "
"output::"
msgstr ""
"Si se le pasa una opción ``-v`` al script de prueba, se establecerá un nivel "
"mayor de detalle del proceso de :func:`unittest.main` y se obtendrá la "
"siguiente salida::"

#: ../Doc/library/unittest.rst:150
msgid ""
"The above examples show the most commonly used :mod:`unittest` features "
"which are sufficient to meet many everyday testing needs.  The remainder of "
"the documentation explores the full feature set from first principles."
msgstr ""
"Los ejemplos anteriores muestra las características más usuales de :mod:"
"`unittest`, que son suficientes para solventar las necesidades cotidianas de "
"pruebas. El resto de la documentación explora el juego completo de "
"características, que abundan en los mismos principios."

#: ../Doc/library/unittest.rst:158
msgid "Command-Line Interface"
msgstr "Interfaz de línea de comandos"

#: ../Doc/library/unittest.rst:160
msgid ""
"The unittest module can be used from the command line to run tests from "
"modules, classes or even individual test methods::"
msgstr ""
"Se puede usar el módulo `unittest` desde la línea de órdenes para ejecutar "
"pruebas de módulos, clases o hasta métodos de prueba individuales::"

#: ../Doc/library/unittest.rst:167
msgid ""
"You can pass in a list with any combination of module names, and fully "
"qualified class or method names."
msgstr ""
"Se puede pasar una lista con cualquier combinación de nombres de módulo, así "
"como clases o métodos completamente cualificados."

#: ../Doc/library/unittest.rst:170
msgid "Test modules can be specified by file path as well::"
msgstr ""
"Se puede especificar los módulos de prueba por ruta de fichero también::"

#: ../Doc/library/unittest.rst:174
msgid ""
"This allows you to use the shell filename completion to specify the test "
"module. The file specified must still be importable as a module. The path is "
"converted to a module name by removing the '.py' and converting path "
"separators into '.'. If you want to execute a test file that isn't "
"importable as a module you should execute the file directly instead."
msgstr ""
"Esto permite usar el completado automático de nombre de fichero de la shell "
"para especificar el módulo de pruebas. El fichero especificado aún debe ser "
"susceptible de importarse como módulo. La ruta se convierte en nombre de "
"módulo eliminando '.py' y convirtiendo el separador de directorios por '.'. "
"Si se desea ejecutar un fichero de prueba que no se puede importar como "
"módulo, se ha de ejecutar el fichero directamente."

#: ../Doc/library/unittest.rst:180
msgid ""
"You can run tests with more detail (higher verbosity) by passing in the -v "
"flag::"
msgstr ""
"Se pueden ejecutar las pruebas con más nivel de detalle (mayor verbosidad) "
"pasando el indicador  `-v`::"

#: ../Doc/library/unittest.rst:184
msgid ""
"When executed without arguments :ref:`unittest-test-discovery` is started::"
msgstr ""
"Cuando se ejecuta sin argumentos, se inicia :ref:`unittest-test-discovery`::"

#: ../Doc/library/unittest.rst:188
msgid "For a list of all the command-line options::"
msgstr "Para obtener una lista de todas las opciones de línea de órdenes::"

#: ../Doc/library/unittest.rst:192
msgid ""
"In earlier versions it was only possible to run individual test methods and "
"not modules or classes."
msgstr ""
"En versiones anteriores sólo era posible ejecutar métodos de prueba "
"individuales, pero no módulos ni clases."

#: ../Doc/library/unittest.rst:198
msgid "Command-line options"
msgstr "Opciones de la línea de órdenes"

#: ../Doc/library/unittest.rst:200
msgid ":program:`unittest` supports these command-line options:"
msgstr ""
":program:`unittest` da soporte a las siguientes opciones de línea de órdenes:"

#: ../Doc/library/unittest.rst:206
msgid ""
"The standard output and standard error streams are buffered during the test "
"run. Output during a passing test is discarded. Output is echoed normally on "
"test fail or error and is added to the failure messages."
msgstr ""
"Los flujos de datos de salida estándar y error estándar se acumulan en un "
"búfer durante la ejecución de pruebas. La salida de las pruebas correctas se "
"descarta. La salida de las pruebas que fallan o devuelven un error se añade "
"a los mensajes de fallo."

#: ../Doc/library/unittest.rst:212
msgid ""
":kbd:`Control-C` during the test run waits for the current test to end and "
"then reports all the results so far. A second :kbd:`Control-C` raises the "
"normal :exc:`KeyboardInterrupt` exception."
msgstr ""
"La pulsación de :kbd:`Control-C` durante la ejecución de pruebas espera a "
"que termine la prueba en curso y da un informe de los resultados hasta ese "
"momento. Una segunda pulsación de :kbd:`Control-C` lanza la excepción :exc:"
"`KeyboardInterrupt` usual."

#: ../Doc/library/unittest.rst:216
msgid ""
"See `Signal Handling`_ for the functions that provide this functionality."
msgstr ""
"Consultar  en `Gestión de señales`_ las funciones que proporcionan esta "
"funcionalidad."

#: ../Doc/library/unittest.rst:220
msgid "Stop the test run on the first error or failure."
msgstr "Finaliza la ejecución tras el primer error o fallo."

#: ../Doc/library/unittest.rst:224
msgid ""
"Only run test methods and classes that match the pattern or substring. This "
"option may be used multiple times, in which case all test cases that match "
"of the given patterns are included."
msgstr ""
"Ejecutar solamente los métodos y clases de prueba que coincidan con el "
"patrón o subcadena. Esta opción se puede usar más de una vez, en cuyo caso "
"se incluirán todos los casos de prueba que coincidan con cualquiera de los "
"patrones dados."

#: ../Doc/library/unittest.rst:228
msgid ""
"Patterns that contain a wildcard character (``*``) are matched against the "
"test name using :meth:`fnmatch.fnmatchcase`; otherwise simple case-sensitive "
"substring matching is used."
msgstr ""
"Los patrones que contengan un comodín (``*``) se comprueban contra el nombre "
"de la prueba usando :meth:`fnmatch.fnmatchcase`; si no lo contienen, se usa "
"una comprobación de contenido simple sensible a mayúsculas."

#: ../Doc/library/unittest.rst:232
msgid ""
"Patterns are matched against the fully qualified test method name as "
"imported by the test loader."
msgstr ""
"Los patrones se comprueban contra el nombre del método completamente "
"cualificado como lo importa el cargador de pruebas."

#: ../Doc/library/unittest.rst:235
msgid ""
"For example, ``-k foo`` matches ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``, but not ``bar_tests.FooTest."
"test_something``."
msgstr ""
"Por ejemplo, ``-k foo`` casa con ``foo_tests.SomeTest.test_something`` y con "
"``bar_tests.SomeTest.test_foo``, pero no con ``bar_tests.FooTest."
"test_something``."

#: ../Doc/library/unittest.rst:240
msgid "Show local variables in tracebacks."
msgstr "Mostrar las variables locales en las trazas."

#: ../Doc/library/unittest.rst:242
msgid "The command-line options ``-b``, ``-c`` and ``-f`` were added."
msgstr "Se añadieron las opciones de línea de órdenes ``-b``, ``-c`` y ``-f``."

#: ../Doc/library/unittest.rst:245
msgid "The command-line option ``--locals``."
msgstr "La opción de línea de órdenes ``--locals``."

#: ../Doc/library/unittest.rst:248
msgid "The command-line option ``-k``."
msgstr "La opción de línea de órdenes ``-k``."

#: ../Doc/library/unittest.rst:251
msgid ""
"The command line can also be used for test discovery, for running all of the "
"tests in a project or just a subset."
msgstr ""
"La línea de órdenes también se puede usar para descubrimiento de pruebas, "
"para ejecutar todas las pruebas de un proyecto o un subconjunto de éstas."

#: ../Doc/library/unittest.rst:258
msgid "Test Discovery"
msgstr "Descubrimiento de pruebas"

#: ../Doc/library/unittest.rst:262
msgid ""
"Unittest supports simple test discovery. In order to be compatible with test "
"discovery, all of the test files must be :ref:`modules <tut-modules>` or :"
"ref:`packages <tut-packages>` (including :term:`namespace packages "
"<namespace package>`) importable from the top-level directory of the project "
"(this means that their filenames must be valid :ref:`identifiers "
"<identifiers>`)."
msgstr ""
"Unittest da soporte al descubrimiento de pruebas simples. Para ser "
"compatible con el descubrimiento de pruebas, todos los ficheros de prueba "
"deben ser :ref:`módulos <tut-modules>` o :ref:`paquetes <tut-packages>` "
"(incluyendo :term:`paquetes nominales <namespace package>`) importables "
"desde el directorio superior del proyecto (por lo que sus nombres han de "
"ser  :ref:`identificadores <identifiers>` válidos)."

#: ../Doc/library/unittest.rst:269
msgid ""
"Test discovery is implemented in :meth:`TestLoader.discover`, but can also "
"be used from the command line. The basic command-line usage is::"
msgstr ""
"El descubrimiento de pruebas está implementado en :meth:`TestLoader."
"discover`, pero también se puede usar desde la línea de órdenes. La línea de "
"órdenes básica es::"

#: ../Doc/library/unittest.rst:277
msgid ""
"As a shortcut, ``python -m unittest`` is the equivalent of ``python -m "
"unittest discover``. If you want to pass arguments to test discovery the "
"``discover`` sub-command must be used explicitly."
msgstr ""
"Como atajo, ``python -m unittest`` es el equivalente de ``python -m unittest "
"discover``. Si se desea pasar argumentos al descubrimiento de pruebas, hay "
"que pasar la sub-orden ``discover`` explícitamente."

#: ../Doc/library/unittest.rst:281
msgid "The ``discover`` sub-command has the following options:"
msgstr "La sub-orden ``discover`` cuenta con las siguientes opciones:"

#: ../Doc/library/unittest.rst:287
msgid "Verbose output"
msgstr "Salida verbosa"

#: ../Doc/library/unittest.rst:291
msgid "Directory to start discovery (``.`` default)"
msgstr "Directorio de inicio para el descubrimiento (``.`` si se omite)"

#: ../Doc/library/unittest.rst:295
msgid "Pattern to match test files (``test*.py`` default)"
msgstr ""
"Patrón para la búsqueda de ficheros de prueba (``test*.py`` si se omite)"

#: ../Doc/library/unittest.rst:299
msgid "Top level directory of project (defaults to start directory)"
msgstr "Directorio superior del proyecto (el directorio inicial si se omite)"

#: ../Doc/library/unittest.rst:301
msgid ""
"The :option:`-s`, :option:`-p`, and :option:`-t` options can be passed in as "
"positional arguments in that order. The following two command lines are "
"equivalent::"
msgstr ""
"Las opciones :option:`-s`, :option:`-p`, y :option:`-t` se pueden pasar por "
"posición en el orden mostrado. Las siguientes líneas de órdenes son "
"equivalentes::"

#: ../Doc/library/unittest.rst:308
msgid ""
"As well as being a path it is possible to pass a package name, for example "
"``myproject.subpackage.test``, as the start directory. The package name you "
"supply will then be imported and its location on the filesystem will be used "
"as the start directory."
msgstr ""
"Además de pasar una ruta, es posible pasar el nombre de un paquete, por "
"ejemplo ``myproject.subpackage.test``, como directorio de inicio. El nombre "
"de paquete proporcionado será importado y su ubicación en el sistema de "
"archivos será utilizada como directorio de inicio."

#: ../Doc/library/unittest.rst:315
msgid ""
"Test discovery loads tests by importing them. Once test discovery has found "
"all the test files from the start directory you specify it turns the paths "
"into package names to import. For example :file:`foo/bar/baz.py` will be "
"imported as ``foo.bar.baz``."
msgstr ""
"El descubrimiento de pruebas carga las pruebas importándolas. Una vez que el "
"descubrimiento ha encontrado todos los ficheros de prueba a partir del "
"directorio inicial, especificado, convierte las rutas en nombres de paquetes "
"a importar. Por ejemplo, :file:`foo/bar/baz.py` será importado como ``foo."
"bar.baz``."

#: ../Doc/library/unittest.rst:320
msgid ""
"If you have a package installed globally and attempt test discovery on a "
"different copy of the package then the import *could* happen from the wrong "
"place. If this happens test discovery will warn you and exit."
msgstr ""
"Si hay un paquete instalado globalmente y se intenta hacer un descubrimiento "
"sobre una copia diferente a la instalada del paquete, *podría* ocurrir que "
"se importe la versión incorrecta. Si ocurre esto, el descubrimiento lanza "
"una advertencia y abandona."

#: ../Doc/library/unittest.rst:324
msgid ""
"If you supply the start directory as a package name rather than a path to a "
"directory then discover assumes that whichever location it imports from is "
"the location you intended, so you will not get the warning."
msgstr ""
"Si se proporciona el directorio de inicio como nombre de paquete en lugar de "
"ruta a un directorio, el descubrimiento asume que la ubicación importada es "
"la deseada, así que no se da la advertencia descrita."

#: ../Doc/library/unittest.rst:329
msgid ""
"Test modules and packages can customize test loading and discovery by "
"through the `load_tests protocol`_."
msgstr ""
"Los módulos y paquetes de prueba pueden personalizar la carta y "
"descubrimiento de pruebas mediante el `protocolo load_tests`_."

#: ../Doc/library/unittest.rst:332
msgid "Test discovery supports :term:`namespace packages <namespace package>`."
msgstr ""
"El descubrimiento de pruebas admite :term:`paquetes nominales <namespace "
"package>`."

#: ../Doc/library/unittest.rst:339
msgid "Organizing test code"
msgstr "Organización del código de pruebas"

#: ../Doc/library/unittest.rst:341
msgid ""
"The basic building blocks of unit testing are :dfn:`test cases` --- single "
"scenarios that must be set up and checked for correctness.  In :mod:"
"`unittest`, test cases are represented by :class:`unittest.TestCase` "
"instances. To make your own test cases you must write subclasses of :class:"
"`TestCase` or use :class:`FunctionTestCase`."
msgstr ""
"Los bloques de construcción básicos de las pruebas unitarias son los :dfn:"
"`test cases`, escenarios simples que se han de configurar y cuya corrección "
"hay que comprobar. En :mod:`unittest`, los casos de prueba están "
"representados por instancias de :class:`unittest.TestCase`. Para crear "
"nuevos casos de prueba, hay que escribir subclases de :class:`TestCase` o "
"usar :class:`FunctionTestCase`."

#: ../Doc/library/unittest.rst:347
msgid ""
"The testing code of a :class:`TestCase` instance should be entirely self "
"contained, such that it can be run either in isolation or in arbitrary "
"combination with any number of other test cases."
msgstr ""
"El código de pruebas de una instancia de :class:`TestCase` debería ser "
"completamente autónomo. de tal modo que se pueda ejecutar aisladamente o en "
"una combinación arbitraria con otras clases de prueba."

#: ../Doc/library/unittest.rst:351
msgid ""
"The simplest :class:`TestCase` subclass will simply implement a test method "
"(i.e. a method whose name starts with ``test``) in order to perform specific "
"testing code::"
msgstr ""
"La subclase más simple de :class:`TestCase` se limita a implementar un "
"método `test` (o un método que empiece por `test`) para realizar código de "
"prueba específico::"

#: ../Doc/library/unittest.rst:362
msgid ""
"Note that in order to test something, we use one of the :meth:`assert\\*` "
"methods provided by the :class:`TestCase` base class.  If the test fails, an "
"exception will be raised with an explanatory message, and :mod:`unittest` "
"will identify the test case as a :dfn:`failure`.  Any other exceptions will "
"be treated as :dfn:`errors`."
msgstr ""
"Adviértase que para probar algo, usamos uno de los métodos :meth:`assert\\*` "
"proporcionados por la clase base :class:`TestCase`. Si la prueba no tiene "
"éxito, se lanzará una excepción con un mensaje explicativo y :mod:`unittest` "
"identificará el caso como :dfn:`failure`. Cualquier otra excepción se "
"considerará un :dfn:`errors`."

#: ../Doc/library/unittest.rst:368
msgid ""
"Tests can be numerous, and their set-up can be repetitive.  Luckily, we can "
"factor out set-up code by implementing a method called :meth:`~TestCase."
"setUp`, which the testing framework will automatically call for every single "
"test we run::"
msgstr ""
"Las pruebas pueden ser muchas y su preparación puede ser repetitiva. Por "
"suerte, se puede \"sacar factor común\" a la preparación implementando un "
"método :meth:`~TestCase.setUp`, al que la infraestructura de prueba llamará "
"para cada prueba que se ejecute::"

#: ../Doc/library/unittest.rst:389
msgid ""
"The order in which the various tests will be run is determined by sorting "
"the test method names with respect to the built-in ordering for strings."
msgstr ""
"El orden en que se ejecutan las diversas pruebas se determina por orden "
"alfabético de los nombres de métodos de prueba."

#: ../Doc/library/unittest.rst:393
msgid ""
"If the :meth:`~TestCase.setUp` method raises an exception while the test is "
"running, the framework will consider the test to have suffered an error, and "
"the test method will not be executed."
msgstr ""
"Si el método :meth:`~TestCase.setUp` lanza una excepción mientras se ejecuta "
"la prueba, la infraestructura considerará que la prueba ha sufrido un error "
"y no se ejecutará el método de prueba propiamente dicho."

#: ../Doc/library/unittest.rst:397
msgid ""
"Similarly, we can provide a :meth:`~TestCase.tearDown` method that tidies up "
"after the test method has been run::"
msgstr ""
"Análogamente, se puede proporcionar un método :meth:`~TestCase.tearDown` que "
"haga limpieza después de que se ejecute el método de prueba::"

#: ../Doc/library/unittest.rst:409
msgid ""
"If :meth:`~TestCase.setUp` succeeded, :meth:`~TestCase.tearDown` will be run "
"whether the test method succeeded or not."
msgstr ""
"Si :meth:`~TestCase.setUp` se ejecuta sin errores, :meth:`~TestCase."
"tearDown` se ejecutará tanto si el método de prueba tuvo éxito como si no."

#: ../Doc/library/unittest.rst:412
msgid ""
"Such a working environment for the testing code is called a :dfn:`test "
"fixture`.  A new TestCase instance is created as a unique test fixture used "
"to execute each individual test method.  Thus :meth:`~TestCase.setUp`, :meth:"
"`~TestCase.tearDown`, and :meth:`~TestCase.__init__` will be called once per "
"test."
msgstr ""
"Un entorno de trabajo así para el código de pruebas se llama :dfn:`test "
"fixture` . Se crea una nueva instancia de TestCase como juego de datos de "
"prueba que se utiliza para cada método de prueba. De este modo, :meth:"
"`~TestCase.setUp`, :meth:`~TestCase.tearDown` y :meth:`~TestCase.__init__` "
"se llamarán una vez por prueba."

#: ../Doc/library/unittest.rst:418
msgid ""
"It is recommended that you use TestCase implementations to group tests "
"together according to the features they test.  :mod:`unittest` provides a "
"mechanism for this: the :dfn:`test suite`, represented by :mod:`unittest`'s :"
"class:`TestSuite` class.  In most cases, calling :func:`unittest.main` will "
"do the right thing and collect all the module's test cases for you and "
"execute them."
msgstr ""
"Se recomienda usar implementaciones de `TestCase` para agrupar las pruebas "
"de acuerdo con las características probadas.  :mod:`unittest` proporciona "
"una mecanismo para esto: el :dfn:`test suite`, representado por la clase :"
"class:`TestSuite` de :mod:`unittest`. En la mayor parte de los casos, llamar "
"a :func:`unittest.main` hará lo correcto y recolectará todos los casos de "
"prueba del módulo para su ejecución."

#: ../Doc/library/unittest.rst:425
msgid ""
"However, should you want to customize the building of your test suite, you "
"can do it yourself::"
msgstr ""
"Sin embargo, si se desea personalizar la construcción del paquete de "
"pruebas , se puede hacer::"

#: ../Doc/library/unittest.rst:438
msgid ""
"You can place the definitions of test cases and test suites in the same "
"modules as the code they are to test (such as :file:`widget.py`), but there "
"are several advantages to placing the test code in a separate module, such "
"as :file:`test_widget.py`:"
msgstr ""
"Se puede poner las definiciones de los casos de prueba y de los paquetes de "
"prueba en los mismos módulos que el código que prueban.(tal como :file:"
"`widget.py`), pero sacarlos a un módulo aparte como :file:`test_widget.py` "
"tiene diversas ventajas:"

#: ../Doc/library/unittest.rst:443
msgid "The test module can be run standalone from the command line."
msgstr ""
"El módulo de pruebas se puede ejecutar aisladamente desde la línea de "
"órdenes."

#: ../Doc/library/unittest.rst:445
msgid "The test code can more easily be separated from shipped code."
msgstr ""
"El código de pruebas se puede separar con más facilidad del código de "
"producción."

#: ../Doc/library/unittest.rst:447
msgid ""
"There is less temptation to change test code to fit the code it tests "
"without a good reason."
msgstr ""
"Disminuye la tentación de cambiar el código de prueba para ajustarse al "
"código bajo prueba."

#: ../Doc/library/unittest.rst:450
msgid ""
"Test code should be modified much less frequently than the code it tests."
msgstr ""
"El código de pruebas debería modificarse con mucha menor frecuencia que el "
"código bajo prueba."

#: ../Doc/library/unittest.rst:452
msgid "Tested code can be refactored more easily."
msgstr "Es más sencillo refactorizar el código bajo prueba."

#: ../Doc/library/unittest.rst:454
msgid ""
"Tests for modules written in C must be in separate modules anyway, so why "
"not be consistent?"
msgstr ""
"El código para probar módulos escritos en C ha de estar en módulos aparte, "
"así que ¿por qué no mantener la consistencia?"

#: ../Doc/library/unittest.rst:457
msgid ""
"If the testing strategy changes, there is no need to change the source code."
msgstr ""
"Si cambia la estrategia de prueba, no hay razón para cambiar el código "
"fuente principal."

#: ../Doc/library/unittest.rst:463
msgid "Re-using old test code"
msgstr "Reutilización de código de prueba anterior"

#: ../Doc/library/unittest.rst:465
msgid ""
"Some users will find that they have existing test code that they would like "
"to run from :mod:`unittest`, without converting every old test function to "
"a :class:`TestCase` subclass."
msgstr ""
"Habrá personas que tengan código de prueba previo que deseen ejecutar desde :"
"mod:`unittest`, sin conversión previa de cada antigua función de prueba a "
"una subclase de :class:`TestCase`."

#: ../Doc/library/unittest.rst:469
msgid ""
"For this reason, :mod:`unittest` provides a :class:`FunctionTestCase` class. "
"This subclass of :class:`TestCase` can be used to wrap an existing test "
"function.  Set-up and tear-down functions can also be provided."
msgstr ""
"Por esto, :mod:`unittest` proporciona una clase :class:`FunctionTestCase`. "
"Se puede utilizar esta subclase de :class:`TestCase` para envolver una "
"función de prueba existente. Se pueden proporcionar también funciones de "
"preparación y desmontaje."

#: ../Doc/library/unittest.rst:473
msgid "Given the following test function::"
msgstr "Dada la siguiente función de prueba::"

#: ../Doc/library/unittest.rst:480
msgid ""
"one can create an equivalent test case instance as follows, with optional "
"set-up and tear-down methods::"
msgstr ""
"se puede crear una instancia de caso de prueba de la siguiente manera, con "
"métodos opcionales de preparación y desmontaje::"

#: ../Doc/library/unittest.rst:489
msgid ""
"Even though :class:`FunctionTestCase` can be used to quickly convert an "
"existing test base over to a :mod:`unittest`\\ -based system, this approach "
"is not recommended.  Taking the time to set up proper :class:`TestCase` "
"subclasses will make future test refactorings infinitely easier."
msgstr ""
"Aunque se puede usar :class:`FunctionTestCase` para convertir rápidamente "
"unas pruebas existentes a un sistema basado en :mod:`unittest`, no es una "
"vía recomendada. Tomarse el tiempo de construir subclases bien construidas "
"de :class:`TestCase` hará las futuras refactorizaciones de pruebas futura "
"considerablemente más fácil."

#: ../Doc/library/unittest.rst:494
msgid ""
"In some cases, the existing tests may have been written using the :mod:"
"`doctest` module.  If so, :mod:`doctest` provides a :class:`DocTestSuite` "
"class that can automatically build :class:`unittest.TestSuite` instances "
"from the existing :mod:`doctest`\\ -based tests."
msgstr ""
"En algunos casos, los tests existentes pueden haber sido escritos usando el "
"módulo :mod:`doctest`. En ese caso, :mod:`doctest` tiene una clase :class:"
"`DocTestSuite` que puede construir automáticamente instancias de :class:"
"`unittest.TestSuite` partiendo de los test basados en :mod:`doctest`."

#: ../Doc/library/unittest.rst:503
msgid "Skipping tests and expected failures"
msgstr "Omitir tests y fallos esperados"

#: ../Doc/library/unittest.rst:507
msgid ""
"Unittest supports skipping individual test methods and even whole classes of "
"tests.  In addition, it supports marking a test as an \"expected failure,\" "
"a test that is broken and will fail, but shouldn't be counted as a failure "
"on a :class:`TestResult`."
msgstr ""
"Unittest soporta omitir métodos individuales de tests e incluso clases "
"completas de tests. Además, soporta marcar un test como un ‘’fallo "
"esperado’’, un test que está roto y va a fallar, pero no debería ser contado "
"como fallo en  :class:`TestResult`."

#: ../Doc/library/unittest.rst:512
msgid ""
"Skipping a test is simply a matter of using the :func:`skip` :term:"
"`decorator` or one of its conditional variants, calling :meth:`TestCase."
"skipTest` within a :meth:`~TestCase.setUp` or test method, or raising :exc:"
"`SkipTest` directly."
msgstr ""
"Omitir un test es solo cuestión de emplear el :term:`decorator`  :func:"
"`skip`  o una de sus variantes condicionales, llamando a :meth:`TestCase."
"skipTest` dentro de :meth:`~TestCase.setUp` o en un método de test, o "
"lanzando :exc:`SkipTest` directamente."

#: ../Doc/library/unittest.rst:516
msgid "Basic skipping looks like this::"
msgstr "La omisión más básica tiene la siguiente forma:"

#: ../Doc/library/unittest.rst:541
msgid "This is the output of running the example above in verbose mode::"
msgstr "Esta es la salida de ejecutar el ejemplo superior en modo verboso::"

#: ../Doc/library/unittest.rst:553
msgid "Classes can be skipped just like methods::"
msgstr "Las clases pueden ser omitidas igual que los métodos::"

#: ../Doc/library/unittest.rst:560
msgid ""
":meth:`TestCase.setUp` can also skip the test.  This is useful when a "
"resource that needs to be set up is not available."
msgstr ""
":meth:`TestCase.setUp`  puede omitir también el test. Esto es útil cuando un "
"recurso que necesita ser puesto a punto no está disponible."

#: ../Doc/library/unittest.rst:563
msgid "Expected failures use the :func:`expectedFailure` decorator. ::"
msgstr "Los fallos esperados emplean el decorador  :func:`expectedFailure`. ::"

#: ../Doc/library/unittest.rst:570
msgid ""
"It's easy to roll your own skipping decorators by making a decorator that "
"calls :func:`skip` on the test when it wants it to be skipped.  This "
"decorator skips the test unless the passed object has a certain attribute::"
msgstr ""
"Es fácil lanzar tus propios decoradores que omitan haciendo un decorador que "
"llame a :func:`skip`  en el test cuando quiere ser omitido. Este decorador "
"omite el test a menos que el objeto pasado tenga un cierto atributo::"

#: ../Doc/library/unittest.rst:579
msgid ""
"The following decorators and exception implement test skipping and expected "
"failures:"
msgstr ""
"Los siguientes decoradores y la excepción implementan la omisión de tests y "
"los fallos esperados:"

#: ../Doc/library/unittest.rst:583
msgid ""
"Unconditionally skip the decorated test.  *reason* should describe why the "
"test is being skipped."
msgstr ""
"Omitir incondicionalmente el test decorado. *reason* debe describir porqué "
"el test está siendo omitido."

#: ../Doc/library/unittest.rst:588
msgid "Skip the decorated test if *condition* is true."
msgstr "Omitir el test decorado si *condition* es verdadero."

#: ../Doc/library/unittest.rst:592
msgid "Skip the decorated test unless *condition* is true."
msgstr "Omitir el test decorado a menos que *condition* sea verdadero."

#: ../Doc/library/unittest.rst:596
msgid ""
"Mark the test as an expected failure.  If the test fails it will be "
"considered a success.  If the test passes, it will be considered a failure."
msgstr ""
"Marca el test como un fallo esperado.  Si el test falla será considerado un "
"éxito. Si el test pasa, será considerado un fallo."

#: ../Doc/library/unittest.rst:601
msgid "This exception is raised to skip a test."
msgstr "Esta excepción es lanzada para omitir un test."

#: ../Doc/library/unittest.rst:603
msgid ""
"Usually you can use :meth:`TestCase.skipTest` or one of the skipping "
"decorators instead of raising this directly."
msgstr ""
"Normalmente puedes usar directamente :meth:`TestCase.skipTest`  o uno de los "
"decoradores de omisión en vez de lanzar esta excepción."

#: ../Doc/library/unittest.rst:606
msgid ""
"Skipped tests will not have :meth:`~TestCase.setUp` or :meth:`~TestCase."
"tearDown` run around them. Skipped classes will not have :meth:`~TestCase."
"setUpClass` or :meth:`~TestCase.tearDownClass` run. Skipped modules will not "
"have :func:`setUpModule` or :func:`tearDownModule` run."
msgstr ""
"Los tests omitidos no ejecutarán :meth:`~TestCase.setUp` o :meth:`~TestCase."
"tearDown`. Las clases omitidas no ejecutarán :meth:`~TestCase.setUpClass` o :"
"meth:`~TestCase.tearDownClass`. Los módulos omitidos no ejecutarán :func:"
"`setUpModule` o :func:`tearDownModule`."

#: ../Doc/library/unittest.rst:614
msgid "Distinguishing test iterations using subtests"
msgstr "Distinguiendo iteraciones de tests empleando subtests"

#: ../Doc/library/unittest.rst:618
msgid ""
"When there are very small differences among your tests, for instance some "
"parameters, unittest allows you to distinguish them inside the body of a "
"test method using the :meth:`~TestCase.subTest` context manager."
msgstr ""
"Cuando hay diferencias muy pequeñas entre tus tests, por ejemplo algunos "
"parámetros, unittest te permite distinguirlos dentro del cuerpo de un método "
"de test empleando el administrador de contexto :meth:`~TestCase.subTest` ."

#: ../Doc/library/unittest.rst:622
msgid "For example, the following test::"
msgstr "Por ejemplo, el siguiente test::"

#: ../Doc/library/unittest.rst:634
msgid "will produce the following output::"
msgstr "producirá la siguiente salida:"

#: ../Doc/library/unittest.rst:660
msgid ""
"Without using a subtest, execution would stop after the first failure, and "
"the error would be less easy to diagnose because the value of ``i`` wouldn't "
"be displayed::"
msgstr ""
"Sin usar un subtest, la ejecución se pararía después del primer fallo, y el "
"error sería más difícil de diagnosticar porque el valor de  ``i`` no se "
"mostraría::"

#: ../Doc/library/unittest.rst:676
msgid "Classes and functions"
msgstr "Clases y funciones"

#: ../Doc/library/unittest.rst:678
msgid "This section describes in depth the API of :mod:`unittest`."
msgstr "Esta sección describe en detalle la API de :mod:`unittest`."

#: ../Doc/library/unittest.rst:684
msgid "Test cases"
msgstr "Casos de test"

#: ../Doc/library/unittest.rst:688
msgid ""
"Instances of the :class:`TestCase` class represent the logical test units in "
"the :mod:`unittest` universe.  This class is intended to be used as a base "
"class, with specific tests being implemented by concrete subclasses.  This "
"class implements the interface needed by the test runner to allow it to "
"drive the tests, and methods that the test code can use to check for and "
"report various kinds of failure."
msgstr ""
"Las instancias de la clase  :class:`TestCase` representan las unidades "
"lógicas de test en el universo de :mod:`unittest`. Esta clase está pensada "
"para ser utilizada como clase base, con los test específicos siendo "
"implementados por subclases concretas. Esta clase implementa la interfaz que "
"necesita el ejecutor de tests para permitirle llevar a cabo los tests, y "
"métodos que el código de test puede utilizar para chequear y reportar "
"distintos tipos de fallo."

#: ../Doc/library/unittest.rst:695
msgid ""
"Each instance of :class:`TestCase` will run a single base method: the method "
"named *methodName*. In most uses of :class:`TestCase`, you will neither "
"change the *methodName* nor reimplement the default ``runTest()`` method."
msgstr ""
"Cada instancia de :class:`TestCase`  ejecutará un solo método base: el "
"método llamado *methodName*. En la mayoría de usos de :class:`TestCase`, no "
"tendrás que cambiar el *methodName*  ni reimplementar el método por defecto  "
"``runTest()``."

#: ../Doc/library/unittest.rst:700
msgid ""
":class:`TestCase` can be instantiated successfully without providing a "
"*methodName*. This makes it easier to experiment with :class:`TestCase` from "
"the interactive interpreter."
msgstr ""
":class:`TestCase` puede instancias con éxito sin dar un *methodName*.  Esto "
"permite experimentar de manera sencilla con :class:`TestCase`  en el "
"intérprete interactivo."

#: ../Doc/library/unittest.rst:705
msgid ""
":class:`TestCase` instances provide three groups of methods: one group used "
"to run the test, another used by the test implementation to check conditions "
"and report failures, and some inquiry methods allowing information about the "
"test itself to be gathered."
msgstr ""
"Las instancias de :class:`TestCase`  proveen tres grupos de métodos: un "
"grupo empleado para ejecutar el test, otro usado para que la implementación "
"del test chequee condiciones y reporte fallos, y algunos métodos de "
"indagación que permiten recopilar información sobre el test en si mismo."

#: ../Doc/library/unittest.rst:710
msgid "Methods in the first group (running the test) are:"
msgstr "Los métodos en el primer grupo (ejecutando el test) son:"

#: ../Doc/library/unittest.rst:714
msgid ""
"Method called to prepare the test fixture.  This is called immediately "
"before calling the test method; other than :exc:`AssertionError` or :exc:"
"`SkipTest`, any exception raised by this method will be considered an error "
"rather than a test failure. The default implementation does nothing."
msgstr ""
"Método llamado para preparar el banco de test. Es invocado inmediatamente "
"antes de llamar al método de test; cualquier excepción lanzada por este "
"método que no sea :exc:`AssertionError` o :exc:`SkipTest` será considerada "
"un error en vez de un fallo del test. La implementación por defecto no hace "
"nada."

#: ../Doc/library/unittest.rst:722
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called even if the test method raised an "
"exception, so the implementation in subclasses may need to be particularly "
"careful about checking internal state.  Any exception, other than :exc:"
"`AssertionError` or :exc:`SkipTest`, raised by this method will be "
"considered an additional error rather than a test failure (thus increasing "
"the total number of reported errors). This method will only be called if "
"the :meth:`setUp` succeeds, regardless of the outcome of the test method. "
"The default implementation does nothing."
msgstr ""

#: ../Doc/library/unittest.rst:735
msgid ""
"A class method called before tests in an individual class are run. "
"``setUpClass`` is called with the class as the only argument and must be "
"decorated as a :func:`classmethod`::"
msgstr ""

#: ../Doc/library/unittest.rst:743 ../Doc/library/unittest.rst:758
msgid "See `Class and Module Fixtures`_ for more details."
msgstr ""

#: ../Doc/library/unittest.rst:750
msgid ""
"A class method called after tests in an individual class have run. "
"``tearDownClass`` is called with the class as the only argument and must be "
"decorated as a :meth:`classmethod`::"
msgstr ""

#: ../Doc/library/unittest.rst:765
msgid ""
"Run the test, collecting the result into the :class:`TestResult` object "
"passed as *result*.  If *result* is omitted or ``None``, a temporary result "
"object is created (by calling the :meth:`defaultTestResult` method) and "
"used. The result object is returned to :meth:`run`'s caller."
msgstr ""

#: ../Doc/library/unittest.rst:771
msgid ""
"The same effect may be had by simply calling the :class:`TestCase` instance."
msgstr ""

#: ../Doc/library/unittest.rst:774
msgid ""
"Previous versions of ``run`` did not return the result. Neither did calling "
"an instance."
msgstr ""

#: ../Doc/library/unittest.rst:780
msgid ""
"Calling this during a test method or :meth:`setUp` skips the current test.  "
"See :ref:`unittest-skipping` for more information."
msgstr ""

#: ../Doc/library/unittest.rst:788
msgid ""
"Return a context manager which executes the enclosed code block as a "
"subtest.  *msg* and *params* are optional, arbitrary values which are "
"displayed whenever a subtest fails, allowing you to identify them clearly."
msgstr ""

#: ../Doc/library/unittest.rst:793
msgid ""
"A test case can contain any number of subtest declarations, and they can be "
"arbitrarily nested."
msgstr ""

#: ../Doc/library/unittest.rst:796
msgid "See :ref:`subtests` for more information."
msgstr ""

#: ../Doc/library/unittest.rst:803
msgid ""
"Run the test without collecting the result.  This allows exceptions raised "
"by the test to be propagated to the caller, and can be used to support "
"running tests under a debugger."
msgstr ""

#: ../Doc/library/unittest.rst:809
msgid ""
"The :class:`TestCase` class provides several assert methods to check for and "
"report failures.  The following table lists the most commonly used methods "
"(see the tables below for more assert methods):"
msgstr ""

#: ../Doc/library/unittest.rst:814 ../Doc/library/unittest.rst:936
#: ../Doc/library/unittest.rst:1128 ../Doc/library/unittest.rst:1255
msgid "Method"
msgstr "Método"

#: ../Doc/library/unittest.rst:814 ../Doc/library/unittest.rst:936
#: ../Doc/library/unittest.rst:1128
msgid "Checks that"
msgstr "Comprueba que"

#: ../Doc/library/unittest.rst:814 ../Doc/library/unittest.rst:936
#: ../Doc/library/unittest.rst:1128 ../Doc/library/unittest.rst:1255
msgid "New in"
msgstr "Nuevo en"

#: ../Doc/library/unittest.rst:816
msgid ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"
msgstr ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"

#: ../Doc/library/unittest.rst:816
msgid "``a == b``"
msgstr "``a == b``"

#: ../Doc/library/unittest.rst:819
msgid ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"
msgstr ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"

#: ../Doc/library/unittest.rst:819
msgid "``a != b``"
msgstr "``a != b``"

#: ../Doc/library/unittest.rst:822
msgid ":meth:`assertTrue(x) <TestCase.assertTrue>`"
msgstr ":meth:`assertTrue(x) <TestCase.assertTrue>`"

#: ../Doc/library/unittest.rst:822
msgid "``bool(x) is True``"
msgstr "``bool(x) is True``"

#: ../Doc/library/unittest.rst:825
msgid ":meth:`assertFalse(x) <TestCase.assertFalse>`"
msgstr ":meth:`assertFalse(x) <TestCase.assertFalse>`"

#: ../Doc/library/unittest.rst:825
msgid "``bool(x) is False``"
msgstr "``bool(x) is False``"

#: ../Doc/library/unittest.rst:828
msgid ":meth:`assertIs(a, b) <TestCase.assertIs>`"
msgstr ":meth:`assertIs(a, b) <TestCase.assertIs>`"

#: ../Doc/library/unittest.rst:828
msgid "``a is b``"
msgstr "``a is b``"

#: ../Doc/library/unittest.rst:828 ../Doc/library/unittest.rst:831
#: ../Doc/library/unittest.rst:834 ../Doc/library/unittest.rst:837
#: ../Doc/library/unittest.rst:840 ../Doc/library/unittest.rst:843
#: ../Doc/library/unittest.rst:941 ../Doc/library/unittest.rst:1136
#: ../Doc/library/unittest.rst:1139 ../Doc/library/unittest.rst:1142
#: ../Doc/library/unittest.rst:1145 ../Doc/library/unittest.rst:1148
#: ../Doc/library/unittest.rst:1257 ../Doc/library/unittest.rst:1260
#: ../Doc/library/unittest.rst:1263 ../Doc/library/unittest.rst:1266
#: ../Doc/library/unittest.rst:1269 ../Doc/library/unittest.rst:1272
msgid "3.1"
msgstr "3.1"

#: ../Doc/library/unittest.rst:831
msgid ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"
msgstr ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"

#: ../Doc/library/unittest.rst:831
msgid "``a is not b``"
msgstr "``a is not b``"

#: ../Doc/library/unittest.rst:834
msgid ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"
msgstr ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"

#: ../Doc/library/unittest.rst:834
msgid "``x is None``"
msgstr "``x is None``"

#: ../Doc/library/unittest.rst:837
msgid ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"
msgstr ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"

#: ../Doc/library/unittest.rst:837
msgid "``x is not None``"
msgstr ""

#: ../Doc/library/unittest.rst:840
msgid ":meth:`assertIn(a, b) <TestCase.assertIn>`"
msgstr ""

#: ../Doc/library/unittest.rst:840
msgid "``a in b``"
msgstr ""

#: ../Doc/library/unittest.rst:843
msgid ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"
msgstr ""

#: ../Doc/library/unittest.rst:843
msgid "``a not in b``"
msgstr ""

#: ../Doc/library/unittest.rst:846
msgid ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"
msgstr ""

#: ../Doc/library/unittest.rst:846
msgid "``isinstance(a, b)``"
msgstr ""

#: ../Doc/library/unittest.rst:846 ../Doc/library/unittest.rst:849
#: ../Doc/library/unittest.rst:944 ../Doc/library/unittest.rst:947
#: ../Doc/library/unittest.rst:1151 ../Doc/library/unittest.rst:1154
msgid "3.2"
msgstr ""

#: ../Doc/library/unittest.rst:849
msgid ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"
msgstr ""

#: ../Doc/library/unittest.rst:849
msgid "``not isinstance(a, b)``"
msgstr ""

#: ../Doc/library/unittest.rst:853
msgid ""
"All the assert methods accept a *msg* argument that, if specified, is used "
"as the error message on failure (see also :data:`longMessage`). Note that "
"the *msg* keyword argument can be passed to :meth:`assertRaises`, :meth:"
"`assertRaisesRegex`, :meth:`assertWarns`, :meth:`assertWarnsRegex` only when "
"they are used as a context manager."
msgstr ""

#: ../Doc/library/unittest.rst:861
msgid ""
"Test that *first* and *second* are equal.  If the values do not compare "
"equal, the test will fail."
msgstr ""

#: ../Doc/library/unittest.rst:864
msgid ""
"In addition, if *first* and *second* are the exact same type and one of "
"list, tuple, dict, set, frozenset or str or any type that a subclass "
"registers with :meth:`addTypeEqualityFunc` the type-specific equality "
"function will be called in order to generate a more useful default error "
"message (see also the :ref:`list of type-specific methods <type-specific-"
"methods>`)."
msgstr ""

#: ../Doc/library/unittest.rst:871
msgid "Added the automatic calling of type-specific equality function."
msgstr ""

#: ../Doc/library/unittest.rst:874
msgid ""
":meth:`assertMultiLineEqual` added as the default type equality function for "
"comparing strings."
msgstr ""

#: ../Doc/library/unittest.rst:881
msgid ""
"Test that *first* and *second* are not equal.  If the values do compare "
"equal, the test will fail."
msgstr ""

#: ../Doc/library/unittest.rst:887
msgid "Test that *expr* is true (or false)."
msgstr ""

#: ../Doc/library/unittest.rst:889
msgid ""
"Note that this is equivalent to ``bool(expr) is True`` and not to ``expr is "
"True`` (use ``assertIs(expr, True)`` for the latter).  This method should "
"also be avoided when more specific methods are available (e.g. "
"``assertEqual(a, b)`` instead of ``assertTrue(a == b)``), because they "
"provide a better error message in case of failure."
msgstr ""

#: ../Doc/library/unittest.rst:899
msgid ""
"Test that *first* and *second* evaluate (or don't evaluate) to the same "
"object."
msgstr ""

#: ../Doc/library/unittest.rst:908
msgid "Test that *expr* is (or is not) ``None``."
msgstr ""

#: ../Doc/library/unittest.rst:916
msgid "Test that *member* is (or is not) in *container*."
msgstr ""

#: ../Doc/library/unittest.rst:924
msgid ""
"Test that *obj* is (or is not) an instance of *cls* (which can be a class or "
"a tuple of classes, as supported by :func:`isinstance`). To check for the "
"exact type, use :func:`assertIs(type(obj), cls) <assertIs>`."
msgstr ""

#: ../Doc/library/unittest.rst:932
msgid ""
"It is also possible to check the production of exceptions, warnings, and log "
"messages using the following methods:"
msgstr ""

#: ../Doc/library/unittest.rst:938
msgid ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"
msgstr ""

#: ../Doc/library/unittest.rst:938
msgid "``fun(*args, **kwds)`` raises *exc*"
msgstr ""

#: ../Doc/library/unittest.rst:941
msgid ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"
msgstr ""

#: ../Doc/library/unittest.rst:941
msgid "``fun(*args, **kwds)`` raises *exc* and the message matches regex *r*"
msgstr ""

#: ../Doc/library/unittest.rst:944
msgid ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"
msgstr ""

#: ../Doc/library/unittest.rst:944
msgid "``fun(*args, **kwds)`` raises *warn*"
msgstr ""

#: ../Doc/library/unittest.rst:947
msgid ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"
msgstr ""

#: ../Doc/library/unittest.rst:947
msgid "``fun(*args, **kwds)`` raises *warn* and the message matches regex *r*"
msgstr ""

#: ../Doc/library/unittest.rst:950
msgid ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"
msgstr ""

#: ../Doc/library/unittest.rst:950
msgid "The ``with`` block logs on *logger* with minimum *level*"
msgstr ""

#: ../Doc/library/unittest.rst:950
msgid "3.4"
msgstr ""

#: ../Doc/library/unittest.rst:957
msgid ""
"Test that an exception is raised when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertRaises`.  The test passes if *exception* is raised, is an error if "
"another exception is raised, or fails if no exception is raised. To catch "
"any of a group of exceptions, a tuple containing the exception classes may "
"be passed as *exception*."
msgstr ""

#: ../Doc/library/unittest.rst:964
msgid ""
"If only the *exception* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""

#: ../Doc/library/unittest.rst:971
msgid ""
"When used as a context manager, :meth:`assertRaises` accepts the additional "
"keyword argument *msg*."
msgstr ""

#: ../Doc/library/unittest.rst:974
msgid ""
"The context manager will store the caught exception object in its :attr:"
"`exception` attribute.  This can be useful if the intention is to perform "
"additional checks on the exception raised::"
msgstr ""

#: ../Doc/library/unittest.rst:984
msgid "Added the ability to use :meth:`assertRaises` as a context manager."
msgstr ""

#: ../Doc/library/unittest.rst:987
msgid "Added the :attr:`exception` attribute."
msgstr ""

#: ../Doc/library/unittest.rst:990 ../Doc/library/unittest.rst:1016
#: ../Doc/library/unittest.rst:1057 ../Doc/library/unittest.rst:1080
msgid "Added the *msg* keyword argument when used as a context manager."
msgstr ""

#: ../Doc/library/unittest.rst:997
msgid ""
"Like :meth:`assertRaises` but also tests that *regex* matches on the string "
"representation of the raised exception.  *regex* may be a regular expression "
"object or a string containing a regular expression suitable for use by :func:"
"`re.search`.  Examples::"
msgstr ""

#: ../Doc/library/unittest.rst:1005 ../Doc/library/unittest.rst:1073
msgid "or::"
msgstr ""

#: ../Doc/library/unittest.rst:1010
msgid "Added under the name ``assertRaisesRegexp``."
msgstr ""

#: ../Doc/library/unittest.rst:1013
msgid "Renamed to :meth:`assertRaisesRegex`."
msgstr ""

#: ../Doc/library/unittest.rst:1023
msgid ""
"Test that a warning is triggered when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertWarns`.  The test passes if *warning* is triggered and fails if it "
"isn't.  Any exception is an error. To catch any of a group of warnings, a "
"tuple containing the warning classes may be passed as *warnings*."
msgstr ""

#: ../Doc/library/unittest.rst:1030
msgid ""
"If only the *warning* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""

#: ../Doc/library/unittest.rst:1037
msgid ""
"When used as a context manager, :meth:`assertWarns` accepts the additional "
"keyword argument *msg*."
msgstr ""

#: ../Doc/library/unittest.rst:1040
msgid ""
"The context manager will store the caught warning object in its :attr:"
"`warning` attribute, and the source line which triggered the warnings in "
"the :attr:`filename` and :attr:`lineno` attributes. This can be useful if "
"the intention is to perform additional checks on the warning caught::"
msgstr ""

#: ../Doc/library/unittest.rst:1052
msgid ""
"This method works regardless of the warning filters in place when it is "
"called."
msgstr ""

#: ../Doc/library/unittest.rst:1064
msgid ""
"Like :meth:`assertWarns` but also tests that *regex* matches on the message "
"of the triggered warning.  *regex* may be a regular expression object or a "
"string containing a regular expression suitable for use by :func:`re."
"search`.  Example::"
msgstr ""

#: ../Doc/library/unittest.rst:1085
msgid ""
"A context manager to test that at least one message is logged on the "
"*logger* or one of its children, with at least the given *level*."
msgstr ""

#: ../Doc/library/unittest.rst:1089
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages."
msgstr ""

#: ../Doc/library/unittest.rst:1093
msgid ""
"If given, *level* should be either a numeric logging level or its string "
"equivalent (for example either ``\"ERROR\"`` or :attr:`logging.ERROR`).  The "
"default is :attr:`logging.INFO`."
msgstr ""

#: ../Doc/library/unittest.rst:1097
msgid ""
"The test passes if at least one message emitted inside the ``with`` block "
"matches the *logger* and *level* conditions, otherwise it fails."
msgstr ""

#: ../Doc/library/unittest.rst:1100
msgid ""
"The object returned by the context manager is a recording helper which keeps "
"tracks of the matching log messages.  It has two attributes:"
msgstr ""

#: ../Doc/library/unittest.rst:1106
msgid ""
"A list of :class:`logging.LogRecord` objects of the matching log messages."
msgstr ""

# he marcado este párrafo como fuzzy como ejemplo para Ignasi :)
#: ../Doc/library/unittest.rst:1111
#, fuzzy
msgid ""
"A list of :class:`str` objects with the formatted output of matching "
"messages."
msgstr ""
"Una lista de objetos :class:`str` con la salida forrajeada en los mensajes "
"coincidentes."

#: ../Doc/library/unittest.rst:1114
msgid "Example::"
msgstr ""

#: ../Doc/library/unittest.rst:1125
msgid ""
"There are also other methods used to perform more specific checks, such as:"
msgstr ""

#: ../Doc/library/unittest.rst:1130
msgid ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"
msgstr ""

#: ../Doc/library/unittest.rst:1130
msgid "``round(a-b, 7) == 0``"
msgstr ""

#: ../Doc/library/unittest.rst:1133
msgid ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"
msgstr ""

#: ../Doc/library/unittest.rst:1133
msgid "``round(a-b, 7) != 0``"
msgstr ""

#: ../Doc/library/unittest.rst:1136
msgid ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"
msgstr ""

#: ../Doc/library/unittest.rst:1136
msgid "``a > b``"
msgstr ""

#: ../Doc/library/unittest.rst:1139
msgid ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"
msgstr ""

#: ../Doc/library/unittest.rst:1139
msgid "``a >= b``"
msgstr ""

#: ../Doc/library/unittest.rst:1142
msgid ":meth:`assertLess(a, b) <TestCase.assertLess>`"
msgstr ""

#: ../Doc/library/unittest.rst:1142
msgid "``a < b``"
msgstr ""

#: ../Doc/library/unittest.rst:1145
msgid ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"
msgstr ""

#: ../Doc/library/unittest.rst:1145
msgid "``a <= b``"
msgstr ""

#: ../Doc/library/unittest.rst:1148
msgid ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"
msgstr ""

#: ../Doc/library/unittest.rst:1148
msgid "``r.search(s)``"
msgstr ""

#: ../Doc/library/unittest.rst:1151
msgid ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"
msgstr ""

#: ../Doc/library/unittest.rst:1151
msgid "``not r.search(s)``"
msgstr ""

#: ../Doc/library/unittest.rst:1154
msgid ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"
msgstr ""

#: ../Doc/library/unittest.rst:1154
msgid ""
"*a* and *b* have the same elements in the same number, regardless of their "
"order."
msgstr ""

#: ../Doc/library/unittest.rst:1163
msgid ""
"Test that *first* and *second* are approximately (or not approximately) "
"equal by computing the difference, rounding to the given number of decimal "
"*places* (default 7), and comparing to zero.  Note that these methods round "
"the values to the given number of *decimal places* (i.e. like the :func:"
"`round` function) and not *significant digits*."
msgstr ""

#: ../Doc/library/unittest.rst:1169
msgid ""
"If *delta* is supplied instead of *places* then the difference between "
"*first* and *second* must be less or equal to (or greater than) *delta*."
msgstr ""

#: ../Doc/library/unittest.rst:1172
msgid "Supplying both *delta* and *places* raises a :exc:`TypeError`."
msgstr ""

#: ../Doc/library/unittest.rst:1174
msgid ""
":meth:`assertAlmostEqual` automatically considers almost equal objects that "
"compare equal.  :meth:`assertNotAlmostEqual` automatically fails if the "
"objects compare equal.  Added the *delta* keyword argument."
msgstr ""

#: ../Doc/library/unittest.rst:1185
msgid ""
"Test that *first* is respectively >, >=, < or <= than *second* depending on "
"the method name.  If not, the test will fail::"
msgstr ""

#: ../Doc/library/unittest.rst:1197
msgid ""
"Test that a *regex* search matches (or does not match) *text*.  In case of "
"failure, the error message will include the pattern and the *text* (or the "
"pattern and the part of *text* that unexpectedly matched).  *regex* may be a "
"regular expression object or a string containing a regular expression "
"suitable for use by :func:`re.search`."
msgstr ""

#: ../Doc/library/unittest.rst:1203
msgid "Added under the name ``assertRegexpMatches``."
msgstr ""

#: ../Doc/library/unittest.rst:1205
msgid ""
"The method ``assertRegexpMatches()`` has been renamed to :meth:`."
"assertRegex`."
msgstr ""

#: ../Doc/library/unittest.rst:1208
msgid ":meth:`.assertNotRegex`."
msgstr ""

#: ../Doc/library/unittest.rst:1210
msgid ""
"The name ``assertNotRegexpMatches`` is a deprecated alias for :meth:`."
"assertNotRegex`."
msgstr ""

#: ../Doc/library/unittest.rst:1217
msgid ""
"Test that sequence *first* contains the same elements as *second*, "
"regardless of their order. When they don't, an error message listing the "
"differences between the sequences will be generated."
msgstr ""

#: ../Doc/library/unittest.rst:1221
msgid ""
"Duplicate elements are *not* ignored when comparing *first* and *second*. It "
"verifies whether each element has the same count in both sequences. "
"Equivalent to: ``assertEqual(Counter(list(first)), Counter(list(second)))`` "
"but works with sequences of unhashable objects as well."
msgstr ""

#: ../Doc/library/unittest.rst:1232
msgid ""
"The :meth:`assertEqual` method dispatches the equality check for objects of "
"the same type to different type-specific methods.  These methods are already "
"implemented for most of the built-in types, but it's also possible to "
"register new methods using :meth:`addTypeEqualityFunc`:"
msgstr ""

#: ../Doc/library/unittest.rst:1239
msgid ""
"Registers a type-specific method called by :meth:`assertEqual` to check if "
"two objects of exactly the same *typeobj* (not subclasses) compare equal.  "
"*function* must take two positional arguments and a third msg=None keyword "
"argument just as :meth:`assertEqual` does.  It must raise :data:`self."
"failureException(msg) <failureException>` when inequality between the first "
"two parameters is detected -- possibly providing useful information and "
"explaining the inequalities in details in the error message."
msgstr ""

#: ../Doc/library/unittest.rst:1250
msgid ""
"The list of type-specific methods automatically used by :meth:`~TestCase."
"assertEqual` are summarized in the following table.  Note that it's usually "
"not necessary to invoke these methods directly."
msgstr ""

#: ../Doc/library/unittest.rst:1255
msgid "Used to compare"
msgstr ""

#: ../Doc/library/unittest.rst:1257
msgid ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"
msgstr ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"

#: ../Doc/library/unittest.rst:1257
msgid "strings"
msgstr "strings"

#: ../Doc/library/unittest.rst:1260
msgid ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"
msgstr ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"

#: ../Doc/library/unittest.rst:1260
msgid "sequences"
msgstr "sequences"

#: ../Doc/library/unittest.rst:1263
msgid ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"
msgstr ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"

#: ../Doc/library/unittest.rst:1263
msgid "lists"
msgstr "lists"

#: ../Doc/library/unittest.rst:1266
msgid ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"
msgstr ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"

#: ../Doc/library/unittest.rst:1266
msgid "tuples"
msgstr "tuples"

#: ../Doc/library/unittest.rst:1269
msgid ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"
msgstr ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"

#: ../Doc/library/unittest.rst:1269
msgid "sets or frozensets"
msgstr "sets or frozensets"

#: ../Doc/library/unittest.rst:1272
msgid ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"
msgstr ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"

#: ../Doc/library/unittest.rst:1272
msgid "dicts"
msgstr "Dicts"

#: ../Doc/library/unittest.rst:1280
msgid ""
"Test that the multiline string *first* is equal to the string *second*. When "
"not equal a diff of the two strings highlighting the differences will be "
"included in the error message. This method is used by default when comparing "
"strings with :meth:`assertEqual`."
msgstr ""

#: ../Doc/library/unittest.rst:1290
msgid ""
"Tests that two sequences are equal.  If a *seq_type* is supplied, both "
"*first* and *second* must be instances of *seq_type* or a failure will be "
"raised.  If the sequences are different an error message is constructed that "
"shows the difference between the two."
msgstr ""

#: ../Doc/library/unittest.rst:1295
msgid ""
"This method is not called directly by :meth:`assertEqual`, but it's used to "
"implement :meth:`assertListEqual` and :meth:`assertTupleEqual`."
msgstr ""

#: ../Doc/library/unittest.rst:1305
msgid ""
"Tests that two lists or tuples are equal.  If not, an error message is "
"constructed that shows only the differences between the two.  An error is "
"also raised if either of the parameters are of the wrong type. These methods "
"are used by default when comparing lists or tuples with :meth:`assertEqual`."
msgstr ""

#: ../Doc/library/unittest.rst:1316
msgid ""
"Tests that two sets are equal.  If not, an error message is constructed that "
"lists the differences between the sets.  This method is used by default when "
"comparing sets or frozensets with :meth:`assertEqual`."
msgstr ""

#: ../Doc/library/unittest.rst:1320
msgid ""
"Fails if either of *first* or *second* does not have a :meth:`set."
"difference` method."
msgstr ""

#: ../Doc/library/unittest.rst:1328
msgid ""
"Test that two dictionaries are equal.  If not, an error message is "
"constructed that shows the differences in the dictionaries. This method will "
"be used by default to compare dictionaries in calls to :meth:`assertEqual`."
msgstr ""

#: ../Doc/library/unittest.rst:1339
msgid ""
"Finally the :class:`TestCase` provides the following methods and attributes:"
msgstr ""

#: ../Doc/library/unittest.rst:1344
msgid ""
"Signals a test failure unconditionally, with *msg* or ``None`` for the error "
"message."
msgstr ""

#: ../Doc/library/unittest.rst:1350
msgid ""
"This class attribute gives the exception raised by the test method.  If a "
"test framework needs to use a specialized exception, possibly to carry "
"additional information, it must subclass this exception in order to \"play "
"fair\" with the framework.  The initial value of this attribute is :exc:"
"`AssertionError`."
msgstr ""

#: ../Doc/library/unittest.rst:1359
msgid ""
"This class attribute determines what happens when a custom failure message "
"is passed as the msg argument to an assertXYY call that fails. ``True`` is "
"the default value. In this case, the custom message is appended to the end "
"of the standard failure message. When set to ``False``, the custom message "
"replaces the standard message."
msgstr ""

#: ../Doc/library/unittest.rst:1365
msgid ""
"The class setting can be overridden in individual test methods by assigning "
"an instance attribute, self.longMessage, to ``True`` or ``False`` before "
"calling the assert methods."
msgstr ""

#: ../Doc/library/unittest.rst:1369
msgid "The class setting gets reset before each test call."
msgstr ""

#: ../Doc/library/unittest.rst:1376
msgid ""
"This attribute controls the maximum length of diffs output by assert methods "
"that report diffs on failure. It defaults to 80*8 characters. Assert methods "
"affected by this attribute are :meth:`assertSequenceEqual` (including all "
"the sequence comparison methods that delegate to it), :meth:"
"`assertDictEqual` and :meth:`assertMultiLineEqual`."
msgstr ""

#: ../Doc/library/unittest.rst:1383
msgid ""
"Setting ``maxDiff`` to ``None`` means that there is no maximum length of "
"diffs."
msgstr ""

#: ../Doc/library/unittest.rst:1389
msgid ""
"Testing frameworks can use the following methods to collect information on "
"the test:"
msgstr ""

#: ../Doc/library/unittest.rst:1395
msgid ""
"Return the number of tests represented by this test object.  For :class:"
"`TestCase` instances, this will always be ``1``."
msgstr ""

#: ../Doc/library/unittest.rst:1401
msgid ""
"Return an instance of the test result class that should be used for this "
"test case class (if no other result instance is provided to the :meth:`run` "
"method)."
msgstr ""

#: ../Doc/library/unittest.rst:1405
msgid ""
"For :class:`TestCase` instances, this will always be an instance of :class:"
"`TestResult`; subclasses of :class:`TestCase` should override this as "
"necessary."
msgstr ""

#: ../Doc/library/unittest.rst:1412
msgid ""
"Return a string identifying the specific test case.  This is usually the "
"full name of the test method, including the module and class name."
msgstr ""

#: ../Doc/library/unittest.rst:1418
msgid ""
"Returns a description of the test, or ``None`` if no description has been "
"provided.  The default implementation of this method returns the first line "
"of the test method's docstring, if available, or ``None``."
msgstr ""

#: ../Doc/library/unittest.rst:1423
msgid ""
"In 3.1 this was changed to add the test name to the short description even "
"in the presence of a docstring.  This caused compatibility issues with "
"unittest extensions and adding the test name was moved to the :class:"
"`TextTestResult` in Python 3.2."
msgstr ""

#: ../Doc/library/unittest.rst:1432
msgid ""
"Add a function to be called after :meth:`tearDown` to cleanup resources used "
"during the test. Functions will be called in reverse order to the order they "
"are added (:abbr:`LIFO (last-in, first-out)`).  They are called with any "
"arguments and keyword arguments passed into :meth:`addCleanup` when they are "
"added."
msgstr ""

#: ../Doc/library/unittest.rst:1438
msgid ""
"If :meth:`setUp` fails, meaning that :meth:`tearDown` is not called, then "
"any cleanup functions added will still be called."
msgstr ""

#: ../Doc/library/unittest.rst:1446
msgid ""
"This method is called unconditionally after :meth:`tearDown`, or after :meth:"
"`setUp` if :meth:`setUp` raises an exception."
msgstr ""

#: ../Doc/library/unittest.rst:1449
msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addCleanup`. If you need cleanup functions to be called *prior* to :meth:"
"`tearDown` then you can call :meth:`doCleanups` yourself."
msgstr ""

#: ../Doc/library/unittest.rst:1454
msgid ""
":meth:`doCleanups` pops methods off the stack of cleanup functions one at a "
"time, so it can be called at any time."
msgstr ""

#: ../Doc/library/unittest.rst:1461
msgid ""
"Add a function to be called after :meth:`tearDownClass` to cleanup resources "
"used during the test class. Functions will be called in reverse order to the "
"order they are added (:abbr:`LIFO (last-in, first-out)`). They are called "
"with any arguments and keyword arguments passed into :meth:`addClassCleanup` "
"when they are added."
msgstr ""

#: ../Doc/library/unittest.rst:1467
msgid ""
"If :meth:`setUpClass` fails, meaning that :meth:`tearDownClass` is not "
"called, then any cleanup functions added will still be called."
msgstr ""

#: ../Doc/library/unittest.rst:1475
msgid ""
"This method is called unconditionally after :meth:`tearDownClass`, or after :"
"meth:`setUpClass` if :meth:`setUpClass` raises an exception."
msgstr ""

#: ../Doc/library/unittest.rst:1478
msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addCleanupClass`. If you need cleanup functions to be called *prior* to :"
"meth:`tearDownClass` then you can call :meth:`doCleanupsClass` yourself."
msgstr ""

#: ../Doc/library/unittest.rst:1483
msgid ""
":meth:`doCleanupsClass` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ""

#: ../Doc/library/unittest.rst:1491
msgid ""
"This class provides an API similar to :class:`TestCase` and also accepts "
"coroutines as test functions."
msgstr ""

#: ../Doc/library/unittest.rst:1498
msgid ""
"Method called to prepare the test fixture. This is called after :meth:"
"`setUp`. This is called immediately before calling the test method; other "
"than :exc:`AssertionError` or :exc:`SkipTest`, any exception raised by this "
"method will be considered an error rather than a test failure. The default "
"implementation does nothing."
msgstr ""

#: ../Doc/library/unittest.rst:1506
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called before :meth:`tearDown`. This is called "
"even if the test method raised an exception, so the implementation in "
"subclasses may need to be particularly careful about checking internal "
"state.  Any exception, other than :exc:`AssertionError` or :exc:`SkipTest`, "
"raised by this method will be considered an additional error rather than a "
"test failure (thus increasing the total number of reported errors). This "
"method will only be called if the :meth:`asyncSetUp` succeeds, regardless of "
"the outcome of the test method. The default implementation does nothing."
msgstr ""

#: ../Doc/library/unittest.rst:1518
msgid "This method accepts a coroutine that can be used as a cleanup function."
msgstr ""

#: ../Doc/library/unittest.rst:1522
msgid ""
"Sets up a new event loop to run the test, collecting the result into the :"
"class:`TestResult` object passed as *result*.  If *result* is omitted or "
"``None``, a temporary result object is created (by calling the :meth:"
"`defaultTestResult` method) and used. The result object is returned to :meth:"
"`run`'s caller. At the end of the test all the tasks in the event loop are "
"cancelled."
msgstr ""

#: ../Doc/library/unittest.rst:1530
msgid "An example illustrating the order::"
msgstr "Un ejemplo ilustrando el orden::"

#: ../Doc/library/unittest.rst:1566
msgid ""
"After running the test, ``events`` would contain ``[\"setUp\", \"asyncSetUp"
"\", \"test_response\", \"asyncTearDown\", \"tearDown\", \"cleanup\"]``."
msgstr ""

#: ../Doc/library/unittest.rst:1571
msgid ""
"This class implements the portion of the :class:`TestCase` interface which "
"allows the test runner to drive the test, but does not provide the methods "
"which test code can use to check and report errors.  This is used to create "
"test cases using legacy test code, allowing it to be integrated into a :mod:"
"`unittest`-based test framework."
msgstr ""

#: ../Doc/library/unittest.rst:1581
msgid "Deprecated aliases"
msgstr "Alias deprecados"

#: ../Doc/library/unittest.rst:1583
msgid ""
"For historical reasons, some of the :class:`TestCase` methods had one or "
"more aliases that are now deprecated.  The following table lists the correct "
"names along with their deprecated aliases:"
msgstr ""

#: ../Doc/library/unittest.rst:1588
msgid "Method Name"
msgstr "Nombre del método"

#: ../Doc/library/unittest.rst:1588
msgid "Deprecated alias"
msgstr "Alias deprecado"

#: ../Doc/library/unittest.rst:1590
msgid ":meth:`.assertEqual`"
msgstr ":meth:`.assertEqual`"

#: ../Doc/library/unittest.rst:1590
msgid "failUnlessEqual"
msgstr "failUnlessEqual"

#: ../Doc/library/unittest.rst:1590
msgid "assertEquals"
msgstr "assertEquals"

#: ../Doc/library/unittest.rst:1591
msgid ":meth:`.assertNotEqual`"
msgstr ":meth:`.assertNotEqual`"

#: ../Doc/library/unittest.rst:1591
msgid "failIfEqual"
msgstr "failIfEqual"

#: ../Doc/library/unittest.rst:1591
msgid "assertNotEquals"
msgstr "assertNotEquals"

#: ../Doc/library/unittest.rst:1592
msgid ":meth:`.assertTrue`"
msgstr ":meth:`.assertTrue`"

#: ../Doc/library/unittest.rst:1592
msgid "failUnless"
msgstr "failUnless"

#: ../Doc/library/unittest.rst:1592
msgid "assert\\_"
msgstr "assert\\_"

#: ../Doc/library/unittest.rst:1593
msgid ":meth:`.assertFalse`"
msgstr ":meth:`.assertFalse`"

#: ../Doc/library/unittest.rst:1593
msgid "failIf"
msgstr "failIf"

#: ../Doc/library/unittest.rst:1594
msgid ":meth:`.assertRaises`"
msgstr ":meth:`.assertRaises`"

#: ../Doc/library/unittest.rst:1594
msgid "failUnlessRaises"
msgstr "failUnlessRaises"

#: ../Doc/library/unittest.rst:1595
msgid ":meth:`.assertAlmostEqual`"
msgstr ":meth:`.assertAlmostEqual`"

#: ../Doc/library/unittest.rst:1595
msgid "failUnlessAlmostEqual"
msgstr "failUnlessAlmostEqual"

#: ../Doc/library/unittest.rst:1595
msgid "assertAlmostEquals"
msgstr "assertAlmostEquals"

#: ../Doc/library/unittest.rst:1596
msgid ":meth:`.assertNotAlmostEqual`"
msgstr ":meth:`.assertNotAlmostEqual`"

#: ../Doc/library/unittest.rst:1596
msgid "failIfAlmostEqual"
msgstr "failIfAlmostEqual"

#: ../Doc/library/unittest.rst:1596
msgid "assertNotAlmostEquals"
msgstr "assertNotAlmostEquals"

#: ../Doc/library/unittest.rst:1597
msgid ":meth:`.assertRegex`"
msgstr ":meth:`.assertRegex`"

#: ../Doc/library/unittest.rst:1597
msgid "assertRegexpMatches"
msgstr "assertRegexpMatches"

#: ../Doc/library/unittest.rst:1598
msgid ":meth:`.assertNotRegex`"
msgstr ":meth:`.assertNotRegex`"

#: ../Doc/library/unittest.rst:1598
msgid "assertNotRegexpMatches"
msgstr "assertNotRegexpMatches"

#: ../Doc/library/unittest.rst:1599
msgid ":meth:`.assertRaisesRegex`"
msgstr ":meth:`.assertRaisesRegex`"

#: ../Doc/library/unittest.rst:1599
msgid "assertRaisesRegexp"
msgstr "assertRaisesRegexp"

#: ../Doc/library/unittest.rst:1602
msgid "The fail* aliases listed in the second column have been deprecated."
msgstr ""

#: ../Doc/library/unittest.rst:1604
msgid "The assert* aliases listed in the third column have been deprecated."
msgstr ""

#: ../Doc/library/unittest.rst:1606
msgid ""
"``assertRegexpMatches`` and ``assertRaisesRegexp`` have been renamed to :"
"meth:`.assertRegex` and :meth:`.assertRaisesRegex`."
msgstr ""

#: ../Doc/library/unittest.rst:1609
msgid ""
"The ``assertNotRegexpMatches`` name is deprecated in favor of :meth:`."
"assertNotRegex`."
msgstr ""

#: ../Doc/library/unittest.rst:1615
msgid "Grouping tests"
msgstr "Agrupando tests"

#: ../Doc/library/unittest.rst:1619
msgid ""
"This class represents an aggregation of individual test cases and test "
"suites. The class presents the interface needed by the test runner to allow "
"it to be run as any other test case.  Running a :class:`TestSuite` instance "
"is the same as iterating over the suite, running each test individually."
msgstr ""

#: ../Doc/library/unittest.rst:1624
msgid ""
"If *tests* is given, it must be an iterable of individual test cases or "
"other test suites that will be used to build the suite initially. Additional "
"methods are provided to add test cases and suites to the collection later on."
msgstr ""

#: ../Doc/library/unittest.rst:1628
msgid ""
":class:`TestSuite` objects behave much like :class:`TestCase` objects, "
"except they do not actually implement a test.  Instead, they are used to "
"aggregate tests into groups of tests that should be run together. Some "
"additional methods are available to add tests to :class:`TestSuite` "
"instances:"
msgstr ""

#: ../Doc/library/unittest.rst:1636
msgid "Add a :class:`TestCase` or :class:`TestSuite` to the suite."
msgstr ""

#: ../Doc/library/unittest.rst:1641
msgid ""
"Add all the tests from an iterable of :class:`TestCase` and :class:"
"`TestSuite` instances to this test suite."
msgstr ""

#: ../Doc/library/unittest.rst:1644
msgid ""
"This is equivalent to iterating over *tests*, calling :meth:`addTest` for "
"each element."
msgstr ""

#: ../Doc/library/unittest.rst:1647
msgid ":class:`TestSuite` shares the following methods with :class:`TestCase`:"
msgstr ""

#: ../Doc/library/unittest.rst:1652
msgid ""
"Run the tests associated with this suite, collecting the result into the "
"test result object passed as *result*.  Note that unlike :meth:`TestCase."
"run`, :meth:`TestSuite.run` requires the result object to be passed in."
msgstr ""

#: ../Doc/library/unittest.rst:1660
msgid ""
"Run the tests associated with this suite without collecting the result. This "
"allows exceptions raised by the test to be propagated to the caller and can "
"be used to support running tests under a debugger."
msgstr ""

#: ../Doc/library/unittest.rst:1667
msgid ""
"Return the number of tests represented by this test object, including all "
"individual tests and sub-suites."
msgstr ""

#: ../Doc/library/unittest.rst:1673
msgid ""
"Tests grouped by a :class:`TestSuite` are always accessed by iteration. "
"Subclasses can lazily provide tests by overriding :meth:`__iter__`. Note "
"that this method may be called several times on a single suite (for example "
"when counting tests or comparing for equality) so the tests returned by "
"repeated iterations before :meth:`TestSuite.run` must be the same for each "
"call iteration. After :meth:`TestSuite.run`, callers should not rely on the "
"tests returned by this method unless the caller uses a subclass that "
"overrides :meth:`TestSuite._removeTestAtIndex` to preserve test references."
msgstr ""

#: ../Doc/library/unittest.rst:1683
msgid ""
"In earlier versions the :class:`TestSuite` accessed tests directly rather "
"than through iteration, so overriding :meth:`__iter__` wasn't sufficient for "
"providing tests."
msgstr ""

#: ../Doc/library/unittest.rst:1688
msgid ""
"In earlier versions the :class:`TestSuite` held references to each :class:"
"`TestCase` after :meth:`TestSuite.run`. Subclasses can restore that behavior "
"by overriding :meth:`TestSuite._removeTestAtIndex`."
msgstr ""

#: ../Doc/library/unittest.rst:1693
msgid ""
"In the typical usage of a :class:`TestSuite` object, the :meth:`run` method "
"is invoked by a :class:`TestRunner` rather than by the end-user test harness."
msgstr ""

#: ../Doc/library/unittest.rst:1698
msgid "Loading and running tests"
msgstr "Cargando y ejecutando tests"

#: ../Doc/library/unittest.rst:1702
msgid ""
"The :class:`TestLoader` class is used to create test suites from classes and "
"modules.  Normally, there is no need to create an instance of this class; "
"the :mod:`unittest` module provides an instance that can be shared as :data:"
"`unittest.defaultTestLoader`.  Using a subclass or instance, however, allows "
"customization of some configurable properties."
msgstr ""

#: ../Doc/library/unittest.rst:1708
msgid ":class:`TestLoader` objects have the following attributes:"
msgstr ""

#: ../Doc/library/unittest.rst:1713
msgid ""
"A list of the non-fatal errors encountered while loading tests. Not reset by "
"the loader at any point. Fatal errors are signalled by the relevant a method "
"raising an exception to the caller. Non-fatal errors are also indicated by a "
"synthetic test that will raise the original error when run."
msgstr ""

#: ../Doc/library/unittest.rst:1722
msgid ":class:`TestLoader` objects have the following methods:"
msgstr ""

#: ../Doc/library/unittest.rst:1727
msgid ""
"Return a suite of all test cases contained in the :class:`TestCase`\\ -"
"derived :class:`testCaseClass`."
msgstr ""

#: ../Doc/library/unittest.rst:1730
msgid ""
"A test case instance is created for each method named by :meth:"
"`getTestCaseNames`. By default these are the method names beginning with "
"``test``. If :meth:`getTestCaseNames` returns no methods, but the :meth:"
"`runTest` method is implemented, a single test case is created for that "
"method instead."
msgstr ""

#: ../Doc/library/unittest.rst:1739
msgid ""
"Return a suite of all test cases contained in the given module. This method "
"searches *module* for classes derived from :class:`TestCase` and creates an "
"instance of the class for each test method defined for the class."
msgstr ""

#: ../Doc/library/unittest.rst:1746
msgid ""
"While using a hierarchy of :class:`TestCase`\\ -derived classes can be "
"convenient in sharing fixtures and helper functions, defining test methods "
"on base classes that are not intended to be instantiated directly does not "
"play well with this method.  Doing so, however, can be useful when the "
"fixtures are different and defined in subclasses."
msgstr ""

#: ../Doc/library/unittest.rst:1752
msgid ""
"If a module provides a ``load_tests`` function it will be called to load the "
"tests. This allows modules to customize test loading. This is the "
"`load_tests protocol`_.  The *pattern* argument is passed as the third "
"argument to ``load_tests``."
msgstr ""

#: ../Doc/library/unittest.rst:1757
msgid "Support for ``load_tests`` added."
msgstr ""

#: ../Doc/library/unittest.rst:1760
msgid ""
"The undocumented and unofficial *use_load_tests* default argument is "
"deprecated and ignored, although it is still accepted for backward "
"compatibility.  The method also now accepts a keyword-only argument "
"*pattern* which is passed to ``load_tests`` as the third argument."
msgstr ""

#: ../Doc/library/unittest.rst:1769
msgid "Return a suite of all test cases given a string specifier."
msgstr ""

#: ../Doc/library/unittest.rst:1771
msgid ""
"The specifier *name* is a \"dotted name\" that may resolve either to a "
"module, a test case class, a test method within a test case class, a :class:"
"`TestSuite` instance, or a callable object which returns a :class:`TestCase` "
"or :class:`TestSuite` instance.  These checks are applied in the order "
"listed here; that is, a method on a possible test case class will be picked "
"up as \"a test method within a test case class\", rather than \"a callable "
"object\"."
msgstr ""

#: ../Doc/library/unittest.rst:1779
msgid ""
"For example, if you have a module :mod:`SampleTests` containing a :class:"
"`TestCase`\\ -derived class :class:`SampleTestCase` with three test methods "
"(:meth:`test_one`, :meth:`test_two`, and :meth:`test_three`), the specifier "
"``'SampleTests.SampleTestCase'`` would cause this method to return a suite "
"which will run all three test methods. Using the specifier ``'SampleTests."
"SampleTestCase.test_two'`` would cause it to return a test suite which will "
"run only the :meth:`test_two` test method. The specifier can refer to "
"modules and packages which have not been imported; they will be imported as "
"a side-effect."
msgstr ""

#: ../Doc/library/unittest.rst:1789
msgid "The method optionally resolves *name* relative to the given *module*."
msgstr ""

#: ../Doc/library/unittest.rst:1791
msgid ""
"If an :exc:`ImportError` or :exc:`AttributeError` occurs while traversing "
"*name* then a synthetic test that raises that error when run will be "
"returned. These errors are included in the errors accumulated by self.errors."
msgstr ""

#: ../Doc/library/unittest.rst:1800
msgid ""
"Similar to :meth:`loadTestsFromName`, but takes a sequence of names rather "
"than a single name.  The return value is a test suite which supports all the "
"tests defined for each name."
msgstr ""

#: ../Doc/library/unittest.rst:1807
msgid ""
"Return a sorted sequence of method names found within *testCaseClass*; this "
"should be a subclass of :class:`TestCase`."
msgstr ""

#: ../Doc/library/unittest.rst:1813
msgid ""
"Find all the test modules by recursing into subdirectories from the "
"specified start directory, and return a TestSuite object containing them. "
"Only test files that match *pattern* will be loaded. (Using shell style "
"pattern matching.) Only module names that are importable (i.e. are valid "
"Python identifiers) will be loaded."
msgstr ""

#: ../Doc/library/unittest.rst:1819
msgid ""
"All test modules must be importable from the top level of the project. If "
"the start directory is not the top level directory then the top level "
"directory must be specified separately."
msgstr ""

#: ../Doc/library/unittest.rst:1823
msgid ""
"If importing a module fails, for example due to a syntax error, then this "
"will be recorded as a single error and discovery will continue.  If the "
"import failure is due to :exc:`SkipTest` being raised, it will be recorded "
"as a skip instead of an error."
msgstr ""

#: ../Doc/library/unittest.rst:1828
msgid ""
"If a package (a directory containing a file named :file:`__init__.py`) is "
"found, the package will be checked for a ``load_tests`` function. If this "
"exists then it will be called ``package.load_tests(loader, tests, "
"pattern)``. Test discovery takes care to ensure that a package is only "
"checked for tests once during an invocation, even if the load_tests function "
"itself calls ``loader.discover``."
msgstr ""

#: ../Doc/library/unittest.rst:1836
msgid ""
"If ``load_tests`` exists then discovery does *not* recurse into the package, "
"``load_tests`` is responsible for loading all tests in the package."
msgstr ""

#: ../Doc/library/unittest.rst:1840
msgid ""
"The pattern is deliberately not stored as a loader attribute so that "
"packages can continue discovery themselves. *top_level_dir* is stored so "
"``load_tests`` does not need to pass this argument in to ``loader."
"discover()``."
msgstr ""

#: ../Doc/library/unittest.rst:1845
msgid "*start_dir* can be a dotted module name as well as a directory."
msgstr ""

#: ../Doc/library/unittest.rst:1849
msgid ""
"Modules that raise :exc:`SkipTest` on import are recorded as skips,   not "
"errors. Discovery works for :term:`namespace packages <namespace package>`. "
"Paths are sorted before being imported so that execution order is   the same "
"even if the underlying file system's ordering is not   dependent on file "
"name."
msgstr ""

#: ../Doc/library/unittest.rst:1857
msgid ""
"Found packages are now checked for ``load_tests`` regardless of whether "
"their path matches *pattern*, because it is impossible for a package name to "
"match the default pattern."
msgstr ""

#: ../Doc/library/unittest.rst:1863
msgid ""
"The following attributes of a :class:`TestLoader` can be configured either "
"by subclassing or assignment on an instance:"
msgstr ""

#: ../Doc/library/unittest.rst:1869
msgid ""
"String giving the prefix of method names which will be interpreted as test "
"methods.  The default value is ``'test'``."
msgstr ""

#: ../Doc/library/unittest.rst:1872
msgid ""
"This affects :meth:`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` "
"methods."
msgstr ""

#: ../Doc/library/unittest.rst:1878
msgid ""
"Function to be used to compare method names when sorting them in :meth:"
"`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` methods."
msgstr ""

#: ../Doc/library/unittest.rst:1884
msgid ""
"Callable object that constructs a test suite from a list of tests. No "
"methods on the resulting object are needed.  The default value is the :class:"
"`TestSuite` class."
msgstr ""

#: ../Doc/library/unittest.rst:1888 ../Doc/library/unittest.rst:1901
msgid "This affects all the :meth:`loadTestsFrom\\*` methods."
msgstr ""

#: ../Doc/library/unittest.rst:1892
msgid ""
"List of Unix shell-style wildcard test name patterns that test methods have "
"to match to be included in test suites (see ``-v`` option)."
msgstr ""

#: ../Doc/library/unittest.rst:1895
msgid ""
"If this attribute is not ``None`` (the default), all test methods to be "
"included in test suites must match one of the patterns in this list. Note "
"that matches are always performed using :meth:`fnmatch.fnmatchcase`, so "
"unlike patterns passed to the ``-v`` option, simple substring patterns will "
"have to be converted using ``*`` wildcards."
msgstr ""

#: ../Doc/library/unittest.rst:1908
msgid ""
"This class is used to compile information about which tests have succeeded "
"and which have failed."
msgstr ""

#: ../Doc/library/unittest.rst:1911
msgid ""
"A :class:`TestResult` object stores the results of a set of tests.  The :"
"class:`TestCase` and :class:`TestSuite` classes ensure that results are "
"properly recorded; test authors do not need to worry about recording the "
"outcome of tests."
msgstr ""

#: ../Doc/library/unittest.rst:1916
msgid ""
"Testing frameworks built on top of :mod:`unittest` may want access to the :"
"class:`TestResult` object generated by running a set of tests for reporting "
"purposes; a :class:`TestResult` instance is returned by the :meth:"
"`TestRunner.run` method for this purpose."
msgstr ""

#: ../Doc/library/unittest.rst:1921
msgid ""
":class:`TestResult` instances have the following attributes that will be of "
"interest when inspecting the results of running a set of tests:"
msgstr ""

#: ../Doc/library/unittest.rst:1927
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test which raised an "
"unexpected exception."
msgstr ""

#: ../Doc/library/unittest.rst:1933
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test where a failure "
"was explicitly signalled using the :meth:`TestCase.assert\\*` methods."
msgstr ""

#: ../Doc/library/unittest.rst:1939
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding the reason for skipping the test."
msgstr ""

#: ../Doc/library/unittest.rst:1946
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks.  Each tuple represents an expected failure of "
"the test case."
msgstr ""

#: ../Doc/library/unittest.rst:1952
msgid ""
"A list containing :class:`TestCase` instances that were marked as expected "
"failures, but succeeded."
msgstr ""

#: ../Doc/library/unittest.rst:1957
msgid ""
"Set to ``True`` when the execution of tests should stop by :meth:`stop`."
msgstr ""

#: ../Doc/library/unittest.rst:1961
msgid "The total number of tests run so far."
msgstr ""

#: ../Doc/library/unittest.rst:1965
msgid ""
"If set to true, ``sys.stdout`` and ``sys.stderr`` will be buffered in "
"between :meth:`startTest` and :meth:`stopTest` being called. Collected "
"output will only be echoed onto the real ``sys.stdout`` and ``sys.stderr`` "
"if the test fails or errors. Any output is also attached to the failure / "
"error message."
msgstr ""

#: ../Doc/library/unittest.rst:1974
msgid ""
"If set to true :meth:`stop` will be called on the first failure or error, "
"halting the test run."
msgstr ""

#: ../Doc/library/unittest.rst:1981
msgid "If set to true then local variables will be shown in tracebacks."
msgstr ""

#: ../Doc/library/unittest.rst:1987
msgid ""
"Return ``True`` if all tests run so far have passed, otherwise returns "
"``False``."
msgstr ""

#: ../Doc/library/unittest.rst:1990
msgid ""
"Returns ``False`` if there were any :attr:`unexpectedSuccesses` from tests "
"marked with the :func:`expectedFailure` decorator."
msgstr ""

#: ../Doc/library/unittest.rst:1996
msgid ""
"This method can be called to signal that the set of tests being run should "
"be aborted by setting the :attr:`shouldStop` attribute to ``True``. :class:"
"`TestRunner` objects should respect this flag and return without running any "
"additional tests."
msgstr ""

#: ../Doc/library/unittest.rst:2001
msgid ""
"For example, this feature is used by the :class:`TextTestRunner` class to "
"stop the test framework when the user signals an interrupt from the "
"keyboard.  Interactive tools which provide :class:`TestRunner` "
"implementations can use this in a similar manner."
msgstr ""

#: ../Doc/library/unittest.rst:2006
msgid ""
"The following methods of the :class:`TestResult` class are used to maintain "
"the internal data structures, and may be extended in subclasses to support "
"additional reporting requirements.  This is particularly useful in building "
"tools which support interactive reporting while tests are being run."
msgstr ""

#: ../Doc/library/unittest.rst:2014
msgid "Called when the test case *test* is about to be run."
msgstr ""

#: ../Doc/library/unittest.rst:2018
msgid ""
"Called after the test case *test* has been executed, regardless of the "
"outcome."
msgstr ""

#: ../Doc/library/unittest.rst:2023
msgid "Called once before any tests are executed."
msgstr ""

#: ../Doc/library/unittest.rst:2030
msgid "Called once after all tests are executed."
msgstr ""

#: ../Doc/library/unittest.rst:2037
msgid ""
"Called when the test case *test* raises an unexpected exception. *err* is a "
"tuple of the form returned by :func:`sys.exc_info`: ``(type, value, "
"traceback)``."
msgstr ""

#: ../Doc/library/unittest.rst:2041
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`errors` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""

#: ../Doc/library/unittest.rst:2048
msgid ""
"Called when the test case *test* signals a failure. *err* is a tuple of the "
"form returned by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""

#: ../Doc/library/unittest.rst:2051
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`failures` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""

#: ../Doc/library/unittest.rst:2058
msgid "Called when the test case *test* succeeds."
msgstr ""

#: ../Doc/library/unittest.rst:2060
msgid "The default implementation does nothing."
msgstr ""

#: ../Doc/library/unittest.rst:2065
msgid ""
"Called when the test case *test* is skipped.  *reason* is the reason the "
"test gave for skipping."
msgstr ""

#: ../Doc/library/unittest.rst:2068
msgid ""
"The default implementation appends a tuple ``(test, reason)`` to the "
"instance's :attr:`skipped` attribute."
msgstr ""

#: ../Doc/library/unittest.rst:2074
msgid ""
"Called when the test case *test* fails, but was marked with the :func:"
"`expectedFailure` decorator."
msgstr ""

#: ../Doc/library/unittest.rst:2077
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`expectedFailures` attribute, where *formatted_err* is a "
"formatted traceback derived from *err*."
msgstr ""

#: ../Doc/library/unittest.rst:2084
msgid ""
"Called when the test case *test* was marked with the :func:`expectedFailure` "
"decorator, but succeeded."
msgstr ""

#: ../Doc/library/unittest.rst:2087
msgid ""
"The default implementation appends the test to the instance's :attr:"
"`unexpectedSuccesses` attribute."
msgstr ""

#: ../Doc/library/unittest.rst:2093
msgid ""
"Called when a subtest finishes.  *test* is the test case corresponding to "
"the test method.  *subtest* is a custom :class:`TestCase` instance "
"describing the subtest."
msgstr ""

#: ../Doc/library/unittest.rst:2097
msgid ""
"If *outcome* is :const:`None`, the subtest succeeded.  Otherwise, it failed "
"with an exception where *outcome* is a tuple of the form returned by :func:"
"`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""

#: ../Doc/library/unittest.rst:2101
msgid ""
"The default implementation does nothing when the outcome is a success, and "
"records subtest failures as normal failures."
msgstr ""

#: ../Doc/library/unittest.rst:2109
msgid ""
"A concrete implementation of :class:`TestResult` used by the :class:"
"`TextTestRunner`."
msgstr ""

#: ../Doc/library/unittest.rst:2112
msgid ""
"This class was previously named ``_TextTestResult``. The old name still "
"exists as an alias but is deprecated."
msgstr ""

#: ../Doc/library/unittest.rst:2119
msgid ""
"Instance of the :class:`TestLoader` class intended to be shared.  If no "
"customization of the :class:`TestLoader` is needed, this instance can be "
"used instead of repeatedly creating new instances."
msgstr ""

#: ../Doc/library/unittest.rst:2127
msgid ""
"A basic test runner implementation that outputs results to a stream. If "
"*stream* is ``None``, the default, :data:`sys.stderr` is used as the output "
"stream. This class has a few configurable parameters, but is essentially "
"very simple.  Graphical applications which run test suites should provide "
"alternate implementations. Such implementations should accept ``**kwargs`` "
"as the interface to construct runners changes when features are added to "
"unittest."
msgstr ""

#: ../Doc/library/unittest.rst:2134
msgid ""
"By default this runner shows :exc:`DeprecationWarning`, :exc:"
"`PendingDeprecationWarning`, :exc:`ResourceWarning` and :exc:`ImportWarning` "
"even if they are :ref:`ignored by default <warning-ignored>`. Deprecation "
"warnings caused by :ref:`deprecated unittest methods <deprecated-aliases>` "
"are also special-cased and, when the warning filters are ``'default'`` or "
"``'always'``, they will appear only once per-module, in order to avoid too "
"many warning messages.  This behavior can be overridden using Python's :"
"option:`!-Wd` or :option:`!-Wa` options (see :ref:`Warning control <using-on-"
"warnings>`) and leaving *warnings* to ``None``."
msgstr ""

#: ../Doc/library/unittest.rst:2145
msgid "Added the ``warnings`` argument."
msgstr ""

#: ../Doc/library/unittest.rst:2148
msgid ""
"The default stream is set to :data:`sys.stderr` at instantiation time rather "
"than import time."
msgstr ""

#: ../Doc/library/unittest.rst:2152
msgid "Added the tb_locals parameter."
msgstr ""

#: ../Doc/library/unittest.rst:2157
msgid ""
"This method returns the instance of ``TestResult`` used by :meth:`run`. It "
"is not intended to be called directly, but can be overridden in subclasses "
"to provide a custom ``TestResult``."
msgstr ""

#: ../Doc/library/unittest.rst:2161
msgid ""
"``_makeResult()`` instantiates the class or callable passed in the "
"``TextTestRunner`` constructor as the ``resultclass`` argument. It defaults "
"to :class:`TextTestResult` if no ``resultclass`` is provided. The result "
"class is instantiated with the following arguments::"
msgstr ""

#: ../Doc/library/unittest.rst:2170
msgid ""
"This method is the main public interface to the ``TextTestRunner``. This "
"method takes a :class:`TestSuite` or :class:`TestCase` instance. A :class:"
"`TestResult` is created by calling :func:`_makeResult` and the test(s) are "
"run and the results printed to stdout."
msgstr ""

#: ../Doc/library/unittest.rst:2181
msgid ""
"A command-line program that loads a set of tests from *module* and runs "
"them; this is primarily for making test modules conveniently executable. The "
"simplest use for this function is to include the following line at the end "
"of a test script::"
msgstr ""

#: ../Doc/library/unittest.rst:2189
msgid ""
"You can run tests with more detailed information by passing in the verbosity "
"argument::"
msgstr ""

#: ../Doc/library/unittest.rst:2195
msgid ""
"The *defaultTest* argument is either the name of a single test or an "
"iterable of test names to run if no test names are specified via *argv*.  If "
"not specified or ``None`` and no test names are provided via *argv*, all "
"tests found in *module* are run."
msgstr ""

#: ../Doc/library/unittest.rst:2200
msgid ""
"The *argv* argument can be a list of options passed to the program, with the "
"first element being the program name.  If not specified or ``None``, the "
"values of :data:`sys.argv` are used."
msgstr ""

#: ../Doc/library/unittest.rst:2204
msgid ""
"The *testRunner* argument can either be a test runner class or an already "
"created instance of it. By default ``main`` calls :func:`sys.exit` with an "
"exit code indicating success or failure of the tests run."
msgstr ""

#: ../Doc/library/unittest.rst:2208
msgid ""
"The *testLoader* argument has to be a :class:`TestLoader` instance, and "
"defaults to :data:`defaultTestLoader`."
msgstr ""

#: ../Doc/library/unittest.rst:2211
msgid ""
"``main`` supports being used from the interactive interpreter by passing in "
"the argument ``exit=False``. This displays the result on standard output "
"without calling :func:`sys.exit`::"
msgstr ""

#: ../Doc/library/unittest.rst:2218
msgid ""
"The *failfast*, *catchbreak* and *buffer* parameters have the same effect as "
"the same-name `command-line options`_."
msgstr ""

#: ../Doc/library/unittest.rst:2221
msgid ""
"The *warnings* argument specifies the :ref:`warning filter <warning-filter>` "
"that should be used while running the tests.  If it's not specified, it will "
"remain ``None`` if a :option:`!-W` option is passed to :program:`python` "
"(see :ref:`Warning control <using-on-warnings>`), otherwise it will be set "
"to ``'default'``."
msgstr ""

#: ../Doc/library/unittest.rst:2227
msgid ""
"Calling ``main`` actually returns an instance of the ``TestProgram`` class. "
"This stores the result of the tests run as the ``result`` attribute."
msgstr ""

#: ../Doc/library/unittest.rst:2230
msgid "The *exit* parameter was added."
msgstr "El parámetro *exit* fue añadido."

#: ../Doc/library/unittest.rst:2233
msgid ""
"The *verbosity*, *failfast*, *catchbreak*, *buffer* and *warnings* "
"parameters were added."
msgstr ""
"Los parámetros *verbosity*, *failfast*, *catchbreak*, *buffer* y *warnings* "
"fueron añadidos."

#: ../Doc/library/unittest.rst:2237
msgid ""
"The *defaultTest* parameter was changed to also accept an iterable of test "
"names."
msgstr ""

#: ../Doc/library/unittest.rst:2243
msgid "load_tests Protocol"
msgstr "Protocolo load_tests"

#: ../Doc/library/unittest.rst:2247
msgid ""
"Modules or packages can customize how tests are loaded from them during "
"normal test runs or test discovery by implementing a function called "
"``load_tests``."
msgstr ""

#: ../Doc/library/unittest.rst:2250
msgid ""
"If a test module defines ``load_tests`` it will be called by :meth:"
"`TestLoader.loadTestsFromModule` with the following arguments::"
msgstr ""

#: ../Doc/library/unittest.rst:2255
msgid ""
"where *pattern* is passed straight through from ``loadTestsFromModule``.  It "
"defaults to ``None``."
msgstr ""

#: ../Doc/library/unittest.rst:2258
msgid "It should return a :class:`TestSuite`."
msgstr "Debe retornar una :class:`TestSuite`."

#: ../Doc/library/unittest.rst:2260
msgid ""
"*loader* is the instance of :class:`TestLoader` doing the loading. "
"*standard_tests* are the tests that would be loaded by default from the "
"module. It is common for test modules to only want to add or remove tests "
"from the standard set of tests. The third argument is used when loading "
"packages as part of test discovery."
msgstr ""

#: ../Doc/library/unittest.rst:2266
msgid ""
"A typical ``load_tests`` function that loads tests from a specific set of :"
"class:`TestCase` classes may look like::"
msgstr ""

#: ../Doc/library/unittest.rst:2278
msgid ""
"If discovery is started in a directory containing a package, either from the "
"command line or by calling :meth:`TestLoader.discover`, then the package :"
"file:`__init__.py` will be checked for ``load_tests``.  If that function "
"does not exist, discovery will recurse into the package as though it were "
"just another directory.  Otherwise, discovery of the package's tests will be "
"left up to ``load_tests`` which is called with the following arguments::"
msgstr ""

#: ../Doc/library/unittest.rst:2287
msgid ""
"This should return a :class:`TestSuite` representing all the tests from the "
"package. (``standard_tests`` will only contain tests collected from :file:"
"`__init__.py`.)"
msgstr ""

#: ../Doc/library/unittest.rst:2291
msgid ""
"Because the pattern is passed into ``load_tests`` the package is free to "
"continue (and potentially modify) test discovery. A 'do nothing' "
"``load_tests`` function for a test package would look like::"
msgstr ""

#: ../Doc/library/unittest.rst:2302
msgid ""
"Discovery no longer checks package names for matching *pattern* due to the "
"impossibility of package names matching the default pattern."
msgstr ""

#: ../Doc/library/unittest.rst:2309
msgid "Class and Module Fixtures"
msgstr ""

#: ../Doc/library/unittest.rst:2311
msgid ""
"Class and module level fixtures are implemented in :class:`TestSuite`. When "
"the test suite encounters a test from a new class then :meth:`tearDownClass` "
"from the previous class (if there is one) is called, followed by :meth:"
"`setUpClass` from the new class."
msgstr ""

#: ../Doc/library/unittest.rst:2316
msgid ""
"Similarly if a test is from a different module from the previous test then "
"``tearDownModule`` from the previous module is run, followed by "
"``setUpModule`` from the new module."
msgstr ""

#: ../Doc/library/unittest.rst:2320
msgid ""
"After all the tests have run the final ``tearDownClass`` and "
"``tearDownModule`` are run."
msgstr ""

#: ../Doc/library/unittest.rst:2323
msgid ""
"Note that shared fixtures do not play well with [potential] features like "
"test parallelization and they break test isolation. They should be used with "
"care."
msgstr ""

#: ../Doc/library/unittest.rst:2326
msgid ""
"The default ordering of tests created by the unittest test loaders is to "
"group all tests from the same modules and classes together. This will lead "
"to ``setUpClass`` / ``setUpModule`` (etc) being called exactly once per "
"class and module. If you randomize the order, so that tests from different "
"modules and classes are adjacent to each other, then these shared fixture "
"functions may be called multiple times in a single test run."
msgstr ""

#: ../Doc/library/unittest.rst:2333
msgid ""
"Shared fixtures are not intended to work with suites with non-standard "
"ordering. A ``BaseTestSuite`` still exists for frameworks that don't want to "
"support shared fixtures."
msgstr ""

#: ../Doc/library/unittest.rst:2337
msgid ""
"If there are any exceptions raised during one of the shared fixture "
"functions the test is reported as an error. Because there is no "
"corresponding test instance an ``_ErrorHolder`` object (that has the same "
"interface as a :class:`TestCase`) is created to represent the error. If you "
"are just using the standard unittest test runner then this detail doesn't "
"matter, but if you are a framework author it may be relevant."
msgstr ""

#: ../Doc/library/unittest.rst:2346
msgid "setUpClass and tearDownClass"
msgstr "setUpClass y tearDownClass"

#: ../Doc/library/unittest.rst:2348
msgid "These must be implemented as class methods::"
msgstr ""

#: ../Doc/library/unittest.rst:2361
msgid ""
"If you want the ``setUpClass`` and ``tearDownClass`` on base classes called "
"then you must call up to them yourself. The implementations in :class:"
"`TestCase` are empty."
msgstr ""

#: ../Doc/library/unittest.rst:2365
msgid ""
"If an exception is raised during a ``setUpClass`` then the tests in the "
"class are not run and the ``tearDownClass`` is not run. Skipped classes will "
"not have ``setUpClass`` or ``tearDownClass`` run. If the exception is a :exc:"
"`SkipTest` exception then the class will be reported as having been skipped "
"instead of as an error."
msgstr ""

#: ../Doc/library/unittest.rst:2373
msgid "setUpModule and tearDownModule"
msgstr "setUpModule y tearDownModule"

#: ../Doc/library/unittest.rst:2375
msgid "These should be implemented as functions::"
msgstr "Estos deben ser implementados como funciones::"

#: ../Doc/library/unittest.rst:2383
msgid ""
"If an exception is raised in a ``setUpModule`` then none of the tests in the "
"module will be run and the ``tearDownModule`` will not be run. If the "
"exception is a :exc:`SkipTest` exception then the module will be reported as "
"having been skipped instead of as an error."
msgstr ""

#: ../Doc/library/unittest.rst:2388
msgid ""
"To add cleanup code that must be run even in the case of an exception, use "
"``addModuleCleanup``:"
msgstr ""

#: ../Doc/library/unittest.rst:2394
msgid ""
"Add a function to be called after :func:`tearDownModule` to cleanup "
"resources used during the test class. Functions will be called in reverse "
"order to the order they are added (:abbr:`LIFO (last-in, first-out)`). They "
"are called with any arguments and keyword arguments passed into :meth:"
"`addModuleCleanup` when they are added."
msgstr ""

#: ../Doc/library/unittest.rst:2400
msgid ""
"If :meth:`setUpModule` fails, meaning that :func:`tearDownModule` is not "
"called, then any cleanup functions added will still be called."
msgstr ""

#: ../Doc/library/unittest.rst:2408
msgid ""
"This function is called unconditionally after :func:`tearDownModule`, or "
"after :func:`setUpModule` if :func:`setUpModule` raises an exception."
msgstr ""

#: ../Doc/library/unittest.rst:2411
msgid ""
"It is responsible for calling all the cleanup functions added by :func:"
"`addCleanupModule`. If you need cleanup functions to be called *prior* to :"
"func:`tearDownModule` then you can call :func:`doModuleCleanups` yourself."
msgstr ""

#: ../Doc/library/unittest.rst:2416
msgid ""
":func:`doModuleCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ""

#: ../Doc/library/unittest.rst:2422
msgid "Signal Handling"
msgstr "Manejo de señales"

#: ../Doc/library/unittest.rst:2426
msgid ""
"The :option:`-c/--catch <unittest -c>` command-line option to unittest, "
"along with the ``catchbreak`` parameter to :func:`unittest.main()`, provide "
"more friendly handling of control-C during a test run. With catch break "
"behavior enabled control-C will allow the currently running test to "
"complete, and the test run will then end and report all the results so far. "
"A second control-c will raise a :exc:`KeyboardInterrupt` in the usual way."
msgstr ""

#: ../Doc/library/unittest.rst:2433
msgid ""
"The control-c handling signal handler attempts to remain compatible with "
"code or tests that install their own :const:`signal.SIGINT` handler. If the "
"``unittest`` handler is called but *isn't* the installed :const:`signal."
"SIGINT` handler, i.e. it has been replaced by the system under test and "
"delegated to, then it calls the default handler. This will normally be the "
"expected behavior by code that replaces an installed handler and delegates "
"to it. For individual tests that need ``unittest`` control-c handling "
"disabled the :func:`removeHandler` decorator can be used."
msgstr ""

#: ../Doc/library/unittest.rst:2442
msgid ""
"There are a few utility functions for framework authors to enable control-c "
"handling functionality within test frameworks."
msgstr ""

#: ../Doc/library/unittest.rst:2447
msgid ""
"Install the control-c handler. When a :const:`signal.SIGINT` is received "
"(usually in response to the user pressing control-c) all registered results "
"have :meth:`~TestResult.stop` called."
msgstr ""

#: ../Doc/library/unittest.rst:2454
msgid ""
"Register a :class:`TestResult` object for control-c handling. Registering a "
"result stores a weak reference to it, so it doesn't prevent the result from "
"being garbage collected."
msgstr ""

#: ../Doc/library/unittest.rst:2458
msgid ""
"Registering a :class:`TestResult` object has no side-effects if control-c "
"handling is not enabled, so test frameworks can unconditionally register all "
"results they create independently of whether or not handling is enabled."
msgstr ""

#: ../Doc/library/unittest.rst:2465
msgid ""
"Remove a registered result. Once a result has been removed then :meth:"
"`~TestResult.stop` will no longer be called on that result object in "
"response to a control-c."
msgstr ""

#: ../Doc/library/unittest.rst:2472
msgid ""
"When called without arguments this function removes the control-c handler if "
"it has been installed. This function can also be used as a test decorator to "
"temporarily remove the handler while the test is being executed::"
msgstr ""
