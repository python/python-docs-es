# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-03-19 11:16+0100\n"
"PO-Revision-Date: 2020-07-28 09:15-0300\n"
"Last-Translator: \n"
"Language: es_AR\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../Doc/library/logging.handlers.rst:2
msgid ":mod:`logging.handlers` --- Logging handlers"
msgstr ":mod:`logging.handlers` --- Gestores de *logging*"

#: ../Doc/library/logging.handlers.rst:10
msgid "**Source code:** :source:`Lib/logging/handlers.py`"
msgstr "**Código fuente** :source:`Lib/logging/handlers.py`"

#: ../Doc/library/logging.handlers.rst:14
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr ""
"Esta página contiene solo información de referencia. Para tutoriales por "
"favor véase"

#: ../Doc/library/logging.handlers.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Tutorial Básico <logging-basic-tutorial>`"

#: ../Doc/library/logging.handlers.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Tutorial avanzado <logging-advanced-tutorial>`"

#: ../Doc/library/logging.handlers.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`Libro de cocina de *Logging* <logging-cookbook>`"

#: ../Doc/library/logging.handlers.rst:25
msgid ""
"The following useful handlers are provided in the package. Note that three "
"of the handlers (:class:`StreamHandler`, :class:`FileHandler` and :class:"
"`NullHandler`) are actually defined in the :mod:`logging` module itself, but "
"have been documented here along with the other handlers."
msgstr ""
"Estos gestores son muy útiles y están provistos en este paquete. Nota que "
"tres de los gestores de las clases (:class:`StreamHandler`, :class:"
"`FileHandler` and :class:`NullHandler`) están definidos en propio módulo :"
"mod:`logging` pero fueron documentados aquí junto con los otros gestores."

#: ../Doc/library/logging.handlers.rst:33
msgid "StreamHandler"
msgstr "StreamHandler"

#: ../Doc/library/logging.handlers.rst:35
msgid ""
"The :class:`StreamHandler` class, located in the core :mod:`logging` "
"package, sends logging output to streams such as *sys.stdout*, *sys.stderr* "
"or any file-like object (or, more precisely, any object which supports :meth:"
"`write` and :meth:`flush` methods)."
msgstr ""
"La clase :class:`StreamHandler` ubicada en el paquete núcleo :mod:`logging` "
"envía la salida del *logging* a un *stream* como *sys.stdout*, *sys.stderr* "
"o cualquier objeto tipo archivo (o mas precisamente cualquier objeto que "
"soporte los métodos :meth:`write` y :meth:`flush`)."

#: ../Doc/library/logging.handlers.rst:43
msgid ""
"Returns a new instance of the :class:`StreamHandler` class. If *stream* is "
"specified, the instance will use it for logging output; otherwise, *sys."
"stderr* will be used."
msgstr ""
"Retorna una nueva instancia de la clase :class:`StreamHandler`. Si *stream* "
"esta especificado, la instancia lo usará para la salida del registro, sino "
"se usará *sys.stderr*."

#: ../Doc/library/logging.handlers.rst:50
#, fuzzy
msgid ""
"If a formatter is specified, it is used to format the record. The record is "
"then written to the stream followed by :attr:`terminator`. If exception "
"information is present, it is formatted using :func:`traceback."
"print_exception` and appended to the stream."
msgstr ""
"Si esta especificado un formateador se usará para formatear el registro. "
"Luego se escribe el registro al *stream* con un terminador. Si hay "
"información de excepción presente, se formateará usando :func:`traceback."
"print_exception` y se añadirá al *stream*."

#: ../Doc/library/logging.handlers.rst:58
msgid ""
"Flushes the stream by calling its :meth:`flush` method. Note that the :meth:"
"`close` method is inherited from :class:`~logging.Handler` and so does no "
"output, so an explicit :meth:`flush` call may be needed at times."
msgstr ""
"Descarga el *stream* llamando a su método :meth:`flush`. Nota que el método :"
"meth:`close` es heredado de la clase :class:`~logging.Handler` y por lo "
"tanto no produce ninguna salida. Por eso muchas veces será necesario invocar "
"al método explícito :meth:`flush`."

#: ../Doc/library/logging.handlers.rst:64
msgid ""
"Sets the instance's stream to the specified value, if it is different. The "
"old stream is flushed before the new stream is set."
msgstr ""
"Establece el *stream* de la instancia a un valor especifico, si este es "
"diferente. El anterior *stream* es vaciado antes de que el nuevo *stream* "
"sea establecido."

#: ../Doc/library/logging.handlers.rst
msgid "Parameters"
msgstr "Parámetros"

#: ../Doc/library/logging.handlers.rst:67
msgid "The stream that the handler should use."
msgstr "El *stream* que el gestor debe usar."

#: ../Doc/library/logging.handlers.rst
msgid "Returns"
msgstr "Retorna"

#: ../Doc/library/logging.handlers.rst:69
msgid "the old stream, if the stream was changed, or *None* if it wasn't."
msgstr "el anterior *stream*. si el *stream* cambió o *None* si no cambió."

#: ../Doc/library/logging.handlers.rst:75
msgid ""
"String used as the terminator when writing a formatted record to a stream. "
"Default value is ``'\\n'``."
msgstr ""

#: ../Doc/library/logging.handlers.rst:78
msgid ""
"If you don't want a newline termination, you can set the handler instance's "
"``terminator`` attribute to the empty string."
msgstr ""

#: ../Doc/library/logging.handlers.rst:81
msgid "In earlier versions, the terminator was hardcoded as ``'\\n'``."
msgstr ""

#: ../Doc/library/logging.handlers.rst:89
msgid "FileHandler"
msgstr "FileHandler"

#: ../Doc/library/logging.handlers.rst:91
msgid ""
"The :class:`FileHandler` class, located in the core :mod:`logging` package, "
"sends logging output to a disk file.  It inherits the output functionality "
"from :class:`StreamHandler`."
msgstr ""
"La clase :class:`FileHandler` está localizada en el paquete núcleo :mod:"
"`logging`, envía la salida del *logging* a un archivo de disco. Hereda la "
"funcionalidad de salida de la clase :class:`StreamHandler`."

#: ../Doc/library/logging.handlers.rst:98
#, fuzzy
msgid ""
"Returns a new instance of the :class:`FileHandler` class. The specified file "
"is opened and used as the stream for logging. If *mode* is not specified, :"
"const:`'a'` is used.  If *encoding* is not ``None``, it is used to open the "
"file with that encoding.  If *delay* is true, then file opening is deferred "
"until the first call to :meth:`emit`. By default, the file grows "
"indefinitely. If *errors* is specified, it's used to determine how encoding "
"errors are handled."
msgstr ""
"Retorna una nueva instancia de la clase :class:`FileHandler`. Abre el "
"archivo especificado y se usa como un *stream* para *logging*. si *mode* no "
"se especifica se usa :const:`'a'` . Si *encoding* no es ``None``, se usará "
"para abrir el archivo con esa codificación. Si *delay* es *true* entonces se "
"difiere la apertura del archivo hasta la primer llamada al método :meth:"
"`emit`. Por defecto el archivo crece indefinidamente."

#: ../Doc/library/logging.handlers.rst:105
#: ../Doc/library/logging.handlers.rst:187
#: ../Doc/library/logging.handlers.rst:322
#: ../Doc/library/logging.handlers.rst:428
msgid ""
"As well as string values, :class:`~pathlib.Path` objects are also accepted "
"for the *filename* argument."
msgstr ""
"Así como valores de cadena de caracteres, también se aceptan objetos de la "
"clase :class:`~pathlib.Path` para el argumento \"*filename*\"."

#: ../Doc/library/logging.handlers.rst:109
#: ../Doc/library/logging.handlers.rst:191
#: ../Doc/library/logging.handlers.rst:326
#: ../Doc/library/logging.handlers.rst:432
#, fuzzy
msgid "The *errors* parameter was added."
msgstr "Se agregó el parámetro *context*."

#: ../Doc/library/logging.handlers.rst:114
msgid "Closes the file."
msgstr "Cierra el archivo."

#: ../Doc/library/logging.handlers.rst:118
msgid "Outputs the record to the file."
msgstr "Da la salida del registro al archivo."

#: ../Doc/library/logging.handlers.rst:124
msgid "NullHandler"
msgstr "NullHandler"

#: ../Doc/library/logging.handlers.rst:128
msgid ""
"The :class:`NullHandler` class, located in the core :mod:`logging` package, "
"does not do any formatting or output. It is essentially a 'no-op' handler "
"for use by library developers."
msgstr ""
"La clase :class:`NullHandler` está ubicada en el núcleo biblioteca :mod:"
"`logging` . No realiza ningún formateo o salida. Es en esencia un gestor 'no-"
"op' para uso de desarrolladores de bibliotecas."

#: ../Doc/library/logging.handlers.rst:134
msgid "Returns a new instance of the :class:`NullHandler` class."
msgstr "Retorna una nueva instancia de la clase :class:`NullHandler`."

#: ../Doc/library/logging.handlers.rst:138
#: ../Doc/library/logging.handlers.rst:142
msgid "This method does nothing."
msgstr "Este método no realiza ninguna acción."

#: ../Doc/library/logging.handlers.rst:146
msgid ""
"This method returns ``None`` for the lock, since there is no underlying I/O "
"to which access needs to be serialized."
msgstr ""
"Este método retorna ``None`` para el bloqueo , dado que no hay una E/S "
"subyacente cuyo acceso se necesite serializar."

#: ../Doc/library/logging.handlers.rst:150
msgid ""
"See :ref:`library-config` for more information on how to use :class:"
"`NullHandler`."
msgstr ""
"Véase :ref:`library-config` para mas información en como usar la clase :"
"class:`NullHandler`."

#: ../Doc/library/logging.handlers.rst:156
msgid "WatchedFileHandler"
msgstr "WatchedFileHandler"

#: ../Doc/library/logging.handlers.rst:160
msgid ""
"The :class:`WatchedFileHandler` class, located in the :mod:`logging."
"handlers` module, is a :class:`FileHandler` which watches the file it is "
"logging to. If the file changes, it is closed and reopened using the file "
"name."
msgstr ""
"La clase :class:`WatchedFileHandler` está ubicada en el módulo :mod:`logging."
"handlers`, es una clase :class:`FileHandler` que vigila a que archivo se "
"está enviando el *logging*. Si el archivo cambia , este se cerrará y se "
"volverá a abrir usando el nombre de archivo."

#: ../Doc/library/logging.handlers.rst:164
msgid ""
"A file change can happen because of usage of programs such as *newsyslog* "
"and *logrotate* which perform log file rotation. This handler, intended for "
"use under Unix/Linux, watches the file to see if it has changed since the "
"last emit. (A file is deemed to have changed if its device or inode have "
"changed.) If the file has changed, the old file stream is closed, and the "
"file opened to get a new stream."
msgstr ""
"Puede suceder que haya un cambio de archivo por uso de programas como "
"*newsyslog* y *logrotate* que realizan una rotación del archivo log. Este "
"gestor destinado para uso bajo Unix/Linux controla el archivo para ver si "
"hubo cambios desde la última emisión. (Un archivo se considera que cambió si "
"su dispositivo o nodo índice cambió). Si el archivo cambió entonces el "
"anterior *stream* de archivo se cerrará, y se abrirá el nuevo para obtener "
"un nuevo *stream*."

#: ../Doc/library/logging.handlers.rst:171
msgid ""
"This handler is not appropriate for use under Windows, because under Windows "
"open log files cannot be moved or renamed - logging opens the files with "
"exclusive locks - and so there is no need for such a handler. Furthermore, "
"*ST_INO* is not supported under Windows; :func:`~os.stat` always returns "
"zero for this value."
msgstr ""
"Este gestor no es apropiado para uso bajo Windows porque bajo Windows los "
"archivos log abiertos no se pueden mover o renombrar. *Logging* abre los "
"archivos con bloqueos exclusivos y entonces no hay necesidad de usar el "
"gestor. Por otra parte *ST_INO* no es soportado bajo Windows. La función :"
"func:`~os.stat` siempre retorna cero para este valor."

#: ../Doc/library/logging.handlers.rst:180
#, fuzzy
msgid ""
"Returns a new instance of the :class:`WatchedFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, :const:`'a'` is used.  If *encoding* is not ``None``, it is "
"used to open the file with that encoding.  If *delay* is true, then file "
"opening is deferred until the first call to :meth:`emit`.  By default, the "
"file grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"Retorna una nueva instancia de la clase :class:`FileHandler`. Abre el "
"archivo especificado y se usa como un *stream* para *logging*. si *mode* no "
"se especifica se usa :const:`'a'` . Si *encoding* no es ``None``, se usará "
"para abrir el archivo con esa codificación. Si *delay* es *true* entonces se "
"difiere la apertura del archivo hasta la primer llamada al método :meth:"
"`emit`. Por defecto el archivo crece indefinidamente."

#: ../Doc/library/logging.handlers.rst:196
msgid ""
"Checks to see if the file has changed.  If it has, the existing stream is "
"flushed and closed and the file opened again, typically as a precursor to "
"outputting the record to the file."
msgstr ""
"Revisa si el archivo cambió. Si hubo cambio, el *stream* existente se vacía "
"y cierra y el archivo se abre nuevamente. Típicamente es un precursor para "
"dar salida del registro a un archivo."

#: ../Doc/library/logging.handlers.rst:205
msgid ""
"Outputs the record to the file, but first calls :meth:`reopenIfNeeded` to "
"reopen the file if it has changed."
msgstr ""
"Da salida al registro a un archivo, pero primero invoca al método :meth:"
"`reopenIfNeeded` para reabrir el archivo si es que cambió."

#: ../Doc/library/logging.handlers.rst:211
msgid "BaseRotatingHandler"
msgstr "BaseRotatingHandler"

#: ../Doc/library/logging.handlers.rst:213
msgid ""
"The :class:`BaseRotatingHandler` class, located in the :mod:`logging."
"handlers` module, is the base class for the rotating file handlers, :class:"
"`RotatingFileHandler` and :class:`TimedRotatingFileHandler`. You should not "
"need to instantiate this class, but it has attributes and methods you may "
"need to override."
msgstr ""
"La clase :class:`BaseRotatingHandler` ubicada en el módulo :mod:`logging."
"handlers` es la clase base para rotar los gestores de archivos de clases :"
"class:`RotatingFileHandler` y :class:`TimedRotatingFileHandler`. No debería "
"ser necesario instanciar esta clase, pero tiene métodos y atributos que "
"quizá se necesiten sobrescribir (*override*)."

#: ../Doc/library/logging.handlers.rst:221
msgid "The parameters are as for :class:`FileHandler`. The attributes are:"
msgstr ""
"Los parámetros son como los de la clase :class:`FileHandler`. Los atributos "
"son:"

#: ../Doc/library/logging.handlers.rst:225
msgid ""
"If this attribute is set to a callable, the :meth:`rotation_filename` method "
"delegates to this callable. The parameters passed to the callable are those "
"passed to :meth:`rotation_filename`."
msgstr ""
"Si este atributo se establece como invocable, el método :meth:"
"`rotation_filename` delega a este invocable. Los parámetros pasados al "
"invocable son aquellos pasados al método :meth:`rotation_filename`."

#: ../Doc/library/logging.handlers.rst:229
msgid ""
"The namer function is called quite a few times during rollover, so it should "
"be as simple and as fast as possible. It should also return the same output "
"every time for a given input, otherwise the rollover behaviour may not work "
"as expected."
msgstr ""
"La función de nombrado es invocada unas cuantas veces durante el volcado "
"(*rollover*) , entonces debe ser tan simple y rápida como sea posible. Debe "
"también retornar siempre la misma salida para una misma entrada, de otra "
"manera el volcado puede no funcionar como se espera."

#: ../Doc/library/logging.handlers.rst:239
msgid ""
"If this attribute is set to a callable, the :meth:`rotate` method delegates "
"to this callable.  The parameters passed to the callable are those passed "
"to :meth:`rotate`."
msgstr ""
"Si este atributo se estableció como invocable, el método :meth:`rotate` "
"delega a este invocable. Los parámetros pasados al invocable son aquellos "
"pasados al método :meth:`rotate`."

#: ../Doc/library/logging.handlers.rst:247
msgid "Modify the filename of a log file when rotating."
msgstr "Modifica el nombre de un archivo log cuando esta rotando."

#: ../Doc/library/logging.handlers.rst:249
msgid "This is provided so that a custom filename can be provided."
msgstr ""
"Esto esta previsto para que pueda usarse un nombre de archivo personalizado."

#: ../Doc/library/logging.handlers.rst:251
msgid ""
"The default implementation calls the 'namer' attribute of the handler, if "
"it's callable, passing the default name to it. If the attribute isn't "
"callable (the default is ``None``), the name is returned unchanged."
msgstr ""
"La implementación por defecto llama al atributo 'namer' del gestor, si este "
"es invocable, pasando el nombre por defecto a él. Si el atributo no es "
"invocable (por defecto es ``None``) el nombre se retorna sin cambios."

#: ../Doc/library/logging.handlers.rst:255
msgid "The default name for the log file."
msgstr "El nombre por defecto para el archivo de log."

#: ../Doc/library/logging.handlers.rst:262
msgid "When rotating, rotate the current log."
msgstr "Cuando está rotando, rotar el actual log."

#: ../Doc/library/logging.handlers.rst:264
msgid ""
"The default implementation calls the 'rotator' attribute of the handler, if "
"it's callable, passing the source and dest arguments to it. If the attribute "
"isn't callable (the default is ``None``), the source is simply renamed to "
"the destination."
msgstr ""
"La implementación por defecto llama al atributo 'rotator' del gestor, si es "
"invocable, pasando los argumentos de origen y destino a él. Si no se puede "
"invocar (porque el atributo por defecto es 'None') el origen es simplemente "
"renombrado al destino."

#: ../Doc/library/logging.handlers.rst:269
msgid ""
"The source filename. This is normally the base filename, e.g. 'test.log'."
msgstr ""
"El nombre de archivo origen . Normalmente el nombre de archivo base, por "
"ejemplo 'test.log'."

#: ../Doc/library/logging.handlers.rst:271
msgid ""
"The destination filename. This is normally what the source is rotated to, e."
"g. 'test.log.1'."
msgstr ""
"El nombre de archivo de destino. Normalmente es el nombre al que se rota el "
"archivo origen por ejemplo 'test.log.1'."

#: ../Doc/library/logging.handlers.rst:276
msgid ""
"The reason the attributes exist is to save you having to subclass - you can "
"use the same callables for instances of :class:`RotatingFileHandler` and :"
"class:`TimedRotatingFileHandler`. If either the namer or rotator callable "
"raises an exception, this will be handled in the same way as any other "
"exception during an :meth:`emit` call, i.e. via the :meth:`handleError` "
"method of the handler."
msgstr ""
"La razón de que existen los atributos es para evitar tener que usar una "
"subclase - puedes usar los mismos invocadores para instancias de clase :"
"class:`RotatingFileHandler` y :class:`TimedRotatingFileHandler`. Si el "
"rotador invocable o la función de nombrado plantean una excepción esta se "
"manejará de la misma manera que cualquier otra excepción durante una llamada "
"al método :meth:`emit` por ejemplo a través del método :meth:`handleError` "
"del gestor."

#: ../Doc/library/logging.handlers.rst:283
msgid ""
"If you need to make more significant changes to rotation processing, you can "
"override the methods."
msgstr ""
"Si necesitas hacer cambios mas significativos al proceso de rotación puedes "
"obviar los métodos."

#: ../Doc/library/logging.handlers.rst:286
msgid "For an example, see :ref:`cookbook-rotator-namer`."
msgstr "Para un ejemplo véase :ref:`cookbook-rotator-namer`."

#: ../Doc/library/logging.handlers.rst:292
msgid "RotatingFileHandler"
msgstr "RotatingFileHandler"

#: ../Doc/library/logging.handlers.rst:294
msgid ""
"The :class:`RotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files."
msgstr ""
"La clase :class:`RotatingFileHandler`, localizada en el módulo :mod:`logging."
"handlers` soporta la rotación de archivos log de disco."

#: ../Doc/library/logging.handlers.rst:300
#, fuzzy
msgid ""
"Returns a new instance of the :class:`RotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is used "
"to open the file with that encoding.  If *delay* is true, then file opening "
"is deferred until the first call to :meth:`emit`.  By default, the file "
"grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"Retorna una nueva instancia de la clase :class:`RotatingFileHandler`. El "
"archivo especificado es abierto y usado como un *stream* para *logging*. Si "
"*mode* no se especifica , se usará ``'a'`` . Si *encoding* no es ``None`` se "
"usará para abrir el archivo con esa codificación. Si *delay* es verdadero "
"entonces la apertura del archivo se diferirá hasta la primer llamada al "
"método :meth:`emit`. Por defecto el archivo crece indefinidamente."

#: ../Doc/library/logging.handlers.rst:307
msgid ""
"You can use the *maxBytes* and *backupCount* values to allow the file to :"
"dfn:`rollover` at a predetermined size. When the size is about to be "
"exceeded, the file is closed and a new file is silently opened for output. "
"Rollover occurs whenever the current log file is nearly *maxBytes* in "
"length; but if either of *maxBytes* or *backupCount* is zero, rollover never "
"occurs, so you generally want to set *backupCount* to at least 1, and have a "
"non-zero *maxBytes*. When *backupCount* is non-zero, the system will save "
"old log files by appending the extensions '.1', '.2' etc., to the filename. "
"For example, with a *backupCount* of 5 and a base file name of :file:`app."
"log`, you would get :file:`app.log`, :file:`app.log.1`, :file:`app.log.2`, "
"up to :file:`app.log.5`. The file being written to is always :file:`app."
"log`.  When this file is filled, it is closed and renamed to :file:`app."
"log.1`, and if files :file:`app.log.1`, :file:`app.log.2`, etc. exist, then "
"they are renamed to :file:`app.log.2`, :file:`app.log.3` etc. respectively."
msgstr ""
"Se pueden usar los valores *maxBytes* y *backupCount* para permitir que el "
"archivo :dfn:`rollover` tenga un tamaño predeterminado. Cuando el tamaño del "
"archivo está a punto de excederse, se cerrará y un nuevo archivo se abrirá "
"silenciosamente para salida. El volcado (*rollover*) ocurre cada vez que el "
"actual archivo log esta cerca de *maxBytes* en tamaño , pero si cualquiera "
"*maxBytes* o *backupCount* es cero, el volcado (*rollover*) no ocurre. Por "
"eso generalmente necesitas establecer *backupCount* por lo menos en 1 y no "
"tener cero en *maxBytes*. Cuando *backupCount* no es cero, el sistema "
"guardará los anteriores archivos log agregando las extensiones '.1', '.2' "
"etc. al nombre del archivo. Por ejemplo con un *backupCount* de 5 y un "
"nombre de archivo base de :file:`app.log`, tendrás como nombre de archivo t :"
"file:`app.log`, :file:`app.log.1`, :file:`app.log.2`, hasta :file:`app."
"log.5`. El archivo que esta siendo escrito es siempre :file:`app.log`. "
"Cuando este se completa , se cierra y se renombra a :file:`app.log.1` y si "
"ya existen :file:`app.log.1`, :file:`app.log.2`, etc. Entonces se renombrará "
"como :file:`app.log.2`, :file:`app.log.3` etc. respectivamente."

#: ../Doc/library/logging.handlers.rst:331
#: ../Doc/library/logging.handlers.rst:437
msgid "Does a rollover, as described above."
msgstr "Realiza un volcado (*rollover*) como se describe arriba."

#: ../Doc/library/logging.handlers.rst:336
msgid ""
"Outputs the record to the file, catering for rollover as described "
"previously."
msgstr ""
"Da la salida del registro al archivo , dando suministro para el volcado "
"(*rollover*) como está descripto anteriormente."

#: ../Doc/library/logging.handlers.rst:342
msgid "TimedRotatingFileHandler"
msgstr "TimedRotatingFileHandler"

#: ../Doc/library/logging.handlers.rst:344
msgid ""
"The :class:`TimedRotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files at certain timed "
"intervals."
msgstr ""
"La clase :class:`TimedRotatingFileHandler` está ubicada en el módulo :mod:"
"`logging.handlers`. Soporta la rotación de archivos de log a ciertos "
"intervalos de tiempo."

#: ../Doc/library/logging.handlers.rst:351
msgid ""
"Returns a new instance of the :class:`TimedRotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. On rotating it "
"also sets the filename suffix. Rotating happens based on the product of "
"*when* and *interval*."
msgstr ""
"Retorna una nueva instancia de la clase :class:`TimedRotatingFileHandler` . "
"El archivo especificado es abierto y usado como *stream* para el historial "
"de log. En la rotación también establece el sufijo del nombre de archivo. La "
"rotación ocurre basada en el producto de *when* y *interval*."

#: ../Doc/library/logging.handlers.rst:356
msgid ""
"You can use the *when* to specify the type of *interval*. The list of "
"possible values is below.  Note that they are not case sensitive."
msgstr ""
"Puedes usar el *when* para especificar el tipo de intervalo *interval*. La "
"lista de posibles valores esta debajo. Nota que no distingue mayúsculas y "
"minúsculas."

#: ../Doc/library/logging.handlers.rst:360
msgid "Value"
msgstr "Valor"

#: ../Doc/library/logging.handlers.rst:360
msgid "Type of interval"
msgstr "Tipo de intervalo"

#: ../Doc/library/logging.handlers.rst:360
msgid "If/how *atTime* is used"
msgstr "Si/como *atTime* es usado"

#: ../Doc/library/logging.handlers.rst:362
msgid "``'S'``"
msgstr "``'S'``"

#: ../Doc/library/logging.handlers.rst:362
msgid "Seconds"
msgstr "Segundos"

#: ../Doc/library/logging.handlers.rst:362
#: ../Doc/library/logging.handlers.rst:364
#: ../Doc/library/logging.handlers.rst:366
#: ../Doc/library/logging.handlers.rst:368
msgid "Ignored"
msgstr "Ignorado"

#: ../Doc/library/logging.handlers.rst:364
msgid "``'M'``"
msgstr "``'M'``"

#: ../Doc/library/logging.handlers.rst:364
msgid "Minutes"
msgstr "Minutos"

#: ../Doc/library/logging.handlers.rst:366
msgid "``'H'``"
msgstr "``'H'``"

#: ../Doc/library/logging.handlers.rst:366
msgid "Hours"
msgstr "Horas"

#: ../Doc/library/logging.handlers.rst:368
msgid "``'D'``"
msgstr "``'D'``"

#: ../Doc/library/logging.handlers.rst:368
msgid "Days"
msgstr "Días"

#: ../Doc/library/logging.handlers.rst:370
msgid "``'W0'-'W6'``"
msgstr "``'W0'-'W6'``"

#: ../Doc/library/logging.handlers.rst:370
msgid "Weekday (0=Monday)"
msgstr "Día de la semana (0=Lunes)"

#: ../Doc/library/logging.handlers.rst:370
#: ../Doc/library/logging.handlers.rst:373
msgid "Used to compute initial rollover time"
msgstr "Usado para calcular la hora inicial del volcado *rollover*"

#: ../Doc/library/logging.handlers.rst:373
msgid "``'midnight'``"
msgstr "``'midnight'``"

#: ../Doc/library/logging.handlers.rst:373
msgid "Roll over at midnight, if *atTime* not specified, else at time *atTime*"
msgstr ""
"Volcado (*rollover*) a medianoche , si *atTime* no está especificado, sino "
"el volcado se hará *atTime*"

#: ../Doc/library/logging.handlers.rst:378
msgid ""
"When using weekday-based rotation, specify 'W0' for Monday, 'W1' for "
"Tuesday, and so on up to 'W6' for Sunday. In this case, the value passed for "
"*interval* isn't used."
msgstr ""
"Cuando se usa rotación basada en día de la semana, especifica 'W0' para "
"Lunes, 'W1' para Martes y así, hasta 'W6' para Domingo. en este caso el "
"valor pasado para *Interval* no se usa."

#: ../Doc/library/logging.handlers.rst:382
#, python-format
msgid ""
"The system will save old log files by appending extensions to the filename. "
"The extensions are date-and-time based, using the strftime format ``%Y-%m-%d_"
"%H-%M-%S`` or a leading portion thereof, depending on the rollover interval."
msgstr ""
"El sistema guardará los archivos de log anteriores agregándoles extensiones "
"al nombre de archivo. Las extensiones están basadas en día-hora usando el "
"formato ``%Y-%m-%d_%H-%M-%S`` o un prefijo respecto el intervalo del volcado "
"(*rollover*)."

#: ../Doc/library/logging.handlers.rst:387
msgid ""
"When computing the next rollover time for the first time (when the handler "
"is created), the last modification time of an existing log file, or else the "
"current time, is used to compute when the next rotation will occur."
msgstr ""
"Cuando se calcula la hora del siguiente volcado (*rollover*) por primera vez "
"(cuando el gestor es creado), la última hora de modificación de un archivo "
"log existente o sino la hora actual, se usa para calcular cuando será la "
"próxima rotación."

#: ../Doc/library/logging.handlers.rst:391
msgid ""
"If the *utc* argument is true, times in UTC will be used; otherwise local "
"time is used."
msgstr ""
"Si el argumento *utc* es *true* se usará la hora en UTC, sino se usará la "
"hora local."

#: ../Doc/library/logging.handlers.rst:394
msgid ""
"If *backupCount* is nonzero, at most *backupCount* files will be kept, and "
"if more would be created when rollover occurs, the oldest one is deleted. "
"The deletion logic uses the interval to determine which files to delete, so "
"changing the interval may leave old files lying around."
msgstr ""
"Si *backupCount* no es cero, se conservará como máximo una cantidad de "
"archivos especificada en *backupCount*,y si son creados más, cuando ocurre "
"el volcado (*rollover*) se borrará el último. La lógica de borrado usa el "
"intervalo para determinar que archivos borrar, pues entonces cambiando el "
"intervalo puede dejar viejos archivos abandonados."

#: ../Doc/library/logging.handlers.rst:399
msgid ""
"If *delay* is true, then file opening is deferred until the first call to :"
"meth:`emit`."
msgstr ""
"Si *delay* es *true* entonces la apertura del archivo se demorará hasta la "
"primer llamada a :meth:`emit`."

#: ../Doc/library/logging.handlers.rst:402
msgid ""
"If *atTime* is not ``None``, it must be a ``datetime.time`` instance which "
"specifies the time of day when rollover occurs, for the cases where rollover "
"is set to happen \"at midnight\" or \"on a particular weekday\". Note that "
"in these cases, the *atTime* value is effectively used to compute the "
"*initial* rollover, and subsequent rollovers would be calculated via the "
"normal interval calculation."
msgstr ""
"Si *atTime* no es \"None\", debe haber una instancia ``datetime.time`` que "
"especifica la hora que ocurre el volcado (*rollover*) , para los casos en "
"que el volcado esta establecido para ocurrir \"a medianoche\" o \"un día en "
"particular\". Nótese que en estos casos el valor *atTime* se usa para "
"calcular el valor *initial* del volcado (*rollover*) y los subsecuentes "
"volcados serán calculados a través del calculo normal de intervalos."

#: ../Doc/library/logging.handlers.rst:409
msgid ""
"If *errors* is specified, it's used to determine how encoding errors are "
"handled."
msgstr ""

#: ../Doc/library/logging.handlers.rst:412
msgid ""
"Calculation of the initial rollover time is done when the handler is "
"initialised. Calculation of subsequent rollover times is done only when "
"rollover occurs, and rollover occurs only when emitting output. If this is "
"not kept in mind, it might lead to some confusion. For example, if an "
"interval of \"every minute\" is set, that does not mean you will always see "
"log files with times (in the filename) separated by a minute; if, during "
"application execution, logging output is generated more frequently than once "
"a minute, *then* you can expect to see log files with times separated by a "
"minute. If, on the other hand, logging messages are only output once every "
"five minutes (say), then there will be gaps in the file times corresponding "
"to the minutes where no output (and hence no rollover) occurred."
msgstr ""
"El cálculo de la hora en que se realizara el volcado (*rollover*) inicial "
"cuando se inicializa el gestor. El cálculo de la hora de los siguientes "
"volcados (*rollovers*) se realiza solo cuando este ocurre, y el volcado "
"ocurre solo cuando se emite una salida. Si esto no se tiene en cuenta puede "
"generar cierta confusión. Por ejemplo si se establece un intervalo de \"cada "
"minuto\" eso no significa que siempre se verán archivos log con hora (en el "
"nombre del archivo) separados por un minuto. Si durante la ejecución de la "
"aplicación el *logging* se genera con mayor frecuencia que un minuto "
"entonces se pueden esperar archivos log separados por un minuto. Si por otro "
"lado los mensajes *logging* son establecidos cada digamos cinco minutos, "
"entonces habrá brechas de tiempo en los archivos correspondientes a los "
"minutos que no hubo salida (y no ocurrió por tanto volcado alguno)."

#: ../Doc/library/logging.handlers.rst:425
msgid "*atTime* parameter was added."
msgstr "Se agregó el parámetro *atTime*."

#: ../Doc/library/logging.handlers.rst:441
msgid ""
"Outputs the record to the file, catering for rollover as described above."
msgstr ""
"Da la salida del registro a un archivo , proveyendo la información para el "
"volcado (*rollover*) como esta descripto anteriormente."

#: ../Doc/library/logging.handlers.rst:447
msgid "SocketHandler"
msgstr "SocketHandler"

#: ../Doc/library/logging.handlers.rst:449
msgid ""
"The :class:`SocketHandler` class, located in the :mod:`logging.handlers` "
"module, sends logging output to a network socket. The base class uses a TCP "
"socket."
msgstr ""
"La clase :class:`SocketHandler` esta localizada en el módulo :mod:`logging."
"handlers`, envía el *logging* a un socket de la red. La clase base usa "
"*sockets* TCP."

#: ../Doc/library/logging.handlers.rst:455
msgid ""
"Returns a new instance of the :class:`SocketHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""
"Retorna una nueva instancia de la clase :class:`SocketHandler` destinada "
"para comunicarse con una terminal remota cuya dirección esta dada por *host* "
"y *port*."

#: ../Doc/library/logging.handlers.rst:458
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a TCP socket is created."
msgstr ""
"Si \"port\" se especifica como``None`` se crea un socket de dominio Unix, "
"usando el valor en``host`` - de otra manera se creará un socket TCP."

#: ../Doc/library/logging.handlers.rst:464
msgid "Closes the socket."
msgstr "Cierra el socket."

#: ../Doc/library/logging.handlers.rst:469
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. If the connection was previously lost, re-establishes the "
"connection. To unpickle the record at the receiving end into a :class:"
"`~logging.LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""
"Serializa (*Pickles*) el registro del diccionario de atributos y lo escribe "
"en el socket en formato binario. Si hay un error con el socket, "
"silenciosamente descarta el paquete. Si la conexión se perdió previamente, "
"la restablece. Para deserializar (*unpickle*) un registro en el extremo "
"receptor a una clase :class:`~logging.LogRecord`, usa la función :func:"
"`~logging.makeLogRecord`."

#: ../Doc/library/logging.handlers.rst:479
msgid ""
"Handles an error which has occurred during :meth:`emit`. The most likely "
"cause is a lost connection. Closes the socket so that we can retry on the "
"next event."
msgstr ""
"Maneja un error que ocurrió durante el método :meth:`emit`. La causa mas "
"común es una perdida de conexión. Cierra el socket para que podamos "
"reintentar en el próximo evento."

#: ../Doc/library/logging.handlers.rst:486
msgid ""
"This is a factory method which allows subclasses to define the precise type "
"of socket they want. The default implementation creates a TCP socket (:const:"
"`socket.SOCK_STREAM`)."
msgstr ""
"Este es un método patrón que permite subclases para definir el tipo preciso "
"de socket que se necesita. La implementación por defecto crea un socket TCP(:"
"const:`socket.SOCK_STREAM`)."

#: ../Doc/library/logging.handlers.rst:493
msgid ""
"Pickles the record's attribute dictionary in binary format with a length "
"prefix, and returns it ready for transmission across the socket. The details "
"of this operation are equivalent to::"
msgstr ""
"Serializa (*pickles*) el registro del diccionario de atributos en formato "
"binario con un prefijo de tamaño, y lo retorna listo para transmitir a "
"través del socket. Los detalles de esta operación son equivalentes a::"

#: ../Doc/library/logging.handlers.rst:501
msgid ""
"Note that pickles aren't completely secure. If you are concerned about "
"security, you may want to override this method to implement a more secure "
"mechanism. For example, you can sign pickles using HMAC and then verify them "
"on the receiving end, or alternatively you can disable unpickling of global "
"objects on the receiving end."
msgstr ""
"Nota que los serializados (*pickles*) no son totalmente seguros. Si te "
"preocupa la seguridad desearás evitar este método para implementar un "
"mecanismo mas seguro. Por ejemplo puedes firmar *pickles* usando HMAC y "
"verificarlos después en el extremo receptor. O alternativamente puedes "
"deshabilitar la deserialización (*unpickling*) de objetos globales en el "
"extremo receptor."

#: ../Doc/library/logging.handlers.rst:510
msgid ""
"Send a pickled byte-string *packet* to the socket. The format of the sent "
"byte-string is as described in the documentation for :meth:`~SocketHandler."
"makePickle`."
msgstr ""
"Envía un paquete serializado (*pickled*) de cadena de caracteres al socket. "
"El formato de la cadena de bytes enviada es tal como se describe en la "
"documentación de :meth:`~SocketHandler.makePickle`."

#: ../Doc/library/logging.handlers.rst:514
msgid ""
"This function allows for partial sends, which can happen when the network is "
"busy."
msgstr ""
"Esta función permite envíos parciales, que pueden ocurrir cuando la red esta "
"ocupada."

#: ../Doc/library/logging.handlers.rst:520
msgid ""
"Tries to create a socket; on failure, uses an exponential back-off "
"algorithm.  On initial failure, the handler will drop the message it was "
"trying to send.  When subsequent messages are handled by the same instance, "
"it will not try connecting until some time has passed.  The default "
"parameters are such that the initial delay is one second, and if after that "
"delay the connection still can't be made, the handler will double the delay "
"each time up to a maximum of 30 seconds."
msgstr ""
"Intenta crear un socket, si hay una falla usa un algoritmo de marcha atrás "
"exponencial. En el fallo inicial el gestor desechará el mensaje que "
"intentaba enviar. Cuando los siguientes mensajes sean gestionados por la "
"misma instancia no intentará conectarse hasta que haya transcurrido cierto "
"tiempo. Los parámetros por defecto son tales que el retardo inicial es un "
"segundo y si después del retardo la conexión todavía no se puede realizar, "
"el gestor doblará el retardo cada vez hasta un máximo de 30 segundos."

#: ../Doc/library/logging.handlers.rst:528
msgid "This behaviour is controlled by the following handler attributes:"
msgstr ""
"Este comportamiento es controlado por los siguientes atributos del gestor:"

#: ../Doc/library/logging.handlers.rst:530
msgid "``retryStart`` (initial delay, defaulting to 1.0 seconds)."
msgstr "``retryStart`` (retardo inicial por defecto 1.0 segundos)"

#: ../Doc/library/logging.handlers.rst:531
msgid "``retryFactor`` (multiplier, defaulting to 2.0)."
msgstr "``retryFactor`` (multiplicador por defecto 2.0)"

#: ../Doc/library/logging.handlers.rst:532
msgid "``retryMax`` (maximum delay, defaulting to 30.0 seconds)."
msgstr "``retryMax`` (máximo retardo por defecto 30.0 segundos)"

#: ../Doc/library/logging.handlers.rst:534
msgid ""
"This means that if the remote listener starts up *after* the handler has "
"been used, you could lose messages (since the handler won't even attempt a "
"connection until the delay has elapsed, but just silently drop messages "
"during the delay period)."
msgstr ""
"Esto significa que si el oyente remoto (*listener*) comienza después de que "
"se usó el gestor , pueden perderse mensajes (dado que el gestor no puede "
"siquiera intentar una conexión hasta que se haya cumplido el retardo, y "
"silenciosamente desechará los mensajes mientras se cumpla el retardo)."

#: ../Doc/library/logging.handlers.rst:543
msgid "DatagramHandler"
msgstr "DatagramHandler"

#: ../Doc/library/logging.handlers.rst:545
msgid ""
"The :class:`DatagramHandler` class, located in the :mod:`logging.handlers` "
"module, inherits from :class:`SocketHandler` to support sending logging "
"messages over UDP sockets."
msgstr ""
"La clase :class:`DatagramHandler` está ubicada en el módulo :mod:`logging."
"handlers`, hereda de la clase :class:`SocketHandler` para realizar el "
"soporte de mensajes *logging* por los *sockets* UDP."

#: ../Doc/library/logging.handlers.rst:552
msgid ""
"Returns a new instance of the :class:`DatagramHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""
"Retorna una nueva instancia de la clase :class:`DatagramHandler` destinada "
"para comunicarse con la terminal remota cuya dirección es dada por *host* y "
"*port*."

#: ../Doc/library/logging.handlers.rst:555
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a UDP socket is created."
msgstr ""
"Si 'port' se especifica como \"None\", se crea un socket de dominio Unix, "
"usando el valor en \"host\" - de otra manera se crea un socket UDP."

#: ../Doc/library/logging.handlers.rst:561
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. To unpickle the record at the receiving end into a :class:`~logging."
"LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""
"Serializa (*pickles*) el registro del diccionario de atributos y lo escribe "
"en el socket en formato binario. Si hay un error con el socket, "
"silenciosamente desecha el paquete. Para deserializar (*unpickle*) el "
"registro en el extremo de recepción a una clase :class:`~logging.LogRecord`, "
"usa la función :func:`~logging.makeLogRecord`."

#: ../Doc/library/logging.handlers.rst:570
msgid ""
"The factory method of :class:`SocketHandler` is here overridden to create a "
"UDP socket (:const:`socket.SOCK_DGRAM`)."
msgstr ""
"El método original de la clase :class:`SocketHandler` se omite para crear un "
"socket UDP (:const:`socket.SOCK_DGRAM`)."

#: ../Doc/library/logging.handlers.rst:576
msgid ""
"Send a pickled byte-string to a socket. The format of the sent byte-string "
"is as described in the documentation for :meth:`SocketHandler.makePickle`."
msgstr ""
"Enviar una cadena de caracteres serializada (*pickled*) a un socket de red. "
"El formato de la cadena de *bytes* enviado es tal como se describe en la "
"documentación para :meth:`SocketHandler.makePickle`."

#: ../Doc/library/logging.handlers.rst:583
msgid "SysLogHandler"
msgstr "Gestor *SysLog* (*SysLogHandler*)"

#: ../Doc/library/logging.handlers.rst:585
msgid ""
"The :class:`SysLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a remote or local Unix syslog."
msgstr ""
"La clase :class:`SysLogHandler` está ubicada en el módulo :mod:`logging."
"handlers`. Realiza el soporte de los mensajes de *logging* a un *syslog* "
"Unix local o remoto."

#: ../Doc/library/logging.handlers.rst:591
msgid ""
"Returns a new instance of the :class:`SysLogHandler` class intended to "
"communicate with a remote Unix machine whose address is given by *address* "
"in the form of a ``(host, port)`` tuple.  If *address* is not specified, "
"``('localhost', 514)`` is used.  The address is used to open a socket.  An "
"alternative to providing a ``(host, port)`` tuple is providing an address as "
"a string, for example '/dev/log'. In this case, a Unix domain socket is used "
"to send the message to the syslog. If *facility* is not specified, :const:"
"`LOG_USER` is used. The type of socket opened depends on the *socktype* "
"argument, which defaults to :const:`socket.SOCK_DGRAM` and thus opens a UDP "
"socket. To open a TCP socket (for use with the newer syslog daemons such as "
"rsyslog), specify a value of :const:`socket.SOCK_STREAM`."
msgstr ""
"Retorna una nueva instancia de la clase :class:`SysLogHandler` concebida "
"para comunicarse con una terminal remota Unix cuya dirección esta dada por "
"*address* en la forma de una tupla ``(host, port)`` . Si *address* no se "
"especifica se usará ``('localhost', 514)``. La dirección se usa para abrir "
"el socket. Una alternativa a consignar una tupla ``(host, port)`` es proveer "
"una dirección como cadena de caracteres, por ejemplo '/dev/log'. En este "
"caso se usa un socket de dominio Unix para enviar el mensaje al syslog. Si "
"*facility* no se especifica se usara :const:`LOG_USER` . El tipo de socket "
"abierto usado depende del argumento *socktype* , que por defecto es :const:"
"`socket.SOCK_DGRAM` y por lo tanto abre un socket UDP . Para abrir un socket "
"TCP (para usar con los nuevos *daemons syslog* como Rsyslog) se debe "
"especificar un valor de :const:`socket.SOCK_STREAM`."

#: ../Doc/library/logging.handlers.rst:603
msgid ""
"Note that if your server is not listening on UDP port 514, :class:"
"`SysLogHandler` may appear not to work. In that case, check what address you "
"should be using for a domain socket - it's system dependent. For example, on "
"Linux it's usually '/dev/log' but on OS/X it's '/var/run/syslog'. You'll "
"need to check your platform and use the appropriate address (you may need to "
"do this check at runtime if your application needs to run on several "
"platforms). On Windows, you pretty much have to use the UDP option."
msgstr ""
"Nótese que si el servidor no esta escuchando el puerto UDP 514, la clase :"
"class:`SysLogHandler` puede parecer no funcionar. En ese caso chequea que "
"dirección deberías usar para un socket de dominio . Es sistema-dependiente. "
"Por ejemplo en Linux generalmente es '/dev/log' pero en OS/X es '/var/run/"
"syslog'. Será necesario chequear tu plataforma y usar la dirección adecuada "
"(quizá sea necesario realizar este chequeo mientras corre la aplicación si "
"necesita correr en diferentes plataformas). En Windows seguramente tengas "
"que usar la opción UDP."

#: ../Doc/library/logging.handlers.rst:612
msgid "*socktype* was added."
msgstr "Se agregó *socktype*."

#: ../Doc/library/logging.handlers.rst:618
msgid "Closes the socket to the remote host."
msgstr "Cierra el socket del host remoto."

#: ../Doc/library/logging.handlers.rst:623
msgid ""
"The record is formatted, and then sent to the syslog server. If exception "
"information is present, it is *not* sent to the server."
msgstr ""
"El registro es formateado, y luego enviado al servidor *syslog*. Si hay "
"información de excepción presente entonces no se enviará al servidor."

#: ../Doc/library/logging.handlers.rst:626
msgid ""
"(See: :issue:`12168`.) In earlier versions, the message sent to the syslog "
"daemons was always terminated with a NUL byte, because early versions of "
"these daemons expected a NUL terminated message - even though it's not in "
"the relevant specification (:rfc:`5424`). More recent versions of these "
"daemons don't expect the NUL byte but strip it off if it's there, and even "
"more recent daemons (which adhere more closely to RFC 5424) pass the NUL "
"byte on as part of the message."
msgstr ""
"(Véase el :issue:`12168`.) En versiones anteriores , los mensajes enviados a "
"los *daemons syslog* siempre terminaban con un byte NUL ya que versiones "
"anteriores de estos *daemons* esperaban un mensaje NUL de terminación. "
"Incluso a pesar que no es relevante la especificación (:rfc:`5424`). "
"Versiones mas recientes de estos *daemons* no esperan el byte NUL pero lo "
"quitan si esta ahí. Versiones aún mas recientes que están mas cercanas a la "
"especificación RFC 5424 pasan el byte NUL como parte del mensaje."

#: ../Doc/library/logging.handlers.rst:635
msgid ""
"To enable easier handling of syslog messages in the face of all these "
"differing daemon behaviours, the appending of the NUL byte has been made "
"configurable, through the use of a class-level attribute, ``append_nul``. "
"This defaults to ``True`` (preserving the existing behaviour) but can be set "
"to ``False`` on a ``SysLogHandler`` instance in order for that instance to "
"*not* append the NUL terminator."
msgstr ""
"Para habilitar una gestión mas sencilla de los mensajes *syslog* respecto de "
"todos esos *daemons* de diferentes comportamientos el agregado del byte NUL "
"es configurable a través del uso del atributo de nivel de clase "
"'append_nul'. Este es por defecto '``True`` (preservando el comportamiento "
"ya existente) pero se puede establecer a 'False' en una instancia "
"``SysLogHandler`` como para que esa instancia no añada el terminador NUL."

#: ../Doc/library/logging.handlers.rst:642
msgid ""
"(See: :issue:`12419`.) In earlier versions, there was no facility for an "
"\"ident\" or \"tag\" prefix to identify the source of the message. This can "
"now be specified using a class-level attribute, defaulting to ``\"\"`` to "
"preserve existing behaviour, but which can be overridden on a "
"``SysLogHandler`` instance in order for that instance to prepend the ident "
"to every message handled. Note that the provided ident must be text, not "
"bytes, and is prepended to the message exactly as is."
msgstr ""
"(Véase: issue '12419') en versiones anteriores, no había posibilidades para "
"un prefijo 'ident' o 'tag' para identificar el origen del mensaje. Esto "
"ahora se puede especificar usando un atributo de nivel de clase, que por "
"defecto será \"''\" para preservar el comportamiento existente , pero puede "
"ser sorteado en una instancia ``SysLogHandler`` para que esta instancia "
"anteponga el *ident* a todos los mensajes gestionados. Nótese que el *ident* "
"provisto debe ser texto, no bytes y se antepone al mensaje tal como es."

#: ../Doc/library/logging.handlers.rst:653
msgid ""
"Encodes the facility and priority into an integer. You can pass in strings "
"or integers - if strings are passed, internal mapping dictionaries are used "
"to convert them to integers."
msgstr ""
"Codifica la funcionalidad y prioridad en un entero. Puedes pasar cadenas de "
"caracteres o enteros, si pasas cadenas de caracteres se usarán los "
"diccionarios de mapeo interno para convertirlos en enteros."

#: ../Doc/library/logging.handlers.rst:657
msgid ""
"The symbolic ``LOG_`` values are defined in :class:`SysLogHandler` and "
"mirror the values defined in the ``sys/syslog.h`` header file."
msgstr ""
"Los valores simbólicos ``LOG_`` están definidos en :class:`SysLogHandler` e "
"invierten los valores definidos en el archivo de encabezado `sys/syslog.h``."

#: ../Doc/library/logging.handlers.rst:660
msgid "**Priorities**"
msgstr "**Prioridades**"

#: ../Doc/library/logging.handlers.rst:663
#: ../Doc/library/logging.handlers.rst:685
msgid "Name (string)"
msgstr "Nombre (cadena de caracteres)"

#: ../Doc/library/logging.handlers.rst:663
#: ../Doc/library/logging.handlers.rst:685
msgid "Symbolic value"
msgstr "Valor simbólico"

#: ../Doc/library/logging.handlers.rst:665
msgid "``alert``"
msgstr "``alert``"

#: ../Doc/library/logging.handlers.rst:665
msgid "LOG_ALERT"
msgstr "LOG_ALERT"

#: ../Doc/library/logging.handlers.rst:667
msgid "``crit`` or ``critical``"
msgstr "``crit`` or ``critical``"

#: ../Doc/library/logging.handlers.rst:667
msgid "LOG_CRIT"
msgstr "LOG_CRIT"

#: ../Doc/library/logging.handlers.rst:669
msgid "``debug``"
msgstr "``debug``"

#: ../Doc/library/logging.handlers.rst:669
msgid "LOG_DEBUG"
msgstr "LOG_DEBUG"

#: ../Doc/library/logging.handlers.rst:671
msgid "``emerg`` or ``panic``"
msgstr "``emerg`` or ``panic``"

#: ../Doc/library/logging.handlers.rst:671
msgid "LOG_EMERG"
msgstr "LOG_EMERG"

#: ../Doc/library/logging.handlers.rst:673
msgid "``err`` or ``error``"
msgstr "``err`` or ``error``"

#: ../Doc/library/logging.handlers.rst:673
msgid "LOG_ERR"
msgstr "LOG_ERR"

#: ../Doc/library/logging.handlers.rst:675
msgid "``info``"
msgstr "``info``"

#: ../Doc/library/logging.handlers.rst:675
msgid "LOG_INFO"
msgstr "LOG_INFO"

#: ../Doc/library/logging.handlers.rst:677
msgid "``notice``"
msgstr "``notice``"

#: ../Doc/library/logging.handlers.rst:677
msgid "LOG_NOTICE"
msgstr "LOG_NOTICE"

#: ../Doc/library/logging.handlers.rst:679
msgid "``warn`` or ``warning``"
msgstr "``warn`` or ``warning``"

#: ../Doc/library/logging.handlers.rst:679
msgid "LOG_WARNING"
msgstr "LOG_WARNING"

#: ../Doc/library/logging.handlers.rst:682
msgid "**Facilities**"
msgstr "**Facilities**"

#: ../Doc/library/logging.handlers.rst:687
msgid "``auth``"
msgstr "``auth``"

#: ../Doc/library/logging.handlers.rst:687
msgid "LOG_AUTH"
msgstr "LOG_AUTH"

#: ../Doc/library/logging.handlers.rst:689
msgid "``authpriv``"
msgstr "``authpriv``"

#: ../Doc/library/logging.handlers.rst:689
msgid "LOG_AUTHPRIV"
msgstr "LOG_AUTHPRIV"

#: ../Doc/library/logging.handlers.rst:691
msgid "``cron``"
msgstr "``cron``"

#: ../Doc/library/logging.handlers.rst:691
msgid "LOG_CRON"
msgstr "LOG_CRON"

#: ../Doc/library/logging.handlers.rst:693
msgid "``daemon``"
msgstr "``daemon``"

#: ../Doc/library/logging.handlers.rst:693
msgid "LOG_DAEMON"
msgstr "LOG_DAEMON"

#: ../Doc/library/logging.handlers.rst:695
msgid "``ftp``"
msgstr "``ftp``"

#: ../Doc/library/logging.handlers.rst:695
msgid "LOG_FTP"
msgstr "LOG_FTP"

#: ../Doc/library/logging.handlers.rst:697
msgid "``kern``"
msgstr "``kern``"

#: ../Doc/library/logging.handlers.rst:697
msgid "LOG_KERN"
msgstr "LOG_KERN"

#: ../Doc/library/logging.handlers.rst:699
msgid "``lpr``"
msgstr "``lpr``"

#: ../Doc/library/logging.handlers.rst:699
msgid "LOG_LPR"
msgstr "LOG_LPR"

#: ../Doc/library/logging.handlers.rst:701
msgid "``mail``"
msgstr "``mail``"

#: ../Doc/library/logging.handlers.rst:701
msgid "LOG_MAIL"
msgstr "LOG_MAIL"

#: ../Doc/library/logging.handlers.rst:703
msgid "``news``"
msgstr "``news``"

#: ../Doc/library/logging.handlers.rst:703
msgid "LOG_NEWS"
msgstr "LOG_NEWS"

#: ../Doc/library/logging.handlers.rst:705
msgid "``syslog``"
msgstr "``syslog``"

#: ../Doc/library/logging.handlers.rst:705
msgid "LOG_SYSLOG"
msgstr "LOG_SYSLOG"

#: ../Doc/library/logging.handlers.rst:707
msgid "``user``"
msgstr "``user``"

#: ../Doc/library/logging.handlers.rst:707
msgid "LOG_USER"
msgstr "LOG_USER"

#: ../Doc/library/logging.handlers.rst:709
msgid "``uucp``"
msgstr "``uucp``"

#: ../Doc/library/logging.handlers.rst:709
msgid "LOG_UUCP"
msgstr "LOG_UUCP"

#: ../Doc/library/logging.handlers.rst:711
msgid "``local0``"
msgstr "``local0``"

#: ../Doc/library/logging.handlers.rst:711
msgid "LOG_LOCAL0"
msgstr "LOG_LOCAL0"

#: ../Doc/library/logging.handlers.rst:713
msgid "``local1``"
msgstr "``local1``"

#: ../Doc/library/logging.handlers.rst:713
msgid "LOG_LOCAL1"
msgstr "LOG_LOCAL1"

#: ../Doc/library/logging.handlers.rst:715
msgid "``local2``"
msgstr "``local2``"

#: ../Doc/library/logging.handlers.rst:715
msgid "LOG_LOCAL2"
msgstr "LOG_LOCAL2"

#: ../Doc/library/logging.handlers.rst:717
msgid "``local3``"
msgstr "``local3``"

#: ../Doc/library/logging.handlers.rst:717
msgid "LOG_LOCAL3"
msgstr "LOG_LOCAL3"

#: ../Doc/library/logging.handlers.rst:719
msgid "``local4``"
msgstr "``local4``"

#: ../Doc/library/logging.handlers.rst:719
msgid "LOG_LOCAL4"
msgstr "LOG_LOCAL4"

#: ../Doc/library/logging.handlers.rst:721
msgid "``local5``"
msgstr "``local5``"

#: ../Doc/library/logging.handlers.rst:721
msgid "LOG_LOCAL5"
msgstr "LOG_LOCAL5"

#: ../Doc/library/logging.handlers.rst:723
msgid "``local6``"
msgstr "``local6``"

#: ../Doc/library/logging.handlers.rst:723
msgid "LOG_LOCAL6"
msgstr "LOG_LOCAL6"

#: ../Doc/library/logging.handlers.rst:725
msgid "``local7``"
msgstr "``local7``"

#: ../Doc/library/logging.handlers.rst:725
msgid "LOG_LOCAL7"
msgstr "LOG_LOCAL7"

#: ../Doc/library/logging.handlers.rst:730
msgid ""
"Maps a logging level name to a syslog priority name. You may need to "
"override this if you are using custom levels, or if the default algorithm is "
"not suitable for your needs. The default algorithm maps ``DEBUG``, ``INFO``, "
"``WARNING``, ``ERROR`` and ``CRITICAL`` to the equivalent syslog names, and "
"all other level names to 'warning'."
msgstr ""
"Mapea un nombre de nivel *logging* a un nombre de prioridad *syslog*. Puedes "
"necesitar omitir esto si estas usando niveles personalizados, o si el "
"algoritmo por defecto no es aplicable a tus necesidades. El algoritmo por "
"defecto mapea ``DEBUG``, ``INFO``, ``WARNING``, ``ERROR`` y ``CRITICAL`` a "
"sus nombres equivalentes *syslog*, y todos los demás nombres de nivel a "
"'warning'."

#: ../Doc/library/logging.handlers.rst:740
msgid "NTEventLogHandler"
msgstr "Gestor de eventos *NTELog* (NTEventLogHandler)"

#: ../Doc/library/logging.handlers.rst:742
msgid ""
"The :class:`NTEventLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a local Windows NT, Windows "
"2000 or Windows XP event log. Before you can use it, you need Mark Hammond's "
"Win32 extensions for Python installed."
msgstr ""
"La clase :class:`NTEventLogHandler` esta localizada en el módulo :mod:"
"`logging.handlers`, soporta el envío de mensajes de *logging* a un log de "
"eventos local Windows NT, Windows 2000 o Windows XP. Antes de que puedas "
"usarlo, necesitarás tener instaladas las extensiones de Win32 de Mark "
"Hammond para Python."

#: ../Doc/library/logging.handlers.rst:750
msgid ""
"Returns a new instance of the :class:`NTEventLogHandler` class. The "
"*appname* is used to define the application name as it appears in the event "
"log. An appropriate registry entry is created using this name. The *dllname* "
"should give the fully qualified pathname of a .dll or .exe which contains "
"message definitions to hold in the log (if not specified, ``'win32service."
"pyd'`` is used - this is installed with the Win32 extensions and contains "
"some basic placeholder message definitions. Note that use of these "
"placeholders will make your event logs big, as the entire message source is "
"held in the log. If you want slimmer logs, you have to pass in the name of "
"your own .dll or .exe which contains the message definitions you want to use "
"in the event log). The *logtype* is one of ``'Application'``, ``'System'`` "
"or ``'Security'``, and defaults to ``'Application'``."
msgstr ""
"Retorna una nueva instancia de la clase :class:`NTEventLogHandler` la "
"*appname* se usa para definir el nombre de la aplicación tal como aparece en "
"el log de eventos. Se crea una entrada de registro apropiada usando este "
"nombre. El *dllname* debe dar la ruta completa calificada de un .dll o .exe "
"que contiene definiciones de mensaje para conservar en el log. (si no esta "
"especificada, se usara``'win32service.pyd'`` esto es instalado con las "
"extensiones de Win32 y contiene algunas definiciones básicas de mensajes de "
"conservación de lugar. Nótese que el uso de estos conservadores de lugar "
"harán tu log de eventos extenso, dado que el origen completo del mensaje es "
"guardado en el log. Si quieres *logs* menos extensos deberás pasar el nombre "
"de tu propio .dll o .exe que contiene la definición de mensajes que quieres "
"usar en el log. El *logtype* puede ser de ``'Application'``, ``'System'`` or "
"``'Security'`` y sino por defecto será de ``'Application'``."

#: ../Doc/library/logging.handlers.rst:766
msgid ""
"At this point, you can remove the application name from the registry as a "
"source of event log entries. However, if you do this, you will not be able "
"to see the events as you intended in the Event Log Viewer - it needs to be "
"able to access the registry to get the .dll name. The current version does "
"not do this."
msgstr ""
"Llegado a este punto puedes remover el nombre de aplicación del registro "
"como origen de entrada de log de eventos. Sin embargo si haces esto no te "
"será posible ver los eventos tal como has propuesto en el visor del log de "
"eventos - necesita ser capaz de acceder al registro para tomar el nombre ."
"dll. Esto no lo hace la versión actual."

#: ../Doc/library/logging.handlers.rst:775
msgid ""
"Determines the message ID, event category and event type, and then logs the "
"message in the NT event log."
msgstr ""
"Determina el ID del mensaje, categoría y tipo de evento y luego registra el "
"mensaje en el log de eventos NT."

#: ../Doc/library/logging.handlers.rst:781
msgid ""
"Returns the event category for the record. Override this if you want to "
"specify your own categories. This version returns 0."
msgstr ""
"Retorna la categoría de evento del registro. Evita esto si quieres "
"especificar tus propias categorías. Esta versión retorna 0."

#: ../Doc/library/logging.handlers.rst:787
msgid ""
"Returns the event type for the record. Override this if you want to specify "
"your own types. This version does a mapping using the handler's typemap "
"attribute, which is set up in :meth:`__init__` to a dictionary which "
"contains mappings for :const:`DEBUG`, :const:`INFO`, :const:`WARNING`, :"
"const:`ERROR` and :const:`CRITICAL`. If you are using your own levels, you "
"will either need to override this method or place a suitable dictionary in "
"the handler's *typemap* attribute."
msgstr ""
"Retorna el tipo de evento del registro. Haz caso omiso de esto si quieres "
"especificar tus propios tipos. Esta versión realiza un mapeo usando el "
"atributo *typemap* del gestor, que se establece en :meth:`__init__` a un "
"diccionario que contiene mapeo para :const:`DEBUG`, :const:`INFO`, :const:"
"`WARNING`, :const:`ERROR` y :const:`CRITICAL`. Si estas usando tus propios "
"niveles, necesitarás omitir este método o colocar un diccionario a medida en "
"el atributo *typemap* del gestor."

#: ../Doc/library/logging.handlers.rst:798
msgid ""
"Returns the message ID for the record. If you are using your own messages, "
"you could do this by having the *msg* passed to the logger being an ID "
"rather than a format string. Then, in here, you could use a dictionary "
"lookup to get the message ID. This version returns 1, which is the base "
"message ID in :file:`win32service.pyd`."
msgstr ""
"Retorna el ID de mensaje para el registro. Si estas usando tus propios "
"mensajes, podrás hacerlo pasando el *msg* al *logger* siendo un ID mas que "
"un formato de cadena de caracteres. Luego aquí puedes usar una búsqueda de "
"diccionario para obtener el ID de mensaje. Esta versión retorna 1, que es el "
"ID de mensaje base en :file:`win32service.pyd`."

#: ../Doc/library/logging.handlers.rst:807
msgid "SMTPHandler"
msgstr "SMTPHandler"

#: ../Doc/library/logging.handlers.rst:809
msgid ""
"The :class:`SMTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to an email address via SMTP."
msgstr ""
"La clase :class:`SMTPHandler` esta ubicada en el módulo :mod:`logging."
"handlers` y soporta el envío de mensajes de *logging* a un a dirección de "
"correo electrónico a través de SMTP."

#: ../Doc/library/logging.handlers.rst:815
msgid ""
"Returns a new instance of the :class:`SMTPHandler` class. The instance is "
"initialized with the from and to addresses and subject line of the email. "
"The *toaddrs* should be a list of strings. To specify a non-standard SMTP "
"port, use the (host, port) tuple format for the *mailhost* argument. If you "
"use a string, the standard SMTP port is used. If your SMTP server requires "
"authentication, you can specify a (username, password) tuple for the "
"*credentials* argument."
msgstr ""
"Retorna una nueva instancia de la clase :class:`SMTPHandler` . Esta "
"instancia se inicializa con la dirección de: y para: y asunto: del correo "
"electrónico. El *toaddrs* debe ser una lista de cadena de caracteres. Para "
"especificar un puerto SMTP no estandarizado usa el formato de tupla (host, "
"puerto) para el argumento *mailhost*. Si usas una cadena de caracteres, se "
"utiliza el puerto estándar SMTP. Si tu servidor SMTP necesita autenticación, "
"puedes especificar una tupla (usuario, contraseña) para el argumento de "
"*credentials*."

#: ../Doc/library/logging.handlers.rst:822
msgid ""
"To specify the use of a secure protocol (TLS), pass in a tuple to the "
"*secure* argument. This will only be used when authentication credentials "
"are supplied. The tuple should be either an empty tuple, or a single-value "
"tuple with the name of a keyfile, or a 2-value tuple with the names of the "
"keyfile and certificate file. (This tuple is passed to the :meth:`smtplib."
"SMTP.starttls` method.)"
msgstr ""
"Para especificar el uso de un protocolo de seguridad (TLS), pasa una tupla "
"al argumento *secure*. Esto solo se utilizará cuando sean provistas las "
"credenciales de autenticación. La tupla deberá ser una tupla vacía o una "
"tupla con único valor con el nombre de un archivo-clave *keyfile*, o una "
"tupla de 2 valores con el nombre del archivo-clave *keyfile* y archivo "
"certificado. (Esta tupla se pasa al método :meth:`smtplib.SMTP.starttls` "
"method.)."

#: ../Doc/library/logging.handlers.rst:829
msgid ""
"A timeout can be specified for communication with the SMTP server using the "
"*timeout* argument."
msgstr ""
"Se puede especificar un tiempo de espera para comunicación con el servidor "
"SMTP usando el argumento *timeout*."

#: ../Doc/library/logging.handlers.rst:832
msgid "The *timeout* argument was added."
msgstr "Se agregó el argumento *timeout*."

#: ../Doc/library/logging.handlers.rst:837
msgid "Formats the record and sends it to the specified addressees."
msgstr "Formatea el registro y lo envía a las direcciones especificadas."

#: ../Doc/library/logging.handlers.rst:842
msgid ""
"If you want to specify a subject line which is record-dependent, override "
"this method."
msgstr ""
"Si quieres especificar una línea de argumento que es registro-dependiente, "
"sobrescribe (*override*) este método."

#: ../Doc/library/logging.handlers.rst:848
msgid "MemoryHandler"
msgstr "MemoryHandler"

#: ../Doc/library/logging.handlers.rst:850
msgid ""
"The :class:`MemoryHandler` class, located in the :mod:`logging.handlers` "
"module, supports buffering of logging records in memory, periodically "
"flushing them to a :dfn:`target` handler. Flushing occurs whenever the "
"buffer is full, or when an event of a certain severity or greater is seen."
msgstr ""
"La clase :class:`MemoryHandler` esta ubicada en el módulo :mod:`logging."
"handlers` .Soporta el almacenamiento temporal de registros *logging* en "
"memoria. Periódicamente los descarga al gestor :dfn:`target`. Esto ocurre "
"cuando el búfer está lleno o cuando ocurre un evento de cierta importancia."

#: ../Doc/library/logging.handlers.rst:855
msgid ""
":class:`MemoryHandler` is a subclass of the more general :class:"
"`BufferingHandler`, which is an abstract class. This buffers logging records "
"in memory. Whenever each record is added to the buffer, a check is made by "
"calling :meth:`shouldFlush` to see if the buffer should be flushed.  If it "
"should, then :meth:`flush` is expected to do the flushing."
msgstr ""
":class:`MemoryHandler` es una subclase de la clase mas general :class:"
"`BufferingHandler`, que es una clase abstracta. Este almacena temporalmente "
"registros *logging* en la memoria. Cada vez que un registro es agregado al "
"búfer, se realiza una comprobación llamando al método :meth:`shouldFlush` "
"para ver si dicho búfer debe ser descargado. Si debiera, entonces el método :"
"meth:`flush` se espera que realice la descarga."

#: ../Doc/library/logging.handlers.rst:864
msgid ""
"Initializes the handler with a buffer of the specified capacity. Here, "
"*capacity* means the number of logging records buffered."
msgstr ""
"Inicializa el gestor con un búfer de una capacidad especifica. Aquí "
"capacidad significa el número de registros *logging* en el almacenamiento "
"temporal."

#: ../Doc/library/logging.handlers.rst:870
msgid ""
"Append the record to the buffer. If :meth:`shouldFlush` returns true, call :"
"meth:`flush` to process the buffer."
msgstr ""
"Añade un registro al búfer. Si el método :meth:`shouldFlush` retorna "
"*true* , entonces llama al método :meth:`flush` para procesar el búfer."

#: ../Doc/library/logging.handlers.rst:876
msgid ""
"You can override this to implement custom flushing behavior. This version "
"just zaps the buffer to empty."
msgstr ""
"Puedes sobrescribir (*override*) esto para implementar un comportamiento 'a "
"medida' de la descarga. Esta versión solo vacía el búfer."

#: ../Doc/library/logging.handlers.rst:882
msgid ""
"Return ``True`` if the buffer is up to capacity. This method can be "
"overridden to implement custom flushing strategies."
msgstr ""
"Retorna ``True`` si el búfer tiene aún capacidad. Este método puede ser "
"omitido para implementar estrategias a medida de vaciado."

#: ../Doc/library/logging.handlers.rst:888
msgid ""
"Returns a new instance of the :class:`MemoryHandler` class. The instance is "
"initialized with a buffer size of *capacity* (number of records buffered). "
"If *flushLevel* is not specified, :const:`ERROR` is used. If no *target* is "
"specified, the target will need to be set using :meth:`setTarget` before "
"this handler does anything useful. If *flushOnClose* is specified as "
"``False``, then the buffer is *not* flushed when the handler is closed. If "
"not specified or specified as ``True``, the previous behaviour of flushing "
"the buffer will occur when the handler is closed."
msgstr ""
"Retorna una nueva instancia de la clase :class:`MemoryHandler` . La "
"instancia se inicializa con un búfer del tamaño *capacity*. Si el "
"*flushLevel* no se especifica, se usará :const:`ERROR` . Si no se especifica "
"*target* el objetivo deberá especificarse usando el método :meth:`setTarget` "
"-Antes de esto el gestor no realizará nada útil. Si se especifica "
"*flushOnClose* como ``False``, entonces el búfer no se vaciará cuando el "
"gestor se cierra. Si no se especifica o se especifica como ``True``, el "
"comportamiento previo de vaciado del búfer sucederá cuando se cierre el "
"gestor."

#: ../Doc/library/logging.handlers.rst:897
msgid "The *flushOnClose* parameter was added."
msgstr "Se añadió el parámetro *flushOnClose*."

#: ../Doc/library/logging.handlers.rst:903
msgid "Calls :meth:`flush`, sets the target to ``None`` and clears the buffer."
msgstr ""
"Invoca al método :meth:`flush` y establece el objetivo a 'None' y vacía el "
"búfer."

#: ../Doc/library/logging.handlers.rst:909
msgid ""
"For a :class:`MemoryHandler`, flushing means just sending the buffered "
"records to the target, if there is one. The buffer is also cleared when this "
"happens. Override if you want different behavior."
msgstr ""
"Para la clase :class:`MemoryHandler` el vaciado significa simplemente enviar "
"los registros del búfer al objetivo, si es que hay uno. El búfer además se "
"vacía cuando esto ocurre. Sobrescribe (*override*) si deseas un "
"comportamiento diferente."

#: ../Doc/library/logging.handlers.rst:916
msgid "Sets the target handler for this handler."
msgstr "Establece el gestor de objetivo para este gestor."

#: ../Doc/library/logging.handlers.rst:921
msgid "Checks for buffer full or a record at the *flushLevel* or higher."
msgstr ""
"Comprueba si el búfer esta lleno o un registro igual o mas alto que "
"*flushLevel*."

#: ../Doc/library/logging.handlers.rst:927
msgid "HTTPHandler"
msgstr "HTTPHandler"

#: ../Doc/library/logging.handlers.rst:929
msgid ""
"The :class:`HTTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a Web server, using either "
"``GET`` or ``POST`` semantics."
msgstr ""
"La clase :class:`HTTPHandler` está ubicada en el módulo :mod:`logging."
"handlers`.Soporta el envío de mensajes *logging* a un servidor Web, usando "
"la semántica ``GET`` o `POST``."

#: ../Doc/library/logging.handlers.rst:936
msgid ""
"Returns a new instance of the :class:`HTTPHandler` class. The *host* can be "
"of the form ``host:port``, should you need to use a specific port number.  "
"If no *method* is specified, ``GET`` is used. If *secure* is true, a HTTPS "
"connection will be used. The *context* parameter may be set to a :class:`ssl."
"SSLContext` instance to configure the SSL settings used for the HTTPS "
"connection. If *credentials* is specified, it should be a 2-tuple consisting "
"of userid and password, which will be placed in a HTTP 'Authorization' "
"header using Basic authentication. If you specify credentials, you should "
"also specify secure=True so that your userid and password are not passed in "
"cleartext across the wire."
msgstr ""
"Retorna una nueva instancia de la clase :class:`HTTPHandler`. el *host* "
"puede ser de la forma \"host:puerto\", y necesitarás usar un numero de "
"puerto especifico. Si no se especifica *method* se usará ``GET`` . Si "
"*secure* es true se usará una conexión HTTPS. El parámetro *context* puede "
"establecerse a una instancia :class:`ssl.SSLContext` para establecer la "
"configuración de SSL usado en la conexión HTTPS. Si se especifica "
"*credentials* debe ser una tupla doble, consistente en usuario y contraseña, "
"que se colocará en un encabezado de autorización HTTP usando autenticación "
"básica. Si especificas credenciales también deberás especificar "
"*secure=True* así tu usuario y contraseña no son pasados como texto en "
"blanco por la conexión."

#: ../Doc/library/logging.handlers.rst:947
msgid "The *context* parameter was added."
msgstr "Se agregó el parámetro *context*."

#: ../Doc/library/logging.handlers.rst:952
msgid ""
"Provides a dictionary, based on ``record``, which is to be URL-encoded and "
"sent to the web server. The default implementation just returns ``record."
"__dict__``. This method can be overridden if e.g. only a subset of :class:"
"`~logging.LogRecord` is to be sent to the web server, or if more specific "
"customization of what's sent to the server is required."
msgstr ""
"Provee un diccionario, basado en ``record`` para ser codificado en forma URL "
"y enviado al servidor web. La implementación por defecto retorna ``record."
"__dict__``. Este método puede omitirse si por ejemplo solo se enviará al "
"servidor web un subconjunto de la clase :class:`~logging.LogRecord` o si se "
"requiere enviar al servidor algo mas específico."

#: ../Doc/library/logging.handlers.rst:960
msgid ""
"Sends the record to the Web server as a URL-encoded dictionary. The :meth:"
"`mapLogRecord` method is used to convert the record to the dictionary to be "
"sent."
msgstr ""
"Envía el registro al servidor Web como un diccionario con codificación URL. "
"Se usa el método :meth:`mapLogRecord` para convertir el registro al "
"diccionario que debe ser enviado."

#: ../Doc/library/logging.handlers.rst:964
msgid ""
"Since preparing a record for sending it to a Web server is not the same as a "
"generic formatting operation, using :meth:`~logging.Handler.setFormatter` to "
"specify a :class:`~logging.Formatter` for a :class:`HTTPHandler` has no "
"effect. Instead of calling :meth:`~logging.Handler.format`, this handler "
"calls :meth:`mapLogRecord` and then :func:`urllib.parse.urlencode` to encode "
"the dictionary in a form suitable for sending to a Web server."
msgstr ""
"Dado que preparar un registro para enviar a un servidor Web no es lo mismo "
"que una operación genérica de formato, usando el método :meth:`~logging."
"Handler.setFormatter` para especificar una clase :class:`~logging.Formatter` "
"por una clase :class:`HTTPHandler` no tiene efecto.  En vez de llamar al "
"método :meth:`~logging.Handler.format` este gestor llama al método :meth:"
"`mapLogRecord` y después a la función :func:`urllib.parse.urlencode` para "
"codificar el diccionario en una forma que sea adecuada para enviar a un "
"servidor Web."

#: ../Doc/library/logging.handlers.rst:977
msgid "QueueHandler"
msgstr "QueueHandler"

#: ../Doc/library/logging.handlers.rst:981
msgid ""
"The :class:`QueueHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules."
msgstr ""
"La clase :class:`QueueHandler` localizada en el módulo :mod:`logging."
"handlers` soporta el envío de mensajes de *logging* a una cola, tal como los "
"implementados en los módulos :mod:`queue` o :mod:`multiprocessing` ."

#: ../Doc/library/logging.handlers.rst:985
msgid ""
"Along with the :class:`QueueListener` class, :class:`QueueHandler` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in Web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""
"Junto con la clase :class:`QueueListener` la clase :class:`QueueHandler` "
"puede usarse para permitir a los gestores realizar su tarea en un hilo "
"separado del que realiza el *logging*. Esto es importante en aplicaciones "
"Web y también otras aplicaciones donde los clientes servidos por los hilos "
"necesitan responder tan rápido como sea posible, mientras que cualquier "
"operación potencialmente lenta (tal como enviar un correo electrónico a "
"través la clase :class:`SMTPHandler`) se realizan por un hilo diferente."

#: ../Doc/library/logging.handlers.rst:994
msgid ""
"Returns a new instance of the :class:`QueueHandler` class. The instance is "
"initialized with the queue to send messages to. The *queue* can be any queue-"
"like object; it's used as-is by the :meth:`enqueue` method, which needs to "
"know how to send messages to it. The queue is not *required* to have the "
"task tracking API, which means that you can use :class:`~queue.SimpleQueue` "
"instances for *queue*."
msgstr ""
"Retorna una nueva instancia de la clase :class:`QueueHandler`. La instancia "
"se inicializa con la cola a la que se enviarán los mensajes. La cola puede "
"ser cualquier objeto tipo-cola; es usado tal como por el método :meth:"
"`enqueue` que necesita saber como enviar los mensajes a ella. La cola no es "
"*requerida* para tener una API de rastreo de tareas, lo que significa que "
"puedes usar instancias de :class:`~queue.SimpleQueue` como *queue*."

#: ../Doc/library/logging.handlers.rst:1004
msgid ""
"Enqueues the result of preparing the LogRecord. Should an exception occur (e."
"g. because a bounded queue has filled up), the :meth:`~logging.Handler."
"handleError` method is called to handle the error. This can result in the "
"record silently being dropped (if :attr:`logging.raiseExceptions` is "
"``False``) or a message printed to ``sys.stderr`` (if :attr:`logging."
"raiseExceptions` is ``True``)."
msgstr ""
"Pone en la cola el resultado de preparar el registro historial de log. Si "
"ocurre una excepción (por ejemplo por que una cola de destino se llenó) "
"entonces se llama al método :meth:`~logging.Handler.handleError`. Esto puede "
"resultar en que el registro se descarte (si :attr:`logging.raiseExceptions` "
"es ``False``) o que se imprima un mensaje a ``sys.stderr`` (si :attr:"
"`logging.raiseExceptions` es ``True``)."

#: ../Doc/library/logging.handlers.rst:1013
msgid ""
"Prepares a record for queuing. The object returned by this method is "
"enqueued."
msgstr ""
"Prepara un registro para poner en la cola. El objeto que retorna este método "
"se colocará en cola."

#: ../Doc/library/logging.handlers.rst:1016
msgid ""
"The base implementation formats the record to merge the message, arguments, "
"and exception information, if present.  It also removes unpickleable items "
"from the record in-place."
msgstr ""
"La implementación base da formato al registro para unir la información de "
"los mensajes, argumentos y excepciones, si están presentes. También remueve "
"los elementos que no se pueden serializar (*unpickleables*) de los registros "
"in-situ."

#: ../Doc/library/logging.handlers.rst:1020
msgid ""
"You might want to override this method if you want to convert the record to "
"a dict or JSON string, or send a modified copy of the record while leaving "
"the original intact."
msgstr ""
"Puedes querer hacer caso omiso de este método si quieres convertir el "
"registro en un diccionario o cadena de caracteres JSON, o enviar una copia "
"modificada del registro mientras dejas el original intacto."

#: ../Doc/library/logging.handlers.rst:1026
msgid ""
"Enqueues the record on the queue using ``put_nowait()``; you may want to "
"override this if you want to use blocking behaviour, or a timeout, or a "
"customized queue implementation."
msgstr ""
"Coloca en la cola al registro usando ``put_nowait()``; puede que quieras "
"sobrescribe (*override*) esto si quieres usar una acción de bloqueo, o un "
"tiempo de espera, o una implementación de cola a medida."

#: ../Doc/library/logging.handlers.rst:1035
msgid "QueueListener"
msgstr "QueueListener"

#: ../Doc/library/logging.handlers.rst:1039
msgid ""
"The :class:`QueueListener` class, located in the :mod:`logging.handlers` "
"module, supports receiving logging messages from a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules. The "
"messages are received from a queue in an internal thread and passed, on the "
"same thread, to one or more handlers for processing. While :class:"
"`QueueListener` is not itself a handler, it is documented here because it "
"works hand-in-hand with :class:`QueueHandler`."
msgstr ""
"La clase :class:`QueueListener` esta localizada en el módulo :mod:`logging."
"handlers`. Soporta la recepción de mensajes *logging* de una cola, tal como "
"los implementados en los módulos :mod:`queue` or :mod:`multiprocessing` . "
"Los mensajes son recibidos de una cola en un hilo interno y se pasan en el "
"mismo hilo, a uno o mas gestores para procesarlos. Mientras la clase :class:"
"`QueueListener` no es en si misma un gestor, esta documentada aquí porque "
"trabaja mano a mano con la clase :class:`QueueHandler`."

#: ../Doc/library/logging.handlers.rst:1047
msgid ""
"Along with the :class:`QueueHandler` class, :class:`QueueListener` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in Web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""
"Junto con la clase :class:`QueueHandler` , la clase :class:`QueueListener` "
"puede usarse para permitir a los gestores hacer su labor en un hilo separado "
"del que hace el *logging*. Esto es importante en aplicaciones Web y también "
"otras aplicaciones de servicio donde los clientes servidos por los hilos "
"necesitan una respuesta tan rápida como sea posible, mientras cualquier "
"operación potencialmente lenta (tal como enviar un correo electrónico a "
"través de la clase :class:`SMTPHandler`) son atendidas por un hilo diferente."

#: ../Doc/library/logging.handlers.rst:1056
msgid ""
"Returns a new instance of the :class:`QueueListener` class. The instance is "
"initialized with the queue to send messages to and a list of handlers which "
"will handle entries placed on the queue. The queue can be any queue-like "
"object; it's passed as-is to the :meth:`dequeue` method, which needs to know "
"how to get messages from it. The queue is not *required* to have the task "
"tracking API (though it's used if available), which means that you can use :"
"class:`~queue.SimpleQueue` instances for *queue*."
msgstr ""
"Retorna una nueva instancia de la clase :class:`QueueListener`. La instancia "
"se inicializa con la cola para enviar mensajes a una lista de gestores que "
"manejarán entradas colocadas en la cola. La cola puede ser cualquier objeto "
"de tipo-cola, es usado tal como está por el método :meth:`dequeue` que "
"necesita saber como tomar los mensajes de esta. La cola no es *obligatoria* "
"para tener la API de seguimiento de tareas (aunque se usa si está "
"disponible), lo que significa que puede usar instancias :class:`~queue."
"SimpleQueue` para *queue*."

#: ../Doc/library/logging.handlers.rst:1064
msgid ""
"If ``respect_handler_level`` is ``True``, a handler's level is respected "
"(compared with the level for the message) when deciding whether to pass "
"messages to that handler; otherwise, the behaviour is as in previous Python "
"versions - to always pass each message to each handler."
msgstr ""
"Si ``respect_handler_level`` es ``True``, se respeta un nivel de gestor "
"(comparado con el nivel del mensaje) cuando decide si pasar el mensajes al "
"gestor; de otra manera, el comportamiento es como en versiones anteriores de "
"Python - de pasar cada mensaje a cada gestor."

#: ../Doc/library/logging.handlers.rst:1069
msgid "The ``respect_handler_level`` argument was added."
msgstr "Se agregó el argumento ``respect_handler_levels``."

#: ../Doc/library/logging.handlers.rst:1074
msgid "Dequeues a record and return it, optionally blocking."
msgstr "Extrae de la cola un registro y lo retorna, con opción a bloquearlo."

#: ../Doc/library/logging.handlers.rst:1076
msgid ""
"The base implementation uses ``get()``. You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""
"La implementación base usa ``get()``. Puedes sobrescribir (*override*) este "
"método si quieres usar tiempos de espera o trabajar con colas implementadas "
"a medida."

#: ../Doc/library/logging.handlers.rst:1082
msgid "Prepare a record for handling."
msgstr "Prepara un registro para ser gestionado."

#: ../Doc/library/logging.handlers.rst:1084
msgid ""
"This implementation just returns the passed-in record. You may want to "
"override this method if you need to do any custom marshalling or "
"manipulation of the record before passing it to the handlers."
msgstr ""
"Esta implementación solo retorna el registro que fue pasado. Puedes "
"sobrescribir (*override*) este método para hacer una serialización a medida "
"o una manipulación del registro antes de pasarlo a los gestores."

#: ../Doc/library/logging.handlers.rst:1090
msgid "Handle a record."
msgstr "Manejar un registro."

#: ../Doc/library/logging.handlers.rst:1092
msgid ""
"This just loops through the handlers offering them the record to handle. The "
"actual object passed to the handlers is that which is returned from :meth:"
"`prepare`."
msgstr ""
"Esto solo realiza un bucle a través de los gestores ofreciéndoles el "
"registro para ser gestionado. El objeto actual pasado a los gestores es "
"aquel que es retornado por el método :meth:`prepare`."

#: ../Doc/library/logging.handlers.rst:1098
msgid "Starts the listener."
msgstr "Da comienzo al oyente (*listener*)."

#: ../Doc/library/logging.handlers.rst:1100
msgid ""
"This starts up a background thread to monitor the queue for LogRecords to "
"process."
msgstr ""
"Esto da comienzo a un hilo en segundo plano para supervisar la cola de "
"registros log a procesar."

#: ../Doc/library/logging.handlers.rst:1105
msgid "Stops the listener."
msgstr "Detiene el oyente (*listener*)."

#: ../Doc/library/logging.handlers.rst:1107
msgid ""
"This asks the thread to terminate, and then waits for it to do so. Note that "
"if you don't call this before your application exits, there may be some "
"records still left on the queue, which won't be processed."
msgstr ""
"Esto solicita terminar al hilo, y luego espera hasta que termine. Nota que "
"si no llamas a esto antes de que tu aplicación salga, puede haber algunos "
"registros que aun están en la cola, que no serán procesados."

#: ../Doc/library/logging.handlers.rst:1113
msgid ""
"Writes a sentinel to the queue to tell the listener to quit. This "
"implementation uses ``put_nowait()``.  You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""
"Escribe un centinela (*sentinel*) en la cola para decir al oyente "
"(*listener*) de salir. Esta implementación usa ``put_nowait()``. Puedes "
"sobrescribir (*override*) este método si quieres usar tiempos de espera o "
"trabajar con implementaciones de cola a tu medida."

#: ../Doc/library/logging.handlers.rst:1124
msgid "Module :mod:`logging`"
msgstr "Módulo :mod:`logging`"

#: ../Doc/library/logging.handlers.rst:1124
msgid "API reference for the logging module."
msgstr "Referencia API para el módulo de *logging*."

#: ../Doc/library/logging.handlers.rst:1126
msgid "Module :mod:`logging.config`"
msgstr "Módulo :mod:`logging.config`"

#: ../Doc/library/logging.handlers.rst:1127
msgid "Configuration API for the logging module."
msgstr "Configuración API para el módulo de *logging*."

#~ msgid ""
#~ "The ``StreamHandler`` class now has a ``terminator`` attribute, default "
#~ "value ``'\\n'``, which is used as the terminator when writing a formatted "
#~ "record to a stream. If you don't want this newline termination, you can "
#~ "set the handler instance's ``terminator`` attribute to the empty string. "
#~ "In earlier versions, the terminator was hardcoded as ``'\\n'``."
#~ msgstr ""
#~ "La clase ``StreamHandler`` ahora tiene un atributo ``terminador` con "
#~ "valor por defecto ``'\\n'``, que se usa como terminador cuando se escribe "
#~ "un registro formateado a un *stream*. Si no se quiere esta terminación de "
#~ "nueva línea, se puede establecer el atributo de la instancia del "
#~ "gestor``terminator`` para vaciar la cadena de caracteres. En versiones "
#~ "anteriores el terminador era codificado como ``'\\n'``."

#~ msgid ""
#~ "Returns a new instance of the :class:`WatchedFileHandler` class. The "
#~ "specified file is opened and used as the stream for logging. If *mode* is "
#~ "not specified, :const:`'a'` is used.  If *encoding* is not ``None``, it "
#~ "is used to open the file with that encoding.  If *delay* is true, then "
#~ "file opening is deferred until the first call to :meth:`emit`.  By "
#~ "default, the file grows indefinitely."
#~ msgstr ""
#~ "Retorna una nueva instancia de la clase :class:`WatchedFileHandler`. El "
#~ "archivo especificado se abre y usa como el *stream* para *logging*. Si "
#~ "*mode* no se especifica se usará :const:`'a'`. Si *encoding* no es "
#~ "``None``, se usa para abrir el archivo con esa codificación. Si *delay* "
#~ "es true se diferirá la apertura del archivo hasta tanto se llame al "
#~ "método :meth:`emit` . Por defecto el archivo crecerá indefinidamente."
