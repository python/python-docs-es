# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2022-10-31 14:33-0300\n"
"Last-Translator: Diego Cristobal Herreros <diecristher@gmail.com>\n"
"Language: es_AR\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.0\n"

#: ../Doc/library/logging.handlers.rst:2
msgid ":mod:`logging.handlers` --- Logging handlers"
msgstr ":mod:`logging.handlers` --- Gestores de *logging*"

#: ../Doc/library/logging.handlers.rst:10
msgid "**Source code:** :source:`Lib/logging/handlers.py`"
msgstr "**Código fuente** :source:`Lib/logging/handlers.py`"

#: ../Doc/library/logging.handlers.rst:14
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr ""
"Esta página contiene solo información de referencia. Para tutoriales por "
"favor véase"

#: ../Doc/library/logging.handlers.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Tutorial Básico <logging-basic-tutorial>`"

#: ../Doc/library/logging.handlers.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Tutorial avanzado <logging-advanced-tutorial>`"

#: ../Doc/library/logging.handlers.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`Libro de cocina de *Logging* <logging-cookbook>`"

#: ../Doc/library/logging.handlers.rst:25
msgid ""
"The following useful handlers are provided in the package. Note that three "
"of the handlers (:class:`StreamHandler`, :class:`FileHandler` and :class:"
"`NullHandler`) are actually defined in the :mod:`logging` module itself, but "
"have been documented here along with the other handlers."
msgstr ""
"Estos gestores son muy útiles y están provistos en este paquete. Nota que "
"tres de los gestores de las clases (:class:`StreamHandler`, :class:"
"`FileHandler` and :class:`NullHandler`) están definidos en propio módulo :"
"mod:`logging` pero fueron documentados aquí junto con los otros gestores."

#: ../Doc/library/logging.handlers.rst:33
msgid "StreamHandler"
msgstr "StreamHandler"

#: ../Doc/library/logging.handlers.rst:35
msgid ""
"The :class:`StreamHandler` class, located in the core :mod:`logging` "
"package, sends logging output to streams such as *sys.stdout*, *sys.stderr* "
"or any file-like object (or, more precisely, any object which supports :meth:"
"`write` and :meth:`flush` methods)."
msgstr ""
"La clase :class:`StreamHandler` ubicada en el paquete núcleo :mod:`logging` "
"envía la salida del *logging* a un *stream* como *sys.stdout*, *sys.stderr* "
"o cualquier objeto tipo archivo (o mas precisamente cualquier objeto que "
"soporte los métodos :meth:`write` y :meth:`flush`)."

#: ../Doc/library/logging.handlers.rst:43
msgid ""
"Returns a new instance of the :class:`StreamHandler` class. If *stream* is "
"specified, the instance will use it for logging output; otherwise, *sys."
"stderr* will be used."
msgstr ""
"Retorna una nueva instancia de la clase :class:`StreamHandler`. Si *stream* "
"esta especificado, la instancia lo usará para la salida del registro, sino "
"se usará *sys.stderr*."

#: ../Doc/library/logging.handlers.rst:50
msgid ""
"If a formatter is specified, it is used to format the record. The record is "
"then written to the stream followed by :attr:`terminator`. If exception "
"information is present, it is formatted using :func:`traceback."
"print_exception` and appended to the stream."
msgstr ""
"Si se especifica un formateador, se utiliza para formatear el registro. "
"Luego, el registro se escribe en el flujo seguido de :attr:`terminator`. Si "
"hay información de excepción, se formatea con :func:`traceback."
"print_exception` y se agrega al flujo."

#: ../Doc/library/logging.handlers.rst:58
msgid ""
"Flushes the stream by calling its :meth:`flush` method. Note that the :meth:"
"`close` method is inherited from :class:`~logging.Handler` and so does no "
"output, so an explicit :meth:`flush` call may be needed at times."
msgstr ""
"Descarga el *stream* llamando a su método :meth:`flush`. Nota que el método :"
"meth:`close` es heredado de la clase :class:`~logging.Handler` y por lo "
"tanto no produce ninguna salida. Por eso muchas veces será necesario invocar "
"al método explícito :meth:`flush`."

#: ../Doc/library/logging.handlers.rst:64
msgid ""
"Sets the instance's stream to the specified value, if it is different. The "
"old stream is flushed before the new stream is set."
msgstr ""
"Establece el *stream* de la instancia a un valor especifico, si este es "
"diferente. El anterior *stream* es vaciado antes de que el nuevo *stream* "
"sea establecido."

#: ../Doc/library/logging.handlers.rst
msgid "Parameters"
msgstr "Parámetros"

#: ../Doc/library/logging.handlers.rst:67
msgid "The stream that the handler should use."
msgstr "El *stream* que el gestor debe usar."

#: ../Doc/library/logging.handlers.rst
msgid "Returns"
msgstr "Retorna"

#: ../Doc/library/logging.handlers.rst:69
msgid "the old stream, if the stream was changed, or *None* if it wasn't."
msgstr "el anterior *stream*. si el *stream* cambió o *None* si no cambió."

#: ../Doc/library/logging.handlers.rst:75
msgid ""
"String used as the terminator when writing a formatted record to a stream. "
"Default value is ``'\\n'``."
msgstr ""
"Cadena utilizada como terminador al escribir un registro formateado en un "
"flujo. El valor por defecto es ``'\\n'``."

#: ../Doc/library/logging.handlers.rst:78
msgid ""
"If you don't want a newline termination, you can set the handler instance's "
"``terminator`` attribute to the empty string."
msgstr ""
"Si no quieres una terminación de nueva línea, puedes establecer el atributo "
"``terminator`` de la instancia del manejador a la cadena vacía."

#: ../Doc/library/logging.handlers.rst:81
msgid "In earlier versions, the terminator was hardcoded as ``'\\n'``."
msgstr ""
"En versiones anteriores, el terminador estaba codificado como ``'\\n'``."

#: ../Doc/library/logging.handlers.rst:89
msgid "FileHandler"
msgstr "FileHandler"

#: ../Doc/library/logging.handlers.rst:91
msgid ""
"The :class:`FileHandler` class, located in the core :mod:`logging` package, "
"sends logging output to a disk file.  It inherits the output functionality "
"from :class:`StreamHandler`."
msgstr ""
"La clase :class:`FileHandler` está localizada en el paquete núcleo :mod:"
"`logging`, envía la salida del *logging* a un archivo de disco. Hereda la "
"funcionalidad de salida de la clase :class:`StreamHandler`."

#: ../Doc/library/logging.handlers.rst:98
msgid ""
"Returns a new instance of the :class:`FileHandler` class. The specified file "
"is opened and used as the stream for logging. If *mode* is not specified, "
"``'a'`` is used.  If *encoding* is not ``None``, it is used to open the file "
"with that encoding.  If *delay* is true, then file opening is deferred until "
"the first call to :meth:`emit`. By default, the file grows indefinitely. If "
"*errors* is specified, it's used to determine how encoding errors are "
"handled."
msgstr ""
"Retorna una nueva instancia de la clase :class:`FileHandler`. El archivo "
"especificado se abre y se utiliza como flujo para el registro. Si no se "
"especifica *mode*, se utiliza ``'a'``. Si *encoding* no es ``None``, se "
"utiliza para abrir el archivo con esa codificación. Si *delay* es verdadero, "
"la apertura del archivo se pospone hasta la primera llamada a :meth:`emit`. "
"Por defecto, el archivo crece de manera indefinida. Si se especifica "
"*errors*, se usa para determinar cómo se manejan los errores de codificación."

#: ../Doc/library/logging.handlers.rst:105
#: ../Doc/library/logging.handlers.rst:190
#: ../Doc/library/logging.handlers.rst:338
#: ../Doc/library/logging.handlers.rst:444
msgid ""
"As well as string values, :class:`~pathlib.Path` objects are also accepted "
"for the *filename* argument."
msgstr ""
"Así como valores de cadena de caracteres, también se aceptan objetos de la "
"clase :class:`~pathlib.Path` para el argumento \"*filename*\"."

#: ../Doc/library/logging.handlers.rst:109
#: ../Doc/library/logging.handlers.rst:194
#: ../Doc/library/logging.handlers.rst:342
#: ../Doc/library/logging.handlers.rst:448
msgid "The *errors* parameter was added."
msgstr "Se agregó el parámetro *errors*."

#: ../Doc/library/logging.handlers.rst:114
msgid "Closes the file."
msgstr "Cierra el archivo."

#: ../Doc/library/logging.handlers.rst:118
msgid "Outputs the record to the file."
msgstr "Da la salida del registro al archivo."

#: ../Doc/library/logging.handlers.rst:120
msgid ""
"Note that if the file was closed due to logging shutdown at exit and the "
"file mode is 'w', the record will not be emitted (see :issue:`42378`)."
msgstr ""
"Ten en cuenta que si el archivo se cerró debido al apagado del registro al "
"salir y el modo de archivo es 'w', el registro no se emitirá (consulta :"
"issue:`42378`)."

#: ../Doc/library/logging.handlers.rst:127
msgid "NullHandler"
msgstr "NullHandler"

#: ../Doc/library/logging.handlers.rst:131
msgid ""
"The :class:`NullHandler` class, located in the core :mod:`logging` package, "
"does not do any formatting or output. It is essentially a 'no-op' handler "
"for use by library developers."
msgstr ""
"La clase :class:`NullHandler` está ubicada en el núcleo biblioteca :mod:"
"`logging` . No realiza ningún formateo o salida. Es en esencia un gestor 'no-"
"op' para uso de desarrolladores de bibliotecas."

#: ../Doc/library/logging.handlers.rst:137
msgid "Returns a new instance of the :class:`NullHandler` class."
msgstr "Retorna una nueva instancia de la clase :class:`NullHandler`."

#: ../Doc/library/logging.handlers.rst:141
#: ../Doc/library/logging.handlers.rst:145
msgid "This method does nothing."
msgstr "Este método no realiza ninguna acción."

#: ../Doc/library/logging.handlers.rst:149
msgid ""
"This method returns ``None`` for the lock, since there is no underlying I/O "
"to which access needs to be serialized."
msgstr ""
"Este método retorna ``None`` para el bloqueo , dado que no hay una E/S "
"subyacente cuyo acceso se necesite serializar."

#: ../Doc/library/logging.handlers.rst:153
msgid ""
"See :ref:`library-config` for more information on how to use :class:"
"`NullHandler`."
msgstr ""
"Véase :ref:`library-config` para mas información en como usar la clase :"
"class:`NullHandler`."

#: ../Doc/library/logging.handlers.rst:159
msgid "WatchedFileHandler"
msgstr "WatchedFileHandler"

#: ../Doc/library/logging.handlers.rst:163
msgid ""
"The :class:`WatchedFileHandler` class, located in the :mod:`logging."
"handlers` module, is a :class:`FileHandler` which watches the file it is "
"logging to. If the file changes, it is closed and reopened using the file "
"name."
msgstr ""
"La clase :class:`WatchedFileHandler` está ubicada en el módulo :mod:`logging."
"handlers`, es una clase :class:`FileHandler` que vigila a que archivo se "
"está enviando el *logging*. Si el archivo cambia , este se cerrará y se "
"volverá a abrir usando el nombre de archivo."

#: ../Doc/library/logging.handlers.rst:167
msgid ""
"A file change can happen because of usage of programs such as *newsyslog* "
"and *logrotate* which perform log file rotation. This handler, intended for "
"use under Unix/Linux, watches the file to see if it has changed since the "
"last emit. (A file is deemed to have changed if its device or inode have "
"changed.) If the file has changed, the old file stream is closed, and the "
"file opened to get a new stream."
msgstr ""
"Puede suceder que haya un cambio de archivo por uso de programas como "
"*newsyslog* y *logrotate* que realizan una rotación del archivo log. Este "
"gestor destinado para uso bajo Unix/Linux controla el archivo para ver si "
"hubo cambios desde la última emisión. (Un archivo se considera que cambió si "
"su dispositivo o nodo índice cambió). Si el archivo cambió entonces el "
"anterior *stream* de archivo se cerrará, y se abrirá el nuevo para obtener "
"un nuevo *stream*."

#: ../Doc/library/logging.handlers.rst:174
msgid ""
"This handler is not appropriate for use under Windows, because under Windows "
"open log files cannot be moved or renamed - logging opens the files with "
"exclusive locks - and so there is no need for such a handler. Furthermore, "
"*ST_INO* is not supported under Windows; :func:`~os.stat` always returns "
"zero for this value."
msgstr ""
"Este gestor no es apropiado para uso bajo Windows porque bajo Windows los "
"archivos log abiertos no se pueden mover o renombrar. *Logging* abre los "
"archivos con bloqueos exclusivos y entonces no hay necesidad de usar el "
"gestor. Por otra parte *ST_INO* no es soportado bajo Windows. La función :"
"func:`~os.stat` siempre retorna cero para este valor."

#: ../Doc/library/logging.handlers.rst:183
msgid ""
"Returns a new instance of the :class:`WatchedFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is used "
"to open the file with that encoding.  If *delay* is true, then file opening "
"is deferred until the first call to :meth:`emit`.  By default, the file "
"grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"Retorna una nueva instancia de la clase :class:`WatchedFileHandler`. El "
"archivo especificado se abre y se utiliza como flujo para el registro. Si no "
"se especifica *mode*, se utiliza ``'a'``. Si *encoding* no es ``None``, se "
"utiliza para abrir el archivo con esa codificación. Si *delay* es verdadero, "
"la apertura del archivo se pospone hasta la primera llamada a :meth:`emit`. "
"Por defecto, el archivo crece de manera indefinida. Si se proporciona "
"*errors*, determina cómo se manejan los errores de codificación."

#: ../Doc/library/logging.handlers.rst:199
msgid ""
"Checks to see if the file has changed.  If it has, the existing stream is "
"flushed and closed and the file opened again, typically as a precursor to "
"outputting the record to the file."
msgstr ""
"Revisa si el archivo cambió. Si hubo cambio, el *stream* existente se vacía "
"y cierra y el archivo se abre nuevamente. Típicamente es un precursor para "
"dar salida del registro a un archivo."

#: ../Doc/library/logging.handlers.rst:208
msgid ""
"Outputs the record to the file, but first calls :meth:`reopenIfNeeded` to "
"reopen the file if it has changed."
msgstr ""
"Da salida al registro a un archivo, pero primero invoca al método :meth:"
"`reopenIfNeeded` para reabrir el archivo si es que cambió."

#: ../Doc/library/logging.handlers.rst:214
msgid "BaseRotatingHandler"
msgstr "BaseRotatingHandler"

#: ../Doc/library/logging.handlers.rst:216
msgid ""
"The :class:`BaseRotatingHandler` class, located in the :mod:`logging."
"handlers` module, is the base class for the rotating file handlers, :class:"
"`RotatingFileHandler` and :class:`TimedRotatingFileHandler`. You should not "
"need to instantiate this class, but it has attributes and methods you may "
"need to override."
msgstr ""
"La clase :class:`BaseRotatingHandler` ubicada en el módulo :mod:`logging."
"handlers` es la clase base para rotar los gestores de archivos de clases :"
"class:`RotatingFileHandler` y :class:`TimedRotatingFileHandler`. No debería "
"ser necesario instanciar esta clase, pero tiene métodos y atributos que "
"quizá se necesiten sobrescribir (*override*)."

#: ../Doc/library/logging.handlers.rst:224
msgid "The parameters are as for :class:`FileHandler`. The attributes are:"
msgstr ""
"Los parámetros son como los de la clase :class:`FileHandler`. Los atributos "
"son:"

#: ../Doc/library/logging.handlers.rst:228
msgid ""
"If this attribute is set to a callable, the :meth:`rotation_filename` method "
"delegates to this callable. The parameters passed to the callable are those "
"passed to :meth:`rotation_filename`."
msgstr ""
"Si este atributo se establece como invocable, el método :meth:"
"`rotation_filename` delega a este invocable. Los parámetros pasados al "
"invocable son aquellos pasados al método :meth:`rotation_filename`."

#: ../Doc/library/logging.handlers.rst:232
msgid ""
"The namer function is called quite a few times during rollover, so it should "
"be as simple and as fast as possible. It should also return the same output "
"every time for a given input, otherwise the rollover behaviour may not work "
"as expected."
msgstr ""
"La función de nombrado es invocada unas cuantas veces durante el volcado "
"(*rollover*) , entonces debe ser tan simple y rápida como sea posible. Debe "
"también retornar siempre la misma salida para una misma entrada, de otra "
"manera el volcado puede no funcionar como se espera."

#: ../Doc/library/logging.handlers.rst:237
msgid ""
"It's also worth noting that care should be taken when using a namer to "
"preserve certain attributes in the filename which are used during rotation. "
"For example, :class:`RotatingFileHandler` expects to have a set of log files "
"whose names contain successive integers, so that rotation works as expected, "
"and :class:`TimedRotatingFileHandler` deletes old log files (based on the "
"``backupCount`` parameter passed to the handler's initializer) by "
"determining the oldest files to delete. For this to happen, the filenames "
"should be sortable using the date/time portion of the filename, and a namer "
"needs to respect this. (If a namer is wanted that doesn't respect this "
"scheme, it will need to be used in a subclass of :class:"
"`TimedRotatingFileHandler` which overrides the :meth:"
"`~TimedRotatingFileHandler.getFilesToDelete` method to fit in with the "
"custom naming scheme.)"
msgstr ""
"También vale la pena señalar que se debe tener cuidado al usar un nombrador "
"para conservar ciertos atributos en el nombre de archivo que se usan durante "
"la rotación. Por ejemplo, :class:`RotatingFileHandler` espera tener un "
"conjunto de archivos de registro cuyos nombres contengan números enteros "
"sucesivos, para que la rotación funcione como se espera, y :class:"
"`TimedRotatingFileHandler` elimina los archivos de registro antiguos (según "
"el parámetro ``backupCount`` pasado al inicializador del controlador), "
"determinando los archivos más antiguos para eliminar. Para que esto suceda, "
"los nombres de los archivos deben poder ordenarse utilizando la parte de "
"fecha/hora del nombre del archivo, y un nombrador debe respetar esto. (Si se "
"desea un nombrador que no respete este esquema, deberá usarse en una "
"subclase de :class:`TimedRotatingFileHandler` que anula el método :meth:"
"`~TimedRotatingFileHandler.getFilesToDelete` para encajar con el esquema de "
"denominación personalizada.)"

#: ../Doc/library/logging.handlers.rst:255
msgid ""
"If this attribute is set to a callable, the :meth:`rotate` method delegates "
"to this callable.  The parameters passed to the callable are those passed "
"to :meth:`rotate`."
msgstr ""
"Si este atributo se estableció como invocable, el método :meth:`rotate` "
"delega a este invocable. Los parámetros pasados al invocable son aquellos "
"pasados al método :meth:`rotate`."

#: ../Doc/library/logging.handlers.rst:263
msgid "Modify the filename of a log file when rotating."
msgstr "Modifica el nombre de un archivo log cuando esta rotando."

#: ../Doc/library/logging.handlers.rst:265
msgid "This is provided so that a custom filename can be provided."
msgstr ""
"Esto esta previsto para que pueda usarse un nombre de archivo personalizado."

#: ../Doc/library/logging.handlers.rst:267
msgid ""
"The default implementation calls the 'namer' attribute of the handler, if "
"it's callable, passing the default name to it. If the attribute isn't "
"callable (the default is ``None``), the name is returned unchanged."
msgstr ""
"La implementación por defecto llama al atributo 'namer' del gestor, si este "
"es invocable, pasando el nombre por defecto a él. Si el atributo no es "
"invocable (por defecto es ``None``) el nombre se retorna sin cambios."

#: ../Doc/library/logging.handlers.rst:271
msgid "The default name for the log file."
msgstr "El nombre por defecto para el archivo de log."

#: ../Doc/library/logging.handlers.rst:278
msgid "When rotating, rotate the current log."
msgstr "Cuando está rotando, rotar el actual log."

#: ../Doc/library/logging.handlers.rst:280
msgid ""
"The default implementation calls the 'rotator' attribute of the handler, if "
"it's callable, passing the source and dest arguments to it. If the attribute "
"isn't callable (the default is ``None``), the source is simply renamed to "
"the destination."
msgstr ""
"La implementación por defecto llama al atributo 'rotator' del gestor, si es "
"invocable, pasando los argumentos de origen y destino a él. Si no se puede "
"invocar (porque el atributo por defecto es 'None') el origen es simplemente "
"renombrado al destino."

#: ../Doc/library/logging.handlers.rst:285
msgid ""
"The source filename. This is normally the base filename, e.g. 'test.log'."
msgstr ""
"El nombre de archivo origen . Normalmente el nombre de archivo base, por "
"ejemplo 'test.log'."

#: ../Doc/library/logging.handlers.rst:287
msgid ""
"The destination filename. This is normally what the source is rotated to, e."
"g. 'test.log.1'."
msgstr ""
"El nombre de archivo de destino. Normalmente es el nombre al que se rota el "
"archivo origen por ejemplo 'test.log.1'."

#: ../Doc/library/logging.handlers.rst:292
msgid ""
"The reason the attributes exist is to save you having to subclass - you can "
"use the same callables for instances of :class:`RotatingFileHandler` and :"
"class:`TimedRotatingFileHandler`. If either the namer or rotator callable "
"raises an exception, this will be handled in the same way as any other "
"exception during an :meth:`emit` call, i.e. via the :meth:`handleError` "
"method of the handler."
msgstr ""
"La razón de que existen los atributos es para evitar tener que usar una "
"subclase - puedes usar los mismos invocadores para instancias de clase :"
"class:`RotatingFileHandler` y :class:`TimedRotatingFileHandler`. Si el "
"rotador invocable o la función de nombrado plantean una excepción esta se "
"manejará de la misma manera que cualquier otra excepción durante una llamada "
"al método :meth:`emit` por ejemplo a través del método :meth:`handleError` "
"del gestor."

#: ../Doc/library/logging.handlers.rst:299
msgid ""
"If you need to make more significant changes to rotation processing, you can "
"override the methods."
msgstr ""
"Si necesitas hacer cambios mas significativos al proceso de rotación puedes "
"obviar los métodos."

#: ../Doc/library/logging.handlers.rst:302
msgid "For an example, see :ref:`cookbook-rotator-namer`."
msgstr "Para un ejemplo véase :ref:`cookbook-rotator-namer`."

#: ../Doc/library/logging.handlers.rst:308
msgid "RotatingFileHandler"
msgstr "RotatingFileHandler"

#: ../Doc/library/logging.handlers.rst:310
msgid ""
"The :class:`RotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files."
msgstr ""
"La clase :class:`RotatingFileHandler`, localizada en el módulo :mod:`logging."
"handlers` soporta la rotación de archivos log de disco."

#: ../Doc/library/logging.handlers.rst:316
msgid ""
"Returns a new instance of the :class:`RotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. If *mode* is "
"not specified, ``'a'`` is used.  If *encoding* is not ``None``, it is used "
"to open the file with that encoding.  If *delay* is true, then file opening "
"is deferred until the first call to :meth:`emit`.  By default, the file "
"grows indefinitely. If *errors* is provided, it determines how encoding "
"errors are handled."
msgstr ""
"Retorna una nueva instancia de la clase :class:`RotatingFileHandler`. El "
"archivo especificado se abre y se utiliza como flujo para el registro. Si no "
"se especifica *mode*, se utiliza ``'a'``. Si *encoding* no es ``None``, se "
"utiliza para abrir el archivo con esa codificación. Si *delay* es verdadero, "
"la apertura del archivo se aplaza hasta la primera llamada a :meth:`emit`. "
"De forma predeterminada, el archivo crece indefinidamente. Si se proporciona "
"*errors*, determina cómo se manejan los errores de codificación."

#: ../Doc/library/logging.handlers.rst:323
msgid ""
"You can use the *maxBytes* and *backupCount* values to allow the file to :"
"dfn:`rollover` at a predetermined size. When the size is about to be "
"exceeded, the file is closed and a new file is silently opened for output. "
"Rollover occurs whenever the current log file is nearly *maxBytes* in "
"length; but if either of *maxBytes* or *backupCount* is zero, rollover never "
"occurs, so you generally want to set *backupCount* to at least 1, and have a "
"non-zero *maxBytes*. When *backupCount* is non-zero, the system will save "
"old log files by appending the extensions '.1', '.2' etc., to the filename. "
"For example, with a *backupCount* of 5 and a base file name of :file:`app."
"log`, you would get :file:`app.log`, :file:`app.log.1`, :file:`app.log.2`, "
"up to :file:`app.log.5`. The file being written to is always :file:`app."
"log`.  When this file is filled, it is closed and renamed to :file:`app."
"log.1`, and if files :file:`app.log.1`, :file:`app.log.2`, etc. exist, then "
"they are renamed to :file:`app.log.2`, :file:`app.log.3` etc. respectively."
msgstr ""
"Se pueden usar los valores *maxBytes* y *backupCount* para permitir que el "
"archivo :dfn:`rollover` tenga un tamaño predeterminado. Cuando el tamaño del "
"archivo está a punto de excederse, se cerrará y un nuevo archivo se abrirá "
"silenciosamente para salida. El volcado (*rollover*) ocurre cada vez que el "
"actual archivo log esta cerca de *maxBytes* en tamaño , pero si cualquiera "
"*maxBytes* o *backupCount* es cero, el volcado (*rollover*) no ocurre. Por "
"eso generalmente necesitas establecer *backupCount* por lo menos en 1 y no "
"tener cero en *maxBytes*. Cuando *backupCount* no es cero, el sistema "
"guardará los anteriores archivos log agregando las extensiones '.1', '.2' "
"etc. al nombre del archivo. Por ejemplo con un *backupCount* de 5 y un "
"nombre de archivo base de :file:`app.log`, tendrás como nombre de archivo t :"
"file:`app.log`, :file:`app.log.1`, :file:`app.log.2`, hasta :file:`app."
"log.5`. El archivo que esta siendo escrito es siempre :file:`app.log`. "
"Cuando este se completa , se cierra y se renombra a :file:`app.log.1` y si "
"ya existen :file:`app.log.1`, :file:`app.log.2`, etc. Entonces se renombrará "
"como :file:`app.log.2`, :file:`app.log.3` etc. respectivamente."

#: ../Doc/library/logging.handlers.rst:347
#: ../Doc/library/logging.handlers.rst:453
msgid "Does a rollover, as described above."
msgstr "Realiza un volcado (*rollover*) como se describe arriba."

#: ../Doc/library/logging.handlers.rst:352
msgid ""
"Outputs the record to the file, catering for rollover as described "
"previously."
msgstr ""
"Da la salida del registro al archivo , dando suministro para el volcado "
"(*rollover*) como está descripto anteriormente."

#: ../Doc/library/logging.handlers.rst:358
msgid "TimedRotatingFileHandler"
msgstr "TimedRotatingFileHandler"

#: ../Doc/library/logging.handlers.rst:360
msgid ""
"The :class:`TimedRotatingFileHandler` class, located in the :mod:`logging."
"handlers` module, supports rotation of disk log files at certain timed "
"intervals."
msgstr ""
"La clase :class:`TimedRotatingFileHandler` está ubicada en el módulo :mod:"
"`logging.handlers`. Soporta la rotación de archivos de log a ciertos "
"intervalos de tiempo."

#: ../Doc/library/logging.handlers.rst:367
msgid ""
"Returns a new instance of the :class:`TimedRotatingFileHandler` class. The "
"specified file is opened and used as the stream for logging. On rotating it "
"also sets the filename suffix. Rotating happens based on the product of "
"*when* and *interval*."
msgstr ""
"Retorna una nueva instancia de la clase :class:`TimedRotatingFileHandler` . "
"El archivo especificado es abierto y usado como *stream* para el historial "
"de log. En la rotación también establece el sufijo del nombre de archivo. La "
"rotación ocurre basada en el producto de *when* y *interval*."

#: ../Doc/library/logging.handlers.rst:372
msgid ""
"You can use the *when* to specify the type of *interval*. The list of "
"possible values is below.  Note that they are not case sensitive."
msgstr ""
"Puedes usar el *when* para especificar el tipo de intervalo *interval*. La "
"lista de posibles valores esta debajo. Nota que no distingue mayúsculas y "
"minúsculas."

#: ../Doc/library/logging.handlers.rst:376
msgid "Value"
msgstr "Valor"

#: ../Doc/library/logging.handlers.rst:376
msgid "Type of interval"
msgstr "Tipo de intervalo"

#: ../Doc/library/logging.handlers.rst:376
msgid "If/how *atTime* is used"
msgstr "Si/como *atTime* es usado"

#: ../Doc/library/logging.handlers.rst:378
msgid "``'S'``"
msgstr "``'S'``"

#: ../Doc/library/logging.handlers.rst:378
msgid "Seconds"
msgstr "Segundos"

#: ../Doc/library/logging.handlers.rst:378
#: ../Doc/library/logging.handlers.rst:380
#: ../Doc/library/logging.handlers.rst:382
#: ../Doc/library/logging.handlers.rst:384
msgid "Ignored"
msgstr "Ignorado"

#: ../Doc/library/logging.handlers.rst:380
msgid "``'M'``"
msgstr "``'M'``"

#: ../Doc/library/logging.handlers.rst:380
msgid "Minutes"
msgstr "Minutos"

#: ../Doc/library/logging.handlers.rst:382
msgid "``'H'``"
msgstr "``'H'``"

#: ../Doc/library/logging.handlers.rst:382
msgid "Hours"
msgstr "Horas"

#: ../Doc/library/logging.handlers.rst:384
msgid "``'D'``"
msgstr "``'D'``"

#: ../Doc/library/logging.handlers.rst:384
msgid "Days"
msgstr "Días"

#: ../Doc/library/logging.handlers.rst:386
msgid "``'W0'-'W6'``"
msgstr "``'W0'-'W6'``"

#: ../Doc/library/logging.handlers.rst:386
msgid "Weekday (0=Monday)"
msgstr "Día de la semana (0=Lunes)"

#: ../Doc/library/logging.handlers.rst:386
#: ../Doc/library/logging.handlers.rst:389
msgid "Used to compute initial rollover time"
msgstr "Usado para calcular la hora inicial del volcado *rollover*"

#: ../Doc/library/logging.handlers.rst:389
msgid "``'midnight'``"
msgstr "``'midnight'``"

#: ../Doc/library/logging.handlers.rst:389
msgid "Roll over at midnight, if *atTime* not specified, else at time *atTime*"
msgstr ""
"Volcado (*rollover*) a medianoche , si *atTime* no está especificado, sino "
"el volcado se hará *atTime*"

#: ../Doc/library/logging.handlers.rst:394
msgid ""
"When using weekday-based rotation, specify 'W0' for Monday, 'W1' for "
"Tuesday, and so on up to 'W6' for Sunday. In this case, the value passed for "
"*interval* isn't used."
msgstr ""
"Cuando se usa rotación basada en día de la semana, especifica 'W0' para "
"Lunes, 'W1' para Martes y así, hasta 'W6' para Domingo. en este caso el "
"valor pasado para *Interval* no se usa."

#: ../Doc/library/logging.handlers.rst:398
#, python-format
msgid ""
"The system will save old log files by appending extensions to the filename. "
"The extensions are date-and-time based, using the strftime format ``%Y-%m-"
"%d_%H-%M-%S`` or a leading portion thereof, depending on the rollover "
"interval."
msgstr ""
"El sistema guardará los archivos de log anteriores agregándoles extensiones "
"al nombre de archivo. Las extensiones están basadas en día-hora usando el "
"formato ``%Y-%m-%d_%H-%M-%S`` o un prefijo respecto el intervalo del volcado "
"(*rollover*)."

#: ../Doc/library/logging.handlers.rst:403
msgid ""
"When computing the next rollover time for the first time (when the handler "
"is created), the last modification time of an existing log file, or else the "
"current time, is used to compute when the next rotation will occur."
msgstr ""
"Cuando se calcula la hora del siguiente volcado (*rollover*) por primera vez "
"(cuando el gestor es creado), la última hora de modificación de un archivo "
"log existente o sino la hora actual, se usa para calcular cuando será la "
"próxima rotación."

#: ../Doc/library/logging.handlers.rst:407
msgid ""
"If the *utc* argument is true, times in UTC will be used; otherwise local "
"time is used."
msgstr ""
"Si el argumento *utc* es *true* se usará la hora en UTC, sino se usará la "
"hora local."

#: ../Doc/library/logging.handlers.rst:410
msgid ""
"If *backupCount* is nonzero, at most *backupCount* files will be kept, and "
"if more would be created when rollover occurs, the oldest one is deleted. "
"The deletion logic uses the interval to determine which files to delete, so "
"changing the interval may leave old files lying around."
msgstr ""
"Si *backupCount* no es cero, se conservará como máximo una cantidad de "
"archivos especificada en *backupCount*,y si son creados más, cuando ocurre "
"el volcado (*rollover*) se borrará el último. La lógica de borrado usa el "
"intervalo para determinar que archivos borrar, pues entonces cambiando el "
"intervalo puede dejar viejos archivos abandonados."

#: ../Doc/library/logging.handlers.rst:415
msgid ""
"If *delay* is true, then file opening is deferred until the first call to :"
"meth:`emit`."
msgstr ""
"Si *delay* es *true* entonces la apertura del archivo se demorará hasta la "
"primer llamada a :meth:`emit`."

#: ../Doc/library/logging.handlers.rst:418
msgid ""
"If *atTime* is not ``None``, it must be a ``datetime.time`` instance which "
"specifies the time of day when rollover occurs, for the cases where rollover "
"is set to happen \"at midnight\" or \"on a particular weekday\". Note that "
"in these cases, the *atTime* value is effectively used to compute the "
"*initial* rollover, and subsequent rollovers would be calculated via the "
"normal interval calculation."
msgstr ""
"Si *atTime* no es \"None\", debe haber una instancia ``datetime.time`` que "
"especifica la hora que ocurre el volcado (*rollover*) , para los casos en "
"que el volcado esta establecido para ocurrir \"a medianoche\" o \"un día en "
"particular\". Nótese que en estos casos el valor *atTime* se usa para "
"calcular el valor *initial* del volcado (*rollover*) y los subsecuentes "
"volcados serán calculados a través del calculo normal de intervalos."

#: ../Doc/library/logging.handlers.rst:425
msgid ""
"If *errors* is specified, it's used to determine how encoding errors are "
"handled."
msgstr ""
"Si se especifica *errors*, se utiliza para determinar cómo se manejan los "
"errores de codificación."

#: ../Doc/library/logging.handlers.rst:428
msgid ""
"Calculation of the initial rollover time is done when the handler is "
"initialised. Calculation of subsequent rollover times is done only when "
"rollover occurs, and rollover occurs only when emitting output. If this is "
"not kept in mind, it might lead to some confusion. For example, if an "
"interval of \"every minute\" is set, that does not mean you will always see "
"log files with times (in the filename) separated by a minute; if, during "
"application execution, logging output is generated more frequently than once "
"a minute, *then* you can expect to see log files with times separated by a "
"minute. If, on the other hand, logging messages are only output once every "
"five minutes (say), then there will be gaps in the file times corresponding "
"to the minutes where no output (and hence no rollover) occurred."
msgstr ""
"El cálculo de la hora en que se realizara el volcado (*rollover*) inicial "
"cuando se inicializa el gestor. El cálculo de la hora de los siguientes "
"volcados (*rollovers*) se realiza solo cuando este ocurre, y el volcado "
"ocurre solo cuando se emite una salida. Si esto no se tiene en cuenta puede "
"generar cierta confusión. Por ejemplo si se establece un intervalo de \"cada "
"minuto\" eso no significa que siempre se verán archivos log con hora (en el "
"nombre del archivo) separados por un minuto. Si durante la ejecución de la "
"aplicación el *logging* se genera con mayor frecuencia que un minuto "
"entonces se pueden esperar archivos log separados por un minuto. Si por otro "
"lado los mensajes *logging* son establecidos cada digamos cinco minutos, "
"entonces habrá brechas de tiempo en los archivos correspondientes a los "
"minutos que no hubo salida (y no ocurrió por tanto volcado alguno)."

#: ../Doc/library/logging.handlers.rst:441
msgid "*atTime* parameter was added."
msgstr "Se agregó el parámetro *atTime*."

#: ../Doc/library/logging.handlers.rst:457
msgid ""
"Outputs the record to the file, catering for rollover as described above."
msgstr ""
"Da la salida del registro a un archivo , proveyendo la información para el "
"volcado (*rollover*) como esta descripto anteriormente."

#: ../Doc/library/logging.handlers.rst:461
msgid ""
"Returns a list of filenames which should be deleted as part of rollover. "
"These are the absolute paths of the oldest backup log files written by the "
"handler."
msgstr ""
"Retorna una lista de nombres de archivos que deben eliminarse como parte del "
"volcado (*rollover*). Estas son las rutas absolutas de los archivos de "
"registro de copia de seguridad más antiguos escritos por el controlador."

#: ../Doc/library/logging.handlers.rst:467
msgid "SocketHandler"
msgstr "SocketHandler"

#: ../Doc/library/logging.handlers.rst:469
msgid ""
"The :class:`SocketHandler` class, located in the :mod:`logging.handlers` "
"module, sends logging output to a network socket. The base class uses a TCP "
"socket."
msgstr ""
"La clase :class:`SocketHandler` esta localizada en el módulo :mod:`logging."
"handlers`, envía el *logging* a un socket de la red. La clase base usa "
"*sockets* TCP."

#: ../Doc/library/logging.handlers.rst:475
msgid ""
"Returns a new instance of the :class:`SocketHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""
"Retorna una nueva instancia de la clase :class:`SocketHandler` destinada "
"para comunicarse con una terminal remota cuya dirección esta dada por *host* "
"y *port*."

#: ../Doc/library/logging.handlers.rst:478
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a TCP socket is created."
msgstr ""
"Si \"port\" se especifica como ``None`` se crea un socket de dominio Unix, "
"usando el valor en ``host`` - de otra manera se creará un socket TCP."

#: ../Doc/library/logging.handlers.rst:484
msgid "Closes the socket."
msgstr "Cierra el socket."

#: ../Doc/library/logging.handlers.rst:489
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. If the connection was previously lost, re-establishes the "
"connection. To unpickle the record at the receiving end into a :class:"
"`~logging.LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""
"Serializa (*Pickles*) el registro del diccionario de atributos y lo escribe "
"en el socket en formato binario. Si hay un error con el socket, "
"silenciosamente descarta el paquete. Si la conexión se perdió previamente, "
"la restablece. Para deserializar (*unpickle*) un registro en el extremo "
"receptor a una clase :class:`~logging.LogRecord`, usa la función :func:"
"`~logging.makeLogRecord`."

#: ../Doc/library/logging.handlers.rst:499
msgid ""
"Handles an error which has occurred during :meth:`emit`. The most likely "
"cause is a lost connection. Closes the socket so that we can retry on the "
"next event."
msgstr ""
"Maneja un error que ocurrió durante el método :meth:`emit`. La causa mas "
"común es una perdida de conexión. Cierra el socket para que podamos "
"reintentar en el próximo evento."

#: ../Doc/library/logging.handlers.rst:506
msgid ""
"This is a factory method which allows subclasses to define the precise type "
"of socket they want. The default implementation creates a TCP socket (:const:"
"`socket.SOCK_STREAM`)."
msgstr ""
"Este es un método patrón que permite subclases para definir el tipo preciso "
"de socket que se necesita. La implementación por defecto crea un socket TCP(:"
"const:`socket.SOCK_STREAM`)."

#: ../Doc/library/logging.handlers.rst:513
msgid ""
"Pickles the record's attribute dictionary in binary format with a length "
"prefix, and returns it ready for transmission across the socket. The details "
"of this operation are equivalent to::"
msgstr ""
"Serializa (*pickles*) el registro del diccionario de atributos en formato "
"binario con un prefijo de tamaño, y lo retorna listo para transmitir a "
"través del socket. Los detalles de esta operación son equivalentes a::"

#: ../Doc/library/logging.handlers.rst:521
msgid ""
"Note that pickles aren't completely secure. If you are concerned about "
"security, you may want to override this method to implement a more secure "
"mechanism. For example, you can sign pickles using HMAC and then verify them "
"on the receiving end, or alternatively you can disable unpickling of global "
"objects on the receiving end."
msgstr ""
"Nota que los serializados (*pickles*) no son totalmente seguros. Si te "
"preocupa la seguridad desearás evitar este método para implementar un "
"mecanismo mas seguro. Por ejemplo puedes firmar *pickles* usando HMAC y "
"verificarlos después en el extremo receptor. O alternativamente puedes "
"deshabilitar la deserialización (*unpickling*) de objetos globales en el "
"extremo receptor."

#: ../Doc/library/logging.handlers.rst:530
msgid ""
"Send a pickled byte-string *packet* to the socket. The format of the sent "
"byte-string is as described in the documentation for :meth:`~SocketHandler."
"makePickle`."
msgstr ""
"Envía un paquete serializado (*pickled*) de cadena de caracteres al socket. "
"El formato de la cadena de bytes enviada es tal como se describe en la "
"documentación de :meth:`~SocketHandler.makePickle`."

#: ../Doc/library/logging.handlers.rst:534
msgid ""
"This function allows for partial sends, which can happen when the network is "
"busy."
msgstr ""
"Esta función permite envíos parciales, que pueden ocurrir cuando la red esta "
"ocupada."

#: ../Doc/library/logging.handlers.rst:540
msgid ""
"Tries to create a socket; on failure, uses an exponential back-off "
"algorithm.  On initial failure, the handler will drop the message it was "
"trying to send.  When subsequent messages are handled by the same instance, "
"it will not try connecting until some time has passed.  The default "
"parameters are such that the initial delay is one second, and if after that "
"delay the connection still can't be made, the handler will double the delay "
"each time up to a maximum of 30 seconds."
msgstr ""
"Intenta crear un socket, si hay una falla usa un algoritmo de marcha atrás "
"exponencial. En el fallo inicial el gestor desechará el mensaje que "
"intentaba enviar. Cuando los siguientes mensajes sean gestionados por la "
"misma instancia no intentará conectarse hasta que haya transcurrido cierto "
"tiempo. Los parámetros por defecto son tales que el retardo inicial es un "
"segundo y si después del retardo la conexión todavía no se puede realizar, "
"el gestor doblará el retardo cada vez hasta un máximo de 30 segundos."

#: ../Doc/library/logging.handlers.rst:548
msgid "This behaviour is controlled by the following handler attributes:"
msgstr ""
"Este comportamiento es controlado por los siguientes atributos del gestor:"

#: ../Doc/library/logging.handlers.rst:550
msgid "``retryStart`` (initial delay, defaulting to 1.0 seconds)."
msgstr "``retryStart`` (retardo inicial por defecto 1.0 segundos)"

#: ../Doc/library/logging.handlers.rst:551
msgid "``retryFactor`` (multiplier, defaulting to 2.0)."
msgstr "``retryFactor`` (multiplicador por defecto 2.0)"

#: ../Doc/library/logging.handlers.rst:552
msgid "``retryMax`` (maximum delay, defaulting to 30.0 seconds)."
msgstr "``retryMax`` (máximo retardo por defecto 30.0 segundos)"

#: ../Doc/library/logging.handlers.rst:554
msgid ""
"This means that if the remote listener starts up *after* the handler has "
"been used, you could lose messages (since the handler won't even attempt a "
"connection until the delay has elapsed, but just silently drop messages "
"during the delay period)."
msgstr ""
"Esto significa que si el oyente remoto (*listener*) comienza después de que "
"se usó el gestor , pueden perderse mensajes (dado que el gestor no puede "
"siquiera intentar una conexión hasta que se haya cumplido el retardo, y "
"silenciosamente desechará los mensajes mientras se cumpla el retardo)."

#: ../Doc/library/logging.handlers.rst:563
msgid "DatagramHandler"
msgstr "DatagramHandler"

#: ../Doc/library/logging.handlers.rst:565
msgid ""
"The :class:`DatagramHandler` class, located in the :mod:`logging.handlers` "
"module, inherits from :class:`SocketHandler` to support sending logging "
"messages over UDP sockets."
msgstr ""
"La clase :class:`DatagramHandler` está ubicada en el módulo :mod:`logging."
"handlers`, hereda de la clase :class:`SocketHandler` para realizar el "
"soporte de mensajes *logging* por los *sockets* UDP."

#: ../Doc/library/logging.handlers.rst:572
msgid ""
"Returns a new instance of the :class:`DatagramHandler` class intended to "
"communicate with a remote machine whose address is given by *host* and "
"*port*."
msgstr ""
"Retorna una nueva instancia de la clase :class:`DatagramHandler` destinada "
"para comunicarse con la terminal remota cuya dirección es dada por *host* y "
"*port*."

#: ../Doc/library/logging.handlers.rst:575
msgid ""
"As UDP is not a streaming protocol, there is no persistent connection "
"between an instance of this handler and *host*. For this reason, when using "
"a network socket, a DNS lookup might have to be made each time an event is "
"logged, which can introduce some latency into the system. If this affects "
"you, you can do a lookup yourself and initialize this handler using the "
"looked-up IP address rather than the hostname."
msgstr ""
"Como UDP no es un protocolo de transmisión, no existe una conexión "
"persistente entre una instancia de este controlador y *host*. Por esta "
"razón, cuando se usa un socket de red, es posible que se deba realizar una "
"búsqueda de DNS cada vez que se registra un evento, lo que puede generar "
"cierta latencia en el sistema. Si esto te afecta, puedes realizar una "
"búsqueda tu mismo e inicializar este controlador utilizando la dirección IP "
"buscada en lugar del nombre de host."

#: ../Doc/library/logging.handlers.rst:582
msgid ""
"If ``port`` is specified as ``None``, a Unix domain socket is created using "
"the value in ``host`` - otherwise, a UDP socket is created."
msgstr ""
"Si 'port' se especifica como \"None\", se crea un socket de dominio Unix, "
"usando el valor en \"host\" - de otra manera se crea un socket UDP."

#: ../Doc/library/logging.handlers.rst:588
msgid ""
"Pickles the record's attribute dictionary and writes it to the socket in "
"binary format. If there is an error with the socket, silently drops the "
"packet. To unpickle the record at the receiving end into a :class:`~logging."
"LogRecord`, use the :func:`~logging.makeLogRecord` function."
msgstr ""
"Serializa (*pickles*) el registro del diccionario de atributos y lo escribe "
"en el socket en formato binario. Si hay un error con el socket, "
"silenciosamente desecha el paquete. Para deserializar (*unpickle*) el "
"registro en el extremo de recepción a una clase :class:`~logging.LogRecord`, "
"usa la función :func:`~logging.makeLogRecord`."

#: ../Doc/library/logging.handlers.rst:597
msgid ""
"The factory method of :class:`SocketHandler` is here overridden to create a "
"UDP socket (:const:`socket.SOCK_DGRAM`)."
msgstr ""
"El método original de la clase :class:`SocketHandler` se omite para crear un "
"socket UDP (:const:`socket.SOCK_DGRAM`)."

#: ../Doc/library/logging.handlers.rst:603
msgid ""
"Send a pickled byte-string to a socket. The format of the sent byte-string "
"is as described in the documentation for :meth:`SocketHandler.makePickle`."
msgstr ""
"Enviar una cadena de caracteres serializada (*pickled*) a un socket de red. "
"El formato de la cadena de *bytes* enviado es tal como se describe en la "
"documentación para :meth:`SocketHandler.makePickle`."

#: ../Doc/library/logging.handlers.rst:610
msgid "SysLogHandler"
msgstr "Gestor *SysLog* (*SysLogHandler*)"

#: ../Doc/library/logging.handlers.rst:612
msgid ""
"The :class:`SysLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a remote or local Unix syslog."
msgstr ""
"La clase :class:`SysLogHandler` está ubicada en el módulo :mod:`logging."
"handlers`. Realiza el soporte de los mensajes de *logging* a un *syslog* "
"Unix local o remoto."

#: ../Doc/library/logging.handlers.rst:618
msgid ""
"Returns a new instance of the :class:`SysLogHandler` class intended to "
"communicate with a remote Unix machine whose address is given by *address* "
"in the form of a ``(host, port)`` tuple.  If *address* is not specified, "
"``('localhost', 514)`` is used.  The address is used to open a socket.  An "
"alternative to providing a ``(host, port)`` tuple is providing an address as "
"a string, for example '/dev/log'. In this case, a Unix domain socket is used "
"to send the message to the syslog. If *facility* is not specified, :const:"
"`LOG_USER` is used. The type of socket opened depends on the *socktype* "
"argument, which defaults to :const:`socket.SOCK_DGRAM` and thus opens a UDP "
"socket. To open a TCP socket (for use with the newer syslog daemons such as "
"rsyslog), specify a value of :const:`socket.SOCK_STREAM`."
msgstr ""
"Retorna una nueva instancia de la clase :class:`SysLogHandler` concebida "
"para comunicarse con una terminal remota Unix cuya dirección esta dada por "
"*address* en la forma de una tupla ``(host, port)`` . Si *address* no se "
"especifica se usará ``('localhost', 514)``. La dirección se usa para abrir "
"el socket. Una alternativa a consignar una tupla ``(host, port)`` es proveer "
"una dirección como cadena de caracteres, por ejemplo '/dev/log'. En este "
"caso se usa un socket de dominio Unix para enviar el mensaje al syslog. Si "
"*facility* no se especifica se usara :const:`LOG_USER` . El tipo de socket "
"abierto usado depende del argumento *socktype* , que por defecto es :const:"
"`socket.SOCK_DGRAM` y por lo tanto abre un socket UDP . Para abrir un socket "
"TCP (para usar con los nuevos *daemons syslog* como rsyslog) se debe "
"especificar un valor de :const:`socket.SOCK_STREAM`."

#: ../Doc/library/logging.handlers.rst:630
msgid ""
"Note that if your server is not listening on UDP port 514, :class:"
"`SysLogHandler` may appear not to work. In that case, check what address you "
"should be using for a domain socket - it's system dependent. For example, on "
"Linux it's usually '/dev/log' but on OS/X it's '/var/run/syslog'. You'll "
"need to check your platform and use the appropriate address (you may need to "
"do this check at runtime if your application needs to run on several "
"platforms). On Windows, you pretty much have to use the UDP option."
msgstr ""
"Nótese que si el servidor no esta escuchando el puerto UDP 514, la clase :"
"class:`SysLogHandler` puede parecer no funcionar. En ese caso chequea que "
"dirección deberías usar para un socket de dominio . Es sistema-dependiente. "
"Por ejemplo en Linux generalmente es '/dev/log' pero en OS/X es '/var/run/"
"syslog'. Será necesario chequear tu plataforma y usar la dirección adecuada "
"(quizá sea necesario realizar este chequeo mientras corre la aplicación si "
"necesita correr en diferentes plataformas). En Windows seguramente tengas "
"que usar la opción UDP."

#: ../Doc/library/logging.handlers.rst:639
msgid ""
"On macOS 12.x (Monterey), Apple has changed the behaviour of their syslog "
"daemon - it no longer listens on a domain socket. Therefore, you cannot "
"expect :class:`SysLogHandler` to work on this system."
msgstr ""
"En macOS 12.x (Monterey), Apple cambió el comportamiento de su syslog "
"daemon: ya no escucha en un socket de dominio. Por lo tanto, no puedes "
"esperar que :class:`SysLogHandler` funcione en este sistema."

#: ../Doc/library/logging.handlers.rst:643
msgid "See :gh:`91070` for more information."
msgstr "Ver :gh:`91070` para más información."

#: ../Doc/library/logging.handlers.rst:645
msgid "*socktype* was added."
msgstr "Se agregó *socktype*."

#: ../Doc/library/logging.handlers.rst:651
msgid "Closes the socket to the remote host."
msgstr "Cierra el socket del host remoto."

#: ../Doc/library/logging.handlers.rst:655
msgid ""
"Tries to create a socket and, if it's not a datagram socket, connect it to "
"the other end. This method is called during handler initialization, but it's "
"not regarded as an error if the other end isn't listening at this point - "
"the method will be called again when emitting an event, if but it's not "
"regarded as an error if the other end isn't listening yet --- the method "
"will be called again when emitting an event, if there is no socket at that "
"point."
msgstr ""
"Intenta crear un socket y, si no es un socket de datagrama, lo conecta al "
"otro extremo. Este método es llamado durante la inicialización del "
"controlador, pero no se considera un error si el otro extremo no está "
"escuchando en este momento; el método se volverá a llamar cuando se emita un "
"evento, pero no se considera un error si el otro extremo no está escuchando "
"todavía --- el método se volverá a llamar cuando se emita un evento, si no "
"hay ningún socket en ese momento."

#: ../Doc/library/logging.handlers.rst:667
msgid ""
"The record is formatted, and then sent to the syslog server. If exception "
"information is present, it is *not* sent to the server."
msgstr ""
"El registro es formateado, y luego enviado al servidor *syslog*. Si hay "
"información de excepción presente entonces no se enviará al servidor."

#: ../Doc/library/logging.handlers.rst:670
msgid ""
"(See: :issue:`12168`.) In earlier versions, the message sent to the syslog "
"daemons was always terminated with a NUL byte, because early versions of "
"these daemons expected a NUL terminated message - even though it's not in "
"the relevant specification (:rfc:`5424`). More recent versions of these "
"daemons don't expect the NUL byte but strip it off if it's there, and even "
"more recent daemons (which adhere more closely to RFC 5424) pass the NUL "
"byte on as part of the message."
msgstr ""
"(Véase el :issue:`12168`.) En versiones anteriores , los mensajes enviados a "
"los *daemons syslog* siempre terminaban con un byte NUL ya que versiones "
"anteriores de estos *daemons* esperaban un mensaje NUL de terminación. "
"Incluso a pesar que no es relevante la especificación (:rfc:`5424`). "
"Versiones mas recientes de estos *daemons* no esperan el byte NUL pero lo "
"quitan si esta ahí. Versiones aún mas recientes que están mas cercanas a la "
"especificación RFC 5424 pasan el byte NUL como parte del mensaje."

#: ../Doc/library/logging.handlers.rst:679
msgid ""
"To enable easier handling of syslog messages in the face of all these "
"differing daemon behaviours, the appending of the NUL byte has been made "
"configurable, through the use of a class-level attribute, ``append_nul``. "
"This defaults to ``True`` (preserving the existing behaviour) but can be set "
"to ``False`` on a ``SysLogHandler`` instance in order for that instance to "
"*not* append the NUL terminator."
msgstr ""
"Para habilitar una gestión mas sencilla de los mensajes *syslog* respecto de "
"todos esos *daemons* de diferentes comportamientos el agregado del byte NUL "
"es configurable a través del uso del atributo de nivel de clase "
"``append_nul``. Este es por defecto '``True`` (preservando el comportamiento "
"ya existente) pero se puede establecer a 'False' en una instancia "
"``SysLogHandler`` como para que esa instancia no añada el terminador NUL."

#: ../Doc/library/logging.handlers.rst:686
msgid ""
"(See: :issue:`12419`.) In earlier versions, there was no facility for an "
"\"ident\" or \"tag\" prefix to identify the source of the message. This can "
"now be specified using a class-level attribute, defaulting to ``\"\"`` to "
"preserve existing behaviour, but which can be overridden on a "
"``SysLogHandler`` instance in order for that instance to prepend the ident "
"to every message handled. Note that the provided ident must be text, not "
"bytes, and is prepended to the message exactly as is."
msgstr ""
"(Véase: issue '12419') en versiones anteriores, no había posibilidades para "
"un prefijo 'ident' o 'tag' para identificar el origen del mensaje. Esto "
"ahora se puede especificar usando un atributo de nivel de clase, que por "
"defecto será \"''\" para preservar el comportamiento existente , pero puede "
"ser sorteado en una instancia ``SysLogHandler`` para que esta instancia "
"anteponga el *ident* a todos los mensajes gestionados. Nótese que el *ident* "
"provisto debe ser texto, no bytes y se antepone al mensaje tal como es."

#: ../Doc/library/logging.handlers.rst:697
msgid ""
"Encodes the facility and priority into an integer. You can pass in strings "
"or integers - if strings are passed, internal mapping dictionaries are used "
"to convert them to integers."
msgstr ""
"Codifica la funcionalidad y prioridad en un entero. Puedes pasar cadenas de "
"caracteres o enteros, si pasas cadenas de caracteres se usarán los "
"diccionarios de mapeo interno para convertirlos en enteros."

#: ../Doc/library/logging.handlers.rst:701
msgid ""
"The symbolic ``LOG_`` values are defined in :class:`SysLogHandler` and "
"mirror the values defined in the ``sys/syslog.h`` header file."
msgstr ""
"Los valores simbólicos ``LOG_`` están definidos en :class:`SysLogHandler` e "
"invierten los valores definidos en el archivo de encabezado ``sys/syslog.h``."

#: ../Doc/library/logging.handlers.rst:704
msgid "**Priorities**"
msgstr "**Prioridades**"

#: ../Doc/library/logging.handlers.rst:707
#: ../Doc/library/logging.handlers.rst:729
msgid "Name (string)"
msgstr "Nombre (cadena de caracteres)"

#: ../Doc/library/logging.handlers.rst:707
#: ../Doc/library/logging.handlers.rst:729
msgid "Symbolic value"
msgstr "Valor simbólico"

#: ../Doc/library/logging.handlers.rst:709
msgid "``alert``"
msgstr "``alert``"

#: ../Doc/library/logging.handlers.rst:709
msgid "LOG_ALERT"
msgstr "LOG_ALERT"

#: ../Doc/library/logging.handlers.rst:711
msgid "``crit`` or ``critical``"
msgstr "``crit`` or ``critical``"

#: ../Doc/library/logging.handlers.rst:711
msgid "LOG_CRIT"
msgstr "LOG_CRIT"

#: ../Doc/library/logging.handlers.rst:713
msgid "``debug``"
msgstr "``debug``"

#: ../Doc/library/logging.handlers.rst:713
msgid "LOG_DEBUG"
msgstr "LOG_DEBUG"

#: ../Doc/library/logging.handlers.rst:715
msgid "``emerg`` or ``panic``"
msgstr "``emerg`` or ``panic``"

#: ../Doc/library/logging.handlers.rst:715
msgid "LOG_EMERG"
msgstr "LOG_EMERG"

#: ../Doc/library/logging.handlers.rst:717
msgid "``err`` or ``error``"
msgstr "``err`` or ``error``"

#: ../Doc/library/logging.handlers.rst:717
msgid "LOG_ERR"
msgstr "LOG_ERR"

#: ../Doc/library/logging.handlers.rst:719
msgid "``info``"
msgstr "``info``"

#: ../Doc/library/logging.handlers.rst:719
msgid "LOG_INFO"
msgstr "LOG_INFO"

#: ../Doc/library/logging.handlers.rst:721
msgid "``notice``"
msgstr "``notice``"

#: ../Doc/library/logging.handlers.rst:721
msgid "LOG_NOTICE"
msgstr "LOG_NOTICE"

#: ../Doc/library/logging.handlers.rst:723
msgid "``warn`` or ``warning``"
msgstr "``warn`` o ``warning``"

#: ../Doc/library/logging.handlers.rst:723
msgid "LOG_WARNING"
msgstr "LOG_WARNING"

#: ../Doc/library/logging.handlers.rst:726
msgid "**Facilities**"
msgstr "**Facilities**"

#: ../Doc/library/logging.handlers.rst:731
msgid "``auth``"
msgstr "``auth``"

#: ../Doc/library/logging.handlers.rst:731
msgid "LOG_AUTH"
msgstr "LOG_AUTH"

#: ../Doc/library/logging.handlers.rst:733
msgid "``authpriv``"
msgstr "``authpriv``"

#: ../Doc/library/logging.handlers.rst:733
msgid "LOG_AUTHPRIV"
msgstr "LOG_AUTHPRIV"

#: ../Doc/library/logging.handlers.rst:735
msgid "``cron``"
msgstr "``cron``"

#: ../Doc/library/logging.handlers.rst:735
msgid "LOG_CRON"
msgstr "LOG_CRON"

#: ../Doc/library/logging.handlers.rst:737
msgid "``daemon``"
msgstr "``daemon``"

#: ../Doc/library/logging.handlers.rst:737
msgid "LOG_DAEMON"
msgstr "LOG_DAEMON"

#: ../Doc/library/logging.handlers.rst:739
msgid "``ftp``"
msgstr "``ftp``"

#: ../Doc/library/logging.handlers.rst:739
msgid "LOG_FTP"
msgstr "LOG_FTP"

#: ../Doc/library/logging.handlers.rst:741
msgid "``kern``"
msgstr "``kern``"

#: ../Doc/library/logging.handlers.rst:741
msgid "LOG_KERN"
msgstr "LOG_KERN"

#: ../Doc/library/logging.handlers.rst:743
msgid "``lpr``"
msgstr "``lpr``"

#: ../Doc/library/logging.handlers.rst:743
msgid "LOG_LPR"
msgstr "LOG_LPR"

#: ../Doc/library/logging.handlers.rst:745
msgid "``mail``"
msgstr "``mail``"

#: ../Doc/library/logging.handlers.rst:745
msgid "LOG_MAIL"
msgstr "LOG_MAIL"

#: ../Doc/library/logging.handlers.rst:747
msgid "``news``"
msgstr "``news``"

#: ../Doc/library/logging.handlers.rst:747
msgid "LOG_NEWS"
msgstr "LOG_NEWS"

#: ../Doc/library/logging.handlers.rst:749
msgid "``syslog``"
msgstr "``syslog``"

#: ../Doc/library/logging.handlers.rst:749
msgid "LOG_SYSLOG"
msgstr "LOG_SYSLOG"

#: ../Doc/library/logging.handlers.rst:751
msgid "``user``"
msgstr "``user``"

#: ../Doc/library/logging.handlers.rst:751
msgid "LOG_USER"
msgstr "LOG_USER"

#: ../Doc/library/logging.handlers.rst:753
msgid "``uucp``"
msgstr "``uucp``"

#: ../Doc/library/logging.handlers.rst:753
msgid "LOG_UUCP"
msgstr "LOG_UUCP"

#: ../Doc/library/logging.handlers.rst:755
msgid "``local0``"
msgstr "``local0``"

#: ../Doc/library/logging.handlers.rst:755
msgid "LOG_LOCAL0"
msgstr "LOG_LOCAL0"

#: ../Doc/library/logging.handlers.rst:757
msgid "``local1``"
msgstr "``local1``"

#: ../Doc/library/logging.handlers.rst:757
msgid "LOG_LOCAL1"
msgstr "LOG_LOCAL1"

#: ../Doc/library/logging.handlers.rst:759
msgid "``local2``"
msgstr "``local2``"

#: ../Doc/library/logging.handlers.rst:759
msgid "LOG_LOCAL2"
msgstr "LOG_LOCAL2"

#: ../Doc/library/logging.handlers.rst:761
msgid "``local3``"
msgstr "``local3``"

#: ../Doc/library/logging.handlers.rst:761
msgid "LOG_LOCAL3"
msgstr "LOG_LOCAL3"

#: ../Doc/library/logging.handlers.rst:763
msgid "``local4``"
msgstr "``local4``"

#: ../Doc/library/logging.handlers.rst:763
msgid "LOG_LOCAL4"
msgstr "LOG_LOCAL4"

#: ../Doc/library/logging.handlers.rst:765
msgid "``local5``"
msgstr "``local5``"

#: ../Doc/library/logging.handlers.rst:765
msgid "LOG_LOCAL5"
msgstr "LOG_LOCAL5"

#: ../Doc/library/logging.handlers.rst:767
msgid "``local6``"
msgstr "``local6``"

#: ../Doc/library/logging.handlers.rst:767
msgid "LOG_LOCAL6"
msgstr "LOG_LOCAL6"

#: ../Doc/library/logging.handlers.rst:769
msgid "``local7``"
msgstr "``local7``"

#: ../Doc/library/logging.handlers.rst:769
msgid "LOG_LOCAL7"
msgstr "LOG_LOCAL7"

#: ../Doc/library/logging.handlers.rst:774
msgid ""
"Maps a logging level name to a syslog priority name. You may need to "
"override this if you are using custom levels, or if the default algorithm is "
"not suitable for your needs. The default algorithm maps ``DEBUG``, ``INFO``, "
"``WARNING``, ``ERROR`` and ``CRITICAL`` to the equivalent syslog names, and "
"all other level names to 'warning'."
msgstr ""
"Mapea un nombre de nivel *logging* a un nombre de prioridad *syslog*. Puedes "
"necesitar omitir esto si estas usando niveles personalizados, o si el "
"algoritmo por defecto no es aplicable a tus necesidades. El algoritmo por "
"defecto mapea ``DEBUG``, ``INFO``, ``WARNING``, ``ERROR`` y ``CRITICAL`` a "
"sus nombres equivalentes *syslog*, y todos los demás nombres de nivel a "
"'warning'."

#: ../Doc/library/logging.handlers.rst:784
msgid "NTEventLogHandler"
msgstr "Gestor de eventos *NTELog* (NTEventLogHandler)"

#: ../Doc/library/logging.handlers.rst:786
msgid ""
"The :class:`NTEventLogHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a local Windows NT, Windows "
"2000 or Windows XP event log. Before you can use it, you need Mark Hammond's "
"Win32 extensions for Python installed."
msgstr ""
"La clase :class:`NTEventLogHandler` esta localizada en el módulo :mod:"
"`logging.handlers`, soporta el envío de mensajes de *logging* a un log de "
"eventos local Windows NT, Windows 2000 o Windows XP. Antes de que puedas "
"usarlo, necesitarás tener instaladas las extensiones de Win32 de Mark "
"Hammond para Python."

#: ../Doc/library/logging.handlers.rst:794
msgid ""
"Returns a new instance of the :class:`NTEventLogHandler` class. The "
"*appname* is used to define the application name as it appears in the event "
"log. An appropriate registry entry is created using this name. The *dllname* "
"should give the fully qualified pathname of a .dll or .exe which contains "
"message definitions to hold in the log (if not specified, ``'win32service."
"pyd'`` is used - this is installed with the Win32 extensions and contains "
"some basic placeholder message definitions. Note that use of these "
"placeholders will make your event logs big, as the entire message source is "
"held in the log. If you want slimmer logs, you have to pass in the name of "
"your own .dll or .exe which contains the message definitions you want to use "
"in the event log). The *logtype* is one of ``'Application'``, ``'System'`` "
"or ``'Security'``, and defaults to ``'Application'``."
msgstr ""
"Retorna una nueva instancia de la clase :class:`NTEventLogHandler` la "
"*appname* se usa para definir el nombre de la aplicación tal como aparece en "
"el log de eventos. Se crea una entrada de registro apropiada usando este "
"nombre. El *dllname* debe dar la ruta completa calificada de un .dll o .exe "
"que contiene definiciones de mensaje para conservar en el log. (si no esta "
"especificada, se usara ``'win32service.pyd'`` esto es instalado con las "
"extensiones de Win32 y contiene algunas definiciones básicas de mensajes de "
"conservación de lugar. Nótese que el uso de estos conservadores de lugar "
"harán tu log de eventos extenso, dado que el origen completo del mensaje es "
"guardado en el log. Si quieres *logs* menos extensos deberás pasar el nombre "
"de tu propio .dll o .exe que contiene la definición de mensajes que quieres "
"usar en el log. El *logtype* puede ser de ``'Application'``, ``'System'`` or "
"``'Security'`` y sino por defecto será de ``'Application'``."

#: ../Doc/library/logging.handlers.rst:810
msgid ""
"At this point, you can remove the application name from the registry as a "
"source of event log entries. However, if you do this, you will not be able "
"to see the events as you intended in the Event Log Viewer - it needs to be "
"able to access the registry to get the .dll name. The current version does "
"not do this."
msgstr ""
"Llegado a este punto puedes remover el nombre de aplicación del registro "
"como origen de entrada de log de eventos. Sin embargo si haces esto no te "
"será posible ver los eventos tal como has propuesto en el visor del log de "
"eventos - necesita ser capaz de acceder al registro para tomar el nombre ."
"dll. Esto no lo hace la versión actual."

#: ../Doc/library/logging.handlers.rst:819
msgid ""
"Determines the message ID, event category and event type, and then logs the "
"message in the NT event log."
msgstr ""
"Determina el ID del mensaje, categoría y tipo de evento y luego registra el "
"mensaje en el log de eventos NT."

#: ../Doc/library/logging.handlers.rst:825
msgid ""
"Returns the event category for the record. Override this if you want to "
"specify your own categories. This version returns 0."
msgstr ""
"Retorna la categoría de evento del registro. Evita esto si quieres "
"especificar tus propias categorías. Esta versión retorna 0."

#: ../Doc/library/logging.handlers.rst:831
msgid ""
"Returns the event type for the record. Override this if you want to specify "
"your own types. This version does a mapping using the handler's typemap "
"attribute, which is set up in :meth:`__init__` to a dictionary which "
"contains mappings for :const:`DEBUG`, :const:`INFO`, :const:`WARNING`, :"
"const:`ERROR` and :const:`CRITICAL`. If you are using your own levels, you "
"will either need to override this method or place a suitable dictionary in "
"the handler's *typemap* attribute."
msgstr ""
"Retorna el tipo de evento del registro. Haz caso omiso de esto si quieres "
"especificar tus propios tipos. Esta versión realiza un mapeo usando el "
"atributo *typemap* del gestor, que se establece en :meth:`__init__` a un "
"diccionario que contiene mapeo para :const:`DEBUG`, :const:`INFO`, :const:"
"`WARNING`, :const:`ERROR` y :const:`CRITICAL`. Si estas usando tus propios "
"niveles, necesitarás omitir este método o colocar un diccionario a medida en "
"el atributo *typemap* del gestor."

#: ../Doc/library/logging.handlers.rst:842
msgid ""
"Returns the message ID for the record. If you are using your own messages, "
"you could do this by having the *msg* passed to the logger being an ID "
"rather than a format string. Then, in here, you could use a dictionary "
"lookup to get the message ID. This version returns 1, which is the base "
"message ID in :file:`win32service.pyd`."
msgstr ""
"Retorna el ID de mensaje para el registro. Si estas usando tus propios "
"mensajes, podrás hacerlo pasando el *msg* al *logger* siendo un ID mas que "
"un formato de cadena de caracteres. Luego aquí puedes usar una búsqueda de "
"diccionario para obtener el ID de mensaje. Esta versión retorna 1, que es el "
"ID de mensaje base en :file:`win32service.pyd`."

#: ../Doc/library/logging.handlers.rst:851
msgid "SMTPHandler"
msgstr "SMTPHandler"

#: ../Doc/library/logging.handlers.rst:853
msgid ""
"The :class:`SMTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to an email address via SMTP."
msgstr ""
"La clase :class:`SMTPHandler` esta ubicada en el módulo :mod:`logging."
"handlers` y soporta el envío de mensajes de *logging* a un a dirección de "
"correo electrónico a través de SMTP."

#: ../Doc/library/logging.handlers.rst:859
msgid ""
"Returns a new instance of the :class:`SMTPHandler` class. The instance is "
"initialized with the from and to addresses and subject line of the email. "
"The *toaddrs* should be a list of strings. To specify a non-standard SMTP "
"port, use the (host, port) tuple format for the *mailhost* argument. If you "
"use a string, the standard SMTP port is used. If your SMTP server requires "
"authentication, you can specify a (username, password) tuple for the "
"*credentials* argument."
msgstr ""
"Retorna una nueva instancia de la clase :class:`SMTPHandler` . Esta "
"instancia se inicializa con la dirección de: y para: y asunto: del correo "
"electrónico. El *toaddrs* debe ser una lista de cadena de caracteres. Para "
"especificar un puerto SMTP no estandarizado usa el formato de tupla (host, "
"puerto) para el argumento *mailhost*. Si usas una cadena de caracteres, se "
"utiliza el puerto estándar SMTP. Si tu servidor SMTP necesita autenticación, "
"puedes especificar una tupla (usuario, contraseña) para el argumento de "
"*credentials*."

#: ../Doc/library/logging.handlers.rst:866
msgid ""
"To specify the use of a secure protocol (TLS), pass in a tuple to the "
"*secure* argument. This will only be used when authentication credentials "
"are supplied. The tuple should be either an empty tuple, or a single-value "
"tuple with the name of a keyfile, or a 2-value tuple with the names of the "
"keyfile and certificate file. (This tuple is passed to the :meth:`smtplib."
"SMTP.starttls` method.)"
msgstr ""
"Para especificar el uso de un protocolo de seguridad (TLS), pasa una tupla "
"al argumento *secure*. Esto solo se utilizará cuando sean provistas las "
"credenciales de autenticación. La tupla deberá ser una tupla vacía o una "
"tupla con único valor con el nombre de un archivo-clave *keyfile*, o una "
"tupla de 2 valores con el nombre del archivo-clave *keyfile* y archivo "
"certificado. (Esta tupla se pasa al método :meth:`smtplib.SMTP.starttls` "
"method.)."

#: ../Doc/library/logging.handlers.rst:873
msgid ""
"A timeout can be specified for communication with the SMTP server using the "
"*timeout* argument."
msgstr ""
"Se puede especificar un tiempo de espera para comunicación con el servidor "
"SMTP usando el argumento *timeout*."

#: ../Doc/library/logging.handlers.rst:876
msgid "The *timeout* argument was added."
msgstr "Se agregó el argumento *timeout*."

#: ../Doc/library/logging.handlers.rst:881
msgid "Formats the record and sends it to the specified addressees."
msgstr "Formatea el registro y lo envía a las direcciones especificadas."

#: ../Doc/library/logging.handlers.rst:886
msgid ""
"If you want to specify a subject line which is record-dependent, override "
"this method."
msgstr ""
"Si quieres especificar una línea de argumento que es registro-dependiente, "
"sobrescribe (*override*) este método."

#: ../Doc/library/logging.handlers.rst:892
msgid "MemoryHandler"
msgstr "MemoryHandler"

#: ../Doc/library/logging.handlers.rst:894
msgid ""
"The :class:`MemoryHandler` class, located in the :mod:`logging.handlers` "
"module, supports buffering of logging records in memory, periodically "
"flushing them to a :dfn:`target` handler. Flushing occurs whenever the "
"buffer is full, or when an event of a certain severity or greater is seen."
msgstr ""
"La clase :class:`MemoryHandler` esta ubicada en el módulo :mod:`logging."
"handlers` .Soporta el almacenamiento temporal de registros *logging* en "
"memoria. Periódicamente los descarga al gestor :dfn:`target`. Esto ocurre "
"cuando el búfer está lleno o cuando ocurre un evento de cierta importancia."

#: ../Doc/library/logging.handlers.rst:899
msgid ""
":class:`MemoryHandler` is a subclass of the more general :class:"
"`BufferingHandler`, which is an abstract class. This buffers logging records "
"in memory. Whenever each record is added to the buffer, a check is made by "
"calling :meth:`shouldFlush` to see if the buffer should be flushed.  If it "
"should, then :meth:`flush` is expected to do the flushing."
msgstr ""
":class:`MemoryHandler` es una subclase de la clase mas general :class:"
"`BufferingHandler`, que es una clase abstracta. Este almacena temporalmente "
"registros *logging* en la memoria. Cada vez que un registro es agregado al "
"búfer, se realiza una comprobación llamando al método :meth:`shouldFlush` "
"para ver si dicho búfer debe ser descargado. Si debiera, entonces el método :"
"meth:`flush` se espera que realice la descarga."

#: ../Doc/library/logging.handlers.rst:908
msgid ""
"Initializes the handler with a buffer of the specified capacity. Here, "
"*capacity* means the number of logging records buffered."
msgstr ""
"Inicializa el gestor con un búfer de una capacidad especifica. Aquí "
"capacidad significa el número de registros *logging* en el almacenamiento "
"temporal."

#: ../Doc/library/logging.handlers.rst:914
msgid ""
"Append the record to the buffer. If :meth:`shouldFlush` returns true, call :"
"meth:`flush` to process the buffer."
msgstr ""
"Añade un registro al búfer. Si el método :meth:`shouldFlush` retorna "
"*true* , entonces llama al método :meth:`flush` para procesar el búfer."

#: ../Doc/library/logging.handlers.rst:920
msgid ""
"For a :class:`BufferingHandler` instance, flushing means that it sets the "
"buffer to an empty list. This method can be overwritten to implement more "
"useful flushing behavior."
msgstr ""
"Para una instancia de :class:`BufferingHandler`, vaciar significa que "
"establece el búfer a una lista vacía. Este método puede ser sobrescrito para "
"implementar un comportamiento de vaciado más útil."

#: ../Doc/library/logging.handlers.rst:927
msgid ""
"Return ``True`` if the buffer is up to capacity. This method can be "
"overridden to implement custom flushing strategies."
msgstr ""
"Retorna ``True`` si el búfer tiene aún capacidad. Este método puede ser "
"omitido para implementar estrategias a medida de vaciado."

#: ../Doc/library/logging.handlers.rst:933
msgid ""
"Returns a new instance of the :class:`MemoryHandler` class. The instance is "
"initialized with a buffer size of *capacity* (number of records buffered). "
"If *flushLevel* is not specified, :const:`ERROR` is used. If no *target* is "
"specified, the target will need to be set using :meth:`setTarget` before "
"this handler does anything useful. If *flushOnClose* is specified as "
"``False``, then the buffer is *not* flushed when the handler is closed. If "
"not specified or specified as ``True``, the previous behaviour of flushing "
"the buffer will occur when the handler is closed."
msgstr ""
"Retorna una nueva instancia de la clase :class:`MemoryHandler` . La "
"instancia se inicializa con un búfer del tamaño *capacity*. Si el "
"*flushLevel* no se especifica, se usará :const:`ERROR` . Si no se especifica "
"*target* el objetivo deberá especificarse usando el método :meth:`setTarget` "
"-Antes de esto el gestor no realizará nada útil. Si se especifica "
"*flushOnClose* como ``False``, entonces el búfer no se vaciará cuando el "
"gestor se cierra. Si no se especifica o se especifica como ``True``, el "
"comportamiento previo de vaciado del búfer sucederá cuando se cierre el "
"gestor."

#: ../Doc/library/logging.handlers.rst:942
msgid "The *flushOnClose* parameter was added."
msgstr "Se añadió el parámetro *flushOnClose*."

#: ../Doc/library/logging.handlers.rst:948
msgid "Calls :meth:`flush`, sets the target to ``None`` and clears the buffer."
msgstr ""
"Invoca al método :meth:`flush` y establece el objetivo a 'None' y vacía el "
"búfer."

#: ../Doc/library/logging.handlers.rst:954
msgid ""
"For a :class:`MemoryHandler` instance, flushing means just sending the "
"buffered records to the target, if there is one. The buffer is also cleared "
"when buffered records are sent to the target. Override if you want different "
"behavior."
msgstr ""
"Para una instancia de :class:`MemoryHandler`, el vaciado implica simplemente "
"enviar los registros almacenados en el búfer al objetivo, si es que existe "
"uno. El búfer también se limpia cuando se envían los registros almacenados "
"al objetivo. Sobrescribe si deseas un comportamiento diferente."

#: ../Doc/library/logging.handlers.rst:961
msgid "Sets the target handler for this handler."
msgstr "Establece el gestor de objetivo para este gestor."

#: ../Doc/library/logging.handlers.rst:966
msgid "Checks for buffer full or a record at the *flushLevel* or higher."
msgstr ""
"Comprueba si el búfer esta lleno o un registro igual o mas alto que "
"*flushLevel*."

#: ../Doc/library/logging.handlers.rst:972
msgid "HTTPHandler"
msgstr "HTTPHandler"

#: ../Doc/library/logging.handlers.rst:974
msgid ""
"The :class:`HTTPHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a web server, using either "
"``GET`` or ``POST`` semantics."
msgstr ""
"La clase :class:`HTTPHandler`, ubicada en el módulo :mod:`logging.handlers`, "
"admite el envío de mensajes de registro a un servidor web, utilizando la "
"semántica ``GET`` o ``POST``."

#: ../Doc/library/logging.handlers.rst:981
msgid ""
"Returns a new instance of the :class:`HTTPHandler` class. The *host* can be "
"of the form ``host:port``, should you need to use a specific port number.  "
"If no *method* is specified, ``GET`` is used. If *secure* is true, a HTTPS "
"connection will be used. The *context* parameter may be set to a :class:`ssl."
"SSLContext` instance to configure the SSL settings used for the HTTPS "
"connection. If *credentials* is specified, it should be a 2-tuple consisting "
"of userid and password, which will be placed in a HTTP 'Authorization' "
"header using Basic authentication. If you specify credentials, you should "
"also specify secure=True so that your userid and password are not passed in "
"cleartext across the wire."
msgstr ""
"Retorna una nueva instancia de la clase :class:`HTTPHandler`. el *host* "
"puede ser de la forma \"host:puerto\", y necesitarás usar un numero de "
"puerto especifico. Si no se especifica *method* se usará ``GET`` . Si "
"*secure* es true se usará una conexión HTTPS. El parámetro *context* puede "
"establecerse a una instancia :class:`ssl.SSLContext` para establecer la "
"configuración de SSL usado en la conexión HTTPS. Si se especifica "
"*credentials* debe ser una tupla doble, consistente en usuario y contraseña, "
"que se colocará en un encabezado de autorización HTTP usando autenticación "
"básica. Si especificas credenciales también deberás especificar "
"*secure=True* así tu usuario y contraseña no son pasados como texto en "
"blanco por la conexión."

#: ../Doc/library/logging.handlers.rst:992
msgid "The *context* parameter was added."
msgstr "Se agregó el parámetro *context*."

#: ../Doc/library/logging.handlers.rst:997
msgid ""
"Provides a dictionary, based on ``record``, which is to be URL-encoded and "
"sent to the web server. The default implementation just returns ``record."
"__dict__``. This method can be overridden if e.g. only a subset of :class:"
"`~logging.LogRecord` is to be sent to the web server, or if more specific "
"customization of what's sent to the server is required."
msgstr ""
"Provee un diccionario, basado en ``record`` para ser codificado en forma URL "
"y enviado al servidor web. La implementación por defecto retorna ``record."
"__dict__``. Este método puede omitirse si por ejemplo solo se enviará al "
"servidor web un subconjunto de la clase :class:`~logging.LogRecord` o si se "
"requiere enviar al servidor algo mas específico."

#: ../Doc/library/logging.handlers.rst:1005
msgid ""
"Sends the record to the web server as a URL-encoded dictionary. The :meth:"
"`mapLogRecord` method is used to convert the record to the dictionary to be "
"sent."
msgstr ""
"Envía el registro al servidor web como un diccionario codificado en URL. El "
"método :meth:`mapLogRecord` se utiliza para convertir el registro al "
"diccionario que se enviará."

#: ../Doc/library/logging.handlers.rst:1009
msgid ""
"Since preparing a record for sending it to a web server is not the same as a "
"generic formatting operation, using :meth:`~logging.Handler.setFormatter` to "
"specify a :class:`~logging.Formatter` for a :class:`HTTPHandler` has no "
"effect. Instead of calling :meth:`~logging.Handler.format`, this handler "
"calls :meth:`mapLogRecord` and then :func:`urllib.parse.urlencode` to encode "
"the dictionary in a form suitable for sending to a web server."
msgstr ""
"Dado que preparar un registro para enviarlo a un servidor web no es lo mismo "
"que una operación de formateo genérico, el uso de :meth:`~logging.Handler."
"setFormatter` para especificar un :class:`~logging.Formatter` para un :class:"
"`HTTPHandler` no tiene ningún efecto. En lugar de llamar a :meth:`~logging."
"Handler.format`, este controlador llama a :meth:`mapLogRecord` y luego a :"
"func:`urllib.parse.urlencode` para codificar el diccionario en una forma "
"adecuada para enviar a un servidor web."

#: ../Doc/library/logging.handlers.rst:1022
msgid "QueueHandler"
msgstr "QueueHandler"

#: ../Doc/library/logging.handlers.rst:1026
msgid ""
"The :class:`QueueHandler` class, located in the :mod:`logging.handlers` "
"module, supports sending logging messages to a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules."
msgstr ""
"La clase :class:`QueueHandler` localizada en el módulo :mod:`logging."
"handlers` soporta el envío de mensajes de *logging* a una cola, tal como los "
"implementados en los módulos :mod:`queue` o :mod:`multiprocessing` ."

#: ../Doc/library/logging.handlers.rst:1030
msgid ""
"Along with the :class:`QueueListener` class, :class:`QueueHandler` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""
"Junto con la clase :class:`QueueListener`, :class:`QueueHandler` se puede "
"usar para permitir que los controladores hagan su trabajo en un hilo "
"separado del que realiza el registro. Esto es importante en aplicaciones web "
"y también en otras aplicaciones de servicio donde los subprocesos que "
"atienden a los clientes deben responder lo más rápido posible, mientras que "
"cualquier operación potencialmente lenta (como enviar un correo electrónico "
"a través de :class:`SMTPHandler`) se realiza en un subproceso separado."

#: ../Doc/library/logging.handlers.rst:1039
msgid ""
"Returns a new instance of the :class:`QueueHandler` class. The instance is "
"initialized with the queue to send messages to. The *queue* can be any queue-"
"like object; it's used as-is by the :meth:`enqueue` method, which needs to "
"know how to send messages to it. The queue is not *required* to have the "
"task tracking API, which means that you can use :class:`~queue.SimpleQueue` "
"instances for *queue*."
msgstr ""
"Retorna una nueva instancia de la clase :class:`QueueHandler`. La instancia "
"se inicializa con la cola a la que se enviarán los mensajes. La cola puede "
"ser cualquier objeto tipo-cola; es usado tal como por el método :meth:"
"`enqueue` que necesita saber como enviar los mensajes a ella. La cola no es "
"*requerida* para tener una API de rastreo de tareas, lo que significa que "
"puedes usar instancias de :class:`~queue.SimpleQueue` como *queue*."

#: ../Doc/library/logging.handlers.rst:1046
#: ../Doc/library/logging.handlers.rst:1135
msgid ""
"If you are using :mod:`multiprocessing`, you should avoid using :class:"
"`~queue.SimpleQueue` and instead use :class:`multiprocessing.Queue`."
msgstr ""
"Si estás usando :mod:`multiprocessing`, debes evitar usar :class:`~queue."
"SimpleQueue` y en su lugar usar :class:`multiprocessing.Queue`."

#: ../Doc/library/logging.handlers.rst:1051
msgid ""
"Enqueues the result of preparing the LogRecord. Should an exception occur (e."
"g. because a bounded queue has filled up), the :meth:`~logging.Handler."
"handleError` method is called to handle the error. This can result in the "
"record silently being dropped (if :data:`logging.raiseExceptions` is "
"``False``) or a message printed to ``sys.stderr`` (if :data:`logging."
"raiseExceptions` is ``True``)."
msgstr ""
"Pone en cola el resultado de preparar el LogRecord. Si ocurre una excepción "
"(por ejemplo, porque una cola limitada se ha llenado), se invoca el método :"
"meth:`~logging.Handler.handleError` para manejar el error. Esto puede "
"resultar en que el registro se descarte de manera silenciosa (si :data:"
"`logging.raiseExceptions` es ``False``) o en que se imprima un mensaje en "
"``sys.stderr`` (si :data:`logging.raiseExceptions` es ``True``)."

#: ../Doc/library/logging.handlers.rst:1060
msgid ""
"Prepares a record for queuing. The object returned by this method is "
"enqueued."
msgstr ""
"Prepara un registro para poner en la cola. El objeto que retorna este método "
"se colocará en cola."

#: ../Doc/library/logging.handlers.rst:1063
msgid ""
"The base implementation formats the record to merge the message, arguments, "
"exception and stack information, if present.  It also removes unpickleable "
"items from the record in-place. Specifically, it overwrites the record's :"
"attr:`msg` and :attr:`message` attributes with the merged message (obtained "
"by calling the handler's :meth:`format` method), and sets the :attr:`args`, :"
"attr:`exc_info` and :attr:`exc_text` attributes to ``None``."
msgstr ""
"La implementación base le da formato al registro para fusionar el mensaje, "
"los argumentos, la excepción y la información de la pila, si está presente. "
"También elimina elementos que no se pueden serializar (*pickle*) del "
"registro en el lugar. Específicamente, sobrescribe los atributos :attr:`msg` "
"y :attr:`message` del registro con el mensaje fusionado (obtenido llamando "
"al método :meth:`format` del controlador) y establece los atributos :attr:"
"`args`, :attr:`exc_info` y :attr:`exc_text` a ``None``."

#: ../Doc/library/logging.handlers.rst:1071
msgid ""
"You might want to override this method if you want to convert the record to "
"a dict or JSON string, or send a modified copy of the record while leaving "
"the original intact."
msgstr ""
"Puedes querer hacer caso omiso de este método si quieres convertir el "
"registro en un diccionario o cadena de caracteres JSON, o enviar una copia "
"modificada del registro mientras dejas el original intacto."

#: ../Doc/library/logging.handlers.rst:1075
msgid ""
"The base implementation formats the message with arguments, sets the "
"``message`` and ``msg`` attributes to the formatted message and sets the "
"``args`` and ``exc_text`` attributes to ``None`` to allow pickling and to "
"prevent further attempts at formatting. This means that a handler on the :"
"class:`QueueListener` side won't have the information to do custom "
"formatting, e.g. of exceptions. You may wish to subclass ``QueueHandler`` "
"and override this method to e.g. avoid setting ``exc_text`` to ``None``. "
"Note that the ``message`` / ``msg`` / ``args`` changes are related to "
"ensuring the record is pickleable, and you might or might not be able to "
"avoid doing that depending on whether your ``args`` are pickleable. (Note "
"that you may have to consider not only your own code but also code in any "
"libraries that you use.)"
msgstr ""
"La implementación base formatea el mensaje con argumentos, establece los "
"atributos ``message`` y ``msg`` en el mensaje formateado y establece los "
"atributos ``args`` y ``exc_text`` en ``None`` para permitir serializado "
"(*pickle*) y para evitar nuevos intentos de formateo. Esto significa que un "
"controlador en el lado :class:`QueueListener` no tendrá la información para "
"hacer un formato personalizado, por ej. de excepciones. Es posible que "
"desees crear una subclase de ``QueueHandler`` y anular este método para, por "
"ej. evitar establecer ``exc_text`` en ``None``. Ten en cuenta que los "
"cambios de ``message`` / ``msg`` / ``args`` están relacionados con "
"garantizar que el registro se pueda seleccionar, y es posible que puedas o "
"no evitar hacerlo dependiendo de si sus ``args`` son serializables. (Ten en "
"cuenta que es posible que debas considerar no solo tu propio código, sino "
"también el código en cualquier biblioteca que uses)."

#: ../Doc/library/logging.handlers.rst:1091
msgid ""
"Enqueues the record on the queue using ``put_nowait()``; you may want to "
"override this if you want to use blocking behaviour, or a timeout, or a "
"customized queue implementation."
msgstr ""
"Coloca en la cola al registro usando ``put_nowait()``; puede que quieras "
"sobrescribe (*override*) esto si quieres usar una acción de bloqueo, o un "
"tiempo de espera, o una implementación de cola a medida."

#: ../Doc/library/logging.handlers.rst:1097
msgid ""
"When created via configuration using :func:`~logging.config.dictConfig`, "
"this attribute will contain a :class:`QueueListener` instance for use with "
"this handler. Otherwise, it will be ``None``."
msgstr ""
"Cuando se crea a través de la configuración usando :func:`~logging.config."
"dictConfig`, este atributo contendrá una instancia de :class:`QueueListener` "
"para usar con este manejador. De lo contrario, será ``None``."

#: ../Doc/library/logging.handlers.rst:1106
msgid "QueueListener"
msgstr "QueueListener"

#: ../Doc/library/logging.handlers.rst:1110
msgid ""
"The :class:`QueueListener` class, located in the :mod:`logging.handlers` "
"module, supports receiving logging messages from a queue, such as those "
"implemented in the :mod:`queue` or :mod:`multiprocessing` modules. The "
"messages are received from a queue in an internal thread and passed, on the "
"same thread, to one or more handlers for processing. While :class:"
"`QueueListener` is not itself a handler, it is documented here because it "
"works hand-in-hand with :class:`QueueHandler`."
msgstr ""
"La clase :class:`QueueListener` esta localizada en el módulo :mod:`logging."
"handlers`. Soporta la recepción de mensajes *logging* de una cola, tal como "
"los implementados en los módulos :mod:`queue` or :mod:`multiprocessing` . "
"Los mensajes son recibidos de una cola en un hilo interno y se pasan en el "
"mismo hilo, a uno o mas gestores para procesarlos. Mientras la clase :class:"
"`QueueListener` no es en si misma un gestor, esta documentada aquí porque "
"trabaja mano a mano con la clase :class:`QueueHandler`."

#: ../Doc/library/logging.handlers.rst:1118
msgid ""
"Along with the :class:`QueueHandler` class, :class:`QueueListener` can be "
"used to let handlers do their work on a separate thread from the one which "
"does the logging. This is important in web applications and also other "
"service applications where threads servicing clients need to respond as "
"quickly as possible, while any potentially slow operations (such as sending "
"an email via :class:`SMTPHandler`) are done on a separate thread."
msgstr ""
"Junto con la clase :class:`QueueHandler`, :class:`QueueListener` se puede "
"usar para permitir que los controladores hagan su trabajo en un hilo "
"separado del que realiza el registro. Esto es importante en aplicaciones web "
"y también en otras aplicaciones de servicio donde los subprocesos que "
"atienden a los clientes deben responder lo más rápido posible, mientras que "
"cualquier operación potencialmente lenta (como enviar un correo electrónico "
"a través de :class:`SMTPHandler`) se realiza en un subproceso separado."

#: ../Doc/library/logging.handlers.rst:1127
msgid ""
"Returns a new instance of the :class:`QueueListener` class. The instance is "
"initialized with the queue to send messages to and a list of handlers which "
"will handle entries placed on the queue. The queue can be any queue-like "
"object; it's passed as-is to the :meth:`dequeue` method, which needs to know "
"how to get messages from it. The queue is not *required* to have the task "
"tracking API (though it's used if available), which means that you can use :"
"class:`~queue.SimpleQueue` instances for *queue*."
msgstr ""
"Retorna una nueva instancia de la clase :class:`QueueListener`. La instancia "
"se inicializa con la cola para enviar mensajes a una lista de gestores que "
"manejarán entradas colocadas en la cola. La cola puede ser cualquier objeto "
"de tipo-cola, es usado tal como está por el método :meth:`dequeue` que "
"necesita saber como tomar los mensajes de esta. La cola no es *obligatoria* "
"para tener la API de seguimiento de tareas (aunque se usa si está "
"disponible), lo que significa que puede usar instancias :class:`~queue."
"SimpleQueue` para *queue*."

#: ../Doc/library/logging.handlers.rst:1138
msgid ""
"If ``respect_handler_level`` is ``True``, a handler's level is respected "
"(compared with the level for the message) when deciding whether to pass "
"messages to that handler; otherwise, the behaviour is as in previous Python "
"versions - to always pass each message to each handler."
msgstr ""
"Si ``respect_handler_level`` es ``True``, se respeta un nivel de gestor "
"(comparado con el nivel del mensaje) cuando decide si pasar el mensajes al "
"gestor; de otra manera, el comportamiento es como en versiones anteriores de "
"Python - de pasar cada mensaje a cada gestor."

#: ../Doc/library/logging.handlers.rst:1143
msgid "The ``respect_handler_level`` argument was added."
msgstr "Se agregó el argumento ``respect_handler_levels``."

#: ../Doc/library/logging.handlers.rst:1148
msgid "Dequeues a record and return it, optionally blocking."
msgstr "Extrae de la cola un registro y lo retorna, con opción a bloquearlo."

#: ../Doc/library/logging.handlers.rst:1150
msgid ""
"The base implementation uses ``get()``. You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""
"La implementación base usa ``get()``. Puedes sobrescribir (*override*) este "
"método si quieres usar tiempos de espera o trabajar con colas implementadas "
"a medida."

#: ../Doc/library/logging.handlers.rst:1156
msgid "Prepare a record for handling."
msgstr "Prepara un registro para ser gestionado."

#: ../Doc/library/logging.handlers.rst:1158
msgid ""
"This implementation just returns the passed-in record. You may want to "
"override this method if you need to do any custom marshalling or "
"manipulation of the record before passing it to the handlers."
msgstr ""
"Esta implementación solo retorna el registro que fue pasado. Puedes "
"sobrescribir (*override*) este método para hacer una serialización a medida "
"o una manipulación del registro antes de pasarlo a los gestores."

#: ../Doc/library/logging.handlers.rst:1164
msgid "Handle a record."
msgstr "Manejar un registro."

#: ../Doc/library/logging.handlers.rst:1166
msgid ""
"This just loops through the handlers offering them the record to handle. The "
"actual object passed to the handlers is that which is returned from :meth:"
"`prepare`."
msgstr ""
"Esto solo realiza un bucle a través de los gestores ofreciéndoles el "
"registro para ser gestionado. El objeto actual pasado a los gestores es "
"aquel que es retornado por el método :meth:`prepare`."

#: ../Doc/library/logging.handlers.rst:1172
msgid "Starts the listener."
msgstr "Da comienzo al oyente (*listener*)."

#: ../Doc/library/logging.handlers.rst:1174
msgid ""
"This starts up a background thread to monitor the queue for LogRecords to "
"process."
msgstr ""
"Esto da comienzo a un hilo en segundo plano para supervisar la cola de "
"registros log a procesar."

#: ../Doc/library/logging.handlers.rst:1179
msgid "Stops the listener."
msgstr "Detiene el oyente (*listener*)."

#: ../Doc/library/logging.handlers.rst:1181
msgid ""
"This asks the thread to terminate, and then waits for it to do so. Note that "
"if you don't call this before your application exits, there may be some "
"records still left on the queue, which won't be processed."
msgstr ""
"Esto solicita terminar al hilo, y luego espera hasta que termine. Nota que "
"si no llamas a esto antes de que tu aplicación salga, puede haber algunos "
"registros que aun están en la cola, que no serán procesados."

#: ../Doc/library/logging.handlers.rst:1187
msgid ""
"Writes a sentinel to the queue to tell the listener to quit. This "
"implementation uses ``put_nowait()``.  You may want to override this method "
"if you want to use timeouts or work with custom queue implementations."
msgstr ""
"Escribe un centinela (*sentinel*) en la cola para decir al oyente "
"(*listener*) de salir. Esta implementación usa ``put_nowait()``. Puedes "
"sobrescribir (*override*) este método si quieres usar tiempos de espera o "
"trabajar con implementaciones de cola a tu medida."

#: ../Doc/library/logging.handlers.rst:1198
msgid "Module :mod:`logging`"
msgstr "Módulo :mod:`logging`"

#: ../Doc/library/logging.handlers.rst:1198
msgid "API reference for the logging module."
msgstr "Referencia API para el módulo de *logging*."

#: ../Doc/library/logging.handlers.rst:1200
msgid "Module :mod:`logging.config`"
msgstr "Módulo :mod:`logging.config`"

#: ../Doc/library/logging.handlers.rst:1201
msgid "Configuration API for the logging module."
msgstr "Configuración API para el módulo de *logging*."

#~ msgid ""
#~ "You can override this to implement custom flushing behavior. This version "
#~ "just zaps the buffer to empty."
#~ msgstr ""
#~ "Puedes sobrescribir (*override*) esto para implementar un comportamiento "
#~ "'a medida' de la descarga. Esta versión solo vacía el búfer."
