# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2024-02-21 10:02-0300\n"
"Last-Translator: zodac <zodac@duck.com>\n"
"Language-Team: python-doc-es\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.13.0\n"
"X-Generator: Poedit 3.4.2\n"

#: ../Doc/library/threading.rst:2
msgid ":mod:`threading` --- Thread-based parallelism"
msgstr ":mod:`threading` --- Paralelismo basado en hilos"

#: ../Doc/library/threading.rst:7
msgid "**Source code:** :source:`Lib/threading.py`"
msgstr "**Código fuente:** :source:`Lib/threading.py`"

#: ../Doc/library/threading.rst:11
msgid ""
"This module constructs higher-level threading interfaces on top of the lower "
"level :mod:`_thread` module."
msgstr ""
"Este módulo construye interfaces de hilado de alto nivel sobre el módulo de "
"más bajo nivel :mod:`_thread`."

#: ../Doc/library/threading.rst:14
msgid "This module used to be optional, it is now always available."
msgstr "Este módulo solía ser opcional, ahora está siempre disponible."

#: ../Doc/library/threading.rst:19
msgid ""
":class:`concurrent.futures.ThreadPoolExecutor` offers a higher level "
"interface to push tasks to a background thread without blocking execution of "
"the calling thread, while still being able to retrieve their results when "
"needed."
msgstr ""
":class:`concurrent.futures.ThreadPoolExecutor` ofrece una interfaz a mas "
"alto nivel para enviar tareas a un hilo en segundo plano sin bloquear la "
"ejecución del hilo de llamada, pero manteniendo la capacidad de recuperar "
"sus resultados cuando sea necesario."

#: ../Doc/library/threading.rst:23
msgid ""
":mod:`queue` provides a thread-safe interface for exchanging data between "
"running threads."
msgstr ""
":mod:`queue` proporciona una interfaz segura a nivel de hilos intercambiar "
"datos entre hilos en ejecución."

#: ../Doc/library/threading.rst:26
msgid ""
":mod:`asyncio` offers an alternative approach to achieving task level "
"concurrency without requiring the use of multiple operating system threads."
msgstr ""
":mod:`asyncio` ofrece un enfoque alternativo para lograr la concurrencia a "
"nivel de tarea sin requerir el uso de múltiples subprocesos del sistema "
"operativo."

#: ../Doc/library/threading.rst:31
msgid ""
"In the Python 2.x series, this module contained ``camelCase`` names for some "
"methods and functions. These are deprecated as of Python 3.10, but they are "
"still supported for compatibility with Python 2.5 and lower."
msgstr ""
"En la serie Python 2.x, este módulo contenía nombres ``camelCase`` para "
"algunos métodos y funciones. Estos están obsoletos a partir de Python 3.10, "
"pero aún son compatibles por compatibilidad con Python 2.5 y versiones "
"anteriores."

#: ../Doc/library/threading.rst:38
msgid ""
"In CPython, due to the :term:`Global Interpreter Lock <global interpreter "
"lock>`, only one thread can execute Python code at once (even though certain "
"performance-oriented libraries might overcome this limitation). If you want "
"your application to make better use of the computational resources of multi-"
"core machines, you are advised to use :mod:`multiprocessing` or :class:"
"`concurrent.futures.ProcessPoolExecutor`. However, threading is still an "
"appropriate model if you want to run multiple I/O-bound tasks simultaneously."
msgstr ""
"En CPython, debido al :term:`Candado de intérprete global <global "
"interpreter lock>`, solo un hilo puede ejecutar código Python a la vez "
"(aunque ciertas bibliotecas orientadas al rendimiento pueden superar esta "
"limitación). Si desea que su aplicación haga un mejor uso de los recursos "
"computacionales de las máquinas multinúcleo, se recomienda utilizar :mod:"
"`multiprocessing` o :class:`concurrent.futures.ProcessPoolExecutor`. Sin "
"embargo, el subproceso sigue siendo un modelo apropiado si desea ejecutar "
"varias tareas vinculadas a E/S simultáneamente."

#: ../Doc/includes/wasm-notavail.rst:3
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ":ref:`Disponibilidad <availability>`: no Emscripten, no WASI."

#: ../Doc/includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"Este módulo no funciona o no está disponible en las plataformas WebAssembly "
"``wasm32-emscripten`` y ``wasm32-wasi``. Consulte :ref:`wasm-availability` "
"para obtener más información."

#: ../Doc/library/threading.rst:50
msgid "This module defines the following functions:"
msgstr "Este módulo define las siguientes funciones:"

#: ../Doc/library/threading.rst:55
msgid ""
"Return the number of :class:`Thread` objects currently alive.  The returned "
"count is equal to the length of the list returned by :func:`.enumerate`."
msgstr ""
"Retorna el número de objetos :class:`Thread` actualmente con vida. La cuenta "
"retornada es igual al largo de la lista retornada por :func:`.enumerate`."

#: ../Doc/library/threading.rst:58
msgid "The function ``activeCount`` is a deprecated alias for this function."
msgstr "La función ``activeCount`` es un alias obsoleto para esta función."

#: ../Doc/library/threading.rst:63
msgid ""
"Return the current :class:`Thread` object, corresponding to the caller's "
"thread of control.  If the caller's thread of control was not created "
"through the :mod:`threading` module, a dummy thread object with limited "
"functionality is returned."
msgstr ""
"Retorna el objeto :class:`Thread` actual, correspondiente al hilo de control "
"del invocador. Si el hilo de control del invocador no fue creado a través "
"del módulo :mod:`threading`, se retorna un objeto hilo *dummy* con "
"funcionalidad limitada."

#: ../Doc/library/threading.rst:68
msgid "The function ``currentThread`` is a deprecated alias for this function."
msgstr "La función ``currentThread`` es un alias obsoleto para esta función."

#: ../Doc/library/threading.rst:73
msgid "Handle uncaught exception raised by :func:`Thread.run`."
msgstr "Gestiona una excepción lanzada por :func:`Thread.run`."

#: ../Doc/library/threading.rst:75
msgid "The *args* argument has the following attributes:"
msgstr "El argumento *args* posee los siguientes atributos:"

#: ../Doc/library/threading.rst:77
msgid "*exc_type*: Exception type."
msgstr "*exc_type*: Tipo de excepción."

#: ../Doc/library/threading.rst:78
msgid "*exc_value*: Exception value, can be ``None``."
msgstr "*exc_value*: Valor de la excepción, puede ser ``None``."

#: ../Doc/library/threading.rst:79
msgid "*exc_traceback*: Exception traceback, can be ``None``."
msgstr "*exc_traceback*: Rastreo de la excepción, puede ser ``None``."

#: ../Doc/library/threading.rst:80
msgid "*thread*: Thread which raised the exception, can be ``None``."
msgstr "*thread*: El hilo que ha lanzado la excepción, puede ser ``None``."

#: ../Doc/library/threading.rst:82
msgid ""
"If *exc_type* is :exc:`SystemExit`, the exception is silently ignored. "
"Otherwise, the exception is printed out on :data:`sys.stderr`."
msgstr ""
"Si *exc_type* es :exc:`SystemExit`, la excepción es silenciosamente "
"ignorada. De otro modo, la excepción se imprime en :data:`sys.stderr`."

#: ../Doc/library/threading.rst:85
msgid ""
"If  this function raises an exception, :func:`sys.excepthook` is called to "
"handle it."
msgstr ""
"Si esta función lanza una excepción, se llama a :func:`sys.excepthook` para "
"manejarla."

#: ../Doc/library/threading.rst:88
msgid ""
":func:`threading.excepthook` can be overridden to control how uncaught "
"exceptions raised by :func:`Thread.run` are handled."
msgstr ""
":func:`threading.excepthook` se puede sobrescribir para controlar cómo se "
"gestionan las excepciones levantadas por :func:`Thread.run`."

#: ../Doc/library/threading.rst:91
msgid ""
"Storing *exc_value* using a custom hook can create a reference cycle. It "
"should be cleared explicitly to break the reference cycle when the exception "
"is no longer needed."
msgstr ""
"Guarda *exc_value* usando un *hook* personalizado puede crear un ciclo de "
"referencias. Debe ser aclarado explícitamente que se rompa el ciclo de "
"referencias cuando la excepción ya no se necesite."

#: ../Doc/library/threading.rst:95
msgid ""
"Storing *thread* using a custom hook can resurrect it if it is set to an "
"object which is being finalized. Avoid storing *thread* after the custom "
"hook completes to avoid resurrecting objects."
msgstr ""
"Guardando *thread* usando un *hook* personalizado puede resucitarlo si se "
"asigna a un objeto que esté siendo finalizado. Evítese que *thread* sea "
"almacenado después de que el *hook* personalizado se complete para evitar "
"resucitar objetos."

#: ../Doc/library/threading.rst:100
msgid ":func:`sys.excepthook` handles uncaught exceptions."
msgstr ":func:`sys.excepthook` gestiona excepciones no capturadas."

#: ../Doc/library/threading.rst:106
msgid ""
"Holds the original value of :func:`threading.excepthook`. It is saved so "
"that the original value can be restored in case they happen to get replaced "
"with broken or alternative objects."
msgstr ""
"Mantiene el valor original de :func:`threading.excepthook`. Se guarda para "
"que se pueda restaurar el valor original en caso de que se reemplacen con "
"objetos rotos o alternativos."

#: ../Doc/library/threading.rst:114
msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""
"Retorna el 'identificador de hilo' del hilo actual. Éste es un entero "
"distinto de cero. Su valor no tiene un significado directo; ha sido pensado "
"como una *cookie* mágica para usarse, por ejemplo, en indexar un diccionario "
"con datos específicos del hilo. Los identificadores de hilo pueden ser "
"reciclados cuando se abandona un hilo y se crea otro hilo."

#: ../Doc/library/threading.rst:125
msgid ""
"Return the native integral Thread ID of the current thread assigned by the "
"kernel. This is a non-negative integer. Its value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"Retorna la ID de Hilo (*Thread ID*) nativo integral del hilo actual asignado "
"por el kernel. Este es un entero distinto de cero. Su valor puede utilizarse "
"para identificar de forma única a este hilo en particular a través de todo "
"el sistema (hasta que el hilo termine, luego de lo cual el valor puede ser "
"reciclado por el SO)."

#: ../Doc/library/threading.rst:130 ../Doc/library/threading.rst:465
msgid ""
":ref:`Availability <availability>`: Windows, FreeBSD, Linux, macOS, OpenBSD, "
"NetBSD, AIX, DragonFlyBSD."
msgstr ""
":ref:`Disponibilidad <availability>`: Windows, FreeBSD, Linux, macOS, "
"OpenBSD, NetBSD, AIX, DragonFlyBSD."

#: ../Doc/library/threading.rst:137
msgid ""
"Return a list of all :class:`Thread` objects currently active.  The list "
"includes daemonic threads and dummy thread objects created by :func:"
"`current_thread`.  It excludes terminated threads and threads that have not "
"yet been started.  However, the main thread is always part of the result, "
"even when terminated."
msgstr ""
"Retorna una lista de todos los objetos :class:`Thread` actualmente activos. "
"La lista incluye subprocesos demoníacos y objetos de subprocesos ficticios "
"creados por :func:`current_thread`. Excluye los subprocesos terminados y los "
"subprocesos que aún no se han iniciado. Sin embargo, el hilo principal "
"siempre es parte del resultado, incluso cuando se termina."

#: ../Doc/library/threading.rst:146
msgid ""
"Return the main :class:`Thread` object.  In normal conditions, the main "
"thread is the thread from which the Python interpreter was started."
msgstr ""
"Retorna el objeto :class:`Thread` principal. En condiciones normales, el "
"hilo principal es el hilo desde el que fue inicializado el intérprete de "
"Python."

#: ../Doc/library/threading.rst:157
msgid ""
"Set a trace function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.settrace` for each thread, "
"before its :meth:`~Thread.run` method is called."
msgstr ""
"Establece una función de seguimiento para todos los hilos iniciados desde el "
"módulo :mod:`threading` . La *func* se pasará a :func:`sys.settrace` por "
"cada hilo, antes de que su método :meth:`~Thread.run` sea invocado."

#: ../Doc/library/threading.rst:163
msgid ""
"Set a trace function for all threads started from the :mod:`threading` "
"module and all Python threads that are currently executing."
msgstr ""
"Establece una función de seguimiento para todos los hilos iniciados desde el "
"módulo :mod:`threading` y todos los hilos de Python que se estén ejecutando "
"en ese momento."

#: ../Doc/library/threading.rst:166
msgid ""
"The *func* will be passed to  :func:`sys.settrace` for each thread, before "
"its :meth:`~Thread.run` method is called."
msgstr ""
"La *func* será pasada a :func:`sys.settrace` para cada hilo, antes de que su "
"método :meth:`~Thread.run` sea invocado."

#: ../Doc/library/threading.rst:177
msgid "Get the trace function as set by :func:`settrace`."
msgstr ""
"Obtiene la función de rastreo según lo establecido por :func:`settrace`."

#: ../Doc/library/threading.rst:186
msgid ""
"Set a profile function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.setprofile` for each "
"thread, before its :meth:`~Thread.run` method is called."
msgstr ""
"Establece una función de perfil para todos los hilos iniciados desde el "
"módulo :mod:`threading`. La *func* se pasará a :func:`sys.setprofile` por "
"cada hilo, antes de que se llame a su método :meth:`~Thread.run`."

#: ../Doc/library/threading.rst:192
msgid ""
"Set a profile function for all threads started from the :mod:`threading` "
"module and all Python threads that are currently executing."
msgstr ""
"Establece una función de perfil para todos los hilos iniciados desde el "
"módulo :mod:`threading` y todos los hilos de Python que se estén ejecutando "
"en ese momento."

#: ../Doc/library/threading.rst:195
msgid ""
"The *func* will be passed to  :func:`sys.setprofile` for each thread, before "
"its :meth:`~Thread.run` method is called."
msgstr ""
"La *func* se pasará a :func:`sys.setprofile` para cada hilo, antes de que se "
"llame a su método :meth:`~Thread.run`."

#: ../Doc/library/threading.rst:204
msgid "Get the profiler function as set by :func:`setprofile`."
msgstr ""
"Obtiene la función de generador de perfiles establecida por :func:"
"`setprofile`."

#: ../Doc/library/threading.rst:211
msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created "
"threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a :exc:"
"`RuntimeError` is raised.  If the specified stack size is invalid, a :exc:"
"`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information)."
msgstr ""
"Retorna el tamaño de pila usado para crear nuevos hilos. El argumento "
"opcional *size* (tamaño) especifica el tamaño de pila a ser utilizado para "
"hilos creados posteriormente, y debe ser 0 (usar el valor por defecto de la "
"plataforma o el configurado) o un valor entero positivo de al menos 32.768 "
"(32KiB). Si no se especifica *size*, se usará 0. Si no existe soporte para "
"cambiar el tamaño de pila, se lanzará un :exc:`RuntimeError`. Si el tamaño "
"de pila especificado es inválido, se lanzará un :exc:`ValueError` y el "
"tamaño de pila no será modificado. El tamaño mínimo de pila actualmente "
"soportado es de 32KiB para garantizar suficiente espacio de pila para el "
"intérprete mismo. Nótese que algunas plataformas pueden tener restricciones "
"particulares de valores para tamaños de pila, como requerir un tamaño de "
"pila > 32KiB, o requerir una asignación en múltiplos del tamaño de página de "
"la memoria del sistema. Debe consultarse la documentación de cada plataforma "
"para mayor información (páginas de 4KiB son comunes; se recomienda el uso de "
"múltiplos de 4096 para el tamaño de pila en ausencia de información más "
"específica)"

#: ../Doc/library/threading.rst:226
msgid ":ref:`Availability <availability>`: Windows, pthreads."
msgstr ":ref:`Disponibilidad <availability>`: Windows, pthreads."

#: ../Doc/library/threading.rst:228
msgid "Unix platforms with POSIX threads support."
msgstr "Plataformas Unix con soporte para subprocesos POSIX."

#: ../Doc/library/threading.rst:231
msgid "This module also defines the following constant:"
msgstr "Este módulo también define la siguiente constante:"

#: ../Doc/library/threading.rst:235
msgid ""
"The maximum value allowed for the *timeout* parameter of blocking functions "
"(:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait`, etc.). "
"Specifying a timeout greater than this value will raise an :exc:"
"`OverflowError`."
msgstr ""
"El máximo valor permitido para el parámetro *timeout* de las funciones "
"bloqueantes (:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition."
"wait`, etc.). La especificación de un tiempo de espera mayor a este valor "
"lanzará un :exc:`OverflowError`."

#: ../Doc/library/threading.rst:243
msgid ""
"This module defines a number of classes, which are detailed in the sections "
"below."
msgstr ""
"Este módulo define un número de clases, las cuales son detalladas en las "
"siguientes secciones."

#: ../Doc/library/threading.rst:246
msgid ""
"The design of this module is loosely based on Java's threading model. "
"However, where Java makes locks and condition variables basic behavior of "
"every object, they are separate objects in Python.  Python's :class:`Thread` "
"class supports a subset of the behavior of Java's Thread class; currently, "
"there are no priorities, no thread groups, and threads cannot be destroyed, "
"stopped, suspended, resumed, or interrupted.  The static methods of Java's "
"Thread class, when implemented, are mapped to module-level functions."
msgstr ""
"El diseño de este módulo está vagamente basado en el modelo de hilos de "
"Java. Sin embargo, donde Java hace que los bloqueos y las variables de "
"condición sean comportamientos básicos de cada objeto, en Python son objetos "
"separados.  La clase :class:`Thread` de Python soporta un subconjunto del "
"comportamiento de la clase Thread de Java; actualmente, no hay prioridades, "
"no hay grupos de hilos, y los hilos no pueden ser destruidos, detenidos, "
"suspendidos, reanudados o interrumpidos.  Los métodos estáticos de la clase "
"Thread de Java, cuando se implementan, se asignan a funciones de nivel de "
"módulo."

#: ../Doc/library/threading.rst:254
msgid "All of the methods described below are executed atomically."
msgstr "Todos los métodos descritos abajo son ejecutados de manera atómica."

#: ../Doc/library/threading.rst:258
msgid "Thread-Local Data"
msgstr "Datos locales del hilo"

#: ../Doc/library/threading.rst:260
msgid ""
"Thread-local data is data whose values are thread specific.  To manage "
"thread-local data, just create an instance of :class:`local` (or a subclass) "
"and store attributes on it::"
msgstr ""
"Los datos locales de hilo son datos cuyos valores son específicos a cada "
"hilo. Para manejar los datos locales de hilos, simplemente crear una "
"instancia de :class:`local` (o una subclase) y almacenar los atributos en "
"ella::"

#: ../Doc/library/threading.rst:267
msgid "The instance's values will be different for separate threads."
msgstr "Los valores de instancia serán diferentes para hilos distintos."

#: ../Doc/library/threading.rst:272
msgid "A class that represents thread-local data."
msgstr "Una clase que representa datos locales de hilo."

#: ../Doc/library/threading.rst:274
msgid ""
"For more details and extensive examples, see the documentation string of "
"the :mod:`!_threading_local` module: :source:`Lib/_threading_local.py`."
msgstr ""
"Para más detalles y ejemplos extensivos, véase la documentación del módulo :"
"mod:`!_threading_local` module: :source:`Lib/_threading_local.py`."

#: ../Doc/library/threading.rst:281
msgid "Thread Objects"
msgstr "Objetos tipo hilo"

#: ../Doc/library/threading.rst:283
msgid ""
"The :class:`Thread` class represents an activity that is run in a separate "
"thread of control.  There are two ways to specify the activity: by passing a "
"callable object to the constructor, or by overriding the :meth:`~Thread.run` "
"method in a subclass.  No other methods (except for the constructor) should "
"be overridden in a subclass.  In other words, *only*  override the "
"``__init__()`` and :meth:`~Thread.run` methods of this class."
msgstr ""
"La clase :class:`Thread` representa una actividad que corre en un hilo de "
"control separado. Hay dos manera de especificar la actividad: pasando un "
"objeto invocable al constructor, o sobrescribiendo el método :meth:`~Thread."
"run` en una subclase. Ningún otro método (a excepción del constructor) "
"deberá ser sobrescrito en una subclase. En otras palabras, *solo* "
"sobrescribir los métodos  ``__init__()`` y :meth:`~Thread.run`  de esta "
"clase."

#: ../Doc/library/threading.rst:290
msgid ""
"Once a thread object is created, its activity must be started by calling the "
"thread's :meth:`~Thread.start` method.  This invokes the :meth:`~Thread.run` "
"method in a separate thread of control."
msgstr ""
"Una vez que un objeto *thread* es creado, su actividad debe ser iniciada "
"llamando al método :meth:`~Thread.start` del hilo. Ésto invoca el método :"
"meth:`~Thread.run` en un hilo de control separado."

#: ../Doc/library/threading.rst:294
msgid ""
"Once the thread's activity is started, the thread is considered 'alive'. It "
"stops being alive when its :meth:`~Thread.run` method terminates -- either "
"normally, or by raising an unhandled exception.  The :meth:`~Thread."
"is_alive` method tests whether the thread is alive."
msgstr ""
"Una vez que la actividad del hilo ha sido iniciada, el hilo se considerará "
"'vivo'. Deja de estar vivo cuando su método :meth:`~Thread.run` termina -- "
"ya sea normalmente, o por lanzar una excepción no manejada. El método  :meth:"
"`~Thread.is_alive` verifica si acaso el hilo está vivo."

#: ../Doc/library/threading.rst:299
msgid ""
"Other threads can call a thread's :meth:`~Thread.join` method.  This blocks "
"the calling thread until the thread whose :meth:`~Thread.join` method is "
"called is terminated."
msgstr ""
"Otras hilos pueden llamar al método :meth:`~Thread.join`. Esto bloquea el "
"hilo que llama hasta que el hilo cuyo método :meth:`~Hilo.join` es llamado "
"termina."

#: ../Doc/library/threading.rst:303
msgid ""
"A thread has a name.  The name can be passed to the constructor, and read or "
"changed through the :attr:`~Thread.name` attribute."
msgstr ""
"Un hilo tiene un nombre. El nombre puede ser pasado al constructor y leído o "
"cambiado a través del atributo :attr:`~Thread.name`."

#: ../Doc/library/threading.rst:306
msgid ""
"If the :meth:`~Thread.run` method raises an exception, :func:`threading."
"excepthook` is called to handle it. By default, :func:`threading.excepthook` "
"ignores silently :exc:`SystemExit`."
msgstr ""
"Si el método :meth:`~Thread.run` lanza una excepción, se llama a :func:"
"`threading.excepthook` para gestionarla. Por defecto, :func:`threading."
"excepthook` ignora silenciosamente a :exc:`SystemExit`."

#: ../Doc/library/threading.rst:310
msgid ""
"A thread can be flagged as a \"daemon thread\".  The significance of this "
"flag is that the entire Python program exits when only daemon threads are "
"left.  The initial value is inherited from the creating thread.  The flag "
"can be set through the :attr:`~Thread.daemon` property or the *daemon* "
"constructor argument."
msgstr ""
"Un hilo puede ser marcado como un \"hilo demonio\". El significado de esta "
"marca es que la totalidad del programa de Python finalizará cuando solo "
"queden hilos demonio. El valor inicial es heredado del hilo creador. La "
"marca puede ser establecida a través de la propiedad :attr:`~Thread.daemon` "
"o del argumento *daemon* en el constructor."

#: ../Doc/library/threading.rst:317
msgid ""
"Daemon threads are abruptly stopped at shutdown.  Their resources (such as "
"open files, database transactions, etc.) may not be released properly. If "
"you want your threads to stop gracefully, make them non-daemonic and use a "
"suitable signalling mechanism such as an :class:`Event`."
msgstr ""
"Los hilos demonio son detenidos abruptamente al momento del cierre. Sus "
"recursos (tales como archivos abiertos, transacciones con bases de datos, "
"etc.) pueden no ser liberados adecuadamente. Si se requiere que los hilos se "
"detengan con gracia, háganse no-demoníacos y úsese un mecanismo de "
"señalización adecuado tal como un :class:`Event`."

#: ../Doc/library/threading.rst:322
msgid ""
"There is a \"main thread\" object; this corresponds to the initial thread of "
"control in the Python program.  It is not a daemon thread."
msgstr ""
"Existe un objeto \"hilo principal\"; éste corresponde al hilo de control "
"inicial del programa de Python. No es un hilo demonio."

#: ../Doc/library/threading.rst:325
msgid ""
"There is the possibility that \"dummy thread objects\" are created. These "
"are thread objects corresponding to \"alien threads\", which are threads of "
"control started outside the threading module, such as directly from C code.  "
"Dummy thread objects have limited functionality; they are always considered "
"alive and daemonic, and cannot be :ref:`joined <meth-thread-join>`.  They "
"are never deleted, since it is impossible to detect the termination of alien "
"threads."
msgstr ""
"Existe la posibilidad de crear \"objetos de hilos *dummy*\". Estos son "
"objetos hilo correspondientes a \"hilos extranjeros\", que son hilos de "
"control iniciados afuera del modulo *threading*, por ejemplo directamente de "
"código en C. Los objetos de hilos *dummy* tienen funcionalidad limitada; "
"siempre se consideran vivos y demoníacos, y no pueden se les puede aplicar "
"el método :ref:`joined <meth-thread-join>`. Nunca son eliminados, ya que es "
"imposible detectar la terminación de hilos extranjeros."

#: ../Doc/library/threading.rst:336
msgid ""
"This constructor should always be called with keyword arguments.  Arguments "
"are:"
msgstr ""
"Este constructor siempre debe ser llamado con argumentos de palabra clave. "
"Los argumentos son:"

#: ../Doc/library/threading.rst:339
msgid ""
"*group* should be ``None``; reserved for future extension when a :class:`!"
"ThreadGroup` class is implemented."
msgstr ""
"*group* debe ser `None`; reservado para una futura extensión cuando se "
"implemente una clase :class:`!ThreadGroup`."

#: ../Doc/library/threading.rst:342
msgid ""
"*target* is the callable object to be invoked by the :meth:`run` method. "
"Defaults to ``None``, meaning nothing is called."
msgstr ""
"*target* es el objeto invocable a ser invocado por el método :meth:`run`. "
"Por defecto es ``None``, lo que significa que nada es llamado."

#: ../Doc/library/threading.rst:345
msgid ""
"*name* is the thread name. By default, a unique name is constructed of the "
"form \"Thread-*N*\" where *N* is a small decimal number, or \"Thread-*N* "
"(target)\" where \"target\" is ``target.__name__`` if the *target* argument "
"is specified."
msgstr ""
"*name* es el nombre del hilo. De forma predeterminada, se construye un "
"nombre único con el formato \"Hilo-*N*\", donde *N* es un número decimal "
"pequeño, o \"Hilo-*N* (target)\" donde \"target\" es ``target.__name__`` si "
"se especifica el argumento *target*."

#: ../Doc/library/threading.rst:350
msgid ""
"*args* is a list or tuple of arguments for the target invocation.  Defaults "
"to ``()``."
msgstr ""
"*args* es una lista o tupla de argumentos para la invocación de destino. Por "
"defecto es ``()``."

#: ../Doc/library/threading.rst:352
msgid ""
"*kwargs* is a dictionary of keyword arguments for the target invocation. "
"Defaults to ``{}``."
msgstr ""
"*kwargs* es un diccionario de argumentos de palabra clave para la invocación "
"objetivo. Por defecto es ``{}``."

#: ../Doc/library/threading.rst:355
msgid ""
"If not ``None``, *daemon* explicitly sets whether the thread is daemonic. If "
"``None`` (the default), the daemonic property is inherited from the current "
"thread."
msgstr ""
"Si no es ``None``, *daemon* establece explícitamente si el hilo es "
"demoníaco. Si es ``None`` (el valor por defecto), la propiedad demoníaca es "
"heredada del hilo actual."

#: ../Doc/library/threading.rst:359
msgid ""
"If the subclass overrides the constructor, it must make sure to invoke the "
"base class constructor (``Thread.__init__()``) before doing anything else to "
"the thread."
msgstr ""
"Si la subclase sobrescribe el constructor, debe asegurarse de invocar al "
"constructor de la clase base (``Thread.__init__()``) antes de hacer "
"cualquier otra cosa al hilo."

#: ../Doc/library/threading.rst:363
msgid "Use the *target* name if *name* argument is omitted."
msgstr "Utilice el nombre *target* si se omite el argumento *name*."

#: ../Doc/library/threading.rst:366
msgid "Added the *daemon* argument."
msgstr "Se agregó el argumento *daemon*."

#: ../Doc/library/threading.rst:371
msgid "Start the thread's activity."
msgstr "Inicia la actividad del hilo."

#: ../Doc/library/threading.rst:373
msgid ""
"It must be called at most once per thread object.  It arranges for the "
"object's :meth:`~Thread.run` method to be invoked in a separate thread of "
"control."
msgstr ""
"Debe ser llamada máximo una vez por objeto hilo. Se encarga de que el "
"método :meth:`~Thread.run` del objeto sea invocado en un hilo de control "
"separado."

#: ../Doc/library/threading.rst:377
msgid ""
"This method will raise a :exc:`RuntimeError` if called more than once on the "
"same thread object."
msgstr ""
"Este método lanzará un :exc:`RuntimeError` si se llama más de una vez en el "
"mismo objeto hilo."

#: ../Doc/library/threading.rst:382
msgid "Method representing the thread's activity."
msgstr "Método que representa la actividad del hilo."

#: ../Doc/library/threading.rst:384
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the "
"*target* argument, if any, with positional and keyword arguments taken from "
"the *args* and *kwargs* arguments, respectively."
msgstr ""
"Se puede sobrescribir este método en una subclase. El método estándar :meth:"
"`run` invoca el objeto invocable pasado al constructor del objeto como "
"argumento *target*, si lo hay, con argumentos posicionales y de palabra "
"clave tomados de los argumentos *args* y *kwargs*, respectivamente."

#: ../Doc/library/threading.rst:389
msgid ""
"Using list or tuple as the *args* argument which passed to the :class:"
"`Thread` could achieve the same effect."
msgstr ""
"Usar una lista o tupla como el argumento *args* que se pasa a :class:"
"`Thread` podría lograr el mismo efecto."

#: ../Doc/library/threading.rst:392
msgid "Example::"
msgstr "Ejemplo::"

#: ../Doc/library/threading.rst:406
msgid ""
"Wait until the thread terminates. This blocks the calling thread until the "
"thread whose :meth:`~Thread.join` method is called terminates -- either "
"normally or through an unhandled exception -- or until the optional timeout "
"occurs."
msgstr ""
"Espera a que el hilo termine. Esto bloquea el hilo llamador hasta que el "
"hilo cuyo método :meth:`~Thread.join` es llamado finalice -- ya sea "
"normalmente o a través de una excepción no gestionada -- o hasta que el "
"tiempo de espera opcional caduque."

#: ../Doc/library/threading.rst:411
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof). As :meth:`~Thread.join` always returns ``None``, you "
"must call :meth:`~Thread.is_alive` after :meth:`~Thread.join` to decide "
"whether a timeout happened -- if the thread is still alive, the :meth:"
"`~Thread.join` call timed out."
msgstr ""
"Cuando se presenta un argumento *timeout* y no es ``None``, debe ser un "
"número de punto flotante que especifique un tiempo de espera en segundos (o "
"en fracciones de segundo) para la operación . Ya que :meth:`~Thread.join` "
"siempre retorna ``None``, se debe llamar a :meth:`~Thread.is_alive` después "
"de :meth:`~Thread.join` para decidir si acaso caducó el tiempo de espera -- "
"si el hilo todavía está vivo, la llamada a :meth:`~Thread.join` caducó."

#: ../Doc/library/threading.rst:418
msgid ""
"When the *timeout* argument is not present or ``None``, the operation will "
"block until the thread terminates."
msgstr ""
"Cuando el argumento *timeout* no se presenta o es ``None``, la operación "
"bloqueará hasta que el hilo termine."

#: ../Doc/library/threading.rst:421
msgid "A thread can be joined many times."
msgstr "Un hilo puede unirse varias veces."

#: ../Doc/library/threading.rst:423
msgid ""
":meth:`~Thread.join` raises a :exc:`RuntimeError` if an attempt is made to "
"join the current thread as that would cause a deadlock. It is also an error "
"to :meth:`~Thread.join` a thread before it has been started and attempts to "
"do so raise the same exception."
msgstr ""
":meth:`~Thread.join` lanza un :exc:`RuntimeError` si se intenta unir el hilo "
"actual ya que ello generaría un punto muerto. También es un error aplicar :"
"meth:`~Thread.join` a un hilo antes de que haya sido iniciado y los intentos "
"de hacerlo lanzaran la misma excepción."

#: ../Doc/library/threading.rst:430
msgid ""
"A string used for identification purposes only. It has no semantics. "
"Multiple threads may be given the same name.  The initial name is set by the "
"constructor."
msgstr ""
"Un *string* utilizado con propósitos de identificación. No posee semántica. "
"Se puede dar el mismo nombre a múltiples hilos. El nombre inicial es "
"establecido por el constructor."

#: ../Doc/library/threading.rst:437
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.name`; use it directly as a "
"property instead."
msgstr ""
"API getter/setter obsoleta para :attr:`~Thread.name`; utilícelo directamente "
"como una propiedad en su lugar."

#: ../Doc/library/threading.rst:444
msgid ""
"The 'thread identifier' of this thread or ``None`` if the thread has not "
"been started.  This is a nonzero integer.  See the :func:`get_ident` "
"function.  Thread identifiers may be recycled when a thread exits and "
"another thread is created.  The identifier is available even after the "
"thread has exited."
msgstr ""
"El 'identificador de hilo' de este hilo o ``None`` si el hilo no ha sido "
"iniciado. Es un entero distinto de cero. Ver la función :func:`get_ident`. "
"Los identificadores de hilos pueden ser reciclados cuando un hilo finaliza y "
"otro hilo es creado. El identificador está disponible incuso después de que "
"el hilo ha abandonado."

#: ../Doc/library/threading.rst:452
msgid ""
"The Thread ID (``TID``) of this thread, as assigned by the OS (kernel). This "
"is a non-negative integer, or ``None`` if the thread has not been started. "
"See the :func:`get_native_id` function. This value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"El ID de subproceso (``TID``) de este subproceso, según lo asignado por el "
"sistema operativo (kernel). Este es un número entero no negativo, o ``None`` "
"si el hilo no se ha iniciado. Consulte la función :func:`get_native_id`. "
"Este valor se puede usar para identificar de forma única este hilo en "
"particular en todo el sistema (hasta que el hilo termine, después de lo cual "
"el sistema operativo puede reciclar el valor)."

#: ../Doc/library/threading.rst:461
msgid ""
"Similar to Process IDs, Thread IDs are only valid (guaranteed unique system-"
"wide) from the time the thread is created until the thread has been "
"terminated."
msgstr ""
"Similar a las *Process IDs*, las *Thread IDs* sólo son válidas (garantizadas "
"como únicas a través de todo el sistema) desde el momento en que se crea el "
"hilo hasta que el hilo es finalizado."

#: ../Doc/library/threading.rst:471
msgid "Return whether the thread is alive."
msgstr "Retornar si acaso el hilo está vivo."

#: ../Doc/library/threading.rst:473
msgid ""
"This method returns ``True`` just before the :meth:`~Thread.run` method "
"starts until just after the :meth:`~Thread.run` method terminates.  The "
"module function :func:`.enumerate` returns a list of all alive threads."
msgstr ""
"Este método retorna ``True`` desde justo antes de que el método :meth:"
"`~Thread.run` inicie hasta junto antes de que el método :meth:`~Thread.run` "
"termine. La función :func:`.enumerate` del módulo retorna una lista de todos "
"los hilos vivos."

#: ../Doc/library/threading.rst:479
msgid ""
"A boolean value indicating whether this thread is a daemon thread (``True``) "
"or not (``False``).  This must be set before :meth:`~Thread.start` is "
"called, otherwise :exc:`RuntimeError` is raised.  Its initial value is "
"inherited from the creating thread; the main thread is not a daemon thread "
"and therefore all threads created in the main thread default to :attr:"
"`~Thread.daemon` = ``False``."
msgstr ""
"Un valor booleano que indica si este hilo es un hilo demonio (*True*) o no "
"(*False*). Debe ser establecido antes de que se llame a :meth:`~Thread."
"start`, de lo contrario se lanzará un :exc:`RuntimeError`. Su valor inicial "
"se hereda del hilo creador; el hilo principal no es un hilo demonio y por lo "
"tanto todos los hilos creados en el hilo principal tienen por defecto un "
"valor :attr:`~Thread.daemon` = ``False``."

#: ../Doc/library/threading.rst:486
msgid ""
"The entire Python program exits when no alive non-daemon threads are left."
msgstr ""
"El programa de Python en su totalidad finaliza cuando no queda ningún hilo "
"no-demonio vivo."

#: ../Doc/library/threading.rst:491
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.daemon`; use it directly as "
"a property instead."
msgstr ""
"API getter/setter obsoleta para :attr:`~Thread.daemon`; utilícelo "
"directamente como una propiedad en su lugar."

#: ../Doc/library/threading.rst:500
msgid "Lock Objects"
msgstr "Objetos tipo *lock*"

#: ../Doc/library/threading.rst:502
msgid ""
"A primitive lock is a synchronization primitive that is not owned by a "
"particular thread when locked.  In Python, it is currently the lowest level "
"synchronization primitive available, implemented directly by the :mod:"
"`_thread` extension module."
msgstr ""
"Una primitiva *lock*, es una primitiva de sincronización que no pertenece a "
"ningún hilo en particular cuando está cerrado. En Python, es la primitiva de "
"sincronización de más bajo nivel actualmente disponible, implementado "
"directamente por el módulo de extensión :mod:`_thread`."

#: ../Doc/library/threading.rst:507
msgid ""
"A primitive lock is in one of two states, \"locked\" or \"unlocked\". It is "
"created in the unlocked state.  It has two basic methods, :meth:`~Lock."
"acquire` and :meth:`~Lock.release`.  When the state is unlocked, :meth:"
"`~Lock.acquire` changes the state to locked and returns immediately.  When "
"the state is locked, :meth:`~Lock.acquire` blocks until a call to :meth:"
"`~Lock.release` in another thread changes it to unlocked, then the :meth:"
"`~Lock.acquire` call resets it to locked and returns.  The :meth:`~Lock."
"release` method should only be called in the locked state; it changes the "
"state to unlocked and returns immediately. If an attempt is made to release "
"an unlocked lock, a :exc:`RuntimeError` will be raised."
msgstr ""
"Una primitiva *lock* está en uno de dos estados, \"cerrado\" o "
"\"abierto\" (*locked*/*unlocked*). Se crea en estado abierto. Tiene dos "
"métodos básicos, :meth:`~Lock.acquire` (adquirir) y :meth:`~Lock.release` "
"(liberar). Cuando el estado es *abierto*, :meth:`~Lock.acquire` cambia el "
"estado a cerrado y retorna inmediatamente. Cuando el estado es *cerrado*, :"
"meth:`~Lock.acquire` bloquea hasta que una llamada a :meth:`~Lock.release` "
"en otro hilo lo cambie a abierto, luego la llamada a :meth:`~Lock.acquire` "
"lo restablece a cerrado y retorna. El método :meth:`~Lock.release` sólo debe "
"ser llamado en el estado cerrado; cambia el estado a abierto y retorna "
"inmediatamente. Si se realiza un intento de liberar un *lock* abierto, se "
"lanzará un :exc:`RuntimeError`."

#: ../Doc/library/threading.rst:518
msgid "Locks also support the :ref:`context management protocol <with-locks>`."
msgstr ""
"Los *locks* también soportan el :ref:`protocolo de gestión de contexto <with-"
"locks>`."

#: ../Doc/library/threading.rst:520
msgid ""
"When more than one thread is blocked in :meth:`~Lock.acquire` waiting for "
"the state to turn to unlocked, only one thread proceeds when a :meth:`~Lock."
"release` call resets the state to unlocked; which one of the waiting threads "
"proceeds is not defined, and may vary across implementations."
msgstr ""
"Cuando más de un hilo está bloqueado en :meth:`~Lock.acquire` esperando que "
"el estado sea abierto, sólo un hilo procederá cuando una llamada a :meth:"
"`~Lock.release` restablezca el estado a abierto; cuál de los hilos en espera "
"procederá no está definido, y puede variar a través de las implementaciones."

#: ../Doc/library/threading.rst:525
msgid "All methods are executed atomically."
msgstr "Todos los métodos se ejecutan de manera atómica."

#: ../Doc/library/threading.rst:530
msgid ""
"The class implementing primitive lock objects.  Once a thread has acquired a "
"lock, subsequent attempts to acquire it block, until it is released; any "
"thread may release it."
msgstr ""
"La clase que implemente los objetos de la primitiva *lock*. Una vez que un "
"hilo ha adquirido un *lock*, intentos subsecuentes por adquirirlo "
"bloquearán, hasta que sea liberado; cualquier hilo puede liberarlo."

#: ../Doc/library/threading.rst:534
msgid ""
"Note that ``Lock`` is actually a factory function which returns an instance "
"of the most efficient version of the concrete Lock class that is supported "
"by the platform."
msgstr ""
"Nótese que ``Lock`` es una función de fábrica que retorna una instancia de "
"la versión más eficiente de la clase *Lock* concreta soportada por la "
"plataforma."

#: ../Doc/library/threading.rst:541 ../Doc/library/threading.rst:621
msgid "Acquire a lock, blocking or non-blocking."
msgstr "Adquirir un *lock*, bloqueante o no bloqueante."

#: ../Doc/library/threading.rst:543
msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default), "
"block until the lock is unlocked, then set it to locked and return ``True``."
msgstr ""
"Cuando se invoca con el argumento *blocking* establecido como ``True`` (el "
"valor por defecto), bloquea hasta que el *lock* se abra, luego lo establece "
"como cerrado y retorna ``True``."

#: ../Doc/library/threading.rst:546
msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block. If "
"a call with *blocking* set to ``True`` would block, return ``False`` "
"immediately; otherwise, set the lock to locked and return ``True``."
msgstr ""
"Cuando es invocado con el argumento *blocking* como ``False``, no bloquea. "
"Si una llamada con *blocking* establecido como ``True`` bloqueara, retorna "
"``Falso`` inmediatamente; de otro modo, cierra el *lock* y retorna ``True``."

#: ../Doc/library/threading.rst:550
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as "
"long as the lock cannot be acquired.  A *timeout* argument of ``-1`` "
"specifies an unbounded wait.  It is forbidden to specify a *timeout* when "
"*blocking* is ``False``."
msgstr ""
"Cuando se invoca con el argumento de punto flotante *timeout* fijado a un "
"valor positivo, bloquea por a lo más el número de segundos especificado en "
"*timeout* y mientras el *lock* no pueda ser adquirido. Un argumento "
"*timeout* de \"-1\" especifica una espera ilimitada. No está admitido "
"especificar un *timeout* cuando *blocking* es ``False``."

#: ../Doc/library/threading.rst:556
msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False`` "
"if not (for example if the *timeout* expired)."
msgstr ""
"El valor de retorno es ``True`` si el *lock* es adquirido con éxito, "
"``Falso`` si no (por ejemplo si *timeout* expiró)."

#: ../Doc/library/threading.rst:559 ../Doc/library/threading.rst:643
#: ../Doc/library/threading.rst:890
msgid "The *timeout* parameter is new."
msgstr "El parámetro *timeout* es nuevo."

#: ../Doc/library/threading.rst:562
msgid ""
"Lock acquisition can now be interrupted by signals on POSIX if the "
"underlying threading implementation supports it."
msgstr ""
"La adquisición de un *lock* ahora puede ser interrumpida por señales en "
"POSIX si la implementación de hilado subyacente lo soporta."

#: ../Doc/library/threading.rst:569
msgid ""
"Release a lock.  This can be called from any thread, not only the thread "
"which has acquired the lock."
msgstr ""
"Libera un *lock*. Puede ser llamado desde cualquier hilo, no solo el hilo "
"que ha adquirido el *lock*."

#: ../Doc/library/threading.rst:572
msgid ""
"When the lock is locked, reset it to unlocked, and return.  If any other "
"threads are blocked waiting for the lock to become unlocked, allow exactly "
"one of them to proceed."
msgstr ""
"Cuando el *lock* está cerrado, lo restablece a abierto, y retorna. Si "
"cualquier otro hilo está bloqueado esperando que el *lock* se abra, permite "
"que exactamente uno de ellos proceda."

#: ../Doc/library/threading.rst:576
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr ""
"Cuando se invoca en un *lock* abierto, se lanza un :exc:`RuntimeError`."

#: ../Doc/library/threading.rst:578 ../Doc/library/threading.rst:659
msgid "There is no return value."
msgstr "No hay valor de retorno."

#: ../Doc/library/threading.rst:582
msgid "Return ``True`` if the lock is acquired."
msgstr "Retorna ``True`` si se adquiere el bloqueo."

#: ../Doc/library/threading.rst:589
msgid "RLock Objects"
msgstr "Objetos *Rlock*"

#: ../Doc/library/threading.rst:591
msgid ""
"A reentrant lock is a synchronization primitive that may be acquired "
"multiple times by the same thread.  Internally, it uses the concepts of "
"\"owning thread\" and \"recursion level\" in addition to the locked/unlocked "
"state used by primitive locks.  In the locked state, some thread owns the "
"lock; in the unlocked state, no thread owns it."
msgstr ""
"Un *lock* reentrante es una primitiva de sincronización que puede ser "
"adquirido múltiples veces por el mismo hilo. Internamente, utiliza el "
"concepto de \"hilo dueño\" y \"nivel de recursividad\" además del estado "
"abierto/cerrado utilizado por las primitivas *locks*. Si está en estado "
"cerrado, algún hilo es dueño del *lock*; si está en estado abierto, ningún "
"hilo es dueño."

#: ../Doc/library/threading.rst:597
msgid ""
"To lock the lock, a thread calls its :meth:`~RLock.acquire` method; this "
"returns once the thread owns the lock.  To unlock the lock, a thread calls "
"its :meth:`~Lock.release` method. :meth:`~Lock.acquire`/:meth:`~Lock."
"release` call pairs may be nested; only the final :meth:`~Lock.release` "
"(the :meth:`~Lock.release` of the outermost pair) resets the lock to "
"unlocked and allows another thread blocked in :meth:`~Lock.acquire` to "
"proceed."
msgstr ""
"Para cerrar el *lock*, un hilo llama a su método :meth:`~RLock.acquire`; "
"esto retorna una vez que el hilo se ha adueñado del *lock*. Para abrir el "
"*lock*, un hilo llama a su método :meth:`~Lock.release`. Pares de llamadas :"
"meth:`~Lock.acquire`/:meth:`~Lock.release` pueden anidarse; sólo el :meth:"
"`~Lock.release` final (el :meth:`~Lock.release` del par más externo) "
"restablece el *lock* a abierto y permite que otro hilo bloqueado en :meth:"
"`~Lock.acquire` proceda."

#: ../Doc/library/threading.rst:604
msgid ""
"Reentrant locks also support the :ref:`context management protocol <with-"
"locks>`."
msgstr ""
"Los *locks* reentrantes también soportan el :ref:`protocolo de manejo de "
"contextos <with-locks>`."

#: ../Doc/library/threading.rst:609
msgid ""
"This class implements reentrant lock objects.  A reentrant lock must be "
"released by the thread that acquired it.  Once a thread has acquired a "
"reentrant lock, the same thread may acquire it again without blocking; the "
"thread must release it once for each time it has acquired it."
msgstr ""
"Esta clase implementa objetos tipo *lock* reentrantes. Un *lock* reentrante "
"debe ser liberado por el hilo que lo adquirió. Una vez que un hilo ha "
"adquirido un *lock* reentrante, el mismo hilo puede adquirirlo otra vez sin "
"bloquearse; el hilo debe liberarlo una vez por vez que lo adquiere."

#: ../Doc/library/threading.rst:614
msgid ""
"Note that ``RLock`` is actually a factory function which returns an instance "
"of the most efficient version of the concrete RLock class that is supported "
"by the platform."
msgstr ""
"Nótese que ``RLock`` en realidad es una función fábrica que retorna una "
"instancia de la versión más eficiente de la clase RLock concreta que sea "
"soportada por la plataforma."

#: ../Doc/library/threading.rst:623
msgid ""
"When invoked without arguments: if this thread already owns the lock, "
"increment the recursion level by one, and return immediately.  Otherwise, if "
"another thread owns the lock, block until the lock is unlocked.  Once the "
"lock is unlocked (not owned by any thread), then grab ownership, set the "
"recursion level to one, and return.  If more than one thread is blocked "
"waiting until the lock is unlocked, only one at a time will be able to grab "
"ownership of the lock. There is no return value in this case."
msgstr ""
"Cuando se invoca sin argumentos: si este subproceso ya posee el bloqueo, "
"incrementa el nivel de recursión en uno y devuelve inmediatamente. En caso "
"contrario, si el bloqueo pertenece a otro subproceso, se bloquea hasta que "
"se desbloquea el bloqueo.  Una vez que se desbloquea el bloqueo (no es "
"propiedad de ningún hilo), se toma la propiedad, se establece el nivel de "
"recursividad en uno y se devuelve.  Si hay más de un proceso bloqueado "
"esperando a que se desbloquee el bloqueo, sólo uno a la vez podrá hacerse "
"con la propiedad del bloqueo. En este caso no hay valor de retorno."

#: ../Doc/library/threading.rst:631
msgid ""
"When invoked with the *blocking* argument set to ``True``, do the same thing "
"as when called without arguments, and return ``True``."
msgstr ""
"Cuando se invoca con el argumento *blocking* fijado en ``True``, hace lo "
"mismo que cuando se llama sin argumentos y retorna ``True``."

#: ../Doc/library/threading.rst:634
msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block.  "
"If a call without an argument would block, return ``False`` immediately; "
"otherwise, do the same thing as when called without arguments, and return "
"``True``."
msgstr ""
"Cuando se invoca con el argumento *blocking* fijado a ``False``, no bloquea. "
"Si una llamada sin argumento bloquease, retorna ``False`` inmediatamente; de "
"otro modo, hace lo mismo que al llamarse sin argumentos, y retorna ``True``."

#: ../Doc/library/threading.rst:638
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as "
"long as the lock cannot be acquired.  Return ``True`` if the lock has been "
"acquired, ``False`` if the timeout has elapsed."
msgstr ""
"Cuando se invoca con el argumento de coma flotante *timeout* fijado a un "
"valor positivo, bloquea por máximo el número de segundos especificado por "
"*timeout* y mientras el lock no pueda ser adquirido. Retorna ``True`` si el "
"lock ha sido adquirido, ``False`` si el tiempo de espera ha caducado."

#: ../Doc/library/threading.rst:649
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement it "
"is zero, reset the lock to unlocked (not owned by any thread), and if any "
"other threads are blocked waiting for the lock to become unlocked, allow "
"exactly one of them to proceed.  If after the decrement the recursion level "
"is still nonzero, the lock remains locked and owned by the calling thread."
msgstr ""
"Libera un *lock*, disminuyendo el nivel de recursividad. Si después de la "
"disminución es cero, restablece el *lock* a abierto (no perteneciente a "
"ningún hilo), y si cualquier otro hilo está bloqueado esperando que se abra "
"el *lock*, permite que exactamente uno de ellos proceda. Si luego de la "
"disminución el nivel de recursividad todavía no es cero, el *lock* permanece "
"cerrado y perteneciente al hilo llamador."

#: ../Doc/library/threading.rst:655
msgid ""
"Only call this method when the calling thread owns the lock. A :exc:"
"`RuntimeError` is raised if this method is called when the lock is unlocked."
msgstr ""
"Solo llámese este método cuando el hilo llamador sea dueño del *lock*. Se "
"lanza un :exc:`RuntimeError` si se llama este método cuando el *lock* esta "
"abierto."

#: ../Doc/library/threading.rst:665
msgid "Condition Objects"
msgstr "Objetos condicionales"

#: ../Doc/library/threading.rst:667
msgid ""
"A condition variable is always associated with some kind of lock; this can "
"be passed in or one will be created by default.  Passing one in is useful "
"when several condition variables must share the same lock.  The lock is part "
"of the condition object: you don't have to track it separately."
msgstr ""
"Una condición variable siempre va asociada a algún tipo de *lock*. éste "
"puede ser provisto o se creará uno por defecto. Proveer uno es útil cuando "
"varias variables de condición deben compartir el mismo *lock*. El *lock* es "
"parte del objeto condicional: no es necesario rastrearlo por separado."

#: ../Doc/library/threading.rst:672
msgid ""
"A condition variable obeys the :ref:`context management protocol <with-"
"locks>`: using the ``with`` statement acquires the associated lock for the "
"duration of the enclosed block.  The :meth:`~Condition.acquire` and :meth:"
"`~Condition.release` methods also call the corresponding methods of the "
"associated lock."
msgstr ""
"Una condición variable obedece el :ref:`protocolo de gestión de "
"contexto<with-locks>`: al usar la declaración ``with`` se adquiere el *lock* "
"asociado por la duración del bloque contenido. Los métodos :meth:`~Condition."
"acquire` y :meth:`~Condition.release` también llaman los métodos "
"correspondientes del *lock* asociado."

#: ../Doc/library/threading.rst:678
msgid ""
"Other methods must be called with the associated lock held.  The :meth:"
"`~Condition.wait` method releases the lock, and then blocks until another "
"thread awakens it by calling :meth:`~Condition.notify` or :meth:`~Condition."
"notify_all`.  Once awakened, :meth:`~Condition.wait` re-acquires the lock "
"and returns.  It is also possible to specify a timeout."
msgstr ""
"Otros métodos deben llamarse con el *lock* asociado conservado. El método :"
"meth:`~Condition.wait` libera el *lock*, y luego bloquea hasta que otro hilo "
"lo despierte llamando :meth:`~Condition.notify` o :meth:`~Condition."
"notify_all`. Una vez que ha sido despertado, :meth:`~Condition.wait` re-"
"adquiere el *lock* y retorna. También es posible especificar un tiempo de "
"espera."

#: ../Doc/library/threading.rst:684
msgid ""
"The :meth:`~Condition.notify` method wakes up one of the threads waiting for "
"the condition variable, if any are waiting.  The :meth:`~Condition."
"notify_all` method wakes up all threads waiting for the condition variable."
msgstr ""
"El método :meth:`~Condition.notify` despierta a uno de los hilos que esperan "
"a la condición variable, si es que alguno espera. El método :meth:"
"`~Condition.notify_all` despierta a todos los hilos que estén esperando a la "
"condición variable."

#: ../Doc/library/threading.rst:688
msgid ""
"Note: the :meth:`~Condition.notify` and :meth:`~Condition.notify_all` "
"methods don't release the lock; this means that the thread or threads "
"awakened will not return from their :meth:`~Condition.wait` call "
"immediately, but only when the thread that called :meth:`~Condition.notify` "
"or :meth:`~Condition.notify_all` finally relinquishes ownership of the lock."
msgstr ""
"Nota: Los métodos :meth:`~Condition.notify` y :meth:`~Condition.notify_all` "
"no liberan el *lock*; esto significa que el hilo o los hilos que han sido "
"despertados no retornaran de su llamada de :meth:`~Condition.wait` "
"inmediatamente, sino solo una vez que el hilo que haya llamado a :meth:"
"`~Condition.notify` o :meth:`~Condition.notify_all` renuncie finalmente a la "
"propiedad del *lock*."

#: ../Doc/library/threading.rst:694
msgid ""
"The typical programming style using condition variables uses the lock to "
"synchronize access to some shared state; threads that are interested in a "
"particular change of state call :meth:`~Condition.wait` repeatedly until "
"they see the desired state, while threads that modify the state call :meth:"
"`~Condition.notify` or :meth:`~Condition.notify_all` when they change the "
"state in such a way that it could possibly be a desired state for one of the "
"waiters.  For example, the following code is a generic producer-consumer "
"situation with unlimited buffer capacity::"
msgstr ""
"El estilo típico de programación con variables condicionales utiliza el "
"*lock* para sincronizar el acceso a algún estado compartido; hilos que estén "
"interesados en un cambio de estado en particular llamarán a :meth:"
"`~Condition.wait` reiteradamente hasta que vean el estado deseado, mientras "
"que los hilos que modifiquen el estado llamarán a :meth:`~Condition.notify` "
"o a :meth:`~Condition.notify_all` cuando cambien el estado de modo que "
"pudiera ser que el el estado sea el deseado por alguno de los hilos en "
"espera. Por ejemplo, el siguiente código es una situación genérica de "
"productor-consumidor con capacidad de búfer ilimitada::"

#: ../Doc/library/threading.rst:714
msgid ""
"The ``while`` loop checking for the application's condition is necessary "
"because :meth:`~Condition.wait` can return after an arbitrary long time, and "
"the condition which prompted the :meth:`~Condition.notify` call may no "
"longer hold true.  This is inherent to multi-threaded programming.  The :"
"meth:`~Condition.wait_for` method can be used to automate the condition "
"checking, and eases the computation of timeouts::"
msgstr ""
"El bucle ``while`` que verifica la condición de la aplicación es necesario "
"porque :meth:`~Condition.wait` puede retornar después de una cantidad "
"arbitraria de tiempo, y la condición que dio pie a la llamada de :meth:"
"`~Condition.notify` puede ya no ser verdadera. Esto es inherente a la "
"programación multi-hilo. El método :meth:`~Condition.wait_for` puede usarse "
"para automatizar la revisión de condiciones, y facilita la computación de "
"tiempos de espera::"

#: ../Doc/library/threading.rst:726
msgid ""
"To choose between :meth:`~Condition.notify` and :meth:`~Condition."
"notify_all`, consider whether one state change can be interesting for only "
"one or several waiting threads.  E.g. in a typical producer-consumer "
"situation, adding one item to the buffer only needs to wake up one consumer "
"thread."
msgstr ""
"Para elegir entre :meth:`~Condition.notify` y :meth:`~Condition.notify_all`, "
"considérese si un cambio de estado puede ser interesante para uno o varios "
"hilos en espera. Por ejemplo en una típica situación productor-consumidor, "
"agregar un elemento al búfer sólo necesita despertar un hilo consumidor."

#: ../Doc/library/threading.rst:734
msgid ""
"This class implements condition variable objects.  A condition variable "
"allows one or more threads to wait until they are notified by another thread."
msgstr ""
"Esta clase implementa objetos de condición variable. Una condición variable "
"permite que uno o más hilos esperen hasta que sean notificados por otro hilo."

#: ../Doc/library/threading.rst:737
msgid ""
"If the *lock* argument is given and not ``None``, it must be a :class:`Lock` "
"or :class:`RLock` object, and it is used as the underlying lock.  Otherwise, "
"a new :class:`RLock` object is created and used as the underlying lock."
msgstr ""
"Si se provee un argumento *lock* distinto de ``None``, debe ser un objeto :"
"class:`Lock` o :class:`RLock`, y se utiliza como el *lock* subyacente. De "
"otro modo, se crea un nuevo objeto :class:`RLock` y se utiliza como el "
"*lock* subyacente."

#: ../Doc/library/threading.rst:741 ../Doc/library/threading.rst:865
#: ../Doc/library/threading.rst:911 ../Doc/library/threading.rst:963
#: ../Doc/library/threading.rst:1034
msgid "changed from a factory function to a class."
msgstr "cambiado de función de fábrica a una clase."

#: ../Doc/library/threading.rst:746
msgid ""
"Acquire the underlying lock. This method calls the corresponding method on "
"the underlying lock; the return value is whatever that method returns."
msgstr ""
"Adquiere el *lock* subyacente. Este método llama al método correspondiente "
"sobre el *lock* subyacente; el valor de retorno es lo que retorne aquel "
"método."

#: ../Doc/library/threading.rst:751
msgid ""
"Release the underlying lock. This method calls the corresponding method on "
"the underlying lock; there is no return value."
msgstr ""
"Libera el *lock* subyacente. Este método llama al método correspondiente en "
"el *lock* subyacente; no tiene valor de retorno."

#: ../Doc/library/threading.rst:756
msgid ""
"Wait until notified or until a timeout occurs. If the calling thread has not "
"acquired the lock when this method is called, a :exc:`RuntimeError` is "
"raised."
msgstr ""
"Espera hasta ser notificado o hasta que el tiempo de espera caduque. Si el "
"hilo invocador no ha adquirido el *lock* cuando este método es llamado, se "
"lanza un :exc:`RuntimeError`."

#: ../Doc/library/threading.rst:760
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call for the same "
"condition variable in another thread, or until the optional timeout occurs.  "
"Once awakened or timed out, it re-acquires the lock and returns."
msgstr ""
"Este método libera el *lock* subyacente, y luego bloquea hasta ser "
"despertado por una llamada a :meth:`notify` o :meth:`notify_all` para la "
"misma condición variable en otro hilo, o hasta que el tiempo de espera "
"opcional se cumpla. Una vez que ha sido despertado o el tiempo de espera ha "
"pasado, re-adquiere el *lock* y retorna."

#: ../Doc/library/threading.rst:765
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr ""
"Cuando haya un argumento *timeout* presente y no sea ``None``, debe ser un "
"número de punto flotante que especifique un tiempo de espera para la "
"operación en segundos (o fracciones de segundo)."

#: ../Doc/library/threading.rst:769
msgid ""
"When the underlying lock is an :class:`RLock`, it is not released using its :"
"meth:`release` method, since this may not actually unlock the lock when it "
"was acquired multiple times recursively.  Instead, an internal interface of "
"the :class:`RLock` class is used, which really unlocks it even when it has "
"been recursively acquired several times. Another internal interface is then "
"used to restore the recursion level when the lock is reacquired."
msgstr ""
"Cuando el *lock* subyacente es un  :class:`RLock`, no se libera utilizando "
"su método :meth:`release`, ya que esto podría no abrir realmente el *lock* "
"cuando haya sido adquirido múltiples veces recursivamente. En cambio, se usa "
"una interfaz interna de la clase :class:`RLock`, que lo abre realmente "
"incluso cuando haya sido adquirido múltiples veces recursivamente. Otra "
"interfaz interna se usa luego para restablecer el nivel de recursividad "
"cuando el *lock* es readquirido."

#: ../Doc/library/threading.rst:777
msgid ""
"The return value is ``True`` unless a given *timeout* expired, in which case "
"it is ``False``."
msgstr ""
"El valor de retorno es ``True`` a menos que un *timeout* dado haya expirado, "
"en cuyo caso será ``False``."

#: ../Doc/library/threading.rst:780 ../Doc/library/threading.rst:999
msgid "Previously, the method always returned ``None``."
msgstr "Previamente, el método siempre retornaba ``None``."

#: ../Doc/library/threading.rst:785
msgid ""
"Wait until a condition evaluates to true.  *predicate* should be a callable "
"which result will be interpreted as a boolean value. A *timeout* may be "
"provided giving the maximum time to wait."
msgstr ""
"Espera a que una condición se evalúe como verdadera. *predicate* debe ser un "
"invocable cuyo resultado se interpretará como un valor booleano. Se puede "
"proveer un *timeout* que especifique el máximo tiempo de espera."

#: ../Doc/library/threading.rst:789
msgid ""
"This utility method may call :meth:`wait` repeatedly until the predicate is "
"satisfied, or until a timeout occurs. The return value is the last return "
"value of the predicate and will evaluate to ``False`` if the method timed "
"out."
msgstr ""
"Este método utilitario puede llamar a :meth:`wait` reiteradas veces hasta "
"que se satisfaga el predicado, o hasta que la espera caduque. El valor de "
"retorno es el último valor de retorno del predicado y se evaluará a "
"``False`` si el método ha caducado."

#: ../Doc/library/threading.rst:794
msgid ""
"Ignoring the timeout feature, calling this method is roughly equivalent to "
"writing::"
msgstr ""
"Al ignorar la propiedad *feature*, llamar a este método equivale vagamente a "
"escribir::"

#: ../Doc/library/threading.rst:800
msgid ""
"Therefore, the same rules apply as with :meth:`wait`: The lock must be held "
"when called and is re-acquired on return.  The predicate is evaluated with "
"the lock held."
msgstr ""
"Por ende, aplican las mismas reglas que con :meth:`wait`: El *lock* debe ser "
"conservado cuando se llame y es re-adquirido al momento del retorno. El "
"predicado se evalúa con el *lock* conservado."

#: ../Doc/library/threading.rst:808
msgid ""
"By default, wake up one thread waiting on this condition, if any.  If the "
"calling thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""
"Por defecto, despierta a un hilo que esté esperando por esta condición, si "
"lo existe. Si el hilo llamador no ha adquirido el *lock* cuando se llama "
"este método, se lanza un :exc:`RuntimeError`."

#: ../Doc/library/threading.rst:812
msgid ""
"This method wakes up at most *n* of the threads waiting for the condition "
"variable; it is a no-op if no threads are waiting."
msgstr ""
"Este método despierta como máximo *n* de los hilos que estén esperando por "
"la condición variable; no es una opción si no hay hilos esperando."

#: ../Doc/library/threading.rst:815
msgid ""
"The current implementation wakes up exactly *n* threads, if at least *n* "
"threads are waiting.  However, it's not safe to rely on this behavior. A "
"future, optimized implementation may occasionally wake up more than *n* "
"threads."
msgstr ""
"La implementación actual despierta exactamente *n* hilos, si hay por lo "
"menos *n* hilos esperando. Sin embargo, no es seguro apoyarse en este "
"comportamiento. A futuro, una implementación optimizada podría "
"ocasionalmente despertar a más de *n* hilos."

#: ../Doc/library/threading.rst:820
msgid ""
"Note: an awakened thread does not actually return from its :meth:`wait` call "
"until it can reacquire the lock.  Since :meth:`notify` does not release the "
"lock, its caller should."
msgstr ""
"Nota: un hilo que ha sido despertado no retorna realmente de su llamada a :"
"meth:`wait` hasta que pueda readquirir el *lock*. Ya que :meth:`notify` no "
"libera el *lock*, su llamador debiera hacerlo."

#: ../Doc/library/threading.rst:826
msgid ""
"Wake up all threads waiting on this condition.  This method acts like :meth:"
"`notify`, but wakes up all waiting threads instead of one. If the calling "
"thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""
"Despierta a todos los hilos que esperen por esta condición. Este método "
"actúa como :meth:`notify`, pero despierta a todos los hilos en espera en vez "
"de a uno. Si el hilo llamador no ha adquirido el *lock* cuando se llama a "
"este método, se lanza un :exc:`RuntimeError`."

#: ../Doc/library/threading.rst:831
msgid "The method ``notifyAll`` is a deprecated alias for this method."
msgstr "El método ``notifyAll`` es un alias obsoleto para este método."

#: ../Doc/library/threading.rst:837
msgid "Semaphore Objects"
msgstr "Objetos semáforo"

#: ../Doc/library/threading.rst:839
msgid ""
"This is one of the oldest synchronization primitives in the history of "
"computer science, invented by the early Dutch computer scientist Edsger W. "
"Dijkstra (he used the names ``P()`` and ``V()`` instead of :meth:`~Semaphore."
"acquire` and :meth:`~Semaphore.release`)."
msgstr ""
"Éste es uno de las primitivas de sincronización más antiguos en la historia "
"de las ciencias de la computación, inventado por el pionero en ciencias de "
"la computación holandés Edsger W. Dijkstra (él utilizó los nombres ``P()`` y "
"``V()`` en lugar de :meth:`~Semaphore.acquire` y :meth:`~Semaphore.release`)"

#: ../Doc/library/threading.rst:844
msgid ""
"A semaphore manages an internal counter which is decremented by each :meth:"
"`~Semaphore.acquire` call and incremented by each :meth:`~Semaphore.release` "
"call.  The counter can never go below zero; when :meth:`~Semaphore.acquire` "
"finds that it is zero, it blocks, waiting until some other thread calls :"
"meth:`~Semaphore.release`."
msgstr ""
"Un semáforo administra un contador interno que se disminuye por cada llamada "
"a :meth:`~Semaphore.acquire` y se incrementa por cada llamada a :meth:"
"`~Semaphore.release`. El contador no puede bajar de cero; cuando :meth:"
"`~Semaphore.acquire` lo encuentra en cero, bloquea, esperando hasta que otro "
"hilo llame :meth:`~Semaphore.release`."

#: ../Doc/library/threading.rst:850
msgid ""
"Semaphores also support the :ref:`context management protocol <with-locks>`."
msgstr ""
"Los semáforos también tienen soporte para el :ref:`protocolo de gestión de "
"contexto <with-locks>`."

#: ../Doc/library/threading.rst:855
msgid ""
"This class implements semaphore objects.  A semaphore manages an atomic "
"counter representing the number of :meth:`release` calls minus the number "
"of :meth:`acquire` calls, plus an initial value.  The :meth:`acquire` method "
"blocks if necessary until it can return without making the counter negative. "
"If not given, *value* defaults to 1."
msgstr ""
"Esta clase implementa los objetos semáforo. Un semáforo gestiona un contador "
"atómico que representa el número de llamadas a :meth:`release` menos el "
"número de llamadas a :meth:`acquire`, más un valor inicial. El método :meth:"
"`acquire` bloquea si es necesario, hasta que pueda retornar sin volver el "
"contador negativo. Si no es provisto, el valor por defecto de *value* será 1."

#: ../Doc/library/threading.rst:861
msgid ""
"The optional argument gives the initial *value* for the internal counter; it "
"defaults to ``1``. If the *value* given is less than 0, :exc:`ValueError` is "
"raised."
msgstr ""
"El argumento opcional da el *value* inicial al contador interno; por defecto "
"es ``1``. Si el *value* provisto es menor a 0; se lanza un :exc:`ValueError`."

#: ../Doc/library/threading.rst:870
msgid "Acquire a semaphore."
msgstr "Adquirir un semáforo."

#: ../Doc/library/threading.rst:872
msgid "When invoked without arguments:"
msgstr "Cuando se invoca sin argumentos:"

#: ../Doc/library/threading.rst:874
msgid ""
"If the internal counter is larger than zero on entry, decrement it by one "
"and return ``True`` immediately."
msgstr ""
"Si el contador interno es mayor a cero de entrada, lo disminuye en uno y "
"retorna ``True`` inmediatamente."

#: ../Doc/library/threading.rst:876
msgid ""
"If the internal counter is zero on entry, block until awoken by a call to :"
"meth:`~Semaphore.release`.  Once awoken (and the counter is greater than 0), "
"decrement the counter by 1 and return ``True``.  Exactly one thread will be "
"awoken by each call to :meth:`~Semaphore.release`.  The order in which "
"threads are awoken should not be relied on."
msgstr ""
"Si el contador interno es cero de entrada, bloquea hasta ser despertado por "
"una llamada a :meth:`~Semaphore.release`. Una vez despierto (y el contador "
"sea mayor a 0), disminuye el contador en 1 y retorna ``True``. Se despertará "
"exactamente un hilo por cada llamada a :meth:`~Semaphore.release`. No "
"debiese confiarse en el orden en que los hilos sean despertados."

#: ../Doc/library/threading.rst:882
msgid ""
"When invoked with *blocking* set to ``False``, do not block.  If a call "
"without an argument would block, return ``False`` immediately; otherwise, do "
"the same thing as when called without arguments, and return ``True``."
msgstr ""
"Cuando se invoca con *blocking* fijado en ``False``, no bloquea. Si una "
"llamada sin un argumento bloquease, retorna ``False`` inmediatamente; de "
"otro modo, hace lo mismo que cuando se llama sin argumentos, y retorna "
"``True``."

#: ../Doc/library/threading.rst:886
msgid ""
"When invoked with a *timeout* other than ``None``, it will block for at most "
"*timeout* seconds.  If acquire does not complete successfully in that "
"interval, return ``False``.  Return ``True`` otherwise."
msgstr ""
"Cuando se invoca con *timeout* distinto de ``None``, bloqueará por un tiempo "
"máximo en segundos fijados en *timeout*. Si *acquire* no se completa "
"exitosamente en ese intervalo, retorna ``False``. De otro modo retorna "
"``True``."

#: ../Doc/library/threading.rst:895
msgid ""
"Release a semaphore, incrementing the internal counter by *n*.  When it was "
"zero on entry and other threads are waiting for it to become larger than "
"zero again, wake up *n* of those threads."
msgstr ""
"Suelta un semáforo, incrementando el contador interno por *n*. Cuando era "
"cero en la entrada y otros subprocesos están esperando que vuelva a ser "
"mayor que cero, active *n* de esos subprocesos."

#: ../Doc/library/threading.rst:899
msgid "Added the *n* parameter to release multiple waiting threads at once."
msgstr ""
"Se agregó el parámetro *n* para liberar varios subprocesos en espera a la "
"vez."

#: ../Doc/library/threading.rst:905
msgid ""
"Class implementing bounded semaphore objects.  A bounded semaphore checks to "
"make sure its current value doesn't exceed its initial value.  If it does, :"
"exc:`ValueError` is raised. In most situations semaphores are used to guard "
"resources with limited capacity.  If the semaphore is released too many "
"times it's a sign of a bug.  If not given, *value* defaults to 1."
msgstr ""
"Clase que implementa objetos de semáforo delimitados. Un semáforo delimitado "
"verifica que su valor actual no exceda su valor inicial. Si lo hace, se "
"lanza un :exc:`ValueError`. En la mayoría de las situaciones se utilizan los "
"semáforos para cuidar recursos con capacidad limitada. Si se libera el "
"semáforo demasiadas veces es signo de un *bug*. Si no se provee, el valor "
"por defecto de *value* será 1."

#: ../Doc/library/threading.rst:918
msgid ":class:`Semaphore` Example"
msgstr "Ejemplo de :class:`Semaphore`"

#: ../Doc/library/threading.rst:920
msgid ""
"Semaphores are often used to guard resources with limited capacity, for "
"example, a database server.  In any situation where the size of the resource "
"is fixed, you should use a bounded semaphore.  Before spawning any worker "
"threads, your main thread would initialize the semaphore::"
msgstr ""
"Los semáforos suelen utilizarse para cuidar recursos con capacidad limitada, "
"por ejemplo, un servidor de base de datos. En cualquier situación en que el "
"tamaño de los recursos sea fijo, se debe usar un semáforo delimitado. Antes "
"de generar cualquier hilo de trabajo, tu hilo principal debe inicializar el "
"semáforo::"

#: ../Doc/library/threading.rst:929
msgid ""
"Once spawned, worker threads call the semaphore's acquire and release "
"methods when they need to connect to the server::"
msgstr ""
"Una vez que han sido generados, los hilos de trabajo llaman a los métodos "
"*acquire* y *release* cuando necesitan conectarse al servidor::"

#: ../Doc/library/threading.rst:939
msgid ""
"The use of a bounded semaphore reduces the chance that a programming error "
"which causes the semaphore to be released more than it's acquired will go "
"undetected."
msgstr ""
"El uso de semáforos delimitados reduce la posibilidad de que pase "
"inadvertido un error de programación que cause que el semáforo sea liberado "
"más veces de las que sea adquirido."

#: ../Doc/library/threading.rst:946
msgid "Event Objects"
msgstr "Objetos de eventos"

#: ../Doc/library/threading.rst:948
msgid ""
"This is one of the simplest mechanisms for communication between threads: "
"one thread signals an event and other threads wait for it."
msgstr ""
"Éste es uno de los mecanismos más simples de comunicación entre hilos: un "
"hilo señala un evento y otro hilo lo espera."

#: ../Doc/library/threading.rst:951
msgid ""
"An event object manages an internal flag that can be set to true with the :"
"meth:`~Event.set` method and reset to false with the :meth:`~Event.clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is true."
msgstr ""
"Un objeto de evento maneja una marca interna que puede ser establecida como "
"verdadera mediante el método :meth:`~Event.set` y restablecida a falsa "
"mediante el método :meth:`~Meth.clear`. El método :meth:`~Meth.wait` bloquea "
"hasta que la marca sea *true*."

#: ../Doc/library/threading.rst:958
msgid ""
"Class implementing event objects.  An event manages a flag that can be set "
"to true with the :meth:`~Event.set` method and reset to false with the :meth:"
"`clear` method.  The :meth:`wait` method blocks until the flag is true. The "
"flag is initially false."
msgstr ""
"Clase que implementa los objetos de evento. Un evento gestiona un indicador "
"que puede ser establecido a verdadero mediante el método :meth:`~Event.set` "
"y restablecido a falso con el método :meth:`clear`. El método :meth:`wait` "
"bloquea hasta que el indicador sea verdadero. El indicador es inicialmente "
"falso."

#: ../Doc/library/threading.rst:968
msgid "Return ``True`` if and only if the internal flag is true."
msgstr "Retorna ``True`` exclusivamente si el indicador interno es verdadero."

#: ../Doc/library/threading.rst:970
msgid "The method ``isSet`` is a deprecated alias for this method."
msgstr "El método ``isSet`` es un alias obsoleto para este método."

#: ../Doc/library/threading.rst:974
msgid ""
"Set the internal flag to true. All threads waiting for it to become true are "
"awakened. Threads that call :meth:`wait` once the flag is true will not "
"block at all."
msgstr ""
"Establece el indicador interno a verdadero. Todos los hilos que estén "
"esperando que se vuelva verdadero serán despertados. Los hilos que llaman a :"
"meth:`wait` una vez que el indicador marca verdadero no bloquearán."

#: ../Doc/library/threading.rst:980
msgid ""
"Reset the internal flag to false. Subsequently, threads calling :meth:`wait` "
"will block until :meth:`.set` is called to set the internal flag to true "
"again."
msgstr ""
"Restablece el indicador a falso. Posteriormente, los hilos que llamen a :"
"meth:`wait` bloquearán hasta que se llame a :meth:`set` para establecer el "
"indicador interno a verdadero nuevamente."

#: ../Doc/library/threading.rst:986
msgid ""
"Block until the internal flag is true.  If the internal flag is true on "
"entry, return immediately.  Otherwise, block until another thread calls :"
"meth:`.set` to set the flag to true, or until the optional timeout occurs."
msgstr ""
"Bloquea hasta que el indicador interno sea verdadero. Si el indicador "
"interno es verdadero de entrada, retorna inmediatamente. De otro modo, "
"bloquea hasta que otro hilo llame a :meth:`.set` para establecer el "
"indicador a verdadero, o hasta que el tiempo de espera opcional caduque."

#: ../Doc/library/threading.rst:990
msgid ""
"When the timeout argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr ""
"Cuando se presenta un argumento para el tiempo de espera *timeout* distinto "
"de ``None``, debe ser un número de punto flotante que especifique un tiempo "
"de espera para la operación en segundos (o fracciones en su defecto)."

#: ../Doc/library/threading.rst:994
msgid ""
"This method returns ``True`` if and only if the internal flag has been set "
"to true, either before the wait call or after the wait starts, so it will "
"always return ``True`` except if a timeout is given and the operation times "
"out."
msgstr ""
"Este método retorna ``True`` exclusivamente si el indicador interno ha sido "
"establecido a verdadero, ya sea antes de la llamada a la espera o después de "
"que la espera inicie, por lo que siempre retorna ``True`` excepto si se "
"provee un tiempo de espera máximo y la operación caduca."

#: ../Doc/library/threading.rst:1006
msgid "Timer Objects"
msgstr "Objetos temporizadores"

#: ../Doc/library/threading.rst:1008
msgid ""
"This class represents an action that should be run only after a certain "
"amount of time has passed --- a timer.  :class:`Timer` is a subclass of :"
"class:`Thread` and as such also functions as an example of creating custom "
"threads."
msgstr ""
"Esta clase representa una acción que sólo debe ejecutarse luego de que una "
"cierta cantidad de tiempo transcurra --- un temporizador. :class:`Timer` es "
"una subclase de :class:`Thread` y en tanto tal también funciona como un "
"ejemplo de creación de hilos personalizados."

#: ../Doc/library/threading.rst:1012
msgid ""
"Timers are started, as with threads, by calling their :meth:`Timer.start "
"<Thread.start>` method.  The timer can be stopped (before its action has "
"begun) by calling the :meth:`~Timer.cancel` method.  The interval the timer "
"will wait before executing its action may not be exactly the same as the "
"interval specified by the user."
msgstr ""
"Los temporizadores son iniciados, tal como los hilos, al llamarse su método :"
"meth:`Timer.start <Thread.start>`. El temporizador puede ser detenido (antes "
"de que su acción haya comenzado) al llamar al método :meth:`~Timer.cancel`. "
"El intervalo que el temporizador esperará antes de ejecutar su acción puede "
"no ser exactamente el mismo que el intervalo especificado por el usuario."

#: ../Doc/library/threading.rst:1018
msgid "For example::"
msgstr "Por ejemplo:"

#: ../Doc/library/threading.rst:1029
msgid ""
"Create a timer that will run *function* with arguments *args* and  keyword "
"arguments *kwargs*, after *interval* seconds have passed. If *args* is "
"``None`` (the default) then an empty list will be used. If *kwargs* is "
"``None`` (the default) then an empty dict will be used."
msgstr ""
"Crear un temporizador que ejecutará *function* con los argumentos *args* y "
"los argumentos de palabra clave *kwargs*, luego de que una cantidad "
"*interval* de segundos hayan transcurrido. Si *args* es ``None`` (por "
"defecto) se utilizará una lista vacía. Si *kwargs* es ``None`` (por defecto) "
"se utilizará un *dict* vacío."

#: ../Doc/library/threading.rst:1039
msgid ""
"Stop the timer, and cancel the execution of the timer's action.  This will "
"only work if the timer is still in its waiting stage."
msgstr ""
"Detiene el temporizador, y cancela la ejecución de la acción del "
"temporizador. Esto sólo funcionará si el temporizador está en etapa de "
"espera."

#: ../Doc/library/threading.rst:1044
msgid "Barrier Objects"
msgstr "Objetos de barrera"

#: ../Doc/library/threading.rst:1048
msgid ""
"This class provides a simple synchronization primitive for use by a fixed "
"number of threads that need to wait for each other.  Each of the threads "
"tries to pass the barrier by calling the :meth:`~Barrier.wait` method and "
"will block until all of the threads have made their :meth:`~Barrier.wait` "
"calls. At this point, the threads are released simultaneously."
msgstr ""
"Esta clase provee una primitiva de sincronización simple para ser usado por "
"un número fijo de hilos que necesitan esperarse entre ellos. Cada uno de los "
"hilos intenta pasar la barrera llamando al método :meth:`~Barrier.wait` y "
"bloqueará hasta que todos los hilos hayan hecho sus respectivas llamadas a :"
"meth:`~Barrier.wait`. En este punto, los hilos son liberados simultáneamente."

#: ../Doc/library/threading.rst:1054
msgid ""
"The barrier can be reused any number of times for the same number of threads."
msgstr ""
"La barrera puede ser reutilizada cualquier número de veces para el mismo "
"número de hilos."

#: ../Doc/library/threading.rst:1056
msgid ""
"As an example, here is a simple way to synchronize a client and server "
"thread::"
msgstr ""
"Como ejemplo, aquí hay una manera simple de sincronizar un hilo cliente con "
"uno servidor::"

#: ../Doc/library/threading.rst:1076
msgid ""
"Create a barrier object for *parties* number of threads.  An *action*, when "
"provided, is a callable to be called by one of the threads when they are "
"released.  *timeout* is the default timeout value if none is specified for "
"the :meth:`wait` method."
msgstr ""
"Crear un objeto de barrera para un número *parties* de hilos. Una *action*, "
"si es provista, es un invocable a ser llamado por uno de los hilos cuando "
"sean liberados. *timeout* es el valor de tiempo de espera máximo por defecto "
"si no se especifica uno en el método :meth:`wait`."

#: ../Doc/library/threading.rst:1083
msgid ""
"Pass the barrier.  When all the threads party to the barrier have called "
"this function, they are all released simultaneously.  If a *timeout* is "
"provided, it is used in preference to any that was supplied to the class "
"constructor."
msgstr ""
"Pasa la barrera. Cuando todos los hilos involucrados en el objeto barrera "
"han llamado esta función, se liberan todos simultáneamente. Si se provee un "
"valor *timeout*, se utilizará con preferencia sobre cualquiera que haya sido "
"suministrado al constructor de la clase."

#: ../Doc/library/threading.rst:1088
msgid ""
"The return value is an integer in the range 0 to *parties* -- 1, different "
"for each thread.  This can be used to select a thread to do some special "
"housekeeping, e.g.::"
msgstr ""
"El valor de retorno es un entero en el rango desde 0 hasta *parties* -- 1, "
"diferente para cada hilo. Puede ser utilizado para seleccionar a un hilo "
"para que haga alguna limpieza especial, por ejemplo::"

#: ../Doc/library/threading.rst:1097
msgid ""
"If an *action* was provided to the constructor, one of the threads will have "
"called it prior to being released.  Should this call raise an error, the "
"barrier is put into the broken state."
msgstr ""
"Se se provee una *action* al constructor, uno de los hilos la habrá llamado "
"antes de ser liberado. Si acaso esta llamada lanzara un error, la barrera "
"entra en estado *broken* (roto)."

#: ../Doc/library/threading.rst:1101
msgid "If the call times out, the barrier is put into the broken state."
msgstr "Si se agota el tiempo de llamada, la barrera pasa al estado roto."

#: ../Doc/library/threading.rst:1103
msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier "
"is broken or reset while a thread is waiting."
msgstr ""
"Este método podría lanzar una excepción :class:`BrokenBarrierError` si la "
"barrera está rota o si se reinicia mientras el hilo está esperando."

#: ../Doc/library/threading.rst:1108
msgid ""
"Return the barrier to the default, empty state.  Any threads waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr ""
"Retorna la barrera al estado por defecto, vacío. Cualquier hilo que esté a "
"su espera recibirá la excepción :class:`BrokenBarrierError`."

#: ../Doc/library/threading.rst:1111
msgid ""
"Note that using this function may require some external synchronization if "
"there are other threads whose state is unknown.  If a barrier is broken it "
"may be better to just leave it and create a new one."
msgstr ""
"Nótese que utilizar esta función podría requerir alguna sincronización "
"externa si existen otros hilos cuyos estados sean desconocidos. Si una "
"barrera se rompe puede ser mejor abandonarla y crear una nueva."

#: ../Doc/library/threading.rst:1117
msgid ""
"Put the barrier into a broken state.  This causes any active or future calls "
"to :meth:`wait` to fail with the :class:`BrokenBarrierError`.  Use this for "
"example if one of the threads needs to abort, to avoid deadlocking the "
"application."
msgstr ""
"Coloca la barrera en estado roto. Esto causa que cualquier llamada activa o "
"futura a :meth:`wait` falle con el error :class:`BrokenBarrierError`. Úsese "
"por ejemplo si uno de los hilos necesita abortar, para evitar que la "
"aplicación quede en punto muerto."

#: ../Doc/library/threading.rst:1122
msgid ""
"It may be preferable to simply create the barrier with a sensible *timeout* "
"value to automatically guard against one of the threads going awry."
msgstr ""
"Puede ser preferible simplemente crear la barrera con un valor *timeout* "
"sensato para cuidarse automáticamente de que uno de los hilos falle."

#: ../Doc/library/threading.rst:1128
msgid "The number of threads required to pass the barrier."
msgstr "El número de hilos requeridos para pasar la barrera."

#: ../Doc/library/threading.rst:1132
msgid "The number of threads currently waiting in the barrier."
msgstr "El número de hilos actualmente esperando en la barrera."

#: ../Doc/library/threading.rst:1136
msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr ""
"Un valor booleano que será ``True`` si la barrera está en el estado roto."

#: ../Doc/library/threading.rst:1141
msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the :class:"
"`Barrier` object is reset or broken."
msgstr ""
"Esta excepción, una subclase de :exc:`RuntimeError`, se lanza cuando el "
"objeto :class:`Barrier` se restablece o se rompe."

#: ../Doc/library/threading.rst:1148
msgid ""
"Using locks, conditions, and semaphores in the :keyword:`!with` statement"
msgstr ""
"Uso de *locks*, condiciones y semáforos en la declaración :keyword:`!with`"

#: ../Doc/library/threading.rst:1150
msgid ""
"All of the objects provided by this module that have ``acquire`` and "
"``release`` methods can be used as context managers for a :keyword:`with` "
"statement.  The ``acquire`` method will be called when the block is entered, "
"and ``release`` will be called when the block is exited.  Hence, the "
"following snippet::"
msgstr ""
"Todos los objetos provistos por este módulo que tienen métodos ``acquire`` y "
"``release`` pueden ser utilizados como administradores de contexto para una "
"declaración :keyword:`with`. El método ``acquire`` será llamado cuando se "
"ingresa al bloque y el método ``release`` será llamado cuando se abandona el "
"bloque. De ahí que, el siguiente fragmento::"

#: ../Doc/library/threading.rst:1159
msgid "is equivalent to::"
msgstr "sea equivalente a::"

#: ../Doc/library/threading.rst:1167
msgid ""
"Currently, :class:`Lock`, :class:`RLock`, :class:`Condition`, :class:"
"`Semaphore`, and :class:`BoundedSemaphore` objects may be used as :keyword:"
"`with` statement context managers."
msgstr ""
"Actualmente, los objetos :class:`Lock`, :class:`RLock`, :class:`Condition`, :"
"class:`Semaphore`, y :class:`BoundedSemaphore` pueden ser utilizados como "
"gestores de contexto con declaraciones :keyword:`with`."

#: ../Doc/library/threading.rst:155 ../Doc/library/threading.rst:173
msgid "trace function"
msgstr "trace function"

#: ../Doc/library/threading.rst:173
msgid "debugger"
msgstr "debugger"

#: ../Doc/library/threading.rst:184 ../Doc/library/threading.rst:202
msgid "profile function"
msgstr "profile function"

#~ msgid ""
#~ ":ref:`Availability <availability>`: Windows, FreeBSD, Linux, macOS, "
#~ "OpenBSD, NetBSD, AIX."
#~ msgstr ""
#~ ":ref:`Disponibilidad <availability>`: Windows, FreeBSD, Linux, macOS, "
#~ "OpenBSD, NetBSD, AIX."
