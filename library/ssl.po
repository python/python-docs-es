# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-03-19 11:16+0100\n"
"PO-Revision-Date: 2021-04-21 17:44+0200\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: Marcos Medrano <marcosmedrano0@gmail.com>\n"
"Language: es\n"
"X-Generator: Poedit 2.4.2\n"
"X-Poedit-Basepath: .\n"

# En el resto del documento, utilizo los términos en inglés "socket" (utilizado comunmente en español) y "wrapper" (que podría traducirse "envoltura" pero me parece mucho mas claro en inglés).
#: ../Doc/library/ssl.rst:2
msgid ":mod:`ssl` --- TLS/SSL wrapper for socket objects"
msgstr ":mod:`ssl` --- TLS/SSL wrapper para objetos socket"

#: ../Doc/library/ssl.rst:10
msgid "**Source code:** :source:`Lib/ssl.py`"
msgstr "**Código fuente:** :source:'Lib/ssl.py'"

#: ../Doc/library/ssl.rst:18
msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities for "
"network sockets, both client-side and server-side.  This module uses the "
"OpenSSL library. It is available on all modern Unix systems, Windows, Mac OS "
"X, and probably additional platforms, as long as OpenSSL is installed on "
"that platform."
msgstr ""
"Este módulo provee acceso al cifrado de la Seguridad de la capa de "
"transporte (conocida también como \"Secure Sockets Layer\") y a facilidades "
"de autenticación para sockets de red, tanto para el lado del cliente como "
"para el lado del servidor. Este módulo utiliza la biblioteca OpenSSL. Está "
"disponible en todos los sistemas Unix modernos, Windows, Max OS X, y "
"probablemente en plataformas adicionales, siempre y cuando OpenSSL esté "
"instalada en esa plataforma."

# El último "openssl" debería escribirse "OpenSSL" por cohérencia con el resto de la documentación. Lo dejo en minúsculas porque así está la documentación en inglés.
#: ../Doc/library/ssl.rst:26
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior. For example, TLSv1.1 and TLSv1.2 come with "
"openssl version 1.0.1."
msgstr ""
"Algunos comportamientos pueden depender de la plataforma, dado que las "
"llamadas se realizan a las API de socket del sistema operativo. La versión "
"de OpenSSL instalada puede también causar variaciones en el comportamiento. "
"Por ejemplo, TLSv1.1 y TLSv1.2 vienen con la versión 1.0.1 de openssl."

#: ../Doc/library/ssl.rst:32
msgid ""
"Don't use this module without reading the :ref:`ssl-security`.  Doing so may "
"lead to a false sense of security, as the default settings of the ssl module "
"are not necessarily appropriate for your application."
msgstr ""
"No utilice este módulo sin leer :ref:`ssl-security`. Hacerlo puede dar lugar "
"a una falsa sensación de seguridad ya que los ajustes por defecto del módulo "
"ssl no son necesariamente adecuados para su aplicación."

#: ../Doc/library/ssl.rst:37
msgid ""
"This section documents the objects and functions in the ``ssl`` module; for "
"more general information about TLS, SSL, and certificates, the reader is "
"referred to the documents in the \"See Also\" section at the bottom."
msgstr ""
"Esta sección documenta los objetos y funciones del módulo ``ssl``; para "
"obtener información mas general sobre TLS, SSL, y certificados, el lector es "
"referido a los documentos de la sección \"Ver también\" en la parte inferior."

#: ../Doc/library/ssl.rst:41
msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived from "
"the :class:`socket.socket` type, and provides a socket-like wrapper that "
"also encrypts and decrypts the data going over the socket with SSL.  It "
"supports additional methods such as :meth:`getpeercert`, which retrieves the "
"certificate of the other side of the connection, and :meth:`cipher`, which "
"retrieves the cipher being used for the secure connection."
msgstr ""
"Este módulo proporciona una clase, :class:`ssl.SSLSocket`, que deriva del "
"tipo :class:`socket.socket`, y proporciona un wrapper tipo socket que "
"también cifra y descifra los datos que pasan por el socket con SSL. Soporta "
"métodos adicionales como :meth:`getpeercert`, el cual recupera el "
"certificado del otro lado de la conexión, y :meth:`cipher`, que recupera el "
"cifrado que se está utilizando para la conexión segura."

#: ../Doc/library/ssl.rst:48
msgid ""
"For more sophisticated applications, the :class:`ssl.SSLContext` class helps "
"manage settings and certificates, which can then be inherited by SSL sockets "
"created through the :meth:`SSLContext.wrap_socket` method."
msgstr ""
"Para aplicaciones mas sofisticadas, la clase :class:`ssl.SSLContext` ayuda a "
"gestionar los ajustes y los certificados, los cuales pueden luego ser "
"heredados por sockets SSL creados a través del método :meth:`SSLContext."
"wrap_socket`."

#: ../Doc/library/ssl.rst:52
msgid "Updated to support linking with OpenSSL 1.1.0"
msgstr "Actualizado para soportar enlace con OpenSSL 1.1.0"

# are deprecated -> son deprecados ?
#: ../Doc/library/ssl.rst:57
msgid ""
"OpenSSL 0.9.8, 1.0.0 and 1.0.1 are deprecated and no longer supported. In "
"the future the ssl module will require at least OpenSSL 1.0.2 or 1.1.0."
msgstr ""
"OpenSSL 0.9.8, 1.0.0 y 1.0.1 son obsoletos y no son compatibles. En el "
"futuro, el módulo ssl requerirá al menos OpenSSL 1.0.2 o 1.1.0."

#: ../Doc/library/ssl.rst:63
msgid "Functions, Constants, and Exceptions"
msgstr "Funciones, constantes y excepciones"

#: ../Doc/library/ssl.rst:67
msgid "Socket creation"
msgstr "Creación de sockets"

# el término en inglés "hostname matching" me parece mucho mas claro que cualquier traducción al español ("coincidencia de nombres de anfitrión" ?)
#: ../Doc/library/ssl.rst:69
msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the :meth:`SSLContext."
"wrap_socket` of an :class:`SSLContext` instance to wrap sockets as :class:"
"`SSLSocket` objects. The helper functions :func:`create_default_context` "
"returns a new context with secure default settings. The old :func:"
"`wrap_socket` function is deprecated since it is both inefficient and has no "
"support for server name indication (SNI) and hostname matching."
msgstr ""
"Desde Python 3.2 y 2.7.9, se recomienda utilizar :meth:`SSLContext."
"wrap_socket` de una instancia de :class:`SSLContext` para envolver sockets "
"como objetos :class:`SSLSocket`. La función utilitaria :func:"
"`create_default_context` retorna un nuevo contexto con ajustes por defecto "
"seguros. La vieja función :func:`wrap_socket` es obsoleta debido a que es "
"ineficiente y que no tiene soporte para la indicación de nombre de servidor "
"(SNI) ni hostname matching."

#: ../Doc/library/ssl.rst:77
msgid "Client socket example with default context and IPv4/IPv6 dual stack::"
msgstr ""
"Ejemplo de socket cliente con contexto por defecto y doble pila IPv4/IPv6::"

#: ../Doc/library/ssl.rst:90
msgid "Client socket example with custom context and IPv4::"
msgstr "Ejemplo de socket cliente con contexto personalizado y IPv4::"

#: ../Doc/library/ssl.rst:102
msgid "Server socket example listening on localhost IPv4::"
msgstr "Ejemplo de socket servidor escuchando en localhost IPv4::"

#: ../Doc/library/ssl.rst:116
msgid "Context creation"
msgstr "Creación de contexto"

#: ../Doc/library/ssl.rst:118
msgid ""
"A convenience function helps create :class:`SSLContext` objects for common "
"purposes."
msgstr ""
"Una función conveniente ayuda a crear objetos :class:`SSLContext` para "
"propósitos comunes."

#: ../Doc/library/ssl.rst:123
msgid ""
"Return a new :class:`SSLContext` object with default settings for the given "
"*purpose*.  The settings are chosen by the :mod:`ssl` module, and usually "
"represent a higher security level than when calling the :class:`SSLContext` "
"constructor directly."
msgstr ""
"Retorna un nuevo objeto :class:`SSLContext` con ajustes por defecto para el "
"*purpose* dado. Los ajustes son elegidos por el módulo :mod:`ssl` y "
"generalmente representan un nivel de seguridad mas alto que invocando "
"directamente el constructor de :class:`SSLContext`."

#: ../Doc/library/ssl.rst:128
msgid ""
"*cafile*, *capath*, *cadata* represent optional CA certificates to trust for "
"certificate verification, as in :meth:`SSLContext.load_verify_locations`.  "
"If all three are :const:`None`, this function can choose to trust the "
"system's default CA certificates instead."
msgstr ""
"*cafile*, *capath*, *cadata* representan certificados CA opcionales para "
"confiar en la verificación de certificados, como en :meth:`SSLContext."
"load_verify_locations`. Si los tres son :const:`None` al mismo tiempo, esta "
"función puede optar por confiar en su lugar en los certificados CA por "
"defecto del sistema."

#: ../Doc/library/ssl.rst:134
msgid ""
"The settings are: :data:`PROTOCOL_TLS`, :data:`OP_NO_SSLv2`, and :data:"
"`OP_NO_SSLv3` with high encryption cipher suites without RC4 and without "
"unauthenticated cipher suites. Passing :data:`~Purpose.SERVER_AUTH` as "
"*purpose* sets :data:`~SSLContext.verify_mode` to :data:`CERT_REQUIRED` and "
"either loads CA certificates (when at least one of *cafile*, *capath* or "
"*cadata* is given) or uses :meth:`SSLContext.load_default_certs` to load "
"default CA certificates."
msgstr ""
"Los ajustes son: :data:`PROTOCOL_TLS`, :data:`OP_NO_SSLv2` y :data:"
"`OP_NO_SSLv3` con suites de cifrado de alto nivel sin RC4 y sin suites de "
"cifrado sin autentificar. Pasar :data:`~Purpose.SERVER_AUTH` como *purpose* "
"establece :data:`~SSLContext.verify_mode` a :data:`CERT_REQUIRED` y carga "
"los certificados CA (si al menos uno de *cafile*, *capath* o *cadata* es "
"dado) o usa :meth:`SSLContext.load_default_certs` para cargar los "
"certificados CA por defecto."

#: ../Doc/library/ssl.rst:142
msgid ""
"When :attr:`~SSLContext.keylog_filename` is supported and the environment "
"variable :envvar:`SSLKEYLOGFILE` is set, :func:`create_default_context` "
"enables key logging."
msgstr ""
"Cuando :attr:`~SSLContext.keylog_filename` es soportado y la variable de "
"entorno :envvar:`SSLKEYLOGFILE` está establecida, :func:"
"`create_default_context` activa el registro de claves."

#: ../Doc/library/ssl.rst:147
msgid ""
"The protocol, options, cipher and other settings may change to more "
"restrictive values anytime without prior deprecation.  The values represent "
"a fair balance between compatibility and security."
msgstr ""
"El protocolo, las opciones, el cifrado y otros ajustes pueden cambiar a "
"valores mas restrictivos en cualquier momento sin previa obsolescencia. Los "
"valores representan un equilibrio justo entre compatibilidad y seguridad."

#: ../Doc/library/ssl.rst:151
msgid ""
"If your application needs specific settings, you should create a :class:"
"`SSLContext` and apply the settings yourself."
msgstr ""
"Si su aplicación necesita ajustes específicos, debe crear un :class:"
"`SSLContext` y aplicar los ajustes usted mismo."

# Es necesario traducir los mensajes de error ?
# ("Protocol or cipher suite mismatch")
#: ../Doc/library/ssl.rst:155
msgid ""
"If you find that when certain older clients or servers attempt to connect "
"with a :class:`SSLContext` created by this function that they get an error "
"stating \"Protocol or cipher suite mismatch\", it may be that they only "
"support SSL3.0 which this function excludes using the :data:`OP_NO_SSLv3`. "
"SSL3.0 is widely considered to be `completely broken <https://en.wikipedia."
"org/wiki/POODLE>`_. If you still wish to continue to use this function but "
"still allow SSL 3.0 connections you can re-enable them using::"
msgstr ""
"Si encuentra que cuando ciertos clientes o servidores antiguos intentan "
"conectarse con un :class:`SSLContext` creado con esta función obtienen un "
"error indicando \"Protocol or cipher suite mismatch\", puede ser que estos "
"sólo soportan SSL3.0 el cual esta función excluye utilizando :data:"
"`OP_NO_SSLv3`. SSL3.0 está ampliamente considerado como `completamente roto "
"<https://en.wikipedia.org/wiki/POODLE>`_. Si todavía desea seguir utilizando "
"esta función pero permitir conexiones SSL 3.0, puede volver a activarlas "
"mediante::"

#: ../Doc/library/ssl.rst:171
msgid "RC4 was dropped from the default cipher string."
msgstr "RC4 ha sido abandonado de la cadena de cifrado por defecto."

#: ../Doc/library/ssl.rst:175
msgid "ChaCha20/Poly1305 was added to the default cipher string."
msgstr ""
"ChaCha20/Poly1305 ha sido agregado a la cadena de caracteres de cifrado por "
"defecto."

#: ../Doc/library/ssl.rst:177
msgid "3DES was dropped from the default cipher string."
msgstr ""
"3DES ha sido abandonado de la cadena de caracteres de cifrado por defecto."

#: ../Doc/library/ssl.rst:181
msgid "Support for key logging to :envvar:`SSLKEYLOGFILE` was added."
msgstr ""
"Soporte del registro de claves en :envvar:`SSLKEYLOGFILE` ha sido agregado."

#: ../Doc/library/ssl.rst:185
msgid "Exceptions"
msgstr "Excepciones"

#: ../Doc/library/ssl.rst:189
msgid ""
"Raised to signal an error from the underlying SSL implementation (currently "
"provided by the OpenSSL library).  This signifies some problem in the higher-"
"level encryption and authentication layer that's superimposed on the "
"underlying network connection.  This error is a subtype of :exc:`OSError`.  "
"The error code and message of :exc:`SSLError` instances are provided by the "
"OpenSSL library."
msgstr ""
"Se lanza para señalar un error de la implementación de SSL subyacente "
"(actualmente proporcionada por la biblioteca OpenSSL). Esto indica algún "
"problema en la capa de cifrado y autenticación de alto nivel que se "
"superpone a la conexión de red subyacente. Este error es un subtipo de :exc:"
"`OSError`. El código de error y el mensaje de las instancias de :exc:"
"`SSLError` son proporcionados por la biblioteca OpenSSL."

#: ../Doc/library/ssl.rst:196
msgid ":exc:`SSLError` used to be a subtype of :exc:`socket.error`."
msgstr ":exc:`SSLError` era un subtipo de :exc:`socket.error`."

#: ../Doc/library/ssl.rst:201
msgid ""
"A string mnemonic designating the OpenSSL submodule in which the error "
"occurred, such as ``SSL``, ``PEM`` or ``X509``.  The range of possible "
"values depends on the OpenSSL version."
msgstr ""
"Una cadena de caracteres mnemotécnica que designa el submódulo de OpenSSL en "
"el que se ha producido el error, como ``SSL``, ``PEM`` o ``X509``. El rango "
"de valores posibles depende de la versión de OpenSSL."

#: ../Doc/library/ssl.rst:209
msgid ""
"A string mnemonic designating the reason this error occurred, for example "
"``CERTIFICATE_VERIFY_FAILED``.  The range of possible values depends on the "
"OpenSSL version."
msgstr ""
"Una cadena de caracteres mnemotécnica que designa la razón por la que se "
"produjo el error, por ejemplo ``CERTIFICATE_VERIFY_FAILED``. El rango de "
"valores posibles depende de la versión de OpenSSL."

#: ../Doc/library/ssl.rst:217
msgid ""
"A subclass of :exc:`SSLError` raised when trying to read or write and the "
"SSL connection has been closed cleanly.  Note that this doesn't mean that "
"the underlying transport (read TCP) has been closed."
msgstr ""
"Una subclase de :exc:`SSLError` lanzada cuando se intenta leer o escribir y "
"la conexión SSL ha sido cerrada limpiamente. Tenga en cuenta que esto no "
"significa que el transporte subyacente (lectura TCP) haya sido cerrado."

#: ../Doc/library/ssl.rst:225
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"received on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"Una subclase de :exc:`SSLError` lanzada por un :ref:`socket SSL no "
"bloqueante <ssl-nonblocking>` cuando se intenta leer o escribir datos, pero "
"mas datos necesitan ser recibidos en el transporte TCP subyacente antes de "
"que la solicitud pueda ser completada."

#: ../Doc/library/ssl.rst:234
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"sent on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"Una subclase de :exc:`SSLError` lanzada por un :ref:`socket SSL no "
"bloqueante <ssl-nonblocking>` cuando se intenta leer o escribir datos, pero "
"mas datos necesitan ser enviados en el transporte TCP subyacente antes de "
"que la solicitud pueda ser completada."

#: ../Doc/library/ssl.rst:243
msgid ""
"A subclass of :exc:`SSLError` raised when a system error was encountered "
"while trying to fulfill an operation on a SSL socket.  Unfortunately, there "
"is no easy way to inspect the original errno number."
msgstr ""
"Una subclase de :exc:`SSLError` lanzada cuando se encuentra un error del "
"sistema mientras se intenta completar una operación en un socket SSL. Por "
"desgracia, no hay una manera fácil de inspeccionar el número errno original."

#: ../Doc/library/ssl.rst:251
msgid ""
"A subclass of :exc:`SSLError` raised when the SSL connection has been "
"terminated abruptly.  Generally, you shouldn't try to reuse the underlying "
"transport when this error is encountered."
msgstr ""
"Una subclase de :exc:`SSLError` lanzada cuando la conexión SSL ha sido "
"cancelada abruptamente. Generalmente, no debería intentar reutilizar el "
"transporte subyacente cuando este error se produce."

#: ../Doc/library/ssl.rst:259
msgid ""
"A subclass of :exc:`SSLError` raised when certificate validation has failed."
msgstr ""
"Una subclase de :exc:`SSLError` lanzada cuando la validación del certificado "
"ha fallado."

#: ../Doc/library/ssl.rst:266
msgid "A numeric error number that denotes the verification error."
msgstr "Un número de error numérico que indica el error de verificación."

#: ../Doc/library/ssl.rst:270
msgid "A human readable string of the verification error."
msgstr "Una cadena de caracteres legible del error de verificación."

#: ../Doc/library/ssl.rst:274
msgid "An alias for :exc:`SSLCertVerificationError`."
msgstr "Un alias para :exc:`SSLCertVerificationError`."

#: ../Doc/library/ssl.rst:276
msgid "The exception is now an alias for :exc:`SSLCertVerificationError`."
msgstr "La excepción es ahora un alias para :exc:`SSLCertVerificationError`."

#: ../Doc/library/ssl.rst:281
msgid "Random generation"
msgstr "Generación aleatoria"

#: ../Doc/library/ssl.rst:285
msgid ""
"Return *num* cryptographically strong pseudo-random bytes. Raises an :class:"
"`SSLError` if the PRNG has not been seeded with enough data or if the "
"operation is not supported by the current RAND method. :func:`RAND_status` "
"can be used to check the status of the PRNG and :func:`RAND_add` can be used "
"to seed the PRNG."
msgstr ""
"Retorna *num* bytes pseudoaleatorios criptográficamente fuertes. Lanza un :"
"class:`SSLError` si el PRNG no a sido sembrado con suficiente datos o si la "
"operación no es soportada por el método RAND actual. :func:`RAND_status` "
"puede ser usada para verificar el estado de PRNG y :func:`RAND_add` puede "
"ser usada para sembrar el PRNG."

#: ../Doc/library/ssl.rst:291 ../Doc/library/ssl.rst:312
msgid "For almost all applications :func:`os.urandom` is preferable."
msgstr "Para casi todas las aplicaciones :func:`os.urandom` es preferible."

#: ../Doc/library/ssl.rst:293
msgid ""
"Read the Wikipedia article, `Cryptographically secure pseudorandom number "
"generator (CSPRNG) <https://en.wikipedia.org/wiki/"
"Cryptographically_secure_pseudorandom_number_generator>`_, to get the "
"requirements of a cryptographically strong generator."
msgstr ""
"Léase el artículo Wikipedia, `Generador de números pseudoaleatorios "
"criptográficamente seguro (CSPRNG) <https://es.wikipedia.org/wiki/"
"Generador_de_n%C3%BAmeros_pseudoaleatorios_criptogr"
"%C3%A1ficamente_seguro>`_, para obtener los requisitos para un generador "
"criptográficamente seguro."

#: ../Doc/library/ssl.rst:302
msgid ""
"Return (bytes, is_cryptographic): bytes are *num* pseudo-random bytes, "
"is_cryptographic is ``True`` if the bytes generated are cryptographically "
"strong. Raises an :class:`SSLError` if the operation is not supported by the "
"current RAND method."
msgstr ""
"Retorna (bytes, is_cryptographic): bytes es *num* bytes pseudoaleatorios, "
"is_cryptographic es ``True`` si los bytes generados son criptográficamente "
"fuertes. Lanza un :class:`SSLError` si la operación no es soportada por el "
"método RAND actual."

#: ../Doc/library/ssl.rst:307
msgid ""
"Generated pseudo-random byte sequences will be unique if they are of "
"sufficient length, but are not necessarily unpredictable. They can be used "
"for non-cryptographic purposes and for certain purposes in cryptographic "
"protocols, but usually not for key generation etc."
msgstr ""
"Las secuencias de bytes pseudoaleatorios generadas serán únicas si tienen "
"una longitud suficiente, pero no son necesariamente impredecibles. Pueden "
"utilizarse para fines no criptográficos y para ciertos fines en protocolos "
"criptográficos, pero normalmente no para la generación de claves, etc."

#: ../Doc/library/ssl.rst:318
msgid ""
"OpenSSL has deprecated :func:`ssl.RAND_pseudo_bytes`, use :func:`ssl."
"RAND_bytes` instead."
msgstr ""
"OpenSSL a dejado obsoleta :func:`ssl.RAND_pseudo_bytes`, utilice :func:`ssl."
"RAND_bytes` en su lugar."

#: ../Doc/library/ssl.rst:323
msgid ""
"Return ``True`` if the SSL pseudo-random number generator has been seeded "
"with 'enough' randomness, and ``False`` otherwise.  You can use :func:`ssl."
"RAND_egd` and :func:`ssl.RAND_add` to increase the randomness of the pseudo-"
"random number generator."
msgstr ""
"Retorna ``True`` si el generador de números pseudoaleatorios SSL a sido "
"sembrado con 'suficiente' aleatoriedad, y ``False`` de lo contrario. Puede "
"utilizarse :func:`ssl.RAND_egd` y :func:`ssl.RAND_add` para aumentar la "
"aleatoriedad del generador de números pseudoaleatorios."

#: ../Doc/library/ssl.rst:330
msgid ""
"If you are running an entropy-gathering daemon (EGD) somewhere, and *path* "
"is the pathname of a socket connection open to it, this will read 256 bytes "
"of randomness from the socket, and add it to the SSL pseudo-random number "
"generator to increase the security of generated secret keys.  This is "
"typically only necessary on systems without better sources of randomness."
msgstr ""
"Si está ejecutando un daemon de recolección de entropía (EGD) en algún "
"lugar, y *path* es la ruta de una conexión de socket abierta a él, esto "
"leerá 256 bytes de aleatoriedad del socket, y lo añadirá al generador de "
"números pseudoaleatorios de SSL para aumentar la seguridad de las claves "
"secretas generadas. Esto suele ser necesario sólo en sistemas sin mejores "
"fuentes de aleatoriedad."

#: ../Doc/library/ssl.rst:336
msgid ""
"See http://egd.sourceforge.net/ or http://prngd.sourceforge.net/ for sources "
"of entropy-gathering daemons."
msgstr ""
"Véase http://egd.sourceforge.net/ o http://prngd.sourceforge.net/ para "
"fuentes de daemons de recolección de entropía (EGD)."

#: ../Doc/library/ssl.rst:339
msgid ""
":ref:`Availability <availability>`: not available with LibreSSL and OpenSSL "
"> 1.1.0."
msgstr ""
":ref:`Disponibilidad <availability>`: no disponible con LibreSSL y OpenSSL > "
"1.1.0."

#: ../Doc/library/ssl.rst:343
msgid ""
"Mix the given *bytes* into the SSL pseudo-random number generator.  The "
"parameter *entropy* (a float) is a lower bound on the entropy contained in "
"string (so you can always use :const:`0.0`).  See :rfc:`1750` for more "
"information on sources of entropy."
msgstr ""
"Mezcla los *bytes* dados en el generador de números pseudoaleatorios de SSL. "
"El parámetro *entropy* (un flotante) es un límite inferior de la entropía "
"contenida en la cadena de caracteres (por lo que siempre se puede utilizar :"
"const:`0.0`). Véase :rfc:`1750` para mas información sobre las fuentes de "
"entropía."

#: ../Doc/library/ssl.rst:348
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "Ahora se acepta :term:`bytes-like object` modificable."

#: ../Doc/library/ssl.rst:352
msgid "Certificate handling"
msgstr "Gestión de certificados"

#: ../Doc/library/ssl.rst:360
msgid ""
"Verify that *cert* (in decoded format as returned by :meth:`SSLSocket."
"getpeercert`) matches the given *hostname*.  The rules applied are those for "
"checking the identity of HTTPS servers as outlined in :rfc:`2818`, :rfc:"
"`5280` and :rfc:`6125`.  In addition to HTTPS, this function should be "
"suitable for checking the identity of servers in various SSL-based protocols "
"such as FTPS, IMAPS, POPS and others."
msgstr ""
"Verifica que *cert* (en formato decodificado tal y como es retornado por :"
"meth:`SSLSocket.getpeercert`) coincide con el *hostname* dado. Las reglas "
"aplicadas son las de comprobación de la identidad de los servidores HTTPS, "
"como se indica en :rfc:`2818`, :rfc:`5280` y :rfc:`6125`. Además de HTTPS, "
"esta función debería ser adecuada para comprobar la identidad de servidores "
"en varios protocolos basados en SSL como FTPS, IMAPS, POPS y otros."

#: ../Doc/library/ssl.rst:367
msgid ""
":exc:`CertificateError` is raised on failure. On success, the function "
"returns nothing::"
msgstr ""
":exc:`CertificateError` es lanzado en caso de error. En caso de éxito, la "
"función no retorna nada::"

#: ../Doc/library/ssl.rst:380
msgid ""
"The function now follows :rfc:`6125`, section 6.4.3 and does neither match "
"multiple wildcards (e.g. ``*.*.com`` or ``*a*.example.org``) nor a wildcard "
"inside an internationalized domain names (IDN) fragment. IDN A-labels such "
"as ``www*.xn--pthon-kva.org`` are still supported, but ``x*.python.org`` no "
"longer matches ``xn--tda.python.org``."
msgstr ""
"La función ahora sigue :rfc:`6125` sección 6.4.3 y no soporta múltiples "
"caracteres comodín (por ejemplo ``*.*.com`` o ``*a*.example.org``) ni "
"tampoco un carácter comodín dentro de un fragmento de un nombre de dominio "
"internacionalizado (IDN). Etiquetas A de IDN tales como ``www*.xn--pthon-kva."
"org`` son todavía soportadas, pero ``x*.python.org`` ya no corresponde con "
"``xn--tda.python.org``."

#: ../Doc/library/ssl.rst:387
msgid ""
"Matching of IP addresses, when present in the subjectAltName field of the "
"certificate, is now supported."
msgstr ""
"Ahora se admite la coincidencia de direcciones IP cuando están presentes en "
"el campo subjectAltName del certificado."

#: ../Doc/library/ssl.rst:391
msgid ""
"The function is no longer used to TLS connections. Hostname matching is now "
"performed by OpenSSL."
msgstr ""
"La función ya no se utiliza para las conexiones TLS. La coincidencia de "
"hostname es ahora realizada por OpenSSL."

#: ../Doc/library/ssl.rst:395
msgid ""
"Allow wildcard when it is the leftmost and the only character in that "
"segment. Partial wildcards like ``www*.example.com`` are no longer supported."
msgstr ""
"Se permite el carácter comodín cuando es el carácter más a la izquierda y el "
"único en ese segmento. Ya no se admiten comodines parciales como ``www*."
"example.com`` ."

#: ../Doc/library/ssl.rst:403
#, python-format
msgid ""
"Return the time in seconds since the Epoch, given the ``cert_time`` string "
"representing the \"notBefore\" or \"notAfter\" date from a certificate in ``"
"\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale)."
msgstr ""
"Retorna el tiempo en segundos desde la Época, dada la cadena de caracteres "
"``cert_time`` que representa la fecha \"notBefore\" o \"notAfter\" de un "
"certificado en formato strptime ``\"%b %d %H:%M:%S %Y %Z\"`` (C locale)."

#: ../Doc/library/ssl.rst:408
msgid "Here's an example:"
msgstr "He aquí un ejemplo:"

#: ../Doc/library/ssl.rst:420
msgid "\"notBefore\" or \"notAfter\" dates must use GMT (:rfc:`5280`)."
msgstr ""
"Las fechas \"notBefore\" o \"notAfter\" deben utilizar GMT (:rfc:`5280`)."

#: ../Doc/library/ssl.rst:422
msgid ""
"Interpret the input time as a time in UTC as specified by 'GMT' timezone in "
"the input string. Local timezone was used previously. Return an integer (no "
"fractions of a second in the input format)"
msgstr ""
"Interpreta la hora de entrada como una hora en UTC según lo especificado por "
"la zona horaria 'GMT' en la cadena de caracteres de entrada. Anteriormente "
"se utilizaba la zona horaria local. Devuelve un número entero (sin "
"fracciones de segundo en el formato de entrada)"

#: ../Doc/library/ssl.rst:430
msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as a "
"PEM-encoded string.  If ``ssl_version`` is specified, uses that version of "
"the SSL protocol to attempt to connect to the server.  If ``ca_certs`` is "
"specified, it should be a file containing a list of root certificates, the "
"same format as used for the same parameter in :meth:`SSLContext."
"wrap_socket`.  The call will attempt to validate the server certificate "
"against that set of root certificates, and will fail if the validation "
"attempt fails."
msgstr ""
"Dada la dirección ``addr`` de un servidor protegido con SSL, como un par "
"(*hostname*, *port-number*), obtiene el certificado del servidor, y lo "
"retorna como una cadena de caracteres codificada en PEM. Si se especifica "
"``ssl_version``, utiliza esta versión del protocolo SSL para intentar "
"conectarse al servidor. Si se especifica ``ca_certs``, debe ser un archivo "
"que contenga una lista de certificados raíz, con el mismo formato que se "
"utiliza para el mismo parámetro en :meth:`SSLContext.wrap_socket`. La "
"llamada intentará validar el certificado del servidor contra ese conjunto de "
"certificados raíz, y fallará si el intento de validación falla."

#: ../Doc/library/ssl.rst:440
msgid "This function is now IPv6-compatible."
msgstr "Esta función es ahora compatible IPv6."

#: ../Doc/library/ssl.rst:443
msgid ""
"The default *ssl_version* is changed from :data:`PROTOCOL_SSLv3` to :data:"
"`PROTOCOL_TLS` for maximum compatibility with modern servers."
msgstr ""
"La *ssl_version* por defecto se cambia de :data:`PROTOCOL_SSLv3` a :data:"
"`PROTOCOL_TLS` para una máxima compatibilidad con los servidores modernos."

#: ../Doc/library/ssl.rst:449
msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded "
"string version of the same certificate."
msgstr ""
"Dado un certificado como blob de bytes codificado en DER, devuelve una "
"versión de cadena de caracteres codificada en PEM del mismo certificado."

#: ../Doc/library/ssl.rst:454
msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded sequence "
"of bytes for that same certificate."
msgstr ""
"Dado un certificado como cadena de caracteres ASCII PEM, devuelve una "
"secuencia de bytes codificada con DER para ese mismo certificado."

#: ../Doc/library/ssl.rst:459
msgid ""
"Returns a named tuple with paths to OpenSSL's default cafile and capath. The "
"paths are the same as used by :meth:`SSLContext.set_default_verify_paths`. "
"The return value is a :term:`named tuple` ``DefaultVerifyPaths``:"
msgstr ""
"Retorna una tupla con nombre con las rutas por defecto de cafile y capath de "
"OpenSSL. Las rutas son las mismas que las usadas por :meth:`SSLContext."
"set_default_verify_paths`. El valor de retorno es una :term:`named tuple` "
"``DefaultVerifyPaths``:"

#: ../Doc/library/ssl.rst:464
msgid ""
":attr:`cafile` - resolved path to cafile or ``None`` if the file doesn't "
"exist,"
msgstr ""
":attr:`cafile` - ruta resuelta a cafile o ``None`` si el archivo no existe,"

#: ../Doc/library/ssl.rst:465
msgid ""
":attr:`capath` - resolved path to capath or ``None`` if the directory "
"doesn't exist,"
msgstr ""
":attr:`capath` - ruta resuelta a capath o ``None`` si el directorio no "
"existe,"

#: ../Doc/library/ssl.rst:466
msgid ""
":attr:`openssl_cafile_env` - OpenSSL's environment key that points to a "
"cafile,"
msgstr ""
":attr:`openssl_cafile_env` - clave de entorno de OpenSSL que apunta a un "
"cafile,"

# Como traducir "hard coded path" ?
# "ruta hardcodeada" ?
# "ruta preseteada" ?
# "ruta predefinida" ?
#: ../Doc/library/ssl.rst:467
msgid ":attr:`openssl_cafile` - hard coded path to a cafile,"
msgstr ":attr:`openssl_cafile` - ruta escrita en duro a un cafile,"

#: ../Doc/library/ssl.rst:468
msgid ""
":attr:`openssl_capath_env` - OpenSSL's environment key that points to a "
"capath,"
msgstr ""
":attr:`openssl_capath_env` - clave de entorno de OpenSSL que apunta a un "
"capath,"

#: ../Doc/library/ssl.rst:469
msgid ":attr:`openssl_capath` - hard coded path to a capath directory"
msgstr ":attr:`openssl_capath` - ruta escrita en duro a un directorio capath"

#: ../Doc/library/ssl.rst:473
msgid ""
":ref:`Availability <availability>`: LibreSSL ignores the environment vars :"
"attr:`openssl_cafile_env` and :attr:`openssl_capath_env`."
msgstr ""
":ref:`Disponibilidad <availability>`: LibreSSL ignora las variables de "
"entorno :attr:`openssl_cafile_env` y :attr:`openssl_capath_env`."

#: ../Doc/library/ssl.rst:478
msgid ""
"Retrieve certificates from Windows' system cert store. *store_name* may be "
"one of ``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert "
"stores, too."
msgstr ""
"Recupera los certificados del almacén de certificados del sistema de "
"Windows. *store_name* puede ser uno de los siguientes: ``CA``, ``ROOT`` o "
"``MY``. Windows también puede proporcionar almacenes de certificados "
"adicionales."

#: ../Doc/library/ssl.rst:482
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 "
"data. Trust specifies the purpose of the certificate as a set of OIDS or "
"exactly ``True`` if the certificate is trustworthy for all purposes."
msgstr ""
"La función devuelve una lista de tuplas (cert_bytes, encoding_type, trust). "
"El encoding_type especifica la codificación de cert_bytes. Es :const:"
"`x509_asn` para datos X.509 ASN.1 o :const:`pkcs_7_asn` para datos PKCS#7 "
"ASN.1. Trust especifica el propósito del certificado como un conjunto de "
"OIDS o exactamente ``True`` si el certificado es de confianza para todos los "
"propósitos."

#: ../Doc/library/ssl.rst:489 ../Doc/library/ssl.rst:1577
#: ../Doc/library/ssl.rst:1892
msgid "Example::"
msgstr "Ejemplo::"

#: ../Doc/library/ssl.rst:496 ../Doc/library/ssl.rst:511
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Disponibilidad <availability>`: Windows."

#: ../Doc/library/ssl.rst:501
msgid ""
"Retrieve CRLs from Windows' system cert store. *store_name* may be one of "
"``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert stores, too."
msgstr ""
"Obtiene CRLs del almacén de certificados del sistema de Windows. "
"*store_name* puede ser uno de los siguientes: ``CA``, ``ROOT`` o ``MY``. "
"Windows también puede proporcionar almacenes de certificados adicionales."

#: ../Doc/library/ssl.rst:505
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 data."
msgstr ""
"La función devuelve una lista de tuplas (cert_bytes, encoding_type, trust). "
"El encoding_type especifica la codificación de cert_bytes. Es :const:"
"`x509_asn` para datos X.509 ASN.1 o :const:`pkcs_7_asn` para datos PKCS#7 "
"ASN.1."

#: ../Doc/library/ssl.rst:519
msgid ""
"Takes an instance ``sock`` of :class:`socket.socket`, and returns an "
"instance of :class:`ssl.SSLSocket`, a subtype of :class:`socket.socket`, "
"which wraps the underlying socket in an SSL context.  ``sock`` must be a :"
"data:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""
"Toma una instancia ``sock`` de :class:`socket.socket`, y devuelve una "
"instancia de :class:`ssl.SSLSocket`, un subtipo de :class:`socket.socket`, "
"que envuelve el socket de base en un contexto SSL. ``sock`` debe ser un "
"socket :data:`~socket.SOCK_STREAM`; otros tipos de socket no son compatibles."

#: ../Doc/library/ssl.rst:524
msgid ""
"Internally, function creates a :class:`SSLContext` with protocol "
"*ssl_version* and :attr:`SSLContext.options` set to *cert_reqs*. If "
"parameters *keyfile*, *certfile*, *ca_certs* or *ciphers* are set, then the "
"values are passed to :meth:`SSLContext.load_cert_chain`, :meth:`SSLContext."
"load_verify_locations`, and :meth:`SSLContext.set_ciphers`."
msgstr ""
"Internamente, la función crea un :class:`SSLContext` con un protocolo "
"*ssl_version* y :attr:`SSLContext.options` establecido a *cert_reqs*. Si los "
"parámetros *keyfile*, *certfile*, *ca_certs* o *ciphers* son establecidos, "
"entonces los valores son pasados a :meth:`SSLContext.load_cert_chain`, :meth:"
"`SSLContext.load_verify_locations`, y :meth:`SSLContext.set_ciphers`."

#: ../Doc/library/ssl.rst:531
msgid ""
"The arguments *server_side*, *do_handshake_on_connect*, and "
"*suppress_ragged_eofs* have the same meaning as :meth:`SSLContext."
"wrap_socket`."
msgstr ""
"Los argumentos *server_side*, *do_handshake_on_connect*, y "
"*supress_ragged_eofs* tienen el mismo significado que :meth:`SSLContext."
"wrap_socket`."

#: ../Doc/library/ssl.rst:537
msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the :meth:`SSLContext."
"wrap_socket` instead of :func:`wrap_socket`. The top-level function is "
"limited and creates an insecure client socket without server name indication "
"or hostname matching."
msgstr ""
"Desde Python 3.2 y 2.7.9, se recomienda usar :meth:`SSLContext.wrap_socket` "
"en lugar de :func:`wrap_socket`. La función de alto nivel tiene limitaciones "
"y crea un socket cliente no seguro sin indicación de nombre de servidor ni "
"hostname matching."

#: ../Doc/library/ssl.rst:543
msgid "Constants"
msgstr "Constantes"

#: ../Doc/library/ssl.rst:545
msgid ""
"All constants are now :class:`enum.IntEnum` or :class:`enum.IntFlag` "
"collections."
msgstr ""
"Todas las constantes son ahora colecciones :class:`enum.IntEnum` o :class:"
"`enum.IntFlag`."

# "handshake" en inglés me parece aceptable.
#: ../Doc/library/ssl.rst:551
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  Except for :const:`PROTOCOL_TLS_CLIENT`, "
"it is the default mode.  With client-side sockets, just about any cert is "
"accepted.  Validation errors, such as untrusted or expired cert, are ignored "
"and do not abort the TLS/SSL handshake."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_mode`, o el parámetro "
"``cert_reqs`` de :func:`wrap_socket`. A excepción de :const:"
"`PROTOCOL_TLS_CLIENT`, es el modo por defecto. Con sockets del lado del "
"cliente, se acepta casi cualquier certificado. Errores de validación, como "
"certificado no confiable o caducado, son ignorados y no abortan el handshake "
"TLS/SSL."

#: ../Doc/library/ssl.rst:557
msgid ""
"In server mode, no certificate is requested from the client, so the client "
"does not send any for client cert authentication."
msgstr ""
"En modo servidor, no se solicita ningún certificado al cliente, por lo que "
"el cliente no envía ninguno para la autenticación del certificado del "
"cliente."

#: ../Doc/library/ssl.rst:560 ../Doc/library/ssl.rst:2317
msgid "See the discussion of :ref:`ssl-security` below."
msgstr "Vea la discusión sobre :ref:`ssl-security` más abajo."

#: ../Doc/library/ssl.rst:564
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In client mode, :const:`CERT_OPTIONAL` "
"has the same meaning as :const:`CERT_REQUIRED`. It is recommended to use :"
"const:`CERT_REQUIRED` for client-side sockets instead."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_mode`, o el parámetro "
"``cert_reqs`` de :func:`wrap_socket`. En modo cliente, :const:"
"`CERT_OPTIONAL` tiene el mismo significado que :const:`CERT_REQUIRED`. Se "
"recomienda usar en su lugar :const:`CERT_REQUIRED` para sockets del lado del "
"cliente."

#: ../Doc/library/ssl.rst:569
msgid ""
"In server mode, a client certificate request is sent to the client.  The "
"client may either ignore the request or send a certificate in order perform "
"TLS client cert authentication.  If the client chooses to send a "
"certificate, it is verified.  Any verification error immediately aborts the "
"TLS handshake."
msgstr ""
"En el modo servidor, se envía una solicitud de certificado de cliente al "
"cliente. El cliente puede ignorar la solicitud o enviar un certificado para "
"realizar la autenticación de certificado de cliente TLS. Si el cliente opta "
"por enviar un certificado, éste se verifica. Cualquier error de verificación "
"aborta inmediatamente el handshake TLS."

#: ../Doc/library/ssl.rst:575 ../Doc/library/ssl.rst:595
msgid ""
"Use of this setting requires a valid set of CA certificates to be passed, "
"either to :meth:`SSLContext.load_verify_locations` or as a value of the "
"``ca_certs`` parameter to :func:`wrap_socket`."
msgstr ""
"El uso de esta configuración requiere que se pase un conjunto válido de "
"certificados de CA, ya sea a :meth:`SSLContext.load_verify_locations` o como "
"valor del parámetro ``ca_certs`` de :func:`wrap_socket`."

#: ../Doc/library/ssl.rst:581
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode, certificates are required "
"from the other side of the socket connection; an :class:`SSLError` will be "
"raised if no certificate is provided, or if its validation fails. This mode "
"is **not** sufficient to verify a certificate in client mode as it does not "
"match hostnames.  :attr:`~SSLContext.check_hostname` must be enabled as well "
"to verify the authenticity of a cert. :const:`PROTOCOL_TLS_CLIENT` uses :"
"const:`CERT_REQUIRED` and enables :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_mode`, o el parámetro "
"``cert_reqs`` de :func:`wrap_socket`. En este modo, se requieren "
"certificados del otro lado de la conexión del socket; se lanzará un :class:"
"`SSLError` si no se proporciona ningún certificado, o si su validación "
"falla. Este modo **no** es suficiente para verificar un certificado en modo "
"cliente, ya que no coincide con los hostnames. :attr:`~SSLContext."
"check_hostname` debe estar activado también para verificar la autenticidad "
"de un certificado. :const:`PROTOCOL_TLS_CLIENT` utiliza :const:"
"`CERT_REQUIRED` y activa :attr:`~SSLContext.check_hostname` por defecto."

#: ../Doc/library/ssl.rst:591
msgid ""
"With server socket, this mode provides mandatory TLS client cert "
"authentication.  A client certificate request is sent to the client and the "
"client must provide a valid and trusted certificate."
msgstr ""
"Con socket servidor, este modo proporciona una autenticación obligatoria de "
"certificado de cliente TLS. Se envía una solicitud de certificado de cliente "
"al cliente y el cliente debe proporcionar un certificado válido y de "
"confianza."

#: ../Doc/library/ssl.rst:601
msgid ":class:`enum.IntEnum` collection of CERT_* constants."
msgstr "Colección :class:`enum.IntEnum` de constantes CERT_*."

#: ../Doc/library/ssl.rst:607
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, "
"certificate revocation lists (CRLs) are not checked. By default OpenSSL does "
"neither require nor verify CRLs."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_flags`. En este modo, las listas "
"de revocación de certificado (CRLs) no son vérificadas. Por defecto OpenSSL "
"no requiere ni verifica CRLs."

#: ../Doc/library/ssl.rst:615
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, only the "
"peer cert is checked but none of the intermediate CA certificates. The mode "
"requires a valid CRL that is signed by the peer cert's issuer (its direct "
"ancestor CA). If no proper CRL has been loaded with :attr:`SSLContext."
"load_verify_locations`, validation will fail."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_flags`. En este modo, sólo el "
"certificado de pares es verificado pero ninguno de los certificados CA "
"intermedios. El modo requiere una CRL válida que esté firmada por el emisor "
"del certificado de pares (su CA antecesora directa). Si no se ha cargado una "
"CRL adecuada con :attr:`SSLContext.load_verify_locations`, la validación "
"fallará."

#: ../Doc/library/ssl.rst:625
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, CRLs of "
"all certificates in the peer cert chain are checked."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_flags`. En este modo, las CRLs "
"de todos los certificados en la cadena de certificado de pares son "
"verificadas."

#: ../Doc/library/ssl.rst:632
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to disable workarounds "
"for broken X.509 certificates."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_flags` para desactivar "
"soluciones alternativas para certificados X.509 rotos."

#: ../Doc/library/ssl.rst:639
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"prefer trusted certificates when building the trust chain to validate a "
"certificate. This flag is enabled by default."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_flags`. Indica a OpenSSL de "
"preferir certificados de confianza al construir la cadena de confianza para "
"validar un certificado. Esta opción está activada por defecto."

#: ../Doc/library/ssl.rst:647
msgid ":class:`enum.IntFlag` collection of VERIFY_* constants."
msgstr "Colección :class:`enum.IntFlag` de constantes VERIFY_*."

#: ../Doc/library/ssl.rst:653
msgid ""
"Selects the highest protocol version that both the client and server "
"support. Despite the name, this option can select both \"SSL\" and \"TLS\" "
"protocols."
msgstr ""
"Selecciona la versión mas alta del protocolo soportada tanto por el cliente "
"como por el servidor. A pesar de su nombre, esta opción puede seleccionar "
"ambos protocolos \"SSL\" y \"TLS\"."

#: ../Doc/library/ssl.rst:660
msgid ""
"Auto-negotiate the highest protocol version like :data:`PROTOCOL_TLS`, but "
"only support client-side :class:`SSLSocket` connections. The protocol "
"enables :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
"Negocia automáticamente la versión más alta del protocolo como :data:"
"`PROTOCOL_TLS`, pero sólo soporta conexiones :class:`SSLSocket` del lado del "
"cliente. El protocolo activa :data:`CERT_REQUIRED` y :attr:`~SSLContext."
"check_hostname` por defecto."

#: ../Doc/library/ssl.rst:669
msgid ""
"Auto-negotiate the highest protocol version like :data:`PROTOCOL_TLS`, but "
"only support server-side :class:`SSLSocket` connections."
msgstr ""
"Negocia automáticamente la versión más alta del protocolo como :data:"
"`PROTOCOL_TLS`, pero sólo soporta conexiones :class:`SSLSocket` del lado del "
"servidor."

#: ../Doc/library/ssl.rst:676
msgid "Alias for :data:`PROTOCOL_TLS`."
msgstr "Alias para :data:`PROTOCOL_TLS`."

#: ../Doc/library/ssl.rst:680
msgid "Use :data:`PROTOCOL_TLS` instead."
msgstr "Utilice en su lugar :data:`PROTOCOL_TLS`."

#: ../Doc/library/ssl.rst:684
msgid "Selects SSL version 2 as the channel encryption protocol."
msgstr "Selecciona la versión 2 de SSL como protocolo de cifrado del canal."

#: ../Doc/library/ssl.rst:686
msgid ""
"This protocol is not available if OpenSSL is compiled with the "
"``OPENSSL_NO_SSL2`` flag."
msgstr ""
"Este protocolo no está disponible si OpenSSL fue compilada con la opción "
"``OPENSSL_NO_SSL2``."

#: ../Doc/library/ssl.rst:691
msgid "SSL version 2 is insecure.  Its use is highly discouraged."
msgstr "La versión 2 de SSL es insegura. Su uso es muy desaconsejado."

#: ../Doc/library/ssl.rst:695
msgid "OpenSSL has removed support for SSLv2."
msgstr "OpenSSL a eliminado el soporte para SSLv2."

#: ../Doc/library/ssl.rst:699
msgid "Selects SSL version 3 as the channel encryption protocol."
msgstr "Selecciona la versión 3 de SSL como protocolo de cifrado del canal."

#: ../Doc/library/ssl.rst:701
msgid ""
"This protocol is not be available if OpenSSL is compiled with the "
"``OPENSSL_NO_SSLv3`` flag."
msgstr ""
"Este protocolo no está disponible si OpenSSL fue compilada con la opción "
"``OPENSSL_NO_SSLv3``."

#: ../Doc/library/ssl.rst:706
msgid "SSL version 3 is insecure.  Its use is highly discouraged."
msgstr "La versión 3 de SSL es insegura. Su uso es muy desaconsejado."

#: ../Doc/library/ssl.rst:710 ../Doc/library/ssl.rst:719
#: ../Doc/library/ssl.rst:731 ../Doc/library/ssl.rst:744
msgid ""
"OpenSSL has deprecated all version specific protocols. Use the default "
"protocol :data:`PROTOCOL_TLS` with flags like :data:`OP_NO_SSLv3` instead."
msgstr ""
"OpenSSL a dejado obsoletas todos los protocolos de versiones específicas. "
"Utilice en su lugar el protocolo por defecto :data:`PROTOCOL_TLS` con "
"opciones como :data:`OP_NO_SSLv3`."

#: ../Doc/library/ssl.rst:715
msgid "Selects TLS version 1.0 as the channel encryption protocol."
msgstr "Selecciona la versión 1.0 de TLS como protocolo de cifrado del canal."

#: ../Doc/library/ssl.rst:724
msgid ""
"Selects TLS version 1.1 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr ""
"Selecciona la versión 1.1 de TLS como protocolo de cifrado del canal. "
"Disponible sólo con openssl en versión 1.0.1+."

#: ../Doc/library/ssl.rst:736
msgid ""
"Selects TLS version 1.2 as the channel encryption protocol. This is the most "
"modern version, and probably the best choice for maximum protection, if both "
"sides can speak it.  Available only with openssl version 1.0.1+."
msgstr ""
"Selecciona la versión 1.2 de TLS como protocolo de cifrado del canal. Esta "
"es la versión mas moderna, y probablemente la mejor alternativa para máxima "
"protección, si ambos lados pueden utilizarla. Disponible sólo con openssl en "
"versión 1.0.1+."

#: ../Doc/library/ssl.rst:749
msgid ""
"Enables workarounds for various bugs present in other SSL implementations. "
"This option is set by default.  It does not necessarily set the same flags "
"as OpenSSL's ``SSL_OP_ALL`` constant."
msgstr ""
"Activa soluciones alternativas para varios errores presentes en otras "
"implementaciones SSL. Esta opción esta activada por defecto. No "
"necesariamente activa las mismas opciones como la constante ``SSL_OP_ALL`` "
"de OpenSSL."

#: ../Doc/library/ssl.rst:757
msgid ""
"Prevents an SSLv2 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv2 as "
"the protocol version."
msgstr ""
"Evita una conexión SSLv2. Esta opción sólo es aplicable junto con :const:"
"`PROTOCOL_TLS`. Evita que los pares elijan SSLv2 como versión del protocolo."

#: ../Doc/library/ssl.rst:765
msgid "SSLv2 is deprecated"
msgstr "SSLv2 es obsoleto"

#: ../Doc/library/ssl.rst:770
msgid ""
"Prevents an SSLv3 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv3 as "
"the protocol version."
msgstr ""
"Evita una conexión SSLv3. Esta opción sólo es aplicable junto con :const:"
"`PROTOCOL_TLS`. Evita que los pares elijan SSLv3 como versión del protocolo."

#: ../Doc/library/ssl.rst:778
msgid "SSLv3 is deprecated"
msgstr "SSLv3 es obsoleto"

#: ../Doc/library/ssl.rst:782
msgid ""
"Prevents a TLSv1 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing TLSv1 as "
"the protocol version."
msgstr ""
"Evita una conexión TLSv1. Esta opción sólo es aplicable junto con :const:"
"`PROTOCOL_TLS`. Evita que los pares elijan TLSv1 como versión del protocolo."

#: ../Doc/library/ssl.rst:788
msgid ""
"The option is deprecated since OpenSSL 1.1.0, use the new :attr:`SSLContext."
"minimum_version` and :attr:`SSLContext.maximum_version` instead."
msgstr ""
"Esta opción es obsoleta desde OpenSSL 1.1.0, utilice en su lugar los nuevos :"
"attr:`SSLContext.minimum_version` y :attr:`SSLContext.maximum_version`."

#: ../Doc/library/ssl.rst:795
msgid ""
"Prevents a TLSv1.1 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.1 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"Evita una conexión TLSv1.1. Esta opción sólo es aplicable junto con :const:"
"`PROTOCOL_TLS`. Evita que los pares elijan TLSv1.1 como versión del "
"protocolo. Disponible sólo con openssl en versión 1.0.1+."

#: ../Doc/library/ssl.rst:801 ../Doc/library/ssl.rst:812
msgid "The option is deprecated since OpenSSL 1.1.0."
msgstr "Esta opción es obsoleta desde OpenSSL 1.1.0."

#: ../Doc/library/ssl.rst:806
msgid ""
"Prevents a TLSv1.2 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.2 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"Evita una conexión TLSv1.2. Esta opción sólo es aplicable junto con :const:"
"`PROTOCOL_TLS`. Evita que los pares elijan TLSv1.2 como versión del "
"protocolo. Disponible sólo con openssl en versión 1.0.1+."

#: ../Doc/library/ssl.rst:817
msgid ""
"Prevents a TLSv1.3 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.3 as "
"the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later. When "
"Python has been compiled against an older version of OpenSSL, the flag "
"defaults to *0*."
msgstr ""
"Evita una conexión TLSv1.3. Esta opción sólo es aplicable junto con :const:"
"`PROTOCOL_TLS`. Evita que los pares elijan TLSv1.3 como versión del "
"protocolo. TLS 1.3 está disponible con OpenSSL 1.1.1 o superior. Cuando "
"Python es compilado contra una versión mas antigua de OpenSSL, la opción "
"vale *0* por defecto."

#: ../Doc/library/ssl.rst:825
msgid ""
"The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15, 3.6.3 "
"and 3.7.0 for backwards compatibility with OpenSSL 1.0.2."
msgstr ""
"Esta opción es obsoleta desde OpenSSL 1.1.0. Ha sido agregada a 2.7.15, "
"3.6.3 y 3.7.0 por retro-compatibilidad con OpenSSL 1.0.2."

#: ../Doc/library/ssl.rst:831
msgid ""
"Disable all renegotiation in TLSv1.2 and earlier. Do not send HelloRequest "
"messages, and ignore renegotiation requests via ClientHello."
msgstr ""
"Desactiva toda re-negociación en TLSv1.2 y anteriores. No envía mensajes "
"HelloRequest e ignora solicitudes de re-negociación vía ClientHello."

#: ../Doc/library/ssl.rst:834
msgid "This option is only available with OpenSSL 1.1.0h and later."
msgstr "Esta opción sólo está disponible con OpenSSL 1.1.0h y posteriores."

#: ../Doc/library/ssl.rst:840
msgid ""
"Use the server's cipher ordering preference, rather than the client's. This "
"option has no effect on client sockets and SSLv2 server sockets."
msgstr ""
"Utiliza la preferencia de ordenación de cifrado del servidor, en lugar de la "
"del cliente. Esta opción no tiene efecto en los sockets del cliente ni en "
"los sockets del servidor SSLv2."

#: ../Doc/library/ssl.rst:847
msgid ""
"Prevents re-use of the same DH key for distinct SSL sessions.  This improves "
"forward secrecy but requires more computational resources. This option only "
"applies to server sockets."
msgstr ""
"Evita la reutilización de la misma clave DH para distintas sesiones SSL. "
"Esto mejora el secreto hacia adelante pero requiere más recursos "
"computacionales. Esta opción sólo se aplica a los sockets del servidor."

#: ../Doc/library/ssl.rst:855
msgid ""
"Prevents re-use of the same ECDH key for distinct SSL sessions.  This "
"improves forward secrecy but requires more computational resources. This "
"option only applies to server sockets."
msgstr ""
"Evita la reutilización de la misma clave ECDH para distintas sesiones SSL. "
"Esto mejora el secreto hacia adelante pero requiere más recursos "
"computacionales. Esta opción sólo se aplica a los sockets del servidor."

#: ../Doc/library/ssl.rst:863
msgid ""
"Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make a "
"TLS 1.3 connection look more like a TLS 1.2 connection."
msgstr ""
"Enviar mensajes Change Cipher Spec (CCS) ficticios en el handshake de TLS "
"1.3 para que una conexión TLS 1.3 se parezca más a una conexión TLS 1.2."

#: ../Doc/library/ssl.rst:866
msgid "This option is only available with OpenSSL 1.1.1 and later."
msgstr "Esta opción sólo está disponible con OpenSSL 1.1.1 y posteriores."

#: ../Doc/library/ssl.rst:872
msgid ""
"Disable compression on the SSL channel.  This is useful if the application "
"protocol supports its own compression scheme."
msgstr ""
"Desactivar la compresión en el canal SSL. Esto es útil si el protocolo de la "
"aplicación soporta su propio esquema de compresión."

#: ../Doc/library/ssl.rst:875
msgid "This option is only available with OpenSSL 1.0.0 and later."
msgstr "Esta opción sólo está disponible con OpenSSL 1.0.0 y posteriores."

#: ../Doc/library/ssl.rst:881
msgid ":class:`enum.IntFlag` collection of OP_* constants."
msgstr "Colección :class:`enum.IntFlag` de constantes OP_*."

#: ../Doc/library/ssl.rst:885
msgid "Prevent client side from requesting a session ticket."
msgstr "Evita que el lado del cliente solicite un ticket de sesión."

#: ../Doc/library/ssl.rst:891
msgid ""
"Whether the OpenSSL library has built-in support for the *Application-Layer "
"Protocol Negotiation* TLS extension as described in :rfc:`7301`."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para la extensión TLS "
"*Application-Layer Protocol Negotiation* como se describe en :rfc:`7301`."

#: ../Doc/library/ssl.rst:898
msgid ""
"Whether the OpenSSL library has built-in support not checking subject common "
"name and :attr:`SSLContext.hostname_checks_common_name` is writeable."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para no comprobar el "
"nombre común del sujeto y :attr:`SSLContext.hostname_checks_common_name` es "
"modificable."

#: ../Doc/library/ssl.rst:906
msgid ""
"Whether the OpenSSL library has built-in support for the Elliptic Curve-"
"based Diffie-Hellman key exchange.  This should be true unless the feature "
"was explicitly disabled by the distributor."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para el intercambio de "
"claves Diffie-Hellman basado en Elliptic Curve. Esto debería ser cierto a "
"menos que la función haya sido desactivada explícitamente por el "
"distribuidor."

#: ../Doc/library/ssl.rst:914
msgid ""
"Whether the OpenSSL library has built-in support for the *Server Name "
"Indication* extension (as defined in :rfc:`6066`)."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para la extensión *Server "
"Name Indication* (como se define en :rfc:`6066`)."

#: ../Doc/library/ssl.rst:921
msgid ""
"Whether the OpenSSL library has built-in support for the *Next Protocol "
"Negotiation* as described in the `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"When true, you can use the :meth:`SSLContext.set_npn_protocols` method to "
"advertise which protocols you want to support."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para *Next Protocol "
"Negotiation* como se describe en `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"Cuando es verdadero, puede utilizar el método :meth:`SSLContext."
"set_npn_protocols` para anunciar los protocolos que desea soportar."

#: ../Doc/library/ssl.rst:931
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 2.0 protocol."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo SSL 2.0."

#: ../Doc/library/ssl.rst:937
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 3.0 protocol."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo SSL 3.0."

#: ../Doc/library/ssl.rst:943
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.0 protocol."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo TLS 1.0."

#: ../Doc/library/ssl.rst:949
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.1 protocol."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo TLS 1.1."

#: ../Doc/library/ssl.rst:955
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.2 protocol."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo TLS 1.2."

#: ../Doc/library/ssl.rst:961
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.3 protocol."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo TLS 1.3."

#: ../Doc/library/ssl.rst:967
msgid ""
"List of supported TLS channel binding types.  Strings in this list can be "
"used as arguments to :meth:`SSLSocket.get_channel_binding`."
msgstr ""
"Lista de tipos de enlace de canales TLS admitidos. Las cadenas de caracteres "
"en esta lista pueden ser usadas como argumentos para :meth:`SSLSocket."
"get_channel_binding`."

#: ../Doc/library/ssl.rst:974
msgid "The version string of the OpenSSL library loaded by the interpreter::"
msgstr ""
"La cadena de versión de la biblioteca OpenSSL cargada por el intérprete::"

#: ../Doc/library/ssl.rst:983
msgid ""
"A tuple of five integers representing version information about the OpenSSL "
"library::"
msgstr ""
"Una tupla de cinco números enteros representando la información de versión "
"de la biblioteca OpenSSL::"

#: ../Doc/library/ssl.rst:993
msgid "The raw version number of the OpenSSL library, as a single integer::"
msgstr ""
"El número de versión en bruto de la biblioteca OpenSSL, como un único número "
"entero::"

#: ../Doc/library/ssl.rst:1006
msgid ""
"Alert Descriptions from :rfc:`5246` and others. The `IANA TLS Alert Registry "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contains this list and references to the RFCs where their "
"meaning is defined."
msgstr ""
"Descripciones de alertas de :rfc:`5246` y otras. El `IANA TLS Alert Registry "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contiene esta lista y las referencias a las RFC donde se "
"define su significado."

#: ../Doc/library/ssl.rst:1010
msgid ""
"Used as the return value of the callback function in :meth:`SSLContext."
"set_servername_callback`."
msgstr ""
"Se utiliza como valor de retorno de la función callback en :meth:`SSLContext."
"set_servername_callback`."

#: ../Doc/library/ssl.rst:1017
msgid ":class:`enum.IntEnum` collection of ALERT_DESCRIPTION_* constants."
msgstr "Colección :class:`enum.IntEnum` de constantes ALERT_DESCRIPTION_*."

#: ../Doc/library/ssl.rst:1023
msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate Web servers (therefore, it will be used to create client-side "
"sockets)."
msgstr ""
"Opción para :func:`create_default_context` y :meth:`SSLContext."
"load_default_certs`. Este valor indica que el contexto puede utilizarse para "
"autenticar servidores web (por lo tanto, se utilizará para crear sockets del "
"lado del cliente)."

#: ../Doc/library/ssl.rst:1032
msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate Web clients (therefore, it will be used to create server-side "
"sockets)."
msgstr ""
"Opción para :func:`create_default_context` y :meth:`SSLContext."
"load_default_certs`. Este valor indica que el contexto puede utilizarse para "
"autenticar clientes web (por lo tanto, se utilizará para crear sockets del "
"lado del servidor)."

#: ../Doc/library/ssl.rst:1041
msgid ":class:`enum.IntEnum` collection of SSL_ERROR_* constants."
msgstr "Colección :class:`enum.IntEnum` de constantes SSL_ERROR_*."

#: ../Doc/library/ssl.rst:1047
msgid ""
":class:`enum.IntEnum` collection of SSL and TLS versions for :attr:"
"`SSLContext.maximum_version` and :attr:`SSLContext.minimum_version`."
msgstr ""
"Colección :class:`enum.IntEnum` de versiones SSL y TLS para :attr:"
"`SSLContext.maximum_version` y :attr:`SSLContext.minimum_version`."

#: ../Doc/library/ssl.rst:1055
msgid ""
"The minimum or maximum supported SSL or TLS version. These are magic "
"constants. Their values don't reflect the lowest and highest available TLS/"
"SSL versions."
msgstr ""
"La mínima o máxima versión soportada de SSL o TLS. Estas son constantes "
"mágicas. Sus valores no reflejan la mas baja o mas alta versión TLS/SSL "
"disponible."

#: ../Doc/library/ssl.rst:1065
msgid "SSL 3.0 to TLS 1.3."
msgstr "SSL 3.0 a TLS 1.3."

#: ../Doc/library/ssl.rst:1069
msgid "SSL Sockets"
msgstr "Sockets SSL"

#: ../Doc/library/ssl.rst:1073
msgid "SSL sockets provide the following methods of :ref:`socket-objects`:"
msgstr ""
"Los sockets SSL proporcionan los siguientes métodos de :ref:`socket-objects`:"

#: ../Doc/library/ssl.rst:1075
msgid ":meth:`~socket.socket.accept()`"
msgstr ":meth:`~socket.socket.accept()`"

#: ../Doc/library/ssl.rst:1076
msgid ":meth:`~socket.socket.bind()`"
msgstr ":meth:`~socket.socket.bind()`"

#: ../Doc/library/ssl.rst:1077
msgid ":meth:`~socket.socket.close()`"
msgstr ":meth:`~socket.socket.close()`"

#: ../Doc/library/ssl.rst:1078
msgid ":meth:`~socket.socket.connect()`"
msgstr ":meth:`~socket.socket.connect()`"

#: ../Doc/library/ssl.rst:1079
msgid ":meth:`~socket.socket.detach()`"
msgstr ":meth:`~socket.socket.detach()`"

#: ../Doc/library/ssl.rst:1080
msgid ":meth:`~socket.socket.fileno()`"
msgstr ":meth:`~socket.socket.fileno()`"

#: ../Doc/library/ssl.rst:1081
msgid ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"
msgstr ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"

#: ../Doc/library/ssl.rst:1082
msgid ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"
msgstr ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"

#: ../Doc/library/ssl.rst:1083
msgid ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, :"
"meth:`~socket.socket.setblocking()`"
msgstr ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, :"
"meth:`~socket.socket.setblocking()`"

#: ../Doc/library/ssl.rst:1085
msgid ":meth:`~socket.socket.listen()`"
msgstr ":meth:`~socket.socket.listen()`"

#: ../Doc/library/ssl.rst:1086
msgid ":meth:`~socket.socket.makefile()`"
msgstr ":meth:`~socket.socket.makefile()`"

#: ../Doc/library/ssl.rst:1087
msgid ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (but "
"passing a non-zero ``flags`` argument is not allowed)"
msgstr ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (pero no "
"se admite pasar un argumento ``flags`` diferente de cero)"

#: ../Doc/library/ssl.rst:1089
msgid ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (with the "
"same limitation)"
msgstr ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (con la "
"misma limitación)"

#: ../Doc/library/ssl.rst:1091
msgid ""
":meth:`~socket.socket.sendfile()` (but :mod:`os.sendfile` will be used for "
"plain-text sockets only, else :meth:`~socket.socket.send()` will be used)"
msgstr ""
":meth:`~socket.socket.sendfile()` (pero :mod:`os.sendfile` sera utilizado "
"sólo para sockets de texto simple, sino :meth:`~socket.socket.send()` sera "
"utilizado)"

#: ../Doc/library/ssl.rst:1093
msgid ":meth:`~socket.socket.shutdown()`"
msgstr ":meth:`~socket.socket.shutdown()`"

#: ../Doc/library/ssl.rst:1095
msgid ""
"However, since the SSL (and TLS) protocol has its own framing atop of TCP, "
"the SSL sockets abstraction can, in certain respects, diverge from the "
"specification of normal, OS-level sockets.  See especially the :ref:`notes "
"on non-blocking sockets <ssl-nonblocking>`."
msgstr ""
"Sin embargo, dado que el protocolo SSL (y TLS) tiene su propia estructura "
"encima de TCP, la abstracción de los sockets SSL puede, en ciertos aspectos, "
"divergir de la especificación de los sockets normales a nivel de SO. Ver "
"especialmente las :ref:`notas sobre sockets no bloqueantes <ssl-"
"nonblocking>`."

#: ../Doc/library/ssl.rst:1100
msgid ""
"Instances of :class:`SSLSocket` must be created using the :meth:`SSLContext."
"wrap_socket` method."
msgstr ""
"Instancias de :class:`SSLSocket` deben ser creadas usando el método :meth:"
"`SSLContext.wrap_socket`."

#: ../Doc/library/ssl.rst:1103
msgid "The :meth:`sendfile` method was added."
msgstr "El método :meth:`sendfile` ha sido agregado."

#: ../Doc/library/ssl.rst:1106
msgid ""
"The :meth:`shutdown` does not reset the socket timeout each time bytes are "
"received or sent. The socket timeout is now to maximum total duration of the "
"shutdown."
msgstr ""
"El método :meth:`shutdown` no reinicia el tiempo de espera del socket cada "
"vez que se reciben o envían bytes. El tiempo de espera del socket es ahora "
"la máxima duración del cierre."

#: ../Doc/library/ssl.rst:1111
msgid ""
"It is deprecated to create a :class:`SSLSocket` instance directly, use :meth:"
"`SSLContext.wrap_socket` to wrap a socket."
msgstr ""
"Crear una instancia de :class:`SSLSocket` directamente es obsoleto, utilice :"
"meth:`SSLContext.wrap_socket` para envolver un socket."

#: ../Doc/library/ssl.rst:1115
msgid ""
":class:`SSLSocket` instances must to created with :meth:`~SSLContext."
"wrap_socket`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""
"Las instancias de :class:`SSLSocket` deben crearse con :meth:`~SSLContext."
"wrap_socket`. En versiones anteriores, era posible crear instancias "
"directamente. Esto nunca fue documentado ni soportado oficialmente."

#: ../Doc/library/ssl.rst:1121
msgid "SSL sockets also have the following additional methods and attributes:"
msgstr ""
"Los sockets SSL tienen también los siguientes métodos y atributos "
"adicionales:"

#: ../Doc/library/ssl.rst:1125
msgid ""
"Read up to *len* bytes of data from the SSL socket and return the result as "
"a ``bytes`` instance. If *buffer* is specified, then read into the buffer "
"instead, and return the number of bytes read."
msgstr ""
"Lee hasta *len* bytes de datos del socket SSL y retorna el resultado como "
"una instancia ``bytes``. Si *buffer* es especificado, entonces se lee hacia "
"el buffer en su lugar, y retorna el número de bytes leídos."

#: ../Doc/library/ssl.rst:1129
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the read would block."
msgstr ""
"Lanza :exc:`SSLWantReadError` o :exc:`SSLWantWriteError` si el socket es :"
"ref:`no-bloqueante <ssl-nonblocking>` y la lectura se bloquearía."

#: ../Doc/library/ssl.rst:1132
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`read` can also "
"cause write operations."
msgstr ""
"Como en cualquier momento es posible una re-negociación, una llamada a :meth:"
"`read` también puede provocar operaciones de escritura."

#: ../Doc/library/ssl.rst:1135
msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration to read up to *len* "
"bytes."
msgstr ""
"El tiempo de espera del socket ya no se reinicia cada vez que se reciben o "
"envían bytes. El tiempo de espera del socket es ahora la duración total "
"máxima para leer hasta *len* bytes."

#: ../Doc/library/ssl.rst:1140
msgid "Use :meth:`~SSLSocket.recv` instead of :meth:`~SSLSocket.read`."
msgstr "Utilice :meth:`~SSLSocket.recv` en lugar de :meth:`~SSLSocket.read`."

#: ../Doc/library/ssl.rst:1145
msgid ""
"Write *buf* to the SSL socket and return the number of bytes written. The "
"*buf* argument must be an object supporting the buffer interface."
msgstr ""
"Escribe *buf* en el socket SSL y retorna el número de bytes escritos. El "
"argumento *buf* debe ser un objeto que soporte la interfaz buffer."

#: ../Doc/library/ssl.rst:1148
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the write would block."
msgstr ""
"Lanza :exc:`SSLWantReadError` o :exc:`SSLWantWriteError` si el socket es :"
"ref:`no-bloqueante <ssl-nonblocking>` y la escritura se bloquearía."

#: ../Doc/library/ssl.rst:1151
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`write` can "
"also cause read operations."
msgstr ""
"Como en cualquier momento es posible una re-negociación, una llamada a :meth:"
"`write` también puede provocar operaciones de lectura."

#: ../Doc/library/ssl.rst:1154
msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration to write *buf*."
msgstr ""
"El tiempo de espera del socket ya no se reinicia cada vez que se reciben o "
"envían bytes. El tiempo de espera del socket es ahora la duración total "
"máxima para escribir *buf*."

#: ../Doc/library/ssl.rst:1158
msgid "Use :meth:`~SSLSocket.send` instead of :meth:`~SSLSocket.write`."
msgstr "Utilice :meth:`~SSLSocket.send` en lugar de :meth:`~SSLSocket.write`."

#: ../Doc/library/ssl.rst:1163
msgid ""
"The :meth:`~SSLSocket.read` and :meth:`~SSLSocket.write` methods are the low-"
"level methods that read and write unencrypted, application-level data and "
"decrypt/encrypt it to encrypted, wire-level data. These methods require an "
"active SSL connection, i.e. the handshake was completed and :meth:`SSLSocket."
"unwrap` was not called."
msgstr ""
"Los métodos :meth:`~SSLSocket.read` y :meth:`~SSLSocket.write` son los "
"métodos de bajo nivel que leen y escriben datos no cifrados a nivel de "
"aplicación y los descifran/cifran a datos cifrados a nivel de cable. Estos "
"métodos requieren una conexión SSL activa, es decir, que se haya completado "
"el handshake y no se haya llamado a :meth:`SSLSocket.unwrap`."

#: ../Doc/library/ssl.rst:1169
msgid ""
"Normally you should use the socket API methods like :meth:`~socket.socket."
"recv` and :meth:`~socket.socket.send` instead of these methods."
msgstr ""
"Normalmente se deberían utilizar los métodos de la API de sockets como :meth:"
"`~socket.socket.recv` y :meth:`~socket.socket.send` en lugar de estos "
"métodos."

#: ../Doc/library/ssl.rst:1175
msgid "Perform the SSL setup handshake."
msgstr "Realiza el handshake de configuración SSL."

#: ../Doc/library/ssl.rst:1177
msgid ""
"The handshake method also performs :func:`match_hostname` when the :attr:"
"`~SSLContext.check_hostname` attribute of the socket's :attr:`~SSLSocket."
"context` is true."
msgstr ""
"El método handshake también realiza :func:`match_hostname` cuando el "
"atributo :attr:`~SSLContext.check_hostname` del :attr:`~SSLSocket.context` "
"del socket es verdadero."

#: ../Doc/library/ssl.rst:1182
msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration of the handshake."
msgstr ""
"El tiempo de espera del socket ya no se reinicia cada vez que se reciben o "
"envían bytes. El tiempo de espera del socket es ahora la duración total "
"máxima del handshake."

#: ../Doc/library/ssl.rst:1186
msgid ""
"Hostname or IP address is matched by OpenSSL during handshake. The function :"
"func:`match_hostname` is no longer used. In case OpenSSL refuses a hostname "
"or IP address, the handshake is aborted early and a TLS alert message is "
"send to the peer."
msgstr ""
"El hostname o la dirección IP son comparados por OpenSSL durante el "
"handshake. La función :func:`match_hostname` ya no se utiliza. En caso de "
"que OpenSSL rechace un hostname o dirección IP, el handshake se aborta antes "
"de tiempo y se envía un mensaje de alerta TLS al peer."

#: ../Doc/library/ssl.rst:1194
msgid ""
"If there is no certificate for the peer on the other end of the connection, "
"return ``None``.  If the SSL handshake hasn't been done yet, raise :exc:"
"`ValueError`."
msgstr ""
"Si no hay un certificado para el peer en el otro extremo de la conexión, "
"devuelve ``None``. Si el handshake SSL no se ha realizado todavía, lanza :"
"exc:`ValueError`."

#: ../Doc/library/ssl.rst:1198
msgid ""
"If the ``binary_form`` parameter is :const:`False`, and a certificate was "
"received from the peer, this method returns a :class:`dict` instance.  If "
"the certificate was not validated, the dict is empty.  If the certificate "
"was validated, it returns a dict with several keys, amongst them ``subject`` "
"(the principal for which the certificate was issued) and ``issuer`` (the "
"principal issuing the certificate).  If a certificate contains an instance "
"of the *Subject Alternative Name* extension (see :rfc:`3280`), there will "
"also be a ``subjectAltName`` key in the dictionary."
msgstr ""
"Si el parámetro ``binary_form`` es :const:`False`, y se ha recibido un "
"certificado del peer, este método devuelve una instancia :class:`dict`. Si "
"el certificado no fue validado, el dict está vacío. Si el certificado fue "
"validado, devuelve un dict con varias claves, entre ellas ``subject`` (la "
"entidad para la que se emitió el certificado) y ``issuer`` (la entidad que "
"emite el certificado). Si un certificado contiene una instancia de la "
"extensión *Subject Alternative Name* (véase :rfc:`3280`), también habrá una "
"clave ``subjectAltName`` en el diccionario."

#: ../Doc/library/ssl.rst:1207
msgid ""
"The ``subject`` and ``issuer`` fields are tuples containing the sequence of "
"relative distinguished names (RDNs) given in the certificate's data "
"structure for the respective fields, and each RDN is a sequence of name-"
"value pairs.  Here is a real-world example::"
msgstr ""
"Los campos ``subject`` y ``issuer`` son tuplas que contienen la secuencia de "
"nombres distinguidos relativos (RDNs) indicados en la estructura de datos "
"del certificado para los campos respectivos, y cada RDN es una secuencia de "
"pares nombre-valor. Este es un ejemplo del mundo real::"

#: ../Doc/library/ssl.rst:1233
msgid ""
"To validate a certificate for a particular service, you can use the :func:"
"`match_hostname` function."
msgstr ""
"Para validar un certificado para un servicio concreto, puede utilizar la "
"función :func:`match_hostname`."

#: ../Doc/library/ssl.rst:1236
msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire certificate "
"as a sequence of bytes, or :const:`None` if the peer did not provide a "
"certificate.  Whether the peer provides a certificate depends on the SSL "
"socket's role:"
msgstr ""
"Si el parámetro ``binary_form`` es :const:`True`, y se proporcionó un "
"certificado, este método devuelve la forma codificada en DER del certificado "
"completo como una secuencia de bytes, o :const:`None` si el par no "
"proporcionó un certificado. El hecho de que el par proporcione un "
"certificado depende del rol del socket SSL:"

#: ../Doc/library/ssl.rst:1242
msgid ""
"for a client SSL socket, the server will always provide a certificate, "
"regardless of whether validation was required;"
msgstr ""
"para un socket SSL cliente, el servidor siempre proporcionará un "
"certificado, independientemente de si se requirió la validación;"

#: ../Doc/library/ssl.rst:1245
msgid ""
"for a server SSL socket, the client will only provide a certificate when "
"requested by the server; therefore :meth:`getpeercert` will return :const:"
"`None` if you used :const:`CERT_NONE` (rather than :const:`CERT_OPTIONAL` "
"or :const:`CERT_REQUIRED`)."
msgstr ""
"para un socket SSL servidor, el cliente sólo proporcionará un certificado "
"cuando lo solicite el servidor; por lo tanto :meth:`getpeercert` devolverá :"
"const:`None` si ha utilizado :const:`CERT_NONE` (en lugar de :const:"
"`CERT_OPTIONAL` o :const:`CERT REQUIRED`)."

#: ../Doc/library/ssl.rst:1250
msgid ""
"The returned dictionary includes additional items such as ``issuer`` and "
"``notBefore``."
msgstr ""
"El diccionario devuelto incluye elementos adicionales tales como ``issuer`` "
"y ``notBefore``."

#: ../Doc/library/ssl.rst:1254
msgid ""
":exc:`ValueError` is raised when the handshake isn't done. The returned "
"dictionary includes additional X509v3 extension items   such as "
"``crlDistributionPoints``, ``caIssuers`` and ``OCSP`` URIs."
msgstr ""
":exc:`ValueError` se lanza cuando no se realiza el handshake. El diccionario "
"devuelto incluye elementos de extensión X509v3 adicionales como "
"``crlDistributionPoints``, ``caIssuers`` y ``OCSP`` URIs."

#: ../Doc/library/ssl.rst:1259
msgid "IPv6 address strings no longer have a trailing new line."
msgstr "Las cadenas de direcciones IPv6 ya no tienen una nueva línea al final."

#: ../Doc/library/ssl.rst:1264
msgid ""
"Returns a three-value tuple containing the name of the cipher being used, "
"the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr ""
"Retorna una tupla de tres valores que contiene el nombre del cifrado que se "
"está utilizando, la versión del protocolo SSL que define su uso y el número "
"de bits secretos que se están utilizando. Si no se ha establecido ninguna "
"conexión, retorna ``None``."

#: ../Doc/library/ssl.rst:1270
msgid ""
"Return the list of ciphers shared by the client during the handshake.  Each "
"entry of the returned list is a three-value tuple containing the name of the "
"cipher, the version of the SSL protocol that defines its use, and the number "
"of secret bits the cipher uses.  :meth:`~SSLSocket.shared_ciphers` returns "
"``None`` if no connection has been established or the socket is a client "
"socket."
msgstr ""
"Retorna la lista de cifrados compartidos por el cliente durante el "
"handshake. Cada entrada de la lista devuelta es una tupla de tres valores "
"que contiene el nombre del cifrado, la versión del protocolo SSL que define "
"su uso y el número de bits secretos que utiliza el cifrado. :meth:"
"`~SSLSocket.shared_ciphers`` retorna ``None`` si no se ha establecido "
"ninguna conexión o el socket es un socket cliente."

#: ../Doc/library/ssl.rst:1281
msgid ""
"Return the compression algorithm being used as a string, or ``None`` if the "
"connection isn't compressed."
msgstr ""
"Retorna el algoritmo de compresión utilizado como una cadena de caracteres, "
"o ``None`` si la conexión no está comprimida."

#: ../Doc/library/ssl.rst:1284
msgid ""
"If the higher-level protocol supports its own compression mechanism, you can "
"use :data:`OP_NO_COMPRESSION` to disable SSL-level compression."
msgstr ""
"Si el protocolo de nivel superior soporta su propio mecanismo de compresión, "
"puede utilizar :data:`OP_NO_COMPRESSION` para desactivar la compresión a "
"nivel de SSL."

#: ../Doc/library/ssl.rst:1291
msgid ""
"Get channel binding data for current connection, as a bytes object.  Returns "
"``None`` if not connected or the handshake has not been completed."
msgstr ""
"Obtiene los datos de enlace del canal para la conexión actual, como un "
"objeto bytes. Retorna ``None`` si no está conectado o no se ha completado el "
"handshake."

#: ../Doc/library/ssl.rst:1294
msgid ""
"The *cb_type* parameter allow selection of the desired channel binding type. "
"Valid channel binding types are listed in the :data:`CHANNEL_BINDING_TYPES` "
"list.  Currently only the 'tls-unique' channel binding, defined by :rfc:"
"`5929`, is supported.  :exc:`ValueError` will be raised if an unsupported "
"channel binding type is requested."
msgstr ""
"El parámetro *cb_type* permite seleccionar el tipo de enlace de canal "
"deseado. Los tipos de enlace de canal válidos se enumeran en la lista :data:"
"`CHANNEL_BINDING_TYPES`. Actualmente, sólo se admite la vinculación de canal "
"'tls-unique', definida por :rfc:`5929`. :exc:`ValueError` se lanzará si se "
"solicita un tipo de vinculación de canal no admitido."

#: ../Doc/library/ssl.rst:1304
msgid ""
"Return the protocol that was selected during the TLS handshake.  If :meth:"
"`SSLContext.set_alpn_protocols` was not called, if the other party does not "
"support ALPN, if this socket does not support any of the client's proposed "
"protocols, or if the handshake has not happened yet, ``None`` is returned."
msgstr ""
"Retorna el protocolo que fue seleccionado durante el handshake TLS. Si no se "
"ha llamado a :meth:`SSLContext.set_alpn_protocols`, si la otra parte no "
"soporta ALPN, si este socket no soporta ninguno de los protocolos propuestos "
"por el cliente, o si el handshake no ha ocurrido todavía, se devuelve "
"``None``."

#: ../Doc/library/ssl.rst:1314
msgid ""
"Return the higher-level protocol that was selected during the TLS/SSL "
"handshake. If :meth:`SSLContext.set_npn_protocols` was not called, or if the "
"other party does not support NPN, or if the handshake has not yet happened, "
"this will return ``None``."
msgstr ""
"Devuelve el protocolo de nivel superior que se seleccionó durante el "
"handshake TLS/SSL. Si no se llamó a :meth:`SSLContext.set_npn_protocols`, o "
"si la otra parte no soporta NPN, o si el handshake aún no ha ocurrido, esto "
"devolverá ``None``."

#: ../Doc/library/ssl.rst:1323
msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the "
"underlying socket, and returns the underlying socket object.  This can be "
"used to go from encrypted operation over a connection to unencrypted.  The "
"returned socket should always be used for further communication with the "
"other side of the connection, rather than the original socket."
msgstr ""
"Realiza el handshake de cierre de SSL, que elimina la capa TLS del socket "
"subyacente, y devuelve el objeto socket subyacente. Esto puede utilizarse "
"para pasar de una operación encriptada sobre una conexión a una sin "
"encriptar. El socket devuelto debe utilizarse siempre para la comunicación "
"posterior con el otro lado de la conexión, en lugar del socket original."

#: ../Doc/library/ssl.rst:1331
msgid ""
"Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA can "
"only be initiated for a TLS 1.3 connection from a server-side socket, after "
"the initial TLS handshake and with PHA enabled on both sides, see :attr:"
"`SSLContext.post_handshake_auth`."
msgstr ""
"Solicita la autenticación post-handshake (PHA) de un cliente TLS 1.3. PHA "
"sólo puede iniciarse para una conexión TLS 1.3 desde un socket del lado del "
"servidor, después del handshake TLS inicial y con PHA habilitado en ambos "
"lados, ver :attr:`SSLContext.post_handshake_auth`."

#: ../Doc/library/ssl.rst:1336
msgid ""
"The method does not perform a cert exchange immediately. The server-side "
"sends a CertificateRequest during the next write event and expects the "
"client to respond with a certificate on the next read event."
msgstr ""
"El método no realiza un intercambio de certificados inmediatamente. El lado "
"del servidor envía una CertificateRequest durante el siguiente evento de "
"escritura y espera que el cliente responda con un certificado en el "
"siguiente evento de lectura."

#: ../Doc/library/ssl.rst:1340
msgid ""
"If any precondition isn't met (e.g. not TLS 1.3, PHA not enabled), an :exc:"
"`SSLError` is raised."
msgstr ""
"Si alguna precondición no se cumple (por ejemplo, no es TLS 1.3, PHA no está "
"habilitado), se genera un :exc:`SSLError`."

#: ../Doc/library/ssl.rst:1344
msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the method raises :exc:`NotImplementedError`."
msgstr ""
"Sólo está disponible con OpenSSL 1.1.1 y TLS 1.3 habilitados. Sin el soporte "
"de TLS 1.3, el método lanza :exc:`NotImplementedError`."

#: ../Doc/library/ssl.rst:1351
msgid ""
"Return the actual SSL protocol version negotiated by the connection as a "
"string, or ``None`` is no secure connection is established. As of this "
"writing, possible return values include ``\"SSLv2\"``, ``\"SSLv3\"``, ``"
"\"TLSv1\"``, ``\"TLSv1.1\"`` and ``\"TLSv1.2\"``. Recent OpenSSL versions "
"may define more return values."
msgstr ""
"Devuelve la versión actual del protocolo SSL negociada por la conexión como "
"una cadena de caracteres, o ``None`` si no se ha establecido ninguna "
"conexión segura. En este momento, los posibles valores de retorno incluyen ``"
"\"SSLv2\"``, ``\"SSLv3\"``, ``\"TLSv1\"``, ``\"TLSv1.1\"`` y ``"
"\"TLSv1.2\"``. Las versiones recientes de OpenSSL pueden definir más valores "
"de retorno."

#: ../Doc/library/ssl.rst:1361
msgid ""
"Returns the number of already decrypted bytes available for read, pending on "
"the connection."
msgstr ""
"Retorna el número de bytes ya descifrados disponibles para leer, pendientes "
"de la conexión."

#: ../Doc/library/ssl.rst:1366
msgid ""
"The :class:`SSLContext` object this SSL socket is tied to.  If the SSL "
"socket was created using the deprecated :func:`wrap_socket` function (rather "
"than :meth:`SSLContext.wrap_socket`), this is a custom context object "
"created for this SSL socket."
msgstr ""
"El objeto :class:`SSLContext` al que está vinculado este socket SSL. Si el "
"socket SSL fue creado usando la función obsoleta :func:`wrap_socket` (en "
"lugar de :meth:`SSLContext.wrap_socket`), este es un objeto de contexto "
"personalizado creado para este socket SSL."

#: ../Doc/library/ssl.rst:1375
msgid ""
"A boolean which is ``True`` for server-side sockets and ``False`` for client-"
"side sockets."
msgstr ""
"Un booleano que es ``True`` para los sockets del lado del servidor y "
"``False`` para los sockets del lado del cliente."

#: ../Doc/library/ssl.rst:1382
msgid ""
"Hostname of the server: :class:`str` type, or ``None`` for server-side "
"socket or if the hostname was not specified in the constructor."
msgstr ""
"Hostname del servidor: tipo :class:`str`, o ``None`` para el socket del lado "
"del servidor o si el hostname no fue especificado en el constructor."

#: ../Doc/library/ssl.rst:1387
msgid ""
"The attribute is now always ASCII text. When ``server_hostname`` is an "
"internationalized domain name (IDN), this attribute now stores the A-label "
"form (``\"xn--pythn-mua.org\"``), rather than the U-label form (``\"pythön."
"org\"``)."
msgstr ""
"El atributo es ahora siempre texto ASCII. Cuando ``server_hostname`` es un "
"nombre de dominio internacionalizado (IDN), este atributo almacena ahora la "
"forma de etiqueta A (``\"xn--pythn-mua.org\"``), en lugar de la forma de "
"etiqueta U (``\"pythön.org\"``)."

#: ../Doc/library/ssl.rst:1395
msgid ""
"The :class:`SSLSession` for this SSL connection. The session is available "
"for client and server side sockets after the TLS handshake has been "
"performed. For client sockets the session can be set before :meth:"
"`~SSLSocket.do_handshake` has been called to reuse a session."
msgstr ""
"La :class:`SSLSession` para esta conexión SSL. La sesión está disponible "
"para los sockets del lado del cliente y del servidor después de que se haya "
"realizado el handshake TLS. Para los sockets del cliente la sesión puede ser "
"establecida antes de que :meth:`~SSLSocket.do_handshake` haya sido llamado "
"para reutilizar una sesión."

#: ../Doc/library/ssl.rst:1408
msgid "SSL Contexts"
msgstr "Contextos SSL"

#: ../Doc/library/ssl.rst:1412
msgid ""
"An SSL context holds various data longer-lived than single SSL connections, "
"such as SSL configuration options, certificate(s) and private key(s). It "
"also manages a cache of SSL sessions for server-side sockets, in order to "
"speed up repeated connections from the same clients."
msgstr ""
"Un contexto SSL contiene varios datos más duraderos que las conexiones SSL "
"individuales, como opciones de configuración SSL, certificado(s) y clave(s) "
"privada(s). También gestiona un cache de sesiones SSL para sockets del lado "
"del servidor, para acelerar conexiones repetidas de los mismos clientes."

#: ../Doc/library/ssl.rst:1419
msgid ""
"Create a new SSL context.  You may pass *protocol* which must be one of the "
"``PROTOCOL_*`` constants defined in this module.  The parameter specifies "
"which version of the SSL protocol to use.  Typically, the server chooses a "
"particular protocol version, and the client must adapt to the server's "
"choice.  Most of the versions are not interoperable with the other "
"versions.  If not specified, the default is :data:`PROTOCOL_TLS`; it "
"provides the most compatibility with other versions."
msgstr ""
"Crea un nuevo contexto SSL. Puede pasar *protocolo* que debe ser una de las "
"constantes ``PROTOCOL_*`` definidas en este módulo. El parámetro especifica "
"la versión del protocolo SSL a utilizar. Típicamente, el servidor elige una "
"versión particular del protocolo, y el cliente debe adaptarse a la elección "
"del servidor. La mayoría de las versiones no son interoperables con las "
"demás. Si no se especifica, el valor por defecto es :data:`PROTOCOL_TLS`; "
"proporciona la mayor compatibilidad con otras versiones."

#: ../Doc/library/ssl.rst:1428
msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr ""
"Esta es una tabla que muestra qué versiones de un cliente (en la parte "
"inferior) pueden conectarse a qué versiones de un servidor (en la parte "
"superior):"

#: ../Doc/library/ssl.rst:1434
msgid "*client* / **server**"
msgstr "*cliente* / **servidor**"

#: ../Doc/library/ssl.rst:1434
msgid "**SSLv2**"
msgstr "**SSLv2**"

#: ../Doc/library/ssl.rst:1434
msgid "**SSLv3**"
msgstr "**SSLv3**"

#: ../Doc/library/ssl.rst:1434
msgid "**TLS** [3]_"
msgstr "**TLS** [3]_"

#: ../Doc/library/ssl.rst:1434
msgid "**TLSv1**"
msgstr "**TLSv1**"

#: ../Doc/library/ssl.rst:1434
msgid "**TLSv1.1**"
msgstr "**TLSv1.1**"

#: ../Doc/library/ssl.rst:1434
msgid "**TLSv1.2**"
msgstr "**TLSv1.2**"

#: ../Doc/library/ssl.rst:1436
msgid "*SSLv2*"
msgstr "*SSLv2*"

#: ../Doc/library/ssl.rst:1436 ../Doc/library/ssl.rst:1437
#: ../Doc/library/ssl.rst:1438 ../Doc/library/ssl.rst:1439
#: ../Doc/library/ssl.rst:1440 ../Doc/library/ssl.rst:1441
msgid "yes"
msgstr "si"

#: ../Doc/library/ssl.rst:1436 ../Doc/library/ssl.rst:1437
#: ../Doc/library/ssl.rst:1439 ../Doc/library/ssl.rst:1440
#: ../Doc/library/ssl.rst:1441
msgid "no"
msgstr "no"

#: ../Doc/library/ssl.rst:1436 ../Doc/library/ssl.rst:1438
msgid "no [1]_"
msgstr "no [1]_"

#: ../Doc/library/ssl.rst:1437
msgid "*SSLv3*"
msgstr "*SSLv3*"

#: ../Doc/library/ssl.rst:1437 ../Doc/library/ssl.rst:1438
msgid "no [2]_"
msgstr "no [2]_"

#: ../Doc/library/ssl.rst:1438
msgid "*TLS* (*SSLv23*) [3]_"
msgstr "*TLS* (*SSLv23*) [3]_"

#: ../Doc/library/ssl.rst:1439
msgid "*TLSv1*"
msgstr "*TLSv1*"

#: ../Doc/library/ssl.rst:1440
msgid "*TLSv1.1*"
msgstr "*TLSv1.1*"

#: ../Doc/library/ssl.rst:1441
msgid "*TLSv1.2*"
msgstr "*TLSv1.2*"

#: ../Doc/library/ssl.rst:1444
msgid "Footnotes"
msgstr "Notas a pie de página"

#: ../Doc/library/ssl.rst:1445
msgid ":class:`SSLContext` disables SSLv2 with :data:`OP_NO_SSLv2` by default."
msgstr ""
":class:`SSLContext` desactiva SSLv2 con :data:`OP_NO_SSLv2` por defecto."

#: ../Doc/library/ssl.rst:1446
msgid ":class:`SSLContext` disables SSLv3 with :data:`OP_NO_SSLv3` by default."
msgstr ""
":class:`SSLContext` desactiva SSLv3 con :data:`OP_NO_SSLv3` por defecto."

#: ../Doc/library/ssl.rst:1447
msgid ""
"TLS 1.3 protocol will be available with :data:`PROTOCOL_TLS` in OpenSSL >= "
"1.1.1. There is no dedicated PROTOCOL constant for just TLS 1.3."
msgstr ""
"El protocolo TLS 1.3 estará disponible con :data:`PROTOCOL_TLS` en OpenSSL "
">= 1.1.1. No existe una constante PROTOCOL dedicada sólo a TLS 1.3."

#: ../Doc/library/ssl.rst:1452
msgid ""
":func:`create_default_context` lets the :mod:`ssl` module choose security "
"settings for a given purpose."
msgstr ""
":func:`create_default_context` permite al módulo :mod:`ssl` elegir la "
"configuración de seguridad para un propósito determinado."

#: ../Doc/library/ssl.rst:1457
msgid ""
"The context is created with secure default values. The options :data:"
"`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, :data:"
"`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2` (except "
"for :data:`PROTOCOL_SSLv2`), and :data:`OP_NO_SSLv3` (except for :data:"
"`PROTOCOL_SSLv3`) are set by default. The initial cipher suite list contains "
"only ``HIGH`` ciphers, no ``NULL`` ciphers and no ``MD5`` ciphers (except "
"for :data:`PROTOCOL_SSLv2`)."
msgstr ""

#: ../Doc/library/ssl.rst:1467
msgid ":class:`SSLContext` objects have the following methods and attributes:"
msgstr ""

#: ../Doc/library/ssl.rst:1471
msgid ""
"Get statistics about quantities of loaded X.509 certificates, count of X.509 "
"certificates flagged as CA certificates and certificate revocation lists as "
"dictionary."
msgstr ""

#: ../Doc/library/ssl.rst:1475
msgid "Example for a context with one CA cert and one other cert::"
msgstr ""

#: ../Doc/library/ssl.rst:1485
msgid ""
"Load a private key and the corresponding certificate.  The *certfile* string "
"must be the path to a single file in PEM format containing the certificate "
"as well as any number of CA certificates needed to establish the "
"certificate's authenticity.  The *keyfile* string, if present, must point to "
"a file containing the private key in.  Otherwise the private key will be "
"taken from *certfile* as well.  See the discussion of :ref:`ssl-"
"certificates` for more information on how the certificate is stored in the "
"*certfile*."
msgstr ""

#: ../Doc/library/ssl.rst:1494
msgid ""
"The *password* argument may be a function to call to get the password for "
"decrypting the private key.  It will only be called if the private key is "
"encrypted and a password is necessary.  It will be called with no arguments, "
"and it should return a string, bytes, or bytearray.  If the return value is "
"a string it will be encoded as UTF-8 before using it to decrypt the key. "
"Alternatively a string, bytes, or bytearray value may be supplied directly "
"as the *password* argument.  It will be ignored if the private key is not "
"encrypted and no password is needed."
msgstr ""

#: ../Doc/library/ssl.rst:1503
msgid ""
"If the *password* argument is not specified and a password is required, "
"OpenSSL's built-in password prompting mechanism will be used to "
"interactively prompt the user for a password."
msgstr ""

#: ../Doc/library/ssl.rst:1507
msgid ""
"An :class:`SSLError` is raised if the private key doesn't match with the "
"certificate."
msgstr ""

#: ../Doc/library/ssl.rst:1510
msgid "New optional argument *password*."
msgstr ""

#: ../Doc/library/ssl.rst:1515
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from "
"default locations. On Windows it loads CA certs from the ``CA`` and ``ROOT`` "
"system stores. On other systems it calls :meth:`SSLContext."
"set_default_verify_paths`. In the future the method may load CA certificates "
"from other locations, too."
msgstr ""

#: ../Doc/library/ssl.rst:1521
msgid ""
"The *purpose* flag specifies what kind of CA certificates are loaded. The "
"default settings :data:`Purpose.SERVER_AUTH` loads certificates, that are "
"flagged and trusted for TLS web server authentication (client side "
"sockets). :data:`Purpose.CLIENT_AUTH` loads CA certificates for client "
"certificate verification on the server side."
msgstr ""

#: ../Doc/library/ssl.rst:1531
msgid ""
"Load a set of \"certification authority\" (CA) certificates used to validate "
"other peers' certificates when :data:`verify_mode` is other than :data:"
"`CERT_NONE`.  At least one of *cafile* or *capath* must be specified."
msgstr ""

#: ../Doc/library/ssl.rst:1535
msgid ""
"This method can also load certification revocation lists (CRLs) in PEM or "
"DER format. In order to make use of CRLs, :attr:`SSLContext.verify_flags` "
"must be configured properly."
msgstr ""

#: ../Doc/library/ssl.rst:1539
msgid ""
"The *cafile* string, if present, is the path to a file of concatenated CA "
"certificates in PEM format. See the discussion of :ref:`ssl-certificates` "
"for more information about how to arrange the certificates in this file."
msgstr ""

#: ../Doc/library/ssl.rst:1544
msgid ""
"The *capath* string, if present, is the path to a directory containing "
"several CA certificates in PEM format, following an `OpenSSL specific layout "
"<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations."
"html>`_."
msgstr ""

#: ../Doc/library/ssl.rst:1549
msgid ""
"The *cadata* object, if present, is either an ASCII string of one or more "
"PEM-encoded certificates or a :term:`bytes-like object` of DER-encoded "
"certificates. Like with *capath* extra lines around PEM-encoded certificates "
"are ignored but at least one certificate must be present."
msgstr ""

#: ../Doc/library/ssl.rst:1554
msgid "New optional argument *cadata*"
msgstr ""

#: ../Doc/library/ssl.rst:1559
msgid ""
"Get a list of loaded \"certification authority\" (CA) certificates. If the "
"``binary_form`` parameter is :const:`False` each list entry is a dict like "
"the output of :meth:`SSLSocket.getpeercert`. Otherwise the method returns a "
"list of DER-encoded certificates. The returned list does not contain "
"certificates from *capath* unless a certificate was requested and loaded by "
"a SSL connection."
msgstr ""

#: ../Doc/library/ssl.rst:1567
msgid ""
"Certificates in a capath directory aren't loaded unless they have been used "
"at least once."
msgstr ""

#: ../Doc/library/ssl.rst:1574
msgid ""
"Get a list of enabled ciphers. The list is in order of cipher priority. See :"
"meth:`SSLContext.set_ciphers`."
msgstr ""

#: ../Doc/library/ssl.rst:1597
msgid "On OpenSSL 1.1 and newer the cipher dict contains additional fields::"
msgstr ""

#: ../Doc/library/ssl.rst:1626
msgid ":ref:`Availability <availability>`: OpenSSL 1.0.2+."
msgstr ""

#: ../Doc/library/ssl.rst:1631
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from a "
"filesystem path defined when building the OpenSSL library.  Unfortunately, "
"there's no easy way to know whether this method succeeds: no error is "
"returned if no certificates are to be found.  When the OpenSSL library is "
"provided as part of the operating system, though, it is likely to be "
"configured properly."
msgstr ""

#: ../Doc/library/ssl.rst:1640
msgid ""
"Set the available ciphers for sockets created with this context. It should "
"be a string in the `OpenSSL cipher list format <https://www.openssl.org/docs/"
"manmaster/man1/ciphers.html>`_. If no cipher can be selected (because "
"compile-time options or other configuration forbids use of all the specified "
"ciphers), an :class:`SSLError` will be raised."
msgstr ""

#: ../Doc/library/ssl.rst:1648
msgid ""
"when connected, the :meth:`SSLSocket.cipher` method of SSL sockets will give "
"the currently selected cipher."
msgstr ""

#: ../Doc/library/ssl.rst:1651
msgid ""
"OpenSSL 1.1.1 has TLS 1.3 cipher suites enabled by default. The suites "
"cannot be disabled with :meth:`~SSLContext.set_ciphers`."
msgstr ""

#: ../Doc/library/ssl.rst:1656
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of ASCII strings, like ``['http/1.1', "
"'spdy/2']``, ordered by preference. The selection of a protocol will happen "
"during the handshake, and will play out according to :rfc:`7301`. After a "
"successful handshake, the :meth:`SSLSocket.selected_alpn_protocol` method "
"will return the agreed-upon protocol."
msgstr ""

#: ../Doc/library/ssl.rst:1663
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_ALPN` is "
"``False``."
msgstr ""

#: ../Doc/library/ssl.rst:1666
msgid ""
"OpenSSL 1.1.0 to 1.1.0e will abort the handshake and raise :exc:`SSLError` "
"when both sides support ALPN but cannot agree on a protocol. 1.1.0f+ behaves "
"like 1.0.2, :meth:`SSLSocket.selected_alpn_protocol` returns None."
msgstr ""

#: ../Doc/library/ssl.rst:1674
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of strings, like ``['http/1.1', 'spdy/2']``, "
"ordered by preference. The selection of a protocol will happen during the "
"handshake, and will play out according to the `Application Layer Protocol "
"Negotiation <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. After a successful handshake, the :meth:"
"`SSLSocket.selected_npn_protocol` method will return the agreed-upon "
"protocol."
msgstr ""

#: ../Doc/library/ssl.rst:1682
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_NPN` is "
"``False``."
msgstr ""

#: ../Doc/library/ssl.rst:1689
msgid ""
"Register a callback function that will be called after the TLS Client Hello "
"handshake message has been received by the SSL/TLS server when the TLS "
"client specifies a server name indication. The server name indication "
"mechanism is specified in :rfc:`6066` section 3 - Server Name Indication."
msgstr ""

#: ../Doc/library/ssl.rst:1694
msgid ""
"Only one callback can be set per ``SSLContext``.  If *sni_callback* is set "
"to ``None`` then the callback is disabled. Calling this function a "
"subsequent time will disable the previously registered callback."
msgstr ""

#: ../Doc/library/ssl.rst:1698
msgid ""
"The callback function will be called with three arguments; the first being "
"the :class:`ssl.SSLSocket`, the second is a string that represents the "
"server name that the client is intending to communicate (or :const:`None` if "
"the TLS Client Hello does not contain a server name) and the third argument "
"is the original :class:`SSLContext`. The server name argument is text. For "
"internationalized domain name, the server name is an IDN A-label (``\"xn--"
"pythn-mua.org\"``)."
msgstr ""

#: ../Doc/library/ssl.rst:1706
msgid ""
"A typical use of this callback is to change the :class:`ssl.SSLSocket`'s :"
"attr:`SSLSocket.context` attribute to a new object of type :class:"
"`SSLContext` representing a certificate chain that matches the server name."
msgstr ""

#: ../Doc/library/ssl.rst:1711
msgid ""
"Due to the early negotiation phase of the TLS connection, only limited "
"methods and attributes are usable like :meth:`SSLSocket."
"selected_alpn_protocol` and :attr:`SSLSocket.context`. :meth:`SSLSocket."
"getpeercert`, :meth:`SSLSocket.getpeercert`, :meth:`SSLSocket.cipher` and :"
"meth:`SSLSocket.compress` methods require that the TLS connection has "
"progressed beyond the TLS Client Hello and therefore will not contain return "
"meaningful values nor can they be called safely."
msgstr ""

#: ../Doc/library/ssl.rst:1719
msgid ""
"The *sni_callback* function must return ``None`` to allow the TLS "
"negotiation to continue.  If a TLS failure is required, a constant :const:"
"`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` can be returned.  "
"Other return values will result in a TLS fatal error with :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR`."
msgstr ""

#: ../Doc/library/ssl.rst:1725
msgid ""
"If an exception is raised from the *sni_callback* function the TLS "
"connection will terminate with a fatal TLS alert message :const:"
"`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."
msgstr ""

#: ../Doc/library/ssl.rst:1729
msgid ""
"This method will raise :exc:`NotImplementedError` if the OpenSSL library had "
"OPENSSL_NO_TLSEXT defined when it was built."
msgstr ""

#: ../Doc/library/ssl.rst:1736
msgid ""
"This is a legacy API retained for backwards compatibility. When possible, "
"you should use :attr:`sni_callback` instead. The given "
"*server_name_callback* is similar to *sni_callback*, except that when the "
"server hostname is an IDN-encoded internationalized domain name, the "
"*server_name_callback* receives a decoded U-label (``\"pythön.org\"``)."
msgstr ""

#: ../Doc/library/ssl.rst:1742
msgid ""
"If there is an decoding error on the server name, the TLS connection will "
"terminate with an :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` fatal TLS alert "
"message to the client."
msgstr ""

#: ../Doc/library/ssl.rst:1750
msgid ""
"Load the key generation parameters for Diffie-Hellman (DH) key exchange. "
"Using DH key exchange improves forward secrecy at the expense of "
"computational resources (both on the server and on the client). The *dhfile* "
"parameter should be the path to a file containing DH parameters in PEM "
"format."
msgstr ""

#: ../Doc/library/ssl.rst:1756
msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_DH_USE` option to further improve security."
msgstr ""

#: ../Doc/library/ssl.rst:1763
msgid ""
"Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key "
"exchange.  ECDH is significantly faster than regular DH while arguably as "
"secure.  The *curve_name* parameter should be a string describing a well-"
"known elliptic curve, for example ``prime256v1`` for a widely supported "
"curve."
msgstr ""

#: ../Doc/library/ssl.rst:1769
msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_ECDH_USE` option to further improve security."
msgstr ""

#: ../Doc/library/ssl.rst:1772
msgid "This method is not available if :data:`HAS_ECDH` is ``False``."
msgstr ""

#: ../Doc/library/ssl.rst:1777
msgid ""
"`SSL/TLS & Perfect Forward Secrecy <https://vincent.bernat.im/en/blog/2011-"
"ssl-perfect-forward-secrecy>`_"
msgstr ""

#: ../Doc/library/ssl.rst:1778
msgid "Vincent Bernat."
msgstr "Vincent Bernat."

#: ../Doc/library/ssl.rst:1784
msgid ""
"Wrap an existing Python socket *sock* and return an instance of :attr:"
"`SSLContext.sslsocket_class` (default :class:`SSLSocket`). The returned SSL "
"socket is tied to the context, its settings and certificates. *sock* must be "
"a :data:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""

#: ../Doc/library/ssl.rst:1790
msgid ""
"The parameter ``server_side`` is a boolean which identifies whether server-"
"side or client-side behavior is desired from this socket."
msgstr ""

#: ../Doc/library/ssl.rst:1793
msgid ""
"For client-side sockets, the context construction is lazy; if the underlying "
"socket isn't connected yet, the context construction will be performed "
"after :meth:`connect` is called on the socket.  For server-side sockets, if "
"the socket has no remote peer, it is assumed to be a listening socket, and "
"the server-side SSL wrapping is automatically performed on client "
"connections accepted via the :meth:`accept` method. The method may raise :"
"exc:`SSLError`."
msgstr ""

#: ../Doc/library/ssl.rst:1801
msgid ""
"On client connections, the optional parameter *server_hostname* specifies "
"the hostname of the service which we are connecting to.  This allows a "
"single server to host multiple SSL-based services with distinct "
"certificates, quite similarly to HTTP virtual hosts. Specifying "
"*server_hostname* will raise a :exc:`ValueError` if *server_side* is true."
msgstr ""

#: ../Doc/library/ssl.rst:1807
msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL "
"handshake automatically after doing a :meth:`socket.connect`, or whether the "
"application program will call it explicitly, by invoking the :meth:"
"`SSLSocket.do_handshake` method.  Calling :meth:`SSLSocket.do_handshake` "
"explicitly gives the program control over the blocking behavior of the "
"socket I/O involved in the handshake."
msgstr ""

#: ../Doc/library/ssl.rst:1814
msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the :meth:`SSLSocket."
"recv` method should signal unexpected EOF from the other end of the "
"connection.  If specified as :const:`True` (the default), it returns a "
"normal EOF (an empty bytes object) in response to unexpected EOF errors "
"raised from the underlying socket; if :const:`False`, it will raise the "
"exceptions back to the caller."
msgstr ""

#: ../Doc/library/ssl.rst:1821
msgid "*session*, see :attr:`~SSLSocket.session`."
msgstr "*session*, véase :attr:`~SSLSocket.session`."

#: ../Doc/library/ssl.rst:1823
msgid ""
"Always allow a server_hostname to be passed, even if OpenSSL does not have "
"SNI."
msgstr ""

#: ../Doc/library/ssl.rst:1827 ../Doc/library/ssl.rst:1853
msgid "*session* argument was added."
msgstr "Se agregó el argumento *session*."

#: ../Doc/library/ssl.rst:1830
msgid ""
"The method returns on instance of :attr:`SSLContext.sslsocket_class` instead "
"of hard-coded :class:`SSLSocket`."
msgstr ""

#: ../Doc/library/ssl.rst:1836
msgid ""
"The return type of :meth:`SSLContext.wrap_socket`, defaults to :class:"
"`SSLSocket`. The attribute can be overridden on instance of class in order "
"to return a custom subclass of :class:`SSLSocket`."
msgstr ""

#: ../Doc/library/ssl.rst:1845
msgid ""
"Wrap the BIO objects *incoming* and *outgoing* and return an instance of :"
"attr:`SSLContext.sslobject_class` (default :class:`SSLObject`). The SSL "
"routines will read input data from the incoming BIO and write data to the "
"outgoing BIO."
msgstr ""

#: ../Doc/library/ssl.rst:1850
msgid ""
"The *server_side*, *server_hostname* and *session* parameters have the same "
"meaning as in :meth:`SSLContext.wrap_socket`."
msgstr ""

#: ../Doc/library/ssl.rst:1856
msgid ""
"The method returns on instance of :attr:`SSLContext.sslobject_class` instead "
"of hard-coded :class:`SSLObject`."
msgstr ""

#: ../Doc/library/ssl.rst:1862
msgid ""
"The return type of :meth:`SSLContext.wrap_bio`, defaults to :class:"
"`SSLObject`. The attribute can be overridden on instance of class in order "
"to return a custom subclass of :class:`SSLObject`."
msgstr ""

#: ../Doc/library/ssl.rst:1870
msgid ""
"Get statistics about the SSL sessions created or managed by this context. A "
"dictionary is returned which maps the names of each `piece of information "
"<https://www.openssl.org/docs/man1.1.0/ssl/SSL_CTX_sess_number.html>`_ to "
"their numeric values.  For example, here is the total number of hits and "
"misses in the session cache since the context was created::"
msgstr ""

#: ../Doc/library/ssl.rst:1881
msgid ""
"Whether to match the peer cert's hostname with :func:`match_hostname` in :"
"meth:`SSLSocket.do_handshake`. The context's :attr:`~SSLContext.verify_mode` "
"must be set to :data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, and you must "
"pass *server_hostname* to :meth:`~SSLContext.wrap_socket` in order to match "
"the hostname.  Enabling hostname checking automatically sets :attr:"
"`~SSLContext.verify_mode` from :data:`CERT_NONE` to :data:`CERT_REQUIRED`.  "
"It cannot be set back to :data:`CERT_NONE` as long as hostname checking is "
"enabled. The :data:`PROTOCOL_TLS_CLIENT` protocol enables hostname checking "
"by default. With other protocols, hostname checking must be enabled "
"explicitly."
msgstr ""

#: ../Doc/library/ssl.rst:1909
msgid ""
":attr:`~SSLContext.verify_mode` is now automatically changed to :data:"
"`CERT_REQUIRED`  when hostname checking is enabled and :attr:`~SSLContext."
"verify_mode` is :data:`CERT_NONE`. Previously the same operation would have "
"failed with a :exc:`ValueError`."
msgstr ""

#: ../Doc/library/ssl.rst:1916
msgid "This features requires OpenSSL 0.9.8f or newer."
msgstr "Esta funcionalidad requiere OpenSSL 0.9.8f o posterior."

#: ../Doc/library/ssl.rst:1920
msgid ""
"Write TLS keys to a keylog file, whenever key material is generated or "
"received. The keylog file is designed for debugging purposes only. The file "
"format is specified by NSS and used by many traffic analyzers such as "
"Wireshark. The log file is opened in append-only mode. Writes are "
"synchronized between threads, but not between processes."
msgstr ""

#: ../Doc/library/ssl.rst:1930
msgid "This features requires OpenSSL 1.1.1 or newer."
msgstr "Esta funcionalidad requiere OpenSSL 1.1.1 o posterior."

#: ../Doc/library/ssl.rst:1934
msgid ""
"A :class:`TLSVersion` enum member representing the highest supported TLS "
"version. The value defaults to :attr:`TLSVersion.MAXIMUM_SUPPORTED`. The "
"attribute is read-only for protocols other than :attr:`PROTOCOL_TLS`, :attr:"
"`PROTOCOL_TLS_CLIENT`, and :attr:`PROTOCOL_TLS_SERVER`."
msgstr ""

#: ../Doc/library/ssl.rst:1939
msgid ""
"The attributes :attr:`~SSLContext.maximum_version`, :attr:`~SSLContext."
"minimum_version` and :attr:`SSLContext.options` all affect the supported SSL "
"and TLS versions of the context. The implementation does not prevent invalid "
"combination. For example a context with :attr:`OP_NO_TLSv1_2` in :attr:"
"`~SSLContext.options` and :attr:`~SSLContext.maximum_version` set to :attr:"
"`TLSVersion.TLSv1_2` will not be able to establish a TLS 1.2 connection."
msgstr ""

#: ../Doc/library/ssl.rst:1950 ../Doc/library/ssl.rst:1962
msgid ""
"This attribute is not available unless the ssl module is compiled with "
"OpenSSL 1.1.0g or newer."
msgstr ""
"Este atributo no está disponible a menos que el módulo ssl haya sido "
"compilado con OpenSSL 1.1.0g o posterior."

#: ../Doc/library/ssl.rst:1957
msgid ""
"Like :attr:`SSLContext.maximum_version` except it is the lowest supported "
"version or :attr:`TLSVersion.MINIMUM_SUPPORTED`."
msgstr ""

#: ../Doc/library/ssl.rst:1969
msgid ""
"Control the number of TLS 1.3 session tickets of a :attr:"
"`TLS_PROTOCOL_SERVER` context. The setting has no impact on TLS 1.0 to 1.2 "
"connections."
msgstr ""

#: ../Doc/library/ssl.rst:1975
msgid ""
"This attribute is not available unless the ssl module is compiled with "
"OpenSSL 1.1.1 or newer."
msgstr ""
"Este atributo no está disponible a menos que el módulo ssl haya sido "
"compilado con OpenSSL 1.1.1 o posterior."

#: ../Doc/library/ssl.rst:1982
msgid ""
"An integer representing the set of SSL options enabled on this context. The "
"default value is :data:`OP_ALL`, but you can specify other options such as :"
"data:`OP_NO_SSLv2` by ORing them together."
msgstr ""

#: ../Doc/library/ssl.rst:1987
msgid ""
"With versions of OpenSSL older than 0.9.8m, it is only possible to set "
"options, not to clear them.  Attempting to clear an option (by resetting the "
"corresponding bits) will raise a :exc:`ValueError`."
msgstr ""

#: ../Doc/library/ssl.rst:1991
msgid ":attr:`SSLContext.options` returns :class:`Options` flags:"
msgstr ":attr:`SSLContext.options` retorna opciones :class:`Options`:"

#: ../Doc/library/ssl.rst:1999
msgid ""
"Enable TLS 1.3 post-handshake client authentication. Post-handshake auth is "
"disabled by default and a server can only request a TLS client certificate "
"during the initial handshake. When enabled, a server may request a TLS "
"client certificate at any time after the handshake."
msgstr ""

#: ../Doc/library/ssl.rst:2004
msgid ""
"When enabled on client-side sockets, the client signals the server that it "
"supports post-handshake authentication."
msgstr ""

#: ../Doc/library/ssl.rst:2007
msgid ""
"When enabled on server-side sockets, :attr:`SSLContext.verify_mode` must be "
"set to :data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, too. The actual "
"client cert exchange is delayed until :meth:`SSLSocket."
"verify_client_post_handshake` is called and some I/O is performed."
msgstr ""

#: ../Doc/library/ssl.rst:2014
msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the property value is None and can't be modified"
msgstr ""

#: ../Doc/library/ssl.rst:2021
msgid ""
"The protocol version chosen when constructing the context.  This attribute "
"is read-only."
msgstr ""

#: ../Doc/library/ssl.rst:2026
msgid ""
"Whether :attr:`~SSLContext.check_hostname` falls back to verify the cert's "
"subject common name in the absence of a subject alternative name extension "
"(default: true)."
msgstr ""

#: ../Doc/library/ssl.rst:2031
msgid "Only writeable with OpenSSL 1.1.0 or higher."
msgstr "Solo modificable con OpenSSL 1.1.0 o posterior."

#: ../Doc/library/ssl.rst:2037
msgid ""
"The flags for certificate verification operations. You can set flags like :"
"data:`VERIFY_CRL_CHECK_LEAF` by ORing them together. By default OpenSSL does "
"neither require nor verify certificate revocation lists (CRLs). Available "
"only with openssl version 0.9.8+."
msgstr ""

#: ../Doc/library/ssl.rst:2044
msgid ":attr:`SSLContext.verify_flags` returns :class:`VerifyFlags` flags:"
msgstr ":attr:`SSLContext.verify_flags` retorna opciones :class:`VerifyFlags`:"

#: ../Doc/library/ssl.rst:2052
msgid ""
"Whether to try to verify other peers' certificates and how to behave if "
"verification fails.  This attribute must be one of :data:`CERT_NONE`, :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`."
msgstr ""

#: ../Doc/library/ssl.rst:2056
msgid ":attr:`SSLContext.verify_mode` returns :class:`VerifyMode` enum:"
msgstr ""

#: ../Doc/library/ssl.rst:2069
msgid "Certificates"
msgstr ""

#: ../Doc/library/ssl.rst:2071
msgid ""
"Certificates in general are part of a public-key / private-key system.  In "
"this system, each *principal*, (which may be a machine, or a person, or an "
"organization) is assigned a unique two-part encryption key.  One part of the "
"key is public, and is called the *public key*; the other part is kept "
"secret, and is called the *private key*.  The two parts are related, in that "
"if you encrypt a message with one of the parts, you can decrypt it with the "
"other part, and **only** with the other part."
msgstr ""

#: ../Doc/library/ssl.rst:2079
msgid ""
"A certificate contains information about two principals.  It contains the "
"name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who they "
"claim to be, and that this is indeed the subject's public key.  The issuer's "
"statement is signed with the issuer's private key, which only the issuer "
"knows.  However, anyone can verify the issuer's statement by finding the "
"issuer's public key, decrypting the statement with it, and comparing it to "
"the other information in the certificate. The certificate also contains "
"information about the time period over which it is valid.  This is expressed "
"as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""

#: ../Doc/library/ssl.rst:2089
msgid ""
"In the Python use of certificates, a client or server can use a certificate "
"to prove who they are.  The other side of a network connection can also be "
"required to produce a certificate, and that certificate can be validated to "
"the satisfaction of the client or server that requires such validation.  The "
"connection attempt can be set to raise an exception if the validation fails. "
"Validation is done automatically, by the underlying OpenSSL framework; the "
"application need not concern itself with its mechanics.  But the application "
"does usually need to provide sets of certificates to allow this process to "
"take place."
msgstr ""

#: ../Doc/library/ssl.rst:2099
msgid ""
"Python uses files to contain certificates.  They should be formatted as \"PEM"
"\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a header "
"line and a footer line::"
msgstr ""

#: ../Doc/library/ssl.rst:2108
msgid "Certificate chains"
msgstr ""

#: ../Doc/library/ssl.rst:2110
msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the client "
"or server, and then the certificate for the issuer of that certificate, and "
"then the certificate for the issuer of *that* certificate, and so on up the "
"chain till you get to a certificate which is *self-signed*, that is, a "
"certificate which has the same subject and issuer, sometimes called a *root "
"certificate*.  The certificates should just be concatenated together in the "
"certificate file.  For example, suppose we had a three certificate chain, "
"from our server certificate to the certificate of the certification "
"authority that signed our server certificate, to the root certificate of the "
"agency which issued the certification authority's certificate::"
msgstr ""

#: ../Doc/library/ssl.rst:2134
msgid "CA certificates"
msgstr ""

#: ../Doc/library/ssl.rst:2136
msgid ""
"If you are going to require validation of the other side of the connection's "
"certificate, you need to provide a \"CA certs\" file, filled with the "
"certificate chains for each issuer you are willing to trust.  Again, this "
"file just contains these chains concatenated together.  For validation, "
"Python will use the first chain it finds in the file which matches.  The "
"platform's certificates file can be used by calling :meth:`SSLContext."
"load_default_certs`, this is done automatically with :func:`."
"create_default_context`."
msgstr ""

#: ../Doc/library/ssl.rst:2145
msgid "Combined key and certificate"
msgstr ""

#: ../Doc/library/ssl.rst:2147
msgid ""
"Often the private key is stored in the same file as the certificate; in this "
"case, only the ``certfile`` parameter to :meth:`SSLContext.load_cert_chain` "
"and :func:`wrap_socket` needs to be passed.  If the private key is stored "
"with the certificate, it should come before the first certificate in the "
"certificate chain::"
msgstr ""

#: ../Doc/library/ssl.rst:2161
msgid "Self-signed certificates"
msgstr ""

#: ../Doc/library/ssl.rst:2163
msgid ""
"If you are going to create a server that provides SSL-encrypted connection "
"services, you will need to acquire a certificate for that service.  There "
"are many ways of acquiring appropriate certificates, such as buying one from "
"a certification authority.  Another common practice is to generate a self-"
"signed certificate.  The simplest way to do this is with the OpenSSL "
"package, using something like the following::"
msgstr ""

#: ../Doc/library/ssl.rst:2192
msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr ""

#: ../Doc/library/ssl.rst:2198
msgid "Examples"
msgstr ""

#: ../Doc/library/ssl.rst:2201
msgid "Testing for SSL support"
msgstr ""

#: ../Doc/library/ssl.rst:2203
msgid ""
"To test for the presence of SSL support in a Python installation, user code "
"should use the following idiom::"
msgstr ""

#: ../Doc/library/ssl.rst:2214
msgid "Client-side operation"
msgstr ""

#: ../Doc/library/ssl.rst:2216
msgid ""
"This example creates a SSL context with the recommended security settings "
"for client sockets, including automatic certificate verification::"
msgstr ""

#: ../Doc/library/ssl.rst:2221
msgid ""
"If you prefer to tune security settings yourself, you might create a context "
"from scratch (but beware that you might not get the settings right)::"
msgstr ""

#: ../Doc/library/ssl.rst:2228
msgid ""
"(this snippet assumes your operating system places a bundle of all CA "
"certificates in ``/etc/ssl/certs/ca-bundle.crt``; if not, you'll get an "
"error and have to adjust the location)"
msgstr ""

#: ../Doc/library/ssl.rst:2232
msgid ""
"The :data:`PROTOCOL_TLS_CLIENT` protocol configures the context for cert "
"validation and hostname verification. :attr:`~SSLContext.verify_mode` is set "
"to :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` is set to "
"``True``. All other protocols create SSL contexts with insecure defaults."
msgstr ""

#: ../Doc/library/ssl.rst:2237
msgid ""
"When you use the context to connect to a server, :const:`CERT_REQUIRED` and :"
"attr:`~SSLContext.check_hostname` validate the server certificate: it "
"ensures that the server certificate was signed with one of the CA "
"certificates, checks the signature for correctness, and verifies other "
"properties like validity and identity of the hostname::"
msgstr ""

#: ../Doc/library/ssl.rst:2247
msgid "You may then fetch the certificate::"
msgstr ""

#: ../Doc/library/ssl.rst:2251
msgid ""
"Visual inspection shows that the certificate does identify the desired "
"service (that is, the HTTPS host ``www.python.org``)::"
msgstr ""

#: ../Doc/library/ssl.rst:2294
msgid ""
"Now the SSL channel is established and the certificate verified, you can "
"proceed to talk with the server::"
msgstr ""

#: ../Doc/library/ssl.rst:2321
msgid "Server-side operation"
msgstr ""

#: ../Doc/library/ssl.rst:2323
msgid ""
"For server operation, typically you'll need to have a server certificate, "
"and private key, each in a file.  You'll first create a context holding the "
"key and the certificate, so that clients can check your authenticity.  Then "
"you'll open a socket, bind it to a port, call :meth:`listen` on it, and "
"start waiting for clients to connect::"
msgstr ""

#: ../Doc/library/ssl.rst:2338
msgid ""
"When a client connects, you'll call :meth:`accept` on the socket to get the "
"new socket from the other end, and use the context's :meth:`SSLContext."
"wrap_socket` method to create a server-side SSL socket for the connection::"
msgstr ""

#: ../Doc/library/ssl.rst:2351
msgid ""
"Then you'll read data from the ``connstream`` and do something with it till "
"you are finished with the client (or the client is finished with you)::"
msgstr ""

#: ../Doc/library/ssl.rst:2365
msgid ""
"And go back to listening for new client connections (of course, a real "
"server would probably handle each client connection in a separate thread, or "
"put the sockets in :ref:`non-blocking mode <ssl-nonblocking>` and use an "
"event loop)."
msgstr ""

#: ../Doc/library/ssl.rst:2373
msgid "Notes on non-blocking sockets"
msgstr ""

#: ../Doc/library/ssl.rst:2375
msgid ""
"SSL sockets behave slightly different than regular sockets in non-blocking "
"mode. When working with non-blocking sockets, there are thus several things "
"you need to be aware of:"
msgstr ""

#: ../Doc/library/ssl.rst:2379
msgid ""
"Most :class:`SSLSocket` methods will raise either :exc:`SSLWantWriteError` "
"or :exc:`SSLWantReadError` instead of :exc:`BlockingIOError` if an I/O "
"operation would block. :exc:`SSLWantReadError` will be raised if a read "
"operation on the underlying socket is necessary, and :exc:"
"`SSLWantWriteError` for a write operation on the underlying socket. Note "
"that attempts to *write* to an SSL socket may require *reading* from the "
"underlying socket first, and attempts to *read* from the SSL socket may "
"require a prior *write* to the underlying socket."
msgstr ""

#: ../Doc/library/ssl.rst:2391
msgid ""
"In earlier Python versions, the :meth:`!SSLSocket.send` method returned zero "
"instead of raising :exc:`SSLWantWriteError` or :exc:`SSLWantReadError`."
msgstr ""

#: ../Doc/library/ssl.rst:2395
msgid ""
"Calling :func:`~select.select` tells you that the OS-level socket can be "
"read from (or written to), but it does not imply that there is sufficient "
"data at the upper SSL layer.  For example, only part of an SSL frame might "
"have arrived.  Therefore, you must be ready to handle :meth:`SSLSocket.recv` "
"and :meth:`SSLSocket.send` failures, and retry after another call to :func:"
"`~select.select`."
msgstr ""

#: ../Doc/library/ssl.rst:2402
msgid ""
"Conversely, since the SSL layer has its own framing, a SSL socket may still "
"have data available for reading without :func:`~select.select` being aware "
"of it.  Therefore, you should first call :meth:`SSLSocket.recv` to drain any "
"potentially available data, and then only block on a :func:`~select.select` "
"call if still necessary."
msgstr ""

#: ../Doc/library/ssl.rst:2408
msgid ""
"(of course, similar provisions apply when using other primitives such as :"
"func:`~select.poll`, or those in the :mod:`selectors` module)"
msgstr ""

#: ../Doc/library/ssl.rst:2411
msgid ""
"The SSL handshake itself will be non-blocking: the :meth:`SSLSocket."
"do_handshake` method has to be retried until it returns successfully.  Here "
"is a synopsis using :func:`~select.select` to wait for the socket's "
"readiness::"
msgstr ""

#: ../Doc/library/ssl.rst:2427
msgid ""
"The :mod:`asyncio` module supports :ref:`non-blocking SSL sockets <ssl-"
"nonblocking>` and provides a higher level API. It polls for events using "
"the :mod:`selectors` module and handles :exc:`SSLWantWriteError`, :exc:"
"`SSLWantReadError` and :exc:`BlockingIOError` exceptions. It runs the SSL "
"handshake asynchronously as well."
msgstr ""

#: ../Doc/library/ssl.rst:2436
msgid "Memory BIO Support"
msgstr ""

#: ../Doc/library/ssl.rst:2440
msgid ""
"Ever since the SSL module was introduced in Python 2.6, the :class:"
"`SSLSocket` class has provided two related but distinct areas of "
"functionality:"
msgstr ""

#: ../Doc/library/ssl.rst:2443
msgid "SSL protocol handling"
msgstr ""

#: ../Doc/library/ssl.rst:2444
msgid "Network IO"
msgstr ""

#: ../Doc/library/ssl.rst:2446
msgid ""
"The network IO API is identical to that provided by :class:`socket.socket`, "
"from which :class:`SSLSocket` also inherits. This allows an SSL socket to be "
"used as a drop-in replacement for a regular socket, making it very easy to "
"add SSL support to an existing application."
msgstr ""

#: ../Doc/library/ssl.rst:2451
msgid ""
"Combining SSL protocol handling and network IO usually works well, but there "
"are some cases where it doesn't. An example is async IO frameworks that want "
"to use a different IO multiplexing model than the \"select/poll on a file "
"descriptor\" (readiness based) model that is assumed by :class:`socket."
"socket` and by the internal OpenSSL socket IO routines. This is mostly "
"relevant for platforms like Windows where this model is not efficient. For "
"this purpose, a reduced scope variant of :class:`SSLSocket` called :class:"
"`SSLObject` is provided."
msgstr ""

#: ../Doc/library/ssl.rst:2462
msgid ""
"A reduced-scope variant of :class:`SSLSocket` representing an SSL protocol "
"instance that does not contain any network IO methods. This class is "
"typically used by framework authors that want to implement asynchronous IO "
"for SSL through memory buffers."
msgstr ""

#: ../Doc/library/ssl.rst:2467
msgid ""
"This class implements an interface on top of a low-level SSL object as "
"implemented by OpenSSL. This object captures the state of an SSL connection "
"but does not provide any network IO itself. IO needs to be performed through "
"separate \"BIO\" objects which are OpenSSL's IO abstraction layer."
msgstr ""

#: ../Doc/library/ssl.rst:2472
msgid ""
"This class has no public constructor.  An :class:`SSLObject` instance must "
"be created using the :meth:`~SSLContext.wrap_bio` method. This method will "
"create the :class:`SSLObject` instance and bind it to a pair of BIOs. The "
"*incoming* BIO is used to pass data from Python to the SSL protocol "
"instance, while the *outgoing* BIO is used to pass data the other way around."
msgstr ""

#: ../Doc/library/ssl.rst:2479
msgid "The following methods are available:"
msgstr ""

#: ../Doc/library/ssl.rst:2481
msgid ":attr:`~SSLSocket.context`"
msgstr ":attr:`~SSLSocket.context`"

#: ../Doc/library/ssl.rst:2482
msgid ":attr:`~SSLSocket.server_side`"
msgstr ":attr:`~SSLSocket.server_side`"

#: ../Doc/library/ssl.rst:2483
msgid ":attr:`~SSLSocket.server_hostname`"
msgstr ":attr:`~SSLSocket.server_hostname`"

#: ../Doc/library/ssl.rst:2484
msgid ":attr:`~SSLSocket.session`"
msgstr ":attr:`~SSLSocket.session`"

#: ../Doc/library/ssl.rst:2485
msgid ":attr:`~SSLSocket.session_reused`"
msgstr ":attr:`~SSLSocket.session_reused`"

#: ../Doc/library/ssl.rst:2486
msgid ":meth:`~SSLSocket.read`"
msgstr ":meth:`~SSLSocket.read`"

#: ../Doc/library/ssl.rst:2487
msgid ":meth:`~SSLSocket.write`"
msgstr ":meth:`~SSLSocket.write`"

#: ../Doc/library/ssl.rst:2488
msgid ":meth:`~SSLSocket.getpeercert`"
msgstr ":meth:`~SSLSocket.getpeercert`"

#: ../Doc/library/ssl.rst:2489
msgid ":meth:`~SSLSocket.selected_alpn_protocol`"
msgstr ":meth:`~SSLSocket.selected_alpn_protocol`"

#: ../Doc/library/ssl.rst:2490
msgid ":meth:`~SSLSocket.selected_npn_protocol`"
msgstr ":meth:`~SSLSocket.selected_npn_protocol`"

#: ../Doc/library/ssl.rst:2491
msgid ":meth:`~SSLSocket.cipher`"
msgstr ":meth:`~SSLSocket.cipher`"

#: ../Doc/library/ssl.rst:2492
msgid ":meth:`~SSLSocket.shared_ciphers`"
msgstr ":meth:`~SSLSocket.shared_ciphers`"

#: ../Doc/library/ssl.rst:2493
msgid ":meth:`~SSLSocket.compression`"
msgstr ":meth:`~SSLSocket.compression`"

#: ../Doc/library/ssl.rst:2494
msgid ":meth:`~SSLSocket.pending`"
msgstr ":meth:`~SSLSocket.pending`"

#: ../Doc/library/ssl.rst:2495
msgid ":meth:`~SSLSocket.do_handshake`"
msgstr ":meth:`~SSLSocket.do_handshake`"

#: ../Doc/library/ssl.rst:2496
msgid ":meth:`~SSLSocket.verify_client_post_handshake`"
msgstr ":meth:`~SSLSocket.verify_client_post_handshake`"

#: ../Doc/library/ssl.rst:2497
msgid ":meth:`~SSLSocket.unwrap`"
msgstr ":meth:`~SSLSocket.unwrap`"

#: ../Doc/library/ssl.rst:2498
msgid ":meth:`~SSLSocket.get_channel_binding`"
msgstr ":meth:`~SSLSocket.get_channel_binding`"

#: ../Doc/library/ssl.rst:2499
msgid ":meth:`~SSLSocket.version`"
msgstr ":meth:`~SSLSocket.version`"

#: ../Doc/library/ssl.rst:2501
msgid ""
"When compared to :class:`SSLSocket`, this object lacks the following "
"features:"
msgstr ""

#: ../Doc/library/ssl.rst:2504
msgid ""
"Any form of network IO; ``recv()`` and ``send()`` read and write only to the "
"underlying :class:`MemoryBIO` buffers."
msgstr ""

#: ../Doc/library/ssl.rst:2507
msgid ""
"There is no *do_handshake_on_connect* machinery. You must always manually "
"call :meth:`~SSLSocket.do_handshake` to start the handshake."
msgstr ""

#: ../Doc/library/ssl.rst:2510
msgid ""
"There is no handling of *suppress_ragged_eofs*. All end-of-file conditions "
"that are in violation of the protocol are reported via the :exc:"
"`SSLEOFError` exception."
msgstr ""

#: ../Doc/library/ssl.rst:2514
msgid ""
"The method :meth:`~SSLSocket.unwrap` call does not return anything, unlike "
"for an SSL socket where it returns the underlying socket."
msgstr ""

#: ../Doc/library/ssl.rst:2517
msgid ""
"The *server_name_callback* callback passed to :meth:`SSLContext."
"set_servername_callback` will get an :class:`SSLObject` instance instead of "
"a :class:`SSLSocket` instance as its first parameter."
msgstr ""

#: ../Doc/library/ssl.rst:2521
msgid "Some notes related to the use of :class:`SSLObject`:"
msgstr ""

#: ../Doc/library/ssl.rst:2523
msgid ""
"All IO on an :class:`SSLObject` is :ref:`non-blocking <ssl-nonblocking>`. "
"This means that for example :meth:`~SSLSocket.read` will raise an :exc:"
"`SSLWantReadError` if it needs more data than the incoming BIO has available."
msgstr ""

#: ../Doc/library/ssl.rst:2528
msgid ""
"There is no module-level ``wrap_bio()`` call like there is for :meth:"
"`~SSLContext.wrap_socket`. An :class:`SSLObject` is always created via an :"
"class:`SSLContext`."
msgstr ""

#: ../Doc/library/ssl.rst:2532
msgid ""
":class:`SSLObject` instances must to created with :meth:`~SSLContext."
"wrap_bio`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""

#: ../Doc/library/ssl.rst:2538
msgid ""
"An SSLObject communicates with the outside world using memory buffers. The "
"class :class:`MemoryBIO` provides a memory buffer that can be used for this "
"purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:"
msgstr ""

#: ../Doc/library/ssl.rst:2544
msgid ""
"A memory buffer that can be used to pass data between Python and an SSL "
"protocol instance."
msgstr ""

#: ../Doc/library/ssl.rst:2549
msgid "Return the number of bytes currently in the memory buffer."
msgstr ""

#: ../Doc/library/ssl.rst:2553
msgid ""
"A boolean indicating whether the memory BIO is current at the end-of-file "
"position."
msgstr ""

#: ../Doc/library/ssl.rst:2558
msgid ""
"Read up to *n* bytes from the memory buffer. If *n* is not specified or "
"negative, all bytes are returned."
msgstr ""

#: ../Doc/library/ssl.rst:2563
msgid ""
"Write the bytes from *buf* to the memory BIO. The *buf* argument must be an "
"object supporting the buffer protocol."
msgstr ""

#: ../Doc/library/ssl.rst:2566
msgid ""
"The return value is the number of bytes written, which is always equal to "
"the length of *buf*."
msgstr ""

#: ../Doc/library/ssl.rst:2571
msgid ""
"Write an EOF marker to the memory BIO. After this method has been called, it "
"is illegal to call :meth:`~MemoryBIO.write`. The attribute :attr:`eof` will "
"become true after all data currently in the buffer has been read."
msgstr ""

#: ../Doc/library/ssl.rst:2577
msgid "SSL session"
msgstr "Sesión SSL"

#: ../Doc/library/ssl.rst:2583
msgid "Session object used by :attr:`~SSLSocket.session`."
msgstr "Objeto sesión usado por :attr:`~SSLSocket.session`."

#: ../Doc/library/ssl.rst:2595
msgid "Security considerations"
msgstr "Consideraciones de seguridad"

#: ../Doc/library/ssl.rst:2598
msgid "Best defaults"
msgstr "Los mejores valores por defecto"

#: ../Doc/library/ssl.rst:2600
msgid ""
"For **client use**, if you don't have any special requirements for your "
"security policy, it is highly recommended that you use the :func:"
"`create_default_context` function to create your SSL context. It will load "
"the system's trusted CA certificates, enable certificate validation and "
"hostname checking, and try to choose reasonably secure protocol and cipher "
"settings."
msgstr ""
"Para el **uso en el cliente**, si no tiene ningún requisito especial para su "
"política de seguridad, es muy recomendable que utilice la función :func:"
"`create_default_context` para crear su contexto SSL. Cargará los "
"certificados CA de confianza del sistema, habilitará la validación de "
"certificados y la comprobación del hostname, e intentará elegir una "
"configuración de protocolo y cifrado razonablemente segura."

#: ../Doc/library/ssl.rst:2607
msgid ""
"For example, here is how you would use the :class:`smtplib.SMTP` class to "
"create a trusted, secure connection to a SMTP server::"
msgstr ""
"Por ejemplo, así es como se utiliza la clase :class:`smtplib.SMTP` para "
"crear una conexión segura y de confianza con un servidor SMTP::"

#: ../Doc/library/ssl.rst:2616
msgid ""
"If a client certificate is needed for the connection, it can be added with :"
"meth:`SSLContext.load_cert_chain`."
msgstr ""
"Si se necesita un certificado de cliente para la conexión, se puede añadir "
"con :meth:`SSLContext.load_cert_chain`."

#: ../Doc/library/ssl.rst:2619
msgid ""
"By contrast, if you create the SSL context by calling the :class:"
"`SSLContext` constructor yourself, it will not have certificate validation "
"nor hostname checking enabled by default.  If you do so, please read the "
"paragraphs below to achieve a good security level."
msgstr ""
"Por el contrario, si crea el contexto SSL llamando usted mismo al "
"constructor :class:`SSLContext`, no tendrá activada por defecto la "
"validación de certificados ni la comprobación de hostname. Si lo hace, lea "
"los párrafos siguientes para conseguir un buen nivel de seguridad."

#: ../Doc/library/ssl.rst:2625
msgid "Manual settings"
msgstr "Ajustes manuales"

#: ../Doc/library/ssl.rst:2628
msgid "Verifying certificates"
msgstr "Verificación de certificados"

#: ../Doc/library/ssl.rst:2630
msgid ""
"When calling the :class:`SSLContext` constructor directly, :const:"
"`CERT_NONE` is the default.  Since it does not authenticate the other peer, "
"it can be insecure, especially in client mode where most of time you would "
"like to ensure the authenticity of the server you're talking to. Therefore, "
"when in client mode, it is highly recommended to use :const:"
"`CERT_REQUIRED`.  However, it is in itself not sufficient; you also have to "
"check that the server certificate, which can be obtained by calling :meth:"
"`SSLSocket.getpeercert`, matches the desired service.  For many protocols "
"and applications, the service can be identified by the hostname; in this "
"case, the :func:`match_hostname` function can be used.  This common check is "
"automatically performed when :attr:`SSLContext.check_hostname` is enabled."
msgstr ""
"Cuando se llama al constructor de :class:`SSLContext` directamente, :const:"
"`CERT_NONE` es el valor por defecto. Dado que no autentifica al otro peer, "
"puede ser inseguro, especialmente en modo cliente, donde la mayoría de las "
"veces se quiere asegurar la autenticidad del servidor con el que se está "
"hablando. Por lo tanto, cuando se está en modo cliente, es muy recomendable "
"utilizar :const:`CERT_REQUIRED`. Sin embargo, no es suficiente por sí mismo; "
"también hay que comprobar que el certificado del servidor, que se puede "
"obtener llamando a :meth:`SSLSocket.getpeercert`, coincide con el servicio "
"deseado. Para muchos protocolos y aplicaciones, el servicio puede ser "
"identificado por el hostname; en este caso, se puede utilizar la función :"
"func:`match_hostname`. Esta comprobación común se realiza automáticamente "
"cuando :attr:`SSLContext.check_hostname` está activado."

# La expresión "hostname matching" suena un poco raro aquí. Sin embargo, como no lo he traducido en el resto del documento, lo dejo aquí también en inglés.
#: ../Doc/library/ssl.rst:2643
msgid ""
"Hostname matchings is now performed by OpenSSL. Python no longer uses :func:"
"`match_hostname`."
msgstr ""
"Las hostname matchings son ahora realizadas por OpenSSL. Python ya no "
"utiliza :func:`match_hostname`."

#: ../Doc/library/ssl.rst:2647
msgid ""
"In server mode, if you want to authenticate your clients using the SSL layer "
"(rather than using a higher-level authentication mechanism), you'll also "
"have to specify :const:`CERT_REQUIRED` and similarly check the client "
"certificate."
msgstr ""
"En el modo servidor, si quiere autenticar a sus clientes utilizando la capa "
"SSL (en lugar de utilizar un mecanismo de autenticación de nivel superior), "
"también tendrá que especificar :const:`CERT_REQUIRED` y comprobar de forma "
"similar el certificado del cliente."

#: ../Doc/library/ssl.rst:2653
msgid "Protocol versions"
msgstr "Versiones del protocolo"

#: ../Doc/library/ssl.rst:2655
msgid ""
"SSL versions 2 and 3 are considered insecure and are therefore dangerous to "
"use.  If you want maximum compatibility between clients and servers, it is "
"recommended to use :const:`PROTOCOL_TLS_CLIENT` or :const:"
"`PROTOCOL_TLS_SERVER` as the protocol version. SSLv2 and SSLv3 are disabled "
"by default."
msgstr ""
"Las versiones 2 y 3 de SSL se consideran inseguras y, por lo tanto, su uso "
"es peligroso. Si desea la máxima compatibilidad entre clientes y servidores, "
"se recomienda utilizar :const:`PROTOCOL_TLS_CLIENT` o :const:"
"`PROTOCOL_TLS_SERVER` como versión del protocolo. SSLv2 y SSLv3 están "
"desactivados por defecto."

#: ../Doc/library/ssl.rst:2668
msgid ""
"The SSL context created above will only allow TLSv1.2 and later (if "
"supported by your system) connections to a server. :const:"
"`PROTOCOL_TLS_CLIENT` implies certificate validation and hostname checks by "
"default. You have to load certificates into the context."
msgstr ""
"El contexto SSL creado anteriormente sólo permitirá conexiones TLSv1.2 y "
"posteriores (si su sistema lo soporta) a un servidor. :const:"
"`PROTOCOL_TLS_CLIENT` implica la validación del certificado y la "
"comprobación del nombre de host por defecto. Tiene que cargar los "
"certificados en el contexto."

#: ../Doc/library/ssl.rst:2675
msgid "Cipher selection"
msgstr "Selección de cifrado"

# Aquí me parece mas claro traducir el título del enlace (incluso si el enlace no está en español).
#: ../Doc/library/ssl.rst:2677
msgid ""
"If you have advanced security requirements, fine-tuning of the ciphers "
"enabled when negotiating a SSL session is possible through the :meth:"
"`SSLContext.set_ciphers` method.  Starting from Python 3.2.3, the ssl module "
"disables certain weak ciphers by default, but you may want to further "
"restrict the cipher choice. Be sure to read OpenSSL's documentation about "
"the `cipher list format <https://www.openssl.org/docs/manmaster/man1/ciphers."
"html#CIPHER-LIST-FORMAT>`_. If you want to check which ciphers are enabled "
"by a given cipher list, use :meth:`SSLContext.get_ciphers` or the ``openssl "
"ciphers`` command on your system."
msgstr ""
"Si tienes requisitos de seguridad avanzados, es posible ajustar los cifrados "
"habilitados al negociar una sesión SSL mediante el método :meth:`SSLContext."
"set_ciphers`. A partir de Python 3.2.3, el módulo ssl deshabilita ciertos "
"cifrados débiles por defecto, pero es posible que quieras restringir más la "
"elección del cifrado. Asegúrese de leer la documentación de OpenSSL sobre el "
"`formato de la lista de cifrado <https://www.openssl.org/docs/manmaster/man1/"
"ciphers.html#CIPHER-LIST-FORMAT>`_. Si quiere comprobar qué cifrados están "
"habilitados por una determinada lista de cifrado, utilice :meth:`SSLContext."
"get_ciphers` o el comando ``openssl ciphers`` en su sistema."

#: ../Doc/library/ssl.rst:2688
msgid "Multi-processing"
msgstr "Multiprocesamiento"

#: ../Doc/library/ssl.rst:2690
msgid ""
"If using this module as part of a multi-processed application (using, for "
"example the :mod:`multiprocessing` or :mod:`concurrent.futures` modules), be "
"aware that OpenSSL's internal random number generator does not properly "
"handle forked processes.  Applications must change the PRNG state of the "
"parent process if they use any SSL feature with :func:`os.fork`.  Any "
"successful call of :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` or :func:"
"`~ssl.RAND_pseudo_bytes` is sufficient."
msgstr ""
"Si utiliza este módulo como parte de una aplicación multiproceso "
"(utilizando, por ejemplo, los módulos :mod:`multiprocessing` o :mod:"
"`concurrent.futures`), tenga en cuenta que el generador de números "
"aleatorios interno de OpenSSL no maneja adecuadamente los procesos "
"bifurcados. Las aplicaciones deben cambiar el estado del PRNG del proceso "
"padre si utilizan cualquier función de SSL con :func:`os.fork`. Cualquier "
"llamada exitosa de :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` o :func:"
"`~ssl.RAND_pseudo_bytes` es suficiente."

#: ../Doc/library/ssl.rst:2702
msgid "TLS 1.3"
msgstr "TLS 1.3"

#: ../Doc/library/ssl.rst:2706
msgid ""
"Python has provisional and experimental support for TLS 1.3 with OpenSSL "
"1.1.1.  The new protocol behaves slightly differently than previous version "
"of TLS/SSL.  Some new TLS 1.3 features are not yet available."
msgstr ""
"Python tiene soporte provisional y experimental para TLS 1.3 con OpenSSL "
"1.1.1. El nuevo protocolo se comporta de forma ligeramente diferente a la "
"versión anterior de TLS/SSL. Algunas de las nuevas características de TLS "
"1.3 aún no están disponibles."

#: ../Doc/library/ssl.rst:2710
msgid ""
"TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and ChaCha20 "
"cipher suites are enabled by default.  The method :meth:`SSLContext."
"set_ciphers` cannot enable or disable any TLS 1.3 ciphers yet, but :meth:"
"`SSLContext.get_ciphers` returns them."
msgstr ""
"TLS 1.3 utiliza un conjunto disjunto de suites de cifrado. Todas las suites "
"de cifrado AES-GCM y ChaCha20 están habilitadas por defecto.  El método :"
"meth:`SSLContext.set_ciphers` aún no puede habilitar o deshabilitar ningún "
"cifrado de TLS 1.3, pero :meth:`SSLContext.get_ciphers` los devuelve."

#: ../Doc/library/ssl.rst:2714
msgid ""
"Session tickets are no longer sent as part of the initial handshake and are "
"handled differently.  :attr:`SSLSocket.session` and :class:`SSLSession` are "
"not compatible with TLS 1.3."
msgstr ""
"Los tickets de sesión ya no se envían como parte del handshake inicial y se "
"manejan de forma diferente. :attr:`SSLSocket.session` y :class:`SSLSession` "
"no son compatibles con TLS 1.3."

#: ../Doc/library/ssl.rst:2717
msgid ""
"Client-side certificates are also no longer verified during the initial "
"handshake.  A server can request a certificate at any time.  Clients process "
"certificate requests while they send or receive application data from the "
"server."
msgstr ""
"Los certificados del lado del cliente ya no se verifican durante el "
"handshake inicial. Un servidor puede solicitar un certificado en cualquier "
"momento. Los clientes procesan las solicitudes de certificados mientras "
"envían o reciben datos de la aplicación desde el servidor."

#: ../Doc/library/ssl.rst:2721
msgid ""
"TLS 1.3 features like early data, deferred TLS client cert request, "
"signature algorithm configuration, and rekeying are not supported yet."
msgstr ""
"Las funciones de TLS 1.3, como los datos anticipados, la solicitud de "
"certificado de cliente TLS diferida, la configuración del algoritmo de firma "
"y la repetición de claves, aún no son compatibles."

#: ../Doc/library/ssl.rst:2728
msgid "LibreSSL support"
msgstr "Soporte LibreSSL"

#: ../Doc/library/ssl.rst:2730
msgid ""
"LibreSSL is a fork of OpenSSL 1.0.1. The ssl module has limited support for "
"LibreSSL. Some features are not available when the ssl module is compiled "
"with LibreSSL."
msgstr ""
"LibreSSL es un fork de OpenSSL 1.0.1. El módulo ssl tiene un soporte "
"limitado para LibreSSL. Algunas características no están disponibles cuando "
"el módulo ssl se compila con LibreSSL."

#: ../Doc/library/ssl.rst:2734
msgid ""
"LibreSSL >= 2.6.1 no longer supports NPN. The methods :meth:`SSLContext."
"set_npn_protocols` and :meth:`SSLSocket.selected_npn_protocol` are not "
"available."
msgstr ""
"LibreSSL >= 2.6.1 ya no soporta NPN. Los métodos :meth:`SSLContext."
"set_npn_protocols` y :meth:`SSLSocket.selected_npn_protocol` no están "
"disponibles."

#: ../Doc/library/ssl.rst:2737
msgid ""
":meth:`SSLContext.set_default_verify_paths` ignores the env vars :envvar:"
"`SSL_CERT_FILE` and :envvar:`SSL_CERT_PATH` although :func:"
"`get_default_verify_paths` still reports them."
msgstr ""
":meth:`SSLContext.set_default_verify_paths` ignora las variables de entorno :"
"envvar:`SSL_CERT_FILE` y :envvar:`SSL_CERT_PATH` aunque :func:"
"`get_default_verify_paths` aún los reporta."

#: ../Doc/library/ssl.rst:2745
msgid "Class :class:`socket.socket`"
msgstr "Clase :class:`socket.socket`"

#: ../Doc/library/ssl.rst:2745
msgid "Documentation of underlying :mod:`socket` class"
msgstr "Documentación de la clase :mod:`socket` subyacente"

#: ../Doc/library/ssl.rst:2748
msgid ""
"`SSL/TLS Strong Encryption: An Introduction <https://httpd.apache.org/docs/"
"trunk/en/ssl/ssl_intro.html>`_"
msgstr ""
"`SSL/TLS Strong Encryption: An Introduction <https://httpd.apache.org/docs/"
"trunk/en/ssl/ssl_intro.html>`_"

#: ../Doc/library/ssl.rst:2748
msgid "Intro from the Apache HTTP Server documentation"
msgstr "Introducción de la documentación del servidor HTTP Apache"

#: ../Doc/library/ssl.rst:2751
msgid ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <1422>`"
msgstr ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <1422>`"

#: ../Doc/library/ssl.rst:2751
msgid "Steve Kent"
msgstr "Steve Kent"

#: ../Doc/library/ssl.rst:2754
msgid ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"
msgstr ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"

#: ../Doc/library/ssl.rst:2754
msgid "Donald E., Jeffrey I. Schiller"
msgstr "Donald E., Jeffrey I. Schiller"

#: ../Doc/library/ssl.rst:2757
msgid ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"
msgstr ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"

#: ../Doc/library/ssl.rst:2757
msgid "D. Cooper"
msgstr "D. Cooper"

#: ../Doc/library/ssl.rst:2760
msgid ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"
msgstr ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"

#: ../Doc/library/ssl.rst:2760
msgid "T. Dierks et. al."
msgstr "T. Dierks et. al."

#: ../Doc/library/ssl.rst:2763
msgid ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"
msgstr ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"

#: ../Doc/library/ssl.rst:2763
msgid "D. Eastlake"
msgstr "D. Eastlake"

#: ../Doc/library/ssl.rst:2766
msgid ""
"`IANA TLS: Transport Layer Security (TLS) Parameters <https://www.iana.org/"
"assignments/tls-parameters/tls-parameters.xml>`_"
msgstr ""
"`IANA TLS: Transport Layer Security (TLS) Parameters <https://www.iana.org/"
"assignments/tls-parameters/tls-parameters.xml>`_"

#: ../Doc/library/ssl.rst:2766
msgid "IANA"
msgstr "IANA"

#: ../Doc/library/ssl.rst:2769
msgid ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer Security "
"(TLS) and Datagram Transport Layer Security (DTLS) <7525>`"
msgstr ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer Security "
"(TLS) and Datagram Transport Layer Security (DTLS) <7525>`"

#: ../Doc/library/ssl.rst:2769
msgid "IETF"
msgstr "IETF"

#: ../Doc/library/ssl.rst:2771
msgid ""
"`Mozilla's Server Side TLS recommendations <https://wiki.mozilla.org/"
"Security/Server_Side_TLS>`_"
msgstr ""
"`Mozilla's Server Side TLS recommendations <https://wiki.mozilla.org/"
"Security/Server_Side_TLS>`_"

#: ../Doc/library/ssl.rst:2772
msgid "Mozilla"
msgstr "Mozilla"
