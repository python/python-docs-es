# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-25 19:47+0200\n"
"PO-Revision-Date: 2021-08-04 16:45+0200\n"
"Last-Translator: Cristián Maureira-Fredes <cmaureirafredes@gmail.com>\n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../Doc/library/ssl.rst:2
msgid ":mod:`ssl` --- TLS/SSL wrapper for socket objects"
msgstr ""
":mod:`ssl` ---Empaquetador o wrapper TLS/SSL para objetos de tipo socket"

#: ../Doc/library/ssl.rst:10
msgid "**Source code:** :source:`Lib/ssl.py`"
msgstr "**Código fuente:**:source:`Lib/ssl.py`"

#: ../Doc/library/ssl.rst:18
msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities for "
"network sockets, both client-side and server-side.  This module uses the "
"OpenSSL library. It is available on all modern Unix systems, Windows, macOS, "
"and probably additional platforms, as long as OpenSSL is installed on that "
"platform."
msgstr ""
"Este módulo proporciona acceso a las funciones de cifrado de Seguridad de la "
"capa de transporte (a menudo conocida como \"Capa de sockets seguros\") y de "
"autenticación de pares para sockets de red, tanto del lado del cliente como "
"del lado del servidor. Este módulo utiliza la biblioteca OpenSSL. Está "
"disponible en todos los sistemas Unix modernos, Windows, Mac OS X y "
"probablemente en plataformas adicionales, siempre que OpenSSL esté instalado "
"en esa plataforma."

#: ../Doc/library/ssl.rst:26
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior. For example, TLSv1.3 with OpenSSL version "
"1.1.1."
msgstr ""
"Algunos comportamientos pueden depender de la plataforma, ya que se realizan "
"llamadas a las API de socket del sistema operativo. La versión instalada de "
"OpenSSL también puede provocar variaciones en el comportamiento. Por "
"ejemplo, TLSv1.3 con OpenSSL versión 1.1.1."

#: ../Doc/library/ssl.rst:32
msgid ""
"Don't use this module without reading the :ref:`ssl-security`.  Doing so may "
"lead to a false sense of security, as the default settings of the ssl module "
"are not necessarily appropriate for your application."
msgstr ""
"No use este módulo sin leer :ref:`ssl-security`. Hacerlo puede generar una "
"falsa sensación de seguridad, ya que la configuración predeterminada del "
"módulo ssl no es necesariamente la adecuada para su aplicación."

#, fuzzy
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ":ref:`Disponibilidad <availability>`: Windows."

#: ../Doc/library/cpython/Doc/includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""

#: ../Doc/library/ssl.rst:38
msgid ""
"This section documents the objects and functions in the ``ssl`` module; for "
"more general information about TLS, SSL, and certificates, the reader is "
"referred to the documents in the \"See Also\" section at the bottom."
msgstr ""
"Esta sección documenta los objetos y funciones en el módulo ``ssl``; para "
"más información general sobre TLS,SSL, y certificados, se recomienda que el "
"lector acuda a la sección \"Ver también\" al final de la página."

#: ../Doc/library/ssl.rst:42
msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived from "
"the :class:`socket.socket` type, and provides a socket-like wrapper that "
"also encrypts and decrypts the data going over the socket with SSL.  It "
"supports additional methods such as :meth:`getpeercert`, which retrieves the "
"certificate of the other side of the connection, and :meth:`cipher`, which "
"retrieves the cipher being used for the secure connection."
msgstr ""
"Este módulo proporciona una clase, :class:`ssl.SSLSocket`, que se deriva del "
"tipo :class:`socket.socket`, y proporciona una envoltura similar a un socket "
"que también encripta y desencripta los datos que pasan por el socket con "
"SSL . Admite métodos adicionales como :meth:`getpeercert`, que recupera el "
"certificado del otro lado de la conexión, y :meth:`cipher`, que recupera el "
"cifrado que se utiliza para la conexión segura."

#: ../Doc/library/ssl.rst:49
msgid ""
"For more sophisticated applications, the :class:`ssl.SSLContext` class helps "
"manage settings and certificates, which can then be inherited by SSL sockets "
"created through the :meth:`SSLContext.wrap_socket` method."
msgstr ""
"Para aplicaciones más sofisticadas, la clase :class:`ssl.SSLContext` ayuda a "
"administrar la configuración y los certificados, que luego pueden ser "
"heredados por sockets SSL creados a través del método :meth:`SSLContext."
"wrap_socket`."

#: ../Doc/library/ssl.rst:53
msgid "Updated to support linking with OpenSSL 1.1.0"
msgstr "Actualizado para admitir la vinculación con OpenSSL 1.1.0"

#: ../Doc/library/ssl.rst:58
msgid ""
"OpenSSL 0.9.8, 1.0.0 and 1.0.1 are deprecated and no longer supported. In "
"the future the ssl module will require at least OpenSSL 1.0.2 or 1.1.0."
msgstr ""
"OpenSSL 0.9.8, 1.0.0 y 1.0.1 son obsoletos y no son compatibles. En el "
"futuro, el módulo ssl requerirá al menos OpenSSL 1.0.2 o 1.1.0."

#: ../Doc/library/ssl.rst:64
msgid ""
":pep:`644` has been implemented. The ssl module requires OpenSSL 1.1.1 or "
"newer."
msgstr ""
"Se ha implementado :pep:`644`. El módulo ssl requiere OpenSSL 1.1.1 o "
"versiones más recientes."

#: ../Doc/library/ssl.rst:67
msgid ""
"Use of deprecated constants and functions result in deprecation warnings."
msgstr ""
"El uso de constantes y funciones obsoletas genera advertencias de "
"obsolescencia."

#: ../Doc/library/ssl.rst:71
msgid "Functions, Constants, and Exceptions"
msgstr "Funciones, constantes y excepciones"

#: ../Doc/library/ssl.rst:75
msgid "Socket creation"
msgstr "Creación de sockets"

# el término en inglés "hostname matching" me parece mucho mas claro que
# cualquier traducción al español ("coincidencia de nombres de anfitrión" ?)
#: ../Doc/library/ssl.rst:77
msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the :meth:`SSLContext."
"wrap_socket` of an :class:`SSLContext` instance to wrap sockets as :class:"
"`SSLSocket` objects. The helper functions :func:`create_default_context` "
"returns a new context with secure default settings. The old :func:"
"`wrap_socket` function is deprecated since it is both inefficient and has no "
"support for server name indication (SNI) and hostname matching."
msgstr ""
"Desde Python 3.2 y 2.7.9, se recomienda utilizar :meth:`SSLContext."
"wrap_socket` de una instancia de :class:`SSLContext` para envolver sockets "
"como objetos :class:`SSLSocket`. La función utilitaria :func:"
"`create_default_context` retorna un nuevo contexto con ajustes por defecto "
"seguros. La vieja función :func:`wrap_socket` es obsoleta debido a que es "
"ineficiente y que no tiene soporte para la indicación de nombre de servidor "
"(SNI) ni hostname matching."

#: ../Doc/library/ssl.rst:85
msgid "Client socket example with default context and IPv4/IPv6 dual stack::"
msgstr ""
"Ejemplo de socket cliente con contexto por defecto y doble pila IPv4/IPv6::"

#: ../Doc/library/ssl.rst:98
msgid "Client socket example with custom context and IPv4::"
msgstr "Ejemplo de socket cliente con contexto personalizado y IPv4::"

#: ../Doc/library/ssl.rst:110
msgid "Server socket example listening on localhost IPv4::"
msgstr "Ejemplo de socket servidor escuchando en localhost IPv4::"

#: ../Doc/library/ssl.rst:124
msgid "Context creation"
msgstr "Creación de contexto"

#: ../Doc/library/ssl.rst:126
msgid ""
"A convenience function helps create :class:`SSLContext` objects for common "
"purposes."
msgstr ""
"Una función conveniente ayuda a crear objetos :class:`SSLContext` para "
"propósitos comunes."

#: ../Doc/library/ssl.rst:131
msgid ""
"Return a new :class:`SSLContext` object with default settings for the given "
"*purpose*.  The settings are chosen by the :mod:`ssl` module, and usually "
"represent a higher security level than when calling the :class:`SSLContext` "
"constructor directly."
msgstr ""
"Retorna un nuevo objeto :class:`SSLContext` con ajustes por defecto para el "
"*purpose* dado. Los ajustes son elegidos por el módulo :mod:`ssl` y "
"generalmente representan un nivel de seguridad mas alto que invocando "
"directamente el constructor de :class:`SSLContext`."

#: ../Doc/library/ssl.rst:136
msgid ""
"*cafile*, *capath*, *cadata* represent optional CA certificates to trust for "
"certificate verification, as in :meth:`SSLContext.load_verify_locations`.  "
"If all three are :const:`None`, this function can choose to trust the "
"system's default CA certificates instead."
msgstr ""
"*cafile*, *capath*, *cadata* representan certificados CA opcionales para "
"confiar en la verificación de certificados, como en :meth:`SSLContext."
"load_verify_locations`. Si los tres son :const:`None` al mismo tiempo, esta "
"función puede optar por confiar en su lugar en los certificados CA por "
"defecto del sistema."

#: ../Doc/library/ssl.rst:142
msgid ""
"The settings are: :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER`, :data:`OP_NO_SSLv2`, and :data:`OP_NO_SSLv3` with "
"high encryption cipher suites without RC4 and without unauthenticated cipher "
"suites. Passing :data:`~Purpose.SERVER_AUTH` as *purpose* sets :data:"
"`~SSLContext.verify_mode` to :data:`CERT_REQUIRED` and either loads CA "
"certificates (when at least one of *cafile*, *capath* or *cadata* is given) "
"or uses :meth:`SSLContext.load_default_certs` to load default CA "
"certificates."
msgstr ""
"Las configuraciones son: :data:`PROTOCOL_TLS_CLIENT` o :data:"
"`PROTOCOL_TLS_SERVER`, :data:`OP_NO_SSLv2` y :data:`OP_NO_SSLv3` con "
"conjuntos de cifrado de alto cifrado sin RC4 y sin conjuntos de cifrado no "
"autenticados. Pasando :data:`~Purpose.SERVER_AUTH` como *purpose* establece :"
"data:`~SSLContext.verify_mode` a :data:`CERT_REQUIRED` y carga certificados "
"CA (cuando al menos uno de los *cafile*, *capath*, o *cadata*) o usa :meth:"
"`SSLContext.load_default_certs` para cargar certificados de CA "
"predeterminados."

#: ../Doc/library/ssl.rst:151
msgid ""
"When :attr:`~SSLContext.keylog_filename` is supported and the environment "
"variable :envvar:`SSLKEYLOGFILE` is set, :func:`create_default_context` "
"enables key logging."
msgstr ""
"Cuando :attr:`~SSLContext.keylog_filename` es soportado y la variable de "
"entorno :envvar:`SSLKEYLOGFILE` está establecida, :func:"
"`create_default_context` activa el registro de claves."

#: ../Doc/library/ssl.rst:156
msgid ""
"The protocol, options, cipher and other settings may change to more "
"restrictive values anytime without prior deprecation.  The values represent "
"a fair balance between compatibility and security."
msgstr ""
"El protocolo, las opciones, el cifrado y otros ajustes pueden cambiar a "
"valores mas restrictivos en cualquier momento sin previa obsolescencia. Los "
"valores representan un equilibrio justo entre compatibilidad y seguridad."

#: ../Doc/library/ssl.rst:160
msgid ""
"If your application needs specific settings, you should create a :class:"
"`SSLContext` and apply the settings yourself."
msgstr ""
"Si su aplicación necesita ajustes específicos, debe crear un :class:"
"`SSLContext` y aplicar los ajustes usted mismo."

# Es necesario traducir los mensajes de error ?
# ("Protocol or cipher suite mismatch")
#: ../Doc/library/ssl.rst:164
msgid ""
"If you find that when certain older clients or servers attempt to connect "
"with a :class:`SSLContext` created by this function that they get an error "
"stating \"Protocol or cipher suite mismatch\", it may be that they only "
"support SSL3.0 which this function excludes using the :data:`OP_NO_SSLv3`. "
"SSL3.0 is widely considered to be `completely broken <https://en.wikipedia."
"org/wiki/POODLE>`_. If you still wish to continue to use this function but "
"still allow SSL 3.0 connections you can re-enable them using::"
msgstr ""
"Si encuentra que cuando ciertos clientes o servidores antiguos intentan "
"conectarse con un :class:`SSLContext` creado con esta función obtienen un "
"error indicando *Protocol or cipher suite mismatch*, puede ser que estos "
"sólo soportan SSL3.0 el cual esta función excluye utilizando :data:"
"`OP_NO_SSLv3`. SSL3.0 está ampliamente considerado como `completamente roto "
"<https://en.wikipedia.org/wiki/POODLE>`_. Si todavía desea seguir utilizando "
"esta función pero permitir conexiones SSL 3.0, puede volver a activarlas "
"mediante::"

#: ../Doc/library/ssl.rst:180
msgid "RC4 was dropped from the default cipher string."
msgstr "RC4 ha sido abandonado de la cadena de cifrado por defecto."

#: ../Doc/library/ssl.rst:184
msgid "ChaCha20/Poly1305 was added to the default cipher string."
msgstr ""
"ChaCha20/Poly1305 ha sido agregado a la cadena de caracteres de cifrado por "
"defecto."

#: ../Doc/library/ssl.rst:186
msgid "3DES was dropped from the default cipher string."
msgstr ""
"3DES ha sido abandonado de la cadena de caracteres de cifrado por defecto."

#: ../Doc/library/ssl.rst:190
msgid "Support for key logging to :envvar:`SSLKEYLOGFILE` was added."
msgstr ""
"Soporte del registro de claves en :envvar:`SSLKEYLOGFILE` ha sido agregado."

#: ../Doc/library/ssl.rst:194
msgid ""
"The context now uses :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER` protocol instead of generic :data:`PROTOCOL_TLS`."
msgstr ""
"El contexto ahora usa el protocolo :data:`PROTOCOL_TLS_CLIENT` o :data:"
"`PROTOCOL_TLS_SERVER` en lugar del :data:`PROTOCOL_TLS` genérico."

#: ../Doc/library/ssl.rst:200
msgid "Exceptions"
msgstr "Excepciones"

#: ../Doc/library/ssl.rst:204
msgid ""
"Raised to signal an error from the underlying SSL implementation (currently "
"provided by the OpenSSL library).  This signifies some problem in the higher-"
"level encryption and authentication layer that's superimposed on the "
"underlying network connection.  This error is a subtype of :exc:`OSError`.  "
"The error code and message of :exc:`SSLError` instances are provided by the "
"OpenSSL library."
msgstr ""
"Se lanza para señalar un error de la implementación de SSL subyacente "
"(actualmente proporcionada por la biblioteca OpenSSL). Esto indica algún "
"problema en la capa de cifrado y autenticación de alto nivel que se "
"superpone a la conexión de red subyacente. Este error es un subtipo de :exc:"
"`OSError`. El código de error y el mensaje de las instancias de :exc:"
"`SSLError` son proporcionados por la biblioteca OpenSSL."

#: ../Doc/library/ssl.rst:211
msgid ":exc:`SSLError` used to be a subtype of :exc:`socket.error`."
msgstr ":exc:`SSLError` era un subtipo de :exc:`socket.error`."

#: ../Doc/library/ssl.rst:216
msgid ""
"A string mnemonic designating the OpenSSL submodule in which the error "
"occurred, such as ``SSL``, ``PEM`` or ``X509``.  The range of possible "
"values depends on the OpenSSL version."
msgstr ""
"Una cadena de caracteres mnemotécnica que designa el submódulo de OpenSSL en "
"el que se ha producido el error, como ``SSL``, ``PEM`` o ``X509``. El rango "
"de valores posibles depende de la versión de OpenSSL."

#: ../Doc/library/ssl.rst:224
msgid ""
"A string mnemonic designating the reason this error occurred, for example "
"``CERTIFICATE_VERIFY_FAILED``.  The range of possible values depends on the "
"OpenSSL version."
msgstr ""
"Una cadena de caracteres mnemotécnica que designa la razón por la que se "
"produjo el error, por ejemplo ``CERTIFICATE_VERIFY_FAILED``. El rango de "
"valores posibles depende de la versión de OpenSSL."

#: ../Doc/library/ssl.rst:232
msgid ""
"A subclass of :exc:`SSLError` raised when trying to read or write and the "
"SSL connection has been closed cleanly.  Note that this doesn't mean that "
"the underlying transport (read TCP) has been closed."
msgstr ""
"Una subclase de :exc:`SSLError` lanzada cuando se intenta leer o escribir y "
"la conexión SSL ha sido cerrada limpiamente. Tenga en cuenta que esto no "
"significa que el transporte subyacente (lectura TCP) haya sido cerrado."

#: ../Doc/library/ssl.rst:240
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"received on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"Una subclase de :exc:`SSLError` lanzada por un :ref:`socket SSL no "
"bloqueante <ssl-nonblocking>` cuando se intenta leer o escribir datos, pero "
"mas datos necesitan ser recibidos en el transporte TCP subyacente antes de "
"que la solicitud pueda ser completada."

#: ../Doc/library/ssl.rst:249
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"sent on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"Una subclase de :exc:`SSLError` lanzada por un :ref:`socket SSL no "
"bloqueante <ssl-nonblocking>` cuando se intenta leer o escribir datos, pero "
"mas datos necesitan ser enviados en el transporte TCP subyacente antes de "
"que la solicitud pueda ser completada."

#: ../Doc/library/ssl.rst:258
msgid ""
"A subclass of :exc:`SSLError` raised when a system error was encountered "
"while trying to fulfill an operation on a SSL socket.  Unfortunately, there "
"is no easy way to inspect the original errno number."
msgstr ""
"Una subclase de :exc:`SSLError` lanzada cuando se encuentra un error del "
"sistema mientras se intenta completar una operación en un socket SSL. Por "
"desgracia, no hay una manera fácil de inspeccionar el número errno original."

#: ../Doc/library/ssl.rst:266
msgid ""
"A subclass of :exc:`SSLError` raised when the SSL connection has been "
"terminated abruptly.  Generally, you shouldn't try to reuse the underlying "
"transport when this error is encountered."
msgstr ""
"Una subclase de :exc:`SSLError` lanzada cuando la conexión SSL ha sido "
"cancelada abruptamente. Generalmente, no debería intentar reutilizar el "
"transporte subyacente cuando este error se produce."

#: ../Doc/library/ssl.rst:274
msgid ""
"A subclass of :exc:`SSLError` raised when certificate validation has failed."
msgstr ""
"Una subclase de :exc:`SSLError` lanzada cuando la validación del certificado "
"ha fallado."

#: ../Doc/library/ssl.rst:281
msgid "A numeric error number that denotes the verification error."
msgstr "Un número de error numérico que indica el error de verificación."

#: ../Doc/library/ssl.rst:285
msgid "A human readable string of the verification error."
msgstr "Una cadena de caracteres legible del error de verificación."

#: ../Doc/library/ssl.rst:289
msgid "An alias for :exc:`SSLCertVerificationError`."
msgstr "Un alias para :exc:`SSLCertVerificationError`."

#: ../Doc/library/ssl.rst:291
msgid "The exception is now an alias for :exc:`SSLCertVerificationError`."
msgstr "La excepción es ahora un alias para :exc:`SSLCertVerificationError`."

#: ../Doc/library/ssl.rst:296
msgid "Random generation"
msgstr "Generación aleatoria"

#: ../Doc/library/ssl.rst:300
msgid ""
"Return *num* cryptographically strong pseudo-random bytes. Raises an :class:"
"`SSLError` if the PRNG has not been seeded with enough data or if the "
"operation is not supported by the current RAND method. :func:`RAND_status` "
"can be used to check the status of the PRNG and :func:`RAND_add` can be used "
"to seed the PRNG."
msgstr ""
"Retorna *num* bytes pseudoaleatorios criptográficamente fuertes. Lanza un :"
"class:`SSLError` si el PRNG no a sido sembrado con suficiente datos o si la "
"operación no es soportada por el método RAND actual. :func:`RAND_status` "
"puede ser usada para verificar el estado de PRNG y :func:`RAND_add` puede "
"ser usada para sembrar el PRNG."

#: ../Doc/library/ssl.rst:306 ../Doc/library/ssl.rst:327
msgid "For almost all applications :func:`os.urandom` is preferable."
msgstr "Para casi todas las aplicaciones :func:`os.urandom` es preferible."

#: ../Doc/library/ssl.rst:308
msgid ""
"Read the Wikipedia article, `Cryptographically secure pseudorandom number "
"generator (CSPRNG) <https://en.wikipedia.org/wiki/"
"Cryptographically_secure_pseudorandom_number_generator>`_, to get the "
"requirements of a cryptographically strong generator."
msgstr ""
"Léase el artículo Wikipedia, `Generador de números pseudoaleatorios "
"criptográficamente seguro (CSPRNG) <https://es.wikipedia.org/wiki/"
"Generador_de_n%C3%BAmeros_pseudoaleatorios_criptogr%C3%A1ficamente_seguro>`_, "
"para obtener los requisitos para un generador criptográficamente seguro."

#: ../Doc/library/ssl.rst:317
msgid ""
"Return (bytes, is_cryptographic): bytes are *num* pseudo-random bytes, "
"is_cryptographic is ``True`` if the bytes generated are cryptographically "
"strong. Raises an :class:`SSLError` if the operation is not supported by the "
"current RAND method."
msgstr ""
"Retorna (bytes, is_cryptographic): bytes es *num* bytes pseudoaleatorios, "
"is_cryptographic es ``True`` si los bytes generados son criptográficamente "
"fuertes. Lanza un :class:`SSLError` si la operación no es soportada por el "
"método RAND actual."

#: ../Doc/library/ssl.rst:322
msgid ""
"Generated pseudo-random byte sequences will be unique if they are of "
"sufficient length, but are not necessarily unpredictable. They can be used "
"for non-cryptographic purposes and for certain purposes in cryptographic "
"protocols, but usually not for key generation etc."
msgstr ""
"Las secuencias de bytes pseudoaleatorios generadas serán únicas si tienen "
"una longitud suficiente, pero no son necesariamente impredecibles. Pueden "
"utilizarse para fines no criptográficos y para ciertos fines en protocolos "
"criptográficos, pero normalmente no para la generación de claves, etc."

#: ../Doc/library/ssl.rst:333
msgid ""
"OpenSSL has deprecated :func:`ssl.RAND_pseudo_bytes`, use :func:`ssl."
"RAND_bytes` instead."
msgstr ""
"OpenSSL a dejado obsoleta :func:`ssl.RAND_pseudo_bytes`, utilice :func:`ssl."
"RAND_bytes` en su lugar."

#: ../Doc/library/ssl.rst:338
msgid ""
"Return ``True`` if the SSL pseudo-random number generator has been seeded "
"with 'enough' randomness, and ``False`` otherwise.  You can use :func:`ssl."
"RAND_egd` and :func:`ssl.RAND_add` to increase the randomness of the pseudo-"
"random number generator."
msgstr ""
"Retorna ``True`` si el generador de números pseudoaleatorios SSL a sido "
"sembrado con 'suficiente' aleatoriedad, y ``False`` de lo contrario. Puede "
"utilizarse :func:`ssl.RAND_egd` y :func:`ssl.RAND_add` para aumentar la "
"aleatoriedad del generador de números pseudoaleatorios."

#: ../Doc/library/ssl.rst:345
msgid ""
"Mix the given *bytes* into the SSL pseudo-random number generator.  The "
"parameter *entropy* (a float) is a lower bound on the entropy contained in "
"string (so you can always use :const:`0.0`).  See :rfc:`1750` for more "
"information on sources of entropy."
msgstr ""
"Mezcla los *bytes* dados en el generador de números pseudoaleatorios de SSL. "
"El parámetro *entropy* (un flotante) es un límite inferior de la entropía "
"contenida en la cadena de caracteres (por lo que siempre se puede utilizar :"
"const:`0.0`). Véase :rfc:`1750` para mas información sobre las fuentes de "
"entropía."

#: ../Doc/library/ssl.rst:350
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "Ahora se acepta :term:`bytes-like object` modificable."

#: ../Doc/library/ssl.rst:354
msgid "Certificate handling"
msgstr "Gestión de certificados"

#: ../Doc/library/ssl.rst:362
msgid ""
"Verify that *cert* (in decoded format as returned by :meth:`SSLSocket."
"getpeercert`) matches the given *hostname*.  The rules applied are those for "
"checking the identity of HTTPS servers as outlined in :rfc:`2818`, :rfc:"
"`5280` and :rfc:`6125`.  In addition to HTTPS, this function should be "
"suitable for checking the identity of servers in various SSL-based protocols "
"such as FTPS, IMAPS, POPS and others."
msgstr ""
"Verifica que *cert* (en formato decodificado tal y como es retornado por :"
"meth:`SSLSocket.getpeercert`) coincide con el *hostname* dado. Las reglas "
"aplicadas son las de comprobación de la identidad de los servidores HTTPS, "
"como se indica en :rfc:`2818`, :rfc:`5280` y :rfc:`6125`. Además de HTTPS, "
"esta función debería ser adecuada para comprobar la identidad de servidores "
"en varios protocolos basados en SSL como FTPS, IMAPS, POPS y otros."

#: ../Doc/library/ssl.rst:369
msgid ""
":exc:`CertificateError` is raised on failure. On success, the function "
"returns nothing::"
msgstr ""
":exc:`CertificateError` es lanzado en caso de error. En caso de éxito, la "
"función no retorna nada::"

#: ../Doc/library/ssl.rst:382
msgid ""
"The function now follows :rfc:`6125`, section 6.4.3 and does neither match "
"multiple wildcards (e.g. ``*.*.com`` or ``*a*.example.org``) nor a wildcard "
"inside an internationalized domain names (IDN) fragment. IDN A-labels such "
"as ``www*.xn--pthon-kva.org`` are still supported, but ``x*.python.org`` no "
"longer matches ``xn--tda.python.org``."
msgstr ""
"La función ahora sigue :rfc:`6125` sección 6.4.3 y no soporta múltiples "
"caracteres comodín (por ejemplo ``*.*.com`` o ``*a*.example.org``) ni "
"tampoco un carácter comodín dentro de un fragmento de un nombre de dominio "
"internacionalizado (IDN). Etiquetas A de IDN tales como ``www*.xn--pthon-kva."
"org`` son todavía soportadas, pero ``x*.python.org`` ya no corresponde con "
"``xn--tda.python.org``."

#: ../Doc/library/ssl.rst:389
msgid ""
"Matching of IP addresses, when present in the subjectAltName field of the "
"certificate, is now supported."
msgstr ""
"Ahora se admite la coincidencia de direcciones IP cuando están presentes en "
"el campo subjectAltName del certificado."

#: ../Doc/library/ssl.rst:393
msgid ""
"The function is no longer used to TLS connections. Hostname matching is now "
"performed by OpenSSL."
msgstr ""
"La función ya no se utiliza para las conexiones TLS. La coincidencia de "
"hostname es ahora realizada por OpenSSL."

#: ../Doc/library/ssl.rst:397
msgid ""
"Allow wildcard when it is the leftmost and the only character in that "
"segment. Partial wildcards like ``www*.example.com`` are no longer supported."
msgstr ""
"Se permite el carácter comodín cuando es el carácter más a la izquierda y el "
"único en ese segmento. Ya no se admiten comodines parciales como ``www*."
"example.com`` ."

#: ../Doc/library/ssl.rst:405
#, python-format
msgid ""
"Return the time in seconds since the Epoch, given the ``cert_time`` string "
"representing the \"notBefore\" or \"notAfter\" date from a certificate in "
"``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale)."
msgstr ""
"Retorna el tiempo en segundos desde la Época, dada la cadena de caracteres "
"``cert_time`` que representa la fecha *notBefore* o *notAfter* de un "
"certificado en formato strptime ``\"%b %d %H:%M:%S %Y %Z\"`` (C locale)."

#: ../Doc/library/ssl.rst:410
msgid "Here's an example:"
msgstr "He aquí un ejemplo:"

#: ../Doc/library/ssl.rst:422
msgid "\"notBefore\" or \"notAfter\" dates must use GMT (:rfc:`5280`)."
msgstr "Las fechas *notBefore* o *notAfter* deben utilizar GMT (:rfc:`5280`)."

#: ../Doc/library/ssl.rst:424
msgid ""
"Interpret the input time as a time in UTC as specified by 'GMT' timezone in "
"the input string. Local timezone was used previously. Return an integer (no "
"fractions of a second in the input format)"
msgstr ""
"Interpreta la hora de entrada como una hora en UTC según lo especificado por "
"la zona horaria 'GMT' en la cadena de caracteres de entrada. Anteriormente "
"se utilizaba la zona horaria local. Devuelve un número entero (sin "
"fracciones de segundo en el formato de entrada)"

#: ../Doc/library/ssl.rst:433
msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as a "
"PEM-encoded string.  If ``ssl_version`` is specified, uses that version of "
"the SSL protocol to attempt to connect to the server.  If ``ca_certs`` is "
"specified, it should be a file containing a list of root certificates, the "
"same format as used for the same parameter in :meth:`SSLContext."
"wrap_socket`.  The call will attempt to validate the server certificate "
"against that set of root certificates, and will fail if the validation "
"attempt fails.  A timeout can be specified with the ``timeout`` parameter."
msgstr ""
"Dada la dirección ``addr`` de un servidor protegido con SSL, como un par "
"(*hostname*, *port-number*), obtiene el certificado del servidor, y lo "
"retorna como una cadena de caracteres codificada en PEM. Si se especifica "
"``ssl_version``, utiliza esta versión del protocolo SSL para intentar "
"conectarse al servidor. Si se especifica ``ca_certs``, debe ser un archivo "
"que contenga una lista de certificados raíz, con el mismo formato que se "
"utiliza para el mismo parámetro en :meth:`SSLContext.wrap_socket`. La "
"llamada intentará validar el certificado del servidor contra ese conjunto de "
"certificados raíz, y fallará si el intento de validación falla."

#: ../Doc/library/ssl.rst:444
msgid "This function is now IPv6-compatible."
msgstr "Esta función es ahora compatible IPv6."

#: ../Doc/library/ssl.rst:447
msgid ""
"The default *ssl_version* is changed from :data:`PROTOCOL_SSLv3` to :data:"
"`PROTOCOL_TLS` for maximum compatibility with modern servers."
msgstr ""
"La *ssl_version* por defecto se cambia de :data:`PROTOCOL_SSLv3` a :data:"
"`PROTOCOL_TLS` para una máxima compatibilidad con los servidores modernos."

#: ../Doc/library/ssl.rst:451
msgid "The *timeout* parameter was added."
msgstr "Se agregó el argumento *session*."

#: ../Doc/library/ssl.rst:456
msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded "
"string version of the same certificate."
msgstr ""
"Dado un certificado como blob de bytes codificado en DER, devuelve una "
"versión de cadena de caracteres codificada en PEM del mismo certificado."

#: ../Doc/library/ssl.rst:461
msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded sequence "
"of bytes for that same certificate."
msgstr ""
"Dado un certificado como cadena de caracteres ASCII PEM, devuelve una "
"secuencia de bytes codificada con DER para ese mismo certificado."

#: ../Doc/library/ssl.rst:466
msgid ""
"Returns a named tuple with paths to OpenSSL's default cafile and capath. The "
"paths are the same as used by :meth:`SSLContext.set_default_verify_paths`. "
"The return value is a :term:`named tuple` ``DefaultVerifyPaths``:"
msgstr ""
"Retorna una tupla con nombre con las rutas por defecto de cafile y capath de "
"OpenSSL. Las rutas son las mismas que las usadas por :meth:`SSLContext."
"set_default_verify_paths`. El valor de retorno es una :term:`named tuple` "
"``DefaultVerifyPaths``:"

#: ../Doc/library/ssl.rst:471
msgid ""
":attr:`cafile` - resolved path to cafile or ``None`` if the file doesn't "
"exist,"
msgstr ""
":attr:`cafile` - ruta resuelta a cafile o ``None`` si el archivo no existe,"

#: ../Doc/library/ssl.rst:472
msgid ""
":attr:`capath` - resolved path to capath or ``None`` if the directory "
"doesn't exist,"
msgstr ""
":attr:`capath` - ruta resuelta a capath o ``None`` si el directorio no "
"existe,"

#: ../Doc/library/ssl.rst:473
msgid ""
":attr:`openssl_cafile_env` - OpenSSL's environment key that points to a "
"cafile,"
msgstr ""
":attr:`openssl_cafile_env` - clave de entorno de OpenSSL que apunta a un "
"cafile,"

#: ../Doc/library/ssl.rst:474
msgid ":attr:`openssl_cafile` - hard coded path to a cafile,"
msgstr ""
":attr:`openssl_cafile` - camino codificado de forma rígida a un cafile,"

#: ../Doc/library/ssl.rst:475
msgid ""
":attr:`openssl_capath_env` - OpenSSL's environment key that points to a "
"capath,"
msgstr ""
":attr:`openssl_capath_env` - clave de entorno de OpenSSL que apunta a un "
"capath,"

#: ../Doc/library/ssl.rst:476
msgid ":attr:`openssl_capath` - hard coded path to a capath directory"
msgstr ""
":attr:`openssl_capath` - camino codificado de forma rígida a un directorio "
"capath"

#: ../Doc/library/ssl.rst:482
msgid ""
"Retrieve certificates from Windows' system cert store. *store_name* may be "
"one of ``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert "
"stores, too."
msgstr ""
"Recupera los certificados del almacén de certificados del sistema de "
"Windows. *store_name* puede ser uno de los siguientes: ``CA``, ``ROOT`` o "
"``MY``. Windows también puede proporcionar almacenes de certificados "
"adicionales."

#: ../Doc/library/ssl.rst:486
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 "
"data. Trust specifies the purpose of the certificate as a set of OIDS or "
"exactly ``True`` if the certificate is trustworthy for all purposes."
msgstr ""
"La función devuelve una lista de tuplas (cert_bytes, encoding_type, trust). "
"El encoding_type especifica la codificación de cert_bytes. Es :const:"
"`x509_asn` para datos X.509 ASN.1 o :const:`pkcs_7_asn` para datos PKCS#7 "
"ASN.1. Trust especifica el propósito del certificado como un conjunto de "
"OIDS o exactamente ``True`` si el certificado es de confianza para todos los "
"propósitos."

#: ../Doc/library/ssl.rst:493 ../Doc/library/ssl.rst:1637
#: ../Doc/library/ssl.rst:1932
msgid "Example::"
msgstr "Ejemplo::"

#: ../Doc/library/ssl.rst:500 ../Doc/library/ssl.rst:515
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Disponibilidad <availability>`: Windows."

#: ../Doc/library/ssl.rst:505
msgid ""
"Retrieve CRLs from Windows' system cert store. *store_name* may be one of "
"``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert stores, too."
msgstr ""
"Obtiene CRLs del almacén de certificados del sistema de Windows. "
"*store_name* puede ser uno de los siguientes: ``CA``, ``ROOT`` o ``MY``. "
"Windows también puede proporcionar almacenes de certificados adicionales."

#: ../Doc/library/ssl.rst:509
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 data."
msgstr ""
"La función devuelve una lista de tuplas (cert_bytes, encoding_type, trust). "
"El encoding_type especifica la codificación de cert_bytes. Es :const:"
"`x509_asn` para datos X.509 ASN.1 o :const:`pkcs_7_asn` para datos PKCS#7 "
"ASN.1."

#: ../Doc/library/ssl.rst:523
msgid ""
"Takes an instance ``sock`` of :class:`socket.socket`, and returns an "
"instance of :class:`ssl.SSLSocket`, a subtype of :class:`socket.socket`, "
"which wraps the underlying socket in an SSL context.  ``sock`` must be a :"
"data:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""
"Toma una instancia ``sock`` de :class:`socket.socket`, y devuelve una "
"instancia de :class:`ssl.SSLSocket`, un subtipo de :class:`socket.socket`, "
"que envuelve el socket de base en un contexto SSL. ``sock`` debe ser un "
"socket :data:`~socket.SOCK_STREAM`; otros tipos de socket no son compatibles."

#: ../Doc/library/ssl.rst:528
msgid ""
"Internally, function creates a :class:`SSLContext` with protocol "
"*ssl_version* and :attr:`SSLContext.options` set to *cert_reqs*. If "
"parameters *keyfile*, *certfile*, *ca_certs* or *ciphers* are set, then the "
"values are passed to :meth:`SSLContext.load_cert_chain`, :meth:`SSLContext."
"load_verify_locations`, and :meth:`SSLContext.set_ciphers`."
msgstr ""
"Internamente, la función crea un :class:`SSLContext` con un protocolo "
"*ssl_version* y :attr:`SSLContext.options` establecido a *cert_reqs*. Si los "
"parámetros *keyfile*, *certfile*, *ca_certs* o *ciphers* son establecidos, "
"entonces los valores son pasados a :meth:`SSLContext.load_cert_chain`, :meth:"
"`SSLContext.load_verify_locations`, y :meth:`SSLContext.set_ciphers`."

#: ../Doc/library/ssl.rst:535
msgid ""
"The arguments *server_side*, *do_handshake_on_connect*, and "
"*suppress_ragged_eofs* have the same meaning as :meth:`SSLContext."
"wrap_socket`."
msgstr ""
"Los argumentos *server_side*, *do_handshake_on_connect*, y "
"*supress_ragged_eofs* tienen el mismo significado que :meth:`SSLContext."
"wrap_socket`."

#: ../Doc/library/ssl.rst:541
msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the :meth:`SSLContext."
"wrap_socket` instead of :func:`wrap_socket`. The top-level function is "
"limited and creates an insecure client socket without server name indication "
"or hostname matching."
msgstr ""
"Desde Python 3.2 y 2.7.9, se recomienda usar :meth:`SSLContext.wrap_socket` "
"en lugar de :func:`wrap_socket`. La función de alto nivel tiene limitaciones "
"y crea un socket cliente no seguro sin indicación de nombre de servidor ni "
"hostname matching."

#: ../Doc/library/ssl.rst:547
msgid "Constants"
msgstr "Constantes"

#: ../Doc/library/ssl.rst:549
msgid ""
"All constants are now :class:`enum.IntEnum` or :class:`enum.IntFlag` "
"collections."
msgstr ""
"Todas las constantes son ahora colecciones :class:`enum.IntEnum` o :class:"
"`enum.IntFlag`."

#: ../Doc/library/ssl.rst:555
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  Except for :const:`PROTOCOL_TLS_CLIENT`, "
"it is the default mode.  With client-side sockets, just about any cert is "
"accepted.  Validation errors, such as untrusted or expired cert, are ignored "
"and do not abort the TLS/SSL handshake."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_mode`, o el parámetro "
"``cert_reqs`` de :func:`wrap_socket`. A excepción de :const:"
"`PROTOCOL_TLS_CLIENT`, es el modo por defecto. Con sockets del lado del "
"cliente, se acepta casi cualquier certificado. Errores de validación, como "
"certificado no confiable o caducado, son ignorados y no abortan el handshake "
"TLS/SSL."

#: ../Doc/library/ssl.rst:561
msgid ""
"In server mode, no certificate is requested from the client, so the client "
"does not send any for client cert authentication."
msgstr ""
"En modo servidor, no se solicita ningún certificado al cliente, por lo que "
"el cliente no envía ninguno para la autenticación del certificado del "
"cliente."

#: ../Doc/library/ssl.rst:564 ../Doc/library/ssl.rst:2340
msgid "See the discussion of :ref:`ssl-security` below."
msgstr "Vea la discusión sobre :ref:`ssl-security` más abajo."

#: ../Doc/library/ssl.rst:568
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In client mode, :const:`CERT_OPTIONAL` "
"has the same meaning as :const:`CERT_REQUIRED`. It is recommended to use :"
"const:`CERT_REQUIRED` for client-side sockets instead."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_mode`, o el parámetro "
"``cert_reqs`` de :func:`wrap_socket`. En modo cliente, :const:"
"`CERT_OPTIONAL` tiene el mismo significado que :const:`CERT_REQUIRED`. Se "
"recomienda usar en su lugar :const:`CERT_REQUIRED` para sockets del lado del "
"cliente."

#: ../Doc/library/ssl.rst:573
msgid ""
"In server mode, a client certificate request is sent to the client.  The "
"client may either ignore the request or send a certificate in order perform "
"TLS client cert authentication.  If the client chooses to send a "
"certificate, it is verified.  Any verification error immediately aborts the "
"TLS handshake."
msgstr ""
"En el modo servidor, se envía una solicitud de certificado de cliente al "
"cliente. El cliente puede ignorar la solicitud o enviar un certificado para "
"realizar la autenticación de certificado de cliente TLS. Si el cliente opta "
"por enviar un certificado, éste se verifica. Cualquier error de verificación "
"aborta inmediatamente el handshake TLS."

#: ../Doc/library/ssl.rst:579 ../Doc/library/ssl.rst:599
msgid ""
"Use of this setting requires a valid set of CA certificates to be passed, "
"either to :meth:`SSLContext.load_verify_locations` or as a value of the "
"``ca_certs`` parameter to :func:`wrap_socket`."
msgstr ""
"El uso de esta configuración requiere que se pase un conjunto válido de "
"certificados de CA, ya sea a :meth:`SSLContext.load_verify_locations` o como "
"valor del parámetro ``ca_certs`` de :func:`wrap_socket`."

#: ../Doc/library/ssl.rst:585
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode, certificates are required "
"from the other side of the socket connection; an :class:`SSLError` will be "
"raised if no certificate is provided, or if its validation fails. This mode "
"is **not** sufficient to verify a certificate in client mode as it does not "
"match hostnames.  :attr:`~SSLContext.check_hostname` must be enabled as well "
"to verify the authenticity of a cert. :const:`PROTOCOL_TLS_CLIENT` uses :"
"const:`CERT_REQUIRED` and enables :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_mode`, o el parámetro "
"``cert_reqs`` de :func:`wrap_socket`. En este modo, se requieren "
"certificados del otro lado de la conexión del socket; se lanzará un :class:"
"`SSLError` si no se proporciona ningún certificado, o si su validación "
"falla. Este modo **no** es suficiente para verificar un certificado en modo "
"cliente, ya que no coincide con los hostnames. :attr:`~SSLContext."
"check_hostname` debe estar activado también para verificar la autenticidad "
"de un certificado. :const:`PROTOCOL_TLS_CLIENT` utiliza :const:"
"`CERT_REQUIRED` y activa :attr:`~SSLContext.check_hostname` por defecto."

#: ../Doc/library/ssl.rst:595
msgid ""
"With server socket, this mode provides mandatory TLS client cert "
"authentication.  A client certificate request is sent to the client and the "
"client must provide a valid and trusted certificate."
msgstr ""
"Con socket servidor, este modo proporciona una autenticación obligatoria de "
"certificado de cliente TLS. Se envía una solicitud de certificado de cliente "
"al cliente y el cliente debe proporcionar un certificado válido y de "
"confianza."

#: ../Doc/library/ssl.rst:605
msgid ":class:`enum.IntEnum` collection of CERT_* constants."
msgstr "Colección :class:`enum.IntEnum` de constantes CERT_*."

#: ../Doc/library/ssl.rst:611
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, "
"certificate revocation lists (CRLs) are not checked. By default OpenSSL does "
"neither require nor verify CRLs."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_flags`. En este modo, las listas "
"de revocación de certificado (CRLs) no son verificadas. Por defecto OpenSSL "
"no requiere ni verifica CRLs."

#: ../Doc/library/ssl.rst:619
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, only the "
"peer cert is checked but none of the intermediate CA certificates. The mode "
"requires a valid CRL that is signed by the peer cert's issuer (its direct "
"ancestor CA). If no proper CRL has been loaded with :attr:`SSLContext."
"load_verify_locations`, validation will fail."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_flags`. En este modo, sólo el "
"certificado de pares es verificado pero ninguno de los certificados CA "
"intermedios. El modo requiere una CRL válida que esté firmada por el emisor "
"del certificado de pares (su CA antecesora directa). Si no se ha cargado una "
"CRL adecuada con :attr:`SSLContext.load_verify_locations`, la validación "
"fallará."

#: ../Doc/library/ssl.rst:629
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, CRLs of "
"all certificates in the peer cert chain are checked."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_flags`. En este modo, las CRLs "
"de todos los certificados en la cadena de certificado de pares son "
"verificadas."

#: ../Doc/library/ssl.rst:636
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to disable workarounds "
"for broken X.509 certificates."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_flags` para desactivar "
"soluciones alternativas para certificados X.509 rotos."

#: ../Doc/library/ssl.rst:643
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to enables proxy "
"certificate verification."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_flags` para desactivar "
"soluciones alternativas para certificados X.509 rotos."

#: ../Doc/library/ssl.rst:650
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"prefer trusted certificates when building the trust chain to validate a "
"certificate. This flag is enabled by default."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_flags`. Indica a OpenSSL de "
"preferir certificados de confianza al construir la cadena de confianza para "
"validar un certificado. Esta opción está activada por defecto."

#: ../Doc/library/ssl.rst:658
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"accept intermediate CAs in the trust store to be treated as trust-anchors, "
"in the same way as the self-signed root CA certificates. This makes it "
"possible to trust certificates issued by an intermediate CA without having "
"to trust its ancestor root CA."
msgstr ""
"Valor posible para :attr:`SSLContext.verify_flags`. Indica a OpenSSL que "
"acepte CA intermedias en el almacén de confianza para que se traten como "
"anclajes de confianza, de la misma manera que los certificados de CA raíz "
"autofirmados. Esto hace posible confiar en los certificados emitidos por una "
"CA intermedia sin tener que confiar en su CA raíz antecesora."

#: ../Doc/library/ssl.rst:669
msgid ":class:`enum.IntFlag` collection of VERIFY_* constants."
msgstr "Colección :class:`enum.IntFlag` de constantes VERIFY_*."

#: ../Doc/library/ssl.rst:675
msgid ""
"Selects the highest protocol version that both the client and server "
"support. Despite the name, this option can select both \"SSL\" and \"TLS\" "
"protocols."
msgstr ""
"Selecciona la versión mas alta del protocolo soportada tanto por el cliente "
"como por el servidor. A pesar de su nombre, esta opción puede seleccionar "
"ambos protocolos \"SSL\" y \"TLS\"."

#: ../Doc/library/ssl.rst:682
msgid ""
"TLS clients and servers require different default settings for secure "
"communication. The generic TLS protocol constant is deprecated in favor of :"
"data:`PROTOCOL_TLS_CLIENT` and :data:`PROTOCOL_TLS_SERVER`."
msgstr ""
"Los clientes y servidores TLS requieren diferentes configuraciones "
"predeterminadas para una comunicación segura. La constante del protocolo TLS "
"genérico está en desuso en favor de :data:`PROTOCOL_TLS_CLIENT` y :data:"
"`PROTOCOL_TLS_SERVER`."

#: ../Doc/library/ssl.rst:688
msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context client-side connections. The protocol "
"enables :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
"Negocie automáticamente la versión de protocolo más alta que admiten tanto "
"el cliente como el servidor, y configure las conexiones del lado del cliente "
"de contexto. El protocolo habilita :data:`CERT_REQUIRED` y :attr:"
"`~SSLContext.check_hostname` de forma predeterminada."

#: ../Doc/library/ssl.rst:697
msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context server-side connections."
msgstr ""
"Selecciona la versión mas alta del protocolo soportada tanto por el cliente "
"como por el servidor. A pesar de su nombre, esta opción puede seleccionar "
"ambos protocolos \"SSL\" y \"TLS\"."

#: ../Doc/library/ssl.rst:704
msgid "Alias for :data:`PROTOCOL_TLS`."
msgstr "Alias para :data:`PROTOCOL_TLS`."

#: ../Doc/library/ssl.rst:708
msgid "Use :data:`PROTOCOL_TLS` instead."
msgstr "Utilice en su lugar :data:`PROTOCOL_TLS`."

#: ../Doc/library/ssl.rst:712
msgid "Selects SSL version 2 as the channel encryption protocol."
msgstr "Selecciona la versión 2 de SSL como protocolo de cifrado del canal."

#: ../Doc/library/ssl.rst:714
#, fuzzy
msgid ""
"This protocol is not available if OpenSSL is compiled with the ``no-ssl2`` "
"option."
msgstr ""
"Este protocolo no está disponible si OpenSSL fue compilada con la opción "
"``OPENSSL_NO_SSL2``."

#: ../Doc/library/ssl.rst:719
msgid "SSL version 2 is insecure.  Its use is highly discouraged."
msgstr "La versión 2 de SSL es insegura. Su uso es muy desaconsejado."

#: ../Doc/library/ssl.rst:723
msgid "OpenSSL has removed support for SSLv2."
msgstr "OpenSSL a eliminado el soporte para SSLv2."

#: ../Doc/library/ssl.rst:727
msgid "Selects SSL version 3 as the channel encryption protocol."
msgstr "Selecciona la versión 3 de SSL como protocolo de cifrado del canal."

#: ../Doc/library/ssl.rst:729
#, fuzzy
msgid ""
"This protocol is not available if OpenSSL is compiled with the ``no-ssl3`` "
"option."
msgstr ""
"Este protocolo no está disponible si OpenSSL fue compilada con la opción "
"``OPENSSL_NO_SSL2``."

#: ../Doc/library/ssl.rst:734
msgid "SSL version 3 is insecure.  Its use is highly discouraged."
msgstr "La versión 3 de SSL es insegura. Su uso es muy desaconsejado."

#: ../Doc/library/ssl.rst:738
msgid ""
"OpenSSL has deprecated all version specific protocols. Use the default "
"protocol :data:`PROTOCOL_TLS_SERVER` or :data:`PROTOCOL_TLS_CLIENT` with :"
"attr:`SSLContext.minimum_version` and :attr:`SSLContext.maximum_version` "
"instead."
msgstr ""
"OpenSSL ha descontinuado todos los protocolos específicos de la versión. "
"Utilice el protocolo predeterminado :data:`PROTOCOL_TLS_SERVER` o :data:"
"`PROTOCOL_TLS_CLIENT` con :attr:`SSLContext.minimum_version` y :attr:"
"`SSLContext.maximum_version` en su lugar."

#: ../Doc/library/ssl.rst:746
msgid "Selects TLS version 1.0 as the channel encryption protocol."
msgstr "Selecciona la versión 1.0 de TLS como protocolo de cifrado del canal."

#: ../Doc/library/ssl.rst:750 ../Doc/library/ssl.rst:761
#: ../Doc/library/ssl.rst:772
msgid "OpenSSL has deprecated all version specific protocols."
msgstr ""
"OpenSSL ha descontinuado todos los protocolos específicos de la versión."

#: ../Doc/library/ssl.rst:754
msgid ""
"Selects TLS version 1.1 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr ""
"Selecciona la versión 1.1 de TLS como protocolo de cifrado del canal. "
"Disponible sólo con openssl en versión 1.0.1+."

#: ../Doc/library/ssl.rst:765
msgid ""
"Selects TLS version 1.2 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr ""
"Selecciona la versión 1.1 de TLS como protocolo de cifrado del canal. "
"Disponible sólo con openssl en versión 1.0.1+."

#: ../Doc/library/ssl.rst:776
msgid ""
"Enables workarounds for various bugs present in other SSL implementations. "
"This option is set by default.  It does not necessarily set the same flags "
"as OpenSSL's ``SSL_OP_ALL`` constant."
msgstr ""
"Activa soluciones alternativas para varios errores presentes en otras "
"implementaciones SSL. Esta opción esta activada por defecto. No "
"necesariamente activa las mismas opciones como la constante ``SSL_OP_ALL`` "
"de OpenSSL."

#: ../Doc/library/ssl.rst:784
msgid ""
"Prevents an SSLv2 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv2 as "
"the protocol version."
msgstr ""
"Evita una conexión SSLv2. Esta opción sólo es aplicable junto con :const:"
"`PROTOCOL_TLS`. Evita que los pares elijan SSLv2 como versión del protocolo."

#: ../Doc/library/ssl.rst:792
msgid "SSLv2 is deprecated"
msgstr "SSLv2 es obsoleto"

#: ../Doc/library/ssl.rst:796
msgid ""
"Prevents an SSLv3 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv3 as "
"the protocol version."
msgstr ""
"Evita una conexión SSLv3. Esta opción sólo es aplicable junto con :const:"
"`PROTOCOL_TLS`. Evita que los pares elijan SSLv3 como versión del protocolo."

#: ../Doc/library/ssl.rst:804
msgid "SSLv3 is deprecated"
msgstr "SSLv3 es obsoleto"

#: ../Doc/library/ssl.rst:808
msgid ""
"Prevents a TLSv1 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing TLSv1 as "
"the protocol version."
msgstr ""
"Evita una conexión TLSv1. Esta opción sólo es aplicable junto con :const:"
"`PROTOCOL_TLS`. Evita que los pares elijan TLSv1 como versión del protocolo."

#: ../Doc/library/ssl.rst:814
msgid ""
"The option is deprecated since OpenSSL 1.1.0, use the new :attr:`SSLContext."
"minimum_version` and :attr:`SSLContext.maximum_version` instead."
msgstr ""
"Esta opción es obsoleta desde OpenSSL 1.1.0, utilice en su lugar los nuevos :"
"attr:`SSLContext.minimum_version` y :attr:`SSLContext.maximum_version`."

#: ../Doc/library/ssl.rst:821
msgid ""
"Prevents a TLSv1.1 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.1 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"Evita una conexión TLSv1.1. Esta opción sólo es aplicable junto con :const:"
"`PROTOCOL_TLS`. Evita que los pares elijan TLSv1.1 como versión del "
"protocolo. Disponible sólo con openssl en versión 1.0.1+."

#: ../Doc/library/ssl.rst:827 ../Doc/library/ssl.rst:838
msgid "The option is deprecated since OpenSSL 1.1.0."
msgstr "Esta opción es obsoleta desde OpenSSL 1.1.0."

#: ../Doc/library/ssl.rst:832
msgid ""
"Prevents a TLSv1.2 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.2 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"Evita una conexión TLSv1.2. Esta opción sólo es aplicable junto con :const:"
"`PROTOCOL_TLS`. Evita que los pares elijan TLSv1.2 como versión del "
"protocolo. Disponible sólo con openssl en versión 1.0.1+."

#: ../Doc/library/ssl.rst:843
msgid ""
"Prevents a TLSv1.3 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.3 as "
"the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later. When "
"Python has been compiled against an older version of OpenSSL, the flag "
"defaults to *0*."
msgstr ""
"Evita una conexión TLSv1.3. Esta opción sólo es aplicable junto con :const:"
"`PROTOCOL_TLS`. Evita que los pares elijan TLSv1.3 como versión del "
"protocolo. TLS 1.3 está disponible con OpenSSL 1.1.1 o superior. Cuando "
"Python es compilado contra una versión mas antigua de OpenSSL, la opción "
"vale *0* por defecto."

#: ../Doc/library/ssl.rst:851
msgid ""
"The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15, 3.6.3 "
"and 3.7.0 for backwards compatibility with OpenSSL 1.0.2."
msgstr ""
"Esta opción es obsoleta desde OpenSSL 1.1.0. Ha sido agregada a 2.7.15, "
"3.6.3 y 3.7.0 por retro-compatibilidad con OpenSSL 1.0.2."

#: ../Doc/library/ssl.rst:857
msgid ""
"Disable all renegotiation in TLSv1.2 and earlier. Do not send HelloRequest "
"messages, and ignore renegotiation requests via ClientHello."
msgstr ""
"Desactiva toda re-negociación en TLSv1.2 y anteriores. No envía mensajes "
"HelloRequest e ignora solicitudes de re-negociación vía ClientHello."

#: ../Doc/library/ssl.rst:860
msgid "This option is only available with OpenSSL 1.1.0h and later."
msgstr "Esta opción sólo está disponible con OpenSSL 1.1.0h y posteriores."

#: ../Doc/library/ssl.rst:866
msgid ""
"Use the server's cipher ordering preference, rather than the client's. This "
"option has no effect on client sockets and SSLv2 server sockets."
msgstr ""
"Utiliza la preferencia de ordenación de cifrado del servidor, en lugar de la "
"del cliente. Esta opción no tiene efecto en los sockets del cliente ni en "
"los sockets del servidor SSLv2."

#: ../Doc/library/ssl.rst:873
msgid ""
"Prevents re-use of the same DH key for distinct SSL sessions.  This improves "
"forward secrecy but requires more computational resources. This option only "
"applies to server sockets."
msgstr ""
"Evita la reutilización de la misma clave DH para distintas sesiones SSL. "
"Esto mejora el secreto hacia adelante pero requiere más recursos "
"computacionales. Esta opción sólo se aplica a los sockets del servidor."

#: ../Doc/library/ssl.rst:881
msgid ""
"Prevents re-use of the same ECDH key for distinct SSL sessions.  This "
"improves forward secrecy but requires more computational resources. This "
"option only applies to server sockets."
msgstr ""
"Evita la reutilización de la misma clave ECDH para distintas sesiones SSL. "
"Esto mejora el secreto hacia adelante pero requiere más recursos "
"computacionales. Esta opción sólo se aplica a los sockets del servidor."

#: ../Doc/library/ssl.rst:889
msgid ""
"Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make a "
"TLS 1.3 connection look more like a TLS 1.2 connection."
msgstr ""
"Enviar mensajes Change Cipher Spec (CCS) ficticios en el handshake de TLS "
"1.3 para que una conexión TLS 1.3 se parezca más a una conexión TLS 1.2."

#: ../Doc/library/ssl.rst:892
msgid "This option is only available with OpenSSL 1.1.1 and later."
msgstr "Esta opción sólo está disponible con OpenSSL 1.1.1 y posteriores."

#: ../Doc/library/ssl.rst:898
msgid ""
"Disable compression on the SSL channel.  This is useful if the application "
"protocol supports its own compression scheme."
msgstr ""
"Desactivar la compresión en el canal SSL. Esto es útil si el protocolo de la "
"aplicación soporta su propio esquema de compresión."

#: ../Doc/library/ssl.rst:905
msgid ":class:`enum.IntFlag` collection of OP_* constants."
msgstr "Colección :class:`enum.IntFlag` de constantes OP_*."

#: ../Doc/library/ssl.rst:909
msgid "Prevent client side from requesting a session ticket."
msgstr "Evita que el lado del cliente solicite un ticket de sesión."

#: ../Doc/library/ssl.rst:915
msgid "Ignore unexpected shutdown of TLS connections."
msgstr "Ignore el cierre inesperado de las conexiones TLS."

#: ../Doc/library/ssl.rst:917
msgid "This option is only available with OpenSSL 3.0.0 and later."
msgstr "Esta opción sólo está disponible con OpenSSL 1.0.0 y posteriores."

#: ../Doc/library/ssl.rst:923
msgid ""
"Whether the OpenSSL library has built-in support for the *Application-Layer "
"Protocol Negotiation* TLS extension as described in :rfc:`7301`."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para la extensión TLS "
"*Application-Layer Protocol Negotiation* como se describe en :rfc:`7301`."

#: ../Doc/library/ssl.rst:930
msgid ""
"Whether the OpenSSL library has built-in support not checking subject common "
"name and :attr:`SSLContext.hostname_checks_common_name` is writeable."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para no comprobar el "
"nombre común del sujeto y :attr:`SSLContext.hostname_checks_common_name` es "
"modificable."

#: ../Doc/library/ssl.rst:938
msgid ""
"Whether the OpenSSL library has built-in support for the Elliptic Curve-"
"based Diffie-Hellman key exchange.  This should be true unless the feature "
"was explicitly disabled by the distributor."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para el intercambio de "
"claves Diffie-Hellman basado en Elliptic Curve. Esto debería ser cierto a "
"menos que la función haya sido desactivada explícitamente por el "
"distribuidor."

#: ../Doc/library/ssl.rst:946
msgid ""
"Whether the OpenSSL library has built-in support for the *Server Name "
"Indication* extension (as defined in :rfc:`6066`)."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para la extensión *Server "
"Name Indication* (como se define en :rfc:`6066`)."

#: ../Doc/library/ssl.rst:953
msgid ""
"Whether the OpenSSL library has built-in support for the *Next Protocol "
"Negotiation* as described in the `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"When true, you can use the :meth:`SSLContext.set_npn_protocols` method to "
"advertise which protocols you want to support."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para *Next Protocol "
"Negotiation* como se describe en `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"Cuando es verdadero, puede utilizar el método :meth:`SSLContext."
"set_npn_protocols` para anunciar los protocolos que desea soportar."

#: ../Doc/library/ssl.rst:963
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 2.0 protocol."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo SSL 2.0."

#: ../Doc/library/ssl.rst:969
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 3.0 protocol."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo SSL 3.0."

#: ../Doc/library/ssl.rst:975
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.0 protocol."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo TLS 1.0."

#: ../Doc/library/ssl.rst:981
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.1 protocol."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo TLS 1.1."

#: ../Doc/library/ssl.rst:987
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.2 protocol."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo TLS 1.2."

#: ../Doc/library/ssl.rst:993
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.3 protocol."
msgstr ""
"Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo TLS 1.3."

#: ../Doc/library/ssl.rst:999
msgid ""
"List of supported TLS channel binding types.  Strings in this list can be "
"used as arguments to :meth:`SSLSocket.get_channel_binding`."
msgstr ""
"Lista de tipos de enlace de canales TLS admitidos. Las cadenas de caracteres "
"en esta lista pueden ser usadas como argumentos para :meth:`SSLSocket."
"get_channel_binding`."

#: ../Doc/library/ssl.rst:1006
msgid "The version string of the OpenSSL library loaded by the interpreter::"
msgstr ""
"La cadena de versión de la biblioteca OpenSSL cargada por el intérprete::"

#: ../Doc/library/ssl.rst:1015
msgid ""
"A tuple of five integers representing version information about the OpenSSL "
"library::"
msgstr ""
"Una tupla de cinco números enteros representando la información de versión "
"de la biblioteca OpenSSL::"

#: ../Doc/library/ssl.rst:1025
msgid "The raw version number of the OpenSSL library, as a single integer::"
msgstr ""
"El número de versión en bruto de la biblioteca OpenSSL, como un único número "
"entero::"

#: ../Doc/library/ssl.rst:1038
msgid ""
"Alert Descriptions from :rfc:`5246` and others. The `IANA TLS Alert Registry "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contains this list and references to the RFCs where their "
"meaning is defined."
msgstr ""
"Descripciones de alertas de :rfc:`5246` y otras. El `IANA TLS Alert Registry "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contiene esta lista y las referencias a las RFC donde se "
"define su significado."

#: ../Doc/library/ssl.rst:1042
msgid ""
"Used as the return value of the callback function in :meth:`SSLContext."
"set_servername_callback`."
msgstr ""
"Se utiliza como valor de retorno de la función callback en :meth:`SSLContext."
"set_servername_callback`."

#: ../Doc/library/ssl.rst:1049
msgid ":class:`enum.IntEnum` collection of ALERT_DESCRIPTION_* constants."
msgstr "Colección :class:`enum.IntEnum` de constantes ALERT_DESCRIPTION_*."

#: ../Doc/library/ssl.rst:1055
msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate web servers (therefore, it will be used to create client-side "
"sockets)."
msgstr ""
"Opción para :func:`create_default_context` y :meth:`SSLContext."
"load_default_certs`. Este valor indica que el contexto puede utilizarse para "
"autenticar servidores web (por lo tanto, se utilizará para crear sockets del "
"lado del cliente)."

#: ../Doc/library/ssl.rst:1064
msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate web clients (therefore, it will be used to create server-side "
"sockets)."
msgstr ""
"Opción para :func:`create_default_context` y :meth:`SSLContext."
"load_default_certs`. Este valor indica que el contexto puede utilizarse para "
"autenticar clientes web (por lo tanto, se utilizará para crear sockets del "
"lado del servidor)."

#: ../Doc/library/ssl.rst:1073
msgid ":class:`enum.IntEnum` collection of SSL_ERROR_* constants."
msgstr "Colección :class:`enum.IntEnum` de constantes SSL_ERROR_*."

#: ../Doc/library/ssl.rst:1079
msgid ""
":class:`enum.IntEnum` collection of SSL and TLS versions for :attr:"
"`SSLContext.maximum_version` and :attr:`SSLContext.minimum_version`."
msgstr ""
"Colección :class:`enum.IntEnum` de versiones SSL y TLS para :attr:"
"`SSLContext.maximum_version` y :attr:`SSLContext.minimum_version`."

#: ../Doc/library/ssl.rst:1087
msgid ""
"The minimum or maximum supported SSL or TLS version. These are magic "
"constants. Their values don't reflect the lowest and highest available TLS/"
"SSL versions."
msgstr ""
"La mínima o máxima versión soportada de SSL o TLS. Estas son constantes "
"mágicas. Sus valores no reflejan la mas baja o mas alta versión TLS/SSL "
"disponible."

#: ../Doc/library/ssl.rst:1097
msgid "SSL 3.0 to TLS 1.3."
msgstr "SSL 3.0 a TLS 1.3."

#: ../Doc/library/ssl.rst:1101
msgid ""
"All :class:`TLSVersion` members except :attr:`TLSVersion.TLSv1_2` and :attr:"
"`TLSVersion.TLSv1_3` are deprecated."
msgstr ""
"Todos los miembros de :class:`TLSVersion`, excepto :attr:`TLSVersion."
"TLSv1_2` y :attr:`TLSVersion.TLSv1_3`, están en desuso."

#: ../Doc/library/ssl.rst:1106
msgid "SSL Sockets"
msgstr "Sockets SSL"

#: ../Doc/library/ssl.rst:1110
msgid "SSL sockets provide the following methods of :ref:`socket-objects`:"
msgstr ""
"Los sockets SSL proporcionan los siguientes métodos de :ref:`socket-objects`:"

#: ../Doc/library/ssl.rst:1112
msgid ":meth:`~socket.socket.accept()`"
msgstr ":meth:`~socket.socket.accept()`"

#: ../Doc/library/ssl.rst:1113
msgid ":meth:`~socket.socket.bind()`"
msgstr ":meth:`~socket.socket.bind()`"

#: ../Doc/library/ssl.rst:1114
msgid ":meth:`~socket.socket.close()`"
msgstr ":meth:`~socket.socket.close()`"

#: ../Doc/library/ssl.rst:1115
msgid ":meth:`~socket.socket.connect()`"
msgstr ":meth:`~socket.socket.connect()`"

#: ../Doc/library/ssl.rst:1116
msgid ":meth:`~socket.socket.detach()`"
msgstr ":meth:`~socket.socket.detach()`"

#: ../Doc/library/ssl.rst:1117
msgid ":meth:`~socket.socket.fileno()`"
msgstr ":meth:`~socket.socket.fileno()`"

#: ../Doc/library/ssl.rst:1118
msgid ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"
msgstr ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"

#: ../Doc/library/ssl.rst:1119
msgid ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"
msgstr ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"

#: ../Doc/library/ssl.rst:1120
msgid ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, :"
"meth:`~socket.socket.setblocking()`"
msgstr ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, :"
"meth:`~socket.socket.setblocking()`"

#: ../Doc/library/ssl.rst:1122
msgid ":meth:`~socket.socket.listen()`"
msgstr ":meth:`~socket.socket.listen()`"

#: ../Doc/library/ssl.rst:1123
msgid ":meth:`~socket.socket.makefile()`"
msgstr ":meth:`~socket.socket.makefile()`"

#: ../Doc/library/ssl.rst:1124
msgid ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (but "
"passing a non-zero ``flags`` argument is not allowed)"
msgstr ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (pero no "
"se admite pasar un argumento ``flags`` diferente de cero)"

#: ../Doc/library/ssl.rst:1126
msgid ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (with the "
"same limitation)"
msgstr ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (con la "
"misma limitación)"

#: ../Doc/library/ssl.rst:1128
msgid ""
":meth:`~socket.socket.sendfile()` (but :mod:`os.sendfile` will be used for "
"plain-text sockets only, else :meth:`~socket.socket.send()` will be used)"
msgstr ""
":meth:`~socket.socket.sendfile()` (pero :mod:`os.sendfile` sera utilizado "
"sólo para sockets de texto simple, sino :meth:`~socket.socket.send()` sera "
"utilizado)"

#: ../Doc/library/ssl.rst:1130
msgid ":meth:`~socket.socket.shutdown()`"
msgstr ":meth:`~socket.socket.shutdown()`"

#: ../Doc/library/ssl.rst:1132
msgid ""
"However, since the SSL (and TLS) protocol has its own framing atop of TCP, "
"the SSL sockets abstraction can, in certain respects, diverge from the "
"specification of normal, OS-level sockets.  See especially the :ref:`notes "
"on non-blocking sockets <ssl-nonblocking>`."
msgstr ""
"Sin embargo, dado que el protocolo SSL (y TLS) tiene su propia estructura "
"encima de TCP, la abstracción de los sockets SSL puede, en ciertos aspectos, "
"divergir de la especificación de los sockets normales a nivel de SO. Ver "
"especialmente las :ref:`notas sobre sockets no bloqueantes <ssl-"
"nonblocking>`."

#: ../Doc/library/ssl.rst:1137
msgid ""
"Instances of :class:`SSLSocket` must be created using the :meth:`SSLContext."
"wrap_socket` method."
msgstr ""
"Instancias de :class:`SSLSocket` deben ser creadas usando el método :meth:"
"`SSLContext.wrap_socket`."

#: ../Doc/library/ssl.rst:1140
msgid "The :meth:`sendfile` method was added."
msgstr "El método :meth:`sendfile` ha sido agregado."

#: ../Doc/library/ssl.rst:1143
msgid ""
"The :meth:`shutdown` does not reset the socket timeout each time bytes are "
"received or sent. The socket timeout is now to maximum total duration of the "
"shutdown."
msgstr ""
"El método :meth:`shutdown` no reinicia el tiempo de espera del socket cada "
"vez que se reciben o envían bytes. El tiempo de espera del socket es ahora "
"la máxima duración del cierre."

#: ../Doc/library/ssl.rst:1148
msgid ""
"It is deprecated to create a :class:`SSLSocket` instance directly, use :meth:"
"`SSLContext.wrap_socket` to wrap a socket."
msgstr ""
"Crear una instancia de :class:`SSLSocket` directamente es obsoleto, utilice :"
"meth:`SSLContext.wrap_socket` para envolver un socket."

#: ../Doc/library/ssl.rst:1152
msgid ""
":class:`SSLSocket` instances must to created with :meth:`~SSLContext."
"wrap_socket`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""
"Las instancias de :class:`SSLSocket` deben crearse con :meth:`~SSLContext."
"wrap_socket`. En versiones anteriores, era posible crear instancias "
"directamente. Esto nunca fue documentado ni soportado oficialmente."

#: ../Doc/library/ssl.rst:1158
msgid ""
"Python now uses ``SSL_read_ex`` and ``SSL_write_ex`` internally. The "
"functions support reading and writing of data larger than 2 GB. Writing zero-"
"length data no longer fails with a protocol violation error."
msgstr ""
"Python ahora usa ``SSL_read_ex`` y ``SSL_write_ex`` internamente. Las "
"funciones admiten la lectura y escritura de datos de más de 2 GB. La "
"escritura de datos de longitud cero ya no falla con un error de violación de "
"protocolo."

#: ../Doc/library/ssl.rst:1163
msgid "SSL sockets also have the following additional methods and attributes:"
msgstr ""
"Los sockets SSL tienen también los siguientes métodos y atributos "
"adicionales:"

#: ../Doc/library/ssl.rst:1167
msgid ""
"Read up to *len* bytes of data from the SSL socket and return the result as "
"a ``bytes`` instance. If *buffer* is specified, then read into the buffer "
"instead, and return the number of bytes read."
msgstr ""
"Lee hasta *len* bytes de datos del socket SSL y retorna el resultado como "
"una instancia ``bytes``. Si *buffer* es especificado, entonces se lee hacia "
"el búfer en su lugar, y retorna el número de bytes leídos."

#: ../Doc/library/ssl.rst:1171
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the read would block."
msgstr ""
"Lanza :exc:`SSLWantReadError` o :exc:`SSLWantWriteError` si el socket es :"
"ref:`no-bloqueante <ssl-nonblocking>` y la lectura se bloquearía."

#: ../Doc/library/ssl.rst:1174
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`read` can also "
"cause write operations."
msgstr ""
"Como en cualquier momento es posible una re-negociación, una llamada a :meth:"
"`read` también puede provocar operaciones de escritura."

#: ../Doc/library/ssl.rst:1177
msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration to read up to *len* "
"bytes."
msgstr ""
"El tiempo de espera del socket ya no se reinicia cada vez que se reciben o "
"envían bytes. El tiempo de espera del socket es ahora la duración total "
"máxima para leer hasta *len* bytes."

#: ../Doc/library/ssl.rst:1182
msgid "Use :meth:`~SSLSocket.recv` instead of :meth:`~SSLSocket.read`."
msgstr "Utilice :meth:`~SSLSocket.recv` en lugar de :meth:`~SSLSocket.read`."

#: ../Doc/library/ssl.rst:1187
msgid ""
"Write *buf* to the SSL socket and return the number of bytes written. The "
"*buf* argument must be an object supporting the buffer interface."
msgstr ""
"Escribe *buf* en el socket SSL y retorna el número de bytes escritos. El "
"argumento *buf* debe ser un objeto que soporte la interfaz búfer."

#: ../Doc/library/ssl.rst:1190
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the write would block."
msgstr ""
"Lanza :exc:`SSLWantReadError` o :exc:`SSLWantWriteError` si el socket es :"
"ref:`no-bloqueante <ssl-nonblocking>` y la escritura se bloquearía."

#: ../Doc/library/ssl.rst:1193
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`write` can "
"also cause read operations."
msgstr ""
"Como en cualquier momento es posible una re-negociación, una llamada a :meth:"
"`write` también puede provocar operaciones de lectura."

#: ../Doc/library/ssl.rst:1196
msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration to write *buf*."
msgstr ""
"El tiempo de espera del socket ya no se reinicia cada vez que se reciben o "
"envían bytes. El tiempo de espera del socket es ahora la duración total "
"máxima para escribir *buf*."

#: ../Doc/library/ssl.rst:1200
msgid "Use :meth:`~SSLSocket.send` instead of :meth:`~SSLSocket.write`."
msgstr "Utilice :meth:`~SSLSocket.send` en lugar de :meth:`~SSLSocket.write`."

#: ../Doc/library/ssl.rst:1205
msgid ""
"The :meth:`~SSLSocket.read` and :meth:`~SSLSocket.write` methods are the low-"
"level methods that read and write unencrypted, application-level data and "
"decrypt/encrypt it to encrypted, wire-level data. These methods require an "
"active SSL connection, i.e. the handshake was completed and :meth:`SSLSocket."
"unwrap` was not called."
msgstr ""
"Los métodos :meth:`~SSLSocket.read` y :meth:`~SSLSocket.write` son los "
"métodos de bajo nivel que leen y escriben datos no cifrados a nivel de "
"aplicación y los descifran/cifran a datos cifrados a nivel de cable. Estos "
"métodos requieren una conexión SSL activa, es decir, que se haya completado "
"el handshake y no se haya llamado a :meth:`SSLSocket.unwrap`."

#: ../Doc/library/ssl.rst:1211
msgid ""
"Normally you should use the socket API methods like :meth:`~socket.socket."
"recv` and :meth:`~socket.socket.send` instead of these methods."
msgstr ""
"Normalmente se deberían utilizar los métodos de la API de sockets como :meth:"
"`~socket.socket.recv` y :meth:`~socket.socket.send` en lugar de estos "
"métodos."

#: ../Doc/library/ssl.rst:1217
msgid "Perform the SSL setup handshake."
msgstr "Realiza el handshake de configuración SSL."

#: ../Doc/library/ssl.rst:1219
msgid ""
"The handshake method also performs :func:`match_hostname` when the :attr:"
"`~SSLContext.check_hostname` attribute of the socket's :attr:`~SSLSocket."
"context` is true."
msgstr ""
"El método handshake también realiza :func:`match_hostname` cuando el "
"atributo :attr:`~SSLContext.check_hostname` del :attr:`~SSLSocket.context` "
"del socket es verdadero."

#: ../Doc/library/ssl.rst:1224
msgid ""
"The socket timeout is no more reset each time bytes are received or sent. "
"The socket timeout is now to maximum total duration of the handshake."
msgstr ""
"El tiempo de espera del socket ya no se reinicia cada vez que se reciben o "
"envían bytes. El tiempo de espera del socket es ahora la duración total "
"máxima del handshake."

#: ../Doc/library/ssl.rst:1228
msgid ""
"Hostname or IP address is matched by OpenSSL during handshake. The function :"
"func:`match_hostname` is no longer used. In case OpenSSL refuses a hostname "
"or IP address, the handshake is aborted early and a TLS alert message is "
"send to the peer."
msgstr ""
"El hostname o la dirección IP son comparados por OpenSSL durante el "
"handshake. La función :func:`match_hostname` ya no se utiliza. En caso de "
"que OpenSSL rechace un hostname o dirección IP, el handshake se aborta antes "
"de tiempo y se envía un mensaje de alerta TLS al peer."

#: ../Doc/library/ssl.rst:1236
msgid ""
"If there is no certificate for the peer on the other end of the connection, "
"return ``None``.  If the SSL handshake hasn't been done yet, raise :exc:"
"`ValueError`."
msgstr ""
"Si no hay un certificado para el peer en el otro extremo de la conexión, "
"devuelve ``None``. Si el handshake SSL no se ha realizado todavía, lanza :"
"exc:`ValueError`."

#: ../Doc/library/ssl.rst:1240
msgid ""
"If the ``binary_form`` parameter is :const:`False`, and a certificate was "
"received from the peer, this method returns a :class:`dict` instance.  If "
"the certificate was not validated, the dict is empty.  If the certificate "
"was validated, it returns a dict with several keys, amongst them ``subject`` "
"(the principal for which the certificate was issued) and ``issuer`` (the "
"principal issuing the certificate).  If a certificate contains an instance "
"of the *Subject Alternative Name* extension (see :rfc:`3280`), there will "
"also be a ``subjectAltName`` key in the dictionary."
msgstr ""
"Si el parámetro ``binary_form`` es :const:`False`, y se ha recibido un "
"certificado del peer, este método devuelve una instancia :class:`dict`. Si "
"el certificado no fue validado, el dict está vacío. Si el certificado fue "
"validado, devuelve un dict con varias claves, entre ellas ``subject`` (la "
"entidad para la que se emitió el certificado) y ``issuer`` (la entidad que "
"emite el certificado). Si un certificado contiene una instancia de la "
"extensión *Subject Alternative Name* (véase :rfc:`3280`), también habrá una "
"clave ``subjectAltName`` en el diccionario."

#: ../Doc/library/ssl.rst:1249
msgid ""
"The ``subject`` and ``issuer`` fields are tuples containing the sequence of "
"relative distinguished names (RDNs) given in the certificate's data "
"structure for the respective fields, and each RDN is a sequence of name-"
"value pairs.  Here is a real-world example::"
msgstr ""
"Los campos ``subject`` y ``issuer`` son tuplas que contienen la secuencia de "
"nombres distinguidos relativos (RDNs) indicados en la estructura de datos "
"del certificado para los campos respectivos, y cada RDN es una secuencia de "
"pares nombre-valor. Este es un ejemplo del mundo real::"

#: ../Doc/library/ssl.rst:1275
msgid ""
"To validate a certificate for a particular service, you can use the :func:"
"`match_hostname` function."
msgstr ""
"Para validar un certificado para un servicio concreto, puede utilizar la "
"función :func:`match_hostname`."

#: ../Doc/library/ssl.rst:1278
msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire certificate "
"as a sequence of bytes, or :const:`None` if the peer did not provide a "
"certificate.  Whether the peer provides a certificate depends on the SSL "
"socket's role:"
msgstr ""
"Si el parámetro ``binary_form`` es :const:`True`, y se proporcionó un "
"certificado, este método devuelve la forma codificada en DER del certificado "
"completo como una secuencia de bytes, o :const:`None` si el par no "
"proporcionó un certificado. El hecho de que el par proporcione un "
"certificado depende del rol del socket SSL:"

#: ../Doc/library/ssl.rst:1284
msgid ""
"for a client SSL socket, the server will always provide a certificate, "
"regardless of whether validation was required;"
msgstr ""
"para un socket SSL cliente, el servidor siempre proporcionará un "
"certificado, independientemente de si se requirió la validación;"

#: ../Doc/library/ssl.rst:1287
msgid ""
"for a server SSL socket, the client will only provide a certificate when "
"requested by the server; therefore :meth:`getpeercert` will return :const:"
"`None` if you used :const:`CERT_NONE` (rather than :const:`CERT_OPTIONAL` "
"or :const:`CERT_REQUIRED`)."
msgstr ""
"para un socket SSL servidor, el cliente sólo proporcionará un certificado "
"cuando lo solicite el servidor; por lo tanto :meth:`getpeercert` devolverá :"
"const:`None` si ha utilizado :const:`CERT_NONE` (en lugar de :const:"
"`CERT_OPTIONAL` o :const:`CERT REQUIRED`)."

#: ../Doc/library/ssl.rst:1292
msgid ""
"The returned dictionary includes additional items such as ``issuer`` and "
"``notBefore``."
msgstr ""
"El diccionario devuelto incluye elementos adicionales tales como ``issuer`` "
"y ``notBefore``."

#: ../Doc/library/ssl.rst:1296
msgid ""
":exc:`ValueError` is raised when the handshake isn't done. The returned "
"dictionary includes additional X509v3 extension items   such as "
"``crlDistributionPoints``, ``caIssuers`` and ``OCSP`` URIs."
msgstr ""
":exc:`ValueError` se lanza cuando no se realiza el handshake. El diccionario "
"retornado incluye elementos de extensión X509v3 adicionales como "
"``crlDistributionPoints``, ``caIssuers`` y ``OCSP`` URIs."

#: ../Doc/library/ssl.rst:1301
msgid "IPv6 address strings no longer have a trailing new line."
msgstr "Las cadenas de direcciones IPv6 ya no tienen una nueva línea al final."

#: ../Doc/library/ssl.rst:1306
msgid ""
"Returns a three-value tuple containing the name of the cipher being used, "
"the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr ""
"Retorna una tupla de tres valores que contiene el nombre del cifrado que se "
"está utilizando, la versión del protocolo SSL que define su uso y el número "
"de bits secretos que se están utilizando. Si no se ha establecido ninguna "
"conexión, retorna ``None``."

#: ../Doc/library/ssl.rst:1312
msgid ""
"Return the list of ciphers shared by the client during the handshake.  Each "
"entry of the returned list is a three-value tuple containing the name of the "
"cipher, the version of the SSL protocol that defines its use, and the number "
"of secret bits the cipher uses.  :meth:`~SSLSocket.shared_ciphers` returns "
"``None`` if no connection has been established or the socket is a client "
"socket."
msgstr ""
"Retorna la lista de cifrados compartidos por el cliente durante el "
"handshake. Cada entrada de la lista devuelta es una tupla de tres valores "
"que contiene el nombre del cifrado, la versión del protocolo SSL que define "
"su uso y el número de bits secretos que utiliza el cifrado. :meth:"
"`~SSLSocket.shared_ciphers`` retorna ``None`` si no se ha establecido "
"ninguna conexión o el socket es un socket cliente."

#: ../Doc/library/ssl.rst:1323
msgid ""
"Return the compression algorithm being used as a string, or ``None`` if the "
"connection isn't compressed."
msgstr ""
"Retorna el algoritmo de compresión utilizado como una cadena de caracteres, "
"o ``None`` si la conexión no está comprimida."

#: ../Doc/library/ssl.rst:1326
msgid ""
"If the higher-level protocol supports its own compression mechanism, you can "
"use :data:`OP_NO_COMPRESSION` to disable SSL-level compression."
msgstr ""
"Si el protocolo de nivel superior soporta su propio mecanismo de compresión, "
"puede utilizar :data:`OP_NO_COMPRESSION` para desactivar la compresión a "
"nivel de SSL."

#: ../Doc/library/ssl.rst:1333
msgid ""
"Get channel binding data for current connection, as a bytes object.  Returns "
"``None`` if not connected or the handshake has not been completed."
msgstr ""
"Obtiene los datos de enlace del canal para la conexión actual, como un "
"objeto bytes. Retorna ``None`` si no está conectado o no se ha completado el "
"handshake."

#: ../Doc/library/ssl.rst:1336
msgid ""
"The *cb_type* parameter allow selection of the desired channel binding type. "
"Valid channel binding types are listed in the :data:`CHANNEL_BINDING_TYPES` "
"list.  Currently only the 'tls-unique' channel binding, defined by :rfc:"
"`5929`, is supported.  :exc:`ValueError` will be raised if an unsupported "
"channel binding type is requested."
msgstr ""
"El parámetro *cb_type* permite seleccionar el tipo de enlace de canal "
"deseado. Los tipos de enlace de canal válidos se enumeran en la lista :data:"
"`CHANNEL_BINDING_TYPES`. Actualmente, sólo se admite la vinculación de canal "
"'tls-unique', definida por :rfc:`5929`. :exc:`ValueError` se lanzará si se "
"solicita un tipo de vinculación de canal no admitido."

#: ../Doc/library/ssl.rst:1346
msgid ""
"Return the protocol that was selected during the TLS handshake.  If :meth:"
"`SSLContext.set_alpn_protocols` was not called, if the other party does not "
"support ALPN, if this socket does not support any of the client's proposed "
"protocols, or if the handshake has not happened yet, ``None`` is returned."
msgstr ""
"Retorna el protocolo que fue seleccionado durante el handshake TLS. Si no se "
"ha llamado a :meth:`SSLContext.set_alpn_protocols`, si la otra parte no "
"soporta ALPN, si este socket no soporta ninguno de los protocolos propuestos "
"por el cliente, o si el handshake no ha ocurrido todavía, se devuelve "
"``None``."

#: ../Doc/library/ssl.rst:1356
msgid ""
"Return the higher-level protocol that was selected during the TLS/SSL "
"handshake. If :meth:`SSLContext.set_npn_protocols` was not called, or if the "
"other party does not support NPN, or if the handshake has not yet happened, "
"this will return ``None``."
msgstr ""
"Devuelve el protocolo de nivel superior que se seleccionó durante el "
"handshake TLS/SSL. Si no se llamó a :meth:`SSLContext.set_npn_protocols`, o "
"si la otra parte no soporta NPN, o si el handshake aún no ha ocurrido, esto "
"devolverá ``None``."

#: ../Doc/library/ssl.rst:1365 ../Doc/library/ssl.rst:1725
msgid "NPN has been superseded by ALPN"
msgstr "NPN ha sido reemplazada por ALPN"

#: ../Doc/library/ssl.rst:1369
msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the "
"underlying socket, and returns the underlying socket object.  This can be "
"used to go from encrypted operation over a connection to unencrypted.  The "
"returned socket should always be used for further communication with the "
"other side of the connection, rather than the original socket."
msgstr ""
"Realiza el handshake de cierre de SSL, que elimina la capa TLS del socket "
"subyacente, y devuelve el objeto socket subyacente. Esto puede utilizarse "
"para pasar de una operación encriptada sobre una conexión a una sin "
"encriptar. El socket devuelto debe utilizarse siempre para la comunicación "
"posterior con el otro lado de la conexión, en lugar del socket original."

#: ../Doc/library/ssl.rst:1377
msgid ""
"Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA can "
"only be initiated for a TLS 1.3 connection from a server-side socket, after "
"the initial TLS handshake and with PHA enabled on both sides, see :attr:"
"`SSLContext.post_handshake_auth`."
msgstr ""
"Solicita la autenticación post-handshake (PHA) de un cliente TLS 1.3. PHA "
"sólo puede iniciarse para una conexión TLS 1.3 desde un socket del lado del "
"servidor, después del handshake TLS inicial y con PHA habilitado en ambos "
"lados, ver :attr:`SSLContext.post_handshake_auth`."

#: ../Doc/library/ssl.rst:1382
msgid ""
"The method does not perform a cert exchange immediately. The server-side "
"sends a CertificateRequest during the next write event and expects the "
"client to respond with a certificate on the next read event."
msgstr ""
"El método no realiza un intercambio de certificados inmediatamente. El lado "
"del servidor envía una CertificateRequest durante el siguiente evento de "
"escritura y espera que el cliente responda con un certificado en el "
"siguiente evento de lectura."

#: ../Doc/library/ssl.rst:1386
msgid ""
"If any precondition isn't met (e.g. not TLS 1.3, PHA not enabled), an :exc:"
"`SSLError` is raised."
msgstr ""
"Si alguna precondición no se cumple (por ejemplo, no es TLS 1.3, PHA no está "
"habilitado), se genera un :exc:`SSLError`."

#: ../Doc/library/ssl.rst:1390
msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the method raises :exc:`NotImplementedError`."
msgstr ""
"Sólo está disponible con OpenSSL 1.1.1 y TLS 1.3 habilitados. Sin el soporte "
"de TLS 1.3, el método lanza :exc:`NotImplementedError`."

#: ../Doc/library/ssl.rst:1397
#, fuzzy
msgid ""
"Return the actual SSL protocol version negotiated by the connection as a "
"string, or ``None`` if no secure connection is established. As of this "
"writing, possible return values include ``\"SSLv2\"``, ``\"SSLv3\"``, "
"``\"TLSv1\"``, ``\"TLSv1.1\"`` and ``\"TLSv1.2\"``. Recent OpenSSL versions "
"may define more return values."
msgstr ""
"Devuelve la versión actual del protocolo SSL negociada por la conexión como "
"una cadena de caracteres, o ``None`` si no se ha establecido ninguna "
"conexión segura. En este momento, los posibles valores de retorno incluyen "
"``\"SSLv2\"``, ``\"SSLv3\"``, ``\"TLSv1\"``, ``\"TLSv1.1\"`` y "
"``\"TLSv1.2\"``. Las versiones recientes de OpenSSL pueden definir más "
"valores de retorno."

#: ../Doc/library/ssl.rst:1407
msgid ""
"Returns the number of already decrypted bytes available for read, pending on "
"the connection."
msgstr ""
"Retorna el número de bytes ya descifrados disponibles para leer, pendientes "
"de la conexión."

#: ../Doc/library/ssl.rst:1412
msgid ""
"The :class:`SSLContext` object this SSL socket is tied to.  If the SSL "
"socket was created using the deprecated :func:`wrap_socket` function (rather "
"than :meth:`SSLContext.wrap_socket`), this is a custom context object "
"created for this SSL socket."
msgstr ""
"El objeto :class:`SSLContext` al que está vinculado este socket SSL. Si el "
"socket SSL fue creado usando la función obsoleta :func:`wrap_socket` (en "
"lugar de :meth:`SSLContext.wrap_socket`), este es un objeto de contexto "
"personalizado creado para este socket SSL."

#: ../Doc/library/ssl.rst:1421
msgid ""
"A boolean which is ``True`` for server-side sockets and ``False`` for client-"
"side sockets."
msgstr ""
"Un booleano que es ``True`` para los sockets del lado del servidor y "
"``False`` para los sockets del lado del cliente."

#: ../Doc/library/ssl.rst:1428
msgid ""
"Hostname of the server: :class:`str` type, or ``None`` for server-side "
"socket or if the hostname was not specified in the constructor."
msgstr ""
"Hostname del servidor: tipo :class:`str`, o ``None`` para el socket del lado "
"del servidor o si el hostname no fue especificado en el constructor."

#: ../Doc/library/ssl.rst:1433
msgid ""
"The attribute is now always ASCII text. When ``server_hostname`` is an "
"internationalized domain name (IDN), this attribute now stores the A-label "
"form (``\"xn--pythn-mua.org\"``), rather than the U-label form (``\"pythön."
"org\"``)."
msgstr ""
"El atributo es ahora siempre texto ASCII. Cuando ``server_hostname`` es un "
"nombre de dominio internacionalizado (IDN), este atributo almacena ahora la "
"forma de etiqueta A (``\"xn--pythn-mua.org\"``), en lugar de la forma de "
"etiqueta U (``\"pythön.org\"``)."

#: ../Doc/library/ssl.rst:1441
msgid ""
"The :class:`SSLSession` for this SSL connection. The session is available "
"for client and server side sockets after the TLS handshake has been "
"performed. For client sockets the session can be set before :meth:"
"`~SSLSocket.do_handshake` has been called to reuse a session."
msgstr ""
"La :class:`SSLSession` para esta conexión SSL. La sesión está disponible "
"para los sockets del lado del cliente y del servidor después de que se haya "
"realizado el handshake TLS. Para los sockets del cliente la sesión puede ser "
"establecida antes de que :meth:`~SSLSocket.do_handshake` haya sido llamado "
"para reutilizar una sesión."

#: ../Doc/library/ssl.rst:1454
msgid "SSL Contexts"
msgstr "Contextos SSL"

#: ../Doc/library/ssl.rst:1458
msgid ""
"An SSL context holds various data longer-lived than single SSL connections, "
"such as SSL configuration options, certificate(s) and private key(s). It "
"also manages a cache of SSL sessions for server-side sockets, in order to "
"speed up repeated connections from the same clients."
msgstr ""
"Un contexto SSL contiene varios datos más duraderos que las conexiones SSL "
"individuales, como opciones de configuración SSL, certificado(s) y clave(s) "
"privada(s). También gestiona un cache de sesiones SSL para sockets del lado "
"del servidor, para acelerar conexiones repetidas de los mismos clientes."

#: ../Doc/library/ssl.rst:1465
msgid ""
"Create a new SSL context.  You may pass *protocol* which must be one of the "
"``PROTOCOL_*`` constants defined in this module.  The parameter specifies "
"which version of the SSL protocol to use.  Typically, the server chooses a "
"particular protocol version, and the client must adapt to the server's "
"choice.  Most of the versions are not interoperable with the other "
"versions.  If not specified, the default is :data:`PROTOCOL_TLS`; it "
"provides the most compatibility with other versions."
msgstr ""
"Crea un nuevo contexto SSL. Puede pasar *protocolo* que debe ser una de las "
"constantes ``PROTOCOL_*`` definidas en este módulo. El parámetro especifica "
"la versión del protocolo SSL a utilizar. Típicamente, el servidor elige una "
"versión particular del protocolo, y el cliente debe adaptarse a la elección "
"del servidor. La mayoría de las versiones no son interoperables con las "
"demás. Si no se especifica, el valor por defecto es :data:`PROTOCOL_TLS`; "
"proporciona la mayor compatibilidad con otras versiones."

#: ../Doc/library/ssl.rst:1474
msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr ""
"Esta es una tabla que muestra qué versiones de un cliente (en la parte "
"inferior) pueden conectarse a qué versiones de un servidor (en la parte "
"superior):"

#: ../Doc/library/ssl.rst:1480
msgid "*client* / **server**"
msgstr "*cliente* / **servidor**"

#: ../Doc/library/ssl.rst:1480
msgid "**SSLv2**"
msgstr "**SSLv2**"

#: ../Doc/library/ssl.rst:1480
msgid "**SSLv3**"
msgstr "**SSLv3**"

#: ../Doc/library/ssl.rst:1480
msgid "**TLS** [3]_"
msgstr "**TLS** [3]_"

#: ../Doc/library/ssl.rst:1480
msgid "**TLSv1**"
msgstr "**TLSv1**"

#: ../Doc/library/ssl.rst:1480
msgid "**TLSv1.1**"
msgstr "**TLSv1.1**"

#: ../Doc/library/ssl.rst:1480
msgid "**TLSv1.2**"
msgstr "**TLSv1.2**"

#: ../Doc/library/ssl.rst:1482
msgid "*SSLv2*"
msgstr "*SSLv2*"

#: ../Doc/library/ssl.rst:1482 ../Doc/library/ssl.rst:1483
#: ../Doc/library/ssl.rst:1484 ../Doc/library/ssl.rst:1485
#: ../Doc/library/ssl.rst:1486 ../Doc/library/ssl.rst:1487
msgid "yes"
msgstr "si"

#: ../Doc/library/ssl.rst:1482 ../Doc/library/ssl.rst:1483
#: ../Doc/library/ssl.rst:1485 ../Doc/library/ssl.rst:1486
#: ../Doc/library/ssl.rst:1487
msgid "no"
msgstr "no"

#: ../Doc/library/ssl.rst:1482 ../Doc/library/ssl.rst:1484
msgid "no [1]_"
msgstr "no [1]_"

#: ../Doc/library/ssl.rst:1483
msgid "*SSLv3*"
msgstr "*SSLv3*"

#: ../Doc/library/ssl.rst:1483 ../Doc/library/ssl.rst:1484
msgid "no [2]_"
msgstr "no [2]_"

#: ../Doc/library/ssl.rst:1484
msgid "*TLS* (*SSLv23*) [3]_"
msgstr "*TLS* (*SSLv23*) [3]_"

#: ../Doc/library/ssl.rst:1485
msgid "*TLSv1*"
msgstr "*TLSv1*"

#: ../Doc/library/ssl.rst:1486
msgid "*TLSv1.1*"
msgstr "*TLSv1.1*"

#: ../Doc/library/ssl.rst:1487
msgid "*TLSv1.2*"
msgstr "*TLSv1.2*"

#: ../Doc/library/ssl.rst:1490
msgid "Footnotes"
msgstr "Notas a pie de página"

#: ../Doc/library/ssl.rst:1491
msgid ":class:`SSLContext` disables SSLv2 with :data:`OP_NO_SSLv2` by default."
msgstr ""
":class:`SSLContext` desactiva SSLv2 con :data:`OP_NO_SSLv2` por defecto."

#: ../Doc/library/ssl.rst:1492
msgid ":class:`SSLContext` disables SSLv3 with :data:`OP_NO_SSLv3` by default."
msgstr ""
":class:`SSLContext` desactiva SSLv3 con :data:`OP_NO_SSLv3` por defecto."

#: ../Doc/library/ssl.rst:1493
msgid ""
"TLS 1.3 protocol will be available with :data:`PROTOCOL_TLS` in OpenSSL >= "
"1.1.1. There is no dedicated PROTOCOL constant for just TLS 1.3."
msgstr ""
"El protocolo TLS 1.3 estará disponible con :data:`PROTOCOL_TLS` en OpenSSL "
">= 1.1.1. No existe una constante PROTOCOL dedicada sólo a TLS 1.3."

#: ../Doc/library/ssl.rst:1498
msgid ""
":func:`create_default_context` lets the :mod:`ssl` module choose security "
"settings for a given purpose."
msgstr ""
":func:`create_default_context` permite al módulo :mod:`ssl` elegir la "
"configuración de seguridad para un propósito determinado."

#: ../Doc/library/ssl.rst:1503
msgid ""
"The context is created with secure default values. The options :data:"
"`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, :data:"
"`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2` (except "
"for :data:`PROTOCOL_SSLv2`), and :data:`OP_NO_SSLv3` (except for :data:"
"`PROTOCOL_SSLv3`) are set by default. The initial cipher suite list contains "
"only ``HIGH`` ciphers, no ``NULL`` ciphers and no ``MD5`` ciphers (except "
"for :data:`PROTOCOL_SSLv2`)."
msgstr ""
"El contexto se crea con valores seguros por defecto. Las opciones :data:"
"`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, :data:"
"`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2` (excepto "
"para :data:`PROTOCOL_SSLv2`), y :data:`OP_NO_SSLv3` (excepto para :data:"
"`PROTOCOL_SSLv3`) están establecidas por defecto. La lista inicial de "
"conjuntos de cifrado sólo contiene cifrados ``HIGH``, ningún cifrado "
"``NULL`` y ningún cifrado ``MD5`` (excepto para :data:`PROTOCOL_SSLv2`)."

#: ../Doc/library/ssl.rst:1514
msgid ""
":class:`SSLContext` without protocol argument is deprecated. The context "
"class will either require :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER` protocol in the future."
msgstr ""
":class:`SSLContext` sin argumento de protocolo está en desuso. La clase de "
"contexto requerirá el protocolo :data:`PROTOCOL_TLS_CLIENT` o :data:"
"`PROTOCOL_TLS_SERVER` en el futuro."

#: ../Doc/library/ssl.rst:1520
msgid ""
"The default cipher suites now include only secure AES and ChaCha20 ciphers "
"with forward secrecy and security level 2. RSA and DH keys with less than "
"2048 bits and ECC keys with less than 224 bits are prohibited. :data:"
"`PROTOCOL_TLS`, :data:`PROTOCOL_TLS_CLIENT`, and :data:`PROTOCOL_TLS_SERVER` "
"use TLS 1.2 as minimum TLS version."
msgstr ""
"Los conjuntos de cifrado predeterminados ahora incluyen solo cifrados AES y "
"ChaCha20 seguros con secreto directo y nivel de seguridad 2. Están "
"prohibidas las claves RSA y DH con menos de 2048 bits y las claves ECC con "
"menos de 224 bits. :data:`PROTOCOL_TLS`, :data:`PROTOCOL_TLS_CLIENT` y :data:"
"`PROTOCOL_TLS_SERVER` usan TLS 1.2 como versión mínima de TLS."

#: ../Doc/library/ssl.rst:1527
msgid ":class:`SSLContext` objects have the following methods and attributes:"
msgstr ""
"Los objetos :class:`SSLContext` tienen los siguientes métodos y atributos:"

#: ../Doc/library/ssl.rst:1531
msgid ""
"Get statistics about quantities of loaded X.509 certificates, count of X.509 "
"certificates flagged as CA certificates and certificate revocation lists as "
"dictionary."
msgstr ""
"Obtiene estadísticas sobre las cantidades de certificados X.509 cargados, la "
"cantidad de certificados X.509 marcados como certificados CA y las listas de "
"revocación de certificados como diccionario."

#: ../Doc/library/ssl.rst:1535
msgid "Example for a context with one CA cert and one other cert::"
msgstr "Ejemplo para un contexto con un certificado CA y otro certificado::"

#: ../Doc/library/ssl.rst:1545
#, fuzzy
msgid ""
"Load a private key and the corresponding certificate.  The *certfile* string "
"must be the path to a single file in PEM format containing the certificate "
"as well as any number of CA certificates needed to establish the "
"certificate's authenticity.  The *keyfile* string, if present, must point to "
"a file containing the private key.  Otherwise the private key will be taken "
"from *certfile* as well.  See the discussion of :ref:`ssl-certificates` for "
"more information on how the certificate is stored in the *certfile*."
msgstr ""
"Carga una clave privada y el certificado correspondiente. La cadena de "
"caracteres *certfile* debe ser la ruta de un único archivo en formato PEM "
"que contenga el certificado, así como cualquier número de certificados de CA "
"necesarios para establecer la autenticidad del certificado. La cadena de "
"caracteres *keyfile*, si está presente, debe apuntar a un archivo que "
"contenga la clave privada. De lo contrario, la clave privada se tomará "
"también de *certfile*. Consulte la discusión de :ref:`ssl-certificates` para "
"más información sobre cómo se almacena el certificado en el *certfile*."

#: ../Doc/library/ssl.rst:1554
msgid ""
"The *password* argument may be a function to call to get the password for "
"decrypting the private key.  It will only be called if the private key is "
"encrypted and a password is necessary.  It will be called with no arguments, "
"and it should return a string, bytes, or bytearray.  If the return value is "
"a string it will be encoded as UTF-8 before using it to decrypt the key. "
"Alternatively a string, bytes, or bytearray value may be supplied directly "
"as the *password* argument.  It will be ignored if the private key is not "
"encrypted and no password is needed."
msgstr ""
"El argumento *password* puede ser una función a la que llamar para obtener "
"la contraseña para descifrar la clave privada. Sólo se llamará si la clave "
"privada está encriptada y se necesita una contraseña. Se llamará sin "
"argumentos, y deberá devolver una cadena de caracteres, bytes o bytearray. "
"Si el valor devuelto es una cadena de caracteres, se codificará como UTF-8 "
"antes de utilizarlo para descifrar la clave. Alternativamente, se puede "
"suministrar un valor de cadena de caracteres, bytes o bytearray directamente "
"como argumento *password*. Se ignorará si la clave privada no está cifrada y "
"no se necesita una contraseña."

#: ../Doc/library/ssl.rst:1563
msgid ""
"If the *password* argument is not specified and a password is required, "
"OpenSSL's built-in password prompting mechanism will be used to "
"interactively prompt the user for a password."
msgstr ""
"Si el argumento *password* no es especificado y una contraseña es requerida, "
"el mecanismo de solicitud de contraseña incorporado de OpenSSL se usará para "
"solicitarle una contraseña al usuario de forma interactiva."

#: ../Doc/library/ssl.rst:1567
msgid ""
"An :class:`SSLError` is raised if the private key doesn't match with the "
"certificate."
msgstr ""
"Un :class:`SSLError` es lanzado si la clave privada no coincide con el "
"certificado."

#: ../Doc/library/ssl.rst:1570
msgid "New optional argument *password*."
msgstr "Nuevo argumento opcional *password*."

#: ../Doc/library/ssl.rst:1575
#, fuzzy
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from "
"default locations. On Windows it loads CA certs from the ``CA`` and ``ROOT`` "
"system stores. On all systems it calls :meth:`SSLContext."
"set_default_verify_paths`. In the future the method may load CA certificates "
"from other locations, too."
msgstr ""
"Carga un conjunto de certificados de \"autoridad de certificación\" (CA) por "
"defecto desde ubicaciones predeterminadas. En Windows carga los certificados "
"de CA desde los almacenes del sistema ``CA`` y ``ROOT``. En otros sistemas "
"llama a :meth:`SSLContext.set_default_verify_paths`. En el futuro el método "
"puede cargar certificados de CA desde otras ubicaciones también."

#: ../Doc/library/ssl.rst:1581
msgid ""
"The *purpose* flag specifies what kind of CA certificates are loaded. The "
"default settings :data:`Purpose.SERVER_AUTH` loads certificates, that are "
"flagged and trusted for TLS web server authentication (client side "
"sockets). :data:`Purpose.CLIENT_AUTH` loads CA certificates for client "
"certificate verification on the server side."
msgstr ""
"La opción *purpose* especifica qué tipo de certificados CA se cargan. La "
"configuración por defecto :data:`Purpose.SERVER_AUTH` carga certificados, "
"que están marcados y son de confianza para la autenticación del servidor web "
"TLS (sockets del lado del cliente). :data:`Purpose.CLIENT_AUTH` carga "
"certificados CA para la verificación de certificados de cliente en el lado "
"del servidor."

#: ../Doc/library/ssl.rst:1591
msgid ""
"Load a set of \"certification authority\" (CA) certificates used to validate "
"other peers' certificates when :data:`verify_mode` is other than :data:"
"`CERT_NONE`.  At least one of *cafile* or *capath* must be specified."
msgstr ""
"Carga un conjunto de certificados de \"autoridad de certificación\" (CA) "
"usados para validar certificados de otros pares cuando :data:`verify_mode` "
"es distinto de :data:`CERT_NONE`. Debe especificarse al menos uno de "
"*cafile* o *capath*."

#: ../Doc/library/ssl.rst:1595
msgid ""
"This method can also load certification revocation lists (CRLs) in PEM or "
"DER format. In order to make use of CRLs, :attr:`SSLContext.verify_flags` "
"must be configured properly."
msgstr ""
"Este método puede cargar también listas de revocación de certificados (CRLs) "
"en formato PEM o DER. Para poder usar CRLs, :attr:`SSLContext.verify_flags` "
"debe ser configurado correctamente."

#: ../Doc/library/ssl.rst:1599
msgid ""
"The *cafile* string, if present, is the path to a file of concatenated CA "
"certificates in PEM format. See the discussion of :ref:`ssl-certificates` "
"for more information about how to arrange the certificates in this file."
msgstr ""
"La cadena de caracteres *cafile*, si está presente, es la ruta a un archivo "
"de certificados CA concatenados en formato PEM. Vea la discusión de :ref:"
"`ssl-certificates` para más información acerca de como organizar los "
"certificados en este archivo."

#: ../Doc/library/ssl.rst:1604
msgid ""
"The *capath* string, if present, is the path to a directory containing "
"several CA certificates in PEM format, following an `OpenSSL specific layout "
"<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations."
"html>`_."
msgstr ""
"La cadena de caracteres *capath*, si está presente, es la ruta a un "
"directorio que contiene varios certificados CA en formato PEM, siguiendo la "
"`disposición específica de OpenSSL <https://www.openssl.org/docs/manmaster/"
"man3/SSL_CTX_load_verify_locations.html>`_."

#: ../Doc/library/ssl.rst:1609
msgid ""
"The *cadata* object, if present, is either an ASCII string of one or more "
"PEM-encoded certificates or a :term:`bytes-like object` of DER-encoded "
"certificates. Like with *capath* extra lines around PEM-encoded certificates "
"are ignored but at least one certificate must be present."
msgstr ""
"El objeto *cadata*, si está presente, es una cadena de caracteres ASCII de "
"uno o más certificados codificados en PEM o un :term:`bytes-like object` de "
"certificados codificados en DER. Al igual que con *capath*, las líneas "
"adicionales alrededor de los certificados codificados en PEM se ignoran, "
"pero debe haber al menos un certificado."

#: ../Doc/library/ssl.rst:1614
msgid "New optional argument *cadata*"
msgstr "Nuevo argumento opcional *cadata*"

#: ../Doc/library/ssl.rst:1619
msgid ""
"Get a list of loaded \"certification authority\" (CA) certificates. If the "
"``binary_form`` parameter is :const:`False` each list entry is a dict like "
"the output of :meth:`SSLSocket.getpeercert`. Otherwise the method returns a "
"list of DER-encoded certificates. The returned list does not contain "
"certificates from *capath* unless a certificate was requested and loaded by "
"a SSL connection."
msgstr ""
"Obtiene una lista de certificados de \"autoridad de certificación\" (CA) "
"cargados. Si el parámetro ``binary_form`` es :const:`False` cada entrada de "
"la lista es un diccionario como la salida de :meth:`SSLSocket.getpeercert`. "
"En caso contrario, el método devuelve una lista de certificados codificados "
"con DER. La lista devuelta no contiene certificados de *capath* a menos que "
"un certificado haya sido solicitado y cargado por una conexión SSL."

#: ../Doc/library/ssl.rst:1627
msgid ""
"Certificates in a capath directory aren't loaded unless they have been used "
"at least once."
msgstr ""
"Los certificados de un directorio capath no se cargan a menos que se hayan "
"utilizado al menos una vez."

#: ../Doc/library/ssl.rst:1634
msgid ""
"Get a list of enabled ciphers. The list is in order of cipher priority. See :"
"meth:`SSLContext.set_ciphers`."
msgstr ""
"Obtiene una lista de cifrados habilitados. La lista está en orden de "
"prioridad de cifrado. Véase :meth:`SSLContext.set_ciphers`."

#: ../Doc/library/ssl.rst:1671
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from a "
"filesystem path defined when building the OpenSSL library.  Unfortunately, "
"there's no easy way to know whether this method succeeds: no error is "
"returned if no certificates are to be found.  When the OpenSSL library is "
"provided as part of the operating system, though, it is likely to be "
"configured properly."
msgstr ""
"Carga un conjunto de certificados de \"autoridad de certificación\" (CA) por "
"defecto desde una ruta del sistema de archivos definida al construir la "
"biblioteca OpenSSL. Desafortunadamente, no hay una manera fácil de saber si "
"este método tiene éxito: no se devuelve ningún error si no se encuentran "
"certificados. Sin embargo, cuando la biblioteca OpenSSL se proporciona como "
"parte del sistema operativo, es probable que esté configurada correctamente."

#: ../Doc/library/ssl.rst:1680
msgid ""
"Set the available ciphers for sockets created with this context. It should "
"be a string in the `OpenSSL cipher list format <https://www.openssl.org/docs/"
"manmaster/man1/ciphers.html>`_. If no cipher can be selected (because "
"compile-time options or other configuration forbids use of all the specified "
"ciphers), an :class:`SSLError` will be raised."
msgstr ""
"Establece los cifrados disponibles para los sockets creados con este "
"contexto. Debe ser una cadena de caracteres con el `formato de la lista de "
"cifrado de OpenSSL <https://www.openssl.org/docs/manmaster/man1/ciphers."
"html>`_. Si no se puede seleccionar ningún cifrado (porque las opciones en "
"tiempo de compilación u otra configuración prohíben el uso de todos los "
"cifrados especificados), se lanzará un :class:`SSLError`."

#: ../Doc/library/ssl.rst:1688
msgid ""
"when connected, the :meth:`SSLSocket.cipher` method of SSL sockets will give "
"the currently selected cipher."
msgstr ""
"cuando se conecta, el método :meth:`SSLSocket.cipher` de los sockets SSL "
"dará el cifrado actualmente seleccionado."

#: ../Doc/library/ssl.rst:1691
msgid ""
"TLS 1.3 cipher suites cannot be disabled with :meth:`~SSLContext."
"set_ciphers`."
msgstr ""
"OpenSSL 1.1.1 tiene suites de cifrado TLS 1.3 habilitadas por defecto. Las "
"suites no se pueden desactivar con :meth:`~SSLContext.set_ciphers`."

#: ../Doc/library/ssl.rst:1696
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of ASCII strings, like ``['http/1.1', "
"'spdy/2']``, ordered by preference. The selection of a protocol will happen "
"during the handshake, and will play out according to :rfc:`7301`. After a "
"successful handshake, the :meth:`SSLSocket.selected_alpn_protocol` method "
"will return the agreed-upon protocol."
msgstr ""
"Especifica qué protocolos debe anunciar el socket durante el handshake SSL/"
"TLS. Debe ser una lista de cadenas de caracteres ASCII, como ``['http/1.1', "
"'spdy/2']``, ordenadas por preferencia. La selección de un protocolo "
"ocurrirá durante el handshake, y se desarrollará de acuerdo con :rfc:`7301`. "
"Después de un handshake exitoso, el método :meth:`SSLSocket."
"selected_alpn_protocol` devolverá el protocolo acordado."

#: ../Doc/library/ssl.rst:1703
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_ALPN` is "
"``False``."
msgstr ""
"Este método lanzará :exc:`NotImplementedError` si :data:`HAS_ALPN` es "
"``False``."

#: ../Doc/library/ssl.rst:1710
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of strings, like ``['http/1.1', 'spdy/2']``, "
"ordered by preference. The selection of a protocol will happen during the "
"handshake, and will play out according to the `Application Layer Protocol "
"Negotiation <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. After a successful handshake, the :meth:"
"`SSLSocket.selected_npn_protocol` method will return the agreed-upon "
"protocol."
msgstr ""
"Especifica qué protocolos debe anunciar el socket durante el handshake SSL/"
"TLS. Debe ser una lista de cadenas, como ``['http/1.1', 'spdy/2']``, "
"ordenadas por preferencia. La selección de un protocolo ocurrirá durante el "
"handshake, y se desarrollará de acuerdo a la `Negociación del Protocolo de "
"la Capa de Aplicación <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. Después de un handshake exitoso, el método :"
"meth:`SSLSocket.selected_npn_protocol` devolverá el protocolo acordado."

#: ../Doc/library/ssl.rst:1718
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_NPN` is "
"``False``."
msgstr ""
"Este método lanzará :exc:`NotImplementedError` si :data:`HAS_NPN` es "
"``False``."

# No traduzco el título de la sección 3 de la RFC porque la RFC está sólo en
# inglés.
#: ../Doc/library/ssl.rst:1729
msgid ""
"Register a callback function that will be called after the TLS Client Hello "
"handshake message has been received by the SSL/TLS server when the TLS "
"client specifies a server name indication. The server name indication "
"mechanism is specified in :rfc:`6066` section 3 - Server Name Indication."
msgstr ""
"Registra una función callback que se llamará después de que el servidor SSL/"
"TLS haya recibido el mensaje de diálogo TLS Client Hello cuando el cliente "
"TLS especifique una indicación de nombre de servidor. El mecanismo de "
"indicación de nombre de servidor se especifica en :rfc:`6066` sección 3 - "
"Server Name Indication."

#: ../Doc/library/ssl.rst:1734
msgid ""
"Only one callback can be set per ``SSLContext``.  If *sni_callback* is set "
"to ``None`` then the callback is disabled. Calling this function a "
"subsequent time will disable the previously registered callback."
msgstr ""
"Sólo se puede establecer una función callback por ``SSLContext``. Si "
"*sni_callback* se establece como ``None``, la función callback se desactiva. "
"Si se llama a esta función una vez más, se desactivará la función callback "
"registrada anteriormente."

#: ../Doc/library/ssl.rst:1738
msgid ""
"The callback function will be called with three arguments; the first being "
"the :class:`ssl.SSLSocket`, the second is a string that represents the "
"server name that the client is intending to communicate (or :const:`None` if "
"the TLS Client Hello does not contain a server name) and the third argument "
"is the original :class:`SSLContext`. The server name argument is text. For "
"internationalized domain name, the server name is an IDN A-label (``\"xn--"
"pythn-mua.org\"``)."
msgstr ""
"La función callback será llamada con tres argumentos; el primero es el :"
"class:`ssl.SSLSocket`, el segundo es una cadena que representa el nombre del "
"servidor con el que el cliente pretende comunicarse (o :const:`None` si el "
"TLS Client Hello no contiene un nombre de servidor) y el tercer argumento es "
"el :class:`SSLContext` original. El argumento del nombre del servidor es un "
"texto. En el caso de los nombres de dominio internacionalizados, el nombre "
"del servidor es un IDN etiqueta A (``\"xn--pythn-mua.org\"``)."

#: ../Doc/library/ssl.rst:1746
msgid ""
"A typical use of this callback is to change the :class:`ssl.SSLSocket`'s :"
"attr:`SSLSocket.context` attribute to a new object of type :class:"
"`SSLContext` representing a certificate chain that matches the server name."
msgstr ""
"Un uso típico de esta función callback es cambiar el atributo :attr:"
"`SSLSocket.context` de :class:`ssl.SSLSocket` por un nuevo objeto de tipo :"
"class:`SSLContext` que representa una cadena de certificados que coincide "
"con el nombre del servidor."

#: ../Doc/library/ssl.rst:1751
#, fuzzy
msgid ""
"Due to the early negotiation phase of the TLS connection, only limited "
"methods and attributes are usable like :meth:`SSLSocket."
"selected_alpn_protocol` and :attr:`SSLSocket.context`. The :meth:`SSLSocket."
"getpeercert`, :meth:`SSLSocket.cipher` and :meth:`SSLSocket.compression` "
"methods require that the TLS connection has progressed beyond the TLS Client "
"Hello and therefore will not return meaningful values nor can they be called "
"safely."
msgstr ""
"Debido a la fase temprana de negociación de la conexión TLS, sólo se pueden "
"utilizar métodos y atributos limitados como :meth:`SSLSocket."
"selected_alpn_protocol` y :attr:`SSLSocket.context`. Los métodos :meth:"
"`SSLSocket.getpeercert`, :meth:`SSLSocket. getpeercert`, :meth:`SSLSocket."
"cipher` y :meth:`SSLSocket.compress` requieren que la conexión TLS haya "
"progresado más allá del TLS Client Hello y, por tanto, no contendrán valores "
"de retorno significativos ni podrán ser llamados con seguridad."

#: ../Doc/library/ssl.rst:1759
msgid ""
"The *sni_callback* function must return ``None`` to allow the TLS "
"negotiation to continue.  If a TLS failure is required, a constant :const:"
"`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` can be returned.  "
"Other return values will result in a TLS fatal error with :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR`."
msgstr ""
"La función *sni_callback* debe devolver ``None`` para permitir que la "
"negociación TLS continúe. Si se requiere un fallo TLS, se puede devolver una "
"constante :const:`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>`. "
"Otros valores de retorno resultarán en un error fatal TLS con :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR`."

#: ../Doc/library/ssl.rst:1765
msgid ""
"If an exception is raised from the *sni_callback* function the TLS "
"connection will terminate with a fatal TLS alert message :const:"
"`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."
msgstr ""
"Si se lanza una excepción desde la función *sni_callback* la conexión TLS "
"terminará con un mensaje de alerta TLS fatal :const:"
"`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."

#: ../Doc/library/ssl.rst:1769
msgid ""
"This method will raise :exc:`NotImplementedError` if the OpenSSL library had "
"OPENSSL_NO_TLSEXT defined when it was built."
msgstr ""
"Este método lanzará :exc:`NotImplementedError` si la biblioteca OpenSSL "
"tenía definido OPENSSL_NO_TLSEXT cuando se construyó."

#: ../Doc/library/ssl.rst:1776
msgid ""
"This is a legacy API retained for backwards compatibility. When possible, "
"you should use :attr:`sni_callback` instead. The given "
"*server_name_callback* is similar to *sni_callback*, except that when the "
"server hostname is an IDN-encoded internationalized domain name, the "
"*server_name_callback* receives a decoded U-label (``\"pythön.org\"``)."
msgstr ""
"Se trata de una API heredada que se mantiene por compatibilidad con "
"versiones anteriores. Cuando sea posible, debería utilizar :attr:"
"`sni_callback` en su lugar. El *server_name_callback* dado es similar a "
"*sni_callback*, excepto que cuando el nombre del servidor es un nombre de "
"dominio internacionalizado codificado con IDN, el *server_name_callback* "
"recibe una etiqueta U decodificada (``\"pythön.org\"``)."

#: ../Doc/library/ssl.rst:1782
msgid ""
"If there is an decoding error on the server name, the TLS connection will "
"terminate with an :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` fatal TLS alert "
"message to the client."
msgstr ""
"Si hay un error de decodificación en el nombre del servidor, la conexión TLS "
"terminará con un mensaje fatal de alerta TLS :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR` al cliente."

#: ../Doc/library/ssl.rst:1790
msgid ""
"Load the key generation parameters for Diffie-Hellman (DH) key exchange. "
"Using DH key exchange improves forward secrecy at the expense of "
"computational resources (both on the server and on the client). The *dhfile* "
"parameter should be the path to a file containing DH parameters in PEM "
"format."
msgstr ""
"Carga los parámetros de generación de claves para el intercambio de claves "
"Diffie-Hellman (DH). El uso del intercambio de claves DH mejora el secreto "
"hacia adelante a expensas de recursos computacionales (tanto en el servidor "
"como en el cliente). El parámetro *dhfile* debe ser la ruta de un archivo "
"que contenga los parámetros DH en formato PEM."

#: ../Doc/library/ssl.rst:1796
msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_DH_USE` option to further improve security."
msgstr ""
"Esta configuración no se aplica a los sockets de los clientes. También puede "
"utilizar la opción :data:`OP_SINGLE_DH_USE` para mejorar aún más la "
"seguridad."

#: ../Doc/library/ssl.rst:1803
msgid ""
"Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key "
"exchange.  ECDH is significantly faster than regular DH while arguably as "
"secure.  The *curve_name* parameter should be a string describing a well-"
"known elliptic curve, for example ``prime256v1`` for a widely supported "
"curve."
msgstr ""
"Establece el nombre de la curva para el intercambio de claves Diffie-Hellman "
"basado en la curva elíptica (ECDH). ECDH es significativamente más rápido "
"que el DH normal, aunque podría decirse que es igual de seguro. El parámetro "
"*curve_name* debe ser una cadena que describa una curva elíptica conocida, "
"por ejemplo ``prime256v1`` para una curva ampliamente soportada."

#: ../Doc/library/ssl.rst:1809
msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_ECDH_USE` option to further improve security."
msgstr ""
"Esta configuración no se aplica a los sockets de los clientes. También puede "
"utilizar la opción :data:`OP_SINGLE_ECDH_USE` para mejorar aún más la "
"seguridad."

#: ../Doc/library/ssl.rst:1812
msgid "This method is not available if :data:`HAS_ECDH` is ``False``."
msgstr "Este método no está disponible si :data:`HAS_ECDH` es ``False``."

#: ../Doc/library/ssl.rst:1817
msgid ""
"`SSL/TLS & Perfect Forward Secrecy <https://vincent.bernat.im/en/blog/2011-"
"ssl-perfect-forward-secrecy>`_"
msgstr ""
"`SSL/TLS & Perfect Forward Secrecy <https://vincent.bernat.im/en/blog/2011-"
"ssl-perfect-forward-secrecy>`_"

#: ../Doc/library/ssl.rst:1818
msgid "Vincent Bernat."
msgstr "Vincent Bernat."

#: ../Doc/library/ssl.rst:1824
msgid ""
"Wrap an existing Python socket *sock* and return an instance of :attr:"
"`SSLContext.sslsocket_class` (default :class:`SSLSocket`). The returned SSL "
"socket is tied to the context, its settings and certificates. *sock* must be "
"a :data:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""
"Envuelve un socket Python existente *sock* y devuelve una instancia de :attr:"
"`SSLContext.sslsocket_class` (por defecto :class:`SSLSocket`). El socket SSL "
"devuelto está ligado al contexto, su configuración y certificados. *sock* "
"debe ser un socket :data:`~socket.SOCK_STREAM`; otros tipos de socket no son "
"soportados."

#: ../Doc/library/ssl.rst:1830
msgid ""
"The parameter ``server_side`` is a boolean which identifies whether server-"
"side or client-side behavior is desired from this socket."
msgstr ""
"El parámetro ``server_side`` es un booleano que identifica si se desea un "
"comportamiento del lado del servidor o del lado del cliente en este socket."

#: ../Doc/library/ssl.rst:1833
msgid ""
"For client-side sockets, the context construction is lazy; if the underlying "
"socket isn't connected yet, the context construction will be performed "
"after :meth:`connect` is called on the socket.  For server-side sockets, if "
"the socket has no remote peer, it is assumed to be a listening socket, and "
"the server-side SSL wrapping is automatically performed on client "
"connections accepted via the :meth:`accept` method. The method may raise :"
"exc:`SSLError`."
msgstr ""
"Para los sockets del lado del cliente, la construcción del contexto es "
"perezosa; si el socket subyacente no está conectado todavía, la construcción "
"del contexto se realizará después de llamar a :meth:`connect` en el socket. "
"Para los sockets del lado del servidor, si el socket no tiene un par remoto, "
"se asume que es un socket a la escucha, y la envoltura SSL del lado del "
"servidor se realiza automáticamente en las conexiones del cliente aceptadas "
"a través del método :meth:`accept`. El método puede lanzar :exc:`SSLError`."

#: ../Doc/library/ssl.rst:1841
msgid ""
"On client connections, the optional parameter *server_hostname* specifies "
"the hostname of the service which we are connecting to.  This allows a "
"single server to host multiple SSL-based services with distinct "
"certificates, quite similarly to HTTP virtual hosts. Specifying "
"*server_hostname* will raise a :exc:`ValueError` if *server_side* is true."
msgstr ""
"En las conexiones de cliente, el parámetro opcional *server_hostname* "
"especifica el nombre del servicio al que nos estamos conectando. Esto "
"permite que un único servidor aloje varios servicios basados en SSL con "
"certificados distintos, de forma similar a los hosts virtuales HTTP. Al "
"especificar *server_hostname* se producirá un :exc:`ValueError` si "
"*server_side* es verdadero."

#: ../Doc/library/ssl.rst:1847
msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL "
"handshake automatically after doing a :meth:`socket.connect`, or whether the "
"application program will call it explicitly, by invoking the :meth:"
"`SSLSocket.do_handshake` method.  Calling :meth:`SSLSocket.do_handshake` "
"explicitly gives the program control over the blocking behavior of the "
"socket I/O involved in the handshake."
msgstr ""
"El parámetro ``do_handshake_on_connect`` especifica si se hace el handshake "
"SSL automáticamente después de hacer un :meth:`socket.connect`, o si el "
"programa de aplicación lo llamará explícitamente, invocando el método :meth:"
"`SSLSocket.do_handshake`. Llamar explícitamente a :meth:`SSLSocket."
"do_handshake` da al programa el control sobre el comportamiento de bloqueo "
"de la E/S del socket involucrada en el handshake."

#: ../Doc/library/ssl.rst:1854
msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the :meth:`SSLSocket."
"recv` method should signal unexpected EOF from the other end of the "
"connection.  If specified as :const:`True` (the default), it returns a "
"normal EOF (an empty bytes object) in response to unexpected EOF errors "
"raised from the underlying socket; if :const:`False`, it will raise the "
"exceptions back to the caller."
msgstr ""
"El parámetro ``suppress_ragged_eofs`` especifica cómo el método :meth:"
"`SSLSocket.recv` debe señalar los EOF inesperados desde el otro extremo de "
"la conexión. Si se especifica como :const:`True` (el valor por defecto), "
"devuelve un EOF normal (un objeto bytes vacío) en respuesta a los errores "
"EOF inesperados que se produzcan desde el socket subyacente; si :const:"
"`False`, lanzará las excepciones al llamador."

#: ../Doc/library/ssl.rst:1861
msgid "*session*, see :attr:`~SSLSocket.session`."
msgstr "*session*, véase :attr:`~SSLSocket.session`."

#: ../Doc/library/ssl.rst:1863
msgid ""
"Always allow a server_hostname to be passed, even if OpenSSL does not have "
"SNI."
msgstr ""
"Siempre permite pasar un server_hostname, incluso si OpenSSL no tiene SNI."

#: ../Doc/library/ssl.rst:1867 ../Doc/library/ssl.rst:1893
msgid "*session* argument was added."
msgstr "Se agregó el argumento *session*."

#: ../Doc/library/ssl.rst:1870
#, fuzzy
msgid ""
"The method returns an instance of :attr:`SSLContext.sslsocket_class` instead "
"of hard-coded :class:`SSLSocket`."
msgstr ""
"El método retorna una instancia de :attr:`SSLContext.sslsocket_class` en "
"lugar de un :class:`SSLSocket` rígidamente programado."

#: ../Doc/library/ssl.rst:1876
msgid ""
"The return type of :meth:`SSLContext.wrap_socket`, defaults to :class:"
"`SSLSocket`. The attribute can be overridden on instance of class in order "
"to return a custom subclass of :class:`SSLSocket`."
msgstr ""
"El tipo de retorno de :meth:`SSLContext.wrap_socket`, por defecto es :class:"
"`SSLSocket`. El atributo puede anularse en la instancia de la clase para "
"devolver una subclase personalizada de :class:`SSLSocket`."

#: ../Doc/library/ssl.rst:1885
msgid ""
"Wrap the BIO objects *incoming* and *outgoing* and return an instance of :"
"attr:`SSLContext.sslobject_class` (default :class:`SSLObject`). The SSL "
"routines will read input data from the incoming BIO and write data to the "
"outgoing BIO."
msgstr ""
"Envuelve los objetos BIO *incoming* y *outgoing* y devuelve una instancia "
"de :attr:`SSLContext.sslobject_class` (por defecto :class:`SSLObject`). Las "
"rutinas SSL leerán los datos de entrada de la BIO entrante y escribirán los "
"datos en la BIO saliente."

#: ../Doc/library/ssl.rst:1890
msgid ""
"The *server_side*, *server_hostname* and *session* parameters have the same "
"meaning as in :meth:`SSLContext.wrap_socket`."
msgstr ""
"Los parámetros *server_side*, *server_hostname* y *session* tienen el mismo "
"significado que en :meth:`SSLContext.wrap_socket`."

#: ../Doc/library/ssl.rst:1896
#, fuzzy
msgid ""
"The method returns an instance of :attr:`SSLContext.sslobject_class` instead "
"of hard-coded :class:`SSLObject`."
msgstr ""
"El método retorna una instancia de :attr:`SSLContext.sslobject_class` en "
"lugar de un :class:`SSLObject` rígidamente programado."

#: ../Doc/library/ssl.rst:1902
msgid ""
"The return type of :meth:`SSLContext.wrap_bio`, defaults to :class:"
"`SSLObject`. The attribute can be overridden on instance of class in order "
"to return a custom subclass of :class:`SSLObject`."
msgstr ""
"El tipo de retorno de :meth:`SSLContext.wrap_bio`, por defecto es :class:"
"`SSLObject`. El atributo puede anularse en la instancia de la clase para "
"devolver una subclase personalizada de :class:`SSLObject`."

#: ../Doc/library/ssl.rst:1910
#, fuzzy
msgid ""
"Get statistics about the SSL sessions created or managed by this context. A "
"dictionary is returned which maps the names of each `piece of information "
"<https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_sess_number.html>`_ to "
"their numeric values.  For example, here is the total number of hits and "
"misses in the session cache since the context was created::"
msgstr ""
"Obtiene estadísticas sobre las sesiones SSL creadas o gestionadas por este "
"contexto. Se devuelve un diccionario que asigna los nombres de cada `pieza "
"de información <https://www.openssl.org/docs/man1.1.0/ssl/"
"SSL_CTX_sess_number.html>`_ a sus valores numéricos. Por ejemplo, aquí está "
"el número total de aciertos y errores en la caché de sesión desde que se "
"creó el contexto::"

#: ../Doc/library/ssl.rst:1921
msgid ""
"Whether to match the peer cert's hostname in :meth:`SSLSocket.do_handshake`. "
"The context's :attr:`~SSLContext.verify_mode` must be set to :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, and you must pass "
"*server_hostname* to :meth:`~SSLContext.wrap_socket` in order to match the "
"hostname.  Enabling hostname checking automatically sets :attr:`~SSLContext."
"verify_mode` from :data:`CERT_NONE` to :data:`CERT_REQUIRED`.  It cannot be "
"set back to :data:`CERT_NONE` as long as hostname checking is enabled. The :"
"data:`PROTOCOL_TLS_CLIENT` protocol enables hostname checking by default. "
"With other protocols, hostname checking must be enabled explicitly."
msgstr ""
"Si debe coincidir con el nombre de host del certificado de pares en :meth:"
"`SSLSocket.do_handshake`. El :attr:`~SSLContext.verify_mode` del contexto "
"debe establecerse en :data:`CERT_OPTIONAL` o :data:`CERT_REQUIRED`, y debe "
"pasar *server_hostname* a :meth:`~SSLContext.wrap_socket` para que coincida "
"con el nombre de host. La activación de la comprobación del nombre de host "
"configura automáticamente :attr:`~SSLContext.verify_mode` de :data:"
"`CERT_NONE` a :data:`CERT_REQUIRED`. No se puede volver a establecer en :"
"data:`CERT_NONE` siempre que la comprobación del nombre de host esté "
"habilitada. El protocolo :data:`PROTOCOL_TLS_CLIENT` habilita la "
"verificación del nombre de host de forma predeterminada. Con otros "
"protocolos, la verificación del nombre de host debe habilitarse "
"explícitamente."

#: ../Doc/library/ssl.rst:1949
msgid ""
":attr:`~SSLContext.verify_mode` is now automatically changed to :data:"
"`CERT_REQUIRED`  when hostname checking is enabled and :attr:`~SSLContext."
"verify_mode` is :data:`CERT_NONE`. Previously the same operation would have "
"failed with a :exc:`ValueError`."
msgstr ""
":attr:`~SSLContext.verify_mode` ahora se cambia automáticamente a :data:"
"`CERT_REQUIRED` cuando la comprobación del hostname está activada y :attr:"
"`~SSLContext.verify_mode` es :data:`CERT_NONE`. Anteriormente la misma "
"operación habría fallado con un :exc:`ValueError`."

#: ../Doc/library/ssl.rst:1956
msgid ""
"Write TLS keys to a keylog file, whenever key material is generated or "
"received. The keylog file is designed for debugging purposes only. The file "
"format is specified by NSS and used by many traffic analyzers such as "
"Wireshark. The log file is opened in append-only mode. Writes are "
"synchronized between threads, but not between processes."
msgstr ""
"Escribe las claves TLS en un archivo keylog, siempre que se genere o reciba "
"material de claves. El archivo keylog está diseñado únicamente para fines de "
"depuración. El formato del archivo está especificado por NSS y es utilizado "
"por muchos analizadores de tráfico como Wireshark. El archivo de registro se "
"abre en modo sólo añadir. Las escrituras se sincronizan entre hilos, pero no "
"entre procesos."

#: ../Doc/library/ssl.rst:1966
msgid ""
"A :class:`TLSVersion` enum member representing the highest supported TLS "
"version. The value defaults to :attr:`TLSVersion.MAXIMUM_SUPPORTED`. The "
"attribute is read-only for protocols other than :attr:`PROTOCOL_TLS`, :attr:"
"`PROTOCOL_TLS_CLIENT`, and :attr:`PROTOCOL_TLS_SERVER`."
msgstr ""
"Un miembro enumeración de :class:`TLSVersion` que representa la versión más "
"alta de TLS soportada. El valor por defecto es :attr:`TLSVersion."
"MAXIMUM_SUPPORTED`. El atributo es de sólo lectura para protocolos distintos "
"de :attr:`PROTOCOL_TLS`, :attr:`PROTOCOL_TLS_CLIENT` y :attr:"
"`PROTOCOL_TLS_SERVER`."

#: ../Doc/library/ssl.rst:1971
msgid ""
"The attributes :attr:`~SSLContext.maximum_version`, :attr:`~SSLContext."
"minimum_version` and :attr:`SSLContext.options` all affect the supported SSL "
"and TLS versions of the context. The implementation does not prevent invalid "
"combination. For example a context with :attr:`OP_NO_TLSv1_2` in :attr:"
"`~SSLContext.options` and :attr:`~SSLContext.maximum_version` set to :attr:"
"`TLSVersion.TLSv1_2` will not be able to establish a TLS 1.2 connection."
msgstr ""
"Los atributos :attr:`~SSLContext.maximum_version`, :attr:`~SSLContext."
"minimum_version` y :attr:`SSLContext.options` afectan a las versiones SSL y "
"TLS soportadas del contexto. La implementación no evita la combinación "
"inválida. Por ejemplo, un contexto con :attr:`OP_NO_TLSv1_2` en :attr:"
"`~SSLContext.options` y :attr:`~SSLContext.maximum_version` establecido en :"
"attr:`TLSVersion.TLSv1_2` no podrá establecer una conexión TLS 1.2."

#: ../Doc/library/ssl.rst:1984
msgid ""
"Like :attr:`SSLContext.maximum_version` except it is the lowest supported "
"version or :attr:`TLSVersion.MINIMUM_SUPPORTED`."
msgstr ""
"Igual que :attr:`SSLContext.maximum_version` excepto que es la versión más "
"baja soportada o :attr:`TLSVersion.MINIMUM_SUPPORTED`."

#: ../Doc/library/ssl.rst:1991
msgid ""
"Control the number of TLS 1.3 session tickets of a :attr:"
"`PROTOCOL_TLS_SERVER` context. The setting has no impact on TLS 1.0 to 1.2 "
"connections."
msgstr ""
"Controla el número de tickets de sesión TLS 1.3 de un contexto :attr:"
"`TLS_PROTOCOL_SERVER`. El ajuste no tiene impacto en las conexiones TLS 1.0 "
"a 1.2."

#: ../Doc/library/ssl.rst:1999
msgid ""
"An integer representing the set of SSL options enabled on this context. The "
"default value is :data:`OP_ALL`, but you can specify other options such as :"
"data:`OP_NO_SSLv2` by ORing them together."
msgstr ""
"Un número entero que representa el conjunto de opciones SSL habilitadas en "
"este contexto. El valor por defecto es :data:`OP_ALL`, pero se pueden "
"especificar otras opciones como :data:`OP_NO_SSLv2` mediante la combinación "
"OR."

#: ../Doc/library/ssl.rst:2003
msgid ":attr:`SSLContext.options` returns :class:`Options` flags:"
msgstr ":attr:`SSLContext.options` retorna opciones :class:`Options`:"

#: ../Doc/library/ssl.rst:2011
msgid ""
"All ``OP_NO_SSL*`` and ``OP_NO_TLS*`` options have been deprecated since "
"Python 3.7. Use :attr:`SSLContext.minimum_version` and :attr:`SSLContext."
"maximum_version` instead."
msgstr ""
"Esta opción es obsoleta desde OpenSSL 1.1.0, utilice en su lugar los nuevos :"
"attr:`SSLContext.minimum_version` y :attr:`SSLContext.maximum_version`."

#: ../Doc/library/ssl.rst:2017
msgid ""
"Enable TLS 1.3 post-handshake client authentication. Post-handshake auth is "
"disabled by default and a server can only request a TLS client certificate "
"during the initial handshake. When enabled, a server may request a TLS "
"client certificate at any time after the handshake."
msgstr ""
"Habilita la autenticación del cliente TLS 1.3 post-handshake. La "
"autenticación post-handshake está deshabilitada por defecto y un servidor "
"sólo puede solicitar un certificado de cliente TLS durante el handshake "
"inicial. Cuando se habilita, un servidor puede solicitar un certificado de "
"cliente TLS en cualquier momento después del handshake."

#: ../Doc/library/ssl.rst:2022
msgid ""
"When enabled on client-side sockets, the client signals the server that it "
"supports post-handshake authentication."
msgstr ""
"Cuando se activa en los sockets del lado del cliente, el cliente indica al "
"servidor que soporta la autenticación post-handshake."

#: ../Doc/library/ssl.rst:2025
msgid ""
"When enabled on server-side sockets, :attr:`SSLContext.verify_mode` must be "
"set to :data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, too. The actual "
"client cert exchange is delayed until :meth:`SSLSocket."
"verify_client_post_handshake` is called and some I/O is performed."
msgstr ""
"Cuando se activa en los sockets del lado del servidor, :attr:`SSLContext."
"verify_mode` debe establecerse también como :data:`CERT_OPTIONAL` o :data:"
"`CERT_REQUIRED`. El intercambio real de certificados del cliente se retrasa "
"hasta que se llama a :meth:`SSLSocket.verify_client_post_handshake` y se "
"realiza alguna E/S."

#: ../Doc/library/ssl.rst:2035
msgid ""
"The protocol version chosen when constructing the context.  This attribute "
"is read-only."
msgstr ""
"La versión del protocolo elegida cuando se construyó el contexto. Este "
"atributo es de sólo lectura."

#: ../Doc/library/ssl.rst:2040
msgid ""
"Whether :attr:`~SSLContext.check_hostname` falls back to verify the cert's "
"subject common name in the absence of a subject alternative name extension "
"(default: true)."
msgstr ""
"Si :attr:`~SSLContext.check_hostname` vuelve a verificar el nombre común del "
"sujeto del certificado en ausencia de una extensión de nombre alternativo "
"del sujeto (por defecto: true)."

#: ../Doc/library/ssl.rst:2048
msgid ""
"The flag had no effect with OpenSSL before version 1.1.1k. Python 3.8.9, "
"3.9.3, and 3.10 include workarounds for previous versions."
msgstr ""
"La bandera no tuvo ningún efecto con OpenSSL antes de la versión 1.1.1k. "
"Python 3.8.9, 3.9.3 y 3.10 incluyen soluciones para versiones anteriores."

#: ../Doc/library/ssl.rst:2053
msgid ""
"An integer representing the `security level <https://www.openssl.org/docs/"
"manmaster/man3/SSL_CTX_get_security_level.html>`_ for the context. This "
"attribute is read-only."
msgstr ""
"Un número entero que representa el `security level <https://www.openssl.org/"
"docs/manmaster/man3/SSL_CTX_get_security_level.html>`_ para el contexto. "
"Este atributo es de solo lectura."

#: ../Doc/library/ssl.rst:2061
msgid ""
"The flags for certificate verification operations. You can set flags like :"
"data:`VERIFY_CRL_CHECK_LEAF` by ORing them together. By default OpenSSL does "
"neither require nor verify certificate revocation lists (CRLs)."
msgstr ""
"Los indicadores para las operaciones de verificación de certificados. Se "
"pueden establecer indicadores como :data:`VERIFY_CRL_CHECK_LEAF` mediante la "
"combinación OR. Por defecto, OpenSSL no requiere ni verifica las listas de "
"revocación de certificados (CRL). Disponible sólo con la versión 0.9.8+ de "
"openssl."

#: ../Doc/library/ssl.rst:2067
msgid ":attr:`SSLContext.verify_flags` returns :class:`VerifyFlags` flags:"
msgstr ":attr:`SSLContext.verify_flags` retorna opciones :class:`VerifyFlags`:"

#: ../Doc/library/ssl.rst:2075
msgid ""
"Whether to try to verify other peers' certificates and how to behave if "
"verification fails.  This attribute must be one of :data:`CERT_NONE`, :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`."
msgstr ""
"Si se intenta verificar los certificados de otros pares y cómo comportarse "
"si la verificación falla. Este atributo debe ser uno de los siguientes: :"
"data:`CERT_NONE`, :data:`CERT_OPTIONAL` o :data:`CERT_REQUIRED`."

#: ../Doc/library/ssl.rst:2079
msgid ":attr:`SSLContext.verify_mode` returns :class:`VerifyMode` enum:"
msgstr ":attr:`SSLContext.verify_mode` retorna :class:`VerifyMode` enum:"

#: ../Doc/library/ssl.rst:2092
msgid "Certificates"
msgstr "Certificados"

#: ../Doc/library/ssl.rst:2094
msgid ""
"Certificates in general are part of a public-key / private-key system.  In "
"this system, each *principal*, (which may be a machine, or a person, or an "
"organization) is assigned a unique two-part encryption key.  One part of the "
"key is public, and is called the *public key*; the other part is kept "
"secret, and is called the *private key*.  The two parts are related, in that "
"if you encrypt a message with one of the parts, you can decrypt it with the "
"other part, and **only** with the other part."
msgstr ""
"En general, los certificados forman parte de un sistema de clave pública/"
"clave privada. En este sistema, a cada *principal* (que puede ser una "
"máquina, una persona o una organización) se le asigna una clave de cifrado "
"única de dos partes. Una parte de la clave es pública y se llama *clave "
"pública*; la otra parte se mantiene en secreto y se llama *clave privada*. "
"Las dos partes están relacionadas, en el sentido de que si se cifra un "
"mensaje con una de las partes, se puede descifrar con la otra parte, y "
"**sólo** con la otra parte."

#: ../Doc/library/ssl.rst:2102
msgid ""
"A certificate contains information about two principals.  It contains the "
"name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who they "
"claim to be, and that this is indeed the subject's public key.  The issuer's "
"statement is signed with the issuer's private key, which only the issuer "
"knows.  However, anyone can verify the issuer's statement by finding the "
"issuer's public key, decrypting the statement with it, and comparing it to "
"the other information in the certificate. The certificate also contains "
"information about the time period over which it is valid.  This is expressed "
"as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""
"Un certificado contiene información sobre dos sujetos. Contiene el nombre de "
"un *sujeto*, y la clave pública del sujeto. También contiene una declaración "
"de un segundo titular, el *emisor*, de que el sujeto es quien dice ser, y de "
"que ésta es efectivamente la clave pública del sujeto. La declaración del "
"emisor está firmada con su clave privada, que sólo el emisor conoce. Sin "
"embargo, cualquiera puede verificar la declaración del emisor encontrando la "
"clave pública del emisor, descifrando la declaración con ella y comparándola "
"con el resto de la información del certificado. El certificado también "
"contiene información sobre el periodo de tiempo en el que es válido. Esto se "
"expresa en dos campos, llamados *notBefore* y *notAfter*."

#: ../Doc/library/ssl.rst:2112
msgid ""
"In the Python use of certificates, a client or server can use a certificate "
"to prove who they are.  The other side of a network connection can also be "
"required to produce a certificate, and that certificate can be validated to "
"the satisfaction of the client or server that requires such validation.  The "
"connection attempt can be set to raise an exception if the validation fails. "
"Validation is done automatically, by the underlying OpenSSL framework; the "
"application need not concern itself with its mechanics.  But the application "
"does usually need to provide sets of certificates to allow this process to "
"take place."
msgstr ""
"En el uso de certificados en Python, un cliente o servidor puede utilizar un "
"certificado para demostrar quién es. El otro lado de una conexión de red "
"también puede ser requerido para producir un certificado, y ese certificado "
"puede ser validado a la satisfacción del cliente o servidor que requiere "
"dicha validación. El intento de conexión puede configurarse para que lance "
"una excepción si la validación falla. La validación se realiza "
"automáticamente, por el subyacente framework OpenSSL; la aplicación no "
"necesita preocuparse de su mecánica. Sin embargo, la aplicación normalmente "
"necesita proporcionar conjuntos de certificados para permitir que este "
"proceso tenga lugar."

#: ../Doc/library/ssl.rst:2122
msgid ""
"Python uses files to contain certificates.  They should be formatted as "
"\"PEM\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a "
"header line and a footer line::"
msgstr ""
"Python utiliza archivos para contener certificados. Deben ser formateados "
"como \"PEM\" (ver :rfc:`1422`), que es una forma codificada en base-64 "
"envuelta con una línea de cabecera y una línea de pie de página::"

#: ../Doc/library/ssl.rst:2131
msgid "Certificate chains"
msgstr "Cadenas de certificados"

#: ../Doc/library/ssl.rst:2133
msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the client "
"or server, and then the certificate for the issuer of that certificate, and "
"then the certificate for the issuer of *that* certificate, and so on up the "
"chain till you get to a certificate which is *self-signed*, that is, a "
"certificate which has the same subject and issuer, sometimes called a *root "
"certificate*.  The certificates should just be concatenated together in the "
"certificate file.  For example, suppose we had a three certificate chain, "
"from our server certificate to the certificate of the certification "
"authority that signed our server certificate, to the root certificate of the "
"agency which issued the certification authority's certificate::"
msgstr ""
"Los archivos de Python que contienen certificados pueden contener una "
"secuencia de certificados, a veces llamada *cadena de certificados*. Esta "
"cadena debería empezar con el certificado específico para el principal que "
"\"es\" el cliente o servidor, y luego el certificado para el emisor de ese "
"certificado, y luego el certificado para el emisor de *ese* certificado, y "
"así sucesivamente hasta llegar a un certificado que es *auto-firmado*, es "
"decir, un certificado que tiene el mismo sujeto y emisor, a veces llamado "
"*certificado raíz*. Los certificados sólo deben concatenarse en el archivo "
"de certificados. Por ejemplo, supongamos que tenemos una cadena de tres "
"certificados, desde el certificado de nuestro servidor al certificado de la "
"autoridad de certificación que firmó nuestro certificado del servidor, hasta "
"el certificado raíz de la agencia que emitió el certificado de la autoridad "
"de certificación::"

#: ../Doc/library/ssl.rst:2157
msgid "CA certificates"
msgstr "Certificados CA"

#: ../Doc/library/ssl.rst:2159
msgid ""
"If you are going to require validation of the other side of the connection's "
"certificate, you need to provide a \"CA certs\" file, filled with the "
"certificate chains for each issuer you are willing to trust.  Again, this "
"file just contains these chains concatenated together.  For validation, "
"Python will use the first chain it finds in the file which matches.  The "
"platform's certificates file can be used by calling :meth:`SSLContext."
"load_default_certs`, this is done automatically with :func:`."
"create_default_context`."
msgstr ""
"Si se requiere la validación del certificado del otro lado de la conexión, "
"se necesita proporcionar un archivo \"CA certs\", con las cadenas de "
"certificados para cada emisor en el que se está dispuesto a confiar. De "
"nuevo, este archivo sólo contiene estas cadenas concatenadas. Para la "
"validación, Python utilizará la primera cadena que encuentre en el archivo "
"que coincida. El archivo de certificados de la plataforma se puede utilizar "
"llamando a :meth:`SSLContext.load_default_certs`, esto se hace "
"automáticamente con :func:`.create_default_context`."

#: ../Doc/library/ssl.rst:2168
msgid "Combined key and certificate"
msgstr "Clave y certificado combinados"

#: ../Doc/library/ssl.rst:2170
msgid ""
"Often the private key is stored in the same file as the certificate; in this "
"case, only the ``certfile`` parameter to :meth:`SSLContext.load_cert_chain` "
"and :func:`wrap_socket` needs to be passed.  If the private key is stored "
"with the certificate, it should come before the first certificate in the "
"certificate chain::"
msgstr ""
"A menudo la clave privada se almacena en el mismo archivo que el "
"certificado; en este caso, sólo es necesario pasar el parámetro ``certfile`` "
"a :meth:`SSLContext.load_cert_chain` y :func:`wrap_socket`. Si la clave "
"privada se almacena con el certificado, debe ir antes del primer certificado "
"de la cadena de certificados::"

#: ../Doc/library/ssl.rst:2184
msgid "Self-signed certificates"
msgstr "Certificados auto-firmados"

#: ../Doc/library/ssl.rst:2186
msgid ""
"If you are going to create a server that provides SSL-encrypted connection "
"services, you will need to acquire a certificate for that service.  There "
"are many ways of acquiring appropriate certificates, such as buying one from "
"a certification authority.  Another common practice is to generate a self-"
"signed certificate.  The simplest way to do this is with the OpenSSL "
"package, using something like the following::"
msgstr ""
"Si va a crear un servidor que proporcione servicios de conexión encriptada "
"SSL, necesitará adquirir un certificado para ese servicio. Hay muchas formas "
"de adquirir los certificados adecuados, como comprar uno a una autoridad de "
"certificación. Otra práctica común es generar un certificado auto-firmado. "
"La forma más sencilla de hacerlo es con el paquete OpenSSL, utilizando algo "
"como lo siguiente:"

#: ../Doc/library/ssl.rst:2215
msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr ""
"La desventaja de un certificado auto-firmado es que es su propio certificado "
"raíz, y nadie más lo tendrá en su caché de certificados raíz conocidos (y de "
"confianza)."

#: ../Doc/library/ssl.rst:2221
msgid "Examples"
msgstr "Ejemplos"

#: ../Doc/library/ssl.rst:2224
msgid "Testing for SSL support"
msgstr "Pruebas de compatibilidad con SSL"

#: ../Doc/library/ssl.rst:2226
msgid ""
"To test for the presence of SSL support in a Python installation, user code "
"should use the following idiom::"
msgstr ""
"Para comprobar la presencia de soporte SSL en una instalación de Python, el "
"código del usuario debe utilizar el siguiente modismo::"

#: ../Doc/library/ssl.rst:2237
msgid "Client-side operation"
msgstr "Operación del lado del cliente"

#: ../Doc/library/ssl.rst:2239
msgid ""
"This example creates a SSL context with the recommended security settings "
"for client sockets, including automatic certificate verification::"
msgstr ""
"Este ejemplo crea un contexto SSL con la configuración de seguridad "
"recomendada para los sockets del cliente, incluyendo la verificación "
"automática de certificados::"

#: ../Doc/library/ssl.rst:2244
msgid ""
"If you prefer to tune security settings yourself, you might create a context "
"from scratch (but beware that you might not get the settings right)::"
msgstr ""
"Si prefieres ajustar la configuración de seguridad tú mismo, puedes crear un "
"contexto desde cero (pero ten en cuenta que podrías no acertar con la "
"configuración)::"

#: ../Doc/library/ssl.rst:2251
msgid ""
"(this snippet assumes your operating system places a bundle of all CA "
"certificates in ``/etc/ssl/certs/ca-bundle.crt``; if not, you'll get an "
"error and have to adjust the location)"
msgstr ""
"(este fragmento asume que tu sistema operativo coloca un paquete de todos "
"los certificados CA en ``/etc/ssl/certs/ca-bundle.crt``; si no es así, "
"obtendrá un error y tendrá que ajustar la ubicación)"

#: ../Doc/library/ssl.rst:2255
msgid ""
"The :data:`PROTOCOL_TLS_CLIENT` protocol configures the context for cert "
"validation and hostname verification. :attr:`~SSLContext.verify_mode` is set "
"to :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` is set to "
"``True``. All other protocols create SSL contexts with insecure defaults."
msgstr ""
"El protocolo :data:`PROTOCOL_TLS_CLIENT` configura el contexto para la "
"validación de certificados y la verificación del hostname. :attr:"
"`~SSLContext.verify_mode` se establece en :data:`CERT_REQUIRED` y :attr:"
"`~SSLContext.check_hostname` se establece en ``True``. Todos los demás "
"protocolos crean contextos SSL con valores predeterminados inseguros."

#: ../Doc/library/ssl.rst:2260
msgid ""
"When you use the context to connect to a server, :const:`CERT_REQUIRED` and :"
"attr:`~SSLContext.check_hostname` validate the server certificate: it "
"ensures that the server certificate was signed with one of the CA "
"certificates, checks the signature for correctness, and verifies other "
"properties like validity and identity of the hostname::"
msgstr ""
"Cuando se utiliza el contexto para conectarse a un servidor, :const:"
"`CERT_REQUIRED` y :attr:`~SSLContext.check_hostname` validan el certificado "
"del servidor: se asegura de que el certificado del servidor se ha firmado "
"con uno de los certificados de la CA, se comprueba que la firma es correcta "
"y se verifican otras propiedades como la validez y la identidad del "
"hostname::"

#: ../Doc/library/ssl.rst:2270
msgid "You may then fetch the certificate::"
msgstr "A continuación, puede obtener el certificado::"

#: ../Doc/library/ssl.rst:2274
msgid ""
"Visual inspection shows that the certificate does identify the desired "
"service (that is, the HTTPS host ``www.python.org``)::"
msgstr ""
"La inspección visual muestra que el certificado sí identifica el servicio "
"deseado (es decir, el host HTTPS ``www.python.org``)::"

#: ../Doc/library/ssl.rst:2317
msgid ""
"Now the SSL channel is established and the certificate verified, you can "
"proceed to talk with the server::"
msgstr ""
"Ahora que se ha establecido el canal SSL y se ha verificado el certificado, "
"se puede proceder a hablar con el servidor::"

#: ../Doc/library/ssl.rst:2344
msgid "Server-side operation"
msgstr "Operación del lado del servidor"

#: ../Doc/library/ssl.rst:2346
msgid ""
"For server operation, typically you'll need to have a server certificate, "
"and private key, each in a file.  You'll first create a context holding the "
"key and the certificate, so that clients can check your authenticity.  Then "
"you'll open a socket, bind it to a port, call :meth:`listen` on it, and "
"start waiting for clients to connect::"
msgstr ""
"Para el funcionamiento del servidor, normalmente necesitarás tener un "
"certificado de servidor y una clave privada, cada uno en un archivo. Primero "
"crearás un contexto que contenga la clave y el certificado, para que los "
"clientes puedan comprobar tu autenticidad. Entonces abrirás un socket, lo "
"enlazarás a un puerto, llamarás a :meth:`listen` en él, y empezarás a "
"esperar a que los clientes se conecten::"

#: ../Doc/library/ssl.rst:2361
msgid ""
"When a client connects, you'll call :meth:`accept` on the socket to get the "
"new socket from the other end, and use the context's :meth:`SSLContext."
"wrap_socket` method to create a server-side SSL socket for the connection::"
msgstr ""
"Cuando un cliente se conecta, llamarás a :meth:`accept` en el socket para "
"obtener el nuevo socket del otro extremo, y utilizarás el método :meth:"
"`SSLContext.wrap_socket` del contexto para crear un socket SSL del lado del "
"servidor para la conexión::"

#: ../Doc/library/ssl.rst:2374
msgid ""
"Then you'll read data from the ``connstream`` and do something with it till "
"you are finished with the client (or the client is finished with you)::"
msgstr ""
"Entonces leerás los datos del ``connstream`` y harás algo con ellos hasta "
"que hayas terminado con el cliente (o el cliente haya terminado contigo)::"

#: ../Doc/library/ssl.rst:2388
msgid ""
"And go back to listening for new client connections (of course, a real "
"server would probably handle each client connection in a separate thread, or "
"put the sockets in :ref:`non-blocking mode <ssl-nonblocking>` and use an "
"event loop)."
msgstr ""
"Y volver a escuchar nuevas conexiones de clientes (por supuesto, un servidor "
"real probablemente manejaría cada conexión de cliente en un hilo separado, o "
"pondría los sockets en modo :ref:`no-bloqueo <ssl-nonblocking>` y usaría un "
"bucle de eventos)."

#: ../Doc/library/ssl.rst:2396
msgid "Notes on non-blocking sockets"
msgstr "Notas sobre los sockets no bloqueantes"

#: ../Doc/library/ssl.rst:2398
msgid ""
"SSL sockets behave slightly different than regular sockets in non-blocking "
"mode. When working with non-blocking sockets, there are thus several things "
"you need to be aware of:"
msgstr ""
"Los sockets SSL se comportan de forma ligeramente diferente a los sockets "
"normales en modo no bloqueante. Cuando se trabaja con sockets no "
"bloqueantes, hay varias cosas que hay que tener en cuenta:"

#: ../Doc/library/ssl.rst:2402
msgid ""
"Most :class:`SSLSocket` methods will raise either :exc:`SSLWantWriteError` "
"or :exc:`SSLWantReadError` instead of :exc:`BlockingIOError` if an I/O "
"operation would block. :exc:`SSLWantReadError` will be raised if a read "
"operation on the underlying socket is necessary, and :exc:"
"`SSLWantWriteError` for a write operation on the underlying socket. Note "
"that attempts to *write* to an SSL socket may require *reading* from the "
"underlying socket first, and attempts to *read* from the SSL socket may "
"require a prior *write* to the underlying socket."
msgstr ""
"La mayoría de los métodos de :class:`SSLSocket` lanzarán :exc:"
"`SSLWantWriteError` o :exc:`SSLWantReadError` en lugar de :exc:"
"`BlockingIOError` si una operación de E/S se bloquea. :exc:"
"`SSLWantReadError` se lanzará si es necesaria una operación de lectura en el "
"socket subyacente, y :exc:`SSLWantWriteError` para una operación de "
"escritura en el socket subyacente. Tenga en cuenta que los intentos de "
"*escribir* en un socket SSL pueden requerir *leer* del socket subyacente "
"primero, y los intentos de *leer* del socket SSL pueden requerir una "
"*escritura* previa en el socket subyacente."

#: ../Doc/library/ssl.rst:2414
msgid ""
"In earlier Python versions, the :meth:`!SSLSocket.send` method returned zero "
"instead of raising :exc:`SSLWantWriteError` or :exc:`SSLWantReadError`."
msgstr ""
"En versiones anteriores de Python, el método :meth:`!SSLSocket.send` "
"devolvía cero en lugar de lanzar :exc:`SSLWantWriteError` o :exc:"
"`SSLWantReadError`."

#: ../Doc/library/ssl.rst:2418
msgid ""
"Calling :func:`~select.select` tells you that the OS-level socket can be "
"read from (or written to), but it does not imply that there is sufficient "
"data at the upper SSL layer.  For example, only part of an SSL frame might "
"have arrived.  Therefore, you must be ready to handle :meth:`SSLSocket.recv` "
"and :meth:`SSLSocket.send` failures, and retry after another call to :func:"
"`~select.select`."
msgstr ""
"Llamar a :func:`~select.select` le indica que se puede leer (o escribir) en "
"el socket a nivel del SO, pero no implica que haya suficientes datos en la "
"capa superior SSL. Por ejemplo, puede que sólo haya llegado una parte de una "
"trama SSL. Por lo tanto, debe estar preparado para manejar los fallos de :"
"meth:`SSLSocket.recv` y :meth:`SSLSocket.send`, y re-intentar después de "
"otra llamada a :func:`~select.select`."

#: ../Doc/library/ssl.rst:2425
msgid ""
"Conversely, since the SSL layer has its own framing, a SSL socket may still "
"have data available for reading without :func:`~select.select` being aware "
"of it.  Therefore, you should first call :meth:`SSLSocket.recv` to drain any "
"potentially available data, and then only block on a :func:`~select.select` "
"call if still necessary."
msgstr ""
"Por el contrario, dado que la capa SSL tiene su propia estructura, un socket "
"SSL puede tener datos disponibles para leer sin que :func:`~select.select` "
"lo sepa. Por lo tanto, debería llamar primero a :meth:`SSLSocket.recv` para "
"drenar cualquier dato potencialmente disponible, y luego sólo bloquear en "
"una llamada a :func:`~select.select` si todavía es necesario."

#: ../Doc/library/ssl.rst:2431
msgid ""
"(of course, similar provisions apply when using other primitives such as :"
"func:`~select.poll`, or those in the :mod:`selectors` module)"
msgstr ""
"(por supuesto, se aplican disposiciones similares cuando se utilizan otras "
"primitivas como :func:`~select.poll`, o las del módulo :mod:`selectors`)"

#: ../Doc/library/ssl.rst:2434
msgid ""
"The SSL handshake itself will be non-blocking: the :meth:`SSLSocket."
"do_handshake` method has to be retried until it returns successfully.  Here "
"is a synopsis using :func:`~select.select` to wait for the socket's "
"readiness::"
msgstr ""
"El handshake SSL en sí mismo será no bloqueante: el método :meth:`SSLSocket."
"do_handshake` tiene que ser re-intentado hasta que regrese con éxito. Aquí "
"hay una sinopsis usando :func:`~select.select` para esperar la "
"disponibilidad del socket::"

#: ../Doc/library/ssl.rst:2450
msgid ""
"The :mod:`asyncio` module supports :ref:`non-blocking SSL sockets <ssl-"
"nonblocking>` and provides a higher level API. It polls for events using "
"the :mod:`selectors` module and handles :exc:`SSLWantWriteError`, :exc:"
"`SSLWantReadError` and :exc:`BlockingIOError` exceptions. It runs the SSL "
"handshake asynchronously as well."
msgstr ""
"El módulo :mod:`asyncio` soporta :ref:`sockets SSL no bloqueantes <ssl-"
"nonblocking>` y proporciona una API de alto nivel. Busca eventos usando el "
"módulo :mod:`selectors` y maneja las excepciones :exc:`SSLWantWriteError`, :"
"exc:`SSLWantReadError` y :exc:`BlockingIOError`. También ejecuta el "
"handshake SSL de forma asíncrona."

#: ../Doc/library/ssl.rst:2459
msgid "Memory BIO Support"
msgstr "Soporte de memoria BIO"

#: ../Doc/library/ssl.rst:2463
msgid ""
"Ever since the SSL module was introduced in Python 2.6, the :class:"
"`SSLSocket` class has provided two related but distinct areas of "
"functionality:"
msgstr ""
"Desde que se introdujo el módulo SSL en Python 2.6, la clase :class:"
"`SSLSocket` ha proporcionado dos áreas de funcionalidad relacionadas pero "
"distintas:"

#: ../Doc/library/ssl.rst:2466
msgid "SSL protocol handling"
msgstr "Manejo del protocolo SSL"

#: ../Doc/library/ssl.rst:2467
msgid "Network IO"
msgstr "E/S de red"

#: ../Doc/library/ssl.rst:2469
msgid ""
"The network IO API is identical to that provided by :class:`socket.socket`, "
"from which :class:`SSLSocket` also inherits. This allows an SSL socket to be "
"used as a drop-in replacement for a regular socket, making it very easy to "
"add SSL support to an existing application."
msgstr ""
"La API de E/S de red es idéntica a la proporcionada por :class:`socket."
"socket`, de la que también hereda :class:`SSLSocket`. Esto permite que un "
"socket SSL sea utilizado como un reemplazo de un socket normal, haciendo que "
"sea muy fácil añadir soporte SSL a una aplicación existente."

#: ../Doc/library/ssl.rst:2474
msgid ""
"Combining SSL protocol handling and network IO usually works well, but there "
"are some cases where it doesn't. An example is async IO frameworks that want "
"to use a different IO multiplexing model than the \"select/poll on a file "
"descriptor\" (readiness based) model that is assumed by :class:`socket."
"socket` and by the internal OpenSSL socket IO routines. This is mostly "
"relevant for platforms like Windows where this model is not efficient. For "
"this purpose, a reduced scope variant of :class:`SSLSocket` called :class:"
"`SSLObject` is provided."
msgstr ""
"La combinación del manejo del protocolo SSL y la E/S de red suele funcionar "
"bien, pero hay algunos casos en los que no es así. Un ejemplo son los "
"frameworks de E/S asíncronos que quieren utilizar un modelo de "
"multiplexación de E/S diferente al modelo \"selección/consulta de un "
"descriptor de archivo\" (basado en la preparación) que es asumido por :class:"
"`socket.socket` y por las rutinas internas de E/S de socket de OpenSSL. Esto "
"es principalmente relevante para plataformas como Windows donde este modelo "
"no es eficiente. Para este propósito, se proporciona una variante de ámbito "
"reducido de :class:`SSLSocket` llamada :class:`SSLObject`."

#: ../Doc/library/ssl.rst:2485
msgid ""
"A reduced-scope variant of :class:`SSLSocket` representing an SSL protocol "
"instance that does not contain any network IO methods. This class is "
"typically used by framework authors that want to implement asynchronous IO "
"for SSL through memory buffers."
msgstr ""
"Una variante de alcance reducido de :class:`SSLSocket` que representa una "
"instancia del protocolo SSL que no contiene ningún método de E/S de red. "
"Esta clase suele ser utilizada por los autores de frameworks que quieren "
"implementar E/S asíncrona para SSL a través de búfers de memoria."

#: ../Doc/library/ssl.rst:2490
msgid ""
"This class implements an interface on top of a low-level SSL object as "
"implemented by OpenSSL. This object captures the state of an SSL connection "
"but does not provide any network IO itself. IO needs to be performed through "
"separate \"BIO\" objects which are OpenSSL's IO abstraction layer."
msgstr ""
"Esta clase implementa una interfaz sobre un objeto SSL de bajo nivel como el "
"implementado por OpenSSL. Este objeto captura el estado de una conexión SSL "
"pero no proporciona ninguna E/S de red en sí misma. La E/S debe realizarse a "
"través de objetos \"BIO\" separados que son la capa de abstracción de E/S de "
"OpenSSL."

#: ../Doc/library/ssl.rst:2495
msgid ""
"This class has no public constructor.  An :class:`SSLObject` instance must "
"be created using the :meth:`~SSLContext.wrap_bio` method. This method will "
"create the :class:`SSLObject` instance and bind it to a pair of BIOs. The "
"*incoming* BIO is used to pass data from Python to the SSL protocol "
"instance, while the *outgoing* BIO is used to pass data the other way around."
msgstr ""
"Esta clase no tiene un constructor público. Se debe crear una instancia :"
"class:`SSLObject` utilizando el método :meth:`~SSLContext.wrap_bio`. Este "
"método creará la instancia :class:`SSLObject` y la vinculará a un par de "
"BIOs. El BIO *de entrada* se utiliza para pasar los datos de Python a la "
"instancia del protocolo SSL, mientras que el BIO *de salida* se utiliza para "
"pasar los datos a la inversa."

#: ../Doc/library/ssl.rst:2502
msgid "The following methods are available:"
msgstr "Los siguientes métodos son disponibles:"

#: ../Doc/library/ssl.rst:2504
msgid ":attr:`~SSLSocket.context`"
msgstr ":attr:`~SSLSocket.context`"

#: ../Doc/library/ssl.rst:2505
msgid ":attr:`~SSLSocket.server_side`"
msgstr ":attr:`~SSLSocket.server_side`"

#: ../Doc/library/ssl.rst:2506
msgid ":attr:`~SSLSocket.server_hostname`"
msgstr ":attr:`~SSLSocket.server_hostname`"

#: ../Doc/library/ssl.rst:2507
msgid ":attr:`~SSLSocket.session`"
msgstr ":attr:`~SSLSocket.session`"

#: ../Doc/library/ssl.rst:2508
msgid ":attr:`~SSLSocket.session_reused`"
msgstr ":attr:`~SSLSocket.session_reused`"

#: ../Doc/library/ssl.rst:2509
msgid ":meth:`~SSLSocket.read`"
msgstr ":meth:`~SSLSocket.read`"

#: ../Doc/library/ssl.rst:2510
msgid ":meth:`~SSLSocket.write`"
msgstr ":meth:`~SSLSocket.write`"

#: ../Doc/library/ssl.rst:2511
msgid ":meth:`~SSLSocket.getpeercert`"
msgstr ":meth:`~SSLSocket.getpeercert`"

#: ../Doc/library/ssl.rst:2512
msgid ":meth:`~SSLSocket.selected_alpn_protocol`"
msgstr ":meth:`~SSLSocket.selected_alpn_protocol`"

#: ../Doc/library/ssl.rst:2513
msgid ":meth:`~SSLSocket.selected_npn_protocol`"
msgstr ":meth:`~SSLSocket.selected_npn_protocol`"

#: ../Doc/library/ssl.rst:2514
msgid ":meth:`~SSLSocket.cipher`"
msgstr ":meth:`~SSLSocket.cipher`"

#: ../Doc/library/ssl.rst:2515
msgid ":meth:`~SSLSocket.shared_ciphers`"
msgstr ":meth:`~SSLSocket.shared_ciphers`"

#: ../Doc/library/ssl.rst:2516
msgid ":meth:`~SSLSocket.compression`"
msgstr ":meth:`~SSLSocket.compression`"

#: ../Doc/library/ssl.rst:2517
msgid ":meth:`~SSLSocket.pending`"
msgstr ":meth:`~SSLSocket.pending`"

#: ../Doc/library/ssl.rst:2518
msgid ":meth:`~SSLSocket.do_handshake`"
msgstr ":meth:`~SSLSocket.do_handshake`"

#: ../Doc/library/ssl.rst:2519
msgid ":meth:`~SSLSocket.verify_client_post_handshake`"
msgstr ":meth:`~SSLSocket.verify_client_post_handshake`"

#: ../Doc/library/ssl.rst:2520
msgid ":meth:`~SSLSocket.unwrap`"
msgstr ":meth:`~SSLSocket.unwrap`"

#: ../Doc/library/ssl.rst:2521
msgid ":meth:`~SSLSocket.get_channel_binding`"
msgstr ":meth:`~SSLSocket.get_channel_binding`"

#: ../Doc/library/ssl.rst:2522
msgid ":meth:`~SSLSocket.version`"
msgstr ":meth:`~SSLSocket.version`"

#: ../Doc/library/ssl.rst:2524
msgid ""
"When compared to :class:`SSLSocket`, this object lacks the following "
"features:"
msgstr ""
"En comparación con :class:`SSLSocket`, este objeto carece de las siguientes "
"características:"

#: ../Doc/library/ssl.rst:2527
msgid ""
"Any form of network IO; ``recv()`` and ``send()`` read and write only to the "
"underlying :class:`MemoryBIO` buffers."
msgstr ""
"Cualquier forma de E/S de red; ``recv()`` y ``send()`` leen y escriben sólo "
"en los búfers subyacentes de :class:`MemoryBIO`."

#: ../Doc/library/ssl.rst:2530
msgid ""
"There is no *do_handshake_on_connect* machinery. You must always manually "
"call :meth:`~SSLSocket.do_handshake` to start the handshake."
msgstr ""
"No existe la maquinaria *do_handshake_on_connect*. Siempre hay que llamar "
"manualmente a :meth:`~SSLSocket.do_handshake` para iniciar el handshake."

#: ../Doc/library/ssl.rst:2533
msgid ""
"There is no handling of *suppress_ragged_eofs*. All end-of-file conditions "
"that are in violation of the protocol are reported via the :exc:"
"`SSLEOFError` exception."
msgstr ""
"No hay manejo de *suppress_ragged_eofs*. Todas las condiciones de fin de "
"archivo que violan el protocolo se reportan a través de la excepción :exc:"
"`SSLEOFError`."

#: ../Doc/library/ssl.rst:2537
msgid ""
"The method :meth:`~SSLSocket.unwrap` call does not return anything, unlike "
"for an SSL socket where it returns the underlying socket."
msgstr ""
"La llamada al método :meth:`~SSLSocket.unwrap` no devuelve nada, a "
"diferencia de lo que ocurre con un socket SSL, que devuelve el socket "
"subyacente."

#: ../Doc/library/ssl.rst:2540
msgid ""
"The *server_name_callback* callback passed to :meth:`SSLContext."
"set_servername_callback` will get an :class:`SSLObject` instance instead of "
"a :class:`SSLSocket` instance as its first parameter."
msgstr ""
"La función callback *server_name_callback* pasada a :meth:`SSLContext."
"set_servername_callback` obtendrá una instancia de :class:`SSLObject` en "
"lugar de una instancia de :class:`SSLSocket` como primer parámetro."

#: ../Doc/library/ssl.rst:2544
msgid "Some notes related to the use of :class:`SSLObject`:"
msgstr "Algunas notas relacionadas con el uso de :class:`SSLObject`:"

#: ../Doc/library/ssl.rst:2546
msgid ""
"All IO on an :class:`SSLObject` is :ref:`non-blocking <ssl-nonblocking>`. "
"This means that for example :meth:`~SSLSocket.read` will raise an :exc:"
"`SSLWantReadError` if it needs more data than the incoming BIO has available."
msgstr ""
"Toda la E/S en un :class:`SSLObject` es :ref:`non-blocking <ssl-"
"nonblocking>`. Esto significa que, por ejemplo, :meth:`~SSLSocket.read` "
"lanzará un :exc:`SSLWantReadError` si necesita más datos de los que la BIO "
"entrante tiene disponibles."

#: ../Doc/library/ssl.rst:2551
msgid ""
"There is no module-level ``wrap_bio()`` call like there is for :meth:"
"`~SSLContext.wrap_socket`. An :class:`SSLObject` is always created via an :"
"class:`SSLContext`."
msgstr ""
"No hay una llamada a nivel de módulo ``wrap_bio()`` como la que hay para :"
"meth:`~SSLContext.wrap_socket`. Un :class:`SSLObject` siempre se crea a "
"través de un :class:`SSLContext`."

#: ../Doc/library/ssl.rst:2555
msgid ""
":class:`SSLObject` instances must to created with :meth:`~SSLContext."
"wrap_bio`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""
"Las instancias :class:`SSLObject` deben crearse con :meth:`~SSLContext."
"wrap_bio`. En versiones anteriores, era posible crear instancias "
"directamente. Esto nunca fue documentado ni soportado oficialmente."

#: ../Doc/library/ssl.rst:2561
msgid ""
"An SSLObject communicates with the outside world using memory buffers. The "
"class :class:`MemoryBIO` provides a memory buffer that can be used for this "
"purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:"
msgstr ""
"Un SSLObject se comunica con el mundo exterior utilizando búfers de memoria. "
"La clase :class:`MemoryBIO` proporciona un búfer de memoria que puede ser "
"utilizado para este propósito. Envuelve un objeto BIO (Basic IO) de memoria "
"de OpenSSL:"

#: ../Doc/library/ssl.rst:2567
msgid ""
"A memory buffer that can be used to pass data between Python and an SSL "
"protocol instance."
msgstr ""
"Un búfer de memoria que se puede utilizar para pasar datos entre Python y "
"una instancia del protocolo SSL."

#: ../Doc/library/ssl.rst:2572
msgid "Return the number of bytes currently in the memory buffer."
msgstr ""
"Retorna el número de bytes que se encuentran actualmente en la memoria búfer."

#: ../Doc/library/ssl.rst:2576
msgid ""
"A boolean indicating whether the memory BIO is current at the end-of-file "
"position."
msgstr ""
"Un booleano que indica si la memoria BIO es actual en la posición de fin de "
"archivo."

#: ../Doc/library/ssl.rst:2581
msgid ""
"Read up to *n* bytes from the memory buffer. If *n* is not specified or "
"negative, all bytes are returned."
msgstr ""
"Lee hasta *n* bytes del búfer de memoria. Si *n* no se especifica o es "
"negativo, se devuelven todos los bytes."

#: ../Doc/library/ssl.rst:2586
msgid ""
"Write the bytes from *buf* to the memory BIO. The *buf* argument must be an "
"object supporting the buffer protocol."
msgstr ""
"Escribe los bytes de *buf* en la memoria BIO. El argumento *buf* debe ser un "
"objeto que soporte el protocolo de búfer."

#: ../Doc/library/ssl.rst:2589
msgid ""
"The return value is the number of bytes written, which is always equal to "
"the length of *buf*."
msgstr ""
"El valor de retorno es el número de bytes escritos, que siempre es igual a "
"la longitud de *buf*."

#: ../Doc/library/ssl.rst:2594
msgid ""
"Write an EOF marker to the memory BIO. After this method has been called, it "
"is illegal to call :meth:`~MemoryBIO.write`. The attribute :attr:`eof` will "
"become true after all data currently in the buffer has been read."
msgstr ""
"Escribe un marcador EOF en la memoria BIO. Después de llamar a este método, "
"es ilegal llamar a :meth:`~MemoryBIO.write`. El atributo :attr:`eof` se "
"convertirá en verdadero después de que se hayan leído todos los datos que "
"hay actualmente en el búfer."

#: ../Doc/library/ssl.rst:2600
msgid "SSL session"
msgstr "Sesión SSL"

#: ../Doc/library/ssl.rst:2606
msgid "Session object used by :attr:`~SSLSocket.session`."
msgstr "Objeto sesión usado por :attr:`~SSLSocket.session`."

#: ../Doc/library/ssl.rst:2618
msgid "Security considerations"
msgstr "Consideraciones de seguridad"

#: ../Doc/library/ssl.rst:2621
msgid "Best defaults"
msgstr "Los mejores valores por defecto"

#: ../Doc/library/ssl.rst:2623
msgid ""
"For **client use**, if you don't have any special requirements for your "
"security policy, it is highly recommended that you use the :func:"
"`create_default_context` function to create your SSL context. It will load "
"the system's trusted CA certificates, enable certificate validation and "
"hostname checking, and try to choose reasonably secure protocol and cipher "
"settings."
msgstr ""
"Para el **uso en el cliente**, si no tiene ningún requisito especial para su "
"política de seguridad, es muy recomendable que utilice la función :func:"
"`create_default_context` para crear su contexto SSL. Cargará los "
"certificados CA de confianza del sistema, habilitará la validación de "
"certificados y la comprobación del hostname, e intentará elegir una "
"configuración de protocolo y cifrado razonablemente segura."

#: ../Doc/library/ssl.rst:2630
msgid ""
"For example, here is how you would use the :class:`smtplib.SMTP` class to "
"create a trusted, secure connection to a SMTP server::"
msgstr ""
"Por ejemplo, así es como se utiliza la clase :class:`smtplib.SMTP` para "
"crear una conexión segura y de confianza con un servidor SMTP::"

#: ../Doc/library/ssl.rst:2639
msgid ""
"If a client certificate is needed for the connection, it can be added with :"
"meth:`SSLContext.load_cert_chain`."
msgstr ""
"Si se necesita un certificado de cliente para la conexión, se puede añadir "
"con :meth:`SSLContext.load_cert_chain`."

#: ../Doc/library/ssl.rst:2642
msgid ""
"By contrast, if you create the SSL context by calling the :class:"
"`SSLContext` constructor yourself, it will not have certificate validation "
"nor hostname checking enabled by default.  If you do so, please read the "
"paragraphs below to achieve a good security level."
msgstr ""
"Por el contrario, si crea el contexto SSL llamando usted mismo al "
"constructor :class:`SSLContext`, no tendrá activada por defecto la "
"validación de certificados ni la comprobación de hostname. Si lo hace, lea "
"los párrafos siguientes para conseguir un buen nivel de seguridad."

#: ../Doc/library/ssl.rst:2648
msgid "Manual settings"
msgstr "Ajustes manuales"

#: ../Doc/library/ssl.rst:2651
msgid "Verifying certificates"
msgstr "Verificación de certificados"

#: ../Doc/library/ssl.rst:2653
msgid ""
"When calling the :class:`SSLContext` constructor directly, :const:"
"`CERT_NONE` is the default.  Since it does not authenticate the other peer, "
"it can be insecure, especially in client mode where most of time you would "
"like to ensure the authenticity of the server you're talking to. Therefore, "
"when in client mode, it is highly recommended to use :const:"
"`CERT_REQUIRED`.  However, it is in itself not sufficient; you also have to "
"check that the server certificate, which can be obtained by calling :meth:"
"`SSLSocket.getpeercert`, matches the desired service.  For many protocols "
"and applications, the service can be identified by the hostname; in this "
"case, the :func:`match_hostname` function can be used.  This common check is "
"automatically performed when :attr:`SSLContext.check_hostname` is enabled."
msgstr ""
"Cuando se llama al constructor de :class:`SSLContext` directamente, :const:"
"`CERT_NONE` es el valor por defecto. Dado que no autentifica al otro peer, "
"puede ser inseguro, especialmente en modo cliente, donde la mayoría de las "
"veces se quiere asegurar la autenticidad del servidor con el que se está "
"hablando. Por lo tanto, cuando se está en modo cliente, es muy recomendable "
"utilizar :const:`CERT_REQUIRED`. Sin embargo, no es suficiente por sí mismo; "
"también hay que comprobar que el certificado del servidor, que se puede "
"obtener llamando a :meth:`SSLSocket.getpeercert`, coincide con el servicio "
"deseado. Para muchos protocolos y aplicaciones, el servicio puede ser "
"identificado por el hostname; en este caso, se puede utilizar la función :"
"func:`match_hostname`. Esta comprobación común se realiza automáticamente "
"cuando :attr:`SSLContext.check_hostname` está activado."

# La expresión "hostname matching" suena un poco raro aquí. Sin embargo, como
# no lo he traducido en el resto del documento, lo dejo aquí también en
# inglés.
#: ../Doc/library/ssl.rst:2666
msgid ""
"Hostname matchings is now performed by OpenSSL. Python no longer uses :func:"
"`match_hostname`."
msgstr ""
"Las hostname matchings son ahora realizadas por OpenSSL. Python ya no "
"utiliza :func:`match_hostname`."

#: ../Doc/library/ssl.rst:2670
msgid ""
"In server mode, if you want to authenticate your clients using the SSL layer "
"(rather than using a higher-level authentication mechanism), you'll also "
"have to specify :const:`CERT_REQUIRED` and similarly check the client "
"certificate."
msgstr ""
"En el modo servidor, si quiere autenticar a sus clientes utilizando la capa "
"SSL (en lugar de utilizar un mecanismo de autenticación de nivel superior), "
"también tendrá que especificar :const:`CERT_REQUIRED` y comprobar de forma "
"similar el certificado del cliente."

#: ../Doc/library/ssl.rst:2676
msgid "Protocol versions"
msgstr "Versiones del protocolo"

#: ../Doc/library/ssl.rst:2678
msgid ""
"SSL versions 2 and 3 are considered insecure and are therefore dangerous to "
"use.  If you want maximum compatibility between clients and servers, it is "
"recommended to use :const:`PROTOCOL_TLS_CLIENT` or :const:"
"`PROTOCOL_TLS_SERVER` as the protocol version. SSLv2 and SSLv3 are disabled "
"by default."
msgstr ""
"Las versiones 2 y 3 de SSL se consideran inseguras y, por lo tanto, su uso "
"es peligroso. Si desea la máxima compatibilidad entre clientes y servidores, "
"se recomienda utilizar :const:`PROTOCOL_TLS_CLIENT` o :const:"
"`PROTOCOL_TLS_SERVER` como versión del protocolo. SSLv2 y SSLv3 están "
"desactivados por defecto."

#: ../Doc/library/ssl.rst:2691
msgid ""
"The SSL context created above will only allow TLSv1.2 and later (if "
"supported by your system) connections to a server. :const:"
"`PROTOCOL_TLS_CLIENT` implies certificate validation and hostname checks by "
"default. You have to load certificates into the context."
msgstr ""
"El contexto SSL creado anteriormente sólo permitirá conexiones TLSv1.2 y "
"posteriores (si su sistema lo soporta) a un servidor. :const:"
"`PROTOCOL_TLS_CLIENT` implica la validación del certificado y la "
"comprobación del nombre de host por defecto. Tiene que cargar los "
"certificados en el contexto."

#: ../Doc/library/ssl.rst:2698
msgid "Cipher selection"
msgstr "Selección de cifrado"

# Aquí me parece mas claro traducir el título del enlace (incluso si el enlace
# no está en español).
#: ../Doc/library/ssl.rst:2700
#, fuzzy
msgid ""
"If you have advanced security requirements, fine-tuning of the ciphers "
"enabled when negotiating a SSL session is possible through the :meth:"
"`SSLContext.set_ciphers` method.  Starting from Python 3.2.3, the ssl module "
"disables certain weak ciphers by default, but you may want to further "
"restrict the cipher choice. Be sure to read OpenSSL's documentation about "
"the `cipher list format <https://www.openssl.org/docs/man1.1.1/man1/ciphers."
"html#CIPHER-LIST-FORMAT>`_. If you want to check which ciphers are enabled "
"by a given cipher list, use :meth:`SSLContext.get_ciphers` or the ``openssl "
"ciphers`` command on your system."
msgstr ""
"Si tienes requisitos de seguridad avanzados, es posible ajustar los cifrados "
"habilitados al negociar una sesión SSL mediante el método :meth:`SSLContext."
"set_ciphers`. A partir de Python 3.2.3, el módulo ssl deshabilita ciertos "
"cifrados débiles por defecto, pero es posible que quieras restringir más la "
"elección del cifrado. Asegúrese de leer la documentación de OpenSSL sobre el "
"`formato de la lista de cifrado <https://www.openssl.org/docs/manmaster/man1/"
"ciphers.html#CIPHER-LIST-FORMAT>`_. Si quiere comprobar qué cifrados están "
"habilitados por una determinada lista de cifrado, utilice :meth:`SSLContext."
"get_ciphers` o el comando ``openssl ciphers`` en su sistema."

#: ../Doc/library/ssl.rst:2711
msgid "Multi-processing"
msgstr "Multiprocesamiento"

#: ../Doc/library/ssl.rst:2713
msgid ""
"If using this module as part of a multi-processed application (using, for "
"example the :mod:`multiprocessing` or :mod:`concurrent.futures` modules), be "
"aware that OpenSSL's internal random number generator does not properly "
"handle forked processes.  Applications must change the PRNG state of the "
"parent process if they use any SSL feature with :func:`os.fork`.  Any "
"successful call of :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` or :func:"
"`~ssl.RAND_pseudo_bytes` is sufficient."
msgstr ""
"Si utiliza este módulo como parte de una aplicación multiproceso "
"(utilizando, por ejemplo, los módulos :mod:`multiprocessing` o :mod:"
"`concurrent.futures`), tenga en cuenta que el generador de números "
"aleatorios interno de OpenSSL no maneja adecuadamente los procesos "
"bifurcados. Las aplicaciones deben cambiar el estado del PRNG del proceso "
"padre si utilizan cualquier función de SSL con :func:`os.fork`. Cualquier "
"llamada exitosa de :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` o :func:"
"`~ssl.RAND_pseudo_bytes` es suficiente."

#: ../Doc/library/ssl.rst:2725
msgid "TLS 1.3"
msgstr "TLS 1.3"

#: ../Doc/library/ssl.rst:2729
msgid ""
"The TLS 1.3 protocol behaves slightly differently than previous version of "
"TLS/SSL. Some new TLS 1.3 features are not yet available."
msgstr ""
"Python tiene soporte provisional y experimental para TLS 1.3 con OpenSSL "
"1.1.1. El nuevo protocolo se comporta de forma ligeramente diferente a la "
"versión anterior de TLS/SSL. Algunas de las nuevas características de TLS "
"1.3 aún no están disponibles."

#: ../Doc/library/ssl.rst:2732
msgid ""
"TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and ChaCha20 "
"cipher suites are enabled by default.  The method :meth:`SSLContext."
"set_ciphers` cannot enable or disable any TLS 1.3 ciphers yet, but :meth:"
"`SSLContext.get_ciphers` returns them."
msgstr ""
"TLS 1.3 utiliza un conjunto disjunto de suites de cifrado. Todas las suites "
"de cifrado AES-GCM y ChaCha20 están habilitadas por defecto.  El método :"
"meth:`SSLContext.set_ciphers` aún no puede habilitar o deshabilitar ningún "
"cifrado de TLS 1.3, pero :meth:`SSLContext.get_ciphers` los devuelve."

#: ../Doc/library/ssl.rst:2736
msgid ""
"Session tickets are no longer sent as part of the initial handshake and are "
"handled differently.  :attr:`SSLSocket.session` and :class:`SSLSession` are "
"not compatible with TLS 1.3."
msgstr ""
"Los tickets de sesión ya no se envían como parte del handshake inicial y se "
"manejan de forma diferente. :attr:`SSLSocket.session` y :class:`SSLSession` "
"no son compatibles con TLS 1.3."

#: ../Doc/library/ssl.rst:2739
msgid ""
"Client-side certificates are also no longer verified during the initial "
"handshake.  A server can request a certificate at any time.  Clients process "
"certificate requests while they send or receive application data from the "
"server."
msgstr ""
"Los certificados del lado del cliente ya no se verifican durante el "
"handshake inicial. Un servidor puede solicitar un certificado en cualquier "
"momento. Los clientes procesan las solicitudes de certificados mientras "
"envían o reciben datos de la aplicación desde el servidor."

#: ../Doc/library/ssl.rst:2743
msgid ""
"TLS 1.3 features like early data, deferred TLS client cert request, "
"signature algorithm configuration, and rekeying are not supported yet."
msgstr ""
"Las funciones de TLS 1.3, como los datos anticipados, la solicitud de "
"certificado de cliente TLS diferida, la configuración del algoritmo de firma "
"y la repetición de claves, aún no son compatibles."

#: ../Doc/library/ssl.rst:2750
msgid "Class :class:`socket.socket`"
msgstr "Clase :class:`socket.socket`"

#: ../Doc/library/ssl.rst:2750
msgid "Documentation of underlying :mod:`socket` class"
msgstr "Documentación de la clase :mod:`socket` subyacente"

#: ../Doc/library/ssl.rst:2753
msgid ""
"`SSL/TLS Strong Encryption: An Introduction <https://httpd.apache.org/docs/"
"trunk/en/ssl/ssl_intro.html>`_"
msgstr ""
"`SSL/TLS Strong Encryption: An Introduction <https://httpd.apache.org/docs/"
"trunk/en/ssl/ssl_intro.html>`_"

#: ../Doc/library/ssl.rst:2753
msgid "Intro from the Apache HTTP Server documentation"
msgstr "Introducción de la documentación del servidor HTTP Apache"

#: ../Doc/library/ssl.rst:2756
msgid ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <1422>`"
msgstr ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <1422>`"

#: ../Doc/library/ssl.rst:2756
msgid "Steve Kent"
msgstr "Steve Kent"

#: ../Doc/library/ssl.rst:2759
msgid ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"
msgstr ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"

#: ../Doc/library/ssl.rst:2759
msgid "Donald E., Jeffrey I. Schiller"
msgstr "Donald E., Jeffrey I. Schiller"

#: ../Doc/library/ssl.rst:2762
msgid ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"
msgstr ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"

#: ../Doc/library/ssl.rst:2762
msgid "D. Cooper"
msgstr "D. Cooper"

#: ../Doc/library/ssl.rst:2765
msgid ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"
msgstr ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"

#: ../Doc/library/ssl.rst:2765
msgid "T. Dierks et. al."
msgstr "T. Dierks et. al."

#: ../Doc/library/ssl.rst:2768
msgid ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"
msgstr ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"

#: ../Doc/library/ssl.rst:2768
msgid "D. Eastlake"
msgstr "D. Eastlake"

#: ../Doc/library/ssl.rst:2771
msgid ""
"`IANA TLS: Transport Layer Security (TLS) Parameters <https://www.iana.org/"
"assignments/tls-parameters/tls-parameters.xml>`_"
msgstr ""
"`IANA TLS: Transport Layer Security (TLS) Parameters <https://www.iana.org/"
"assignments/tls-parameters/tls-parameters.xml>`_"

#: ../Doc/library/ssl.rst:2771
msgid "IANA"
msgstr "IANA"

#: ../Doc/library/ssl.rst:2774
msgid ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer Security "
"(TLS) and Datagram Transport Layer Security (DTLS) <7525>`"
msgstr ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer Security "
"(TLS) and Datagram Transport Layer Security (DTLS) <7525>`"

#: ../Doc/library/ssl.rst:2774
msgid "IETF"
msgstr "IETF"

#: ../Doc/library/ssl.rst:2776
msgid ""
"`Mozilla's Server Side TLS recommendations <https://wiki.mozilla.org/"
"Security/Server_Side_TLS>`_"
msgstr ""
"`Mozilla's Server Side TLS recommendations <https://wiki.mozilla.org/"
"Security/Server_Side_TLS>`_"

#: ../Doc/library/ssl.rst:2777
msgid "Mozilla"
msgstr "Mozilla"

#~ msgid ""
#~ ":ref:`Availability <availability>`: LibreSSL ignores the environment "
#~ "vars :attr:`openssl_cafile_env` and :attr:`openssl_capath_env`."
#~ msgstr ""
#~ ":ref:`Disponibilidad <availability>`: LibreSSL ignora las variables de "
#~ "entorno :attr:`openssl_cafile_env` y :attr:`openssl_capath_env`."

#~ msgid ""
#~ "This protocol is not be available if OpenSSL is compiled with the "
#~ "``OPENSSL_NO_SSLv3`` flag."
#~ msgstr ""
#~ "Este protocolo no está disponible si OpenSSL fue compilada con la opción "
#~ "``OPENSSL_NO_SSLv3``."
