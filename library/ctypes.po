# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2021-08-07 16:58+0200\n"
"Last-Translator: Cristián Maureira-Fredes <cmaureirafredes@gmail.com>\n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.0\n"

#: ../Doc/library/ctypes.rst:2
msgid ":mod:`ctypes` --- A foreign function library for Python"
msgstr ":mod:`ctypes` --- Una biblioteca de funciones foráneas para Python"

#: ../Doc/library/ctypes.rst:9
msgid "**Source code:** :source:`Lib/ctypes`"
msgstr ""

#: ../Doc/library/ctypes.rst:13
msgid ""
":mod:`ctypes` is a foreign function library for Python.  It provides C "
"compatible data types, and allows calling functions in DLLs or shared "
"libraries.  It can be used to wrap these libraries in pure Python."
msgstr ""
":mod:`ctypes` es una biblioteca de funciones foráneas para Python. "
"Proporciona tipos de datos compatibles con C y permite llamar a funciones en "
"archivos DLL o bibliotecas compartidas. Se puede utilizar para envolver "
"estas bibliotecas en Python puro."

#: ../Doc/library/ctypes.rst:21
msgid "ctypes tutorial"
msgstr "tutorial de ctypes"

#: ../Doc/library/ctypes.rst:23
msgid ""
"Note: The code samples in this tutorial use :mod:`doctest` to make sure that "
"they actually work.  Since some code samples behave differently under Linux, "
"Windows, or macOS, they contain doctest directives in comments."
msgstr ""
"Nota: Los ejemplos de código en este tutorial usan :mod:`doctest` para "
"asegurarse de que realmente funcionen. Dado que algunos ejemplos de código "
"se comportan de manera diferente en Linux, Windows o macOS, contienen "
"directivas doctest en los comentarios."

#: ../Doc/library/ctypes.rst:27
msgid ""
"Note: Some code samples reference the ctypes :class:`c_int` type.  On "
"platforms where ``sizeof(long) == sizeof(int)`` it is an alias to :class:"
"`c_long`. So, you should not be confused if :class:`c_long` is printed if "
"you would expect :class:`c_int` --- they are actually the same type."
msgstr ""
"Nota: Algunos ejemplos de código hacen referencia al tipo ctypes :class:"
"`c_int`. En las plataformas donde ``sizeof(long) == sizeof(int)`` es un "
"alias de :class:`c_long`. Por lo tanto, no debe confundirse si :class:"
"`c_long` se imprime si espera :class:`c_int` --- son en realidad del mismo "
"tipo."

#: ../Doc/library/ctypes.rst:35
msgid "Loading dynamic link libraries"
msgstr "Carga de bibliotecas de enlaces dinámicos"

#: ../Doc/library/ctypes.rst:37
msgid ""
":mod:`ctypes` exports the *cdll*, and on Windows *windll* and *oledll* "
"objects, for loading dynamic link libraries."
msgstr ""
":mod:`ctypes` exporta los objetos *cdll* y en Windows *windll* y *oledll*, "
"para cargar bibliotecas de enlaces dinámicos."

#: ../Doc/library/ctypes.rst:40
#, fuzzy
msgid ""
"You load libraries by accessing them as attributes of these objects. *cdll* "
"loads libraries which export functions using the standard ``cdecl`` calling "
"convention, while *windll* libraries call functions using the ``stdcall`` "
"calling convention. *oledll* also uses the ``stdcall`` calling convention, "
"and assumes the functions return a Windows :c:type:`!HRESULT` error code. "
"The error code is used to automatically raise an :class:`OSError` exception "
"when the function call fails."
msgstr ""
"Las bibliotecas se cargan accediendo a ellas como atributos de estos "
"objetos. *cdll* carga bibliotecas que exportan funciones utilizando la "
"convención de llamada estándar ``cdecl``, mientras que las bibliotecas "
"*windll* llaman a funciones mediante la convención de llamada ``stdcall``. "
"*oledll* también utiliza la convención de llamada ``stdcall`` y asume que "
"las funciones retornan un código de error Windows :c:type:`HRESULT`. El "
"código de error se utiliza para generar automáticamente una excepción :class:"
"`OSError` cuando se produce un error en la llamada a la función."

#: ../Doc/library/ctypes.rst:48
msgid ""
"Windows errors used to raise :exc:`WindowsError`, which is now an alias of :"
"exc:`OSError`."
msgstr ""
"Los errores de Windows solían generar :exc:`WindowsError`, que ahora es un "
"alias de :exc:`OSError`."

#: ../Doc/library/ctypes.rst:53
msgid ""
"Here are some examples for Windows. Note that ``msvcrt`` is the MS standard "
"C library containing most standard C functions, and uses the cdecl calling "
"convention::"
msgstr ""
"Estos son algunos ejemplos para Windows. Tener en cuenta que ''msvcrt'' es "
"la biblioteca estándar de MS C que contiene la mayoría de las funciones C "
"estándar y utiliza la convención de llamada cdecl::"

#: ../Doc/library/ctypes.rst:65
msgid "Windows appends the usual ``.dll`` file suffix automatically."
msgstr "Windows agrega automáticamente la extensión común ``.dll``."

#: ../Doc/library/ctypes.rst:68
msgid ""
"Accessing the standard C library through ``cdll.msvcrt`` will use an "
"outdated version of the library that may be incompatible with the one being "
"used by Python. Where possible, use native Python functionality, or else "
"import and use the ``msvcrt`` module."
msgstr ""
"Acceder a la biblioteca estándar de C a través de ``cdll.msvcrt`` utilizará "
"una versión obsoleta de la biblioteca que puede ser incompatible con la "
"utilizada por Python. Cuando sea posible, use la funcionalidad nativa de "
"Python, o bien importe y use el módulo ``msvcrt``."

#: ../Doc/library/ctypes.rst:73
#, fuzzy
msgid ""
"On Linux, it is required to specify the filename *including* the extension "
"to load a library, so attribute access can not be used to load libraries. "
"Either the :meth:`~LibraryLoader.LoadLibrary` method of the dll loaders "
"should be used, or you should load the library by creating an instance of "
"CDLL by calling the constructor::"
msgstr ""
"En Linux, se requiere especificar el nombre de archivo *incluyendo* la "
"extensión para cargar una biblioteca, por lo que no se puede utilizar el "
"acceso por atributos para cargar las bibliotecas. Se debe usar el método :"
"meth:`LoadLibrary` de los cargadores de dll, o se debe cargar la biblioteca "
"creando una instancia de CDLL llamando al constructor::"

#: ../Doc/library/ctypes.rst:92
msgid "Accessing functions from loaded dlls"
msgstr "Acceder a las funciones de los dll cargados"

#: ../Doc/library/ctypes.rst:94
msgid "Functions are accessed as attributes of dll objects::"
msgstr "Las funciones se acceden como atributos de los objetos dll::"

#: ../Doc/library/ctypes.rst:109
msgid ""
"Note that win32 system dlls like ``kernel32`` and ``user32`` often export "
"ANSI as well as UNICODE versions of a function. The UNICODE version is "
"exported with an ``W`` appended to the name, while the ANSI version is "
"exported with an ``A`` appended to the name. The win32 ``GetModuleHandle`` "
"function, which returns a *module handle* for a given module name, has the "
"following C prototype, and a macro is used to expose one of them as "
"``GetModuleHandle`` depending on whether UNICODE is defined or not::"
msgstr ""
"Nótese que las dlls del sistema win32 como ``kernel32`` y ``user32`` a "
"menudo exportan versiones ANSI y UNICODE de una función. La versión UNICODE "
"se exporta con una ``W`` añadida al nombre, mientras que la versión ANSI se "
"exporta con una ``A`` añadida al nombre. La función ``GetModuleHandle`` de "
"win32, que retorna un *manejador de módulo* para un nombre de módulo dado, "
"tiene el siguiente prototipo de C, y se usa una macro para exponer uno de "
"ellos como ``GetModuleHandle`` dependiendo de si UNICODE está definido o no::"

#: ../Doc/library/ctypes.rst:122
msgid ""
"*windll* does not try to select one of them by magic, you must access the "
"version you need by specifying ``GetModuleHandleA`` or ``GetModuleHandleW`` "
"explicitly, and then call it with bytes or string objects respectively."
msgstr ""
"*windll* no intenta seleccionar una de ellas por arte de magia, se debe "
"acceder a la versión que se necesita especificando ``GetModuleHandleA`` o "
"``GetModuleHandleW`` explícitamente, y luego llamarlo con bytes u objetos de "
"cadena respectivamente."

#: ../Doc/library/ctypes.rst:126
msgid ""
"Sometimes, dlls export functions with names which aren't valid Python "
"identifiers, like ``\"??2@YAPAXI@Z\"``. In this case you have to use :func:"
"`getattr` to retrieve the function::"
msgstr ""
"A veces, las dlls exportan funciones con nombres que no son identificadores "
"válidos de Python, como ``\"??2@YAPAXI@Z\"``. En este caso tienes que usar :"
"func:`getattr` para recuperar la función::"

#: ../Doc/library/ctypes.rst:134
msgid ""
"On Windows, some dlls export functions not by name but by ordinal. These "
"functions can be accessed by indexing the dll object with the ordinal "
"number::"
msgstr ""
"En Windows, algunas dlls exportan funciones no por nombre sino por ordinal. "
"Se pueden acceder a estas funciones indexando el objeto dll con el número "
"ordinal::"

#: ../Doc/library/ctypes.rst:151
msgid "Calling functions"
msgstr "Funciones de llamada"

#: ../Doc/library/ctypes.rst:153
#, fuzzy
msgid ""
"You can call these functions like any other Python callable. This example "
"uses the ``rand()`` function, which takes no arguments and returns a pseudo-"
"random integer::"
msgstr ""
"Puedes llamar a estas funciones como cualquier otra función en Python. Este "
"ejemplo utiliza la función ``time()``, que retorna el tiempo del sistema en "
"segundos desde la época de Unix, y la función ``GetModuleHandleA()``, que "
"retorna un manejador de módulo de win32."

#: ../Doc/library/ctypes.rst:159
msgid ""
"On Windows, you can call the ``GetModuleHandleA()`` function, which returns "
"a win32 module handle (passing ``None`` as single argument to call it with a "
"``NULL`` pointer)::"
msgstr ""

#: ../Doc/library/ctypes.rst:166
msgid ""
":exc:`ValueError` is raised when you call an ``stdcall`` function with the "
"``cdecl`` calling convention, or vice versa::"
msgstr ""
":exc:`ValueError` es lanzado cuando se llama a una función ``stdcall`` con "
"la convención de llamada ``cdecl``, o viceversa::"

#: ../Doc/library/ctypes.rst:181
msgid ""
"To find out the correct calling convention you have to look into the C "
"header file or the documentation for the function you want to call."
msgstr ""
"Para saber la convención de llamada correcta, hay que mirar en el archivo de "
"encabezado C o en la documentación de la función que se quiere llamar."

#: ../Doc/library/ctypes.rst:184
msgid ""
"On Windows, :mod:`ctypes` uses win32 structured exception handling to "
"prevent crashes from general protection faults when functions are called "
"with invalid argument values::"
msgstr ""
"En Windows, :mod:`ctypes` utiliza la gestión de excepciones estructurada de "
"win32 para evitar que se produzcan fallos de protección general cuando se "
"llaman funciones con valores de argumento inválidos::"

#: ../Doc/library/ctypes.rst:194
msgid ""
"There are, however, enough ways to crash Python with :mod:`ctypes`, so you "
"should be careful anyway.  The :mod:`faulthandler` module can be helpful in "
"debugging crashes (e.g. from segmentation faults produced by erroneous C "
"library calls)."
msgstr ""
"Sin embargo, hay suficientes maneras de bloquear Python con :mod:`ctypes`, "
"así que debes tener cuidado de todos modos. El módulo :mod:`faulthandler` "
"puede ser útil para depurar bloqueos (por ejemplo, provenientes de fallos de "
"segmentación producidos por llamadas erróneas a la biblioteca C)."

#: ../Doc/library/ctypes.rst:199
msgid ""
"``None``, integers, bytes objects and (unicode) strings are the only native "
"Python objects that can directly be used as parameters in these function "
"calls. ``None`` is passed as a C ``NULL`` pointer, bytes objects and strings "
"are passed as pointer to the memory block that contains their data (:c:expr:"
"`char *` or :c:expr:`wchar_t *`).  Python integers are passed as the "
"platforms default C :c:expr:`int` type, their value is masked to fit into "
"the C type."
msgstr ""
"``None``, enteros, objetos de bytes y cadenas (unicode) son los únicos "
"objetos nativos de Python que se pueden usar directamente como parámetros en "
"estas llamadas a funciones. ``None`` se pasa como puntero C ``NULL``, "
"objetos de bytes y cadenas se pasan como puntero al bloque de memoria que "
"contiene sus datos (:c:expr:`char *` or :c:expr:`wchar_t *`). Los enteros de "
"Python se pasan como el tipo C :c:expr:`int` predeterminado de la "
"plataforma, su valor se enmascara para encajar en el tipo C."

#: ../Doc/library/ctypes.rst:206
msgid ""
"Before we move on calling functions with other parameter types, we have to "
"learn more about :mod:`ctypes` data types."
msgstr ""
"Antes de pasar a llamar funciones con otros tipos de parámetros, tenemos que "
"aprender más sobre los tipos de datos :mod:`ctypes`."

#: ../Doc/library/ctypes.rst:213 ../Doc/library/ctypes.rst:2201
msgid "Fundamental data types"
msgstr "Tipos de datos fundamentales"

#: ../Doc/library/ctypes.rst:215
msgid ":mod:`ctypes` defines a number of primitive C compatible data types:"
msgstr ""
":mod:`ctypes` define un número de tipos de datos primitivos compatibles con "
"C:"

#: ../Doc/library/ctypes.rst:218
msgid "ctypes type"
msgstr "tipo ctypes"

#: ../Doc/library/ctypes.rst:218
msgid "C type"
msgstr "Tipo C"

#: ../Doc/library/ctypes.rst:218
msgid "Python type"
msgstr "Tipo Python"

#: ../Doc/library/ctypes.rst:220
msgid ":class:`c_bool`"
msgstr ":class:`c_bool`"

#: ../Doc/library/ctypes.rst:220
msgid ":c:expr:`_Bool`"
msgstr ":c:expr:`_Bool`"

#: ../Doc/library/ctypes.rst:220
msgid "bool (1)"
msgstr "bool (1)"

#: ../Doc/library/ctypes.rst:222
msgid ":class:`c_char`"
msgstr ":class:`c_char`"

#: ../Doc/library/ctypes.rst:222 ../Doc/library/ctypes.rst:226
msgid ":c:expr:`char`"
msgstr ":c:expr:`char`"

#: ../Doc/library/ctypes.rst:222
msgid "1-character bytes object"
msgstr "Un objeto bytes de 1-caracter"

#: ../Doc/library/ctypes.rst:224
msgid ":class:`c_wchar`"
msgstr ":class:`c_wchar`"

#: ../Doc/library/ctypes.rst:224
#, fuzzy
msgid ":c:type:`wchar_t`"
msgstr ":c:expr:`wchar_t`"

#: ../Doc/library/ctypes.rst:224
msgid "1-character string"
msgstr "Una cadena de 1-caracter"

#: ../Doc/library/ctypes.rst:226
msgid ":class:`c_byte`"
msgstr ":class:`c_byte`"

#: ../Doc/library/ctypes.rst:226 ../Doc/library/ctypes.rst:228
#: ../Doc/library/ctypes.rst:230 ../Doc/library/ctypes.rst:232
#: ../Doc/library/ctypes.rst:234 ../Doc/library/ctypes.rst:236
#: ../Doc/library/ctypes.rst:238 ../Doc/library/ctypes.rst:240
#: ../Doc/library/ctypes.rst:242 ../Doc/library/ctypes.rst:244
#: ../Doc/library/ctypes.rst:247 ../Doc/library/ctypes.rst:249
#: ../Doc/library/ctypes.rst:252
msgid "int"
msgstr "entero"

#: ../Doc/library/ctypes.rst:228
msgid ":class:`c_ubyte`"
msgstr ":class:`c_ubyte`"

#: ../Doc/library/ctypes.rst:228
msgid ":c:expr:`unsigned char`"
msgstr ":c:expr:`unsigned char`"

#: ../Doc/library/ctypes.rst:230
msgid ":class:`c_short`"
msgstr ":class:`c_short`"

#: ../Doc/library/ctypes.rst:230
msgid ":c:expr:`short`"
msgstr ":c:expr:`short`"

#: ../Doc/library/ctypes.rst:232
msgid ":class:`c_ushort`"
msgstr ":class:`c_ushort`"

#: ../Doc/library/ctypes.rst:232
msgid ":c:expr:`unsigned short`"
msgstr ":c:expr:`unsigned short`"

#: ../Doc/library/ctypes.rst:234
msgid ":class:`c_int`"
msgstr ":class:`c_int`"

#: ../Doc/library/ctypes.rst:234
msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

#: ../Doc/library/ctypes.rst:236
msgid ":class:`c_uint`"
msgstr ":class:`c_uint`"

#: ../Doc/library/ctypes.rst:236
msgid ":c:expr:`unsigned int`"
msgstr ":c:expr:`unsigned int`"

#: ../Doc/library/ctypes.rst:238
msgid ":class:`c_long`"
msgstr ":class:`c_long`"

#: ../Doc/library/ctypes.rst:238
msgid ":c:expr:`long`"
msgstr ":c:expr:`long`"

#: ../Doc/library/ctypes.rst:240
msgid ":class:`c_ulong`"
msgstr ":class:`c_ulong`"

#: ../Doc/library/ctypes.rst:240
msgid ":c:expr:`unsigned long`"
msgstr ":c:expr:`unsigned long`"

#: ../Doc/library/ctypes.rst:242
msgid ":class:`c_longlong`"
msgstr ":class:`c_longlong`"

#: ../Doc/library/ctypes.rst:242
msgid ":c:expr:`__int64` or :c:expr:`long long`"
msgstr ":c:expr:`__int64` o :c:expr:`long long`"

#: ../Doc/library/ctypes.rst:244
msgid ":class:`c_ulonglong`"
msgstr ":class:`c_ulonglong`"

#: ../Doc/library/ctypes.rst:244
msgid ":c:expr:`unsigned __int64` or :c:expr:`unsigned long long`"
msgstr ":c:expr:`unsigned __int64` o :c:expr:`unsigned long long`"

#: ../Doc/library/ctypes.rst:247
msgid ":class:`c_size_t`"
msgstr ":class:`c_size_t`"

#: ../Doc/library/ctypes.rst:247
#, fuzzy
msgid ":c:type:`size_t`"
msgstr ":c:expr:`size_t`"

#: ../Doc/library/ctypes.rst:249
msgid ":class:`c_ssize_t`"
msgstr ":class:`c_ssize_t`"

#: ../Doc/library/ctypes.rst:249
#, fuzzy
msgid ":c:type:`ssize_t` or :c:expr:`Py_ssize_t`"
msgstr ":c:expr:`ssize_t` o :c:expr:`Py_ssize_t`"

#: ../Doc/library/ctypes.rst:252
#, fuzzy
msgid ":class:`c_time_t`"
msgstr ":class:`c_size_t`"

#: ../Doc/library/ctypes.rst:252
#, fuzzy
msgid ":c:type:`time_t`"
msgstr ":c:expr:`size_t`"

#: ../Doc/library/ctypes.rst:254
msgid ":class:`c_float`"
msgstr ":class:`c_float`"

#: ../Doc/library/ctypes.rst:254
msgid ":c:expr:`float`"
msgstr ":c:expr:`float`"

#: ../Doc/library/ctypes.rst:254 ../Doc/library/ctypes.rst:256
#: ../Doc/library/ctypes.rst:258
msgid "float"
msgstr "flotante"

#: ../Doc/library/ctypes.rst:256
msgid ":class:`c_double`"
msgstr ":class:`c_double`"

#: ../Doc/library/ctypes.rst:256
msgid ":c:expr:`double`"
msgstr ":c:expr:`double`"

#: ../Doc/library/ctypes.rst:258
msgid ":class:`c_longdouble`"
msgstr ":class:`c_longdouble`"

#: ../Doc/library/ctypes.rst:258
msgid ":c:expr:`long double`"
msgstr ":c:expr:`long double`"

#: ../Doc/library/ctypes.rst:260
msgid ":class:`c_char_p`"
msgstr ":class:`c_char_p`"

#: ../Doc/library/ctypes.rst:260
msgid ":c:expr:`char *` (NUL terminated)"
msgstr ":c:expr:`char *` (terminado en NUL)"

#: ../Doc/library/ctypes.rst:260
msgid "bytes object or ``None``"
msgstr "objeto de bytes o ``None``"

#: ../Doc/library/ctypes.rst:262
msgid ":class:`c_wchar_p`"
msgstr ":class:`c_wchar_p`"

#: ../Doc/library/ctypes.rst:262
msgid ":c:expr:`wchar_t *` (NUL terminated)"
msgstr ":c:expr:`wchar_t *` (terminado en NUL)"

#: ../Doc/library/ctypes.rst:262
msgid "string or ``None``"
msgstr "cadena o ``None``"

#: ../Doc/library/ctypes.rst:264
msgid ":class:`c_void_p`"
msgstr ":class:`c_void_p`"

#: ../Doc/library/ctypes.rst:264
msgid ":c:expr:`void *`"
msgstr ":c:expr:`void *`"

#: ../Doc/library/ctypes.rst:264
msgid "int or ``None``"
msgstr "entero o ``None``"

#: ../Doc/library/ctypes.rst:268
msgid "The constructor accepts any object with a truth value."
msgstr "El constructor acepta cualquier objeto con valor verdadero."

#: ../Doc/library/ctypes.rst:270
msgid ""
"All these types can be created by calling them with an optional initializer "
"of the correct type and value::"
msgstr ""
"Todos estos tipos pueden ser creados llamándolos con un inicializador "
"opcional del tipo y valor correctos::"

#: ../Doc/library/ctypes.rst:281
msgid ""
"Since these types are mutable, their value can also be changed afterwards::"
msgstr ""
"Dado que estos tipos son mutables, su valor también puede ser cambiado "
"después::"

#: ../Doc/library/ctypes.rst:293
msgid ""
"Assigning a new value to instances of the pointer types :class:`c_char_p`, :"
"class:`c_wchar_p`, and :class:`c_void_p` changes the *memory location* they "
"point to, *not the contents* of the memory block (of course not, because "
"Python bytes objects are immutable)::"
msgstr ""
"Asignando un nuevo valor a las instancias de los tipos de punteros :class:"
"`c_char_p`, :class:`c_wchar_p`, y :class:`c_void_p` cambia el *lugar de "
"memoria* al que apuntan, *no el contenido* del bloque de memoria (por "
"supuesto que no, porque los objetos de bytes de Python son inmutables)::"

#: ../Doc/library/ctypes.rst:313
msgid ""
"You should be careful, however, not to pass them to functions expecting "
"pointers to mutable memory. If you need mutable memory blocks, ctypes has a :"
"func:`create_string_buffer` function which creates these in various ways.  "
"The current memory block contents can be accessed (or changed) with the "
"``raw`` property; if you want to access it as NUL terminated string, use the "
"``value`` property::"
msgstr ""
"Sin embargo, debe tener cuidado de no pasarlos a funciones que esperan "
"punteros a la memoria mutable. Si necesitas bloques de memoria mutables, "
"ctypes tiene una función :func:`create_string_buffer` que los crea de varias "
"maneras. El contenido actual del bloque de memoria puede ser accedido (o "
"cambiado) con la propiedad ``raw``; si quieres acceder a él como cadena "
"terminada NUL, usa la propiedad ``value``::"

#: ../Doc/library/ctypes.rst:337
#, fuzzy
msgid ""
"The :func:`create_string_buffer` function replaces the old :func:`!c_buffer` "
"function (which is still available as an alias).  To create a mutable memory "
"block containing unicode characters of the C type :c:type:`wchar_t`, use "
"the :func:`create_unicode_buffer` function."
msgstr ""
"La función :func:`create_string_buffer` reemplaza la antigua función :func:"
"`c_buffer` (que todavía está disponible como alias). Para crear un bloque de "
"memoria mutable que contenga caracteres Unicode del tipo C :c:expr:"
"`wchar_t`, use la función :func:`create_unicode_buffer`."

#: ../Doc/library/ctypes.rst:346
msgid "Calling functions, continued"
msgstr "Funciones de llamada, continuación"

#: ../Doc/library/ctypes.rst:348
msgid ""
"Note that printf prints to the real standard output channel, *not* to :data:"
"`sys.stdout`, so these examples will only work at the console prompt, not "
"from within *IDLE* or *PythonWin*::"
msgstr ""
"Note que printf imprime al canal de salida estándar real, *no* a :data:`sys."
"stdout`, por lo que estos ejemplos sólo funcionarán en el prompt de la "
"consola, no desde dentro de *IDLE* o *PythonWin*::"

#: ../Doc/library/ctypes.rst:368
msgid ""
"As has been mentioned before, all Python types except integers, strings, and "
"bytes objects have to be wrapped in their corresponding :mod:`ctypes` type, "
"so that they can be converted to the required C data type::"
msgstr ""
"Como se ha mencionado antes, todos los tipos de Python, excepto los enteros, "
"cadenas y objetos bytes, tienen que ser envueltos en su correspondiente "
"tipo :mod:`ctypes`, para que puedan ser convertidos al tipo de datos C "
"requerido::"

#: ../Doc/library/ctypes.rst:380
#, fuzzy
msgid "Calling variadic functions"
msgstr "Funciones de llamada"

#: ../Doc/library/ctypes.rst:382
msgid ""
"On a lot of platforms calling variadic functions through ctypes is exactly "
"the same as calling functions with a fixed number of parameters. On some "
"platforms, and in particular ARM64 for Apple Platforms, the calling "
"convention for variadic functions is different than that for regular "
"functions."
msgstr ""

#: ../Doc/library/ctypes.rst:387
msgid ""
"On those platforms it is required to specify the :attr:`~_FuncPtr.argtypes` "
"attribute for the regular, non-variadic, function arguments:"
msgstr ""

#: ../Doc/library/ctypes.rst:394
msgid ""
"Because specifying the attribute does not inhibit portability it is advised "
"to always specify :attr:`~_FuncPtr.argtypes` for all variadic functions."
msgstr ""

#: ../Doc/library/ctypes.rst:401
msgid "Calling functions with your own custom data types"
msgstr "Funciones de llamada con sus propios tipos de datos personalizados"

#: ../Doc/library/ctypes.rst:403
#, fuzzy
msgid ""
"You can also customize :mod:`ctypes` argument conversion to allow instances "
"of your own classes be used as function arguments. :mod:`ctypes` looks for "
"an :attr:`!_as_parameter_` attribute and uses this as the function argument. "
"The attribute must be an integer, string, bytes, a :mod:`ctypes` instance, "
"or an object with an :attr:`!_as_parameter_` attribute::"
msgstr ""
"También puedes personalizar la conversión de argumentos de :mod:`ctypes` "
"para permitir que las instancias de tus propias clases se usen como "
"argumentos de función. :mod:`ctypes` busca un atributo :attr:"
"`_as_parameter_` y lo usa como argumento de función. Por supuesto, debe ser "
"uno de entero, cadena o bytes::"

#: ../Doc/library/ctypes.rst:419
#, fuzzy
msgid ""
"If you don't want to store the instance's data in the :attr:`!"
"_as_parameter_` instance variable, you could define a :class:`property` "
"which makes the attribute available on request."
msgstr ""
"Si no quieres almacenar los datos de la instancia en la variable de "
"instancia :attr:`_as_parameter_`, puedes definir una :class:`property` que "
"haga que el atributo esté disponible a petición."

#: ../Doc/library/ctypes.rst:427
msgid "Specifying the required argument types (function prototypes)"
msgstr ""
"Especificar los tipos de argumentos requeridos (prototipos de funciones)"

#: ../Doc/library/ctypes.rst:429
#, fuzzy
msgid ""
"It is possible to specify the required argument types of functions exported "
"from DLLs by setting the :attr:`~_FuncPtr.argtypes` attribute."
msgstr ""
"Es posible especificar los tipos de argumentos necesarios de las funciones "
"exportadas desde las DLL estableciendo el atributo :attr:`argtypes`."

#: ../Doc/library/ctypes.rst:432
#, fuzzy
msgid ""
":attr:`~_FuncPtr.argtypes` must be a sequence of C data types (the :func:`!"
"printf` function is probably not a good example here, because it takes a "
"variable number and different types of parameters depending on the format "
"string, on the other hand this is quite handy to experiment with this "
"feature)::"
msgstr ""
":attr:`argtypes` debe ser una secuencia de tipos de datos de C (la función "
"``printf`` probablemente no es un buen ejemplo aquí, porque toma un número "
"variable y diferentes tipos de parámetros dependiendo del formato de la "
"cadena, por otro lado esto es bastante útil para experimentar con esta "
"característica)::"

#: ../Doc/library/ctypes.rst:443
msgid ""
"Specifying a format protects against incompatible argument types (just as a "
"prototype for a C function), and tries to convert the arguments to valid "
"types::"
msgstr ""
"La especificación de un formato protege contra los tipos de argumentos "
"incompatibles (al igual que un prototipo para una función C), e intenta "
"convertir los argumentos en tipos válidos::"

#: ../Doc/library/ctypes.rst:455
#, fuzzy
msgid ""
"If you have defined your own classes which you pass to function calls, you "
"have to implement a :meth:`~_CData.from_param` class method for them to be "
"able to use them in the :attr:`~_FuncPtr.argtypes` sequence. The :meth:"
"`~_CData.from_param` class method receives the Python object passed to the "
"function call, it should do a typecheck or whatever is needed to make sure "
"this object is acceptable, and then return the object itself, its :attr:`!"
"_as_parameter_` attribute, or whatever you want to pass as the C function "
"argument in this case. Again, the result should be an integer, string, "
"bytes, a :mod:`ctypes` instance, or an object with an :attr:`!"
"_as_parameter_` attribute."
msgstr ""
"Si has definido tus propias clases las cuales pasas a las llamadas a "
"funciones, tienes que implementar un método de clase :meth:`from_param` para "
"que puedan ser usadas en la secuencia :attr:`argtypes`. El método de clase :"
"meth:`from_param` recibe el objeto Python que se le pasa a la llamada a "
"función, debería hacer una comprobación de tipo o lo que sea necesario para "
"asegurarse de que este objeto es aceptable, y luego retornar el objeto en "
"sí, su atributo :attr:`_as_parameter_`, o lo que se quiera pasar como "
"argumento de la función C en este caso. De nuevo, el resultado debe ser un "
"entero, una cadena, unos bytes, una instancia :mod:`ctypes`, o un objeto con "
"el atributo :attr:`_as_parameter_`."

#: ../Doc/library/ctypes.rst:469
msgid "Return types"
msgstr "Tipos de retorno"

#: ../Doc/library/ctypes.rst:479
#, fuzzy
msgid ""
"By default functions are assumed to return the C :c:expr:`int` type.  Other "
"return types can be specified by setting the :attr:`~_FuncPtr.restype` "
"attribute of the function object."
msgstr ""
"Por defecto, se supone que las funciones retornan el tipo C :c:expr:`int`. "
"Se pueden especificar otros tipos de retorno configurando el atributo :attr:"
"`restype` del objeto de función."

#: ../Doc/library/ctypes.rst:483
msgid ""
"The C prototype of :c:func:`time` is ``time_t time(time_t *)``. Because :c:"
"type:`time_t` might be of a different type than the default return type :c:"
"expr:`int`, you should specify the :attr:`!restype` attribute::"
msgstr ""

#: ../Doc/library/ctypes.rst:489
msgid "The argument types can be specified using :attr:`~_FuncPtr.argtypes`::"
msgstr ""

#: ../Doc/library/ctypes.rst:493
msgid ""
"To call the function with a ``NULL`` pointer as first argument, use "
"``None``::"
msgstr ""

#: ../Doc/library/ctypes.rst:498
#, fuzzy
msgid ""
"Here is a more advanced example, it uses the :func:`!strchr` function, which "
"expects a string pointer and a char, and returns a pointer to a string::"
msgstr ""
"Aquí hay un ejemplo más avanzado, utiliza la función ``strchr``, que espera "
"un puntero de cadena y un carácter, y retorna un puntero a una cadena::"

#: ../Doc/library/ctypes.rst:511
#, fuzzy
msgid ""
"If you want to avoid the :func:`ord(\"x\") <ord>` calls above, you can set "
"the :attr:`~_FuncPtr.argtypes` attribute, and the second argument will be "
"converted from a single character Python bytes object into a C char:"
msgstr ""
"Si quieres evitar las llamadas ``ord(\"x\")`` de arriba, puedes establecer "
"el atributo :attr:`argtypes`, y el segundo argumento se convertirá de un "
"objeto de un solo carácter de bytes de Python a un char::"

#: ../Doc/library/ctypes.rst:530
#, fuzzy
msgid ""
"You can also use a callable Python object (a function or a class for "
"example) as the :attr:`~_FuncPtr.restype` attribute, if the foreign function "
"returns an integer.  The callable will be called with the *integer* the C "
"function returns, and the result of this call will be used as the result of "
"your function call. This is useful to check for error return values and "
"automatically raise an exception::"
msgstr ""
"También puedes usar un objeto Python invocable (una función o una clase, por "
"ejemplo) como el atributo :attr:`restype`, si la función foránea retorna un "
"número entero. El objeto invocable será llamado con el *entero* que la "
"función C retorna, y el resultado de esta llamada será utilizado como "
"resultado de la llamada a la función. Esto es útil para comprobar si hay "
"valores de retorno de error y plantear automáticamente una excepción::"

#: ../Doc/library/ctypes.rst:553
msgid ""
"``WinError`` is a function which will call Windows ``FormatMessage()`` api "
"to get the string representation of an error code, and *returns* an "
"exception. ``WinError`` takes an optional error code parameter, if no one is "
"used, it calls :func:`GetLastError` to retrieve it."
msgstr ""
"``WinError`` es una función que llamará a la api Windows ``FormatMessage`` "
"para obtener la representación de la cadena de un código de error, y "
"retornará una excepción. ``WinError`` toma un parámetro de código de error "
"opcional, si no se usa ninguno, llama a :func:`GetLastError`` para "
"recuperarlo."

#: ../Doc/library/ctypes.rst:558
#, fuzzy
msgid ""
"Please note that a much more powerful error checking mechanism is available "
"through the :attr:`~_FuncPtr.errcheck` attribute; see the reference manual "
"for details."
msgstr ""
"Tenga en cuenta que un mecanismo de comprobación de errores mucho más "
"potente está disponible a través del atributo :attr:`errcheck`; consulte el "
"manual de referencia para obtener más detalles."

#: ../Doc/library/ctypes.rst:566
msgid "Passing pointers (or: passing parameters by reference)"
msgstr "Pasar los punteros (o: pasar los parámetros por referencia)"

#: ../Doc/library/ctypes.rst:568
msgid ""
"Sometimes a C api function expects a *pointer* to a data type as parameter, "
"probably to write into the corresponding location, or if the data is too "
"large to be passed by value. This is also known as *passing parameters by "
"reference*."
msgstr ""
"A veces una función api C espera un *puntero* a un tipo de datos como "
"parámetro, probablemente para escribir en el lugar correspondiente, o si los "
"datos son demasiado grandes para ser pasados por valor. Esto también se "
"conoce cómo *pasar parámetros por referencia*."

#: ../Doc/library/ctypes.rst:572
msgid ""
":mod:`ctypes` exports the :func:`byref` function which is used to pass "
"parameters by reference.  The same effect can be achieved with the :func:"
"`pointer` function, although :func:`pointer` does a lot more work since it "
"constructs a real pointer object, so it is faster to use :func:`byref` if "
"you don't need the pointer object in Python itself::"
msgstr ""
":mod:`ctypes` exporta la función :func:`byref` que se utiliza para pasar "
"parámetros por referencia. El mismo efecto se puede conseguir con la "
"función :func:`pointer`, aunque :func:`pointer` hace mucho más trabajo ya "
"que construye un objeto puntero real, por lo que es más rápido usar :func:"
"`byref` si no se necesita el objeto puntero en el propio Python::"

#: ../Doc/library/ctypes.rst:594
msgid "Structures and unions"
msgstr "Estructuras y uniones"

#: ../Doc/library/ctypes.rst:596
#, fuzzy
msgid ""
"Structures and unions must derive from the :class:`Structure` and :class:"
"`Union` base classes which are defined in the :mod:`ctypes` module. Each "
"subclass must define a :attr:`~Structure._fields_` attribute.  :attr:`!"
"_fields_` must be a list of *2-tuples*, containing a *field name* and a "
"*field type*."
msgstr ""
"Las estructuras y uniones deben derivar de las clases base :class:"
"`Structure` y :class:`Union` que se definen en el módulo :mod:`ctypes`. Cada "
"subclase debe definir un atributo :attr:`_fields_`. :attr:`_fields_` debe "
"ser una lista de *2-tuplas*, que contenga un *nombre de campo* y un *tipo de "
"campo*."

#: ../Doc/library/ctypes.rst:601
msgid ""
"The field type must be a :mod:`ctypes` type like :class:`c_int`, or any "
"other derived :mod:`ctypes` type: structure, union, array, pointer."
msgstr ""
"El tipo de campo debe ser un tipo :mod:`ctypes` como :class:`c_int`, o "
"cualquier otro tipo :mod:`ctypes` derivado: estructura, unión, matriz, "
"puntero."

#: ../Doc/library/ctypes.rst:604
msgid ""
"Here is a simple example of a POINT structure, which contains two integers "
"named *x* and *y*, and also shows how to initialize a structure in the "
"constructor::"
msgstr ""
"Aquí hay un ejemplo simple de una estructura POINT, que contiene dos enteros "
"llamados *x* y *y*, y también muestra cómo inicializar una estructura en el "
"constructor::"

#: ../Doc/library/ctypes.rst:624
msgid ""
"You can, however, build much more complicated structures.  A structure can "
"itself contain other structures by using a structure as a field type."
msgstr ""
"Sin embargo, se pueden construir estructuras mucho más complicadas. Una "
"estructura puede contener por sí misma otras estructuras usando una "
"estructura como tipo de campo."

#: ../Doc/library/ctypes.rst:627
msgid ""
"Here is a RECT structure which contains two POINTs named *upperleft* and "
"*lowerright*::"
msgstr ""
"Aquí hay una estructura RECT que contiene dos POINTs llamados *upperleft* "
"(superior izquierda)y *lowerright* (abajo a la derecha)::"

#: ../Doc/library/ctypes.rst:641
msgid ""
"Nested structures can also be initialized in the constructor in several "
"ways::"
msgstr ""
"Las estructuras anidadas también pueden ser inicializadas en el constructor "
"de varias maneras::"

#: ../Doc/library/ctypes.rst:646
msgid ""
"Field :term:`descriptor`\\s can be retrieved from the *class*, they are "
"useful for debugging because they can provide useful information::"
msgstr ""
"El campo :term:`descriptor` puede ser recuperado de la *class*, son útiles "
"para la depuración porque pueden proporcionar información útil::"

#: ../Doc/library/ctypes.rst:660
msgid ""
":mod:`ctypes` does not support passing unions or structures with bit-fields "
"to functions by value.  While this may work on 32-bit x86, it's not "
"guaranteed by the library to work in the general case.  Unions and "
"structures with bit-fields should always be passed to functions by pointer."
msgstr ""
":mod:`ctypes` no soporta el paso de uniones o estructuras con campos de bits "
"a funciones por valor. Aunque esto puede funcionar en 32-bit x86, la "
"biblioteca no garantiza que funcione en el caso general. Las uniones y "
"estructuras con campos de bits siempre deben pasarse a las funciones por "
"puntero."

#: ../Doc/library/ctypes.rst:666
msgid "Structure/union alignment and byte order"
msgstr "Alineación de estructura/unión y orden de bytes"

#: ../Doc/library/ctypes.rst:668
#, fuzzy
msgid ""
"By default, Structure and Union fields are aligned in the same way the C "
"compiler does it. It is possible to override this behavior by specifying a :"
"attr:`~Structure._pack_` class attribute in the subclass definition. This "
"must be set to a positive integer and specifies the maximum alignment for "
"the fields. This is what ``#pragma pack(n)`` also does in MSVC."
msgstr ""
"Por defecto, los campos de Estructura y Unión están alineados de la misma "
"manera que lo hace el compilador C. Es posible anular este comportamiento "
"especificando un atributo de clase :attr:`_pack_` en la definición de la "
"subclase. Este debe ser establecido como un entero positivo y especifica la "
"alineación máxima de los campos. Esto es lo que ``#pragma pack(n)`` también "
"hace en MSVC."

#: ../Doc/library/ctypes.rst:674
msgid ""
":mod:`ctypes` uses the native byte order for Structures and Unions.  To "
"build structures with non-native byte order, you can use one of the :class:"
"`BigEndianStructure`, :class:`LittleEndianStructure`, :class:"
"`BigEndianUnion`, and :class:`LittleEndianUnion` base classes.  These "
"classes cannot contain pointer fields."
msgstr ""
":mod:`ctypes` utiliza el orden de bytes nativos para las Estructuras y "
"Uniones. Para construir estructuras con un orden de bytes no nativo, puedes "
"usar una de las clases base :class:`BigEndianStructure`, :class:"
"`LittleEndianStructure`, :class:`BigEndianUnion`, y :class:"
"`LittleEndianUnion`. Estas clases no pueden contener campos puntero."

#: ../Doc/library/ctypes.rst:684
msgid "Bit fields in structures and unions"
msgstr "Campos de bits en estructuras y uniones"

#: ../Doc/library/ctypes.rst:686
#, fuzzy
msgid ""
"It is possible to create structures and unions containing bit fields. Bit "
"fields are only possible for integer fields, the bit width is specified as "
"the third item in the :attr:`~Structure._fields_` tuples::"
msgstr ""
"Es posible crear estructuras y uniones que contengan campos de bits. Los "
"campos de bits sólo son posibles para campos enteros, el ancho de bit se "
"especifica como el tercer ítem en las tuplas :attr:`_fields_`::"

#: ../Doc/library/ctypes.rst:704
msgid "Arrays"
msgstr "Arreglos"

#: ../Doc/library/ctypes.rst:706
msgid ""
"Arrays are sequences, containing a fixed number of instances of the same "
"type."
msgstr ""
"Los arreglos son secuencias, que contienen un número fijo de instancias del "
"mismo tipo."

#: ../Doc/library/ctypes.rst:708
msgid ""
"The recommended way to create array types is by multiplying a data type with "
"a positive integer::"
msgstr ""
"La forma recomendada de crear tipos de arreglos es multiplicando un tipo de "
"dato por un entero positivo::"

#: ../Doc/library/ctypes.rst:713
msgid ""
"Here is an example of a somewhat artificial data type, a structure "
"containing 4 POINTs among other stuff::"
msgstr ""
"Aquí hay un ejemplo de un tipo de datos algo artificial, una estructura que "
"contiene 4 POINTs entre otras cosas::"

#: ../Doc/library/ctypes.rst:729
msgid "Instances are created in the usual way, by calling the class::"
msgstr "Las instancias se crean de la manera habitual, llamando a la clase::"

#: ../Doc/library/ctypes.rst:735
msgid ""
"The above code print a series of ``0 0`` lines, because the array contents "
"is initialized to zeros."
msgstr ""
"El código anterior imprime una serie de líneas ``0 0``, porque el contenido "
"del arreglos se inicializa con ceros."

#: ../Doc/library/ctypes.rst:738
msgid "Initializers of the correct type can also be specified::"
msgstr "También se pueden especificar inicializadores del tipo correcto::"

#: ../Doc/library/ctypes.rst:754
msgid "Pointers"
msgstr "Punteros"

#: ../Doc/library/ctypes.rst:756
msgid ""
"Pointer instances are created by calling the :func:`pointer` function on a :"
"mod:`ctypes` type::"
msgstr ""
"Las instancias de puntero se crean llamando a la función :func:`pointer` en "
"un tipo :mod:`ctypes`::"

#: ../Doc/library/ctypes.rst:764
msgid ""
"Pointer instances have a :attr:`~_Pointer.contents` attribute which returns "
"the object to which the pointer points, the ``i`` object above::"
msgstr ""
"Las instancias del puntero tienen un atributo :attr:`~_Pointer.contents` que "
"retorna el objeto al que apunta el puntero, el objeto ``i`` arriba::"

#: ../Doc/library/ctypes.rst:771
msgid ""
"Note that :mod:`ctypes` does not have OOR (original object return), it "
"constructs a new, equivalent object each time you retrieve an attribute::"
msgstr ""
"Ten en cuenta que :mod:`ctypes` no tiene OOR (original object return), "
"construye un nuevo objeto equivalente cada vez que recuperas un atributo::"

#: ../Doc/library/ctypes.rst:780
msgid ""
"Assigning another :class:`c_int` instance to the pointer's contents "
"attribute would cause the pointer to point to the memory location where this "
"is stored::"
msgstr ""
"Asignar otra instancia :class:`c_int` al atributo de contenido del puntero "
"causaría que el puntero apunte al lugar de memoria donde se almacena::"

#: ../Doc/library/ctypes.rst:792
msgid "Pointer instances can also be indexed with integers::"
msgstr ""
"Las instancias de puntero también pueden ser indexadas con números enteros::"

#: ../Doc/library/ctypes.rst:798
msgid "Assigning to an integer index changes the pointed to value::"
msgstr "Asignando a un índice entero cambia el valor señalado::"

#: ../Doc/library/ctypes.rst:807
msgid ""
"It is also possible to use indexes different from 0, but you must know what "
"you're doing, just as in C: You can access or change arbitrary memory "
"locations. Generally you only use this feature if you receive a pointer from "
"a C function, and you *know* that the pointer actually points to an array "
"instead of a single item."
msgstr ""
"También es posible usar índices diferentes de 0, pero debes saber lo que "
"estás haciendo, al igual que en C: Puedes acceder o cambiar arbitrariamente "
"las ubicaciones de memoria. Generalmente sólo usas esta característica si "
"recibes un puntero de una función C, y *sabes* que el puntero en realidad "
"apunta a un arreglo en lugar de a un solo elemento."

#: ../Doc/library/ctypes.rst:813
msgid ""
"Behind the scenes, the :func:`pointer` function does more than simply create "
"pointer instances, it has to create pointer *types* first. This is done with "
"the :func:`POINTER` function, which accepts any :mod:`ctypes` type, and "
"returns a new type::"
msgstr ""
"Entre bastidores, la función :func:`pointer` hace más que simplemente crear "
"instancias de puntero, tiene que crear primero punteros *tipos*. Esto se "
"hace con la función :func:`POINTER`, que acepta cualquier tipo de :mod:"
"`ctypes`, y retorna un nuevo tipo::"

#: ../Doc/library/ctypes.rst:829
msgid ""
"Calling the pointer type without an argument creates a ``NULL`` pointer. "
"``NULL`` pointers have a ``False`` boolean value::"
msgstr ""
"Llamar al tipo de puntero sin un argumento crea un puntero ``NULL``. Los "
"punteros ``NULL`` tienen un valor booleano falso..:"

#: ../Doc/library/ctypes.rst:837
msgid ""
":mod:`ctypes` checks for ``NULL`` when dereferencing pointers (but "
"dereferencing invalid non-\\ ``NULL`` pointers would crash Python)::"
msgstr ""
":mod:`ctypes` comprueba si hay ``NULL`` cuando los punteros de referencia "
"(pero los punteros no válidos de referencia no-\\ ``NULL`` se romperán en "
"Python)::"

#: ../Doc/library/ctypes.rst:856
msgid "Type conversions"
msgstr "Conversiones de tipos"

#: ../Doc/library/ctypes.rst:858
#, fuzzy
msgid ""
"Usually, ctypes does strict type checking.  This means, if you have "
"``POINTER(c_int)`` in the :attr:`~_FuncPtr.argtypes` list of a function or "
"as the type of a member field in a structure definition, only instances of "
"exactly the same type are accepted.  There are some exceptions to this rule, "
"where ctypes accepts other objects.  For example, you can pass compatible "
"array instances instead of pointer types.  So, for ``POINTER(c_int)``, "
"ctypes accepts an array of c_int::"
msgstr ""
"Por lo general, los ctypes hacen un control estricto de los tipos. Esto "
"significa que si tienes ``POINTER(c_int)`` en la lista :attr:`argtypes` de "
"una función o como el tipo de un campo miembro en una definición de "
"estructura, sólo se aceptan instancias exactamente del mismo tipo. Hay "
"algunas excepciones a esta regla, en las que ctypes acepta otros objetos. "
"Por ejemplo, se pueden pasar instancias de arreglo compatibles en lugar de "
"tipos de puntero. Así, para ``POINTER(c_int)``, ctypes acepta un arreglo de "
"*c_int*::"

#: ../Doc/library/ctypes.rst:879
#, fuzzy
msgid ""
"In addition, if a function argument is explicitly declared to be a pointer "
"type (such as ``POINTER(c_int)``) in :attr:`~_FuncPtr.argtypes`, an object "
"of the pointed type (``c_int`` in this case) can be passed to the function.  "
"ctypes will apply the required :func:`byref` conversion in this case "
"automatically."
msgstr ""
"Además, si se declara explícitamente que un argumento de función es de tipo "
"puntero (como ``POINTER(c_int)``) en :attr:`argtypes`, se puede pasar un "
"objeto de tipo puntero (``c_int`` en este caso) a la función. ctypes "
"aplicará la conversión :func:`byref` requerida en este caso automáticamente."

#: ../Doc/library/ctypes.rst:884
msgid "To set a POINTER type field to ``NULL``, you can assign ``None``::"
msgstr ""
"Para poner un campo de tipo POINTER a ``NULL``, puedes asignar ``None``::"

#: ../Doc/library/ctypes.rst:891
msgid ""
"Sometimes you have instances of incompatible types.  In C, you can cast one "
"type into another type.  :mod:`ctypes` provides a :func:`cast` function "
"which can be used in the same way.  The ``Bar`` structure defined above "
"accepts ``POINTER(c_int)`` pointers or :class:`c_int` arrays for its "
"``values`` field, but not instances of other types::"
msgstr ""
"A veces se tienen instancias de tipos incompatibles. En C, puedes cambiar un "
"tipo por otro tipo. :mod:`ctypes` proporciona una función :func:`cast` qué "
"puede ser usada de la misma manera. La estructura ``Bar`` definida arriba "
"acepta punteros ``POINTER(c_int)`` o arreglos :class:`c_int`` para su campo "
"``values``, pero no instancias de otros tipos::"

#: ../Doc/library/ctypes.rst:903
msgid "For these cases, the :func:`cast` function is handy."
msgstr "Para estos casos, la función :func:`cast` es muy útil."

#: ../Doc/library/ctypes.rst:905
msgid ""
"The :func:`cast` function can be used to cast a ctypes instance into a "
"pointer to a different ctypes data type.  :func:`cast` takes two parameters, "
"a ctypes object that is or can be converted to a pointer of some kind, and a "
"ctypes pointer type.  It returns an instance of the second argument, which "
"references the same memory block as the first argument::"
msgstr ""
"La función :func:`cast` puede ser usada para lanzar una instancia ctypes en "
"un puntero a un tipo de datos ctypes diferente. :func:`cast` toma dos "
"parámetros, un objeto ctypes que es o puede ser convertido en un puntero de "
"algún tipo, y un tipo de puntero ctypes. retorna una instancia del segundo "
"argumento, que hace referencia al mismo bloque de memoria que el primer "
"argumento::"

#: ../Doc/library/ctypes.rst:916
msgid ""
"So, :func:`cast` can be used to assign to the ``values`` field of ``Bar`` "
"the structure::"
msgstr ""
"Así, :func:`cast` puede ser usado para asignar al campo ``values`` de "
"``Bar`` la estructura::"

#: ../Doc/library/ctypes.rst:929
msgid "Incomplete Types"
msgstr "Tipos incompletos"

#: ../Doc/library/ctypes.rst:931
msgid ""
"*Incomplete Types* are structures, unions or arrays whose members are not "
"yet specified. In C, they are specified by forward declarations, which are "
"defined later::"
msgstr ""
"*Los Tipos Incompletos* son estructuras, uniones o matrices cuyos miembros "
"aún no están especificados. En C, se especifican mediante declaraciones a "
"futuro, que se definen más adelante::"

#: ../Doc/library/ctypes.rst:942
msgid ""
"The straightforward translation into ctypes code would be this, but it does "
"not work::"
msgstr ""
"La traducción directa al código de ctypes sería esta, pero no funciona::"

#: ../Doc/library/ctypes.rst:955
#, fuzzy
msgid ""
"because the new ``class cell`` is not available in the class statement "
"itself. In :mod:`ctypes`, we can define the ``cell`` class and set the :attr:"
"`~Structure._fields_` attribute later, after the class statement::"
msgstr ""
"porque la nueva ``class cell`` no está disponible en la propia declaración "
"de clase. En :mod:`ctypes`, podemos definir la clase ``cell`` y establecer "
"el atributo :attr:`_fields_` más tarde, después de la declaración de clase::"

#: ../Doc/library/ctypes.rst:967
msgid ""
"Let's try it. We create two instances of ``cell``, and let them point to "
"each other, and finally follow the pointer chain a few times::"
msgstr ""
"Vamos a intentarlo. Creamos dos instancias de ``cell``, y dejamos que se "
"apunten una a la otra, y finalmente seguimos la cadena de punteros unas "
"cuantas veces::"

#: ../Doc/library/ctypes.rst:988
msgid "Callback functions"
msgstr "Funciones de retrollamadas (*callback*)"

#: ../Doc/library/ctypes.rst:990
msgid ""
":mod:`ctypes` allows creating C callable function pointers from Python "
"callables. These are sometimes called *callback functions*."
msgstr ""
":mod:`ctypes` permite crear punteros de función invocables C a partir de los "
"invocables de Python. A veces se llaman *funciones de retrollamada*."

#: ../Doc/library/ctypes.rst:993
msgid ""
"First, you must create a class for the callback function. The class knows "
"the calling convention, the return type, and the number and types of "
"arguments this function will receive."
msgstr ""
"Primero, debes crear una clase para la función de retrollamada. La clase "
"conoce la convención de llamada, el tipo de retorno, y el número y tipos de "
"argumentos que esta función recibirá."

#: ../Doc/library/ctypes.rst:997
msgid ""
"The :func:`CFUNCTYPE` factory function creates types for callback functions "
"using the ``cdecl`` calling convention. On Windows, the :func:`WINFUNCTYPE` "
"factory function creates types for callback functions using the ``stdcall`` "
"calling convention."
msgstr ""
"La función de fábrica :func:`CFUNCTYPE`` crea tipos para las funciones de "
"retrollamada usando la convención de llamada ``cdecl``. En Windows, la "
"función de fábrica :func:`WINFUNCTYPE` crea tipos para funciones de "
"retrollamadas usando la convención de llamadas ``stdcall``."

#: ../Doc/library/ctypes.rst:1002
msgid ""
"Both of these factory functions are called with the result type as first "
"argument, and the callback functions expected argument types as the "
"remaining arguments."
msgstr ""
"Ambas funciones de fábrica se llaman con el tipo de resultado como primer "
"argumento, y las funciones de llamada de retorno con los tipos de argumentos "
"esperados como los argumentos restantes."

#: ../Doc/library/ctypes.rst:1006
#, fuzzy
msgid ""
"I will present an example here which uses the standard C library's :c:func:`!"
"qsort` function, that is used to sort items with the help of a callback "
"function.  :c:func:`!qsort` will be used to sort an array of integers::"
msgstr ""
"Presentaré un ejemplo aquí que utiliza la función :c:func:`qsort` de la "
"biblioteca estándar de C, que se utiliza para ordenar los elementos con la "
"ayuda de una función de retrollamada. :c:func:`qsort` se utilizará para "
"ordenar un conjunto de números enteros::"

#: ../Doc/library/ctypes.rst:1016
#, fuzzy
msgid ""
":func:`!qsort` must be called with a pointer to the data to sort, the number "
"of items in the data array, the size of one item, and a pointer to the "
"comparison function, the callback. The callback will then be called with two "
"pointers to items, and it must return a negative integer if the first item "
"is smaller than the second, a zero if they are equal, and a positive integer "
"otherwise."
msgstr ""
":func:`qsort` debe ser llamada con un puntero a los datos a ordenar, el "
"número de elementos en el array de datos, el tamaño de un elemento, y un "
"puntero a la función de comparación, la llamada de retorno. La llamada de "
"retorno se llamará entonces con dos punteros a los ítems, y debe retornar un "
"entero negativo si el primer ítem es más pequeño que el segundo, un cero si "
"son iguales, y un entero positivo en caso contrario."

#: ../Doc/library/ctypes.rst:1022
msgid ""
"So our callback function receives pointers to integers, and must return an "
"integer. First we create the ``type`` for the callback function::"
msgstr ""
"Así que nuestra función de retrollamada recibe punteros a números enteros, y "
"debe retornar un número entero. Primero creamos el ``tipo`` para la función "
"de retrollamada:"

#: ../Doc/library/ctypes.rst:1028
msgid ""
"To get started, here is a simple callback that shows the values it gets "
"passed::"
msgstr ""
"Para empezar, aquí hay una simple llamada que muestra los valores que se "
"pasan::"

#: ../Doc/library/ctypes.rst:1038
msgid "The result::"
msgstr "El resultado::"

#: ../Doc/library/ctypes.rst:1048
msgid "Now we can actually compare the two items and return a useful result::"
msgstr "Ahora podemos comparar los dos artículos y obtener un resultado útil::"

#: ../Doc/library/ctypes.rst:1063
msgid "As we can easily check, our array is sorted now::"
msgstr ""
"Como podemos comprobar fácilmente, nuestro arreglo está ordenado ahora::"

#: ../Doc/library/ctypes.rst:1070
msgid ""
"The function factories can be used as decorator factories, so we may as well "
"write::"
msgstr ""
"Las funciones de fabrica pueden ser usadas como decoradores de fabrica, así "
"que podemos escribir::"

#: ../Doc/library/ctypes.rst:1088
msgid ""
"Make sure you keep references to :func:`CFUNCTYPE` objects as long as they "
"are used from C code. :mod:`ctypes` doesn't, and if you don't, they may be "
"garbage collected, crashing your program when a callback is made."
msgstr ""
"Asegúrate de mantener las referencias a los objetos :func:`CFUNCTYPE` "
"mientras se usen desde el código C. :mod:`ctypes` no lo hace, y si no lo "
"haces, pueden ser basura recolectada, colapsando tu programa cuando se hace "
"una llamada."

#: ../Doc/library/ctypes.rst:1092
msgid ""
"Also, note that if the callback function is called in a thread created "
"outside of Python's control (e.g. by the foreign code that calls the "
"callback), ctypes creates a new dummy Python thread on every invocation. "
"This behavior is correct for most purposes, but it means that values stored "
"with :class:`threading.local` will *not* survive across different callbacks, "
"even when those calls are made from the same C thread."
msgstr ""
"Además, nótese que sí se llama a la función de retrollamada en un hilo "
"creado fuera del control de Python (por ejemplo, por el código foráneo que "
"llama a la retrollamada), ctypes crea un nuevo hilo Python tonto en cada "
"invocación. Este comportamiento es correcto para la mayoría de los "
"propósitos, pero significa que los valores almacenados con :class:`threading."
"local` *no* sobreviven a través de diferentes llamadas de retorno, incluso "
"cuando esas llamadas se hacen desde el mismo hilo C."

#: ../Doc/library/ctypes.rst:1102
msgid "Accessing values exported from dlls"
msgstr "Acceder a los valores exportados de los dlls"

#: ../Doc/library/ctypes.rst:1104
#, fuzzy
msgid ""
"Some shared libraries not only export functions, they also export variables. "
"An example in the Python library itself is the :c:data:`Py_Version`, Python "
"runtime version number encoded in a single constant integer."
msgstr ""
"Algunas bibliotecas compartidas no sólo exportan funciones, sino también "
"variables. Un ejemplo en la propia biblioteca de Python es el :c:data:"
"`Py_OptimizeFlag`, un entero establecido en 0, 1, o 2, dependiendo del flag :"
"option:`-O` o :option:`-OO` dado en el inicio."

#: ../Doc/library/ctypes.rst:1108
#, fuzzy
msgid ""
":mod:`ctypes` can access values like this with the :meth:`~_CData.in_dll` "
"class methods of the type.  *pythonapi* is a predefined symbol giving access "
"to the Python C api::"
msgstr ""
":mod:`ctypes` puede acceder a valores como este con los métodos de la clase :"
"meth:`in_dll` del tipo. *pythonapi* es un símbolo predefinido que da acceso "
"a la API de Python C::"

#: ../Doc/library/ctypes.rst:1116
msgid ""
"If the interpreter would have been started with :option:`-O`, the sample "
"would have printed ``c_long(1)``, or ``c_long(2)`` if :option:`-OO` would "
"have been specified."
msgstr ""
"Si el intérprete se hubiera iniciado con :option:`-O`, el ejemplo habría "
"impreso ``c_long(1)``, o ``c_long(2)`` si :option:`-OO` se hubiera "
"especificado."

#: ../Doc/library/ctypes.rst:1120
msgid ""
"An extended example which also demonstrates the use of pointers accesses "
"the :c:data:`PyImport_FrozenModules` pointer exported by Python."
msgstr ""
"Un ejemplo extendido que también demuestra el uso de punteros accediendo al "
"puntero :c:data:`PyImport_FrozenModules` exportado por Python."

#: ../Doc/library/ctypes.rst:1123
msgid "Quoting the docs for that value:"
msgstr "Citando los documentos para ese valor:"

#: ../Doc/library/ctypes.rst:1125
msgid ""
"This pointer is initialized to point to an array of :c:struct:`_frozen` "
"records, terminated by one whose members are all ``NULL`` or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""
"Este puntero se inicializa para apuntar a un arreglo de registros :c:struct:"
"`_frozen`, terminados por uno cuyos miembros son todos ``NULL`` o cero. "
"Cuando se importa un módulo congelado, se busca en esta tabla. El código de "
"terceros podría jugar trucos con esto para proporcionar una colección de "
"módulos congelados creada dinámicamente."

#: ../Doc/library/ctypes.rst:1130
msgid ""
"So manipulating this pointer could even prove useful. To restrict the "
"example size, we show only how this table can be read with :mod:`ctypes`::"
msgstr ""
"Así que manipular este puntero podría incluso resultar útil. Para restringir "
"el tamaño del ejemplo, sólo mostramos cómo esta tabla puede ser leída con :"
"mod:`ctypes`::"

#: ../Doc/library/ctypes.rst:1144
msgid ""
"We have defined the :c:struct:`_frozen` data type, so we can get the pointer "
"to the table::"
msgstr ""
"Hemos definido el tipo de datos :c:struct:`_frozen`, por lo que podemos "
"obtener el puntero a la tabla::"

#: ../Doc/library/ctypes.rst:1151
msgid ""
"Since ``table`` is a ``pointer`` to the array of ``struct_frozen`` records, "
"we can iterate over it, but we just have to make sure that our loop "
"terminates, because pointers have no size. Sooner or later it would probably "
"crash with an access violation or whatever, so it's better to break out of "
"the loop when we hit the ``NULL`` entry::"
msgstr ""
"Como ``tabla`` es un ``puntero`` al arreglo de registros ``struct_frozen``, "
"podemos iterar sobre ella, pero sólo tenemos que asegurarnos de que nuestro "
"bucle termine, porque los punteros no tienen tamaño. Tarde o temprano, "
"probablemente se caerá con una violación de acceso o lo que sea, así que es "
"mejor salir del bucle cuando le demos a la entrada ``NULL``::"

#: ../Doc/library/ctypes.rst:1167
msgid ""
"The fact that standard Python has a frozen module and a frozen package "
"(indicated by the negative ``size`` member) is not well known, it is only "
"used for testing. Try it out with ``import __hello__`` for example."
msgstr ""
"El hecho de que la Python estándar tenga un módulo congelado y un paquete "
"congelado (indicado por el miembro ``tamaño`` negativo) no se conoce bien, "
"sólo se usa para hacer pruebas. Pruébalo con ``import __hello__`` por "
"ejemplo."

#: ../Doc/library/ctypes.rst:1175
msgid "Surprises"
msgstr "Sorpresas"

#: ../Doc/library/ctypes.rst:1177
msgid ""
"There are some edges in :mod:`ctypes` where you might expect something other "
"than what actually happens."
msgstr ""
"Hay algunas aristas en :mod:`ctypes` en las que podrías esperar algo "
"distinto de lo que realmente sucede."

#: ../Doc/library/ctypes.rst:1180
msgid "Consider the following example::"
msgstr "Considere el siguiente ejemplo::"

#: ../Doc/library/ctypes.rst:1200
msgid ""
"Hm. We certainly expected the last statement to print ``3 4 1 2``. What "
"happened? Here are the steps of the ``rc.a, rc.b = rc.b, rc.a`` line above::"
msgstr ""
"Hm. Ciertamente esperábamos que la última declaración imprimiera ``3 4 1 "
"2``. ¿Qué ha pasado? Aquí están los pasos de la línea ``rc.a, rc.b = rc.b, "
"rc.a`` arriba::"

#: ../Doc/library/ctypes.rst:1208
msgid ""
"Note that ``temp0`` and ``temp1`` are objects still using the internal "
"buffer of the ``rc`` object above. So executing ``rc.a = temp0`` copies the "
"buffer contents of ``temp0`` into ``rc`` 's buffer.  This, in turn, changes "
"the contents of ``temp1``. So, the last assignment ``rc.b = temp1``, doesn't "
"have the expected effect."
msgstr ""
"Note que ``temp0`` y ``temp1`` son objetos que todavía usan el buffer "
"interno del objeto ``rc`` de arriba. Así que ejecutando ``rc.a = temp0`` "
"copia el contenido del buffer de ``temp0`` en el buffer de ``rc``. Esto, a "
"su vez, cambia el contenido de ``temp1``. Por lo tanto, la última asignación "
"``rc.b = temp1``, no tiene el efecto esperado."

#: ../Doc/library/ctypes.rst:1214
msgid ""
"Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays "
"doesn't *copy* the sub-object, instead it retrieves a wrapper object "
"accessing the root-object's underlying buffer."
msgstr ""
"Tengan en cuenta que la recuperación de subobjetos de Estructuras, Uniones y "
"Arreglos no *copia* el subobjeto, sino que recupera un objeto contenido que "
"accede al búfer subyacente del objeto raíz."

#: ../Doc/library/ctypes.rst:1218
msgid ""
"Another example that may behave differently from what one would expect is "
"this::"
msgstr ""
"Otro ejemplo que puede comportarse de manera diferente a lo que uno "
"esperaría es este::"

#: ../Doc/library/ctypes.rst:1230
msgid ""
"Objects instantiated from :class:`c_char_p` can only have their value set to "
"bytes or integers."
msgstr ""
"Los objetos instanciados desde :class:`c_char_p` sólo pueden tener su valor "
"fijado en bytes o enteros."

#: ../Doc/library/ctypes.rst:1233
msgid ""
"Why is it printing ``False``?  ctypes instances are objects containing a "
"memory block plus some :term:`descriptor`\\s accessing the contents of the "
"memory. Storing a Python object in the memory block does not store the "
"object itself, instead the ``contents`` of the object is stored.  Accessing "
"the contents again constructs a new Python object each time!"
msgstr ""
"¿Por qué está imprimiendo ``False``? Las instancias ctypes son objetos que "
"contienen un bloque de memoria más algunos :term:`descriptor`\\s que acceden "
"al contenido de la memoria. Almacenar un objeto Python en el bloque de "
"memoria no almacena el objeto en sí mismo, en su lugar se almacenan los "
"``contenidos`` del objeto. ¡Acceder a los contenidos de nuevo construye un "
"nuevo objeto Python cada vez!"

#: ../Doc/library/ctypes.rst:1243
msgid "Variable-sized data types"
msgstr "Tipos de datos de tamaño variable"

#: ../Doc/library/ctypes.rst:1245
msgid ""
":mod:`ctypes` provides some support for variable-sized arrays and structures."
msgstr ""
":mod:`ctypes` proporciona algo de soporte para matrices y estructuras de "
"tamaño variable."

#: ../Doc/library/ctypes.rst:1247
msgid ""
"The :func:`resize` function can be used to resize the memory buffer of an "
"existing ctypes object.  The function takes the object as first argument, "
"and the requested size in bytes as the second argument.  The memory block "
"cannot be made smaller than the natural memory block specified by the "
"objects type, a :exc:`ValueError` is raised if this is tried::"
msgstr ""
"La función :func:`resize` puede ser usada para redimensionar el buffer de "
"memoria de un objeto ctypes existente. La función toma el objeto como primer "
"argumento, y el tamaño solicitado en bytes como segundo argumento. El bloque "
"de memoria no puede hacerse más pequeño que el bloque de memoria natural "
"especificado por el tipo de objeto, se lanza un :exc:`ValueError` si se "
"intenta::"

#: ../Doc/library/ctypes.rst:1267
msgid ""
"This is nice and fine, but how would one access the additional elements "
"contained in this array?  Since the type still only knows about 4 elements, "
"we get errors accessing other elements::"
msgstr ""
"Esto está bien, pero ¿cómo se puede acceder a los elementos adicionales "
"contenidos en este arreglo?  Dado que el tipo todavía sabe sólo 4 elementos, "
"obtenemos errores al acceder a otros elementos::"

#: ../Doc/library/ctypes.rst:1279
msgid ""
"Another way to use variable-sized data types with :mod:`ctypes` is to use "
"the dynamic nature of Python, and (re-)define the data type after the "
"required size is already known, on a case by case basis."
msgstr ""
"Otra forma de utilizar tipos de datos de tamaño variable con :mod:`ctypes` "
"es utilizar la naturaleza dinámica de Python, y (re)definir el tipo de datos "
"después de que se conozca el tamaño requerido, caso por caso."

#: ../Doc/library/ctypes.rst:1287
msgid "ctypes reference"
msgstr "referencia ctypes"

#: ../Doc/library/ctypes.rst:1293
msgid "Finding shared libraries"
msgstr "Encontrar bibliotecas compartidas"

#: ../Doc/library/ctypes.rst:1295
msgid ""
"When programming in a compiled language, shared libraries are accessed when "
"compiling/linking a program, and when the program is run."
msgstr ""
"Cuando se programa en un lenguaje compilado, se accede a las bibliotecas "
"compartidas cuando se compila/enlaza un programa, y cuándo se ejecuta el "
"programa."

#: ../Doc/library/ctypes.rst:1298
#, fuzzy
msgid ""
"The purpose of the :func:`~ctypes.util.find_library` function is to locate a "
"library in a way similar to what the compiler or runtime loader does (on "
"platforms with several versions of a shared library the most recent should "
"be loaded), while the ctypes library loaders act like when a program is run, "
"and call the runtime loader directly."
msgstr ""
"El propósito de la función :func:`find_library` es localizar una biblioteca "
"de forma similar a lo que hace el compilador o el cargador en tiempo de "
"ejecución (en plataformas con varias versiones de una biblioteca compartida "
"se debería cargar la más reciente), mientras que los cargadores de "
"bibliotecas ctypes actúan como cuando se ejecuta un programa, y llaman "
"directamente al cargador en tiempo de ejecución."

#: ../Doc/library/ctypes.rst:1304
#, fuzzy
msgid ""
"The :mod:`!ctypes.util` module provides a function which can help to "
"determine the library to load."
msgstr ""
"El módulo :mod:`ctypes.util` proporciona una función que puede ayudar a "
"determinar la biblioteca a cargar."

#: ../Doc/library/ctypes.rst:1312
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like *lib*, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"Intenta encontrar una biblioteca y retornar un nombre. *name* es el nombre "
"de la biblioteca sin ningún prefijo como *lib*, sufijo como ``.so``, ``."
"dylib`` o número de versión (esta es la forma usada para la opción del "
"enlazador posix :option:`!-l`). Si no se puede encontrar ninguna biblioteca, "
"retorna ``None``."

#: ../Doc/library/ctypes.rst:1317 ../Doc/library/ctypes.rst:1976
msgid "The exact functionality is system dependent."
msgstr "La funcionalidad exacta depende del sistema."

#: ../Doc/library/ctypes.rst:1319
#, fuzzy
msgid ""
"On Linux, :func:`~ctypes.util.find_library` tries to run external programs "
"(``/sbin/ldconfig``, ``gcc``, ``objdump`` and ``ld``) to find the library "
"file. It returns the filename of the library file."
msgstr ""
"En Linux, :func:`find_library` intenta ejecutar programas externos (``/sbin/"
"ldconfig``, ``gcc``, ``objdump`` y ``ld``) para encontrar el archivo de la "
"biblioteca. retorna el nombre del archivo de la biblioteca."

#: ../Doc/library/ctypes.rst:1323
msgid ""
"On Linux, the value of the environment variable ``LD_LIBRARY_PATH`` is used "
"when searching for libraries, if a library cannot be found by any other "
"means."
msgstr ""
"En Linux, el valor de la variable de entorno ``LD_LIBRARY_PATH`` se utiliza "
"cuando se buscan bibliotecas, si una biblioteca no puede ser encontrada por "
"ningún otro medio."

#: ../Doc/library/ctypes.rst:1327
msgid "Here are some examples::"
msgstr "Aquí hay algunos ejemplos::"

#: ../Doc/library/ctypes.rst:1338
#, fuzzy
msgid ""
"On macOS, :func:`~ctypes.util.find_library` tries several predefined naming "
"schemes and paths to locate the library, and returns a full pathname if "
"successful::"
msgstr ""
"En macOS, :func:`find_library` prueba varios esquemas de nombres y rutas "
"predefinidos para ubicar la biblioteca, y retorna un nombre de ruta completo "
"si tiene éxito:"

#: ../Doc/library/ctypes.rst:1352
#, fuzzy
msgid ""
"On Windows, :func:`~ctypes.util.find_library` searches along the system "
"search path, and returns the full pathname, but since there is no predefined "
"naming scheme a call like ``find_library(\"c\")`` will fail and return "
"``None``."
msgstr ""
"En Windows, :func:`find_library`` busca a lo largo de la ruta de búsqueda "
"del sistema, y retorna la ruta completa, pero como no hay un esquema de "
"nombres predefinido, una llamada como ``find_library(\"c\")`` fallará y "
"retornará ``None``."

#: ../Doc/library/ctypes.rst:1356
#, fuzzy
msgid ""
"If wrapping a shared library with :mod:`ctypes`, it *may* be better to "
"determine the shared library name at development time, and hardcode that "
"into the wrapper module instead of using :func:`~ctypes.util.find_library` "
"to locate the library at runtime."
msgstr ""
"Si envolvemos una biblioteca compartida con :mod:`ctypes`, puede ser mejor "
"determinar el nombre de la biblioteca compartida en tiempo de desarrollo, y "
"codificarlo en el módulo de envoltura en lugar de usar :func:`find_library` "
"para localizar la biblioteca en tiempo de ejecución."

#: ../Doc/library/ctypes.rst:1364
msgid "Loading shared libraries"
msgstr "Cargando bibliotecas compartidas"

#: ../Doc/library/ctypes.rst:1366
msgid ""
"There are several ways to load shared libraries into the Python process.  "
"One way is to instantiate one of the following classes:"
msgstr ""
"Hay varias maneras de cargar las bibliotecas compartidas en el proceso "
"Python. Una forma es instanciar una de las siguientes clases:"

#: ../Doc/library/ctypes.rst:1372
msgid ""
"Instances of this class represent loaded shared libraries. Functions in "
"these libraries use the standard C calling convention, and are assumed to "
"return :c:expr:`int`."
msgstr ""
"Las instancias de esta clase representan bibliotecas compartidas cargadas. "
"Las funciones en estas bibliotecas utilizan la convención de llamada "
"estándar de C y se supone que retornan :c:expr:`int`."

#: ../Doc/library/ctypes.rst:1376
msgid ""
"On Windows creating a :class:`CDLL` instance may fail even if the DLL name "
"exists. When a dependent DLL of the loaded DLL is not found, a :exc:"
"`OSError` error is raised with the message *\"[WinError 126] The specified "
"module could not be found\".* This error message does not contain the name "
"of the missing DLL because the Windows API does not return this information "
"making this error hard to diagnose. To resolve this error and determine "
"which DLL is not found, you need to find the list of dependent DLLs and "
"determine which one is not found using Windows debugging and tracing tools."
msgstr ""
"En Windows, la creación de una instancia :class:`CDLL` puede fallar incluso "
"si existe el nombre de la DLL. Cuando no se encuentra una DLL dependiente de "
"la DLL cargada, se lanza un error :exc:`OSError` con el mensaje *\"[WinError "
"126] No se pudo encontrar el módulo especificado\".* Este mensaje de error "
"no contiene el nombre de DLL que falta porque la API de Windows no retorna "
"esta información, lo que dificulta el diagnóstico de este error. Para "
"resolver este error y determinar qué DLL no se encuentra, debe buscar la "
"lista de DLL dependientes y determinar cuál no se encuentra utilizando las "
"herramientas de depuración y seguimiento de Windows."

#: ../Doc/library/ctypes.rst:1388 ../Doc/library/ctypes.rst:1410
#: ../Doc/library/ctypes.rst:1421 ../Doc/library/ctypes.rst:1438
msgid "The *name* parameter can now be a :term:`path-like object`."
msgstr ""

#: ../Doc/library/ctypes.rst:1392
msgid ""
"`Microsoft DUMPBIN tool <https://docs.microsoft.com/cpp/build/reference/"
"dependents>`_ -- A tool to find DLL dependents."
msgstr ""
"`Herramienta Microsoft DUMPBIN <https://docs.microsoft.com/cpp/build/"
"reference/dependents>`_ -- Una herramienta para encontrar dependientes de "
"DLL."

#: ../Doc/library/ctypes.rst:1398
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and are "
"assumed to return the windows specific :class:`HRESULT` code.  :class:"
"`HRESULT` values contain information specifying whether the function call "
"failed or succeeded, together with additional error code.  If the return "
"value signals a failure, an :class:`OSError` is automatically raised."
msgstr ""
"Sólo Windows: Las instancias de esta clase representan bibliotecas "
"compartidas cargadas, las funciones en estas bibliotecas usan la convención "
"de llamada ``stdcall``, y se asume que retornan el código específico de "
"windows :class:`HRESULT``. Los valores :class:`HRESULT`` contienen "
"información que especifica si la llamada a la función falló o tuvo éxito, "
"junto con un código de error adicional. Si el valor de retorno señala un "
"fracaso, se lanza automáticamente un :class:`OSError``."

#: ../Doc/library/ctypes.rst:1405
msgid ":exc:`WindowsError` used to be raised."
msgstr ":exc:`WindowsError` solía ser lanzado."

#: ../Doc/library/ctypes.rst:1415
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and are "
"assumed to return :c:expr:`int` by default."
msgstr ""
"Solo Windows: las instancias de esta clase representan bibliotecas "
"compartidas cargadas, las funciones en estas bibliotecas utilizan la "
"convención de llamadas ``stdcall`` y se supone que retornan :c:expr:`int` de "
"forma predeterminada."

#: ../Doc/library/ctypes.rst:1423
msgid ""
"The Python :term:`global interpreter lock` is released before calling any "
"function exported by these libraries, and reacquired afterwards."
msgstr ""
"El termino Python :term:`global interpreter lock` es lanzado antes de llamar "
"a cualquier función exportada por estas librerías, y se requiere después."

#: ../Doc/library/ctypes.rst:1429
msgid ""
"Instances of this class behave like :class:`CDLL` instances, except that the "
"Python GIL is *not* released during the function call, and after the "
"function execution the Python error flag is checked. If the error flag is "
"set, a Python exception is raised."
msgstr ""
"Las instancias de esta clase se comportan como instancias :class:`CDLL` , "
"excepto que el GIL de Python es *no* liberado durante la llamada a la "
"función, y después de la ejecución de la función se comprueba si esta activo "
"el flag de error de Python. Si el flag de error esta activado, se lanza una "
"excepción Python."

#: ../Doc/library/ctypes.rst:1434
msgid "Thus, this is only useful to call Python C api functions directly."
msgstr ""
"Por lo tanto, esto sólo es útil para llamar directamente a las funciones api "
"C de Python."

#: ../Doc/library/ctypes.rst:1440
#, fuzzy
msgid ""
"All these classes can be instantiated by calling them with at least one "
"argument, the pathname of the shared library.  If you have an existing "
"handle to an already loaded shared library, it can be passed as the "
"``handle`` named parameter, otherwise the underlying platforms :c:func:`!"
"dlopen` or :c:func:`!LoadLibrary` function is used to load the library into "
"the process, and to get a handle to it."
msgstr ""
"Todas estas clases pueden ser instanciadas llamándolas con al menos un "
"argumento, la ruta de la biblioteca compartida.  Si tienes un manejador "
"existente de una biblioteca compartida ya cargada, se puede pasar como el "
"parámetro llamado ``handle``, de lo contrario la función ``dlopen`` o "
"``LoadLibrary`` de la plataforma subyacente es utilizada para cargar la "
"biblioteca en el proceso, y  obtener un manejador de la misma."

#: ../Doc/library/ctypes.rst:1447
msgid ""
"The *mode* parameter can be used to specify how the library is loaded.  For "
"details, consult the :manpage:`dlopen(3)` manpage.  On Windows, *mode* is "
"ignored.  On posix systems, RTLD_NOW is always added, and is not "
"configurable."
msgstr ""
"El parámetro *mode* puede utilizarse para especificar cómo se carga la "
"biblioteca. Para más detalles, consulte la página :manpage:`dlopen(3)` del "
"manual. En Windows, *mode* es ignorado. En los sistemas posix, RTLD_NOW "
"siempre se agrega, y no es configurable."

#: ../Doc/library/ctypes.rst:1452
msgid ""
"The *use_errno* parameter, when set to true, enables a ctypes mechanism that "
"allows accessing the system :data:`errno` error number in a safe way. :mod:"
"`ctypes` maintains a thread-local copy of the systems :data:`errno` "
"variable; if you call foreign functions created with ``use_errno=True`` then "
"the :data:`errno` value before the function call is swapped with the ctypes "
"private copy, the same happens immediately after the function call."
msgstr ""
"El parámetro *use_errno*, cuando se establece en true, habilita un mecanismo "
"ctypes que permite acceder al número de error del sistema :data:`errno` de "
"forma segura. :mod:`ctypes` mantiene una copia local del hilo de la variable "
"del sistema :data:`errno`; si llamas a funciones extranjeras creadas con "
"``use_errno=True`` entonces el valor :data:`errno` antes de la llamada a la "
"función se intercambia con la copia privada de ctypes, lo mismo ocurre "
"inmediatamente después de la llamada a la función."

#: ../Doc/library/ctypes.rst:1459
msgid ""
"The function :func:`ctypes.get_errno` returns the value of the ctypes "
"private copy, and the function :func:`ctypes.set_errno` changes the ctypes "
"private copy to a new value and returns the former value."
msgstr ""
"La función :func:`ctypes.get_errno` retorna el valor de la copia privada de "
"ctypes, y la función :func:`ctypes.set_errno` cambia la copia privada de "
"ctypes a un nuevo valor y retorna el valor anterior."

#: ../Doc/library/ctypes.rst:1463
#, fuzzy
msgid ""
"The *use_last_error* parameter, when set to true, enables the same mechanism "
"for the Windows error code which is managed by the :func:`GetLastError` and :"
"func:`!SetLastError` Windows API functions; :func:`ctypes.get_last_error` "
"and :func:`ctypes.set_last_error` are used to request and change the ctypes "
"private copy of the windows error code."
msgstr ""
"El parámetro *use_last_error*, cuando se establece en true, habilita el "
"mismo mecanismo para el código de error de Windows que es administrado por "
"las funciones de la API de Windows :func:`GetLastError` y :func:"
"`SetLastError`; :func:`ctypes.get_last_error` y :func:`ctypes."
"set_last_error` se utilizan para solicitar y cambiar la copia privada ctypes "
"del código de error de Windows."

#: ../Doc/library/ctypes.rst:1469
#, fuzzy
msgid ""
"The *winmode* parameter is used on Windows to specify how the library is "
"loaded (since *mode* is ignored). It takes any value that is valid for the "
"Win32 API ``LoadLibraryEx`` flags parameter. When omitted, the default is to "
"use the flags that result in the most secure DLL load, which avoids issues "
"such as DLL hijacking. Passing the full path to the DLL is the safest way to "
"ensure the correct library and dependencies are loaded."
msgstr ""
"El parámetro *winmode* se utiliza en Windows para especificar cómo se carga "
"la biblioteca (ya que *mode* se ignora). Toma cualquier valor que sea válido "
"para el parámetro flags de la API de Win32 ``LoadLibraryEx``. Cuando se "
"omite, el valor por defecto es usar los flags que resultan en la carga de "
"DLL más segura para evitar problemas como el secuestro de DLL. Pasar la ruta "
"completa a la DLL es la forma más segura de asegurar que se cargan la "
"biblioteca y las dependencias correctas."

#: ../Doc/library/ctypes.rst:1476
msgid "Added *winmode* parameter."
msgstr "Añadido el parámetro *winmode*."

#: ../Doc/library/ctypes.rst:1483
msgid ""
"Flag to use as *mode* parameter.  On platforms where this flag is not "
"available, it is defined as the integer zero."
msgstr ""
"Flag para usar como parámetro *modo*. En las plataformas en las que esta "
"bandera no está disponible, se define como el cero entero."

#: ../Doc/library/ctypes.rst:1490
msgid ""
"Flag to use as *mode* parameter.  On platforms where this is not available, "
"it is the same as *RTLD_GLOBAL*."
msgstr ""
"Flag para usar como parámetro *modo*. En las plataformas en las que esto no "
"está disponible, es lo mismo que *RTLD_GLOBAL*."

#: ../Doc/library/ctypes.rst:1497
msgid ""
"The default mode which is used to load shared libraries.  On OSX 10.3, this "
"is *RTLD_GLOBAL*, otherwise it is the same as *RTLD_LOCAL*."
msgstr ""
"El modo por defecto que se utiliza para cargar las bibliotecas compartidas. "
"En OSX 10.3, esto es *RTLD_GLOBAL*, de lo contrario es lo mismo que "
"*RTLD_LOCAL*."

#: ../Doc/library/ctypes.rst:1500
msgid ""
"Instances of these classes have no public methods.  Functions exported by "
"the shared library can be accessed as attributes or by index.  Please note "
"that accessing the function through an attribute caches the result and "
"therefore accessing it repeatedly returns the same object each time.  On the "
"other hand, accessing it through an index returns a new object each time::"
msgstr ""
"Las instancias de estas clases no tienen métodos públicos. Se puede acceder "
"a las funciones exportadas por la biblioteca compartida como atributos o por "
"índice. Tenga en cuenta que al acceder a la función a través de un atributo "
"se almacena en caché el resultado y, por lo tanto, al acceder a él "
"repetidamente se retorna el mismo objeto cada vez. Por otro lado, acceder a "
"ella a través de un índice retorna un nuevo objeto cada vez::"

#: ../Doc/library/ctypes.rst:1513
msgid ""
"The following public attributes are available, their name starts with an "
"underscore to not clash with exported function names:"
msgstr ""
"Los siguientes atributos públicos están disponibles, su nombre comienza con "
"un guión bajo para no chocar con los nombres de las funciones exportadas:"

#: ../Doc/library/ctypes.rst:1519
msgid "The system handle used to access the library."
msgstr "El manejador del sistema usado para acceder a la biblioteca."

#: ../Doc/library/ctypes.rst:1524
msgid "The name of the library passed in the constructor."
msgstr "El nombre de la biblioteca pasado en el constructor."

#: ../Doc/library/ctypes.rst:1526
#, fuzzy
msgid ""
"Shared libraries can also be loaded by using one of the prefabricated "
"objects, which are instances of the :class:`LibraryLoader` class, either by "
"calling the :meth:`~LibraryLoader.LoadLibrary` method, or by retrieving the "
"library as attribute of the loader instance."
msgstr ""
"Las bibliotecas compartidas también pueden ser cargadas usando uno de los "
"objetos prefabricados, que son instancias de la clase :class:"
"`LibraryLoader`, ya sea llamando al método :meth:`LoadLibrary`, o "
"recuperando la biblioteca como atributo de la instancia de carga."

#: ../Doc/library/ctypes.rst:1534
msgid ""
"Class which loads shared libraries.  *dlltype* should be one of the :class:"
"`CDLL`, :class:`PyDLL`, :class:`WinDLL`, or :class:`OleDLL` types."
msgstr ""
"Clase que carga bibliotecas compartidas. *dlltype* debe ser uno de los "
"tipos :class:`CDLL`, :class:`PyDLL`, :class:`WinDLL`, o :class:`OleDLL`."

#: ../Doc/library/ctypes.rst:1537
#, fuzzy
msgid ""
":meth:`!__getattr__` has special behavior: It allows loading a shared "
"library by accessing it as attribute of a library loader instance.  The "
"result is cached, so repeated attribute accesses return the same library "
"each time."
msgstr ""
":meth:`__getattr__` tiene un comportamiento especial: Permite cargar una "
"biblioteca compartida accediendo a ella como atributo de una instancia de "
"carga de biblioteca. El resultado se almacena en caché, de modo que los "
"accesos repetidos a los atributos retornan la misma biblioteca cada vez."

#: ../Doc/library/ctypes.rst:1543
msgid ""
"Load a shared library into the process and return it.  This method always "
"returns a new instance of the library."
msgstr ""
"Carga una biblioteca compartida en el proceso y la retorna. Este método "
"siempre retorna una nueva instancia de la biblioteca."

#: ../Doc/library/ctypes.rst:1547
msgid "These prefabricated library loaders are available:"
msgstr "Estos cargadores prefabricados de bibliotecas están disponibles:"

#: ../Doc/library/ctypes.rst:1552
msgid "Creates :class:`CDLL` instances."
msgstr "Crea instancias de :class:`CDLL`."

#: ../Doc/library/ctypes.rst:1558
msgid "Windows only: Creates :class:`WinDLL` instances."
msgstr "Sólo Windows: Crea instancias de :class:`WinDLL`."

#: ../Doc/library/ctypes.rst:1564
msgid "Windows only: Creates :class:`OleDLL` instances."
msgstr "Sólo Windows: Crea instancias de :class:`OleDLL`."

#: ../Doc/library/ctypes.rst:1570
msgid "Creates :class:`PyDLL` instances."
msgstr "Crea instancias de :class:`PyDLL`."

#: ../Doc/library/ctypes.rst:1573
msgid ""
"For accessing the C Python api directly, a ready-to-use Python shared "
"library object is available:"
msgstr ""
"Para acceder directamente a la API C de Python, se dispone de un objeto de "
"biblioteca compartida de Python listo-para-usar:"

#: ../Doc/library/ctypes.rst:1579
#, fuzzy
msgid ""
"An instance of :class:`PyDLL` that exposes Python C API functions as "
"attributes.  Note that all these functions are assumed to return C :c:expr:"
"`int`, which is of course not always the truth, so you have to assign the "
"correct :attr:`!restype` attribute to use these functions."
msgstr ""
"Una instancia de :class:`PyDLL` que expone las funciones de la API de Python "
"C como atributos. Tenga en cuenta que se supone que todas estas funciones "
"retornan C :c:expr:`int`, lo que, por supuesto, no siempre es cierto, por lo "
"que debe asignar el atributo :attr:`restype` correcto para usar estas "
"funciones."

#: ../Doc/library/ctypes.rst:1584
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.dlopen`` with argument "
"``name``."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``ctypes.dlopen`` con argumento "
"``name``."

#: ../Doc/library/ctypes.rst:1586
#, fuzzy
msgid ""
"Loading a library through any of these objects raises an :ref:`auditing "
"event <auditing>` ``ctypes.dlopen`` with string argument ``name``, the name "
"used to load the library."
msgstr ""
"Cargar una biblioteca a través de cualquiera de estos objetos lanza un :ref:"
"`auditing event <auditing>` ``ctypes.dlopen`` con el argumento de cadena "
"``name``, el nombre usado para cargar la biblioteca."

#: ../Doc/library/ctypes.rst:1590
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.dlsym`` with arguments "
"``library``, ``name``."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``ctypes.dlsym`` con argumento "
"``library``, ``name``."

#: ../Doc/library/ctypes.rst:1592
#, fuzzy
msgid ""
"Accessing a function on a loaded library raises an auditing event ``ctypes."
"dlsym`` with arguments ``library`` (the library object) and ``name`` (the "
"symbol's name as a string or integer)."
msgstr ""
"Al acceder a una función en una biblioteca cargada se lanza un evento de "
"auditoría ``ctypes.dlsym`` con argumentos ``library`` (el objeto de la "
"biblioteca) y ``name`` (el nombre del símbolo como cadena o entero)."

#: ../Doc/library/ctypes.rst:1596
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.dlsym/handle`` with "
"arguments ``handle``, ``name``."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``ctypes.dlsym/handle`` con "
"argumento ``handle``, ``name``."

#: ../Doc/library/ctypes.rst:1598
msgid ""
"In cases when only the library handle is available rather than the object, "
"accessing a function raises an auditing event ``ctypes.dlsym/handle`` with "
"arguments ``handle`` (the raw library handle) and ``name``."
msgstr ""
"En los casos en los que sólo está disponible el manejador de la biblioteca "
"en lugar del objeto, al acceder a una función se produce un evento de "
"auditoría ``ctypes.dlsym/handle`` con los argumentos ``handle`` (el "
"manejador de la biblioteca en bruto) y ``name``."

#: ../Doc/library/ctypes.rst:1605
msgid "Foreign functions"
msgstr "Funciones foráneas"

#: ../Doc/library/ctypes.rst:1607
msgid ""
"As explained in the previous section, foreign functions can be accessed as "
"attributes of loaded shared libraries.  The function objects created in this "
"way by default accept any number of arguments, accept any ctypes data "
"instances as arguments, and return the default result type specified by the "
"library loader. They are instances of a private class:"
msgstr ""
"Como se explicó en la sección anterior, se puede acceder a las funciones "
"foráneas como atributos de las bibliotecas compartidas cargadas. Los objetos "
"de función creados de esta forma aceptan por defecto cualquier número de "
"argumentos, aceptan cualquier instancia de datos ctypes como argumentos y "
"retornan el tipo de resultado por defecto especificado por el cargador de la "
"biblioteca. Son instancias de una clase privada:"

#: ../Doc/library/ctypes.rst:1616
msgid "Base class for C callable foreign functions."
msgstr "Clase base para funciones foráneas C invocables."

#: ../Doc/library/ctypes.rst:1618
msgid ""
"Instances of foreign functions are also C compatible data types; they "
"represent C function pointers."
msgstr ""
"Las instancias de funciones foráneas también son tipos de datos compatibles "
"con C; representan punteros de funciones C."

#: ../Doc/library/ctypes.rst:1621
msgid ""
"This behavior can be customized by assigning to special attributes of the "
"foreign function object."
msgstr ""
"Este comportamiento puede personalizarse asignando a los atributos "
"especiales del objeto de la función foránea."

#: ../Doc/library/ctypes.rst:1626
msgid ""
"Assign a ctypes type to specify the result type of the foreign function. Use "
"``None`` for :c:expr:`void`, a function not returning anything."
msgstr ""
"Asigne un tipo ctypes para especificar el tipo de resultado de la función "
"externa. Use ``None`` para :c:expr:`void`, una función que no retorna nada."

#: ../Doc/library/ctypes.rst:1629
#, fuzzy
msgid ""
"It is possible to assign a callable Python object that is not a ctypes type, "
"in this case the function is assumed to return a C :c:expr:`int`, and the "
"callable will be called with this integer, allowing further processing or "
"error checking.  Using this is deprecated, for more flexible post processing "
"or error checking use a ctypes data type as :attr:`!restype` and assign a "
"callable to the :attr:`errcheck` attribute."
msgstr ""
"Es posible asignar un objeto de Python invocable que no sea del tipo ctypes, "
"en este caso se supone que la función retorna un C :c:expr:`int`, y el "
"invocable se llamará con este entero, lo que permite un mayor procesamiento "
"o comprobación de errores. El uso de esto es obsoleto, para un procesamiento "
"posterior más flexible o una verificación de errores, use un tipo de datos "
"ctypes como :attr:`restype` y asigne un invocable al atributo :attr:"
"`errcheck`."

#: ../Doc/library/ctypes.rst:1638
msgid ""
"Assign a tuple of ctypes types to specify the argument types that the "
"function accepts.  Functions using the ``stdcall`` calling convention can "
"only be called with the same number of arguments as the length of this "
"tuple; functions using the C calling convention accept additional, "
"unspecified arguments as well."
msgstr ""
"Asigne una tupla de tipos ctypes para especificar los tipos de argumentos "
"que acepta la función. Las funciones que utilizan la convención de llamada "
"``stdcall`` sólo pueden ser llamadas con el mismo número de argumentos que "
"la longitud de esta tupla; las funciones que utilizan la convención de "
"llamada C aceptan también argumentos adicionales no especificados."

#: ../Doc/library/ctypes.rst:1644
#, fuzzy
msgid ""
"When a foreign function is called, each actual argument is passed to the :"
"meth:`~_CData.from_param` class method of the items in the :attr:`argtypes` "
"tuple, this method allows adapting the actual argument to an object that the "
"foreign function accepts.  For example, a :class:`c_char_p` item in the :"
"attr:`argtypes` tuple will convert a string passed as argument into a bytes "
"object using ctypes conversion rules."
msgstr ""
"Cuando se llama a una función foránea, cada argumento real se pasa al método "
"de la clase :meth:`from_param` de los elementos de la tupla :attr:"
"`argtypes`, este método permite adaptar el argumento real a un objeto que la "
"función externa acepta. Por ejemplo, un elemento :class:`c_char_p` de la "
"tupla :attr:`argtypes` convertirá una cadena pasada como argumento en un "
"objeto de bytes utilizando reglas de conversión ctypes."

#: ../Doc/library/ctypes.rst:1651
#, fuzzy
msgid ""
"New: It is now possible to put items in argtypes which are not ctypes types, "
"but each item must have a :meth:`~_CData.from_param` method which returns a "
"value usable as argument (integer, string, ctypes instance).  This allows "
"defining adapters that can adapt custom objects as function parameters."
msgstr ""
"Nuevo: Ahora es posible poner en argtypes elementos que no son de tipo "
"ctypes, pero cada elemento debe tener un método :meth:`from_param` que "
"retorne un valor utilizable como argumento (entero, cadena, instancia "
"ctypes). Esto permite definir adaptadores que pueden adaptar objetos "
"personalizados como parámetros de la función."

#: ../Doc/library/ctypes.rst:1658
msgid ""
"Assign a Python function or another callable to this attribute. The callable "
"will be called with three or more arguments:"
msgstr ""
"Asigne una función Python u otra llamada a este atributo. El invocable será "
"llamado con tres o más argumentos:"

#: ../Doc/library/ctypes.rst:1665
#, fuzzy
msgid ""
"*result* is what the foreign function returns, as specified by the :attr:`!"
"restype` attribute."
msgstr ""
"*result* es lo que retorna la función externa, como se especifica en el "
"atributo :attr:`restype`."

#: ../Doc/library/ctypes.rst:1668
msgid ""
"*func* is the foreign function object itself, this allows reusing the same "
"callable object to check or post process the results of several functions."
msgstr ""
"*func* es el propio objeto de la función foránea, lo que permite reutilizar "
"el mismo objeto invocable para comprobar o postprocesar los resultados de "
"varias funciones."

#: ../Doc/library/ctypes.rst:1672
msgid ""
"*arguments* is a tuple containing the parameters originally passed to the "
"function call, this allows specializing the behavior on the arguments used."
msgstr ""
"*arguments* es una tupla que contiene los parámetros originalmente pasados a "
"la llamada de la función, esto permite especializar el comportamiento en los "
"argumentos utilizados."

#: ../Doc/library/ctypes.rst:1676
msgid ""
"The object that this function returns will be returned from the foreign "
"function call, but it can also check the result value and raise an exception "
"if the foreign function call failed."
msgstr ""
"El objeto que retorna esta función será retornado por la llamada de la "
"función foránea, pero también puede comprobar el valor del resultado y hacer "
"una excepción si la llamada de la función foránea ha fallado."

#: ../Doc/library/ctypes.rst:1683
msgid ""
"This exception is raised when a foreign function call cannot convert one of "
"the passed arguments."
msgstr ""
"Esta excepción se lanza cuando una llamada a una función foránea no puede "
"convertir uno de los argumentos pasados."

# Typo en la versión original, se envió un PR para corregirlo
#: ../Doc/library/ctypes.rst:1687
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_exception`` with "
"argument ``code``."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``ctypes.set_exception`` con "
"argumento ``code``."

# Typo en la versión original, se envió un PR para corregirlo
#: ../Doc/library/ctypes.rst:1689
msgid ""
"On Windows, when a foreign function call raises a system exception (for "
"example, due to an access violation), it will be captured and replaced with "
"a suitable Python exception. Further, an auditing event ``ctypes."
"set_exception`` with argument ``code`` will be raised, allowing an audit "
"hook to replace the exception with its own."
msgstr ""
"En Windows, cuando una llamada a una función foránea plantea una excepción "
"de sistema (por ejemplo, debido a una violación de acceso), será capturada y "
"sustituida por una excepción Python adecuada. Además, un evento de auditoría "
"``ctypes.set_exception`` con el argumento ``code`` será levantado, "
"permitiendo que un gancho de auditoría reemplace la excepción con la suya "
"propia."

#: ../Doc/library/ctypes.rst:1695
#, fuzzy
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.call_function`` with "
"arguments ``func_pointer``, ``arguments``."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``ctypes.call_function`` con "
"argumentos ``func_pointer``, ``arguments``."

#: ../Doc/library/ctypes.rst:1697
msgid ""
"Some ways to invoke foreign function calls may raise an auditing event "
"``ctypes.call_function`` with arguments ``function pointer`` and "
"``arguments``."
msgstr ""
"Algunas formas de invocar llamadas a funciones foráneas pueden lanzar un "
"evento de auditoría ``ctypes.call_function`` con los argumentos ``function "
"pointer`` y ``arguments``."

#: ../Doc/library/ctypes.rst:1703
msgid "Function prototypes"
msgstr "Prototipos de funciones"

#: ../Doc/library/ctypes.rst:1705
msgid ""
"Foreign functions can also be created by instantiating function prototypes. "
"Function prototypes are similar to function prototypes in C; they describe a "
"function (return type, argument types, calling convention) without defining "
"an implementation.  The factory functions must be called with the desired "
"result type and the argument types of the function, and can be used as "
"decorator factories, and as such, be applied to functions through the "
"``@wrapper`` syntax. See :ref:`ctypes-callback-functions` for examples."
msgstr ""
"Las funciones foráneas también pueden crearse mediante la instanciación de "
"prototipos de funciones. Los prototipos de funciones son similares a los "
"prototipos de funciones en C; describen una función (tipo de retorno, tipos "
"de argumentos, convención de llamada) sin definir una implementación. Las "
"funciones de fábrica deben ser llamadas con el tipo de resultado deseado y "
"los tipos de argumento de la función, y pueden ser usadas como fábricas de "
"decoradores, y como tales, ser aplicadas a las funciones a través de la "
"sintaxis ``@wrapper``. Ver :ref:`ctypes-callback-functions` para ejemplos."

#: ../Doc/library/ctypes.rst:1716
msgid ""
"The returned function prototype creates functions that use the standard C "
"calling convention.  The function will release the GIL during the call.  If "
"*use_errno* is set to true, the ctypes private copy of the system :data:"
"`errno` variable is exchanged with the real :data:`errno` value before and "
"after the call; *use_last_error* does the same for the Windows error code."
msgstr ""
"El prototipo de función retornado crea funciones que usan la convención de "
"llamada C estándar. La función liberará el GIL durante la llamada. Si "
"*use_errno* se configura a true, la copia privada de ctypes de la variable "
"del sistema :data:`errno` se intercambia con el valor real :data:`errno` "
"antes y después de la llamada; *use_last_error* hace lo mismo con el código "
"de error de Windows."

#: ../Doc/library/ctypes.rst:1726
msgid ""
"Windows only: The returned function prototype creates functions that use the "
"``stdcall`` calling convention.  The function will release the GIL during "
"the call.  *use_errno* and *use_last_error* have the same meaning as above."
msgstr ""
"Solo Windows: el prototipo de función retornada crea funciones que utilizan "
"la convención de llamada ``stdcall``. La función liberará el GIL durante la "
"llamada. *use_errno* y *use_last_error* tienen el mismo significado que el "
"anterior."

#: ../Doc/library/ctypes.rst:1734
msgid ""
"The returned function prototype creates functions that use the Python "
"calling convention.  The function will *not* release the GIL during the call."
msgstr ""
"El prototipo de función retornado crea funciones que usan la convención de "
"llamadas de Python. La función *no* liberará el GIL durante la llamada."

#: ../Doc/library/ctypes.rst:1737
msgid ""
"Function prototypes created by these factory functions can be instantiated "
"in different ways, depending on the type and number of the parameters in the "
"call:"
msgstr ""
"Los prototipos de funciones creados por estas funciones de fábrica pueden "
"ser instanciados de diferentes maneras, dependiendo del tipo y el número de "
"los parámetros en la llamada:"

#: ../Doc/library/ctypes.rst:1745
msgid ""
"Returns a foreign function at the specified address which must be an integer."
msgstr ""
"Retorna una función foránea en la dirección especificada que debe ser un "
"número entero."

#: ../Doc/library/ctypes.rst:1752
msgid ""
"Create a C callable function (a callback function) from a Python *callable*."
msgstr ""
"Crear una función de llamada C (una función de retrollamada) a partir de un "
"*callable* Python."

#: ../Doc/library/ctypes.rst:1759
msgid ""
"Returns a foreign function exported by a shared library. *func_spec* must be "
"a 2-tuple ``(name_or_ordinal, library)``. The first item is the name of the "
"exported function as string, or the ordinal of the exported function as "
"small integer.  The second item is the shared library instance."
msgstr ""
"Retorna una función foránea exportada por una biblioteca compartida. "
"*func_spec* debe ser un 2-tupla ``(name_or_ordinal, library)``. El primer "
"elemento es el nombre de la función exportada como cadena, o el ordinal de "
"la función exportada como entero pequeño. El segundo elemento es la "
"instancia de la biblioteca compartida."

#: ../Doc/library/ctypes.rst:1769
msgid ""
"Returns a foreign function that will call a COM method. *vtbl_index* is the "
"index into the virtual function table, a small non-negative integer. *name* "
"is name of the COM method. *iid* is an optional pointer to the interface "
"identifier which is used in extended error reporting."
msgstr ""
"Retorna una función foránea que llamará a un método COM. *vtbl_index* es el "
"índice de la tabla de funciones virtuales, un pequeño entero no negativo. "
"*name* es el nombre del método COM. *iid* es un puntero opcional para el "
"identificador de la interfaz que se utiliza en el informe de errores "
"extendido."

#: ../Doc/library/ctypes.rst:1774
#, fuzzy
msgid ""
"COM methods use a special calling convention: They require a pointer to the "
"COM interface as first argument, in addition to those parameters that are "
"specified in the :attr:`!argtypes` tuple."
msgstr ""
"Los métodos COM usan una convención especial de llamadas: Requieren un "
"puntero a la interfaz COM como primer argumento, además de los parámetros "
"que se especifican en la tupla :attr:`argtypes`."

#: ../Doc/library/ctypes.rst:1778
msgid ""
"The optional *paramflags* parameter creates foreign function wrappers with "
"much more functionality than the features described above."
msgstr ""
"El parámetro opcional *paramflags* crea envoltorios de funciones foráneas "
"con mucha más funcionalidad que las características descritas anteriormente."

#: ../Doc/library/ctypes.rst:1781
#, fuzzy
msgid ""
"*paramflags* must be a tuple of the same length as :attr:`~_FuncPtr."
"argtypes`."
msgstr ""
"*paramflags* deben ser una tupla de la misma longitud que :attr:`argtypes`."

#: ../Doc/library/ctypes.rst:1783
msgid ""
"Each item in this tuple contains further information about a parameter, it "
"must be a tuple containing one, two, or three items."
msgstr ""
"Cada elemento de esta tupla contiene más información sobre un parámetro, "
"debe ser una tupla que contenga uno, dos o tres elementos."

#: ../Doc/library/ctypes.rst:1786
msgid ""
"The first item is an integer containing a combination of direction flags for "
"the parameter:"
msgstr ""
"El primer elemento es un entero que contiene una combinación de flags de "
"dirección para el parámetro:"

#: ../Doc/library/ctypes.rst:1790
msgid "1"
msgstr "1"

#: ../Doc/library/ctypes.rst:1790
msgid "Specifies an input parameter to the function."
msgstr "Especifica un parámetro de entrada a la función."

#: ../Doc/library/ctypes.rst:1793
msgid "2"
msgstr "2"

#: ../Doc/library/ctypes.rst:1793
msgid "Output parameter.  The foreign function fills in a value."
msgstr "Parámetro de salida. La función foránea rellena un valor."

#: ../Doc/library/ctypes.rst:1796
msgid "4"
msgstr "4"

#: ../Doc/library/ctypes.rst:1796
msgid "Input parameter which defaults to the integer zero."
msgstr "Parámetro de entrada que por defecto es el cero entero."

#: ../Doc/library/ctypes.rst:1798
msgid ""
"The optional second item is the parameter name as string.  If this is "
"specified, the foreign function can be called with named parameters."
msgstr ""
"El segundo elemento opcional es el nombre del parámetro como cadena. Si se "
"especifica esto, se puede llamar a la función foránea con parámetros con "
"nombre."

#: ../Doc/library/ctypes.rst:1801
msgid "The optional third item is the default value for this parameter."
msgstr "El tercer elemento opcional es el valor por defecto de este parámetro."

#: ../Doc/library/ctypes.rst:1803
msgid ""
"This example demonstrates how to wrap the Windows ``MessageBoxW`` function "
"so that it supports default parameters and named arguments. The C "
"declaration from the windows header file is this::"
msgstr ""
"Este ejemplo demuestra cómo envolver la función ``MessageBoxW`` de Windows "
"para que soporte los parámetros por defecto y los argumentos con nombre. La "
"declaración C del archivo de cabecera de Windows es esta::"

#: ../Doc/library/ctypes.rst:1814 ../Doc/library/ctypes.rst:1837
msgid "Here is the wrapping with :mod:`ctypes`::"
msgstr "Aquí está el envoltorio con :mod:`ctypes`::"

#: ../Doc/library/ctypes.rst:1822
msgid "The ``MessageBox`` foreign function can now be called in these ways::"
msgstr "La función foránea de ``MessageBox`` puede ser llamada de esta manera:"

#: ../Doc/library/ctypes.rst:1828
msgid ""
"A second example demonstrates output parameters.  The win32 "
"``GetWindowRect`` function retrieves the dimensions of a specified window by "
"copying them into ``RECT`` structure that the caller has to supply.  Here is "
"the C declaration::"
msgstr ""
"Un segundo ejemplo demuestra los parámetros de salida. La función "
"``GetWindowRect`` de win32 retorna las dimensiones de una ventana "
"especificada copiándolas en la estructura ``RECT`` que la persona que llama "
"tiene que suministrar. Aquí está la declaración C::"

#: ../Doc/library/ctypes.rst:1846
msgid ""
"Functions with output parameters will automatically return the output "
"parameter value if there is a single one, or a tuple containing the output "
"parameter values when there are more than one, so the GetWindowRect function "
"now returns a RECT instance, when called."
msgstr ""
"Las funciones con parámetros de salida retornarán automáticamente el valor "
"del parámetro de salida si hay uno solo, o una tupla que contiene los "
"valores del parámetro de salida cuando hay más de uno, por lo que la función "
"GetWindowRect retorna ahora una instancia RECT, cuando se llama."

#: ../Doc/library/ctypes.rst:1851
#, fuzzy
msgid ""
"Output parameters can be combined with the :attr:`~_FuncPtr.errcheck` "
"protocol to do further output processing and error checking.  The win32 "
"``GetWindowRect`` api function returns a ``BOOL`` to signal success or "
"failure, so this function could do the error checking, and raises an "
"exception when the api call failed::"
msgstr ""
"Los parámetros de salida pueden combinarse con el protocolo :attr:`errcheck` "
"para hacer un mayor procesamiento de la salida y la comprobación de errores. "
"La función api de win32 ``GetWindowRect`` retorna un ``BOOL`` para señalar "
"el éxito o el fracaso, por lo que esta función podría hacer la comprobación "
"de errores, y plantea una excepción cuando la llamada api ha fallado::"

#: ../Doc/library/ctypes.rst:1864
#, fuzzy
msgid ""
"If the :attr:`~_FuncPtr.errcheck` function returns the argument tuple it "
"receives unchanged, :mod:`ctypes` continues the normal processing it does on "
"the output parameters.  If you want to return a tuple of window coordinates "
"instead of a ``RECT`` instance, you can retrieve the fields in the function "
"and return them instead, the normal processing will no longer take place::"
msgstr ""
"Si la función :attr:`errcheck` retorna la tupla de argumentos que recibe sin "
"cambios, :mod:`ctypes` continúa el procesamiento normal que hace en los "
"parámetros de salida. Si quieres retornar una tupla de coordenadas de "
"ventana en lugar de una instancia ``RECT``, puedes recuperar los campos de "
"la función y retornarlos en su lugar, el procesamiento normal ya no tendrá "
"lugar::"

#: ../Doc/library/ctypes.rst:1883
msgid "Utility functions"
msgstr "Funciones de utilidad"

#: ../Doc/library/ctypes.rst:1887
msgid ""
"Returns the address of the memory buffer as integer.  *obj* must be an "
"instance of a ctypes type."
msgstr ""
"Retorna la dirección del buffer de memoria como un entero. *obj* debe ser "
"una instancia de tipo ctypes."

#: ../Doc/library/ctypes.rst:1890
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.addressof`` with "
"argument ``obj``."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``ctypes.addressof`` con el "
"argumento ``obj``."

#: ../Doc/library/ctypes.rst:1895
msgid ""
"Returns the alignment requirements of a ctypes type. *obj_or_type* must be a "
"ctypes type or instance."
msgstr ""
"Retorna los requerimientos de alineación de un tipo de ctypes. *obj_or_type* "
"debe ser un tipo o instancia ctypes."

#: ../Doc/library/ctypes.rst:1901
msgid ""
"Returns a light-weight pointer to *obj*, which must be an instance of a "
"ctypes type.  *offset* defaults to zero, and must be an integer that will be "
"added to the internal pointer value."
msgstr ""
"Retorna un puntero ligero a *obj*, que debe ser un ejemplo de un tipo de "
"ctypes. *offset* es por defecto cero, y debe ser un entero que se añadirá al "
"valor del puntero interno."

#: ../Doc/library/ctypes.rst:1905
msgid "``byref(obj, offset)`` corresponds to this C code::"
msgstr "``byref(obj, offset)`` corresponde a este código C::"

#: ../Doc/library/ctypes.rst:1909
msgid ""
"The returned object can only be used as a foreign function call parameter. "
"It behaves similar to ``pointer(obj)``, but the construction is a lot faster."
msgstr ""
"El objeto retornado sólo puede ser utilizado como un parámetro de llamada de "
"función foránea. Se comporta de manera similar a ``pointer(obj)``, pero la "
"construcción es mucho más rápida."

#: ../Doc/library/ctypes.rst:1915
msgid ""
"This function is similar to the cast operator in C. It returns a new "
"instance of *type* which points to the same memory block as *obj*.  *type* "
"must be a pointer type, and *obj* must be an object that can be interpreted "
"as a pointer."
msgstr ""
"Esta función es similar a la del operador de reparto en C. retorna una nueva "
"instancia de *type* que apunta al mismo bloque de memoria que *obj*. *type* "
"debe ser un tipo de puntero, y *obj* debe ser un objeto que pueda ser "
"interpretado como un puntero."

#: ../Doc/library/ctypes.rst:1923
msgid ""
"This function creates a mutable character buffer. The returned object is a "
"ctypes array of :class:`c_char`."
msgstr ""
"Esta función crea un búfer de caracteres mutables. El objeto retornado es un "
"arreglo de ctypes de :class:`c_char`."

#: ../Doc/library/ctypes.rst:1926
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a bytes object which will be used to initialize the array items."
msgstr ""
"*init_or_size* debe ser un número entero que especifique el tamaño del "
"arreglo, o un objeto de bytes que se utilizará para inicializar los "
"elementos del arreglo."

#: ../Doc/library/ctypes.rst:1929
msgid ""
"If a bytes object is specified as first argument, the buffer is made one "
"item larger than its length so that the last element in the array is a NUL "
"termination character. An integer can be passed as second argument which "
"allows specifying the size of the array if the length of the bytes should "
"not be used."
msgstr ""
"Si se especifica un objeto bytes como primer argumento, el buffer se hace un "
"elemento más grande que su longitud, de modo que el último elemento del "
"arreglo es un carácter de terminación NUL. Se puede pasar un entero como "
"segundo argumento que permite especificar el tamaño del arreglo si no se "
"debe utilizar la longitud de los bytes."

#: ../Doc/library/ctypes.rst:1934
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.create_string_buffer`` "
"with arguments ``init``, ``size``."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``ctypes.create_string_buffer`` "
"con argumentos ``init``, ``size``."

#: ../Doc/library/ctypes.rst:1939
msgid ""
"This function creates a mutable unicode character buffer. The returned "
"object is a ctypes array of :class:`c_wchar`."
msgstr ""
"Esta función crea un búfer de caracteres unicode mutable. El objeto "
"retornado es un arreglo de ctypes de :class:`c_wchar`."

#: ../Doc/library/ctypes.rst:1942
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a string which will be used to initialize the array items."
msgstr ""
"*init_or_size* debe ser un entero que especifique el tamaño del arreglo, o "
"una cadena que se utilizará para inicializar los elementos del arreglo."

#: ../Doc/library/ctypes.rst:1945
msgid ""
"If a string is specified as first argument, the buffer is made one item "
"larger than the length of the string so that the last element in the array "
"is a NUL termination character. An integer can be passed as second argument "
"which allows specifying the size of the array if the length of the string "
"should not be used."
msgstr ""
"Si se especifica una cadena como primer argumento, el búfer se hace un "
"elemento más grande que la longitud de la cadena, de modo que el último "
"elemento del arreglo es un carácter de terminación NUL. Se puede pasar un "
"entero como segundo argumento que permite especificar el tamaño del arreglo "
"si no se debe utilizar la longitud de la cadena."

#: ../Doc/library/ctypes.rst:1951
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.create_unicode_buffer`` "
"with arguments ``init``, ``size``."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``ctypes.create_unicode_buffer`` "
"con argumentos ``init``, ``size``."

#: ../Doc/library/ctypes.rst:1956
msgid ""
"Windows only: This function is a hook which allows implementing in-process "
"COM servers with ctypes.  It is called from the DllCanUnloadNow function "
"that the _ctypes extension dll exports."
msgstr ""
"Sólo Windows: Esta función es un gancho que permite implementar servidores "
"COM en proceso con ctypes. Se llama desde la función DllCanUnloadNow que la "
"extensión _ctypes dll exporta."

#: ../Doc/library/ctypes.rst:1963
msgid ""
"Windows only: This function is a hook which allows implementing in-process "
"COM servers with ctypes.  It is called from the DllGetClassObject function "
"that the ``_ctypes`` extension dll exports."
msgstr ""
"Sólo Windows: Esta función es un gancho que permite implementar servidores "
"COM en proceso con ctypes. Se llama desde la función DllGetClassObject que "
"la extensión ``_ctypes`` exporta."

#: ../Doc/library/ctypes.rst:1971
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like ``lib``, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"Intenta encontrar una biblioteca y retornar un nombre de ruta. *name* es el "
"nombre de la biblioteca sin ningún prefijo como ``lib``, sufijo como ``."
"so``, ``.dylib`` o número de versión (esta es la forma usada para la opción "
"del enlazador posix :option:`!-l`). Si no se puede encontrar ninguna "
"biblioteca, retorna ``None``."

#: ../Doc/library/ctypes.rst:1982
msgid ""
"Windows only: return the filename of the VC runtime library used by Python, "
"and by the extension modules.  If the name of the library cannot be "
"determined, ``None`` is returned."
msgstr ""
"Sólo Windows: retorna el nombre de archivo de la biblioteca de tiempo de "
"ejecución de VC usada por Python, y por los módulos de extensión. Si no se "
"puede determinar el nombre de la biblioteca, se retorna ``None``."

#: ../Doc/library/ctypes.rst:1986
msgid ""
"If you need to free memory, for example, allocated by an extension module "
"with a call to the ``free(void *)``, it is important that you use the "
"function in the same library that allocated the memory."
msgstr ""
"Si necesita liberar memoria, por ejemplo, asignada por un módulo de "
"extensión con una llamada al ``free(void *)``, es importante que utilice la "
"función en la misma biblioteca que asignó la memoria."

#: ../Doc/library/ctypes.rst:1993
msgid ""
"Windows only: Returns a textual description of the error code *code*.  If no "
"error code is specified, the last error code is used by calling the Windows "
"api function GetLastError."
msgstr ""
"Sólo Windows: retorna una descripción textual del código de error *code*. Si "
"no se especifica ningún código de error, se utiliza el último código de "
"error llamando a la función de api de Windows GetLastError."

#: ../Doc/library/ctypes.rst:2000
msgid ""
"Windows only: Returns the last error code set by Windows in the calling "
"thread. This function calls the Windows ``GetLastError()`` function "
"directly, it does not return the ctypes-private copy of the error code."
msgstr ""
"Solo Windows: retorna el último código de error establecido por Windows en "
"el hilo de llamada. Esta función llama directamente a la función "
"``GetLastError()`` de Windows, no retorna la copia privada ctypes del código "
"de error."

#: ../Doc/library/ctypes.rst:2006
msgid ""
"Returns the current value of the ctypes-private copy of the system :data:"
"`errno` variable in the calling thread."
msgstr ""
"Retorna el valor actual de la copia ctypes-private de la variable de "
"sistema :data:`errno` en el hilo de llamada."

#: ../Doc/library/ctypes.rst:2009
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_errno`` with no "
"arguments."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``ctypes.get_errno`` sin "
"argumentos."

#: ../Doc/library/ctypes.rst:2013
#, fuzzy
msgid ""
"Windows only: returns the current value of the ctypes-private copy of the "
"system :data:`!LastError` variable in the calling thread."
msgstr ""
"Sólo Windows: retorna el valor actual de la copia ctypes-private de la "
"variable de sistema :data:`LastError` en el hilo de llamada."

#: ../Doc/library/ctypes.rst:2016
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_last_error`` with no "
"arguments."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``ctypes.get_last_error`` sin "
"argumentos."

#: ../Doc/library/ctypes.rst:2020
msgid ""
"Same as the standard C memmove library function: copies *count* bytes from "
"*src* to *dst*. *dst* and *src* must be integers or ctypes instances that "
"can be converted to pointers."
msgstr ""
"Igual que la función de la biblioteca estándar  de C *memmove*: copia "
"*count* bytes de *src* a *dst*. *dst* y *src* deben ser enteros o instancias "
"ctypes que pueden ser convertidos en punteros."

#: ../Doc/library/ctypes.rst:2027
msgid ""
"Same as the standard C memset library function: fills the memory block at "
"address *dst* with *count* bytes of value *c*. *dst* must be an integer "
"specifying an address, or a ctypes instance."
msgstr ""
"Igual que la función de la biblioteca estándar de C *memset* C: llena el "
"bloque de memoria en la dirección *dst* con *count* bytes de valor *c*. "
"*dst* debe ser un número entero que especifique una dirección, o una "
"instancia ctypes."

#: ../Doc/library/ctypes.rst:2034
#, fuzzy
msgid ""
"Create and return a new ctypes pointer type. Pointer types are cached and "
"reused internally, so calling this function repeatedly is cheap. *type* must "
"be a ctypes type."
msgstr ""
"Esta función de fábrica crea y retorna un nuevo tipo de puntero ctypes. Los "
"tipos de puntero se almacenan en caché y se reutilizan internamente, por lo "
"que llamar a esta función repetidamente es barato. *type* debe ser un tipo "
"ctypes."

#: ../Doc/library/ctypes.rst:2041
#, fuzzy
msgid ""
"Create a new pointer instance, pointing to *obj*. The returned object is of "
"the type ``POINTER(type(obj))``."
msgstr ""
"Esta función crea una nueva instancia de puntero, apuntando a *obj*. El "
"objeto retornado es del tipo ``POINTER(tipo(obj))``."

#: ../Doc/library/ctypes.rst:2044
msgid ""
"Note: If you just want to pass a pointer to an object to a foreign function "
"call, you should use ``byref(obj)`` which is much faster."
msgstr ""
"Nota: Si sólo quieres pasar un puntero a un objeto a una llamada de función "
"foránea, deberías usar ``byref(obj)`` que es mucho más rápido."

#: ../Doc/library/ctypes.rst:2050
msgid ""
"This function resizes the internal memory buffer of *obj*, which must be an "
"instance of a ctypes type.  It is not possible to make the buffer smaller "
"than the native size of the objects type, as given by ``sizeof(type(obj))``, "
"but it is possible to enlarge the buffer."
msgstr ""
"Esta función redimensiona el búfer de memoria interna de *obj*, que debe ser "
"una instancia de tipo ctypes. No es posible hacer el buffer más pequeño que "
"el tamaño nativo del tipo de objetos, como lo indica ``size of "
"(type(obj))``, pero es posible agrandar el buffer."

#: ../Doc/library/ctypes.rst:2058
msgid ""
"Set the current value of the ctypes-private copy of the system :data:`errno` "
"variable in the calling thread to *value* and return the previous value."
msgstr ""
"Poner el valor actual de la copia ctypes-private de la variable del sistema :"
"data:`errno` en el hilo de llamada a *valor* y retornar el valor anterior."

#: ../Doc/library/ctypes.rst:2061
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_errno`` with "
"argument ``errno``."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``ctypes.set_errno`` con argumento "
"``errno``."

#: ../Doc/library/ctypes.rst:2066
#, fuzzy
msgid ""
"Windows only: set the current value of the ctypes-private copy of the "
"system :data:`!LastError` variable in the calling thread to *value* and "
"return the previous value."
msgstr ""
"Sólo para Windows: pone el valor actual de la copia ctypes-private de la "
"variable del sistema :data:`LastError` en el hilo de llamada a *valor* y "
"retorna el valor anterior."

#: ../Doc/library/ctypes.rst:2070
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_last_error`` with "
"argument ``error``."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``ctypes.set_last_error`` con "
"argumento ``error``."

#: ../Doc/library/ctypes.rst:2075
msgid ""
"Returns the size in bytes of a ctypes type or instance memory buffer. Does "
"the same as the C ``sizeof`` operator."
msgstr ""
"Retorna el tamaño en bytes de un buffer de memoria tipo ctypes o instancia. "
"Hace lo mismo que el operador C ``sizeof``."

#: ../Doc/library/ctypes.rst:2081
msgid ""
"This function returns the C string starting at memory address *address* as a "
"bytes object. If size is specified, it is used as size, otherwise the string "
"is assumed to be zero-terminated."
msgstr ""
"Esta función retorna la cadena C que comienza en la dirección de memoria "
"*address* como un objeto de bytes. Si se especifica el tamaño, se utiliza "
"como tamaño, de lo contrario se asume que la cadena tiene un final cero."

#: ../Doc/library/ctypes.rst:2085
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.string_at`` with "
"arguments ``address``, ``size``."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``ctypes.string_at`` con "
"argumentos ``address``, ``size``."

#: ../Doc/library/ctypes.rst:2090
msgid ""
"Windows only: this function is probably the worst-named thing in ctypes. It "
"creates an instance of OSError.  If *code* is not specified, "
"``GetLastError`` is called to determine the error code. If *descr* is not "
"specified, :func:`FormatError` is called to get a textual description of the "
"error."
msgstr ""
"Sólo para Windows: esta función es probablemente la cosa peor nombrada de "
"los ctypes. Crea una instancia de OSError. Si no se especifica el *code*, se "
"llama a ``GetLastError`` para determinar el código de error. Si no se "
"especifica *descr*, se llama a :func:`FormatError`` para obtener una "
"descripción textual del error."

#: ../Doc/library/ctypes.rst:2096
msgid "An instance of :exc:`WindowsError` used to be created."
msgstr "Una instancia de :exc:`WindowsError` solía ser creada."

#: ../Doc/library/ctypes.rst:2102
msgid ""
"This function returns the wide character string starting at memory address "
"*address* as a string.  If *size* is specified, it is used as the number of "
"characters of the string, otherwise the string is assumed to be zero-"
"terminated."
msgstr ""
"Esta función retorna la cadena de caracteres anchos que comienza en la "
"dirección de memoria *address* como una cadena. Si se especifica *size*, se "
"utiliza como el número de caracteres de la cadena, de lo contrario se asume "
"que la cadena tiene un final cero."

#: ../Doc/library/ctypes.rst:2107
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.wstring_at`` with "
"arguments ``address``, ``size``."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``ctypes.wstring_at`` con "
"argumentos ``address``, ``size``."

#: ../Doc/library/ctypes.rst:2113
msgid "Data types"
msgstr "Tipos de datos"

#: ../Doc/library/ctypes.rst:2118
msgid ""
"This non-public class is the common base class of all ctypes data types. "
"Among other things, all ctypes type instances contain a memory block that "
"hold C compatible data; the address of the memory block is returned by the :"
"func:`addressof` helper function. Another instance variable is exposed as :"
"attr:`_objects`; this contains other Python objects that need to be kept "
"alive in case the memory block contains pointers."
msgstr ""
"Esta clase no pública es la clase de base común de todos los tipos de datos "
"de los ctypes. Entre otras cosas, todas las instancias de tipo ctypes "
"contienen un bloque de memoria que contiene datos compatibles con C; la "
"dirección del bloque de memoria es retornada por la función de ayuda :func:"
"`addressof`. Otra variable de instancia se expone como :attr:`_objetos`; "
"ésta contiene otros objetos de Python que deben mantenerse vivos en caso de "
"que el bloque de memoria contenga punteros."

#: ../Doc/library/ctypes.rst:2125
msgid ""
"Common methods of ctypes data types, these are all class methods (to be "
"exact, they are methods of the :term:`metaclass`):"
msgstr ""
"Métodos comunes de tipos de datos ctypes, estos son todos métodos de clase "
"(para ser exactos, son métodos del :term:`metaclass`):"

#: ../Doc/library/ctypes.rst:2130
msgid ""
"This method returns a ctypes instance that shares the buffer of the *source* "
"object.  The *source* object must support the writeable buffer interface.  "
"The optional *offset* parameter specifies an offset into the source buffer "
"in bytes; the default is zero.  If the source buffer is not large enough a :"
"exc:`ValueError` is raised."
msgstr ""
"Este método retorna una instancia ctypes que comparte el buffer del objeto "
"*source*. El objeto *source* debe soportar la interfaz del buffer de "
"escritura. El parámetro opcional *offset* especifica un offset en el buffer "
"de la fuente en bytes; el valor por defecto es cero. Si el buffer de la "
"fuente no es lo suficientemente grande se lanza un :exc:`ValueError`."

#: ../Doc/library/ctypes.rst:2136 ../Doc/library/ctypes.rst:2146
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.cdata/buffer`` with "
"arguments ``pointer``, ``size``, ``offset``."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``ctypes.cdata/buffer`` con "
"argumentos ``pointer``, ``size``, ``offset``."

#: ../Doc/library/ctypes.rst:2140
msgid ""
"This method creates a ctypes instance, copying the buffer from the *source* "
"object buffer which must be readable.  The optional *offset* parameter "
"specifies an offset into the source buffer in bytes; the default is zero.  "
"If the source buffer is not large enough a :exc:`ValueError` is raised."
msgstr ""
"Este método crea una instancia ctypes, copiando el buffer del buffer de "
"objetos *source* que debe ser legible. El parámetro opcional *offset* "
"especifica un offset en el buffer de origen en bytes; el valor por defecto "
"es cero. Si el buffer de fuente no es lo suficientemente grande se lanza un :"
"exc:`ValueError`."

#: ../Doc/library/ctypes.rst:2150
msgid ""
"This method returns a ctypes type instance using the memory specified by "
"*address* which must be an integer."
msgstr ""
"Este método retorna una instancia de tipo ctypes utilizando la memoria "
"especificada por *address* que debe ser un entero."

#: ../Doc/library/ctypes.rst:2153
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.cdata`` with argument "
"``address``."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``ctypes.cdata`` con argumento "
"``address``."

#: ../Doc/library/ctypes.rst:2155
msgid ""
"This method, and others that indirectly call this method, raises an :ref:"
"`auditing event <auditing>` ``ctypes.cdata`` with argument ``address``."
msgstr ""
"Este método, y otros que indirectamente llaman a este método, lanzan un :ref:"
"`auditing event <auditing>` ``ctypes.cdata`` con argumento ``address``."

#: ../Doc/library/ctypes.rst:2161
#, fuzzy
msgid ""
"This method adapts *obj* to a ctypes type.  It is called with the actual "
"object used in a foreign function call when the type is present in the "
"foreign function's :attr:`~_FuncPtr.argtypes` tuple; it must return an "
"object that can be used as a function call parameter."
msgstr ""
"Este método adapta el *obj* a un tipo de ctypes. Se llama con el objeto real "
"usado en una llamada a una función externa cuando el tipo está presente en "
"la tupla :attr:`argtypes` de la función foránea; debe retornar un objeto que "
"pueda ser usado como parámetro de llamada a la función."

#: ../Doc/library/ctypes.rst:2166
msgid ""
"All ctypes data types have a default implementation of this classmethod that "
"normally returns *obj* if that is an instance of the type.  Some types "
"accept other objects as well."
msgstr ""
"Todos los tipos de datos ctypes tienen una implementación por defecto de "
"este método de clase que normalmente retorna *obj* si es una instancia del "
"tipo. Algunos tipos aceptan también otros objetos."

#: ../Doc/library/ctypes.rst:2172
msgid ""
"This method returns a ctypes type instance exported by a shared library. "
"*name* is the name of the symbol that exports the data, *library* is the "
"loaded shared library."
msgstr ""
"Este método retorna una instancia de tipo ctypes exportada por una "
"biblioteca compartida. *name* es el nombre del símbolo que exporta los "
"datos, *library* es la biblioteca compartida cargada."

#: ../Doc/library/ctypes.rst:2176
msgid "Common instance variables of ctypes data types:"
msgstr "Variables de instancia común de los tipos de datos de ctypes:"

#: ../Doc/library/ctypes.rst:2180
msgid ""
"Sometimes ctypes data instances do not own the memory block they contain, "
"instead they share part of the memory block of a base object.  The :attr:"
"`_b_base_` read-only member is the root ctypes object that owns the memory "
"block."
msgstr ""
"A veces, las instancias de datos ctypes no poseen el bloque de memoria que "
"contienen, sino que comparten parte del bloque de memoria de un objeto base. "
"El miembro de sólo lectura :attr:`_b_base_` es el objeto raíz ctypes que "
"posee el bloque de memoria."

#: ../Doc/library/ctypes.rst:2187
msgid ""
"This read-only variable is true when the ctypes data instance has allocated "
"the memory block itself, false otherwise."
msgstr ""
"Esta variable de sólo lectura es verdadera cuando la instancia de datos "
"ctypes ha sido asignada a el propio bloque de memoria, falsa en caso "
"contrario."

#: ../Doc/library/ctypes.rst:2192
msgid ""
"This member is either ``None`` or a dictionary containing Python objects "
"that need to be kept alive so that the memory block contents is kept valid.  "
"This object is only exposed for debugging; never modify the contents of this "
"dictionary."
msgstr ""
"Este miembro es ``None`` o un diccionario que contiene objetos de Python que "
"deben mantenerse vivos para que el contenido del bloque de memoria sea "
"válido. Este objeto sólo se expone para su depuración; nunca modifique el "
"contenido de este diccionario."

#: ../Doc/library/ctypes.rst:2205
msgid ""
"This non-public class is the base class of all fundamental ctypes data "
"types. It is mentioned here because it contains the common attributes of the "
"fundamental ctypes data types.  :class:`_SimpleCData` is a subclass of :"
"class:`_CData`, so it inherits their methods and attributes. ctypes data "
"types that are not and do not contain pointers can now be pickled."
msgstr ""
"Esta clase no pública es la clase base de todos los tipos de datos de ctypes "
"fundamentales. Se menciona aquí porque contiene los atributos comunes de los "
"tipos de datos de ctypes fundamentales. :class:`_SimpleCData` es una "
"subclase de :class:`_CData`, por lo que hereda sus métodos y atributos. Los "
"tipos de datos ctypes que no son y no contienen punteros ahora pueden ser "
"archivados."

#: ../Doc/library/ctypes.rst:2211
msgid "Instances have a single attribute:"
msgstr "Los instancias tienen un solo atributo:"

#: ../Doc/library/ctypes.rst:2215
msgid ""
"This attribute contains the actual value of the instance. For integer and "
"pointer types, it is an integer, for character types, it is a single "
"character bytes object or string, for character pointer types it is a Python "
"bytes object or string."
msgstr ""
"Este atributo contiene el valor real de la instancia. Para los tipos enteros "
"y punteros, es un entero, para los tipos de caracteres, es un objeto o "
"cadena de bytes de un solo carácter, para los tipos de punteros de "
"caracteres es un objeto o cadena de bytes de Python."

#: ../Doc/library/ctypes.rst:2220
msgid ""
"When the ``value`` attribute is retrieved from a ctypes instance, usually a "
"new object is returned each time.  :mod:`ctypes` does *not* implement "
"original object return, always a new object is constructed.  The same is "
"true for all other ctypes object instances."
msgstr ""
"Cuando el atributo ``value`` se recupera de una instancia ctypes, "
"normalmente se retorna un nuevo objeto cada vez. :mod:`ctypes` *no* "
"implementa el retorno del objeto original, siempre se construye un nuevo "
"objeto. Lo mismo ocurre con todas las demás instancias de objetos ctypes."

#: ../Doc/library/ctypes.rst:2226
#, fuzzy
msgid ""
"Fundamental data types, when returned as foreign function call results, or, "
"for example, by retrieving structure field members or array items, are "
"transparently converted to native Python types.  In other words, if a "
"foreign function has a :attr:`~_FuncPtr.restype` of :class:`c_char_p`, you "
"will always receive a Python bytes object, *not* a :class:`c_char_p` "
"instance."
msgstr ""
"Los tipos de datos fundamentales, cuando se retornan como resultados de "
"llamadas de funciones foráneas, o, por ejemplo, al recuperar miembros de "
"campo de estructura o elementos de arreglos, se convierten de forma "
"transparente a tipos nativos de Python. En otras palabras, si una función "
"externa tiene un :attr:`restype` de :class:`c_char_p`, siempre recibirá un "
"objeto de bytes Python, *no* una instancia de :class:`c_char_p`."

#: ../Doc/library/ctypes.rst:2234
#, fuzzy
msgid ""
"Subclasses of fundamental data types do *not* inherit this behavior. So, if "
"a foreign functions :attr:`!restype` is a subclass of :class:`c_void_p`, you "
"will receive an instance of this subclass from the function call. Of course, "
"you can get the value of the pointer by accessing the ``value`` attribute."
msgstr ""
"Las subclases de los tipos de datos fundamentales *no* heredan este "
"comportamiento. Así, si una función externa :attr:`restype` es una subclase "
"de :class:`c_void_p`, recibirás una instancia de esta subclase desde la "
"llamada a la función. Por supuesto, puedes obtener el valor del puntero "
"accediendo al atributo ``value``."

#: ../Doc/library/ctypes.rst:2239
msgid "These are the fundamental ctypes data types:"
msgstr "Estos son los tipos de datos fundamentales de ctypes:"

#: ../Doc/library/ctypes.rst:2243
msgid ""
"Represents the C :c:expr:`signed char` datatype, and interprets the value as "
"small integer.  The constructor accepts an optional integer initializer; no "
"overflow checking is done."
msgstr ""
"Representa el tipo de datos C :c:expr:`signed char` e interpreta el valor "
"como un entero pequeño. El constructor acepta un inicializador entero "
"opcional; no se realiza ninguna comprobación de desbordamiento."

#: ../Doc/library/ctypes.rst:2250
msgid ""
"Represents the C :c:expr:`char` datatype, and interprets the value as a "
"single character.  The constructor accepts an optional string initializer, "
"the length of the string must be exactly one character."
msgstr ""
"Representa el tipo de datos C :c:expr:`char` e interpreta el valor como un "
"solo carácter. El constructor acepta un inicializador de cadena opcional, la "
"longitud de la cadena debe ser exactamente un carácter."

#: ../Doc/library/ctypes.rst:2257
msgid ""
"Represents the C :c:expr:`char *` datatype when it points to a zero-"
"terminated string.  For a general character pointer that may also point to "
"binary data, ``POINTER(c_char)`` must be used.  The constructor accepts an "
"integer address, or a bytes object."
msgstr ""
"Representa el tipo de datos C :c:expr:`char *` cuando apunta a una cadena "
"terminada en cero. Para un puntero de carácter general que también puede "
"apuntar a datos binarios, se debe usar ``POINTER(c_char)``. El constructor "
"acepta una dirección entera o un objeto de bytes."

#: ../Doc/library/ctypes.rst:2265
msgid ""
"Represents the C :c:expr:`double` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""
"Representa el tipo de datos C :c:expr:`double`. El constructor acepta un "
"inicializador flotante opcional."

#: ../Doc/library/ctypes.rst:2271
msgid ""
"Represents the C :c:expr:`long double` datatype.  The constructor accepts an "
"optional float initializer.  On platforms where ``sizeof(long double) == "
"sizeof(double)`` it is an alias to :class:`c_double`."
msgstr ""
"Representa el tipo de datos C :c:expr:`long double`. El constructor acepta "
"un inicializador flotante opcional. En plataformas donde ``sizeof(long "
"double) == sizeof(double)`` es un alias de :class:`c_double`."

#: ../Doc/library/ctypes.rst:2277
msgid ""
"Represents the C :c:expr:`float` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""
"Representa el tipo de datos C :c:expr:`float`. El constructor acepta un "
"inicializador flotante opcional."

#: ../Doc/library/ctypes.rst:2283
msgid ""
"Represents the C :c:expr:`signed int` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias to :class:`c_long`."
msgstr ""
"Representa el tipo de datos C :c:expr:`signed int`. El constructor acepta un "
"inicializador entero opcional; no se realiza ninguna comprobación de "
"desbordamiento. En plataformas donde ``sizeof(int) == sizeof(long)`` es un "
"alias de :class:`c_long`."

#: ../Doc/library/ctypes.rst:2290
msgid ""
"Represents the C 8-bit :c:expr:`signed int` datatype.  Usually an alias for :"
"class:`c_byte`."
msgstr ""
"Representa el tipo de datos :c:expr:`signed int` de C de 8 bits. Por lo "
"general, un alias para :class:`c_byte`."

#: ../Doc/library/ctypes.rst:2296
msgid ""
"Represents the C 16-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_short`."
msgstr ""
"Representa el tipo de datos :c:expr:`signed int` de C de 16 bits. Por lo "
"general, un alias para :class:`c_short`."

#: ../Doc/library/ctypes.rst:2302
msgid ""
"Represents the C 32-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_int`."
msgstr ""
"Representa el tipo de datos :c:expr:`signed int` de C de 32 bits. Por lo "
"general, un alias para :class:`c_int`."

#: ../Doc/library/ctypes.rst:2308
msgid ""
"Represents the C 64-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_longlong`."
msgstr ""
"Representa el tipo de datos :c:expr:`signed int` de C de 64 bits. Por lo "
"general, un alias para :class:`c_longlong`."

#: ../Doc/library/ctypes.rst:2314
msgid ""
"Represents the C :c:expr:`signed long` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done."
msgstr ""
"Representa el tipo de datos C :c:expr:`signed long`. El constructor acepta "
"un inicializador entero opcional; no se realiza ninguna comprobación de "
"desbordamiento."

#: ../Doc/library/ctypes.rst:2320
msgid ""
"Represents the C :c:expr:`signed long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"Representa el tipo de datos C :c:expr:`signed long long`. El constructor "
"acepta un inicializador entero opcional; no se realiza ninguna comprobación "
"de desbordamiento."

#: ../Doc/library/ctypes.rst:2326
msgid ""
"Represents the C :c:expr:`signed short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"Representa el tipo de datos C :c:expr:`signed short`. El constructor acepta "
"un inicializador entero opcional; no se realiza ninguna comprobación de "
"desbordamiento."

#: ../Doc/library/ctypes.rst:2332
msgid "Represents the C :c:type:`size_t` datatype."
msgstr "Representa el tipo de datos C :c:type:`size_t`."

#: ../Doc/library/ctypes.rst:2337
msgid "Represents the C :c:type:`ssize_t` datatype."
msgstr "Representa el tipo de datos C :c:type:`ssize_t`."

#: ../Doc/library/ctypes.rst:2344
#, fuzzy
msgid "Represents the C :c:type:`time_t` datatype."
msgstr "Representa el tipo de datos C :c:type:`size_t`."

#: ../Doc/library/ctypes.rst:2351
msgid ""
"Represents the C :c:expr:`unsigned char` datatype, it interprets the value "
"as small integer.  The constructor accepts an optional integer initializer; "
"no overflow checking is done."
msgstr ""
"Representa el tipo de datos C :c:expr:`unsigned char`, interpreta el valor "
"como un entero pequeño. El constructor acepta un inicializador entero "
"opcional; no se realiza ninguna comprobación de desbordamiento."

#: ../Doc/library/ctypes.rst:2358
msgid ""
"Represents the C :c:expr:`unsigned int` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias for :class:`c_ulong`."
msgstr ""
"Representa el tipo de datos C :c:expr:`unsigned int`. El constructor acepta "
"un inicializador entero opcional; no se realiza ninguna comprobación de "
"desbordamiento. En plataformas donde ``sizeof(int) == sizeof(long)`` es un "
"alias para :class:`c_ulong`."

#: ../Doc/library/ctypes.rst:2365
msgid ""
"Represents the C 8-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ubyte`."
msgstr ""
"Representa el tipo de datos :c:expr:`unsigned int` de C de 8 bits. Por lo "
"general, un alias para :class:`c_ubyte`."

#: ../Doc/library/ctypes.rst:2371
msgid ""
"Represents the C 16-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ushort`."
msgstr ""
"Representa el tipo de datos :c:expr:`unsigned int` de C de 16 bits. Por lo "
"general, un alias para :class:`c_ushort`."

#: ../Doc/library/ctypes.rst:2377
msgid ""
"Represents the C 32-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_uint`."
msgstr ""
"Representa el tipo de datos :c:expr:`unsigned int` de C de 32 bits. Por lo "
"general, un alias para :class:`c_uint`."

#: ../Doc/library/ctypes.rst:2383
msgid ""
"Represents the C 64-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ulonglong`."
msgstr ""
"Representa el tipo de datos :c:expr:`unsigned int` de C de 64 bits. Por lo "
"general, un alias para :class:`c_ulonglong`."

#: ../Doc/library/ctypes.rst:2389
msgid ""
"Represents the C :c:expr:`unsigned long` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"Representa el tipo de datos C :c:expr:`unsigned long`. El constructor acepta "
"un inicializador entero opcional; no se realiza ninguna comprobación de "
"desbordamiento."

#: ../Doc/library/ctypes.rst:2395
msgid ""
"Represents the C :c:expr:`unsigned long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"Representa el tipo de datos C :c:expr:`unsigned long long`. El constructor "
"acepta un inicializador entero opcional; no se realiza ninguna comprobación "
"de desbordamiento."

#: ../Doc/library/ctypes.rst:2401
msgid ""
"Represents the C :c:expr:`unsigned short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"Representa el tipo de datos C :c:expr:`unsigned short`. El constructor "
"acepta un inicializador entero opcional; no se realiza ninguna comprobación "
"de desbordamiento."

#: ../Doc/library/ctypes.rst:2407
msgid ""
"Represents the C :c:expr:`void *` type.  The value is represented as "
"integer. The constructor accepts an optional integer initializer."
msgstr ""
"Representa el tipo C :c:expr:`void *`. El valor se representa como un número "
"entero. El constructor acepta un inicializador entero opcional."

#: ../Doc/library/ctypes.rst:2413
#, fuzzy
msgid ""
"Represents the C :c:type:`wchar_t` datatype, and interprets the value as a "
"single character unicode string.  The constructor accepts an optional string "
"initializer, the length of the string must be exactly one character."
msgstr ""
"Representa el tipo de datos C :c:expr:`wchar_t` e interpreta el valor como "
"una cadena Unicode de un solo carácter. El constructor acepta un "
"inicializador de cadena opcional, la longitud de la cadena debe ser "
"exactamente un carácter."

#: ../Doc/library/ctypes.rst:2420
msgid ""
"Represents the C :c:expr:`wchar_t *` datatype, which must be a pointer to a "
"zero-terminated wide character string.  The constructor accepts an integer "
"address, or a string."
msgstr ""
"Representa el tipo de datos C :c:expr:`wchar_t *`, que debe ser un puntero a "
"una cadena de caracteres anchos terminada en cero. El constructor acepta una "
"dirección entera o una cadena."

#: ../Doc/library/ctypes.rst:2427
msgid ""
"Represent the C :c:expr:`bool` datatype (more accurately, :c:expr:`_Bool` "
"from C99).  Its value can be ``True`` or ``False``, and the constructor "
"accepts any object that has a truth value."
msgstr ""
"Representa el tipo de dato C :c:expr:`bool` (más precisamente, :c:expr:"
"`_Bool` de C99). Su valor puede ser ``True`` o ``False``, y el constructor "
"acepta cualquier objeto que tenga un valor de verdad."

#: ../Doc/library/ctypes.rst:2434
#, fuzzy
msgid ""
"Windows only: Represents a :c:type:`!HRESULT` value, which contains success "
"or error information for a function or method call."
msgstr ""
"Sólo Windows: Representa un valor :c:type:`HRESULT` , que contiene "
"información de éxito o error para una llamada de función o método."

#: ../Doc/library/ctypes.rst:2440
msgid ""
"Represents the C :c:expr:`PyObject *` datatype.  Calling this without an "
"argument creates a ``NULL`` :c:expr:`PyObject *` pointer."
msgstr ""
"Representa el tipo de dato de C :c:expr:`PyObject *`.  Llamar esto sin un "
"argumento crea un puntero :c:expr:`PyObject *` ``NULL``."

#: ../Doc/library/ctypes.rst:2443
#, fuzzy
msgid ""
"The :mod:`!ctypes.wintypes` module provides quite some other Windows "
"specific data types, for example :c:type:`!HWND`, :c:type:`!WPARAM`, or :c:"
"type:`!DWORD`. Some useful structures like :c:type:`!MSG` or :c:type:`!RECT` "
"are also defined."
msgstr ""
"El módulo :mod:`ctypes.wintypes` proporciona otros tipos de datos "
"específicos de Windows, por ejemplo :c:type:`HWND`, :c:type:`WPARAM`, o :c:"
"type:`DWORD`. Algunas estructuras útiles como :c:type:`MSG` o :c:type:`RECT` "
"también están definidas."

#: ../Doc/library/ctypes.rst:2451
msgid "Structured data types"
msgstr "Tipos de datos estructurados"

#: ../Doc/library/ctypes.rst:2456
msgid "Abstract base class for unions in native byte order."
msgstr "Clase base abstracta para uniones en orden de bytes nativos."

#: ../Doc/library/ctypes.rst:2461
msgid "Abstract base class for unions in *big endian* byte order."
msgstr "Clase base abstracta para uniones en orden de bytes *big endian*."

#: ../Doc/library/ctypes.rst:2467
msgid "Abstract base class for unions in *little endian* byte order."
msgstr "Clase base abstracta para uniones en orden de bytes *little endian*."

#: ../Doc/library/ctypes.rst:2473
msgid "Abstract base class for structures in *big endian* byte order."
msgstr "Clase base abstracta para estructuras en orden de bytes *big endian*."

#: ../Doc/library/ctypes.rst:2478
msgid "Abstract base class for structures in *little endian* byte order."
msgstr ""
"Clase base abstracta para estructuras en orden de bytes *little endian*."

#: ../Doc/library/ctypes.rst:2480
msgid ""
"Structures and unions with non-native byte order cannot contain pointer type "
"fields, or any other data types containing pointer type fields."
msgstr ""
"Las estructuras y uniones con un orden de bytes no nativo no pueden contener "
"campos de tipo puntero ni ningún otro tipo de datos que contenga campos de "
"tipo puntero."

#: ../Doc/library/ctypes.rst:2486
msgid "Abstract base class for structures in *native* byte order."
msgstr "Clase base abstracta para estructuras en orden de bytes *native*."

#: ../Doc/library/ctypes.rst:2488
msgid ""
"Concrete structure and union types must be created by subclassing one of "
"these types, and at least define a :attr:`_fields_` class variable. :mod:"
"`ctypes` will create :term:`descriptor`\\s which allow reading and writing "
"the fields by direct attribute accesses.  These are the"
msgstr ""
"La estructura concreta y los tipos de unión deben crearse subclasificando "
"uno de estos tipos, y al menos definir una variable de clase :attr:"
"`_fields_`. :mod:`ctypes` creará :term:`descriptor`\\s que permitan leer y "
"escribir los campos por accesos directos de atributos. Estos son los"

#: ../Doc/library/ctypes.rst:2496
msgid ""
"A sequence defining the structure fields.  The items must be 2-tuples or 3-"
"tuples.  The first item is the name of the field, the second item specifies "
"the type of the field; it can be any ctypes data type."
msgstr ""
"Una secuencia que define los campos de estructura. Los elementos deben ser "
"de 2 o 3 tuplas. El primer ítem es el nombre del campo, el segundo ítem "
"especifica el tipo de campo; puede ser cualquier tipo de datos ctypes."

#: ../Doc/library/ctypes.rst:2500
msgid ""
"For integer type fields like :class:`c_int`, a third optional item can be "
"given.  It must be a small positive integer defining the bit width of the "
"field."
msgstr ""
"Para los campos de tipo entero como :class:`c_int`, se puede dar un tercer "
"elemento opcional. Debe ser un pequeño entero positivo que defina el ancho "
"de bit del campo."

#: ../Doc/library/ctypes.rst:2504
msgid ""
"Field names must be unique within one structure or union.  This is not "
"checked, only one field can be accessed when names are repeated."
msgstr ""
"Los nombres de los campos deben ser únicos dentro de una estructura o unión. "
"Esto no se comprueba, sólo se puede acceder a un campo cuando los nombres se "
"repiten."

#: ../Doc/library/ctypes.rst:2507
msgid ""
"It is possible to define the :attr:`_fields_` class variable *after* the "
"class statement that defines the Structure subclass, this allows creating "
"data types that directly or indirectly reference themselves::"
msgstr ""
"Es posible definir la variable de clase :attr:`_fields_` *después* de la "
"sentencia de clase que define la subclase Estructura, esto permite crear "
"tipos de datos que se refieren directa o indirectamente a sí mismos::"

#: ../Doc/library/ctypes.rst:2517
msgid ""
"The :attr:`_fields_` class variable must, however, be defined before the "
"type is first used (an instance is created, :func:`sizeof` is called on it, "
"and so on).  Later assignments to the :attr:`_fields_` class variable will "
"raise an AttributeError."
msgstr ""
"Sin embargo, la variable de clase :attr:`_fields_` debe ser definida antes "
"de que el tipo sea usado por primera vez (se crea una instancia, se llama a :"
"func:`sizeof`, y así sucesivamente). Las asignaciones posteriores a la "
"variable de clase :attr:`_fields_` lanzarán un AttributeError."

#: ../Doc/library/ctypes.rst:2522
msgid ""
"It is possible to define sub-subclasses of structure types, they inherit the "
"fields of the base class plus the :attr:`_fields_` defined in the sub-"
"subclass, if any."
msgstr ""
"Es posible definir subclases de tipos de estructura, que heredan los campos "
"de la clase base más el :attr:`_fields_` definido en la subclase, si existe."

#: ../Doc/library/ctypes.rst:2529
#, fuzzy
msgid ""
"An optional small integer that allows overriding the alignment of structure "
"fields in the instance.  :attr:`_pack_` must already be defined when :attr:"
"`_fields_` is assigned, otherwise it will have no effect. Setting this "
"attribute to 0 is the same as not setting it at all."
msgstr ""
"Un pequeño entero opcional que permite anular la alineación de los campos de "
"estructura en la instancia. :attr:`_pack_` ya debe estar definido cuando se "
"asigna :attr:`_fields_`, de lo contrario no tendrá ningún efecto."

#: ../Doc/library/ctypes.rst:2537
msgid ""
"An optional sequence that lists the names of unnamed (anonymous) fields. :"
"attr:`_anonymous_` must be already defined when :attr:`_fields_` is "
"assigned, otherwise it will have no effect."
msgstr ""
"Una secuencia opcional que enumera los nombres de los campos sin nombre "
"(anónimos). :attr:`_anonymous_` debe estar ya definida cuando se asigna :"
"attr:`_fields_`, de lo contrario no tendrá ningún efecto."

#: ../Doc/library/ctypes.rst:2541
msgid ""
"The fields listed in this variable must be structure or union type fields. :"
"mod:`ctypes` will create descriptors in the structure type that allows "
"accessing the nested fields directly, without the need to create the "
"structure or union field."
msgstr ""
"Los campos listados en esta variable deben ser campos de tipo estructura o "
"unión. :mod:`ctypes` creará descriptores en el tipo de estructura que "
"permitan acceder a los campos anidados directamente, sin necesidad de crear "
"el campo de estructura o unión."

#: ../Doc/library/ctypes.rst:2546
msgid "Here is an example type (Windows)::"
msgstr "Aquí hay un tipo de ejemplo (Windows)::"

#: ../Doc/library/ctypes.rst:2559
msgid ""
"The ``TYPEDESC`` structure describes a COM data type, the ``vt`` field "
"specifies which one of the union fields is valid.  Since the ``u`` field is "
"defined as anonymous field, it is now possible to access the members "
"directly off the TYPEDESC instance. ``td.lptdesc`` and ``td.u.lptdesc`` are "
"equivalent, but the former is faster since it does not need to create a "
"temporary union instance::"
msgstr ""
"La estructura ``TYPEDESC`` describe un tipo de datos COM, el campo ``vt`` "
"especifica cuál de los campos de unión es válido. Como el campo ``u`` está "
"definido como campo anónimo, ahora es posible acceder a los miembros "
"directamente desde la instancia TYPEDESC. ``td.lptdesc`` y ``td.u.lptdesc`` "
"son equivalentes, pero el primero es más rápido ya que no necesita crear una "
"instancia de unión temporal::"

#: ../Doc/library/ctypes.rst:2571
msgid ""
"It is possible to define sub-subclasses of structures, they inherit the "
"fields of the base class.  If the subclass definition has a separate :attr:"
"`_fields_` variable, the fields specified in this are appended to the fields "
"of the base class."
msgstr ""
"Es posible definir subclases de estructuras, que heredan los campos de la "
"clase base. Si la definición de la subclase tiene una variable :attr:"
"`_fields_` separada, los campos especificados en ella se añaden a los campos "
"de la clase base."

#: ../Doc/library/ctypes.rst:2576
msgid ""
"Structure and union constructors accept both positional and keyword "
"arguments.  Positional arguments are used to initialize member fields in the "
"same order as they are appear in :attr:`_fields_`.  Keyword arguments in the "
"constructor are interpreted as attribute assignments, so they will "
"initialize :attr:`_fields_` with the same name, or create new attributes for "
"names not present in :attr:`_fields_`."
msgstr ""
"Los constructores de estructuras y uniones aceptan tanto argumentos "
"posicionales como de palabras clave. Los argumentos posicionales se usan "
"para inicializar los campos de los miembros en el mismo orden en que "
"aparecen en :attr:`_fields_`. Los argumentos de palabras clave en el "
"constructor se interpretan como asignaciones de atributos, por lo que "
"inicializarán :attr:`_fields_` con el mismo nombre, o crearán nuevos "
"atributos para nombres no presentes en :attr:`_fields_`."

#: ../Doc/library/ctypes.rst:2587
msgid "Arrays and pointers"
msgstr "Arreglos y punteros"

#: ../Doc/library/ctypes.rst:2591
msgid "Abstract base class for arrays."
msgstr "Clase base abstracta para arreglos."

#: ../Doc/library/ctypes.rst:2593
msgid ""
"The recommended way to create concrete array types is by multiplying any :"
"mod:`ctypes` data type with a non-negative integer.  Alternatively, you can "
"subclass this type and define :attr:`_length_` and :attr:`_type_` class "
"variables. Array elements can be read and written using standard subscript "
"and slice accesses; for slice reads, the resulting object is *not* itself "
"an :class:`Array`."
msgstr ""
"La forma recomendada de crear tipos de arreglos concretos es multiplicando "
"cualquier tipo de datos :mod:`ctypes` con un número entero no negativo. Como "
"alternativa, puede subclasificar este tipo y definir variables de clase :"
"attr:`_length_` y :attr:`_type_`. Los elementos del arreglo se pueden leer y "
"escribir utilizando subíndices estándar y accesos de segmento; para lecturas "
"de segmentos, el objeto resultante *no es* en sí mismo, un :class:`Array`."

#: ../Doc/library/ctypes.rst:2603
msgid ""
"A positive integer specifying the number of elements in the array. Out-of-"
"range subscripts result in an :exc:`IndexError`. Will be returned by :func:"
"`len`."
msgstr ""
"Un número entero positivo que especifica el número de elementos del "
"conjunto. Los subíndices fuera de rango dan como resultado un :exc:"
"`IndexError`. Será retornado por :func:`len`."

#: ../Doc/library/ctypes.rst:2610
msgid "Specifies the type of each element in the array."
msgstr "Especifica el tipo de cada elemento del arreglo."

#: ../Doc/library/ctypes.rst:2613
msgid ""
"Array subclass constructors accept positional arguments, used to initialize "
"the elements in order."
msgstr ""
"Los constructores de subclases de arreglos aceptan argumentos posicionales, "
"usados para inicializar los elementos en orden."

#: ../Doc/library/ctypes.rst:2619
msgid "Private, abstract base class for pointers."
msgstr "Clase base, privada y abstracta para punteros."

#: ../Doc/library/ctypes.rst:2621
msgid ""
"Concrete pointer types are created by calling :func:`POINTER` with the type "
"that will be pointed to; this is done automatically by :func:`pointer`."
msgstr ""
"Los tipos de punteros concretos se crean llamando a :func:`POINTER` con el "
"tipo que será apuntado; esto se hace automáticamente por :func:`pointer`."

#: ../Doc/library/ctypes.rst:2625
msgid ""
"If a pointer points to an array, its elements can be read and written using "
"standard subscript and slice accesses.  Pointer objects have no size, so :"
"func:`len` will raise :exc:`TypeError`.  Negative subscripts will read from "
"the memory *before* the pointer (as in C), and out-of-range subscripts will "
"probably crash with an access violation (if you're lucky)."
msgstr ""
"Si un puntero apunta a un arreglo, sus elementos pueden ser leídos y "
"escritos usando accesos de subíndices y cortes estándar. Los objetos "
"punteros no tienen tamaño, así que :func:`len` lanzará un :exc:`TypeError`. "
"Los subíndices negativos se leerán de la memoria *antes* que el puntero "
"(como en C), y los subíndices fuera de rango probablemente se bloqueen con "
"una violación de acceso (si tienes suerte)."

#: ../Doc/library/ctypes.rst:2635
msgid "Specifies the type pointed to."
msgstr "Especifica el tipo apuntado."

#: ../Doc/library/ctypes.rst:2639
msgid ""
"Returns the object to which to pointer points.  Assigning to this attribute "
"changes the pointer to point to the assigned object."
msgstr ""
"Retorna el objeto al que el puntero apunta. Asignando a este atributo cambia "
"el puntero para que apunte al objeto asignado."

#~ msgid ""
#~ "This example calls both functions with a ``NULL`` pointer (``None`` "
#~ "should be used as the ``NULL`` pointer)::"
#~ msgstr ""
#~ "Este ejemplo llama a ambas funciones con un puntero ``NULL`` (``None`` "
#~ "debe ser usado como el puntero ``NULL``)::"
