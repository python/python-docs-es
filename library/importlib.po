# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-10-16 21:42+0200\n"
"PO-Revision-Date: 2022-01-03 17:36-0500\n"
"Last-Translator: Adolfo Hristo David Roque Gámez <aroquega@gmail.com>\n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0\n"

#: ../Doc/library/importlib.rst:2
msgid ":mod:`!importlib` --- The implementation of :keyword:`!import`"
msgstr ":mod:`!importlib` --- La implementación de :keyword:`!import`"

#: ../Doc/library/importlib.rst:12
msgid "**Source code:** :source:`Lib/importlib/__init__.py`"
msgstr "**Código fuente:** :source:`Lib/importlib/__init__.py`"

#: ../Doc/library/importlib.rst:17
msgid "Introduction"
msgstr "Introducción"

#: ../Doc/library/importlib.rst:19
msgid ""
"The purpose of the :mod:`importlib` package is two-fold. One is to provide "
"the implementation of the :keyword:`import` statement (and thus, by "
"extension, the :func:`__import__` function) in Python source code. This "
"provides an implementation of :keyword:`!import` which is portable to any "
"Python interpreter. This also provides an implementation which is easier to "
"comprehend than one implemented in a programming language other than Python."
msgstr ""
"El propósito del paquete :mod:`importlib` es doble. Uno es proveer la "
"implementación de la declaración de :keyword:`import`, (y así, por "
"extensión, el método :func:`__import__` ) en el código fuente de Python. "
"Esto provee una implementación de la :keyword:`!import` la cual es "
"compatible con cualquier interprete de Python. También provee una "
"implementación que es más fácil de comprender que otras implementaciones, en "
"lenguajes diferentes a Python."

#: ../Doc/library/importlib.rst:26
msgid ""
"Two, the components to implement :keyword:`import` are exposed in this "
"package, making it easier for users to create their own custom objects "
"(known generically as an :term:`importer`) to participate in the import "
"process."
msgstr ""
"Dos, los componentes incluidos para implementar :keyword:`import`  están "
"expuestos en este paquete para que sea más fácil para los usuarios crear sus "
"propios objetos (conocidos de forma genérica como :term:`importer`) para "
"participar en el proceso de importación."

#: ../Doc/library/importlib.rst:33
msgid ":ref:`import`"
msgstr ":ref:`import`"

#: ../Doc/library/importlib.rst:33
msgid "The language reference for the :keyword:`import` statement."
msgstr "La referencia en el lenguaje para la declaración de :keyword:`import`."

#: ../Doc/library/importlib.rst:38
msgid ""
"`Packages specification <https://www.python.org/doc/essays/packages/>`__"
msgstr ""
"`Especificaciones de paquetes <https://www.python.org/doc/essays/packages/"
">`__"

#: ../Doc/library/importlib.rst:36
msgid ""
"Original specification of packages. Some semantics have changed since the "
"writing of this document (e.g. redirecting based on ``None`` in :data:`sys."
"modules`)."
msgstr ""
"Especificaciones originales de los paquetes. Algunas semánticas han cambiado "
"desde que este documento fue escrito (ejemplo, redirección de acuerdo a "
"``None`` en :data:`sys.modules`)."

#: ../Doc/library/importlib.rst:41
msgid "The :func:`.__import__` function"
msgstr "La función :func:`.__import__`"

#: ../Doc/library/importlib.rst:41
msgid "The :keyword:`import` statement is syntactic sugar for this function."
msgstr ""
"La declaración de :keyword:`import` es una decoración sintáctica para esta "
"función."

#: ../Doc/library/importlib.rst:44
msgid ":pep:`235`"
msgstr ":pep:`235`"

#: ../Doc/library/importlib.rst:44
msgid "Import on Case-Insensitive Platforms"
msgstr "Importar en sistemas que no distinguen entre mayúsculas y minúsculas"

#: ../Doc/library/importlib.rst:47
msgid ":pep:`263`"
msgstr ":pep:`263`"

#: ../Doc/library/importlib.rst:47
msgid "Defining Python Source Code Encodings"
msgstr "Definiendo las codificaciones del código fuente de Python"

#: ../Doc/library/importlib.rst:50
msgid ":pep:`302`"
msgstr ":pep:`302`"

#: ../Doc/library/importlib.rst:50
msgid "New Import Hooks"
msgstr "Nuevos ganchos de importación"

#: ../Doc/library/importlib.rst:53
msgid ":pep:`328`"
msgstr "pep:`328`"

#: ../Doc/library/importlib.rst:53
msgid "Imports: Multi-Line and Absolute/Relative"
msgstr "Importaciones: Multilíneas, y absolutos/relativos"

#: ../Doc/library/importlib.rst:56
msgid ":pep:`366`"
msgstr ":pep:`366`"

#: ../Doc/library/importlib.rst:56
msgid "Main module explicit relative imports"
msgstr "Importaciones relativas, explicitas, del módulo principal"

#: ../Doc/library/importlib.rst:59
msgid ":pep:`420`"
msgstr ":pep:`420`"

#: ../Doc/library/importlib.rst:59
msgid "Implicit namespace packages"
msgstr "Paquetes implícitos en el espacio de nombres"

#: ../Doc/library/importlib.rst:62
msgid ":pep:`451`"
msgstr ":pep:`451`"

#: ../Doc/library/importlib.rst:62
msgid "A ModuleSpec Type for the Import System"
msgstr "Un tipo de ModuleSpec para el sistema de importación"

#: ../Doc/library/importlib.rst:65
msgid ":pep:`488`"
msgstr ":pep:`488`"

#: ../Doc/library/importlib.rst:65
msgid "Elimination of PYO files"
msgstr "Eliminación de archivos PYO"

#: ../Doc/library/importlib.rst:68
msgid ":pep:`489`"
msgstr ":pep:`489`"

#: ../Doc/library/importlib.rst:68
msgid "Multi-phase extension module initialization"
msgstr "Inicialización de extensión de módulo en múltiples fases"

#: ../Doc/library/importlib.rst:71
msgid ":pep:`552`"
msgstr ":pep:`552`"

#: ../Doc/library/importlib.rst:71
msgid "Deterministic pycs"
msgstr "Pycs determinísticos"

#: ../Doc/library/importlib.rst:74
msgid ":pep:`3120`"
msgstr ":pep:`3120`"

#: ../Doc/library/importlib.rst:74
msgid "Using UTF-8 as the Default Source Encoding"
msgstr "Usando UTF-8 como la codificación fuente por defecto"

#: ../Doc/library/importlib.rst:76
msgid ":pep:`3147`"
msgstr ":pep:`3147`"

#: ../Doc/library/importlib.rst:77
msgid "PYC Repository Directories"
msgstr "Repositorio de directorios PYC"

#: ../Doc/library/importlib.rst:81
msgid "Functions"
msgstr "Funciones"

#: ../Doc/library/importlib.rst:85
msgid "An implementation of the built-in :func:`__import__` function."
msgstr "Una implementación de la función :func:`__import__` incorporada."

#: ../Doc/library/importlib.rst:88
msgid ""
"Programmatic importing of modules should use :func:`import_module` instead "
"of this function."
msgstr ""
"La importación programática los módulos debe usar :func:`import_module` en "
"lugar de esta función."

#: ../Doc/library/importlib.rst:93
msgid ""
"Import a module. The *name* argument specifies what module to import in "
"absolute or relative terms (e.g. either ``pkg.mod`` or ``..mod``). If the "
"name is specified in relative terms, then the *package* argument must be set "
"to the name of the package which is to act as the anchor for resolving the "
"package name (e.g. ``import_module('..mod', 'pkg.subpkg')`` will import "
"``pkg.mod``)."
msgstr ""
"Importar un módulo. El argumento llamado *name* especifica qué módulo "
"importar en términos absolutos o relativos (ejemplo, puede ser ``pkg.mod`` o "
"``..mod``). Si el nombre fuera especificado en términos relativos, entonces "
"el argumento llamado *package* debe ser igual al nombre del paquete que será "
"el ancla para resolver el nombre del paquete (ejemplo ``import_module('.."
"mod', 'pkg.subpkg')`` importará ``pkg.mod``)."

#: ../Doc/library/importlib.rst:101
msgid ""
"The :func:`import_module` function acts as a simplifying wrapper around :"
"func:`importlib.__import__`. This means all semantics of the function are "
"derived from :func:`importlib.__import__`. The most important difference "
"between these two functions is that :func:`import_module` returns the "
"specified package or module (e.g. ``pkg.mod``), while :func:`__import__` "
"returns the top-level package or module (e.g. ``pkg``)."
msgstr ""
"La función :func:`import_module` actúa como un envoltorio simplificador "
"alrededor de :func:`importlib.__import__`.  Esto quiere decir que las "
"semánticas de la función son derivadas de :func:`importlib.__import__`. La "
"diferencia más importante entre las dos funciones es que :func:"
"`import_module` retorna el paquete especificado o el módulo (ejemplo ``pkg."
"mod``), mientras que :func:`__import__` retorna el paquete o módulo del "
"nivel superior (ejemplo ``pkg``)."

#: ../Doc/library/importlib.rst:108
msgid ""
"If you are dynamically importing a module that was created since the "
"interpreter began execution (e.g., created a Python source file), you may "
"need to call :func:`invalidate_caches` in order for the new module to be "
"noticed by the import system."
msgstr ""
"Si está importando dinámicamente un módulo que se creó desde que el "
"intérprete comenzó la ejecución (por ejemplo, creó un archivo fuente de "
"Python), es posible que deba llamar a :func:`invalidate_caches` para que el "
"nuevo módulo sea detectado por el sistema de importación."

#: ../Doc/library/importlib.rst:113
msgid "Parent packages are automatically imported."
msgstr "Paquetes padres son importados automáticamente."

#: ../Doc/library/importlib.rst:118
msgid ""
"Find the loader for a module, optionally within the specified *path*. If the "
"module is in :attr:`sys.modules`, then ``sys.modules[name].__loader__`` is "
"returned (unless the loader would be ``None`` or is not set, in which case :"
"exc:`ValueError` is raised). Otherwise a search using :attr:`sys.meta_path` "
"is done. ``None`` is returned if no loader is found."
msgstr ""
"Encuentra el cargador de un módulo, opcionalmente con el especificado en "
"*path*.Si el módulo esta en :attr:`sys.modules`, entonces retorna el `sys."
"modules[name].__loader__`` (a menos que el cargador sea ``None`` o no haya "
"uno especificado, en tal caso se eleva un :exc:`ValueError`).Si no se "
"encuentra ahí, se hace una búsqueda usando :attr:`sys.meta_path`. Se retorna "
"``None`` si no se encuentra un cargador."

#: ../Doc/library/importlib.rst:124
msgid ""
"A dotted name does not have its parents implicitly imported as that requires "
"loading them and that may not be desired. To properly import a submodule you "
"will need to import all parent packages of the submodule and use the correct "
"argument to *path*."
msgstr ""
"Un nombre con puntos no tiene sus ascendientes importados implícitamente, ya "
"que eso requeriría cargarlo y eso podría no ser deseado. Para importar un "
"sub-módulo correctamente debes importar todos los paquetes ascendientes del "
"sub-módulo y pase el argumento correcto a *path*."

#: ../Doc/library/importlib.rst:131
msgid ""
"If ``__loader__`` is not set, raise :exc:`ValueError`, just like when the "
"attribute is set to ``None``."
msgstr ""
"Si el ``__loader__`` no está configurado, eleva un :exc:`ValueError`, igual "
"a si el atributo fuera ``None``."

#: ../Doc/library/importlib.rst:135
msgid "Use :func:`importlib.util.find_spec` instead."
msgstr "Utilice :func:`importlib.util.find_spec` en su lugar."

#: ../Doc/library/importlib.rst:140
msgid ""
"Invalidate the internal caches of finders stored at :data:`sys.meta_path`. "
"If a finder implements ``invalidate_caches()`` then it will be called to "
"perform the invalidation.  This function should be called if any modules are "
"created/installed while your program is running to guarantee all finders "
"will notice the new module's existence."
msgstr ""
"Invalide los cache internos de ubicadores encontrados en :data:`sys."
"meta_path`.Si un buscador implementa ``invalidate_caches()`` entonces será "
"llamado para realizar la invalidación.Esta función debe ser llamada si "
"cualquier módulo ha sido creado/instalado mientras tu programa esta siendo "
"ejecutado para garantizar que todos los buscadores noten la existencia del "
"nuevo módulo."

#: ../Doc/library/importlib.rst:150
msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (which can be different if re-importing "
"causes a different object to be placed in :data:`sys.modules`)."
msgstr ""
"Recarga un *modulo* previamente importado. El argumento debe ser un objeto "
"módulo, por lo que debe haber sido importado exitosamente. Esto es útil "
"cuando has editado el código fuente de un archivo usando un editor externo y "
"deseas probar la nueva versión sin abandonar el interprete de Python. El "
"valor retornado es el objeto módulo (que puede ser diferente si la "
"reimportación crea un nuevo objeto en :data:`sys.modules`)."

#: ../Doc/library/importlib.rst:157
msgid "When :func:`reload` is executed:"
msgstr "Cuando :func:`reload` es ejecutada:"

#: ../Doc/library/importlib.rst:159
msgid ""
"Python module's code is recompiled and the module-level code re-executed, "
"defining a new set of objects which are bound to names in the module's "
"dictionary by reusing the :term:`loader` which originally loaded the "
"module.  The ``init`` function of extension modules is not called a second "
"time."
msgstr ""
"El código de un módulo de Python es recompilado y el código del módulo "
"reejecutado, definiendo un nuevo conjunto de objetos que son asignados a los "
"nombres de los módulos en el diccionario, reusando el :term:`loader` que "
"originalmente carga los módulos. El método ``init`` de los módulos de "
"extension no es llamado de nuevo."

#: ../Doc/library/importlib.rst:165
msgid ""
"As with all other objects in Python the old objects are only reclaimed after "
"their reference counts drop to zero."
msgstr ""
"Al igual que con todos los demás objetos en Python, los objetos antiguos "
"solo se recuperan después de que sus recuentos de referencias caen a cero."

#: ../Doc/library/importlib.rst:168
msgid ""
"The names in the module namespace are updated to point to any new or changed "
"objects."
msgstr ""
"Los nombres en el espacio de nombres del módulo se actualizan para señalar "
"cualquier objeto nuevo o modificado."

#: ../Doc/library/importlib.rst:171
msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr ""
"Otras referencias a los objetos antiguos (como los nombres externos al "
"módulo) no se vuelven a vincular para hacer referencia a los nuevos objetos "
"y deben actualizarse en cada espacio de nombres donde se produzcan si se "
"desea."

#: ../Doc/library/importlib.rst:175
msgid "There are a number of other caveats:"
msgstr "Hay una serie de otras advertencias:"

#: ../Doc/library/importlib.rst:177
msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"Cuando se vuelve a cargar un módulo, se conserva su diccionario (que "
"contiene las variables globales del módulo). Las redefiniciones de nombres "
"anularán las antiguas definiciones, por lo que generalmente esto no es un "
"problema. Si la nueva versión de un módulo no define un nombre que fue "
"definido por la versión anterior, la definición anterior permanece. Esta "
"característica se puede utilizar en beneficio del módulo si mantiene una "
"tabla global o caché de objetos --- con una declaración :keyword:`try` puede "
"probar la presencia de la tabla y omitir su inicialización si lo desea:"

#: ../Doc/library/importlib.rst:191
msgid ""
"It is generally not very useful to reload built-in or dynamically loaded "
"modules.  Reloading :mod:`sys`, :mod:`__main__`, :mod:`builtins` and other "
"key modules is not recommended.  In many cases extension modules are not "
"designed to be initialized more than once, and may fail in arbitrary ways "
"when reloaded."
msgstr ""
"Por lo general, no es muy útil recargar módulos integrados o cargados "
"dinámicamente. No se recomienda recargar :mod:`sys`, :mod:`__main__`, :mod:"
"`builtins` y otros módulos clave. En muchos casos, los módulos de extensión "
"no están diseñados para inicializarse más de una vez y pueden fallar de "
"manera arbitraria cuando se vuelven a cargar."

#: ../Doc/library/importlib.rst:197
msgid ""
"If a module imports objects from another module using :keyword:`from` ... :"
"keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`!from` statement, another is to use :keyword:`!import` "
"and qualified names (*module.name*) instead."
msgstr ""
"Si un módulo importa objetos de otro módulo usando :keyword:`from` ... :"
"keyword:`import` ..., al llamar a :func:`reload` para el otro módulo no "
"redefine los objetos importados de él --- una forma de evitar esto es volver "
"a ejecutar la instrucción :keyword:`!from`, otra es usar :keyword:`!import` "
"y nombres calificados (*module.name*) en su lugar."

#: ../Doc/library/importlib.rst:203
msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr ""
"Si un módulo crea instancias de una clase, volver a cargar el módulo que "
"define la clase no afecta las definiciones de método de las instancias --- "
"continúan usando la definición de clase anterior. Lo mismo ocurre con las "
"clases derivadas."

#: ../Doc/library/importlib.rst:209
msgid ""
":exc:`ModuleNotFoundError` is raised when the module being reloaded lacks a :"
"class:`~importlib.machinery.ModuleSpec`."
msgstr ""
":exc:`ModuleNotFoundError` se lanza cuando el módulo que se está recargando "
"carece de :class:`~importlib.machinery.ModuleSpec`."

#: ../Doc/library/importlib.rst:215
msgid ":mod:`importlib.abc` -- Abstract base classes related to import"
msgstr ""
":mod:`importlib.abc` -- Clases base abstractas relacionadas con la "
"importación"

#: ../Doc/library/importlib.rst:220
msgid "**Source code:** :source:`Lib/importlib/abc.py`"
msgstr "**Código fuente:** :source:`Lib/importlib/abc.py`"

#: ../Doc/library/importlib.rst:225
msgid ""
"The :mod:`importlib.abc` module contains all of the core abstract base "
"classes used by :keyword:`import`. Some subclasses of the core abstract base "
"classes are also provided to help in implementing the core ABCs."
msgstr ""
"El módulo :mod:`importlib.abc` contiene todas las clases base abstractas "
"principales utilizadas por :keyword:`import`. También se proporcionan "
"algunas subclases de las clases base abstractas centrales para ayudar a "
"implementar los ABC centrales."

#: ../Doc/library/importlib.rst:229
msgid "ABC hierarchy::"
msgstr "Jerarquía ABC::"

#: ../Doc/library/importlib.rst:245
msgid "An abstract base class representing a :term:`finder`."
msgstr "Una clase base abstracta que representa :term:`finder`."

#: ../Doc/library/importlib.rst:247
msgid "Use :class:`MetaPathFinder` or :class:`PathEntryFinder` instead."
msgstr ""
"Utilice :class:`MetaPathFinder` o :class:`PathEntryFinder` en su lugar."

#: ../Doc/library/importlib.rst:252
msgid ""
"An abstract method for finding a :term:`loader` for the specified module.  "
"Originally specified in :pep:`302`, this method was meant for use in :data:"
"`sys.meta_path` and in the path-based import subsystem."
msgstr ""
"Un método abstracto para encontrar un :term:`loader` para el módulo "
"especificado. Originalmente especificado en :pep:`302`, este método estaba "
"destinado a ser utilizado en :data:`sys.meta_path` y en el subsistema de "
"importación basado en rutas."

#: ../Doc/library/importlib.rst:256
msgid ""
"Returns ``None`` when called instead of raising :exc:`NotImplementedError`."
msgstr ""
"Retorna ``None`` cuando se llama en lugar de generar :exc:"
"`NotImplementedError`."

#: ../Doc/library/importlib.rst:260
msgid ""
"Implement :meth:`MetaPathFinder.find_spec` or :meth:`PathEntryFinder."
"find_spec` instead."
msgstr ""
"Implemente :meth:`MetaPathFinder.find_spec` o :meth:`PathEntryFinder."
"find_spec` en su lugar."

#: ../Doc/library/importlib.rst:267
msgid ""
"An abstract base class representing a :term:`meta path finder`. For "
"compatibility, this is a subclass of :class:`Finder`."
msgstr ""
"Una clase base abstracta que representa un :term:`meta path finder`. Por "
"compatibilidad, esta es una subclase de :class:`Finder`."

#: ../Doc/library/importlib.rst:272 ../Doc/library/importlib.rst:327
msgid "No longer a subclass of :class:`Finder`."
msgstr "Ya no hereda de :class:`Finder`."

#: ../Doc/library/importlib.rst:277
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  If this is a top-level import, *path* will be ``None``.  "
"Otherwise, this is a search for a subpackage or module and *path* will be "
"the value of :attr:`__path__` from the parent package. If a spec cannot be "
"found, ``None`` is returned. When passed in, ``target`` is a module object "
"that the finder may use to make a more educated guess about what spec to "
"return. :func:`importlib.util.spec_from_loader` may be useful for "
"implementing concrete ``MetaPathFinders``."
msgstr ""
"Un método abstracto para encontrar un :term:`spec <module spec>` para el "
"módulo especificado. Si se trata de una importación de nivel superior, el "
"*path* será ``None``. De lo contrario, esta es una búsqueda de un subpaquete "
"o módulo y *path* será el valor de :attr:`__path__` del paquete principal. "
"Si no se puede encontrar una especificación, se retorna ``None``. Cuando se "
"pasa, ``target`` es un objeto de módulo que el buscador puede usar para "
"hacer una suposición más informada sobre qué especificación retornar. :func:"
"`importlib.util.spec_from_loader` puede ser útil para implementar "
"``MetaPathFinders`` concretos."

#: ../Doc/library/importlib.rst:291
msgid ""
"A legacy method for finding a :term:`loader` for the specified module.  If "
"this is a top-level import, *path* will be ``None``. Otherwise, this is a "
"search for a subpackage or module and *path* will be the value of :attr:"
"`__path__` from the parent package. If a loader cannot be found, ``None`` is "
"returned."
msgstr ""
"Un método heredado para encontrar un :term:`loader` para el módulo "
"especificado. Si se trata de una importación de nivel superior, el *path* "
"será ``None``. De lo contrario, esta es una búsqueda de un subpaquete o "
"módulo y *path* será el valor de :attr:`__path__` del paquete principal. Si "
"no se puede encontrar un cargador, se retorna ``None``."

#: ../Doc/library/importlib.rst:297
msgid ""
"If :meth:`find_spec` is defined, backwards-compatible functionality is "
"provided."
msgstr ""
"Si se define :meth:`find_spec`, se proporciona una funcionalidad compatible "
"con versiones anteriores."

#: ../Doc/library/importlib.rst:300
msgid ""
"Returns ``None`` when called instead of raising :exc:`NotImplementedError`. "
"Can use :meth:`find_spec` to provide functionality."
msgstr ""
"Retorna ``None`` cuando se llama en lugar de generar :exc:"
"`NotImplementedError`. Puede usar :meth:`find_spec` para proporcionar "
"funcionalidad."

#: ../Doc/library/importlib.rst:305 ../Doc/library/importlib.rst:361
#: ../Doc/library/importlib.rst:369 ../Doc/library/importlib.rst:1149
#: ../Doc/library/importlib.rst:1206
msgid "Use :meth:`find_spec` instead."
msgstr "Use :meth:`find_spec` en su lugar."

#: ../Doc/library/importlib.rst:310
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :func:`importlib.invalidate_caches` when "
"invalidating the caches of all finders on :data:`sys.meta_path`."
msgstr ""
"Un método opcional que, cuando se llama, debería invalidar cualquier caché "
"interno utilizado por el buscador. Utilizado por :func:`importlib."
"invalidate_caches` al invalidar los cachés de todos los buscadores en :data:"
"`sys.meta_path`."

#: ../Doc/library/importlib.rst:314
msgid "Returns ``None`` when called instead of ``NotImplemented``."
msgstr "Retorna ``None`` cuando se llama en lugar de ``NotImplemented``."

#: ../Doc/library/importlib.rst:320
msgid ""
"An abstract base class representing a :term:`path entry finder`.  Though it "
"bears some similarities to :class:`MetaPathFinder`, ``PathEntryFinder`` is "
"meant for use only within the path-based import subsystem provided by :class:"
"`importlib.machinery.PathFinder`."
msgstr ""
"Una clase base abstracta que representa un :term:`buscador de entradas de "
"ruta <path entry finder>`. Aunque tiene algunas similitudes con :class:"
"`MetaPathFinder`, ``PathEntryFinder`` está diseñado para usarse solo dentro "
"del subsistema de importación basado en rutas proporcionado por :class:"
"`importlib.machinery.PathFinder`."

#: ../Doc/library/importlib.rst:332
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  The finder will search for the module only within the :"
"term:`path entry` to which it is assigned.  If a spec cannot be found, "
"``None`` is returned.  When passed in, ``target`` is a module object that "
"the finder may use to make a more educated guess about what spec to return. :"
"func:`importlib.util.spec_from_loader` may be useful for implementing "
"concrete ``PathEntryFinders``."
msgstr ""
"Un método abstracto para encontrar un :term:`spec <module spec>` para el "
"módulo especificado. El buscador buscará el módulo solo dentro del :term:"
"`path entry` a la que está asignado. Si no se puede encontrar una "
"especificación, se retorna ``None``. Cuando se pasa, ``target`` es un objeto "
"de módulo que el buscador puede usar para hacer una suposición más informada "
"sobre qué especificación retornar. :func:`importlib.util.spec_from_loader` "
"puede ser útil para implementar ``PathEntryFinders`` concretos."

#: ../Doc/library/importlib.rst:344
msgid ""
"A legacy method for finding a :term:`loader` for the specified module.  "
"Returns a 2-tuple of ``(loader, portion)`` where ``portion`` is a sequence "
"of file system locations contributing to part of a namespace package. The "
"loader may be ``None`` while specifying ``portion`` to signify the "
"contribution of the file system locations to a namespace package. An empty "
"list can be used for ``portion`` to signify the loader is not part of a "
"namespace package. If ``loader`` is ``None`` and ``portion`` is the empty "
"list then no loader or location for a namespace package were found (i.e. "
"failure to find anything for the module)."
msgstr ""
"Un método heredado para encontrar un :term:`loader` para el módulo "
"especificado. Retorna una tupla de 2 de ``(loader, portion)`` donde "
"``portion`` es una secuencia de ubicaciones del sistema de archivos que "
"contribuyen a parte de un paquete de espacio de nombres. El cargador puede "
"ser ``None`` mientras se especifica ``portion`` para indicar la contribución "
"de las ubicaciones del sistema de archivos a un paquete de espacio de "
"nombres. Se puede usar una lista vacía para ``portion`` para indicar que el "
"cargador no es parte de un paquete de espacio de nombres. Si ``loader`` es "
"``None`` y ``portion`` es la lista vacía, entonces no se encontró ningún "
"cargador o ubicación para un paquete de espacio de nombres (es decir, no se "
"pudo encontrar nada para el módulo)."

#: ../Doc/library/importlib.rst:354
msgid ""
"If :meth:`find_spec` is defined then backwards-compatible functionality is "
"provided."
msgstr ""
"Si se define :meth:`find_spec`, se proporciona una funcionalidad compatible "
"con versiones anteriores."

#: ../Doc/library/importlib.rst:357
msgid ""
"Returns ``(None, [])`` instead of raising :exc:`NotImplementedError`. Uses :"
"meth:`find_spec` when available to provide functionality."
msgstr ""
"Retorna ``(None, [])`` en lugar de lanzar :exc:`NotImplementedError`. Usa :"
"meth:`find_spec` cuando está disponible para proporcionar funcionalidad."

#: ../Doc/library/importlib.rst:366
msgid ""
"A concrete implementation of :meth:`Finder.find_module` which is equivalent "
"to ``self.find_loader(fullname)[0]``."
msgstr ""
"Una implementación concreta de :meth:`Finder.find_module` que es equivalente "
"a ``self.find_loader(fullname)[0]``."

#: ../Doc/library/importlib.rst:374
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :meth:`importlib.machinery.PathFinder."
"invalidate_caches` when invalidating the caches of all cached finders."
msgstr ""
"Un método opcional que, cuando se llama, debería invalidar cualquier caché "
"interno utilizado por el buscador. Usado por :meth:`importlib.machinery."
"PathFinder.invalidate_caches` al invalidar las cachés de todos los "
"buscadores en caché."

#: ../Doc/library/importlib.rst:382
msgid ""
"An abstract base class for a :term:`loader`. See :pep:`302` for the exact "
"definition for a loader."
msgstr ""
"Una clase base abstracta para un :term:`loader`. Consulte :pep:`302` para "
"obtener la definición exacta de cargador."

#: ../Doc/library/importlib.rst:385 ../Doc/library/importlib.rst:870
msgid ""
"Loaders that wish to support resource reading should implement a "
"``get_resource_reader(fullname)`` method as specified by :class:`importlib."
"abc.ResourceReader`."
msgstr ""
"Los cargadores que deseen admitir la lectura de recursos deben implementar "
"un método ``get_resource_reader(fullname)`` según lo especificado por :class:"
"`importlib.abc.ResourceReader`."

#: ../Doc/library/importlib.rst:389
msgid "Introduced the optional ``get_resource_reader()`` method."
msgstr "Introdujo el método opcional ``get_resource_reader()``."

#: ../Doc/library/importlib.rst:394
msgid ""
"A method that returns the module object to use when importing a module.  "
"This method may return ``None``, indicating that default module creation "
"semantics should take place."
msgstr ""
"Un método que retorna el objeto de módulo que se utilizará al importar un "
"módulo. Este método puede retornar ``None``, lo que indica que se debe "
"llevar a cabo la semántica de creación de módulos predeterminada."

#: ../Doc/library/importlib.rst:400
msgid ""
"Starting in Python 3.6, this method will not be optional when :meth:"
"`exec_module` is defined."
msgstr ""
"A partir de Python 3.6, este método no será opcional cuando se defina :meth:"
"`exec_module`."

#: ../Doc/library/importlib.rst:406
msgid ""
"An abstract method that executes the module in its own namespace when a "
"module is imported or reloaded.  The module should already be initialized "
"when ``exec_module()`` is called. When this method exists, :meth:`~importlib."
"abc.Loader.create_module` must be defined."
msgstr ""
"Un método abstracto que ejecuta el módulo en su propio espacio de nombres "
"cuando se importa o se vuelve a cargar un módulo. El módulo ya debería estar "
"inicializado cuando se llama a ``exec_module()``. Cuando existe este método, "
"se debe definir :meth:`~importlib.abc.Loader.create_module`."

#: ../Doc/library/importlib.rst:413
msgid ":meth:`~importlib.abc.Loader.create_module` must also be defined."
msgstr ":meth:`~importlib.abc.Loader.create_module` también debe definirse."

#: ../Doc/library/importlib.rst:418
msgid ""
"A legacy method for loading a module. If the module cannot be loaded, :exc:"
"`ImportError` is raised, otherwise the loaded module is returned."
msgstr ""
"Un método heredado para cargar un módulo. Si el módulo no se puede cargar, "
"se lanza :exc:`ImportError`; de lo contrario, se retorna el módulo cargado."

#: ../Doc/library/importlib.rst:422
msgid ""
"If the requested module already exists in :data:`sys.modules`, that module "
"should be used and reloaded. Otherwise the loader should create a new module "
"and insert it into :data:`sys.modules` before any loading begins, to prevent "
"recursion from the import. If the loader inserted a module and the load "
"fails, it must be removed by the loader from :data:`sys.modules`; modules "
"already in :data:`sys.modules` before the loader began execution should be "
"left alone (see :func:`importlib.util.module_for_loader`)."
msgstr ""
"Si el módulo solicitado ya existe en :data:`sys.modules`, ese módulo debe "
"usarse y recargarse. De lo contrario, el cargador debe crear un nuevo módulo "
"e insertarlo en :data:`sys.modules` antes de que comience la carga, para "
"evitar la recursividad de la importación. Si el cargador insertó un módulo y "
"la carga falla, el cargador debe eliminarlo de :data:`sys.modules`; los "
"módulos que ya están en :data:`sys.modules` antes de que el cargador "
"comenzara a ejecutarse deben dejarse en paz (ver :func:`importlib.util."
"module_for_loader`)."

#: ../Doc/library/importlib.rst:431
msgid ""
"The loader should set several attributes on the module. (Note that some of "
"these attributes can change when a module is reloaded):"
msgstr ""
"El cargador debe establecer varios atributos en el módulo. (Tenga en cuenta "
"que algunos de estos atributos pueden cambiar cuando se recarga un módulo):"

#: ../Doc/library/importlib.rst:436
msgid ":attr:`__name__`"
msgstr ":attr:`__name__`"

#: ../Doc/library/importlib.rst:436
msgid "The name of the module."
msgstr "El nombre del módulo."

#: ../Doc/library/importlib.rst:440
msgid ":attr:`__file__`"
msgstr ":attr:`__file__`"

#: ../Doc/library/importlib.rst:439
msgid ""
"The path to where the module data is stored (not set for built-in modules)."
msgstr ""
"La ruta hacia donde se almacenan los datos del módulo (no configurada para "
"módulos integrados)."

#: ../Doc/library/importlib.rst:444
msgid ":attr:`__cached__`"
msgstr ":attr:`__cached__`"

#: ../Doc/library/importlib.rst:443
msgid ""
"The path to where a compiled version of the module is/should be stored (not "
"set when the attribute would be inappropriate)."
msgstr ""
"La ruta a la que se debe almacenar una versión compilada del módulo (no se "
"establece cuando el atributo sería inapropiado)."

#: ../Doc/library/importlib.rst:448
msgid ":attr:`__path__`"
msgstr ":attr:`__path__`"

#: ../Doc/library/importlib.rst:447
msgid ""
"A list of strings specifying the search path within a package. This "
"attribute is not set on modules."
msgstr ""
"Una lista de cadenas de caracteres que especifican la ruta de búsqueda "
"dentro de un paquete. Este atributo no se establece en módulos."

#: ../Doc/library/importlib.rst:455
msgid ":attr:`__package__`"
msgstr ":attr:`__package__`"

#: ../Doc/library/importlib.rst:451
msgid ""
"The fully-qualified name of the package under which the module was loaded as "
"a submodule (or the empty string for top-level modules). For packages, it is "
"the same as :attr:`__name__`.  The :func:`importlib.util.module_for_loader` "
"decorator can handle the details for :attr:`__package__`."
msgstr ""
"El nombre completo del paquete bajo el cual se cargó el módulo como "
"submódulo (o la cadena de caracteres vacía para los módulos de nivel "
"superior). Para los paquetes, es lo mismo que :attr:`__name__`. El "
"decorador :func:`importlib.util.module_for_loader` puede manejar los "
"detalles de :attr:`__package__`."

#: ../Doc/library/importlib.rst:460
msgid ":attr:`__loader__`"
msgstr ":attr:`__loader__`"

#: ../Doc/library/importlib.rst:458
msgid ""
"The loader used to load the module. The :func:`importlib.util."
"module_for_loader` decorator can handle the details for :attr:`__package__`."
msgstr ""
"El cargador utilizado para cargar el módulo. El decorador :func:`importlib."
"util.module_for_loader` puede manejar los detalles de :attr:`__package__`."

#: ../Doc/library/importlib.rst:462
msgid ""
"When :meth:`exec_module` is available then backwards-compatible "
"functionality is provided."
msgstr ""
"Cuando :meth:`exec_module` está disponible, se proporciona una funcionalidad "
"compatible con versiones anteriores."

#: ../Doc/library/importlib.rst:465
msgid ""
"Raise :exc:`ImportError` when called instead of :exc:`NotImplementedError`. "
"Functionality provided when :meth:`exec_module` is available."
msgstr ""
"Lanza :exc:`ImportError` cuando se llama en lugar de :exc:"
"`NotImplementedError`. Funcionalidad proporcionada cuando :meth:"
"`exec_module` está disponible."

#: ../Doc/library/importlib.rst:470
msgid ""
"The recommended API for loading a module is :meth:`exec_module` (and :meth:"
"`create_module`).  Loaders should implement it instead of load_module().  "
"The import machinery takes care of all the other responsibilities of "
"load_module() when exec_module() is implemented."
msgstr ""
"La API recomendada para cargar un módulo es :meth:`exec_module` (y :meth:"
"`create_module`). Los cargadores deberían implementarlo en lugar de "
"load_module(). La maquinaria de importación se encarga de todas las demás "
"responsabilidades de load_module() cuando se implementa exec_module()."

#: ../Doc/library/importlib.rst:479
msgid ""
"A legacy method which when implemented calculates and returns the given "
"module's repr, as a string. The module type's default repr() will use the "
"result of this method as appropriate."
msgstr ""
"Un método heredado que, cuando se implementa, calcula y retorna la repr del "
"módulo dado, como una cadena. El repr() predeterminado del tipo de módulo "
"utilizará el resultado de este método según corresponda."

#: ../Doc/library/importlib.rst:485
msgid "Made optional instead of an abstractmethod."
msgstr "Hecho opcional en vez de un método abstracto (*abstractmethod*)"

#: ../Doc/library/importlib.rst:488
msgid "The import machinery now takes care of this automatically."
msgstr "La maquinaria de importación ahora se encarga de esto automáticamente."

#: ../Doc/library/importlib.rst:494
msgid "*Superseded by TraversableResources*"
msgstr "*Reemplazada por TraversableResources*"

#: ../Doc/library/importlib.rst:496
msgid ""
"An :term:`abstract base class` to provide the ability to read *resources*."
msgstr ""
"Un :term:`abstract base class` para proporcionar la capacidad de leer "
"*resources*."

#: ../Doc/library/importlib.rst:499
msgid ""
"From the perspective of this ABC, a *resource* is a binary artifact that is "
"shipped within a package. Typically this is something like a data file that "
"lives next to the ``__init__.py`` file of the package. The purpose of this "
"class is to help abstract out the accessing of such data files so that it "
"does not matter if the package and its data file(s) are stored in a e.g. zip "
"file versus on the file system."
msgstr ""
"Desde la perspectiva de este ABC, un *resource* es un artefacto binario que "
"se envía dentro de un paquete. Por lo general, esto es algo así como un "
"archivo de datos que se encuentra junto al archivo ``__init__.py`` del "
"paquete. El propósito de esta clase es ayudar a abstraer el acceso a dichos "
"archivos de datos de modo que no importe si el paquete y sus archivos de "
"datos se almacenan en un, por ejemplo, zip en comparación con el sistema de "
"archivos."

#: ../Doc/library/importlib.rst:507
msgid ""
"For any of methods of this class, a *resource* argument is expected to be a :"
"term:`path-like object` which represents conceptually just a file name. This "
"means that no subdirectory paths should be included in the *resource* "
"argument. This is because the location of the package the reader is for, "
"acts as the \"directory\". Hence the metaphor for directories and file names "
"is packages and resources, respectively. This is also why instances of this "
"class are expected to directly correlate to a specific package (instead of "
"potentially representing multiple packages or a module)."
msgstr ""
"Para cualquiera de los métodos de esta clase, se espera que un argumento "
"*resource* sea un :term:`path-like object` que representa conceptualmente "
"solo un nombre de archivo. Esto significa que no se deben incluir rutas de "
"subdirectorio en el argumento *resource*. Esto se debe a que la ubicación "
"del paquete para el que está ubicado el lector actúa como el \"directorio\". "
"Por lo tanto, la metáfora de los directorios y los nombres de los archivos "
"son los paquetes y los recursos, respectivamente. Esta es también la razón "
"por la que se espera que las instancias de esta clase se correlacionen "
"directamente con un paquete específico (en lugar de representar "
"potencialmente varios paquetes o un módulo)."

#: ../Doc/library/importlib.rst:518
msgid ""
"Loaders that wish to support resource reading are expected to provide a "
"method called ``get_resource_reader(fullname)`` which returns an object "
"implementing this ABC's interface. If the module specified by fullname is "
"not a package, this method should return :const:`None`. An object compatible "
"with this ABC should only be returned when the specified module is a package."
msgstr ""
"Se espera que los cargadores que deseen admitir la lectura de recursos "
"proporcionen un método llamado ``get_resource_reader(fullname)`` que retorna "
"un objeto que implementa la interfaz de este ABC. Si el módulo especificado "
"por fullname no es un paquete, este método debería devolver :const:`None`. "
"Un objeto compatible con este ABC solo debe retornarse cuando el módulo "
"especificado es un paquete."

#: ../Doc/library/importlib.rst:529
msgid ""
"Returns an opened, :term:`file-like object` for binary reading of the "
"*resource*."
msgstr ""
"Retorna un, :term:`file-like object` abierto para la lectura binaria del "
"*resource*."

#: ../Doc/library/importlib.rst:532
msgid "If the resource cannot be found, :exc:`FileNotFoundError` is raised."
msgstr ""
"Si no se puede encontrar el recurso, se lanza :exc:`FileNotFoundError`."

#: ../Doc/library/importlib.rst:537
msgid "Returns the file system path to the *resource*."
msgstr "Retorna la ruta del sistema de archivos al *resource*."

#: ../Doc/library/importlib.rst:539
msgid ""
"If the resource does not concretely exist on the file system, raise :exc:"
"`FileNotFoundError`."
msgstr ""
"Si el recurso no existe concretamente en el sistema de archivos, lanza :exc:"
"`FileNotFoundError`."

#: ../Doc/library/importlib.rst:544
msgid ""
"Returns ``True`` if the named *name* is considered a resource. :exc:"
"`FileNotFoundError` is raised if *name* does not exist."
msgstr ""
"Retorna ``True`` si el *name* nombrado se considera un recurso. :exc:"
"`FileNotFoundError` se lanza si *name* no existe."

#: ../Doc/library/importlib.rst:549
msgid ""
"Returns an :term:`iterable` of strings over the contents of the package. Do "
"note that it is not required that all names returned by the iterator be "
"actual resources, e.g. it is acceptable to return names for which :meth:"
"`is_resource` would be false."
msgstr ""
"Retorna un :term:`iterable` de cadenas de caracteres sobre el contenido del "
"paquete. Tenga en cuenta que no es necesario que todos los nombres "
"retornados por el iterador sean recursos reales, por ejemplo, es aceptable "
"retornar nombres para los que :meth:`is_resource` sería falso."

#: ../Doc/library/importlib.rst:555
msgid ""
"Allowing non-resource names to be returned is to allow for situations where "
"how a package and its resources are stored are known a priori and the non-"
"resource names would be useful. For instance, returning subdirectory names "
"is allowed so that when it is known that the package and resources are "
"stored on the file system then those subdirectory names can be used directly."
msgstr ""
"Al permitir que se retornen nombres que no son de recursos es para permitir "
"situaciones en las que se conoce a priori cómo se almacenan un paquete y sus "
"recursos y los nombres que no son de recursos serían útiles. Por ejemplo, se "
"permite el retorno de nombres de subdirectorios para que cuando se sepa que "
"el paquete y los recursos están almacenados en el sistema de archivos, esos "
"nombres de subdirectorios se puedan usar directamente."

#: ../Doc/library/importlib.rst:563
msgid "The abstract method returns an iterable of no items."
msgstr "El método abstracto retorna un iterable de ningún elemento."

#: ../Doc/library/importlib.rst:568
msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loading arbitrary resources from the storage back-end."
msgstr ""
"Una clase base abstracta para un :term:`loader` que implementa el protocolo "
"opcional :pep:`302` para cargar recursos arbitrarios desde el back-end de "
"almacenamiento."

#: ../Doc/library/importlib.rst:572
msgid ""
"This ABC is deprecated in favour of supporting resource loading through :"
"class:`importlib.abc.ResourceReader`."
msgstr ""
"Este ABC está en desuso a favor de admitir la carga de recursos a través de :"
"class:`importlib.abc.ResourceReader`."

#: ../Doc/library/importlib.rst:578
msgid ""
"An abstract method to return the bytes for the data located at *path*. "
"Loaders that have a file-like storage back-end that allows storing arbitrary "
"data can implement this abstract method to give direct access to the data "
"stored. :exc:`OSError` is to be raised if the *path* cannot be found. The "
"*path* is expected to be constructed using a module's :attr:`__file__` "
"attribute or an item from a package's :attr:`__path__`."
msgstr ""
"Un método abstracto para devolver los bytes de los datos ubicados en *path*. "
"Los cargadores que tienen un back-end de almacenamiento similar a un archivo "
"que permite almacenar datos arbitrarios pueden implementar este método "
"abstracto para dar acceso directo a los datos almacenados. :exc:`OSError` se "
"lanza si no se puede encontrar el *path*. Se espera que la *path* se "
"construya utilizando el atributo :attr:`__file__` de un módulo o un elemento "
"de un paquete :attr:`__path__`."

#: ../Doc/library/importlib.rst:586
msgid "Raises :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Lanza :exc:`OSError` en vez de :exc:`NotImplementedError`."

#: ../Doc/library/importlib.rst:592
msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loaders that inspect modules."
msgstr ""
"Una clase base abstracta para un :term:`loader` que implementa el protocolo "
"opcional :pep:`302` para cargadores que inspeccionan módulos."

#: ../Doc/library/importlib.rst:597
msgid ""
"Return the code object for a module, or ``None`` if the module does not have "
"a code object (as would be the case, for example, for a built-in module).  "
"Raise an :exc:`ImportError` if loader cannot find the requested module."
msgstr ""
"Retorna el objeto código para un módulo, o ``None`` si el módulo no tiene un "
"objeto código (como sería el caso, por ejemplo, para un módulo integrado). "
"Lanza un :exc:`ImportError` si el cargador no puede encontrar el módulo "
"solicitado."

#: ../Doc/library/importlib.rst:603
msgid ""
"While the method has a default implementation, it is suggested that it be "
"overridden if possible for performance."
msgstr ""
"Si bien el método tiene una implementación predeterminada, se sugiere que se "
"anule si es posible para mejorar el rendimiento."

#: ../Doc/library/importlib.rst:609
msgid "No longer abstract and a concrete implementation is provided."
msgstr ""
"Ya no es un método abstracto y se proporciona una implementación concreta."

#: ../Doc/library/importlib.rst:614
msgid ""
"An abstract method to return the source of a module. It is returned as a "
"text string using :term:`universal newlines`, translating all recognized "
"line separators into ``'\\n'`` characters.  Returns ``None`` if no source is "
"available (e.g. a built-in module). Raises :exc:`ImportError` if the loader "
"cannot find the module specified."
msgstr ""
"Un método abstracto para retornar la fuente de un módulo. Se retorna como "
"una cadena de caracteres de texto usando :term:`universal newlines`, "
"traduciendo todos los separadores de línea reconocidos en caracteres ``'\n"
"'``. Retorna ``None`` si no hay una fuente disponible (por ejemplo, un "
"módulo integrado). Lanza :exc:`ImportError` si el cargador no puede "
"encontrar el módulo especificado."

#: ../Doc/library/importlib.rst:620 ../Doc/library/importlib.rst:629
#: ../Doc/library/importlib.rst:679
msgid "Raises :exc:`ImportError` instead of :exc:`NotImplementedError`."
msgstr "Lanza :exc:`ImportError` en vez de :exc:`NotImplementedError`."

#: ../Doc/library/importlib.rst:625
msgid ""
"An optional method to return a true value if the module is a package, a "
"false value otherwise. :exc:`ImportError` is raised if the :term:`loader` "
"cannot find the module."
msgstr ""
"Un método opcional para retornar un valor verdadero si el módulo es un "
"paquete, un valor falso en caso contrario. Se lanza :exc:`ImportError` si "
"el :term:`cargador <loader>` no puede encontrar el módulo."

#: ../Doc/library/importlib.rst:634
msgid "Create a code object from Python source."
msgstr "Cree un objeto de código a partir de la fuente de Python."

#: ../Doc/library/importlib.rst:636
msgid ""
"The *data* argument can be whatever the :func:`compile` function supports (i."
"e. string or bytes). The *path* argument should be the \"path\" to where the "
"source code originated from, which can be an abstract concept (e.g. location "
"in a zip file)."
msgstr ""
"El argumento *data* puede ser cualquier cosa que admita la función :func:"
"`compile` (es decir, cadena de caracteres o bytes). El argumento *path* debe "
"ser la \"ruta\" de donde se originó el código fuente, que puede ser un "
"concepto abstracto (por ejemplo, ubicación en un archivo zip)."

#: ../Doc/library/importlib.rst:641
msgid ""
"With the subsequent code object one can execute it in a module by running "
"``exec(code, module.__dict__)``."
msgstr ""
"Con el objeto de código subsiguiente, uno puede ejecutarlo en un módulo "
"ejecutando ``exec(code, module.__dict__)``."

#: ../Doc/library/importlib.rst:646
msgid "Made the method static."
msgstr "Hace el método estático."

#: ../Doc/library/importlib.rst:651
msgid "Implementation of :meth:`Loader.exec_module`."
msgstr "Implementación de :meth:`Loader.exec_module`."

#: ../Doc/library/importlib.rst:657
msgid "Implementation of :meth:`Loader.load_module`."
msgstr "Implementación de :meth:`Loader.load_module`."

#: ../Doc/library/importlib.rst:659
msgid "use :meth:`exec_module` instead."
msgstr "use :meth:`exec_module` en su lugar."

#: ../Doc/library/importlib.rst:665
msgid ""
"An abstract base class which inherits from :class:`InspectLoader` that, when "
"implemented, helps a module to be executed as a script. The ABC represents "
"an optional :pep:`302` protocol."
msgstr ""
"Una clase base abstracta que hereda de :class:`InspectLoader` que, cuando se "
"implementa, ayuda a que un módulo se ejecute como un script. El ABC "
"representa un protocolo opcional :pep:`302`."

#: ../Doc/library/importlib.rst:671
msgid ""
"An abstract method that is to return the value of :attr:`__file__` for the "
"specified module. If no path is available, :exc:`ImportError` is raised."
msgstr ""
"Un método abstracto que retorna el valor de :attr:`__file__` para el módulo "
"especificado. Si no hay una ruta disponible, se lanza :exc:`ImportError`."

#: ../Doc/library/importlib.rst:675
msgid ""
"If source code is available, then the method should return the path to the "
"source file, regardless of whether a bytecode was used to load the module."
msgstr ""
"Si el código fuente está disponible, entonces el método debe devolver la "
"ruta al archivo fuente, independientemente de si se utilizó un código de "
"bytes para cargar el módulo."

#: ../Doc/library/importlib.rst:685
msgid ""
"An abstract base class which inherits from :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, providing concrete implementations of :meth:"
"`ResourceLoader.get_data` and :meth:`ExecutionLoader.get_filename`."
msgstr ""
"Una clase base abstracta que hereda de :class:`ResourceLoader` y :class:"
"`ExecutionLoader`, proporcionando implementaciones concretas de :meth:"
"`ResourceLoader.get_data` y :meth:`ExecutionLoader.get_filename`."

#: ../Doc/library/importlib.rst:689
msgid ""
"The *fullname* argument is a fully resolved name of the module the loader is "
"to handle. The *path* argument is the path to the file for the module."
msgstr ""
"El argumento *fullname* es un nombre completamente resuelto del módulo que "
"el cargador debe manejar. El argumento *path* es la ruta al archivo del "
"módulo."

#: ../Doc/library/importlib.rst:696
msgid "The name of the module the loader can handle."
msgstr "El nombre del módulo que puede manejar el cargador."

#: ../Doc/library/importlib.rst:700
msgid "Path to the file of the module."
msgstr "Ruta al archivo del módulo."

#: ../Doc/library/importlib.rst:704
msgid "Calls super's ``load_module()``."
msgstr "Llama a super's ``load_module()``."

#: ../Doc/library/importlib.rst:706
msgid "Use :meth:`Loader.exec_module` instead."
msgstr "Utilice :meth:`Loader.exec_module` en su lugar."

#: ../Doc/library/importlib.rst:711 ../Doc/library/importlib.rst:1351
msgid "Returns :attr:`path`."
msgstr "Retorna :attr:`path`."

#: ../Doc/library/importlib.rst:715
msgid "Reads *path* as a binary file and returns the bytes from it."
msgstr "Lee *path* como un archivo binario y devuelve los bytes de él."

#: ../Doc/library/importlib.rst:720
msgid ""
"An abstract base class for implementing source (and optionally bytecode) "
"file loading. The class inherits from both :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, requiring the implementation of:"
msgstr ""
"Una clase base abstracta para implementar la carga de archivos fuente (y "
"opcionalmente bytecode). La clase hereda tanto de :class:`ResourceLoader` "
"como de :class:`ExecutionLoader`, lo que requiere la implementación de:"

#: ../Doc/library/importlib.rst:724
msgid ":meth:`ResourceLoader.get_data`"
msgstr ":meth:`ResourceLoader.get_data`"

#: ../Doc/library/importlib.rst:727
msgid ":meth:`ExecutionLoader.get_filename`"
msgstr ":meth:`ExecutionLoader.get_filename`"

#: ../Doc/library/importlib.rst:726
msgid ""
"Should only return the path to the source file; sourceless loading is not "
"supported."
msgstr ""
"Solo debe devolver la ruta al archivo de origen; la carga sin fuente no es "
"compatible."

#: ../Doc/library/importlib.rst:729
msgid ""
"The abstract methods defined by this class are to add optional bytecode file "
"support. Not implementing these optional methods (or causing them to raise :"
"exc:`NotImplementedError`) causes the loader to only work with source code. "
"Implementing the methods allows the loader to work with source *and* "
"bytecode files; it does not allow for *sourceless* loading where only "
"bytecode is provided.  Bytecode files are an optimization to speed up "
"loading by removing the parsing step of Python's compiler, and so no "
"bytecode-specific API is exposed."
msgstr ""
"Los métodos abstractos definidos por esta clase son para agregar soporte de "
"archivo de código de bytes opcional. No implementar estos métodos opcionales "
"(o hacer que se lance :exc:`NotImplementedError`) hace que el cargador solo "
"funcione con el código fuente. La implementación de los métodos permite que "
"el cargador trabaje con archivos fuente *y* código de bytes; no permite la "
"carga *sin fuente* donde solo se proporciona un código de bytes. Los "
"archivos de código de bytes son una optimización para acelerar la carga al "
"eliminar el paso de análisis del compilador de Python, por lo que no se "
"expone ninguna API específica de código de bytes."

#: ../Doc/library/importlib.rst:740
msgid ""
"Optional abstract method which returns a :class:`dict` containing metadata "
"about the specified path.  Supported dictionary keys are:"
msgstr ""
"Método abstracto opcional que devuelve un :class:`dict` que contiene "
"metadatos sobre la ruta especificada. Las claves de diccionario admitidas "
"son:"

#: ../Doc/library/importlib.rst:743
msgid ""
"``'mtime'`` (mandatory): an integer or floating-point number representing "
"the modification time of the source code;"
msgstr ""
"``'mtime'`` (obligatorio): un número entero o de punto flotante que "
"representa la hora de modificación del código fuente;"

#: ../Doc/library/importlib.rst:745
msgid "``'size'`` (optional): the size in bytes of the source code."
msgstr "``'size'`` (opcional): el tamaño en bytes del código fuente."

#: ../Doc/library/importlib.rst:747
msgid ""
"Any other keys in the dictionary are ignored, to allow for future "
"extensions. If the path cannot be handled, :exc:`OSError` is raised."
msgstr ""
"Cualquier otra clave del diccionario se ignora para permitir futuras "
"extensiones. Si no se puede manejar la ruta, se genera :exc:`OSError`."

#: ../Doc/library/importlib.rst:752 ../Doc/library/importlib.rst:765
msgid "Raise :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Lanza :exc:`OSError` en vez de :exc:`NotImplementedError`."

#: ../Doc/library/importlib.rst:757
msgid ""
"Optional abstract method which returns the modification time for the "
"specified path."
msgstr ""
"Método abstracto opcional que retorna la hora de modificación de la ruta "
"especificada."

#: ../Doc/library/importlib.rst:760
msgid ""
"This method is deprecated in favour of :meth:`path_stats`.  You don't have "
"to implement it, but it is still available for compatibility purposes. "
"Raise :exc:`OSError` if the path cannot be handled."
msgstr ""
"Este método está obsoleto en favor de :meth:`path_stats`. No tiene que "
"implementarlo, pero aún está disponible para fines de compatibilidad. Lanza :"
"exc:`OSError` si la ruta no se puede manejar."

#: ../Doc/library/importlib.rst:770
msgid ""
"Optional abstract method which writes the specified bytes to a file path. "
"Any intermediate directories which do not exist are to be created "
"automatically."
msgstr ""
"Método abstracto opcional que escribe los bytes especificados en una ruta de "
"archivo. Los directorios intermedios que no existan se crearán "
"automáticamente."

#: ../Doc/library/importlib.rst:774
msgid ""
"When writing to the path fails because the path is read-only (:attr:`errno."
"EACCES`/:exc:`PermissionError`), do not propagate the exception."
msgstr ""
"Cuando la escritura en la ruta falla porque la ruta es de solo lectura (:"
"attr:`errno.EACCES`/:exc:`PermissionError`), no propague la excepción."

#: ../Doc/library/importlib.rst:778
msgid "No longer raises :exc:`NotImplementedError` when called."
msgstr "Ya no lanza :exc:`NotImplementedError` cuando se llama."

#: ../Doc/library/importlib.rst:783
msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
msgstr "Implementación concreta de :meth:`InspectLoader.get_code`."

#: ../Doc/library/importlib.rst:787
msgid "Concrete implementation of :meth:`Loader.exec_module`."
msgstr "Implementación concreta de :meth:`Loader.exec_module`."

#: ../Doc/library/importlib.rst:793
msgid "Concrete implementation of :meth:`Loader.load_module`."
msgstr "Implementación concreta de :meth:`Loader.load_module`."

#: ../Doc/library/importlib.rst:795
msgid "Use :meth:`exec_module` instead."
msgstr "Utilice :meth:`exec_module` en su lugar."

#: ../Doc/library/importlib.rst:800
msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
msgstr "Implementación concreta de :meth:`InspectLoader.get_source`."

#: ../Doc/library/importlib.rst:804
msgid ""
"Concrete implementation of :meth:`InspectLoader.is_package`. A module is "
"determined to be a package if its file path (as provided by :meth:"
"`ExecutionLoader.get_filename`) is a file named ``__init__`` when the file "
"extension is removed **and** the module name itself does not end in "
"``__init__``."
msgstr ""
"Implementación concreta de :meth:`InspectLoader.is_package`. Se determina "
"que un módulo es un paquete si su ruta de archivo (proporcionada por :meth:"
"`ExecutionLoader.get_filename`) es un archivo llamado ``__init__`` cuando se "
"elimina la extensión del archivo **y** el nombre del módulo sí lo hace no "
"termina en ``__init__``."

#: ../Doc/library/importlib.rst:813
msgid ""
"An object with a subset of pathlib.Path methods suitable for traversing "
"directories and opening files."
msgstr ""
"Un objeto con un subconjunto de métodos pathlib.Path adecuados para recorrer "
"directorios y abrir archivos."

#: ../Doc/library/importlib.rst:821
msgid ""
"An abstract base class for resource readers capable of serving the ``files`` "
"interface. Subclasses ResourceReader and provides concrete implementations "
"of the ResourceReader's abstract methods. Therefore, any loader supplying "
"TraversableReader also supplies ResourceReader."
msgstr ""
"Una clase base abstracta para lectores de recursos capaz de servir la "
"interfaz de ``files``. Subclases ResourceReader y proporciona "
"implementaciones concretas de los métodos abstractos de ResourceReader. Por "
"lo tanto, cualquier cargador que suministre TraversableReader también "
"suministra ResourceReader."

#: ../Doc/library/importlib.rst:827
msgid ""
"Loaders that wish to support resource reading are expected to implement this "
"interface."
msgstr ""
"Se espera que los cargadores que deseen admitir la lectura de recursos "
"implementen esta interfaz."

#: ../Doc/library/importlib.rst:834
msgid ":mod:`importlib.resources` -- Resources"
msgstr ":mod:`importlib.resources` -- Recursos"

#: ../Doc/library/importlib.rst:839
msgid "**Source code:** :source:`Lib/importlib/resources.py`"
msgstr "**Código fuente:** :source:`Lib/importlib/resources.py`"

#: ../Doc/library/importlib.rst:845
msgid ""
"This module leverages Python's import system to provide access to "
"*resources* within *packages*.  If you can import a package, you can access "
"resources within that package.  Resources can be opened or read, in either "
"binary or text mode."
msgstr ""
"Este módulo aprovecha el sistema de importación de Python para proporcionar "
"acceso a *resources* dentro de *packages*. Si puede importar un paquete, "
"puede acceder a los recursos dentro de ese paquete. Los recursos se pueden "
"abrir o leer, ya sea en modo binario o texto."

#: ../Doc/library/importlib.rst:850
msgid ""
"Resources are roughly akin to files inside directories, though it's "
"important to keep in mind that this is just a metaphor.  Resources and "
"packages **do not** have to exist as physical files and directories on the "
"file system."
msgstr ""
"Los recursos son similares a los archivos dentro de los directorios, aunque "
"es importante tener en cuenta que esto es solo una metáfora. Los recursos y "
"paquetes **no** tienen que existir como archivos y directorios físicos en el "
"sistema de archivos."

#: ../Doc/library/importlib.rst:856
msgid ""
"This module provides functionality similar to `pkg_resources <https://"
"setuptools.readthedocs.io/en/latest/pkg_resources.html>`_ `Basic Resource "
"Access <http://setuptools.readthedocs.io/en/latest/pkg_resources.html#basic-"
"resource-access>`_ without the performance overhead of that package.  This "
"makes reading resources included in packages easier, with more stable and "
"consistent semantics."
msgstr ""
"Este módulo proporciona una funcionalidad similar a `pkg_resources <https://"
"setuptools.readthedocs.io/en/latest/pkg_resources.html>`_ `Acceso Básico a "
"Recursos <http://setuptools.readthedocs.io/en/latest/pkg_resources. "
"html#basic-resource-access>`_ sin la sobrecarga de rendimiento de ese "
"paquete. Esto facilita la lectura de los recursos incluidos en los paquetes, "
"con una semántica más estable y coherente."

#: ../Doc/library/importlib.rst:864
msgid ""
"The standalone backport of this module provides more information on `using "
"importlib.resources <http://importlib-resources.readthedocs.io/en/latest/"
"using.html>`_ and `migrating from pkg_resources to importlib.resources "
"<http://importlib-resources.readthedocs.io/en/latest/migration.html>`_."
msgstr ""
"El backport independiente de este módulo proporciona más información sobre "
"`usar importlib.resources <http://importlib-resources.readthedocs.io/en/"
"latest/using.html>`_ y `migrar desde pkg_resources a importlib.resources "
"<http: //importlib-resources.readthedocs.io/en/latest/migration.html>`_."

#: ../Doc/library/importlib.rst:874
msgid "The following types are defined."
msgstr "Se definen los siguientes tipos."

#: ../Doc/library/importlib.rst:878
msgid ""
"The ``Package`` type is defined as ``Union[str, ModuleType]``.  This means "
"that where the function describes accepting a ``Package``, you can pass in "
"either a string or a module.  Module objects must have a resolvable "
"``__spec__.submodule_search_locations`` that is not ``None``."
msgstr ""
"El tipo ``Package`` se define como ``Union[str, ModuleType]``. Esto "
"significa que cuando la función describe la aceptación de un ``Package``, "
"puede pasar una cadena de caracteres o un módulo. Los objetos de módulo "
"deben tener un ``__spec__.submodule_search_locations`` que se pueda resolver "
"que no sea ``None``."

#: ../Doc/library/importlib.rst:885
msgid ""
"This type describes the resource names passed into the various functions in "
"this package.  This is defined as ``Union[str, os.PathLike]``."
msgstr ""
"Este tipo describe los nombres de los recursos que se pasan a las distintas "
"funciones de este paquete. Esto se define como ``Union[str, os.PathLike]``."

#: ../Doc/library/importlib.rst:889
msgid "The following functions are available."
msgstr "Están disponibles las siguientes funciones."

#: ../Doc/library/importlib.rst:894
msgid ""
"Returns an :class:`importlib.resources.abc.Traversable` object representing "
"the resource container for the package (think directory) and its resources "
"(think files). A Traversable may contain other containers (think "
"subdirectories)."
msgstr ""
"Retorna un objeto :class:`importlib.resources.abc.Traversable` que "
"representa el contenedor de recursos para el paquete (directorio think) y "
"sus recursos (archivos think). Un Traversable puede contener otros "
"contenedores (subdirectorios think)."

#: ../Doc/library/importlib.rst:899 ../Doc/library/importlib.rst:1000
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements."
msgstr ""
"*package* es un nombre o un objeto de módulo que cumple con los requisitos "
"de ``Package``."

#: ../Doc/library/importlib.rst:906
msgid ""
"Given a :class:`importlib.resources.abc.Traversable` object representing a "
"file, typically from :func:`importlib.resources.files`, return a context "
"manager for use in a :keyword:`with` statement. The context manager provides "
"a :class:`pathlib.Path` object."
msgstr ""
"Dado un objeto :class:`importlib.resources.abc.Traversable` que representa "
"un archivo, típicamente de :func:`importlib.resources.files`, retorna un "
"gestor de contexto para su uso en una sentencia :keyword:`with`. El gestor "
"de contexto proporciona un objeto :class:`pathlib.Path`."

#: ../Doc/library/importlib.rst:911
msgid ""
"Exiting the context manager cleans up any temporary file created when the "
"resource was extracted from e.g. a zip file."
msgstr ""
"Salir del gestor de contexto limpia cualquier archivo temporal creado cuando "
"se extrajo el recurso de, por ejemplo, un archivo zip."

#: ../Doc/library/importlib.rst:914
msgid ""
"Use ``as_file`` when the Traversable methods (``read_text``, etc) are "
"insufficient and an actual file on the file system is required."
msgstr ""
"Use ``as_file` cuando los métodos Traversable (``read_text``, etc) sean "
"insuficientes y se requiera un archivo real en el sistema de archivos."

#: ../Doc/library/importlib.rst:922
msgid "Open for binary reading the *resource* within *package*."
msgstr "Abra para lectura binaria el *resource* dentro del *package*."

#: ../Doc/library/importlib.rst:924
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open "
"within *package*; it may not contain path separators and it may not have sub-"
"resources (i.e. it cannot be a directory).  This function returns a ``typing."
"BinaryIO`` instance, a binary I/O stream open for reading."
msgstr ""
"*package* es un nombre o un objeto de módulo que cumple con los requisitos "
"de ``Package``. *resource* es el nombre del recurso a abrir dentro de "
"*package*; puede que no contenga separadores de ruta y puede que no tenga "
"sub-recursos (es decir, no puede ser un directorio). Esta función retorna "
"una instancia de ``typing.BinaryIO``, un flujo de E/S binario abierto para "
"lectura."

#: ../Doc/library/importlib.rst:933
msgid ""
"Open for text reading the *resource* within *package*.  By default, the "
"resource is opened for reading as UTF-8."
msgstr ""
"Se abre para leer el texto del *resource* dentro del *package*. De forma "
"predeterminada, el recurso está abierto para lectura como UTF-8."

#: ../Doc/library/importlib.rst:936
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open "
"within *package*; it may not contain path separators and it may not have sub-"
"resources (i.e. it cannot be a directory).  *encoding* and *errors* have the "
"same meaning as with built-in :func:`open`."
msgstr ""
"*package* es un nombre o un objeto de módulo que cumple con los requisitos "
"de ``Package``. *resource* es el nombre del recurso a abrir dentro de "
"*package*; puede que no contenga separadores de ruta y puede que no tenga "
"sub-recursos (es decir, no puede ser un directorio). *encoding* y *errors* "
"tienen el mismo significado que con la función integrada :func:`open`."

#: ../Doc/library/importlib.rst:942
msgid ""
"This function returns a ``typing.TextIO`` instance, a text I/O stream open "
"for reading."
msgstr ""
"Esta función retorna una instancia de ``typing.TextIO``, un flujo de E/S de "
"texto abierto para lectura."

#: ../Doc/library/importlib.rst:948
msgid ""
"Read and return the contents of the *resource* within *package* as ``bytes``."
msgstr ""
"Lee y retorna el contenido del *resource* dentro del *package* como "
"``bytes``."

#: ../Doc/library/importlib.rst:951
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open "
"within *package*; it may not contain path separators and it may not have sub-"
"resources (i.e. it cannot be a directory).  This function returns the "
"contents of the resource as :class:`bytes`."
msgstr ""
"*package* es un nombre o un objeto de módulo que cumple con los requisitos "
"de ``Package``. *resource* es el nombre del recurso a abrir dentro de "
"*package*; puede que no contenga separadores de ruta y puede que no tenga "
"sub-recursos (es decir, no puede ser un directorio). Esta función retorna el "
"contenido del recurso como :class:`bytes`."

#: ../Doc/library/importlib.rst:960
msgid ""
"Read and return the contents of *resource* within *package* as a ``str``. By "
"default, the contents are read as strict UTF-8."
msgstr ""
"Lee y retorna el contenido de *resource* dentro de *package* como un "
"``str``. De forma predeterminada, los contenidos se leen como UTF-8 estricto."

#: ../Doc/library/importlib.rst:963
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open "
"within *package*; it may not contain path separators and it may not have sub-"
"resources (i.e. it cannot be a directory).  *encoding* and *errors* have the "
"same meaning as with built-in :func:`open`.  This function returns the "
"contents of the resource as :class:`str`."
msgstr ""
"*package* es un nombre o un objeto de módulo que cumple con los requisitos "
"de ``Package``. *resource* es el nombre del recurso a abrir dentro de "
"*package*; puede que no contenga separadores de ruta y puede que no tenga "
"sub-recursos (es decir, no puede ser un directorio). *encoding* y *errors* "
"tienen el mismo significado que con la función integrada :func:`open`. Esta "
"función retorna el contenido del recurso como :class:`str`."

#: ../Doc/library/importlib.rst:973
msgid ""
"Return the path to the *resource* as an actual file system path.  This "
"function returns a context manager for use in a :keyword:`with` statement. "
"The context manager provides a :class:`pathlib.Path` object."
msgstr ""
"Retorna la ruta al *resource* como una ruta real del sistema de archivos. "
"Esta función retorna un administrador de contexto para usar en una "
"declaración :keyword:`with`. El administrador de contexto proporciona un "
"objeto :class:`pathlib.Path`."

#: ../Doc/library/importlib.rst:977
msgid ""
"Exiting the context manager cleans up any temporary file created when the "
"resource needs to be extracted from e.g. a zip file."
msgstr ""
"Salir del administrador de contexto limpia cualquier archivo temporal creado "
"cuando el recurso necesita ser extraído, por ejemplo, un archivo zip."

#: ../Doc/library/importlib.rst:980
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open "
"within *package*; it may not contain path separators and it may not have sub-"
"resources (i.e. it cannot be a directory)."
msgstr ""
"*package* es un nombre o un objeto de módulo que cumple con los requisitos "
"de ``Package``. *resource* es el nombre del recurso a abrir dentro de "
"*package*; puede que no contenga separadores de ruta y puede que no tenga "
"sub-recursos (es decir, no puede ser un directorio)."

#: ../Doc/library/importlib.rst:988
msgid ""
"Return ``True`` if there is a resource named *name* in the package, "
"otherwise ``False``.  Remember that directories are *not* resources! "
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements."
msgstr ""
"Retorna ``True`` si hay un recurso llamado *name* en el paquete; de lo "
"contrario, ``False``. ¡Recuerde que los directorios *no* son recursos! "
"*package* es un nombre o un objeto de módulo que cumple con los requisitos "
"de ``Package``."

#: ../Doc/library/importlib.rst:996
msgid ""
"Return an iterable over the named items within the package.  The iterable "
"returns :class:`str` resources (e.g. files) and non-resources (e.g. "
"directories).  The iterable does not recurse into subdirectories."
msgstr ""
"Retorna un iterable sobre los elementos nombrados dentro del paquete. El "
"iterable retorna recursos :class:`str` (por ejemplo, archivos) y no-recursos "
"(por ejemplo, directorios). El iterable no recurre a subdirectorios."

#: ../Doc/library/importlib.rst:1005
msgid ":mod:`importlib.machinery` -- Importers and path hooks"
msgstr ":mod:`importlib.machinery` -- Importadores y enlaces de ruta"

#: ../Doc/library/importlib.rst:1010
msgid "**Source code:** :source:`Lib/importlib/machinery.py`"
msgstr "**Código fuente:** :source:`Lib/importlib/machinery.py`"

#: ../Doc/library/importlib.rst:1014
msgid ""
"This module contains the various objects that help :keyword:`import` find "
"and load modules."
msgstr ""
"Este módulo contiene varios objetos que ayudan :keyword:`import` buscar y "
"cargar módulos."

#: ../Doc/library/importlib.rst:1019
msgid ""
"A list of strings representing the recognized file suffixes for source "
"modules."
msgstr ""
"Una lista de cadenas de caracteres que representan los sufijos de archivo "
"reconocidos para los módulos de origen."

#: ../Doc/library/importlib.rst:1026
msgid ""
"A list of strings representing the file suffixes for non-optimized bytecode "
"modules."
msgstr ""
"Una lista de cadenas que representan los sufijos de archivo para módulos de "
"código de bytes no optimizados."

#: ../Doc/library/importlib.rst:1031 ../Doc/library/importlib.rst:1041
msgid "Use :attr:`BYTECODE_SUFFIXES` instead."
msgstr "Utilice :attr:`BYTECODE_SUFFIXES` en su lugar."

#: ../Doc/library/importlib.rst:1036
msgid ""
"A list of strings representing the file suffixes for optimized bytecode "
"modules."
msgstr ""
"Una lista de cadenas de caracteres que representan los sufijos de archivo "
"para módulos de código de bytes optimizados."

#: ../Doc/library/importlib.rst:1046
msgid ""
"A list of strings representing the recognized file suffixes for bytecode "
"modules (including the leading dot)."
msgstr ""
"Una lista de cadenas de caracteres que representan los sufijos de archivo "
"reconocidos para los módulos de código de bytes (incluido el punto inicial)."

#: ../Doc/library/importlib.rst:1051
msgid "The value is no longer dependent on ``__debug__``."
msgstr "El valor ya no depende de ``__debug__``."

#: ../Doc/library/importlib.rst:1056
msgid ""
"A list of strings representing the recognized file suffixes for extension "
"modules."
msgstr ""
"Una lista de cadenas de caracteres que representan los sufijos de archivo "
"reconocidos para los módulos de extensión."

#: ../Doc/library/importlib.rst:1063
msgid ""
"Returns a combined list of strings representing all file suffixes for "
"modules recognized by the standard import machinery. This is a helper for "
"code which simply needs to know if a filesystem path potentially refers to a "
"module without needing any details on the kind of module (for example, :func:"
"`inspect.getmodulename`)."
msgstr ""
"Retorna una lista combinada de cadenas de caracteres que representan todos "
"los sufijos de archivo para módulos reconocidos por la maquinaria de "
"importación estándar. Este es un ayudante para el código que simplemente "
"necesita saber si una ruta del sistema de archivos potencialmente se refiere "
"a un módulo sin necesidad de detalles sobre el tipo de módulo (por ejemplo, :"
"func:`inspect.getmodulename`)."

#: ../Doc/library/importlib.rst:1074
msgid ""
"An :term:`importer` for built-in modules. All known built-in modules are "
"listed in :data:`sys.builtin_module_names`. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"Un :term:`importer` para módulos integrados. Todos los módulos integrados "
"conocidos se enumeran en :data:`sys.builtin_module_names`. Esta clase "
"implementa los ABC :class:`importlib.abc.MetaPathFinder` y :class:`importlib."
"abc.InspectLoader`."

#: ../Doc/library/importlib.rst:1079 ../Doc/library/importlib.rst:1093
#: ../Doc/library/importlib.rst:1106 ../Doc/library/importlib.rst:1121
msgid ""
"Only class methods are defined by this class to alleviate the need for "
"instantiation."
msgstr ""
"Esta clase solo define los métodos de clase para aliviar la necesidad de "
"instanciación."

#: ../Doc/library/importlib.rst:1082
msgid ""
"As part of :pep:`489`, the builtin importer now implements :meth:`Loader."
"create_module` and :meth:`Loader.exec_module`"
msgstr ""
"Como parte de :pep:`489`, el importador integrado ahora implementa :meth:"
"`Loader.create_module` y :meth:`Loader.exec_module`"

#: ../Doc/library/importlib.rst:1089
msgid ""
"An :term:`importer` for frozen modules. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"Un :term:`importer` para módulos congelados. Esta clase implementa los ABC :"
"class:`importlib.abc.MetaPathFinder` y :class:`importlib.abc.InspectLoader`."

#: ../Doc/library/importlib.rst:1096
msgid ""
"Gained :meth:`~Loader.create_module` and :meth:`~Loader.exec_module` methods."
msgstr ""
"Métodos obtenidos :meth:`~Loader.create_module` y :meth:`~Loader."
"exec_module`."

#: ../Doc/library/importlib.rst:1103
msgid ""
":term:`Finder <finder>` for modules declared in the Windows registry.  This "
"class implements the :class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
":term:`Finder <finder>` para los módulos declarados en el registro de "
"Windows. Esta clase implementa el :class:`importlib.abc.MetaPathFinder` ABC."

#: ../Doc/library/importlib.rst:1111
msgid ""
"Use :mod:`site` configuration instead. Future versions of Python may not "
"enable this finder by default."
msgstr ""
"Utilice la configuración de :mod:`site` en su lugar. Es posible que las "
"versiones futuras de Python no habiliten este buscador de forma "
"predeterminada."

#: ../Doc/library/importlib.rst:1118
msgid ""
"A :term:`Finder <finder>` for :data:`sys.path` and package ``__path__`` "
"attributes. This class implements the :class:`importlib.abc.MetaPathFinder` "
"ABC."
msgstr ""
"Un :term:`Finder <finder>` para :data:`sys.path` y atributos del paquete "
"``__path__``. Esta clase implementa el :class:`importlib.abc.MetaPathFinder` "
"ABC."

#: ../Doc/library/importlib.rst:1126
msgid ""
"Class method that attempts to find a :term:`spec <module spec>` for the "
"module specified by *fullname* on :data:`sys.path` or, if defined, on "
"*path*. For each path entry that is searched, :data:`sys."
"path_importer_cache` is checked. If a non-false object is found then it is "
"used as the :term:`path entry finder` to look for the module being searched "
"for. If no entry is found in :data:`sys.path_importer_cache`, then :data:"
"`sys.path_hooks` is searched for a finder for the path entry and, if found, "
"is stored in :data:`sys.path_importer_cache` along with being queried about "
"the module. If no finder is ever found then ``None`` is both stored in the "
"cache and returned."
msgstr ""
"Método de clase que intenta encontrar un :term:`spec <module spec>` para el "
"módulo especificado por *fullname* en :data:`sys.path` o, si está definido, "
"en *path*. Para cada entrada de ruta que se busca, se comprueba :data:`sys."
"path_importer_cache`. Si se encuentra un objeto que no es falso, se utiliza "
"como :term:`path entry finder` para buscar el módulo que se está buscando. "
"Si no se encuentra ninguna entrada en :data:`sys.path_importer_cache`, "
"entonces :data:`sys.path_hooks` se busca un buscador para la entrada de ruta "
"y, si se encuentra, se almacena en :data:`sys.path_importer_cache` junto con "
"ser consultado sobre el módulo. Si nunca se encuentra ningún buscador, "
"entonces ``None`` se almacena en el caché y se retorna."

#: ../Doc/library/importlib.rst:1140
msgid ""
"If the current working directory -- represented by an empty string -- is no "
"longer valid then ``None`` is returned but no value is cached in :data:`sys."
"path_importer_cache`."
msgstr ""
"Si el directorio de trabajo actual, representado por una cadena de "
"caracteres vacía, ya no es válido, se retorna``None`` pero no se almacena "
"ningún valor en :data:`sys.path_importer_cache`."

#: ../Doc/library/importlib.rst:1147
msgid "A legacy wrapper around :meth:`find_spec`."
msgstr "Una envoltura heredada alrededor de :meth:`find_spec`."

#: ../Doc/library/importlib.rst:1154
msgid ""
"Calls :meth:`importlib.abc.PathEntryFinder.invalidate_caches` on all finders "
"stored in :data:`sys.path_importer_cache` that define the method. Otherwise "
"entries in :data:`sys.path_importer_cache` set to ``None`` are deleted."
msgstr ""
"Llama :meth:`importlib.abc.PathEntryFinder.invalidate_caches` en todos los "
"buscadores almacenados en :data:`sys.path_importer_cache` que definen el "
"método. De lo contrario, las entradas en :data:`sys.path_importer_cache` "
"establecidas en ``None`` se eliminan."

#: ../Doc/library/importlib.rst:1159
msgid "Entries of ``None`` in :data:`sys.path_importer_cache` are deleted."
msgstr ""
"Se eliminan las entradas de ``None`` en :data:`sys.path_importer_cache`."

#: ../Doc/library/importlib.rst:1162
msgid ""
"Calls objects in :data:`sys.path_hooks` with the current working directory "
"for ``''`` (i.e. the empty string)."
msgstr ""
"Llama a objetos en :data:`sys.path_hooks` con el directorio de trabajo "
"actual para ``''`` (es decir, la cadena de caracteres vacía)."

#: ../Doc/library/importlib.rst:1169
msgid ""
"A concrete implementation of :class:`importlib.abc.PathEntryFinder` which "
"caches results from the file system."
msgstr ""
"Una implementación concreta de :class:`importlib.abc.PathEntryFinder` que "
"almacena en caché los resultados del sistema de archivos."

#: ../Doc/library/importlib.rst:1172
msgid ""
"The *path* argument is the directory for which the finder is in charge of "
"searching."
msgstr ""
"El argumento *path* es el directorio que el buscador se encarga de buscar."

#: ../Doc/library/importlib.rst:1175
msgid ""
"The *loader_details* argument is a variable number of 2-item tuples each "
"containing a loader and a sequence of file suffixes the loader recognizes. "
"The loaders are expected to be callables which accept two arguments of the "
"module's name and the path to the file found."
msgstr ""
"El argumento *loader_details* es un número variable de tuplas de 2 "
"elementos, cada una de las cuales contiene un cargador y una secuencia de "
"sufijos de archivo que el cargador reconoce. Se espera que los cargadores "
"sean invocables que acepten dos argumentos del nombre del módulo y la ruta "
"al archivo encontrado."

#: ../Doc/library/importlib.rst:1180
msgid ""
"The finder will cache the directory contents as necessary, making stat calls "
"for each module search to verify the cache is not outdated. Because cache "
"staleness relies upon the granularity of the operating system's state "
"information of the file system, there is a potential race condition of "
"searching for a module, creating a new file, and then searching for the "
"module the new file represents. If the operations happen fast enough to fit "
"within the granularity of stat calls, then the module search will fail. To "
"prevent this from happening, when you create a module dynamically, make sure "
"to call :func:`importlib.invalidate_caches`."
msgstr ""
"El buscador almacenará en caché el contenido del directorio según sea "
"necesario, haciendo llamadas estadísticas para cada búsqueda de módulo para "
"verificar que la caché no esté desactualizada. Debido a que la obsolescencia "
"de la caché se basa en la granularidad de la información de estado del "
"sistema operativo del sistema de archivos, existe una condición de carrera "
"potencial de buscar un módulo, crear un nuevo archivo y luego buscar el "
"módulo que representa el nuevo archivo. Si las operaciones ocurren lo "
"suficientemente rápido como para ajustarse a la granularidad de las llamadas "
"estadísticas, la búsqueda del módulo fallará. Para evitar que esto suceda, "
"cuando cree un módulo dinámicamente, asegúrese de llamar a :func:`importlib."
"invalidate_caches`."

#: ../Doc/library/importlib.rst:1194
msgid "The path the finder will search in."
msgstr "La ruta en la que buscará el buscador."

#: ../Doc/library/importlib.rst:1198
msgid "Attempt to find the spec to handle *fullname* within :attr:`path`."
msgstr ""
"Intente encontrar la especificación para manejar *fullname* dentro de :attr:"
"`path`."

#: ../Doc/library/importlib.rst:1204
msgid "Attempt to find the loader to handle *fullname* within :attr:`path`."
msgstr ""
"Intente encontrar el cargador para manejar *fullname* dentro de :attr:`path`."

#: ../Doc/library/importlib.rst:1211
msgid "Clear out the internal cache."
msgstr "Borrar el caché interno."

#: ../Doc/library/importlib.rst:1215
msgid ""
"A class method which returns a closure for use on :attr:`sys.path_hooks`. An "
"instance of :class:`FileFinder` is returned by the closure using the path "
"argument given to the closure directly and *loader_details* indirectly."
msgstr ""
"Un método de clase que devuelve un cierre para su uso en :attr:`sys."
"path_hooks`. Una instancia de :class:`FileFinder` es retornada por el cierre "
"usando el argumento de ruta dado al cierre directamente y *loader_details* "
"indirectamente."

#: ../Doc/library/importlib.rst:1220
msgid ""
"If the argument to the closure is not an existing directory, :exc:"
"`ImportError` is raised."
msgstr ""
"Si el argumento del cierre no es un directorio existente, se lanza :exc:"
"`ImportError`."

#: ../Doc/library/importlib.rst:1226
msgid ""
"A concrete implementation of :class:`importlib.abc.SourceLoader` by "
"subclassing :class:`importlib.abc.FileLoader` and providing some concrete "
"implementations of other methods."
msgstr ""
"Una implementación concreta de :class:`importlib.abc.SourceLoader` "
"subclasificando :class:`importlib.abc.FileLoader` y proporcionando algunas "
"implementaciones concretas de otros métodos."

#: ../Doc/library/importlib.rst:1234
msgid "The name of the module that this loader will handle."
msgstr "El nombre del módulo que manejará este cargador."

#: ../Doc/library/importlib.rst:1238
msgid "The path to the source file."
msgstr "La ruta al archivo de origen."

#: ../Doc/library/importlib.rst:1242
msgid "Return ``True`` if :attr:`path` appears to be for a package."
msgstr "Devuelve ``True`` si :attr:`path` parece ser para un paquete."

#: ../Doc/library/importlib.rst:1246
msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.path_stats`."
msgstr ""
"Implementación concreta de :meth:`importlib.abc.SourceLoader.path_stats`."

#: ../Doc/library/importlib.rst:1250
msgid "Concrete implementation of :meth:`importlib.abc.SourceLoader.set_data`."
msgstr ""
"Implementación concreta de :meth:`importlib.abc.SourceLoader.set_data`."

#: ../Doc/library/importlib.rst:1254 ../Doc/library/importlib.rst:1297
msgid ""
"Concrete implementation of :meth:`importlib.abc.Loader.load_module` where "
"specifying the name of the module to load is optional."
msgstr ""
"Implementación concreta de :meth:`importlib.abc.Loader.load_module` donde "
"especificar el nombre del módulo a cargar es opcional."

#: ../Doc/library/importlib.rst:1259 ../Doc/library/importlib.rst:1302
msgid "Use :meth:`importlib.abc.Loader.exec_module` instead."
msgstr "Utilice :meth:`importlib.abc.Loader.exec_module` en su lugar."

#: ../Doc/library/importlib.rst:1264
msgid ""
"A concrete implementation of :class:`importlib.abc.FileLoader` which can "
"import bytecode files (i.e. no source code files exist)."
msgstr ""
"Una implementación concreta de :class:`importlib.abc.FileLoader` que puede "
"importar archivos de código de bytes (es decir, no existen archivos de "
"código fuente)."

#: ../Doc/library/importlib.rst:1267
msgid ""
"Please note that direct use of bytecode files (and thus not source code "
"files) inhibits your modules from being usable by all Python implementations "
"or new versions of Python which change the bytecode format."
msgstr ""
"Tenga en cuenta que el uso directo de archivos de código de bytes (y, por lo "
"tanto, no de archivos de código fuente) impide que sus módulos sean "
"utilizables por todas las implementaciones de Python o las nuevas versiones "
"de Python que cambian el formato de código de bytes."

#: ../Doc/library/importlib.rst:1276
msgid "The name of the module the loader will handle."
msgstr "El nombre del módulo que manejará el cargador."

#: ../Doc/library/importlib.rst:1280
msgid "The path to the bytecode file."
msgstr "La ruta al archivo de código de bytes."

#: ../Doc/library/importlib.rst:1284
msgid "Determines if the module is a package based on :attr:`path`."
msgstr "Determina si el módulo es un paquete basado en :attr:`path`."

#: ../Doc/library/importlib.rst:1288
msgid "Returns the code object for :attr:`name` created from :attr:`path`."
msgstr ""
"Retorna el objeto de código para :attr:`name` creado a partir de :attr:"
"`path`."

#: ../Doc/library/importlib.rst:1292
msgid ""
"Returns ``None`` as bytecode files have no source when this loader is used."
msgstr ""
"Devuelve ``None`` ya que los archivos de código de bytes no tienen fuente "
"cuando se usa este cargador."

#: ../Doc/library/importlib.rst:1307
msgid ""
"A concrete implementation of :class:`importlib.abc.ExecutionLoader` for "
"extension modules."
msgstr ""
"Una implementación concreta de :class:`importlib.abc.ExecutionLoader` para "
"módulos de extensión."

#: ../Doc/library/importlib.rst:1310
msgid ""
"The *fullname* argument specifies the name of the module the loader is to "
"support. The *path* argument is the path to the extension module's file."
msgstr ""
"El argumento *fullname* especifica el nombre del módulo que el cargador debe "
"admitir. El argumento *path* es la ruta al archivo del módulo de extensión."

#: ../Doc/library/importlib.rst:1317
msgid "Name of the module the loader supports."
msgstr "Nombre del módulo que admite el cargador."

#: ../Doc/library/importlib.rst:1321
msgid "Path to the extension module."
msgstr "Ruta al módulo de extensión."

#: ../Doc/library/importlib.rst:1325
msgid ""
"Creates the module object from the given specification in accordance with :"
"pep:`489`."
msgstr ""
"Crea el objeto de módulo a partir de la especificación dada de acuerdo con :"
"pep:`489`."

#: ../Doc/library/importlib.rst:1332
msgid "Initializes the given module object in accordance with :pep:`489`."
msgstr "Inicializa el objeto de módulo dado de acuerdo con :pep:`489`."

#: ../Doc/library/importlib.rst:1338
msgid ""
"Returns ``True`` if the file path points to a package's ``__init__`` module "
"based on :attr:`EXTENSION_SUFFIXES`."
msgstr ""
"Retorna ``True`` si la ruta del archivo apunta al módulo ``__init__`` de un "
"paquete basado en :attr:`EXTENSION_SUFFIXES`."

#: ../Doc/library/importlib.rst:1343
msgid "Returns ``None`` as extension modules lack a code object."
msgstr ""
"Retorna ``None`` ya que los módulos de extensión carecen de un objeto de "
"código."

#: ../Doc/library/importlib.rst:1347
msgid "Returns ``None`` as extension modules do not have source code."
msgstr ""
"Retorna ``None`` ya que los módulos de extensión no tienen código fuente."

#: ../Doc/library/importlib.rst:1358
msgid ""
"A specification for a module's import-system-related state.  This is "
"typically exposed as the module's ``__spec__`` attribute.  In the "
"descriptions below, the names in parentheses give the corresponding "
"attribute available directly on the module object. E.g. ``module.__spec__."
"origin == module.__file__``.  Note however that while the *values* are "
"usually equivalent, they can differ since there is no synchronization "
"between the two objects.  Thus it is possible to update the module's "
"``__path__`` at runtime, and this will not be automatically reflected in "
"``__spec__.submodule_search_locations``."
msgstr ""
"Una especificación para el estado relacionado con el sistema de importación "
"de un módulo. Esto generalmente se expone como el atributo ``__spec__`` del "
"módulo. En las descripciones siguientes, los nombres entre paréntesis dan el "
"atributo correspondiente disponible directamente en el objeto del módulo, "
"por ejemplo, ``module.__spec__.origin == module.__file__``. Sin embargo, "
"tenga en cuenta que, si bien los *values* suelen ser equivalentes, pueden "
"diferir ya que no hay sincronización entre los dos objetos. Por lo tanto, es "
"posible actualizar el ``__path__`` del módulo en tiempo de ejecución, y esto "
"no se reflejará automáticamente en ``__spec__.submodule_search_locations``."

#: ../Doc/library/importlib.rst:1372
msgid "(``__name__``)"
msgstr "(``__name__``)"

#: ../Doc/library/importlib.rst:1374
msgid "A string for the fully-qualified name of the module."
msgstr "Una cadena de caracteres para el nombre completo del módulo."

#: ../Doc/library/importlib.rst:1378
msgid "(``__loader__``)"
msgstr "(``__loader__``)"

#: ../Doc/library/importlib.rst:1380
msgid ""
"The :term:`Loader <loader>` that should be used when loading the module.  :"
"term:`Finders <finder>` should always set this."
msgstr ""
"El :term:`Loader <loader>` que debe usarse al cargar el módulo. :term:"
"`Finders <finder>` siempre debe establecer esto."

#: ../Doc/library/importlib.rst:1385
msgid "(``__file__``)"
msgstr "(``__file__``)"

#: ../Doc/library/importlib.rst:1387
msgid ""
"Name of the place from which the module is loaded, e.g. \"builtin\" for "
"built-in modules and the filename for modules loaded from source. Normally "
"\"origin\" should be set, but it may be ``None`` (the default) which "
"indicates it is unspecified (e.g. for namespace packages)."
msgstr ""
"Nombre del lugar desde el que se carga el módulo, por ejemplo \"incorporado"
"\" (*builtin*) para los módulos incorporados y el nombre de archivo para los "
"módulos cargados desde la fuente. Normalmente se debe establecer \"origen\", "
"pero puede ser ``None`` (el valor predeterminado), lo que indica que no está "
"especificado (por ejemplo, para paquetes de espacio de nombres)."

#: ../Doc/library/importlib.rst:1394
msgid "(``__path__``)"
msgstr "(``__path__``)"

#: ../Doc/library/importlib.rst:1396
msgid ""
"List of strings for where to find submodules, if a package (``None`` "
"otherwise)."
msgstr ""
"Lista de cadenas de caracteres de dónde encontrar submódulos, si es un "
"paquete (``None`` de lo contrario)."

#: ../Doc/library/importlib.rst:1401
msgid ""
"Container of extra module-specific data for use during loading (or ``None``)."
msgstr ""
"Contenedor de datos adicionales específicos del módulo para usar durante la "
"carga (o ``None``)."

#: ../Doc/library/importlib.rst:1406
msgid "(``__cached__``)"
msgstr "(``__cached__``)"

#: ../Doc/library/importlib.rst:1408
msgid "String for where the compiled module should be stored (or ``None``)."
msgstr ""
"Cadena de caracteres para el lugar donde se debe almacenar el módulo "
"compilado (o ``None``)."

#: ../Doc/library/importlib.rst:1412
msgid "(``__package__``)"
msgstr "(``__package__``)"

#: ../Doc/library/importlib.rst:1414
msgid ""
"(Read-only) The fully-qualified name of the package under which the module "
"should be loaded as a submodule (or the empty string for top-level modules). "
"For packages, it is the same as :attr:`__name__`."
msgstr ""
"(Solo lectura) El nombre completo del paquete bajo el cual se debe cargar el "
"módulo como submódulo (o la cadena de caracteres vacía para los módulos de "
"nivel superior). Para los paquetes, es lo mismo que :attr:`__name__`."

#: ../Doc/library/importlib.rst:1420
msgid ""
"Boolean indicating whether or not the module's \"origin\" attribute refers "
"to a loadable location."
msgstr ""
"Booleano que indica si el atributo \"origen\" del módulo se refiere a una "
"ubicación cargable."

#: ../Doc/library/importlib.rst:1424
msgid ":mod:`importlib.util` -- Utility code for importers"
msgstr ":mod:`importlib.util` -- Código de utilidad para importadores"

#: ../Doc/library/importlib.rst:1430
msgid "**Source code:** :source:`Lib/importlib/util.py`"
msgstr "**Código fuente:** :source:`Lib/importlib/util.py`"

#: ../Doc/library/importlib.rst:1434
msgid ""
"This module contains the various objects that help in the construction of "
"an :term:`importer`."
msgstr ""
"Este módulo contiene los diversos objetos que ayudan en la construcción de "
"un :term:`importer`."

#: ../Doc/library/importlib.rst:1439
msgid ""
"The bytes which represent the bytecode version number. If you need help with "
"loading/writing bytecode then consider :class:`importlib.abc.SourceLoader`."
msgstr ""
"Los bytes que representan el número de versión del código de bytes. Si "
"necesita ayuda para cargar/escribir código de bytes, considere :class:"
"`importlib.abc.SourceLoader`."

#: ../Doc/library/importlib.rst:1446
msgid ""
"Return the :pep:`3147`/:pep:`488` path to the byte-compiled file associated "
"with the source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the "
"return value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python "
"3.2. The ``cpython-32`` string comes from the current magic tag (see :func:"
"`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then :exc:"
"`NotImplementedError` will be raised)."
msgstr ""
"Retorna la ruta :pep:`3147`/:pep:`488` al archivo compilado por bytes "
"asociado con la *path* de origen. Por ejemplo, si *path* es ``/foo/bar/baz."
"py``, el valor de retorno sería ``/foo/bar/__pycache__/baz.cpython-32.pyc`` "
"para Python 3.2. La cadena de caracteres ``cpython-32`` proviene de la "
"etiqueta mágica actual (ver :func:`get_tag`; si :attr:`sys.implementation."
"cache_tag` no está definido, se lanzará :exc:`NotImplementedError`)."

#: ../Doc/library/importlib.rst:1453
msgid ""
"The *optimization* parameter is used to specify the optimization level of "
"the bytecode file. An empty string represents no optimization, so ``/foo/bar/"
"baz.py`` with an *optimization* of ``''`` will result in a bytecode path of "
"``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` causes the "
"interpreter's optimization level to be used. Any other value's string "
"representation is used, so ``/foo/bar/baz.py`` with an *optimization* of "
"``2`` will lead to the bytecode path of ``/foo/bar/__pycache__/baz."
"cpython-32.opt-2.pyc``. The string representation of *optimization* can only "
"be alphanumeric, else :exc:`ValueError` is raised."
msgstr ""
"El parámetro *optimization* se utiliza para especificar el nivel de "
"optimización del archivo de código de bytes. Una cadena de caracteres vacía "
"no representa optimización, por lo que ``/foo/bar/baz.py`` con una "
"*optimization* de ``''`` dará como resultado una ruta de código de bytes de "
"``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` hace que se utilice el "
"nivel de optimización del intérprete. Se usa la representación de cadena de "
"caracteres de cualquier otro valor, por lo que ``/foo/bar/baz.py`` con una "
"*optimization* de ``2`` conducirá a la ruta del código de bytes de ``/foo/"
"bar/__pycache__/baz.cpython-32.opt-2.pyc``. La representación de cadena de "
"caracteres *optimization* solo puede ser alfanumérica, de lo contrario se "
"lanza :exc:`ValueError`."

#: ../Doc/library/importlib.rst:1463
msgid ""
"The *debug_override* parameter is deprecated and can be used to override the "
"system's value for ``__debug__``. A ``True`` value is the equivalent of "
"setting *optimization* to the empty string. A ``False`` value is the same as "
"setting *optimization* to ``1``. If both *debug_override* an *optimization* "
"are not ``None`` then :exc:`TypeError` is raised."
msgstr ""
"El parámetro *debug_override* está obsoleto y se puede usar para anular el "
"valor del sistema para ``__debug__``. Un valor ``True`` es el equivalente a "
"establecer *optimization* en la cadena de caracteres vacía. Un valor "
"``False`` es lo mismo que establecer *optimization* en ``1``. Si tanto "
"*debug_override* como *optimization* no es ``None``, entonces se lanza :exc:"
"`TypeError`."

#: ../Doc/library/importlib.rst:1471
msgid ""
"The *optimization* parameter was added and the *debug_override* parameter "
"was deprecated."
msgstr ""
"Se agregó el parámetro *optimization* y el parámetro *debug_override* quedó "
"obsoleto."

#: ../Doc/library/importlib.rst:1475 ../Doc/library/importlib.rst:1491
#: ../Doc/library/importlib.rst:1640
msgid "Accepts a :term:`path-like object`."
msgstr "Acepta un :term:`path-like object`."

#: ../Doc/library/importlib.rst:1481
msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is ``/foo/bar/__pycache__/baz."
"cpython-32.pyc`` the returned path would be ``/foo/bar/baz.py``.  *path* "
"need not exist, however if it does not conform to :pep:`3147` or :pep:`488` "
"format, a :exc:`ValueError` is raised. If :attr:`sys.implementation."
"cache_tag` is not defined, :exc:`NotImplementedError` is raised."
msgstr ""
"Dado el *path* a un nombre de archivo :pep:`3147`, retorna la ruta del "
"archivo del código fuente asociado. Por ejemplo, si *path* es ``/foo/bar/"
"__pycache__/baz.cpython-32.pyc``, la ruta retornada sería ``/foo/bar/baz."
"py``. *path* no necesita existir, sin embargo, si no se ajusta al formato :"
"pep:`3147` o :pep:`488`, se lanza un :exc:`ValueError`. Si :attr:`sys."
"implementation.cache_tag` no está definido, se lanza :exc:"
"`NotImplementedError`."

#: ../Doc/library/importlib.rst:1496
msgid ""
"Decode the given bytes representing source code and return it as a string "
"with universal newlines (as required by :meth:`importlib.abc.InspectLoader."
"get_source`)."
msgstr ""
"Decodifica los bytes dados que representan el código fuente y los retorna "
"como una cadena de caracteres con nuevas líneas universales (como lo "
"requiere :meth:`importlib.abc.InspectLoader.get_source`)."

#: ../Doc/library/importlib.rst:1504
msgid "Resolve a relative module name to an absolute one."
msgstr "Resuelve un nombre de módulo relativo a uno absoluto."

#: ../Doc/library/importlib.rst:1506
msgid ""
"If  **name** has no leading dots, then **name** is simply returned. This "
"allows for usage such as ``importlib.util.resolve_name('sys', __spec__."
"parent)`` without doing a check to see if the **package** argument is needed."
msgstr ""
"Si **name** no tiene puntos iniciales, entonces **name** simplemente se "
"retorna. Esto permite el uso como ``importlib.util.resolve_name('sys', "
"__spec__.parent)`` sin hacer una verificación para ver si se necesita el "
"argumento **package**."

#: ../Doc/library/importlib.rst:1511
msgid ""
":exc:`ImportError` is raised if **name** is a relative module name but "
"**package** is a false value (e.g. ``None`` or the empty string). :exc:"
"`ImportError` is also raised a relative name would escape its containing "
"package (e.g. requesting ``..bacon`` from within the ``spam`` package)."
msgstr ""
":exc:`ImportError` se lanza si **name** es un nombre de módulo relativo pero "
"**package** es un valor falso (por ejemplo, ``None`` o la cadena de "
"caracteres vacía). También se lanza :exc:`ImportError` un nombre relativo "
"que escaparía del paquete que lo contiene (por ejemplo, solicitando ``.."
"bacon`` desde el paquete ``spam``)."

#: ../Doc/library/importlib.rst:1518
msgid ""
"To improve consistency with import statements, raise :exc:`ImportError` "
"instead of :exc:`ValueError` for invalid relative import attempts."
msgstr ""
"Para mejorar la coherencia con las declaraciones de importación, aumente :"
"exc:`ImportError` en lugar de :exc:`ValueError` para intentos de importación "
"relativa no válidos."

#: ../Doc/library/importlib.rst:1525
msgid ""
"Find the :term:`spec <module spec>` for a module, optionally relative to the "
"specified **package** name. If the module is in :attr:`sys.modules`, then "
"``sys.modules[name].__spec__`` is returned (unless the spec would be "
"``None`` or is not set, in which case :exc:`ValueError` is raised). "
"Otherwise a search using :attr:`sys.meta_path` is done. ``None`` is returned "
"if no spec is found."
msgstr ""
"Busca el :term:`spec <module spec>` para un módulo, opcionalmente relativo "
"al nombre del **package** especificado. Si el módulo está en :attr:`sys."
"modules`, se retorna ``sys.modules[name].__spec__`` (a menos que la "
"especificación sea ``None`` o no esté establecida, en cuyo caso se lanza :"
"exc:`ValueError`). De lo contrario, se realiza una búsqueda utilizando :attr:"
"`sys.meta_path`. Se retorna ``None`` si no se encuentra ninguna "
"especificación."

#: ../Doc/library/importlib.rst:1532
msgid ""
"If **name** is for a submodule (contains a dot), the parent module is "
"automatically imported."
msgstr ""
"Si **name** es para un submódulo (contiene un punto), el módulo principal se "
"importa automáticamente."

#: ../Doc/library/importlib.rst:1535
msgid "**name** and **package** work the same as for :func:`import_module`."
msgstr "**name** y **package** funcionan igual que para :func:`import_module`."

#: ../Doc/library/importlib.rst:1539
msgid ""
"Raises :exc:`ModuleNotFoundError` instead of :exc:`AttributeError` if "
"**package** is in fact not a package (i.e. lacks a :attr:`__path__` "
"attribute)."
msgstr ""
"Lanza :exc:`ModuleNotFoundError` en lugar de :exc:`AttributeError` si "
"**package** no es de hecho un paquete (es decir, carece de un atributo :attr:"
"`__path__`)."

#: ../Doc/library/importlib.rst:1546
msgid ""
"Create a new module based on **spec** and :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."
msgstr ""
"Cree un nuevo módulo basado en **spec** y :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."

#: ../Doc/library/importlib.rst:1549
msgid ""
"If :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"does not return ``None``, then any pre-existing attributes will not be "
"reset. Also, no :exc:`AttributeError` will be raised if triggered while "
"accessing **spec** or setting an attribute on the module."
msgstr ""
"Si :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` no "
"retorna ``None``, no se restablecerán los atributos preexistentes. Además, "
"no se lanzará :exc:`AttributeError` si se activa mientras se accede a "
"**spec** o se establece un atributo en el módulo."

#: ../Doc/library/importlib.rst:1554
msgid ""
"This function is preferred over using :class:`types.ModuleType` to create a "
"new module as **spec** is used to set as many import-controlled attributes "
"on the module as possible."
msgstr ""
"Esta función es preferible a usar :class:`types.ModuleType` para crear un "
"nuevo módulo ya que **spec** se usa para establecer tantos atributos de "
"importación controlados en el módulo como sea posible."

#: ../Doc/library/importlib.rst:1562
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to handle "
"selecting the proper module object to load with. The decorated method is "
"expected to have a call signature taking two positional arguments (e.g. "
"``load_module(self, module)``) for which the second argument will be the "
"module **object** to be used by the loader. Note that the decorator will not "
"work on static methods because of the assumption of two arguments."
msgstr ""
"Un :term:`decorator` para :meth:`importlib.abc.Loader.load_module` para "
"manejar la selección del objeto de módulo adecuado para cargar. Se espera "
"que el método decorado tenga una firma de llamada que tome dos argumentos "
"posicionales (por ejemplo, ``load_module(self, module)``) para los cuales el "
"segundo argumento será el módulo **object** que usará el cargador. Tenga en "
"cuenta que el decorador no funcionará con métodos estáticos debido a la "
"suposición de dos argumentos."

#: ../Doc/library/importlib.rst:1571
msgid ""
"The decorated method will take in the **name** of the module to be loaded as "
"expected for a :term:`loader`. If the module is not found in :data:`sys."
"modules` then a new one is constructed. Regardless of where the module came "
"from, :attr:`__loader__` set to **self** and :attr:`__package__` is set "
"based on what :meth:`importlib.abc.InspectLoader.is_package` returns (if "
"available). These attributes are set unconditionally to support reloading."
msgstr ""
"El método decorado tomará el **name** del módulo que se cargará como se "
"esperaba para un :term:`loader`. Si el módulo no se encuentra en :data:`sys."
"modules`, se construye uno nuevo. Independientemente de la procedencia del "
"módulo, :attr:`__loader__` se establece en **self** y :attr:`__package__` se "
"establece en función de lo que retorna :meth:`importlib.abc.InspectLoader."
"is_package` (si está disponible) . Estos atributos se establecen "
"incondicionalmente para admitir la recarga."

#: ../Doc/library/importlib.rst:1579
msgid ""
"If an exception is raised by the decorated method and a module was added to :"
"data:`sys.modules`, then the module will be removed to prevent a partially "
"initialized module from being in left in :data:`sys.modules`. If the module "
"was already in :data:`sys.modules` then it is left alone."
msgstr ""
"Si el método decorado lanza una excepción y se agrega un módulo a :data:`sys."
"modules`, entonces el módulo se eliminará para evitar que un módulo "
"parcialmente inicializado quede en :data:`sys.modules`. Si el módulo ya "
"estaba en :data:`sys.modules` entonces se deja solo."

#: ../Doc/library/importlib.rst:1584
msgid ""
":attr:`__loader__` and :attr:`__package__` are automatically set (when "
"possible)."
msgstr ""
":attr:`__loader__` y :attr:`__package__` se configuran automáticamente "
"(cuando es posible)."

#: ../Doc/library/importlib.rst:1588
msgid ""
"Set :attr:`__name__`, :attr:`__loader__` :attr:`__package__` unconditionally "
"to support reloading."
msgstr ""
"Establece :attr:`__name__`, :attr:`__loader__` :attr:`__package__` "
"incondicionalmente para apoyar la recarga."

#: ../Doc/library/importlib.rst:1592
msgid ""
"The import machinery now directly performs all the functionality provided by "
"this function."
msgstr ""
"La maquinaria de importación ahora realiza directamente toda la "
"funcionalidad proporcionada por esta función."

#: ../Doc/library/importlib.rst:1598
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to set the :"
"attr:`__loader__` attribute on the returned module. If the attribute is "
"already set the decorator does nothing. It is assumed that the first "
"positional argument to the wrapped method (i.e. ``self``) is what :attr:"
"`__loader__` should be set to."
msgstr ""
"Un :term:`decorator` para :meth:`importlib.abc.Loader.load_module` para "
"establecer el atributo :attr:`__loader__` en el módulo retornado. Si el "
"atributo ya está configurado, el decorador no hace nada. Se asume que el "
"primer argumento posicional del método envuelto (es decir, ``self``) es lo "
"que se debe establecer en :attr:`__loader__`."

#: ../Doc/library/importlib.rst:1605
msgid ""
"Set ``__loader__`` if set to ``None``, as if the attribute does not exist."
msgstr ""
"Establece ``__loader__`` si está configurado como ``None``, como si el "
"atributo no existiera."

#: ../Doc/library/importlib.rst:1609 ../Doc/library/importlib.rst:1618
msgid "The import machinery takes care of this automatically."
msgstr "La maquinaria de importación se encarga de esto automáticamente."

#: ../Doc/library/importlib.rst:1614
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to set the :"
"attr:`__package__` attribute on the returned module. If :attr:`__package__` "
"is set and has a value other than ``None`` it will not be changed."
msgstr ""
"Un :term:`decorator` para :meth:`importlib.abc.Loader.load_module` para "
"establecer el atributo :attr:`__package__` en el módulo retornado. Si :attr:"
"`__package__` está configurado y tiene un valor diferente a ``None``, no se "
"cambiará."

#: ../Doc/library/importlib.rst:1623
msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on a loader.  The parameters have the same meaning as they do "
"for ModuleSpec.  The function uses available :term:`loader` APIs, such as :"
"meth:`InspectLoader.is_package`, to fill in any missing information on the "
"spec."
msgstr ""
"Una función de fábrica para crear una instancia de :class:`~importlib."
"machinery.ModuleSpec` basada en un cargador. Los parámetros tienen el mismo "
"significado que para ModuleSpec. La función utiliza APIs disponibles de :"
"term:`loader`, tal como :meth:`InspectLoader.is_package`, para completar "
"cualquier información que falte en la especificación."

#: ../Doc/library/importlib.rst:1633
msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on the path to a file.  Missing information will be filled in "
"on the spec by making use of loader APIs and by the implication that the "
"module will be file-based."
msgstr ""
"Una función de fábrica para crear una instancia de :class:`~importlib."
"machinery.ModuleSpec` basada en la ruta a un archivo. La información que "
"falte se completará en la especificación mediante el uso de las API de "
"loader y la implicación de que el módulo estará basado en archivos."

#: ../Doc/library/importlib.rst:1645
msgid ""
"Return the hash of *source_bytes* as bytes. A hash-based ``.pyc`` file "
"embeds the :func:`source_hash` of the corresponding source file's contents "
"in its header."
msgstr ""
"Retorna el hash de *source_bytes* como bytes. Un archivo ``.pyc`` basado en "
"hash incrusta :func:`source_hash` del contenido del archivo fuente "
"correspondiente en su encabezado."

#: ../Doc/library/importlib.rst:1653
msgid ""
"A class which postpones the execution of the loader of a module until the "
"module has an attribute accessed."
msgstr ""
"Una clase que pospone la ejecución del cargador de un módulo hasta que el "
"módulo tiene acceso a un atributo."

#: ../Doc/library/importlib.rst:1656
msgid ""
"This class **only** works with loaders that define :meth:`~importlib.abc."
"Loader.exec_module` as control over what module type is used for the module "
"is required. For those same reasons, the loader's :meth:`~importlib.abc."
"Loader.create_module` method must return ``None`` or a type for which its "
"``__class__`` attribute can be mutated along with not using :term:`slots "
"<__slots__>`. Finally, modules which substitute the object placed into :attr:"
"`sys.modules` will not work as there is no way to properly replace the "
"module references throughout the interpreter safely; :exc:`ValueError` is "
"raised if such a substitution is detected."
msgstr ""
"Esta clase **solo** funciona con cargadores que definen :meth:`~importlib."
"abc.Loader.exec_module` ya que se requiere control sobre qué tipo de módulo "
"se usa para el módulo. Por esas mismas razones, el método del cargador :meth:"
"`~importlib.abc.Loader.create_module` debe retornar ``None`` o un tipo para "
"el cual su atributo ``__class__`` se puede mutar junto con no usar :term:"
"`slots <__slots__>`. Finalmente, los módulos que sustituyen el objeto "
"colocado en :attr:`sys.modules` no funcionarán ya que no hay forma de "
"reemplazar correctamente las referencias del módulo en todo el intérprete de "
"forma segura; :exc:`ValueError` se genera si se detecta tal sustitución."

#: ../Doc/library/importlib.rst:1667
msgid ""
"For projects where startup time is critical, this class allows for "
"potentially minimizing the cost of loading a module if it is never used. For "
"projects where startup time is not essential then use of this class is "
"**heavily** discouraged due to error messages created during loading being "
"postponed and thus occurring out of context."
msgstr ""
"Para proyectos donde el tiempo de inicio es crítico, esta clase permite "
"minimizar potencialmente el costo de cargar un módulo si nunca se usa. Para "
"proyectos en los que el tiempo de inicio no es esencial, el uso de esta "
"clase se desaconseja **en gran medida** debido a que los mensajes de error "
"creados durante la carga se posponen y, por lo tanto, ocurren fuera de "
"contexto."

#: ../Doc/library/importlib.rst:1675
msgid ""
"Began calling :meth:`~importlib.abc.Loader.create_module`, removing the "
"compatibility warning for :class:`importlib.machinery.BuiltinImporter` and :"
"class:`importlib.machinery.ExtensionFileLoader`."
msgstr ""
"Comenzó a llamar :meth:`~importlib.abc.Loader.create_module`, eliminando la "
"advertencia de compatibilidad para :class:`importlib.machinery."
"BuiltinImporter` y :class:`importlib.machinery.ExtensionFileLoader`."

#: ../Doc/library/importlib.rst:1682
msgid ""
"A static method which returns a callable that creates a lazy loader. This is "
"meant to be used in situations where the loader is passed by class instead "
"of by instance. ::"
msgstr ""
"Un método estático que devuelve un invocable que crea un cargador diferido. "
"Esto está destinado a utilizarse en situaciones en las que el cargador se "
"pasa por clase en lugar de por instancia. ::"

#: ../Doc/library/importlib.rst:1695
msgid "Examples"
msgstr "Ejemplos"

#: ../Doc/library/importlib.rst:1698
msgid "Importing programmatically"
msgstr "Importar programáticamente"

#: ../Doc/library/importlib.rst:1700
msgid ""
"To programmatically import a module, use :func:`importlib.import_module`. ::"
msgstr ""
"Para importar un módulo mediante programación, use :func:`importlib."
"import_module`. ::"

#: ../Doc/library/importlib.rst:1709
msgid "Checking if a module can be imported"
msgstr "Comprobando si se puede importar un módulo"

#: ../Doc/library/importlib.rst:1711
msgid ""
"If you need to find out if a module can be imported without actually doing "
"the import, then you should use :func:`importlib.util.find_spec`. ::"
msgstr ""
"Si necesita averiguar si un módulo se puede importar sin realmente realizar "
"la importación, entonces debe usar :func:`importlib.util.find_spec`. ::"

#: ../Doc/library/importlib.rst:1734
msgid "Importing a source file directly"
msgstr "Importar un archivo fuente directamente"

#: ../Doc/library/importlib.rst:1736
msgid ""
"To import a Python source file directly, use the following recipe (Python "
"3.5 and newer only)::"
msgstr ""
"Para importar un archivo fuente de Python directamente, use la siguiente "
"receta (solo Python 3.5 y más reciente)::"

#: ../Doc/library/importlib.rst:1754
msgid "Implementing lazy imports"
msgstr "Implementar importaciones diferidas"

#: ../Doc/library/importlib.rst:1756
msgid "The example below shows how to implement lazy imports::"
msgstr "El ejemplo de abajo muestra cómo implementar importaciones diferidas::"

#: ../Doc/library/importlib.rst:1778
msgid "Setting up an importer"
msgstr "Configurar un importador"

#: ../Doc/library/importlib.rst:1780
msgid ""
"For deep customizations of import, you typically want to implement an :term:"
"`importer`. This means managing both the :term:`finder` and :term:`loader` "
"side of things. For finders there are two flavours to choose from depending "
"on your needs: a :term:`meta path finder` or a :term:`path entry finder`. "
"The former is what you would put on :attr:`sys.meta_path` while the latter "
"is what you create using a :term:`path entry hook` on :attr:`sys.path_hooks` "
"which works with :attr:`sys.path` entries to potentially create a finder. "
"This example will show you how to register your own importers so that import "
"will use them (for creating an importer for yourself, read the documentation "
"for the appropriate classes defined within this package)::"
msgstr ""
"Para personalizaciones profundas de la importación, normalmente desea "
"implementar un :term:`importador`. Esto significa administrar tanto el lado :"
"term:`finder` como :term:`loader` de las cosas. Para los buscadores, hay dos "
"sabores para elegir según sus necesidades: un :term:`meta path finder` o un :"
"term:`path entry finder`. El primero es lo que pondrías en :attr:`sys."
"meta_path` mientras que el segundo es lo que creas usando un :term:`path "
"entry hook` en :attr:`sys.path_hooks` que funciona con :attr:`sys .path` "
"entradas para crear potencialmente un buscador. Este ejemplo le mostrará "
"cómo registrar sus propios importadores para que import los utilice (para "
"crear un importador para usted, lea la documentación de las clases "
"apropiadas definidas dentro de este paquete):"

#: ../Doc/library/importlib.rst:1812
msgid "Approximating :func:`importlib.import_module`"
msgstr "Aproximando :func:`importlib.import_module`"

#: ../Doc/library/importlib.rst:1814
msgid ""
"Import itself is implemented in Python code, making it possible to expose "
"most of the import machinery through importlib. The following helps "
"illustrate the various APIs that importlib exposes by providing an "
"approximate implementation of :func:`importlib.import_module` (Python 3.4 "
"and newer for the importlib usage, Python 3.6 and newer for other parts of "
"the code). ::"
msgstr ""
"La importación en sí está implementada en código Python, lo que permite "
"exponer la mayor parte de la maquinaria de importación a través de "
"importlib. Lo siguiente ayuda a ilustrar las diversas API que importlib "
"expone al proporcionar una implementación aproximada de :func:`importlib."
"import_module` (Python 3.4 y más reciente para el uso de importlib, Python "
"3.6 y más reciente para otras partes del código). ::"
