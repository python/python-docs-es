# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2024-09-09 19:28+0230\n"
"Last-Translator: Carlos Mena Pérez <@carlosm00>\n"
"Language-Team: python-doc-es\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.13.0\n"
"X-Generator: Poedit 3.5\n"

#: ../Doc/library/codecs.rst:2
msgid ":mod:`codecs` --- Codec registry and base classes"
msgstr ":mod:`codecs` --- Registro de códec y clases base"

#: ../Doc/library/codecs.rst:11
msgid "**Source code:** :source:`Lib/codecs.py`"
msgstr "**Código fuente:** :source:`Lib/codecs.py`"

#: ../Doc/library/codecs.rst:23
msgid ""
"This module defines base classes for standard Python codecs (encoders and "
"decoders) and provides access to the internal Python codec registry, which "
"manages the codec and error handling lookup process. Most standard codecs "
"are :term:`text encodings <text encoding>`, which encode text to bytes (and "
"decode bytes to text), but there are also codecs provided that encode text "
"to text, and bytes to bytes. Custom codecs may encode and decode between "
"arbitrary types, but some module features are restricted to be used "
"specifically with :term:`text encodings <text encoding>` or with codecs that "
"encode to :class:`bytes`."
msgstr ""
"Este módulo define las clases base para los códecs estándar de Python "
"(codificadores y decodificadores) y proporciona acceso al registro interno "
"de códecs de Python, que administra el códec y el proceso de búsqueda del "
"manejo de errores. La mayoría de los códecs estándar son :term:`text "
"encodings <text encoding>`, que codifican texto a bytes (y decodifican bytes "
"a texto), pero también se proporcionan códecs que codifican texto a texto y "
"bytes a bytes. Los códecs personalizados pueden codificar y decodificar "
"entre tipos arbitrarios, pero algunas características del módulo están "
"restringidas para usarse específicamente con :term:`text encodings <text "
"encoding>` o con códecs que codifican a :class:`bytes`."

#: ../Doc/library/codecs.rst:33
msgid ""
"The module defines the following functions for encoding and decoding with "
"any codec:"
msgstr ""
"El módulo define las siguientes funciones para codificar y decodificar con "
"cualquier códec:"

#: ../Doc/library/codecs.rst:38
msgid "Encodes *obj* using the codec registered for *encoding*."
msgstr "Codifica *obj* utilizando el códec registrado para *encoding*."

#: ../Doc/library/codecs.rst:40
msgid ""
"*Errors* may be given to set the desired error handling scheme. The default "
"error handler is ``'strict'`` meaning that encoding errors raise :exc:"
"`ValueError` (or a more codec specific subclass, such as :exc:"
"`UnicodeEncodeError`). Refer to :ref:`codec-base-classes` for more "
"information on codec error handling."
msgstr ""
"Se pueden dar *errors* para establecer el esquema de manejo de errores "
"deseado. El manejador de errores predeterminado es ``'estricto'``, lo que "
"significa que los errores de codificación provocan :exc:`ValueError` (o una "
"subclase más específica del códec, como :exc:`UnicodeEncodeError`). "
"Consulte :ref:`codec-base-classes` para obtener más información sobre el "
"manejo de errores de códec."

#: ../Doc/library/codecs.rst:48
msgid "Decodes *obj* using the codec registered for *encoding*."
msgstr "Decodifica *obj* utilizando el códec registrado para *encoding*."

#: ../Doc/library/codecs.rst:50
msgid ""
"*Errors* may be given to set the desired error handling scheme. The default "
"error handler is ``'strict'`` meaning that decoding errors raise :exc:"
"`ValueError` (or a more codec specific subclass, such as :exc:"
"`UnicodeDecodeError`). Refer to :ref:`codec-base-classes` for more "
"information on codec error handling."
msgstr ""
"Se pueden dar *errors* para establecer el esquema de manejo de errores "
"deseado. El manejador de errores predeterminado es ``'estricto'``, lo que "
"significa que los errores de decodificación generan :exc:`ValueError` (o una "
"subclase más específica de códec, como :exc:`UnicodeDecodeError`). Consulte :"
"ref:`codec-base-classes` para obtener más información sobre el manejo de "
"errores de códec."

#: ../Doc/library/codecs.rst:56
msgid "The full details for each codec can also be looked up directly:"
msgstr ""
"Los detalles completos de cada códec también se pueden consultar "
"directamente:"

#: ../Doc/library/codecs.rst:60
msgid ""
"Looks up the codec info in the Python codec registry and returns a :class:"
"`CodecInfo` object as defined below."
msgstr ""
"Busca la información de códec en el registro de códec de Python y retorna un "
"objeto :class:`CodecInfo` como se define a continuación."

#: ../Doc/library/codecs.rst:63
msgid ""
"Encodings are first looked up in the registry's cache. If not found, the "
"list of registered search functions is scanned. If no :class:`CodecInfo` "
"object is found, a :exc:`LookupError` is raised. Otherwise, the :class:"
"`CodecInfo` object is stored in the cache and returned to the caller."
msgstr ""
"Las codificaciones se buscan primero en la memoria caché del registro. Si no "
"se encuentran, se explora la lista de funciones de búsqueda registradas. Si "
"no se encuentran objetos :class:`CodecInfo`, se lanza un :exc:`LookupError`. "
"De lo contrario, el objeto :class:`CodecInfo` se almacena en la memoria "
"caché y se retorna a quien llama."

#: ../Doc/library/codecs.rst:70
msgid ""
"Codec details when looking up the codec registry. The constructor arguments "
"are stored in attributes of the same name:"
msgstr ""
"Detalles de códec al buscar el registro de códec. Los argumentos del "
"constructor se almacenan en atributos del mismo nombre:"

#: ../Doc/library/codecs.rst:76
msgid "The name of the encoding."
msgstr "El nombre de la codificación."

#: ../Doc/library/codecs.rst:82
msgid ""
"The stateless encoding and decoding functions. These must be functions or "
"methods which have the same interface as the :meth:`~Codec.encode` and :meth:"
"`~Codec.decode` methods of Codec instances (see :ref:`Codec Interface <codec-"
"objects>`). The functions or methods are expected to work in a stateless "
"mode."
msgstr ""
"Las funciones de codificación y decodificación sin estado. Deben ser "
"funciones o métodos que tengan la misma interfaz que los métodos :meth:"
"`~Codec.encode` y :meth:`~Codec.decode` de instancias de *Codec* (ver :ref:"
"`Codec Interface <codec-objects>`). Se espera que las funciones o métodos "
"funcionen en modo sin estado."

#: ../Doc/library/codecs.rst:92
msgid ""
"Incremental encoder and decoder classes or factory functions. These have to "
"provide the interface defined by the base classes :class:"
"`IncrementalEncoder` and :class:`IncrementalDecoder`, respectively. "
"Incremental codecs can maintain state."
msgstr ""
"Clases de codificación y decodificación incremental o funciones de fábrica. "
"Deben proporcionar la interfaz definida por las clases base :class:"
"`IncrementalEncoder` y :class:`IncrementalDecoder`, respectivamente. Los "
"códecs incrementales pueden mantener el estado."

#: ../Doc/library/codecs.rst:101
msgid ""
"Stream writer and reader classes or factory functions. These have to provide "
"the interface defined by the base classes :class:`StreamWriter` and :class:"
"`StreamReader`, respectively. Stream codecs can maintain state."
msgstr ""
"Las clases *stream*, tanto *writer* como *reader* o funciones de fábrica. "
"Estos tienen que proporcionar la interfaz definida por las clases base :"
"class:`StreamWriter` y :class:`StreamReader`, respectivamente. Los códecs de "
"flujo pueden mantener el estado."

#: ../Doc/library/codecs.rst:106
msgid ""
"To simplify access to the various codec components, the module provides "
"these additional functions which use :func:`lookup` for the codec lookup:"
msgstr ""
"Para simplificar el acceso a los diversos componentes de códec, el módulo "
"proporciona estas funciones adicionales que utilizan :func:`lookup` para la "
"búsqueda de códec:"

#: ../Doc/library/codecs.rst:111
msgid ""
"Look up the codec for the given encoding and return its encoder function."
msgstr ""
"Busca el códec para la codificación dada y retorna su función de codificador."

#: ../Doc/library/codecs.rst:113 ../Doc/library/codecs.rst:120
#: ../Doc/library/codecs.rst:146 ../Doc/library/codecs.rst:154
msgid "Raises a :exc:`LookupError` in case the encoding cannot be found."
msgstr ""
"Lanza un :exc:`LookupError` en caso de que no se encuentre la codificación."

#: ../Doc/library/codecs.rst:118
msgid ""
"Look up the codec for the given encoding and return its decoder function."
msgstr ""
"Busca el códec para la codificación dada y retorna su función de "
"decodificador."

#: ../Doc/library/codecs.rst:125
msgid ""
"Look up the codec for the given encoding and return its incremental encoder "
"class or factory function."
msgstr ""
"Busca el códec para la codificación dada y retorna su clase de codificador "
"incremental o función de fábrica."

#: ../Doc/library/codecs.rst:128
msgid ""
"Raises a :exc:`LookupError` in case the encoding cannot be found or the "
"codec doesn't support an incremental encoder."
msgstr ""
"Lanza un :exc:`LookupError` en caso de que no se encuentre la codificación o "
"el códec no admita un codificador incremental."

#: ../Doc/library/codecs.rst:134
msgid ""
"Look up the codec for the given encoding and return its incremental decoder "
"class or factory function."
msgstr ""
"Busca el códec para la codificación dada y retorna su clase de decodificador "
"incremental o función de fábrica."

#: ../Doc/library/codecs.rst:137
msgid ""
"Raises a :exc:`LookupError` in case the encoding cannot be found or the "
"codec doesn't support an incremental decoder."
msgstr ""
"Lanza un :exc:`LookupError` en caso de que no se encuentre la codificación o "
"el códec no admita un decodificador incremental."

#: ../Doc/library/codecs.rst:143
msgid ""
"Look up the codec for the given encoding and return its :class:"
"`StreamReader` class or factory function."
msgstr ""
"Busca el códec para la codificación dada y retorna su clase :class:"
"`StreamReader` o función de fábrica."

#: ../Doc/library/codecs.rst:151
msgid ""
"Look up the codec for the given encoding and return its :class:"
"`StreamWriter` class or factory function."
msgstr ""
"Busca el códec para la codificación dada y retorna su clase :class:"
"`StreamWriter` o función de fábrica."

#: ../Doc/library/codecs.rst:156
msgid ""
"Custom codecs are made available by registering a suitable codec search "
"function:"
msgstr ""
"Los códecs personalizados se ponen a disposición registrando una función de "
"búsqueda de códecs adecuada:"

#: ../Doc/library/codecs.rst:161
msgid ""
"Register a codec search function. Search functions are expected to take one "
"argument, being the encoding name in all lower case letters with hyphens and "
"spaces converted to underscores, and return a :class:`CodecInfo` object. In "
"case a search function cannot find a given encoding, it should return "
"``None``."
msgstr ""
"Registra una función de búsqueda de códec. Se espera que las funciones de "
"búsqueda tomen un argumento, que sea el nombre de codificación en minúsculas "
"con guiones y espacios convertidos a guiones bajos, y que retorne un objeto :"
"class:`CodecInfo`. En caso de que una función de búsqueda no pueda encontrar "
"una codificación dada, debería retornar ``None``."

#: ../Doc/library/codecs.rst:167
msgid "Hyphens and spaces are converted to underscore."
msgstr "Guiones y espacios se convierten a guiones bajos."

#: ../Doc/library/codecs.rst:173
msgid ""
"Unregister a codec search function and clear the registry's cache. If the "
"search function is not registered, do nothing."
msgstr ""
"Anula el registro de una función de búsqueda de códecs y elimina el caché "
"del registro. Si la función de búsqueda no está registrada, no hace nada."

#: ../Doc/library/codecs.rst:179
msgid ""
"While the builtin :func:`open` and the associated :mod:`io` module are the "
"recommended approach for working with encoded text files, this module "
"provides additional utility functions and classes that allow the use of a "
"wider range of codecs when working with binary files:"
msgstr ""
"Mientras que la función incorporada :func:`open` y el módulo asociado :mod:"
"`io` son el enfoque recomendado para trabajar con archivos de texto "
"codificados, este módulo proporciona funciones y clases de utilidad "
"adicionales que permiten el uso de una gama más amplia de códecs cuando se "
"trabaja con archivos binarios:"

#: ../Doc/library/codecs.rst:186
msgid ""
"Open an encoded file using the given *mode* and return an instance of :class:"
"`StreamReaderWriter`, providing transparent encoding/decoding. The default "
"file mode is ``'r'``, meaning to open the file in read mode."
msgstr ""
"Abre un archivo codificado utilizando el modo dado y retorna una instancia "
"de :class:`StreamReaderWriter`, proporcionando codificación/decodificación "
"transparente. El modo de archivo predeterminado es ``'r'``, que significa "
"abrir el archivo en modo de lectura."

#: ../Doc/library/codecs.rst:192
msgid ""
"If *encoding* is not ``None``, then the underlying encoded files are always "
"opened in binary mode. No automatic conversion of ``'\\n'`` is done on "
"reading and writing. The *mode* argument may be any binary mode acceptable "
"to the built-in :func:`open` function; the ``'b'`` is automatically added."
msgstr ""
"Si el valor de *encoding* no es ``None``, entonces, los archivos codificados "
"subyacentes siempre se abren en modo binario. No se realiza ninguna "
"conversión automática de ``'\\n'`` al leer y escribir. El argumento *mode* "
"puede ser cualquier modo binario aceptable para la función integrada :func:"
"`open`; la ``'b'`` se añade automáticamente."

#: ../Doc/library/codecs.rst:198
msgid ""
"*encoding* specifies the encoding which is to be used for the file. Any "
"encoding that encodes to and decodes from bytes is allowed, and the data "
"types supported by the file methods depend on the codec used."
msgstr ""
"*encoding* especifica la codificación que se utilizará para el archivo. Se "
"permite cualquier codificación que codifique y decodifique desde bytes, y "
"los tipos de datos admitidos por los métodos de archivo dependen del códec "
"utilizado."

#: ../Doc/library/codecs.rst:202
msgid ""
"*errors* may be given to define the error handling. It defaults to "
"``'strict'`` which causes a :exc:`ValueError` to be raised in case an "
"encoding error occurs."
msgstr ""
"pueden proporcionarse *errors* para definir el manejo de errores. El valor "
"predeterminado es ``'estricto'``, lo que hace que se genere un :exc:"
"`ValueError` en caso de que ocurra un error de codificación."

#: ../Doc/library/codecs.rst:205
msgid ""
"*buffering* has the same meaning as for the built-in :func:`open` function. "
"It defaults to -1 which means that the default buffer size will be used."
msgstr ""
"*buffering* tiene el mismo significado que para la función incorporada :func:"
"`open`. Su valor predeterminado es -1, lo que significa que se utilizará el "
"tamaño predeterminado del búfer."

#: ../Doc/library/codecs.rst:208
msgid "The ``'U'`` mode has been removed."
msgstr "El modo ``'U'`` ha sido eliminado."

#: ../Doc/library/codecs.rst:214
msgid ""
"Return a :class:`StreamRecoder` instance, a wrapped version of *file* which "
"provides transparent transcoding. The original file is closed when the "
"wrapped version is closed."
msgstr ""
"Retorna una instancia de :class:`StreamRecoder`, una versión envuelta de "
"*file* que proporciona transcodificación transparente. El archivo original "
"se cierra cuando se cierra la versión empaquetada."

#: ../Doc/library/codecs.rst:218
msgid ""
"Data written to the wrapped file is decoded according to the given "
"*data_encoding* and then written to the original file as bytes using "
"*file_encoding*. Bytes read from the original file are decoded according to "
"*file_encoding*, and the result is encoded using *data_encoding*."
msgstr ""
"Los datos escritos en el archivo empaquetado se decodifican de acuerdo con "
"la *data_encoding* dada y luego se escriben en el archivo original como "
"bytes usando *file_encoding*. Los bytes leídos del archivo original se "
"decodifican según *file_encoding*, y el resultado se codifica utilizando "
"*data_encoding*."

#: ../Doc/library/codecs.rst:224
msgid "If *file_encoding* is not given, it defaults to *data_encoding*."
msgstr ""
"Si no se proporciona *file_encoding*, el valor predeterminado es "
"*data_encoding*."

#: ../Doc/library/codecs.rst:226
msgid ""
"*errors* may be given to define the error handling. It defaults to "
"``'strict'``, which causes :exc:`ValueError` to be raised in case an "
"encoding error occurs."
msgstr ""
"Pueden proporcionarse *errors* para definir el manejo de errores. Su valor "
"predeterminado es ``'estricto'``, lo que hace que se genere :exc:"
"`ValueError` en caso de que ocurra un error de codificación."

#: ../Doc/library/codecs.rst:233
msgid ""
"Uses an incremental encoder to iteratively encode the input provided by "
"*iterator*. This function is a :term:`generator`. The *errors* argument (as "
"well as any other keyword argument) is passed through to the incremental "
"encoder."
msgstr ""
"Utiliza un codificador incremental para codificar iterativamente la entrada "
"proporcionada por *iterator*. Esta función es un :term:`generator`. El "
"argumento *errors* (así como cualquier otro argumento de palabra clave) se "
"pasa al codificador incremental."

#: ../Doc/library/codecs.rst:238
msgid ""
"This function requires that the codec accept text :class:`str` objects to "
"encode. Therefore it does not support bytes-to-bytes encoders such as "
"``base64_codec``."
msgstr ""
"Esta función requiere que el códec acepte texto en objetos :class:`str` para "
"codificar. Por lo tanto, no admite codificadores de bytes a bytes, como "
"``base64_codec``."

#: ../Doc/library/codecs.rst:245
msgid ""
"Uses an incremental decoder to iteratively decode the input provided by "
"*iterator*. This function is a :term:`generator`. The *errors* argument (as "
"well as any other keyword argument) is passed through to the incremental "
"decoder."
msgstr ""
"Utiliza un decodificador incremental para decodificar iterativamente la "
"entrada proporcionada por *iterator*. Esta función es un :term:`generator`. "
"El argumento *errors* (así como cualquier otro argumento de palabra clave) "
"se pasa al decodificador incremental."

#: ../Doc/library/codecs.rst:250
msgid ""
"This function requires that the codec accept :class:`bytes` objects to "
"decode. Therefore it does not support text-to-text encoders such as "
"``rot_13``, although ``rot_13`` may be used equivalently with :func:"
"`iterencode`."
msgstr ""
"Esta función requiere que el códec acepte objetos :class:`bytes` para "
"decodificar. Por lo tanto, no admite codificadores de texto a texto como "
"``rot_13``, aunque ``rot_13`` puede usarse de manera equivalente con :func:"
"`iterencode`."

#: ../Doc/library/codecs.rst:256
msgid ""
"The module also provides the following constants which are useful for "
"reading and writing to platform dependent files:"
msgstr ""
"El módulo también proporciona las siguientes constantes que son útiles para "
"leer y escribir en archivos dependientes de la plataforma:"

#: ../Doc/library/codecs.rst:271
msgid ""
"These constants define various byte sequences, being Unicode byte order "
"marks (BOMs) for several encodings. They are used in UTF-16 and UTF-32 data "
"streams to indicate the byte order used, and in UTF-8 as a Unicode "
"signature. :const:`BOM_UTF16` is either :const:`BOM_UTF16_BE` or :const:"
"`BOM_UTF16_LE` depending on the platform's native byte order, :const:`BOM` "
"is an alias for :const:`BOM_UTF16`, :const:`BOM_LE` for :const:"
"`BOM_UTF16_LE` and :const:`BOM_BE` for :const:`BOM_UTF16_BE`. The others "
"represent the BOM in UTF-8 and UTF-32 encodings."
msgstr ""
"Estas constantes definen varias secuencias de bytes, que son marcas de orden "
"de bytes Unicode (BOM) para varias codificaciones. Se utilizan en flujos de "
"datos UTF-16 y UTF-32 para indicar el orden de bytes utilizado, y en UTF-8 "
"como firma Unicode. :const:`BOM_UTF16` es :const:`BOM_UTF16_BE` o :const:"
"`BOM_UTF16_LE` dependiendo del orden de bytes nativo de la plataforma, :"
"const:`BOM` es un alias para :const:`BOM_UTF16`, :const:`BOM_LE` para :const:"
"`BOM_UTF16_LE` y :const:`BOM_BE` para :const:`BOM_UTF16_BE`. Los otros "
"representan la lista de materiales en las codificaciones UTF-8 y UTF-32."

#: ../Doc/library/codecs.rst:285
msgid "Codec Base Classes"
msgstr "Clases Base de Códec"

#: ../Doc/library/codecs.rst:287
msgid ""
"The :mod:`codecs` module defines a set of base classes which define the "
"interfaces for working with codec objects, and can also be used as the basis "
"for custom codec implementations."
msgstr ""
"El módulo :mod:`codecs` define un conjunto de clases base que definen las "
"interfaces para trabajar con objetos de códec, y también puede usarse como "
"base para implementaciones de códec personalizadas."

#: ../Doc/library/codecs.rst:291
msgid ""
"Each codec has to define four interfaces to make it usable as codec in "
"Python: stateless encoder, stateless decoder, stream reader and stream "
"writer. The stream reader and writers typically reuse the stateless encoder/"
"decoder to implement the file protocols. Codec authors also need to define "
"how the codec will handle encoding and decoding errors."
msgstr ""
"Cada códec tiene que definir cuatro interfaces para que pueda usarse como "
"códec en Python: codificador sin estado, decodificador sin estado, lector de "
"flujo y escritor de flujo. El lector de flujo y los escritores suelen "
"reutilizar el codificador/decodificador sin estado para implementar los "
"protocolos de archivo. Los autores de códecs también necesitan definir cómo "
"manejará los errores de codificación y decodificación."

#: ../Doc/library/codecs.rst:302
msgid "Error Handlers"
msgstr "Manejadores de errores"

#: ../Doc/library/codecs.rst:304
msgid ""
"To simplify and standardize error handling, codecs may implement different "
"error handling schemes by accepting the *errors* string argument:"
msgstr ""
"Para simplificar y estandarizar el manejo de errores, los códecs pueden "
"implementar diferentes esquemas de manejo de errores aceptando el argumento "
"de cadena *errors*:"

#: ../Doc/library/codecs.rst:324
msgid ""
"The following error handlers can be used with all Python :ref:`standard-"
"encodings` codecs:"
msgstr ""
"Los siguientes manejadores de errores se pueden emplear con todos los códecs "
"Python :ref:`standard-encodings`:"

#: ../Doc/library/codecs.rst:330 ../Doc/library/codecs.rst:373
#: ../Doc/library/codecs.rst:393
msgid "Value"
msgstr "Valor"

#: ../Doc/library/codecs.rst:330 ../Doc/library/codecs.rst:373
#: ../Doc/library/codecs.rst:393 ../Doc/library/codecs.rst:1327
#: ../Doc/library/codecs.rst:1395 ../Doc/library/codecs.rst:1450
msgid "Meaning"
msgstr "Significado"

#: ../Doc/library/codecs.rst:332
msgid "``'strict'``"
msgstr "``'strict'``"

#: ../Doc/library/codecs.rst:332
msgid ""
"Raise :exc:`UnicodeError` (or a subclass), this is the default. Implemented "
"in :func:`strict_errors`."
msgstr ""
"Lanza :exc:`UnicodeError` (o una subclase), este es el valor predeterminado. "
"Implementado en :func:`strictly_errors`."

#: ../Doc/library/codecs.rst:336
msgid "``'ignore'``"
msgstr "``'ignore'``"

#: ../Doc/library/codecs.rst:336
msgid ""
"Ignore the malformed data and continue without further notice. Implemented "
"in :func:`ignore_errors`."
msgstr ""
"Ignore los datos mal formados y continúe sin previo aviso. Implementado en :"
"func:`ignore_errors`."

#: ../Doc/library/codecs.rst:340
msgid "``'replace'``"
msgstr "``'replace'``"

#: ../Doc/library/codecs.rst:340
msgid ""
"Replace with a replacement marker. On encoding, use ``?`` (ASCII character). "
"On decoding, use ``�`` (U+FFFD, the official REPLACEMENT CHARACTER). "
"Implemented in :func:`replace_errors`."
msgstr ""
"Sustituir con un marcador de reemplazo. Al codificar, emplear ``?`` "
"(carácter ASCII). Al decodificar, usar ``�`` (U+FFFD, el CARÁCTER DE "
"REEMPLAZO oficial). Implementado en :func:`replace_errors`."

#: ../Doc/library/codecs.rst:346
msgid "``'backslashreplace'``"
msgstr "``'backslashreplace'``"

#: ../Doc/library/codecs.rst:346
msgid ""
"Replace with backslashed escape sequences. On encoding, use hexadecimal form "
"of Unicode code point with formats :samp:`\\\\x{hh}` :samp:`\\\\u{xxxx}` :"
"samp:`\\\\U{xxxxxxxx}`. On decoding, use hexadecimal form of byte value with "
"format :samp:`\\\\x{hh}`. Implemented in :func:`backslashreplace_errors`."
msgstr ""
"Reemplazar con secuencias de escape mediante barra invertida. Al codificar, "
"emplear la forma hexadecimal del punto de código Unicode con los formatos :"
"samp:`\\\\x{hh}` :samp:`\\\\u{xxxx}` :samp:`\\\\U{xxxxxxxx}`. Al "
"decodificar, usa la forma hexadecimal del valor del byte con el formato :"
"samp:`\\\\x{hh}`. Implementado en :func:`backslashreplace_errors`."

#: ../Doc/library/codecs.rst:355
msgid "``'surrogateescape'``"
msgstr "``'surrogateescape'``"

#: ../Doc/library/codecs.rst:355
msgid ""
"On decoding, replace byte with individual surrogate code ranging from "
"``U+DC80`` to ``U+DCFF``. This code will then be turned back into the same "
"byte when the ``'surrogateescape'`` error handler is used when encoding the "
"data. (See :pep:`383` for more.)"
msgstr ""
"En la decodificación, reemplace el byte con código sustituto individual que "
"va desde ``U+DC80`` a ``U+DCFF``. Este código se volverá a convertir en el "
"mismo byte cuando se use el manejador de errores ``'sustituto de paisaje'`` "
"al codificar los datos. (Ver :pep:`383` para más información)."

#: ../Doc/library/codecs.rst:369
msgid ""
"The following error handlers are only applicable to encoding (within :term:"
"`text encodings <text encoding>`):"
msgstr ""
"Los siguientes manejadores de errores solo son aplicables a :term:"
"`codificaciones de texto <text encoding>`:"

#: ../Doc/library/codecs.rst:375
msgid "``'xmlcharrefreplace'``"
msgstr "``'xmlcharrefreplace'``"

#: ../Doc/library/codecs.rst:375
msgid ""
"Replace with XML/HTML numeric character reference, which is a decimal form "
"of Unicode code point with format :samp:`&#{num};`. Implemented in :func:"
"`xmlcharrefreplace_errors`."
msgstr ""
"Reemplazar con una referencia de carácter numérico XML/HTML, que es una "
"forma decimal del punto de código Unicode con formato :samp:`&#{num};`. "
"Implementado en :func:`xmlcharrefreplace_errors`."

#: ../Doc/library/codecs.rst:381
msgid "``'namereplace'``"
msgstr "``'namereplace'``"

#: ../Doc/library/codecs.rst:381
msgid ""
"Replace with ``\\N{...}`` escape sequences, what appears in the braces is "
"the Name property from Unicode Character Database. Implemented in :func:"
"`namereplace_errors`."
msgstr ""
"Reemplazar con secuencias de escape ``\\N{...}``, lo que aparece entre "
"llaves, es la propiedad Nombre de la Base de datos de Caracteres Unicode. "
"Implementado en :func:`namereplace_errors`."

#: ../Doc/library/codecs.rst:390
msgid ""
"In addition, the following error handler is specific to the given codecs:"
msgstr ""
"Además, el siguiente manejador de errores es específico de los códecs dados:"

#: ../Doc/library/codecs.rst:13 ../Doc/library/codecs.rst:393
msgid "Codecs"
msgstr "Códecs"

#: ../Doc/library/codecs.rst:395
msgid "``'surrogatepass'``"
msgstr "``'surrogatepass'``"

#: ../Doc/library/codecs.rst:395
msgid "utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le"
msgstr "utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le"

#: ../Doc/library/codecs.rst:395
msgid ""
"Allow encoding and decoding surrogate code point (``U+D800`` - ``U+DFFF``) "
"as normal code point. Otherwise these codecs treat the presence of surrogate "
"code point in :class:`str` as an error."
msgstr ""
"Permite la codificación y decodificación del punto de código sustituto "
"(``U+D800`` - ``U+DFFF``) como punto de código normal. De lo contrario, "
"estos códecs tratan la presencia de un punto de código sustituto en :class:"
"`str` como un error."

#: ../Doc/library/codecs.rst:402
msgid "The ``'surrogateescape'`` and ``'surrogatepass'`` error handlers."
msgstr ""
"Los manejadores de errores ``'surrogateescape'`` y ``'surrogatepass'``."

#: ../Doc/library/codecs.rst:405
msgid ""
"The ``'surrogatepass'`` error handler now works with utf-16\\* and utf-32\\* "
"codecs."
msgstr ""
"Los manejadores de errores ``'surrogatepass'`` ahora funcionan con los "
"códecs utf-16\\* y utf-32\\*."

#: ../Doc/library/codecs.rst:409
msgid "The ``'namereplace'`` error handler."
msgstr "El manejador de errores ``'namereplace'``."

#: ../Doc/library/codecs.rst:412
msgid ""
"The ``'backslashreplace'`` error handler now works with decoding and "
"translating."
msgstr ""
"El manejador de errores ``'backslashreplace'`` ahora funciona con "
"decodificación y traducción."

#: ../Doc/library/codecs.rst:416
msgid ""
"The set of allowed values can be extended by registering a new named error "
"handler:"
msgstr ""
"El conjunto de valores permitidos puede ampliarse registrando un nuevo "
"manejador de errores con nombre:"

#: ../Doc/library/codecs.rst:421
msgid ""
"Register the error handling function *error_handler* under the name *name*. "
"The *error_handler* argument will be called during encoding and decoding in "
"case of an error, when *name* is specified as the errors parameter."
msgstr ""
"Registre la función de manejo de errores *error_handler* bajo el nombre "
"*name*. Se invocará el argumento *error_handler* durante la codificación y "
"decodificación en caso de error, cuando *name* se especifica como el "
"parámetro de errores."

#: ../Doc/library/codecs.rst:425
msgid ""
"For encoding, *error_handler* will be called with a :exc:"
"`UnicodeEncodeError` instance, which contains information about the location "
"of the error. The error handler must either raise this or a different "
"exception, or return a tuple with a replacement for the unencodable part of "
"the input and a position where encoding should continue. The replacement may "
"be either :class:`str` or :class:`bytes`. If the replacement is bytes, the "
"encoder will simply copy them into the output buffer. If the replacement is "
"a string, the encoder will encode the replacement. Encoding continues on "
"original input at the specified position. Negative position values will be "
"treated as being relative to the end of the input string. If the resulting "
"position is out of bound an :exc:`IndexError` will be raised."
msgstr ""
"Para la codificación, se llamará a *error_handler* con una instancia :exc:"
"`UnicodeEncodeError`, que contiene información sobre la ubicación del error. "
"El manejador de errores debe generar esta o una excepción diferente, o "
"retornar una tupla con un reemplazo para la parte no codificable de la "
"entrada y una posición donde la codificación debe continuar. El reemplazo "
"puede ser :class:`str` o :class:`bytes`. Si el reemplazo son bytes, el "
"codificador simplemente los copiará en el búfer de salida. Si el reemplazo "
"es una cadena de caracteres, el codificador codificará el reemplazo. La "
"codificación continúa en la entrada original en la posición especificada. "
"Los valores de posición negativos se tratarán como relativos al final de la "
"cadena de entrada. Si la posición resultante está fuera del límite, se "
"lanzará :exc:`IndexError`."

#: ../Doc/library/codecs.rst:437
msgid ""
"Decoding and translating works similarly, except :exc:`UnicodeDecodeError` "
"or :exc:`UnicodeTranslateError` will be passed to the handler and that the "
"replacement from the error handler will be put into the output directly."
msgstr ""
"La decodificación y la traducción funcionan de manera similar, excepto que :"
"exc:`UnicodeDecodeError` o :exc:`UnicodeTranslateError` se pasarán al "
"manejador y el sustituto del manejador de errores se colocará directamente "
"en la salida."

#: ../Doc/library/codecs.rst:442
msgid ""
"Previously registered error handlers (including the standard error handlers) "
"can be looked up by name:"
msgstr ""
"Los manejadores de errores registrados previamente (incluidos los "
"manejadores de error estándar) se pueden buscar por nombre:"

#: ../Doc/library/codecs.rst:447
msgid "Return the error handler previously registered under the name *name*."
msgstr ""
"Retorna el manejador de errores previamente registrado con el nombre *name*."

#: ../Doc/library/codecs.rst:449
msgid "Raises a :exc:`LookupError` in case the handler cannot be found."
msgstr ""
"Lanza un :exc:`LookupError` en caso de que no se pueda encontrar el "
"controlador."

#: ../Doc/library/codecs.rst:451
msgid ""
"The following standard error handlers are also made available as module "
"level functions:"
msgstr ""
"Los siguientes manejadores de errores estándar también están disponibles "
"como funciones de nivel de módulo:"

#: ../Doc/library/codecs.rst:456
msgid "Implements the ``'strict'`` error handling."
msgstr "Implementa el manejo de errores ``'strict'``."

#: ../Doc/library/codecs.rst:458
msgid "Each encoding or decoding error raises a :exc:`UnicodeError`."
msgstr ""
"Cada error de codificación o decodificación genera un :exc:`UnicodeError`."

#: ../Doc/library/codecs.rst:463
msgid "Implements the ``'ignore'`` error handling."
msgstr "Implementa el manejo de errores ``'ignore'``."

#: ../Doc/library/codecs.rst:465
msgid ""
"Malformed data is ignored; encoding or decoding is continued without further "
"notice."
msgstr ""
"Los datos con formato incorrecto se ignoran; la codificación o "
"decodificación continúa sin previo aviso."

#: ../Doc/library/codecs.rst:471
msgid "Implements the ``'replace'`` error handling."
msgstr "Implementa el manejo de errores ``'replace'`` ."

#: ../Doc/library/codecs.rst:473
msgid ""
"Substitutes ``?`` (ASCII character) for encoding errors or ``�`` (U+FFFD, "
"the official REPLACEMENT CHARACTER) for decoding errors."
msgstr ""
"Sustituye ``?`` (carácter ASCII) por errores de codificación o ``�`` "
"(U+FFFD, el CARÁCTER DE REEMPLAZO oficial) por errores de decodificación."

#: ../Doc/library/codecs.rst:479
msgid "Implements the ``'backslashreplace'`` error handling."
msgstr "Implementa el manejador de errores ``'backslashreplace'``."

#: ../Doc/library/codecs.rst:481
msgid ""
"Malformed data is replaced by a backslashed escape sequence. On encoding, "
"use the hexadecimal form of Unicode code point with formats :samp:`\\\\x{hh}"
"` :samp:`\\\\u{xxxx}` :samp:`\\\\U{xxxxxxxx}`. On decoding, use the "
"hexadecimal form of byte value with format :samp:`\\\\x{hh}`."
msgstr ""
"Los datos con formato incorrecto se reemplazan por una secuencia de escape "
"con barra invertida. Al codificar, emplea la forma hexadecimal del punto de "
"código Unicode con los formatos :samp:`\\\\x{hh}` :samp:`\\\\u{xxxx}` :samp:"
"`\\\\U{xxxxxxxx}`. Al decodificar, usa la forma hexadecimal del valor del "
"byte con el formato :samp:`\\\\x{hh}`."

#: ../Doc/library/codecs.rst:487
msgid "Works with decoding and translating."
msgstr "Funciona con la decodificación y traducción."

#: ../Doc/library/codecs.rst:493
msgid ""
"Implements the ``'xmlcharrefreplace'`` error handling (for encoding within :"
"term:`text encoding` only)."
msgstr ""
"Implementa el manejador de errores ``'xmlcharrefreplace'`` (solo para "
"codificar dentro de :term:`text encoding`)."

#: ../Doc/library/codecs.rst:496
msgid ""
"The unencodable character is replaced by an appropriate XML/HTML numeric "
"character reference, which is a decimal form of Unicode code point with "
"format :samp:`&#{num};` ."
msgstr ""
"El carácter no codificable se reemplaza por una referencia de carácter "
"numérico XML/HTML adecuada, que es una forma decimal del punto de código "
"Unicode con formato :samp:`&#{num};` ."

#: ../Doc/library/codecs.rst:503
msgid ""
"Implements the ``'namereplace'`` error handling (for encoding within :term:"
"`text encoding` only)."
msgstr ""
"Implementa el manejo de errores ``'namereplace`` (solo para codificar dentro "
"de :term:`text encoding`)."

#: ../Doc/library/codecs.rst:506
msgid ""
"The unencodable character is replaced by a ``\\N{...}`` escape sequence. The "
"set of characters that appear in the braces is the Name property from "
"Unicode Character Database. For example, the German lowercase letter ``'ß'`` "
"will be converted to byte sequence ``\\N{LATIN SMALL LETTER SHARP S}`` ."
msgstr ""
"El carácter no codificable se reemplaza por una secuencia de escape "
"``\\N{...}``. El conjunto de caracteres que aparecen entre llaves es la "
"propiedad Nombre de la Base de datos de Caracteres Unicode. Por ejemplo, la "
"letra minúscula alemana ``'ß'`` se convertirá en la secuencia de bytes "
"``\\N{LATIN SMALL LETTER SHARP S}`` ."

#: ../Doc/library/codecs.rst:517
msgid "Stateless Encoding and Decoding"
msgstr "Codificación y decodificación sin estado"

#: ../Doc/library/codecs.rst:519
msgid ""
"The base :class:`Codec` class defines these methods which also define the "
"function interfaces of the stateless encoder and decoder:"
msgstr ""
"La clase base :class:`Codec` define estos métodos que también definen las "
"interfaces de función del codificador y decodificador sin estado:"

#: ../Doc/library/codecs.rst:525
msgid ""
"Encodes the object *input* and returns a tuple (output object, length "
"consumed). For instance, :term:`text encoding` converts a string object to a "
"bytes object using a particular character set encoding (e.g., ``cp1252`` or "
"``iso-8859-1``)."
msgstr ""
"Codifica el objeto *input* y retorna una tupla (objeto de salida, longitud "
"consumida). Por ejemplo :term:`text encoding` convierte un objeto de cadena "
"de caracteres en un objeto de bytes utilizando una codificación de juego de "
"caracteres particular (por ejemplo,``cp1252`` o ``iso-8859-1``)."

#: ../Doc/library/codecs.rst:530 ../Doc/library/codecs.rst:552
msgid ""
"The *errors* argument defines the error handling to apply. It defaults to "
"``'strict'`` handling."
msgstr ""
"El argumento *errors* define el manejo de errores a aplicar. El valor "
"predeterminado es el manejo ``estricto``."

#: ../Doc/library/codecs.rst:533
msgid ""
"The method may not store state in the :class:`Codec` instance. Use :class:"
"`StreamWriter` for codecs which have to keep state in order to make encoding "
"efficient."
msgstr ""
"Es posible que el método no almacene estado en la instancia :class:`Codec`. "
"Use :class:`StreamWriter` para códecs que deben mantener el estado para que "
"la codificación sea eficiente."

#: ../Doc/library/codecs.rst:537
msgid ""
"The encoder must be able to handle zero length input and return an empty "
"object of the output object type in this situation."
msgstr ""
"El codificador debe poder manejar la entrada de longitud cero y retornar un "
"objeto vacío del tipo de objeto de salida en esta situación."

#: ../Doc/library/codecs.rst:543
msgid ""
"Decodes the object *input* and returns a tuple (output object, length "
"consumed). For instance, for a :term:`text encoding`, decoding converts a "
"bytes object encoded using a particular character set encoding to a string "
"object."
msgstr ""
"Decodifica el objeto *input* y retorna una tupla (objeto de salida, longitud "
"consumida). Por ejemplo, para un :term:`codificación de texto`, la "
"decodificación convierte un objeto de bytes codificado usando una "
"codificación de juego de caracteres particular en un objeto de cadena de "
"caracteres."

#: ../Doc/library/codecs.rst:548
msgid ""
"For text encodings and bytes-to-bytes codecs, *input* must be a bytes object "
"or one which provides the read-only buffer interface -- for example, buffer "
"objects and memory mapped files."
msgstr ""
"Para codificaciones de texto y códecs de bytes a bytes, *input* debe ser un "
"objeto de bytes o uno que proporcione la interfaz de búfer de solo lectura, "
"por ejemplo, objetos de búfer y archivos mapeados en memoria."

#: ../Doc/library/codecs.rst:555
msgid ""
"The method may not store state in the :class:`Codec` instance. Use :class:"
"`StreamReader` for codecs which have to keep state in order to make decoding "
"efficient."
msgstr ""
"Es posible que el método no almacene estado en la instancia de :class:"
"`Codec`. Use :class:`StreamReader` para códecs que deben mantener el estado "
"para que la decodificación sea eficiente."

#: ../Doc/library/codecs.rst:559
msgid ""
"The decoder must be able to handle zero length input and return an empty "
"object of the output object type in this situation."
msgstr ""
"El decodificador debe poder manejar la entrada de longitud cero y retornar "
"un objeto vacío del tipo de objeto de salida en esta situación."

#: ../Doc/library/codecs.rst:564
msgid "Incremental Encoding and Decoding"
msgstr "Codificación y decodificación incrementales"

#: ../Doc/library/codecs.rst:566
msgid ""
"The :class:`IncrementalEncoder` and :class:`IncrementalDecoder` classes "
"provide the basic interface for incremental encoding and decoding. Encoding/"
"decoding the input isn't done with one call to the stateless encoder/decoder "
"function, but with multiple calls to the :meth:`~IncrementalEncoder.encode`/:"
"meth:`~IncrementalDecoder.decode` method of the incremental encoder/decoder. "
"The incremental encoder/decoder keeps track of the encoding/decoding process "
"during method calls."
msgstr ""
"Las clases :class:`IncrementalEncoder` y :class:`IncrementalDecoder` "
"proporcionan la interfaz básica para la codificación y decodificación "
"incrementales. La codificación/decodificación de la entrada no se realiza "
"con una llamada a la función de codificador/decodificador sin estado, sino "
"con varias llamadas al método :meth:`~IncrementalEncoder.encode`/:meth:"
"`~IncrementalDecoder.decode` del codificador incremental /decodificador. El "
"codificador/decodificador incremental realiza un seguimiento del proceso de "
"codificación/decodificación durante las llamadas a métodos."

#: ../Doc/library/codecs.rst:574
msgid ""
"The joined output of calls to the :meth:`~IncrementalEncoder.encode`/:meth:"
"`~IncrementalDecoder.decode` method is the same as if all the single inputs "
"were joined into one, and this input was encoded/decoded with the stateless "
"encoder/decoder."
msgstr ""
"La salida combinada de las llamadas al método :meth:`~IncrementalEncoder."
"encode`/:meth:`~IncrementalDecoder.decode` es el mismo que si todas las "
"entradas individuales se unieran en una, y esta entrada se codificara/"
"decodificara con codificador/decodificador sin estado."

#: ../Doc/library/codecs.rst:583
msgid "IncrementalEncoder Objects"
msgstr "Objetos IncrementalEncoder"

#: ../Doc/library/codecs.rst:585
msgid ""
"The :class:`IncrementalEncoder` class is used for encoding an input in "
"multiple steps. It defines the following methods which every incremental "
"encoder must define in order to be compatible with the Python codec registry."
msgstr ""
"La clase :class:`IncrementalEncoder` se usa para codificar una entrada en "
"varios pasos. Define los siguientes métodos que cada codificador incremental "
"debe definir para ser compatible con el registro de códec Python."

#: ../Doc/library/codecs.rst:592
msgid "Constructor for an :class:`IncrementalEncoder` instance."
msgstr "Constructor para una clase instancia de :class:`IncrementalEncoder`."

#: ../Doc/library/codecs.rst:594
msgid ""
"All incremental encoders must provide this constructor interface. They are "
"free to add additional keyword arguments, but only the ones defined here are "
"used by the Python codec registry."
msgstr ""
"Todos los codificadores incrementales deben proporcionar esta interfaz de "
"constructor. Son libres de agregar argumentos de palabras clave adicionales, "
"pero el registro de códecs de Python solo utiliza los definidos aquí."

#: ../Doc/library/codecs.rst:598
msgid ""
"The :class:`IncrementalEncoder` may implement different error handling "
"schemes by providing the *errors* keyword argument. See :ref:`error-"
"handlers` for possible values."
msgstr ""
"La clase :class:`IncrementalEncoder` puede implementar diferentes esquemas "
"de manejo de errores al proporcionar el argumento de palabra clave *errors*. "
"Ver :ref:`error-handlers` para posibles valores."

#: ../Doc/library/codecs.rst:602
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:"
"`IncrementalEncoder` object."
msgstr ""
"El argumento *errors* se asignará a un atributo del mismo nombre. La "
"asignación a este atributo hace posible cambiar entre diferentes estrategias "
"de manejo de errores durante la vida útil del objeto :class:"
"`IncrementalEncoder`."

#: ../Doc/library/codecs.rst:610
msgid ""
"Encodes *object* (taking the current state of the encoder into account) and "
"returns the resulting encoded object. If this is the last call to :meth:"
"`encode` *final* must be true (the default is false)."
msgstr ""
"Codifica *object* (teniendo en cuenta el estado actual del codificador) y "
"retorna el objeto codificado resultante. Si esta es la última llamada a :"
"meth:`encode` *final* debe ser verdadero (el valor predeterminado es falso)."

#: ../Doc/library/codecs.rst:617
msgid ""
"Reset the encoder to the initial state. The output is discarded: call ``."
"encode(object, final=True)``, passing an empty byte or text string if "
"necessary, to reset the encoder and to get the output."
msgstr ""
"Restablece el codificador al estado inicial. La salida se descarta: llama a "
"``.encode(object, final=True)``, pasando un byte vacío o una cadena de texto "
"si es necesario, para restablecer el codificador y obtener la salida."

#: ../Doc/library/codecs.rst:624
msgid ""
"Return the current state of the encoder which must be an integer. The "
"implementation should make sure that ``0`` is the most common state. (States "
"that are more complicated than integers can be converted into an integer by "
"marshaling/pickling the state and encoding the bytes of the resulting string "
"into an integer.)"
msgstr ""
"Retorna el estado actual del codificador que debe ser un número entero. La "
"implementación debe asegurarse de que ``0`` sea el estado más común. (Los "
"estados que son más complicados que los enteros se pueden convertir en un "
"entero al empaquetar/serializar el estado y codificar los bytes de la cadena "
"resultante en un entero)."

#: ../Doc/library/codecs.rst:633
msgid ""
"Set the state of the encoder to *state*. *state* must be an encoder state "
"returned by :meth:`getstate`."
msgstr ""
"Establece el estado del codificador en *state*. *state* debe ser un estado "
"de codificador retornado por :meth:`getstate`."

#: ../Doc/library/codecs.rst:640
msgid "IncrementalDecoder Objects"
msgstr "Objetos IncrementalDecoder"

#: ../Doc/library/codecs.rst:642
msgid ""
"The :class:`IncrementalDecoder` class is used for decoding an input in "
"multiple steps. It defines the following methods which every incremental "
"decoder must define in order to be compatible with the Python codec registry."
msgstr ""
"La clase :class:`IncrementalDecoder` se usa para decodificar una entrada en "
"varios pasos. Define los siguientes métodos que cada decodificador "
"incremental debe definir para ser compatible con el registro de códec Python."

#: ../Doc/library/codecs.rst:649
msgid "Constructor for an :class:`IncrementalDecoder` instance."
msgstr "Constructor para una instancia de :class:`IncrementalDecoder`."

#: ../Doc/library/codecs.rst:651
msgid ""
"All incremental decoders must provide this constructor interface. They are "
"free to add additional keyword arguments, but only the ones defined here are "
"used by the Python codec registry."
msgstr ""
"Todos los decodificadores incrementales deben proporcionar esta interfaz de "
"constructor. Son libres de agregar argumentos de palabras clave adicionales, "
"pero el registro de códecs de Python solo utiliza los definidos aquí."

#: ../Doc/library/codecs.rst:655
msgid ""
"The :class:`IncrementalDecoder` may implement different error handling "
"schemes by providing the *errors* keyword argument. See :ref:`error-"
"handlers` for possible values."
msgstr ""
"La clase :class:`IncrementalDecoder` puede implementar diferentes esquemas "
"de manejo de errores al proporcionar el argumento de palabra clave *errors*. "
"Ver :ref:`error-handlers` para posibles valores."

#: ../Doc/library/codecs.rst:659
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:"
"`IncrementalDecoder` object."
msgstr ""
"El argumento *errors* se asignará a un atributo del mismo nombre. La "
"asignación a este atributo hace posible cambiar entre diferentes estrategias "
"de manejo de errores durante la vida útil del objeto :class:"
"`IncrementalDecoder`."

#: ../Doc/library/codecs.rst:667
msgid ""
"Decodes *object* (taking the current state of the decoder into account) and "
"returns the resulting decoded object. If this is the last call to :meth:"
"`decode` *final* must be true (the default is false). If *final* is true the "
"decoder must decode the input completely and must flush all buffers. If this "
"isn't possible (e.g. because of incomplete byte sequences at the end of the "
"input) it must initiate error handling just like in the stateless case "
"(which might raise an exception)."
msgstr ""
"Decodifica *object* (teniendo en cuenta el estado actual del decodificador) "
"y retorna el objeto decodificado resultante. Si esta es la última llamada a :"
"meth:`decode` *final* debe ser verdadero (el valor predeterminado es falso). "
"Si *final* es verdadero, el decodificador debe decodificar la entrada por "
"completo y debe vaciar todos los búferes. Si esto no es posible (por "
"ejemplo, debido a secuencias de bytes incompletas al final de la entrada), "
"debe iniciar el manejo de errores al igual que en el caso sin estado (lo que "
"podría generar una excepción)."

#: ../Doc/library/codecs.rst:678
msgid "Reset the decoder to the initial state."
msgstr "Restablece el decodificador al estado inicial."

#: ../Doc/library/codecs.rst:683
msgid ""
"Return the current state of the decoder. This must be a tuple with two "
"items, the first must be the buffer containing the still undecoded input. "
"The second must be an integer and can be additional state info. (The "
"implementation should make sure that ``0`` is the most common additional "
"state info.) If this additional state info is ``0`` it must be possible to "
"set the decoder to the state which has no input buffered and ``0`` as the "
"additional state info, so that feeding the previously buffered input to the "
"decoder returns it to the previous state without producing any output. "
"(Additional state info that is more complicated than integers can be "
"converted into an integer by marshaling/pickling the info and encoding the "
"bytes of the resulting string into an integer.)"
msgstr ""
"Retorna el estado actual del decodificador. Debe ser una tupla con dos "
"elementos, el primero debe ser el búfer que contiene la entrada aún sin "
"codificar. El segundo debe ser un número entero y puede ser información de "
"estado adicional. (La implementación debe asegurarse de que ``0`` sea la "
"información de estado adicional más común). Si esta información de estado "
"adicional es ``0``, debe ser posible establecer el decodificador en el "
"estado que no tiene entrada almacenada y ``0`` como información de estado "
"adicional, de modo que alimentar la entrada previamente almacenada en el "
"búfer al decodificador la retorna al estado anterior sin producir ninguna "
"salida. (La información de estado adicional que es más complicada que los "
"enteros se puede convertir en un entero al empaquetar/serializar la "
"información y codificar los bytes de la cadena resultante en un entero)."

#: ../Doc/library/codecs.rst:698
msgid ""
"Set the state of the decoder to *state*. *state* must be a decoder state "
"returned by :meth:`getstate`."
msgstr ""
"Establezca el estado del decodificador en *state*. *state* debe ser un "
"estado de decodificador retornado por :meth:`getstate`."

#: ../Doc/library/codecs.rst:703
msgid "Stream Encoding and Decoding"
msgstr "Codificación y decodificación de flujos"

#: ../Doc/library/codecs.rst:706
msgid ""
"The :class:`StreamWriter` and :class:`StreamReader` classes provide generic "
"working interfaces which can be used to implement new encoding submodules "
"very easily. See :mod:`encodings.utf_8` for an example of how this is done."
msgstr ""
"Las clases :class:`StreamWriter` y :class:`StreamReader` proporcionan "
"interfaces de trabajo genéricas que se pueden usar para implementar nuevos "
"submódulos de codificación muy fácilmente. Ir a :mod:`encodings.utf_8` para "
"ver un ejemplo de cómo se hace esto."

#: ../Doc/library/codecs.rst:714
msgid "StreamWriter Objects"
msgstr "Objetos StreamWriter"

#: ../Doc/library/codecs.rst:716
msgid ""
"The :class:`StreamWriter` class is a subclass of :class:`Codec` and defines "
"the following methods which every stream writer must define in order to be "
"compatible with the Python codec registry."
msgstr ""
"La clase :class:`StreamWriter` es una subclase de :class:`Codec` y define "
"los siguientes métodos que cada escritor del flujo debe definir para ser "
"compatible con el registro de códecs Python."

#: ../Doc/library/codecs.rst:723
msgid "Constructor for a :class:`StreamWriter` instance."
msgstr "Constructor para una instancia de :class:`StreamWriter`."

#: ../Doc/library/codecs.rst:725
msgid ""
"All stream writers must provide this constructor interface. They are free to "
"add additional keyword arguments, but only the ones defined here are used by "
"the Python codec registry."
msgstr ""
"Todos los escritores de flujos deben proporcionar esta interfaz de "
"constructor. Son libres de agregar argumentos de palabras clave adicionales, "
"pero el registro de códecs de Python solo utiliza los definidos aquí."

#: ../Doc/library/codecs.rst:729
msgid ""
"The *stream* argument must be a file-like object open for writing text or "
"binary data, as appropriate for the specific codec."
msgstr ""
"El argumento *stream* debe ser un objeto tipo archivo abierto para escribir "
"texto o datos binarios, según corresponda para el códec específico."

#: ../Doc/library/codecs.rst:732
msgid ""
"The :class:`StreamWriter` may implement different error handling schemes by "
"providing the *errors* keyword argument. See :ref:`error-handlers` for the "
"standard error handlers the underlying stream codec may support."
msgstr ""
"La clase :class:`StreamWriter` puede implementar diferentes esquemas de "
"manejo de errores al proporcionar el argumento de palabra clave *errors*. "
"Consulte :ref:`error-handlers` para ver los manejadores de errores estándar "
"que puede admitir el códec de flujo subyacente."

#: ../Doc/library/codecs.rst:736
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:`StreamWriter` "
"object."
msgstr ""
"El argumento *errors* se asignará a un atributo del mismo nombre. La "
"asignación a este atributo hace posible cambiar entre diferentes estrategias "
"de manejo de errores durante la vida útil del objeto :class:`StreamWriter`."

#: ../Doc/library/codecs.rst:742
msgid "Writes the object's contents encoded to the stream."
msgstr "Escribe el contenido del objeto codificado en el flujo."

#: ../Doc/library/codecs.rst:747
msgid ""
"Writes the concatenated iterable of strings to the stream (possibly by "
"reusing the :meth:`write` method). Infinite or very large iterables are not "
"supported. The standard bytes-to-bytes codecs do not support this method."
msgstr ""
"Escribe una lista concatenada de cadenas en el flujo (posiblemente "
"reutilizando el método :meth:`write`). No se admiten iterables infinitos o "
"muy grandes. Los códecs estándar de bytes a bytes no admiten este método."

#: ../Doc/library/codecs.rst:755 ../Doc/library/codecs.rst:850
msgid "Resets the codec buffers used for keeping internal state."
msgstr ""
"Restablece los búfers de códec utilizados para mantener el estado interno."

#: ../Doc/library/codecs.rst:757
msgid ""
"Calling this method should ensure that the data on the output is put into a "
"clean state that allows appending of new fresh data without having to rescan "
"the whole stream to recover state."
msgstr ""
"Llamar a este método debería garantizar que los datos en la salida se pongan "
"en un estado limpio que permita agregar datos nuevos sin tener que volver a "
"escanear todo el flujo para recuperar el estado."

#: ../Doc/library/codecs.rst:762
msgid ""
"In addition to the above methods, the :class:`StreamWriter` must also "
"inherit all other methods and attributes from the underlying stream."
msgstr ""
"Además de los métodos anteriores, la clase :class:`StreamWriter` también "
"debe heredar todos los demás métodos y atributos del flujo subyacente."

#: ../Doc/library/codecs.rst:769
msgid "StreamReader Objects"
msgstr "Objetos StreamReader"

#: ../Doc/library/codecs.rst:771
msgid ""
"The :class:`StreamReader` class is a subclass of :class:`Codec` and defines "
"the following methods which every stream reader must define in order to be "
"compatible with the Python codec registry."
msgstr ""
"La clase :class:`StreamReader` es una subclase de :class:`Codec` y define "
"los siguientes métodos que cada lector de flujo debe definir para ser "
"compatible con el registro de códecs de Python."

#: ../Doc/library/codecs.rst:778
msgid "Constructor for a :class:`StreamReader` instance."
msgstr "Constructor para una instancia de :class:`StreamReader`."

#: ../Doc/library/codecs.rst:780
msgid ""
"All stream readers must provide this constructor interface. They are free to "
"add additional keyword arguments, but only the ones defined here are used by "
"the Python codec registry."
msgstr ""
"Todos los lectores de flujo deben proporcionar esta interfaz de constructor. "
"Son libres de agregar argumentos de palabras clave adicionales, pero el "
"registro de códecs de Python solo utiliza los definidos aquí."

#: ../Doc/library/codecs.rst:784
msgid ""
"The *stream* argument must be a file-like object open for reading text or "
"binary data, as appropriate for the specific codec."
msgstr ""
"El argumento *stream* debe ser un objeto tipo archivo abierto para leer "
"texto o datos binarios, según corresponda para el códec específico."

#: ../Doc/library/codecs.rst:787
msgid ""
"The :class:`StreamReader` may implement different error handling schemes by "
"providing the *errors* keyword argument. See :ref:`error-handlers` for the "
"standard error handlers the underlying stream codec may support."
msgstr ""
"La clase :class:`StreamReader` puede implementar diferentes esquemas de "
"manejo de errores al proporcionar el argumento de palabra clave *errors*. "
"Consulte :ref:`error-handlers` para ver los manejadores de errores estándar "
"que puede admitir el códec de flujo subyacente."

#: ../Doc/library/codecs.rst:791
msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:`StreamReader` "
"object."
msgstr ""
"El argumento *errors* se asignará a un atributo del mismo nombre. La "
"asignación a este atributo hace posible cambiar entre diferentes estrategias "
"de manejo de errores durante la vida útil del objeto :class:`StreamReader`."

#: ../Doc/library/codecs.rst:795
msgid ""
"The set of allowed values for the *errors* argument can be extended with :"
"func:`register_error`."
msgstr ""
"El conjunto de valores permitidos para el argumento *errors* se puede "
"ampliar con :func:`register_error`."

#: ../Doc/library/codecs.rst:801
msgid "Decodes data from the stream and returns the resulting object."
msgstr "Decodifica datos del flujo y retorna el objeto resultante."

#: ../Doc/library/codecs.rst:803
msgid ""
"The *chars* argument indicates the number of decoded code points or bytes to "
"return. The :func:`read` method will never return more data than requested, "
"but it might return less, if there is not enough available."
msgstr ""
"El argumento *chars* indica el número de puntos de código decodificados o "
"bytes a retornar. El método :func:`read` nunca retornará más datos de los "
"solicitados, pero podría retornar menos, si no hay suficientes disponibles."

#: ../Doc/library/codecs.rst:808
msgid ""
"The *size* argument indicates the approximate maximum number of encoded "
"bytes or code points to read for decoding. The decoder can modify this "
"setting as appropriate. The default value -1 indicates to read and decode as "
"much as possible. This parameter is intended to prevent having to decode "
"huge files in one step."
msgstr ""
"El argumento *size* indica el número máximo aproximado de bytes codificados "
"o puntos de código para leer para la decodificación. El decodificador puede "
"modificar esta configuración según corresponda. El valor predeterminado -1 "
"indica leer y decodificar tanto como sea posible. Este parámetro está "
"diseñado para evitar tener que decodificar archivos grandes en un solo paso."

#: ../Doc/library/codecs.rst:815
msgid ""
"The *firstline* flag indicates that it would be sufficient to only return "
"the first line, if there are decoding errors on later lines."
msgstr ""
"La bandera *firstline* indica que sería suficiente retornar solo la primera "
"línea, si hay errores de decodificación en las líneas posteriores."

#: ../Doc/library/codecs.rst:819
msgid ""
"The method should use a greedy read strategy meaning that it should read as "
"much data as is allowed within the definition of the encoding and the given "
"size, e.g.  if optional encoding endings or state markers are available on "
"the stream, these should be read too."
msgstr ""
"El método debe usar una estrategia de lectura codiciosa, lo que significa "
"que debe leer la mayor cantidad de datos permitidos dentro de la definición "
"de la codificación y el tamaño dado, por ejemplo si las terminaciones de "
"codificación opcionales o los marcadores de estado están disponibles en la "
"transmisión, también deben leerse."

#: ../Doc/library/codecs.rst:827
msgid "Read one line from the input stream and return the decoded data."
msgstr "Lee una línea del flujo de entrada y retorna los datos decodificados."

#: ../Doc/library/codecs.rst:829
msgid ""
"*size*, if given, is passed as size argument to the stream's :meth:`read` "
"method."
msgstr ""
"*size*, si se da, se pasa como argumento de tamaño al método :meth:`read` "
"del *stream*."

#: ../Doc/library/codecs.rst:832
msgid ""
"If *keepends* is false line-endings will be stripped from the lines returned."
msgstr ""
"Si *keepends* es falso, las terminaciones de línea se eliminarán de las "
"líneas retornadas."

#: ../Doc/library/codecs.rst:838
msgid ""
"Read all lines available on the input stream and return them as a list of "
"lines."
msgstr ""
"Lee todas las líneas disponibles en el flujo de entrada y las retorna como "
"una lista de líneas."

#: ../Doc/library/codecs.rst:841
msgid ""
"Line-endings are implemented using the codec's :meth:`decode` method and are "
"included in the list entries if *keepends* is true."
msgstr ""
"Los finales de línea se implementan utilizando el método :meth:`decode` del "
"códec y se incluyen en las entradas de la lista si *keepends* es verdadero."

#: ../Doc/library/codecs.rst:844
msgid ""
"*sizehint*, if given, is passed as the *size* argument to the stream's :meth:"
"`read` method."
msgstr ""
"*sizehint*, si se proporciona, se pasa como argumento *size* al método :meth:"
"`read` del *stream*."

#: ../Doc/library/codecs.rst:852
msgid ""
"Note that no stream repositioning should take place. This method is "
"primarily intended to be able to recover from decoding errors."
msgstr ""
"Tenga en cuenta que ningún reposicionamiento de flujo debe suceder. Este "
"método está destinado principalmente a poder recuperarse de errores de "
"decodificación."

#: ../Doc/library/codecs.rst:856
msgid ""
"In addition to the above methods, the :class:`StreamReader` must also "
"inherit all other methods and attributes from the underlying stream."
msgstr ""
"Además de los métodos anteriores, la clase :class:`StreamReader` también "
"debe heredar todos los demás métodos y atributos del flujo subyacente."

#: ../Doc/library/codecs.rst:862
msgid "StreamReaderWriter Objects"
msgstr "Objetos StreamReaderWriter"

#: ../Doc/library/codecs.rst:864
msgid ""
"The :class:`StreamReaderWriter` is a convenience class that allows wrapping "
"streams which work in both read and write modes."
msgstr ""
"La clase :class:`StreamReaderWriter` es una clase de conveniencia que "
"permite envolver flujos que funcionan tanto en modo de lectura como de "
"escritura."

#: ../Doc/library/codecs.rst:867 ../Doc/library/codecs.rst:891
msgid ""
"The design is such that one can use the factory functions returned by the :"
"func:`lookup` function to construct the instance."
msgstr ""
"El diseño es tal que uno puede usar las funciones de fábrica retornadas por "
"la función :func:`lookup` para construir la instancia."

#: ../Doc/library/codecs.rst:873
msgid ""
"Creates a :class:`StreamReaderWriter` instance. *stream* must be a file-like "
"object. *Reader* and *Writer* must be factory functions or classes providing "
"the :class:`StreamReader` and :class:`StreamWriter` interface resp. Error "
"handling is done in the same way as defined for the stream readers and "
"writers."
msgstr ""
"Crea una instancia de :class:`StreamReaderWriter`. *stream* debe ser un "
"objeto similar a un archivo. *Reader* y *Writer* deben ser funciones o "
"clases de fábrica que proporcionen la interfaz :class:`StreamReader` y :"
"class:`StreamWriter` respectivamente. El manejo de errores se realiza de la "
"misma manera que se define para los lectores y escritores de flujos."

#: ../Doc/library/codecs.rst:878
msgid ""
":class:`StreamReaderWriter` instances define the combined interfaces of :"
"class:`StreamReader` and :class:`StreamWriter` classes. They inherit all "
"other methods and attributes from the underlying stream."
msgstr ""
"Las instancias :class:`StreamReaderWriter` definen las interfaces combinadas "
"de :class:`StreamReader` y clases :class:`StreamWriter`. Heredan todos los "
"demás métodos y atributos del flujo subyacente."

#: ../Doc/library/codecs.rst:886
msgid "StreamRecoder Objects"
msgstr "Objetos StreamRecoder"

#: ../Doc/library/codecs.rst:888
msgid ""
"The :class:`StreamRecoder` translates data from one encoding to another, "
"which is sometimes useful when dealing with different encoding environments."
msgstr ""
"La clase :class:`StreamRecoder` traduce datos de una codificación a otra, lo "
"que a veces es útil cuando se trata de diferentes entornos de codificación."

#: ../Doc/library/codecs.rst:897
msgid ""
"Creates a :class:`StreamRecoder` instance which implements a two-way "
"conversion: *encode* and *decode* work on the frontend — the data visible to "
"code calling :meth:`read` and :meth:`write`, while *Reader* and *Writer* "
"work on the backend — the data in *stream*."
msgstr ""
"Crea una instancia de :class:`StreamRecoder` que implementa una conversión "
"bidireccional: *encode* y *decode* funcionan en el *frontend*: los datos "
"visibles para la llamada de código :meth:`read` y :meth:`write`, mientras "
"que *Reader* y *Writer* funcionan en el *backend* --- los datos en *stream*."

#: ../Doc/library/codecs.rst:902
msgid ""
"You can use these objects to do transparent transcodings, e.g., from Latin-1 "
"to UTF-8 and back."
msgstr ""
"Puede usar estos objetos para realizar transcodificaciones transparentes, "
"por ejemplo, de Latin-1 a UTF-8 y viceversa."

#: ../Doc/library/codecs.rst:905
msgid "The *stream* argument must be a file-like object."
msgstr "El argumento *stream* debe ser un objeto similar a un archivo."

#: ../Doc/library/codecs.rst:907
msgid ""
"The *encode* and *decode* arguments must adhere to the :class:`Codec` "
"interface. *Reader* and *Writer* must be factory functions or classes "
"providing objects of the :class:`StreamReader` and :class:`StreamWriter` "
"interface respectively."
msgstr ""
"Los argumentos *encode* y *decode* deben cumplir con la interfaz de :class:"
"`Codec`. *Reader* y *Writer* deben ser funciones o clases de fábrica que "
"proporcionen objetos de la interfaz :class:`StreamReader` y :class:"
"`StreamWriter` respectivamente."

#: ../Doc/library/codecs.rst:912
msgid ""
"Error handling is done in the same way as defined for the stream readers and "
"writers."
msgstr ""
"El manejo de errores se realiza de la misma manera que se define para los "
"lectores y escritores de flujos."

#: ../Doc/library/codecs.rst:916
msgid ""
":class:`StreamRecoder` instances define the combined interfaces of :class:"
"`StreamReader` and :class:`StreamWriter` classes. They inherit all other "
"methods and attributes from the underlying stream."
msgstr ""
"las instancias :class:`StreamRecoder` definen las interfaces combinadas de "
"las clases :class:`StreamReader` y :class:`StreamWriter`. Heredan todos los "
"demás métodos y atributos del flujo subyacente."

#: ../Doc/library/codecs.rst:924
msgid "Encodings and Unicode"
msgstr "Codificaciones y Unicode"

#: ../Doc/library/codecs.rst:926
msgid ""
"Strings are stored internally as sequences of code points in range "
"``U+0000``--``U+10FFFF``. (See :pep:`393` for more details about the "
"implementation.) Once a string object is used outside of CPU and memory, "
"endianness and how these arrays are stored as bytes become an issue. As with "
"other codecs, serialising a string into a sequence of bytes is known as "
"*encoding*, and recreating the string from the sequence of bytes is known as "
"*decoding*. There are a variety of different text serialisation codecs, "
"which are collectivity referred to as :term:`text encodings <text encoding>`."
msgstr ""
"Las cadenas de caracteres se almacenan internamente como secuencias de "
"puntos de código en el rango ``U+0000``--``U+10FFFF``. (Consultar :pep:`393` "
"para obtener más detalles sobre la implementación). Una vez utilizado un "
"objeto de cadena de caracteres fuera de la CPU y de la memoria, la "
"*endianness* y cómo se almacenan estas matrices como bytes se convierte en "
"un problema. Al igual que con otros códecs, la serialización de una cadena "
"en una secuencia de bytes se conoce como codificación, y la recreación de la "
"cadena a partir de los bytes se conoce como decodificación. Hay múltiples "
"códecs para la serialización de texto, a los que se puede consultar "
"colectivamente mediante :term:`text encodings <text encoding>`."

#: ../Doc/library/codecs.rst:936
msgid ""
"The simplest text encoding (called ``'latin-1'`` or ``'iso-8859-1'``) maps "
"the code points 0--255 to the bytes ``0x0``--``0xff``, which means that a "
"string object that contains code points above ``U+00FF`` can't be encoded "
"with this codec. Doing so will raise a :exc:`UnicodeEncodeError` that looks "
"like the following (although the details of the error message may differ): "
"``UnicodeEncodeError: 'latin-1' codec can't encode character '\\u1234' in "
"position 3: ordinal not in range(256)``."
msgstr ""
"La codificación de texto más simple (llamada ``'latin-1'`` o "
"``'iso-8859-1'``) asigna los puntos de código 0--255 a los bytes ``0x0`` -- "
"``0xff``, lo que significa que un objeto de cadena de caracteres que "
"contiene puntos de código encima de ``U+00FF`` no se puede codificar con "
"este códec. Al hacerlo, lanzará un :exc:`UnicodeEncodeError` que se parece a "
"lo siguiente (aunque los detalles del mensaje de error pueden diferir): "
"``UnicodeEncodeError: 'latin-1' codec can't encode character '\\u1234' 'in "
"position 3: ordinal not in range(256)``."

#: ../Doc/library/codecs.rst:944
msgid ""
"There's another group of encodings (the so called charmap encodings) that "
"choose a different subset of all Unicode code points and how these code "
"points are mapped to the bytes ``0x0``--``0xff``. To see how this is done "
"simply open e.g. :file:`encodings/cp1252.py` (which is an encoding that is "
"used primarily on Windows). There's a string constant with 256 characters "
"that shows you which character is mapped to which byte value."
msgstr ""
"Hay otro grupo de codificaciones (las llamadas codificaciones de mapa de "
"caracteres) que eligen un subconjunto diferente de todos los puntos de "
"código Unicode y cómo estos puntos de código se asignan a los bytes ``0x0`` "
"-- ``0xff``. Para ver cómo se hace esto, simplemente abra, por ejemplo :file:"
"`encodings/cp1252.py` (que es una codificación que se usa principalmente en "
"Windows). Hay una cadena constante con 256 caracteres que le muestra qué "
"carácter está asignado a qué valor de byte."

#: ../Doc/library/codecs.rst:951
msgid ""
"All of these encodings can only encode 256 of the 1114112 code points "
"defined in Unicode. A simple and straightforward way that can store each "
"Unicode code point, is to store each code point as four consecutive bytes. "
"There are two possibilities: store the bytes in big endian or in little "
"endian order. These two encodings are called ``UTF-32-BE`` and ``UTF-32-LE`` "
"respectively. Their disadvantage is that if e.g. you use ``UTF-32-BE`` on a "
"little endian machine you will always have to swap bytes on encoding and "
"decoding. ``UTF-32`` avoids this problem: bytes will always be in natural "
"endianness. When these bytes are read by a CPU with a different endianness, "
"then bytes have to be swapped though. To be able to detect the endianness of "
"a ``UTF-16`` or ``UTF-32`` byte sequence, there's the so called BOM (\"Byte "
"Order Mark\"). This is the Unicode character ``U+FEFF``. This character can "
"be prepended to every ``UTF-16`` or ``UTF-32`` byte sequence. The byte "
"swapped version of this character (``0xFFFE``) is an illegal character that "
"may not appear in a Unicode text. So when the first character in a "
"``UTF-16`` or ``UTF-32`` byte sequence appears to be a ``U+FFFE`` the bytes "
"have to be swapped on decoding. Unfortunately the character ``U+FEFF`` had a "
"second purpose as a ``ZERO WIDTH NO-BREAK SPACE``: a character that has no "
"width and doesn't allow a word to be split. It can e.g. be used to give "
"hints to a ligature algorithm. With Unicode 4.0 using ``U+FEFF`` as a ``ZERO "
"WIDTH NO-BREAK SPACE`` has been deprecated (with ``U+2060`` (``WORD "
"JOINER``) assuming this role). Nevertheless Unicode software still must be "
"able to handle ``U+FEFF`` in both roles: as a BOM it's a device to determine "
"the storage layout of the encoded bytes, and vanishes once the byte sequence "
"has been decoded into a string; as a ``ZERO WIDTH NO-BREAK SPACE`` it's a "
"normal character that will be decoded like any other."
msgstr ""
"Todas estas codificaciones solo pueden codificar 256 de los 1114112 puntos "
"de código definidos en Unicode. Una manera simple y directa que permita "
"almacenar cada punto de código Unicode, es almacenar cada punto de código "
"como cuatro bytes consecutivos. Hay dos posibilidades: almacenar los bytes "
"en orden *big endian* o *little endian*. Estas dos codificaciones se "
"denominan ``UTF-32-BE`` y ``UTF-32-LE`` respectivamente. Su desventaja es "
"que, si por ejemplo, usa ``UTF-32-BE`` en una pequeña máquina *endian*, "
"siempre tendrá que intercambiar bytes en la codificación y decodificación. "
"``UTF-32`` evita este problema: los bytes siempre estarán en *endianness* "
"natural. Cuando estos bytes son leídos por una CPU con una *endianness* "
"diferente, entonces los bytes deben intercambiarse. Para poder detectar el "
"*endian* de una secuencia de bytes ``UTF-16`` o ``UTF-32``, existe la "
"llamada BOM (\"Marca de orden de bytes\", o en inglés *Byte Order Mark*). "
"Este es el carácter Unicode ``U+FEFF``. Este carácter puede anteponerse a "
"cada secuencia de bytes ``UTF-16`` o ``UTF-32``. La versión intercambiada de "
"bytes de este carácter (``0xFFFE``) es un carácter ilegal que puede no "
"aparecer en un texto Unicode. Entonces, cuando el primer carácter en una "
"secuencia de bytes ``UTF-16`` o ``UTF-32`` parece ser un ``U+FFFE``, los "
"bytes deben intercambiarse en la decodificación. Desafortunadamente, el "
"carácter ``U+FEFF`` tenía un segundo propósito como ``ESPACIO DE ANCHO CERO "
"SIN QUIEBRA``: un carácter que no tiene ancho y no permite dividir una "
"palabra. Por ejemplo, puede ser usado para dar pistas a un algoritmo de "
"ligadura. Con Unicode 4.0, el uso de ``U+FEFF`` como ``ESPACIO DE ANCHO CERO "
"SIN QUIEBRA`` ha quedado obsoleto (con ``U+2060`` (``WORD JOINER``) "
"asumiendo este rol). Sin embargo, el software Unicode aún debe ser capaz de "
"manejar ``U+FEFF`` en ambos roles: como BOM, es un dispositivo para "
"determinar el diseño de almacenamiento de los bytes codificados, y "
"desaparece una vez que la secuencia de bytes ha sido decodificada en una "
"cadena; como un ``ESPACIO DE ANCHO CERO SIN QUIEBRA`` es un carácter normal "
"que se decodificará como cualquier otro."

#: ../Doc/library/codecs.rst:977
msgid ""
"There's another encoding that is able to encode the full range of Unicode "
"characters: UTF-8. UTF-8 is an 8-bit encoding, which means there are no "
"issues with byte order in UTF-8. Each byte in a UTF-8 byte sequence consists "
"of two parts: marker bits (the most significant bits) and payload bits. The "
"marker bits are a sequence of zero to four ``1`` bits followed by a ``0`` "
"bit. Unicode characters are encoded like this (with x being payload bits, "
"which when concatenated give the Unicode character):"
msgstr ""
"Hay otra codificación que puede codificar el rango completo de caracteres "
"Unicode: UTF-8. UTF-8 es una codificación de 8 bits, lo que significa que no "
"hay problemas con el orden de bytes en UTF-8. Cada byte en una secuencia de "
"bytes UTF-8 consta de dos partes: bits marcadores (los bits más "
"significativos) y bits de carga útil. Los bits marcadores son una secuencia "
"de cero a cuatro bits ``1`` seguidos de un bit ``0``. Los caracteres Unicode "
"se codifican de esta manera (con x siendo bits de carga útil, que cuando se "
"concatenan dan el carácter Unicode):"

#: ../Doc/library/codecs.rst:986
msgid "Range"
msgstr "Rango"

#: ../Doc/library/codecs.rst:986
msgid "Encoding"
msgstr "Codificación"

#: ../Doc/library/codecs.rst:988
msgid "``U-00000000`` ... ``U-0000007F``"
msgstr "``U-00000000`` ... ``U-0000007F``"

#: ../Doc/library/codecs.rst:988
msgid "0xxxxxxx"
msgstr "0xxxxxxx"

#: ../Doc/library/codecs.rst:990
msgid "``U-00000080`` ... ``U-000007FF``"
msgstr "``U-00000080`` ... ``U-000007FF``"

#: ../Doc/library/codecs.rst:990
msgid "110xxxxx 10xxxxxx"
msgstr "110xxxxx 10xxxxxx"

#: ../Doc/library/codecs.rst:992
msgid "``U-00000800`` ... ``U-0000FFFF``"
msgstr "``U-00000800`` ... ``U-0000FFFF``"

#: ../Doc/library/codecs.rst:992
msgid "1110xxxx 10xxxxxx 10xxxxxx"
msgstr "1110xxxx 10xxxxxx 10xxxxxx"

#: ../Doc/library/codecs.rst:994
msgid "``U-00010000`` ... ``U-0010FFFF``"
msgstr "``U-00010000`` ... ``U-0010FFFF``"

#: ../Doc/library/codecs.rst:994
msgid "11110xxx 10xxxxxx 10xxxxxx 10xxxxxx"
msgstr "11110xxx 10xxxxxx 10xxxxxx 10xxxxxx"

#: ../Doc/library/codecs.rst:997
msgid ""
"The least significant bit of the Unicode character is the rightmost x bit."
msgstr ""
"El bit menos significativo del carácter Unicode es el bit x más a la derecha."

#: ../Doc/library/codecs.rst:999
msgid ""
"As UTF-8 is an 8-bit encoding no BOM is required and any ``U+FEFF`` "
"character in the decoded string (even if it's the first character) is "
"treated as a ``ZERO WIDTH NO-BREAK SPACE``."
msgstr ""
"Como UTF-8 es una codificación de 8 bits, no se requiere una lista de "
"materiales y cualquier carácter ``U+FEFF`` en la cadena decodificada "
"(incluso si es el primer carácter) se trata como un ``ESPACIO SIN QUIEBRE DE "
"ANCHO CERO`` (*``ZERO WIDTH NO-BREAK SPACE``*)."

#: ../Doc/library/codecs.rst:1003
msgid ""
"Without external information it's impossible to reliably determine which "
"encoding was used for encoding a string. Each charmap encoding can decode "
"any random byte sequence. However that's not possible with UTF-8, as UTF-8 "
"byte sequences have a structure that doesn't allow arbitrary byte sequences. "
"To increase the reliability with which a UTF-8 encoding can be detected, "
"Microsoft invented a variant of UTF-8 (that Python calls ``\"utf-8-sig\"``) "
"for its Notepad program: Before any of the Unicode characters is written to "
"the file, a UTF-8 encoded BOM (which looks like this as a byte sequence: "
"``0xef``, ``0xbb``, ``0xbf``) is written. As it's rather improbable that any "
"charmap encoded file starts with these byte values (which would e.g. map to"
msgstr ""
"Sin información externa, es imposible determinar de manera fidedigna qué "
"codificación se utilizó para codificar una cadena de caracteres. Cada "
"codificación de mapa de caracteres puede decodificar cualquier secuencia de "
"bytes aleatoria. Sin embargo, eso no es posible con UTF-8, ya que las "
"secuencias de bytes UTF-8 tienen una estructura que no permite secuencias de "
"bytes arbitrarias. Para aumentar la confiabilidad con la que se puede "
"detectar una codificación UTF-8, Microsoft inventó una variante de UTF-8 "
"(que Python 2.5 llama ``\"utf-8-sig\"``) para su programa Bloc de notas: "
"Antes de que cualquier carácter Unicode sea escrito en un archivo, se "
"escribe un BOM codificado en UTF-8 (que se muestra como una secuencia de "
"bytes: ``0xef``, ``0xbb``, ``0xbf``). Como es bastante improbable que "
"cualquier archivo codificado del mapa de caracteres comience con estos "
"valores de bytes (que, por ejemplo, se asignarían a"

#: ../Doc/library/codecs.rst
msgid "LATIN SMALL LETTER I WITH DIAERESIS"
msgstr "LETRA LATINA PEQUEÑA I CON DIAERESIS"

#: ../Doc/library/codecs.rst
msgid "RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK"
msgstr "SEÑALADO A LA DERECHA DE DOBLE ÁNGULO MARCA DE CITA"

#: ../Doc/library/codecs.rst
msgid "INVERTED QUESTION MARK"
msgstr "SIGNO DE PREGUNTA INVERTIDO"

#: ../Doc/library/codecs.rst:1019
msgid ""
"in iso-8859-1), this increases the probability that a ``utf-8-sig`` encoding "
"can be correctly guessed from the byte sequence. So here the BOM is not used "
"to be able to determine the byte order used for generating the byte "
"sequence, but as a signature that helps in guessing the encoding. On "
"encoding the utf-8-sig codec will write ``0xef``, ``0xbb``, ``0xbf`` as the "
"first three bytes to the file. On decoding ``utf-8-sig`` will skip those "
"three bytes if they appear as the first three bytes in the file. In UTF-8, "
"the use of the BOM is discouraged and should generally be avoided."
msgstr ""
"en iso-8859-1), esto aumenta la probabilidad de que una codificación ``utf-8-"
"sig`` pueda adivinarse correctamente a partir de la secuencia de bytes. Por "
"lo tanto, aquí la lista de materiales no se utiliza para poder determinar el "
"orden de bytes utilizado para generar la secuencia de bytes, sino como una "
"firma que ayuda a adivinar la codificación. Al codificar, el códec utf-8-sig "
"escribirá ``0xef``, ``0xbb``, ``0xbf`` como los primeros tres bytes del "
"archivo. Al decodificar, ``utf-8-sig`` omitirá esos tres bytes si aparecen "
"como los primeros tres bytes en el archivo. En UTF-8, se desaconseja el uso "
"de la lista de materiales y, en general, debe evitarse."

#: ../Doc/library/codecs.rst:1032
msgid "Standard Encodings"
msgstr "Codificaciones estándar"

#: ../Doc/library/codecs.rst:1034
msgid ""
"Python comes with a number of codecs built-in, either implemented as C "
"functions or with dictionaries as mapping tables. The following table lists "
"the codecs by name, together with a few common aliases, and the languages "
"for which the encoding is likely used. Neither the list of aliases nor the "
"list of languages is meant to be exhaustive. Notice that spelling "
"alternatives that only differ in case or use a hyphen instead of an "
"underscore are also valid aliases; therefore, e.g. ``'utf-8'`` is a valid "
"alias for the ``'utf_8'`` codec."
msgstr ""
"Python viene con una serie de códecs integrados, ya sea implementados como "
"funciones C o con diccionarios como tablas de mapeo. La siguiente tabla "
"enumera los códecs por nombre, junto con algunos alias comunes y los idiomas "
"para los que probablemente se usa la codificación. Ni la lista de alias ni "
"la lista de idiomas deben ser exhaustivas. Tenga en cuenta que las "
"alternativas de ortografía que solo difieren en el caso o usan un guión en "
"lugar de un guión bajo también son alias válidos; por lo tanto, por ejemplo "
"``'utf-8'`` es un alias válido para el códec ``'utf_8'``."

#: ../Doc/library/codecs.rst:1044
msgid ""
"Some common encodings can bypass the codecs lookup machinery to improve "
"performance. These optimization opportunities are only recognized by CPython "
"for a limited set of (case insensitive) aliases: utf-8, utf8, latin-1, "
"latin1, iso-8859-1, iso8859-1, mbcs (Windows only), ascii, us-ascii, utf-16, "
"utf16, utf-32, utf32, and the same using underscores instead of dashes. "
"Using alternative aliases for these encodings may result in slower execution."
msgstr ""
"Algunas codificaciones comunes pueden omitir la maquinaria de búsqueda de "
"códecs para mejorar el rendimiento. CPython solo reconoce estas "
"oportunidades de optimización para un conjunto limitado de alias (sin "
"distinción entre mayúsculas y minúsculas): utf-8, utf8, latin-1, latin1, "
"iso-8859-1, iso8859-1, mbcs (solo Windows), ascii, us-ascii, utf-16, utf16, "
"utf-32, utf32, y lo mismo usando guiones bajos en lugar de guiones. El uso "
"de alias alternativos para estas codificaciones puede resultar en una "
"ejecución más lenta."

#: ../Doc/library/codecs.rst:1052
msgid "Optimization opportunity recognized for us-ascii."
msgstr "Oportunidad de optimización reconocida para us-ascii."

#: ../Doc/library/codecs.rst:1055
msgid ""
"Many of the character sets support the same languages. They vary in "
"individual characters (e.g. whether the EURO SIGN is supported or not), and "
"in the assignment of characters to code positions. For the European "
"languages in particular, the following variants typically exist:"
msgstr ""
"Muchos de los juegos de caracteres admiten los mismos idiomas. Varían en "
"caracteres individuales (por ejemplo, si el SIGNO EURO es compatible o no), "
"y en la asignación de caracteres para codificar posiciones. Para los idiomas "
"europeos en particular, generalmente existen las siguientes variantes:"

#: ../Doc/library/codecs.rst:1060
msgid "an ISO 8859 codeset"
msgstr "un conjunto de códigos ISO 8859"

#: ../Doc/library/codecs.rst:1062
msgid ""
"a Microsoft Windows code page, which is typically derived from an 8859 "
"codeset, but replaces control characters with additional graphic characters"
msgstr ""
"una página de códigos de Microsoft Windows, que generalmente se deriva de un "
"conjunto de códigos 8859, pero reemplaza los caracteres de control con "
"caracteres gráficos adicionales"

#: ../Doc/library/codecs.rst:1065
msgid "an IBM EBCDIC code page"
msgstr "una página de códigos EBCDIC de IBM"

#: ../Doc/library/codecs.rst:1067
msgid "an IBM PC code page, which is ASCII compatible"
msgstr "una página de códigos de IBM PC, que es compatible con ASCII"

#: ../Doc/library/codecs.rst:1072 ../Doc/library/codecs.rst:1327
#: ../Doc/library/codecs.rst:1395 ../Doc/library/codecs.rst:1450
msgid "Codec"
msgstr "Códec"

#: ../Doc/library/codecs.rst:1072 ../Doc/library/codecs.rst:1327
#: ../Doc/library/codecs.rst:1395 ../Doc/library/codecs.rst:1450
msgid "Aliases"
msgstr "Aliases"

#: ../Doc/library/codecs.rst:1072
msgid "Languages"
msgstr "Lenguajes"

#: ../Doc/library/codecs.rst:1074
msgid "ascii"
msgstr "ascii"

#: ../Doc/library/codecs.rst:1074
msgid "646, us-ascii"
msgstr "646, us-ascii"

#: ../Doc/library/codecs.rst:1074 ../Doc/library/codecs.rst:1080
#: ../Doc/library/codecs.rst:1088
msgid "English"
msgstr "Inglés"

#: ../Doc/library/codecs.rst:1076
msgid "big5"
msgstr "big5"

#: ../Doc/library/codecs.rst:1076
msgid "big5-tw, csbig5"
msgstr "big5-tw, csbig5"

#: ../Doc/library/codecs.rst:1076 ../Doc/library/codecs.rst:1078
#: ../Doc/library/codecs.rst:1136
msgid "Traditional Chinese"
msgstr "Chino Tradicional"

#: ../Doc/library/codecs.rst:1078
msgid "big5hkscs"
msgstr "big5hkscs"

#: ../Doc/library/codecs.rst:1078
msgid "big5-hkscs, hkscs"
msgstr "big5-hkscs, hkscs"

#: ../Doc/library/codecs.rst:1080
msgid "cp037"
msgstr "cp037"

#: ../Doc/library/codecs.rst:1080
msgid "IBM037, IBM039"
msgstr "IBM037, IBM039"

#: ../Doc/library/codecs.rst:1082
msgid "cp273"
msgstr "cp273"

#: ../Doc/library/codecs.rst:1082
msgid "273, IBM273, csIBM273"
msgstr "273, IBM273, csIBM273"

#: ../Doc/library/codecs.rst:1082
msgid "German"
msgstr "Alemán"

#: ../Doc/library/codecs.rst:1086
msgid "cp424"
msgstr "cp424"

#: ../Doc/library/codecs.rst:1086
msgid "EBCDIC-CP-HE, IBM424"
msgstr "EBCDIC-CP-HE, IBM424"

#: ../Doc/library/codecs.rst:1086 ../Doc/library/codecs.rst:1106
#: ../Doc/library/codecs.rst:1116 ../Doc/library/codecs.rst:1159
#: ../Doc/library/codecs.rst:1222
msgid "Hebrew"
msgstr "Hebreo"

#: ../Doc/library/codecs.rst:1088
msgid "cp437"
msgstr "cp437"

#: ../Doc/library/codecs.rst:1088
msgid "437, IBM437"
msgstr "437, IBM437"

#: ../Doc/library/codecs.rst:1090
msgid "cp500"
msgstr "cp500"

#: ../Doc/library/codecs.rst:1090
msgid "EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500"
msgstr "EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500"

#: ../Doc/library/codecs.rst:1090 ../Doc/library/codecs.rst:1099
#: ../Doc/library/codecs.rst:1110 ../Doc/library/codecs.rst:1146
#: ../Doc/library/codecs.rst:1153 ../Doc/library/codecs.rst:1206
#: ../Doc/library/codecs.rst:1234 ../Doc/library/codecs.rst:1262
msgid "Western Europe"
msgstr "Europa Occidental"

#: ../Doc/library/codecs.rst:1093
msgid "cp720"
msgstr "cp720"

#: ../Doc/library/codecs.rst:1093 ../Doc/library/codecs.rst:1120
#: ../Doc/library/codecs.rst:1161 ../Doc/library/codecs.rst:1218
msgid "Arabic"
msgstr "Árabe"

#: ../Doc/library/codecs.rst:1095
msgid "cp737"
msgstr "cp737"

#: ../Doc/library/codecs.rst:1095 ../Doc/library/codecs.rst:1126
#: ../Doc/library/codecs.rst:1130 ../Doc/library/codecs.rst:1155
#: ../Doc/library/codecs.rst:1220 ../Doc/library/codecs.rst:1255
msgid "Greek"
msgstr "Griego"

#: ../Doc/library/codecs.rst:1097
msgid "cp775"
msgstr "cp775"

#: ../Doc/library/codecs.rst:1097
msgid "IBM775"
msgstr "IBM775"

#: ../Doc/library/codecs.rst:1097 ../Doc/library/codecs.rst:1163
#: ../Doc/library/codecs.rst:1213 ../Doc/library/codecs.rst:1230
msgid "Baltic languages"
msgstr "Lenguajes bálticos"

#: ../Doc/library/codecs.rst:1099
msgid "cp850"
msgstr "cp850"

#: ../Doc/library/codecs.rst:1099
msgid "850, IBM850"
msgstr "850, IBM850"

#: ../Doc/library/codecs.rst:1101
msgid "cp852"
msgstr "cp852"

#: ../Doc/library/codecs.rst:1101
msgid "852, IBM852"
msgstr "852, IBM852"

#: ../Doc/library/codecs.rst:1101 ../Doc/library/codecs.rst:1148
#: ../Doc/library/codecs.rst:1209 ../Doc/library/codecs.rst:1259
msgid "Central and Eastern Europe"
msgstr "Europa central y del este"

#: ../Doc/library/codecs.rst:1103
msgid "cp855"
msgstr "cp855"

#: ../Doc/library/codecs.rst:1103
msgid "855, IBM855"
msgstr "855, IBM855"

#: ../Doc/library/codecs.rst:1103 ../Doc/library/codecs.rst:1150
#: ../Doc/library/codecs.rst:1215 ../Doc/library/codecs.rst:1252
msgid "Bulgarian, Byelorussian, Macedonian, Russian, Serbian"
msgstr "Búlgaro, Bielorruso, Macedonio, Ruso, Serbio"

#: ../Doc/library/codecs.rst:1106
msgid "cp856"
msgstr "cp856"

#: ../Doc/library/codecs.rst:1108
msgid "cp857"
msgstr "cp857"

#: ../Doc/library/codecs.rst:1108
msgid "857, IBM857"
msgstr "857, IBM857"

#: ../Doc/library/codecs.rst:1108 ../Doc/library/codecs.rst:1140
#: ../Doc/library/codecs.rst:1157 ../Doc/library/codecs.rst:1224
#: ../Doc/library/codecs.rst:1264
msgid "Turkish"
msgstr "Turco"

#: ../Doc/library/codecs.rst:1110
msgid "cp858"
msgstr "cp858"

#: ../Doc/library/codecs.rst:1110
msgid "858, IBM858"
msgstr "858, IBM858"

#: ../Doc/library/codecs.rst:1112
msgid "cp860"
msgstr "cp860"

#: ../Doc/library/codecs.rst:1112
msgid "860, IBM860"
msgstr "860, IBM860"

#: ../Doc/library/codecs.rst:1112
msgid "Portuguese"
msgstr "Portugués"

#: ../Doc/library/codecs.rst:1114
msgid "cp861"
msgstr "cp861"

#: ../Doc/library/codecs.rst:1114
msgid "861, CP-IS, IBM861"
msgstr "861, CP-IS, IBM861"

#: ../Doc/library/codecs.rst:1114 ../Doc/library/codecs.rst:1257
msgid "Icelandic"
msgstr "Islandés"

#: ../Doc/library/codecs.rst:1116
msgid "cp862"
msgstr "cp862"

#: ../Doc/library/codecs.rst:1116
msgid "862, IBM862"
msgstr "862, IBM862"

#: ../Doc/library/codecs.rst:1118
msgid "cp863"
msgstr "cp863"

#: ../Doc/library/codecs.rst:1118
msgid "863, IBM863"
msgstr "863, IBM863"

#: ../Doc/library/codecs.rst:1118
msgid "Canadian"
msgstr "Canadiense"

#: ../Doc/library/codecs.rst:1120
msgid "cp864"
msgstr "cp864"

#: ../Doc/library/codecs.rst:1120
msgid "IBM864"
msgstr "IBM864"

#: ../Doc/library/codecs.rst:1122
msgid "cp865"
msgstr "cp865"

#: ../Doc/library/codecs.rst:1122
msgid "865, IBM865"
msgstr "865, IBM865"

#: ../Doc/library/codecs.rst:1122
msgid "Danish, Norwegian"
msgstr "Danés, Noruego"

#: ../Doc/library/codecs.rst:1124
msgid "cp866"
msgstr "cp866"

#: ../Doc/library/codecs.rst:1124
msgid "866, IBM866"
msgstr "866, IBM866"

#: ../Doc/library/codecs.rst:1124 ../Doc/library/codecs.rst:1240
msgid "Russian"
msgstr "Ruso"

#: ../Doc/library/codecs.rst:1126
msgid "cp869"
msgstr "cp869"

#: ../Doc/library/codecs.rst:1126
msgid "869, CP-GR, IBM869"
msgstr "869, CP-GR, IBM869"

#: ../Doc/library/codecs.rst:1128
msgid "cp874"
msgstr "cp874"

#: ../Doc/library/codecs.rst:1128
msgid "Thai"
msgstr "Tailandés"

#: ../Doc/library/codecs.rst:1130
msgid "cp875"
msgstr "cp875"

#: ../Doc/library/codecs.rst:1132
msgid "cp932"
msgstr "cp932"

#: ../Doc/library/codecs.rst:1132
msgid "932, ms932, mskanji, ms-kanji"
msgstr "932, ms932, mskanji, ms-kanji"

#: ../Doc/library/codecs.rst:1132 ../Doc/library/codecs.rst:1167
#: ../Doc/library/codecs.rst:1169 ../Doc/library/codecs.rst:1171
#: ../Doc/library/codecs.rst:1188 ../Doc/library/codecs.rst:1191
#: ../Doc/library/codecs.rst:1196 ../Doc/library/codecs.rst:1199
#: ../Doc/library/codecs.rst:1201 ../Doc/library/codecs.rst:1269
#: ../Doc/library/codecs.rst:1272 ../Doc/library/codecs.rst:1275
msgid "Japanese"
msgstr "Japonés"

#: ../Doc/library/codecs.rst:1134
msgid "cp949"
msgstr "cp949"

#: ../Doc/library/codecs.rst:1134
msgid "949, ms949, uhc"
msgstr "949, ms949, uhc"

#: ../Doc/library/codecs.rst:1134 ../Doc/library/codecs.rst:1173
#: ../Doc/library/codecs.rst:1203 ../Doc/library/codecs.rst:1238
msgid "Korean"
msgstr "Coreano"

#: ../Doc/library/codecs.rst:1136
msgid "cp950"
msgstr "cp950"

#: ../Doc/library/codecs.rst:1136
msgid "950, ms950"
msgstr "950, ms950"

#: ../Doc/library/codecs.rst:1138
msgid "cp1006"
msgstr "cp1006"

#: ../Doc/library/codecs.rst:1138
msgid "Urdu"
msgstr "Urdu"

#: ../Doc/library/codecs.rst:1140
msgid "cp1026"
msgstr "cp1026"

#: ../Doc/library/codecs.rst:1140
msgid "ibm1026"
msgstr "ibm1026"

#: ../Doc/library/codecs.rst:1142
msgid "cp1125"
msgstr "cp1125"

#: ../Doc/library/codecs.rst:1142
msgid "1125, ibm1125, cp866u, ruscii"
msgstr "1125, ibm1125, cp866u, ruscii"

#: ../Doc/library/codecs.rst:1142 ../Doc/library/codecs.rst:1246
msgid "Ukrainian"
msgstr "Ucraniano"

#: ../Doc/library/codecs.rst:1146
msgid "cp1140"
msgstr "cp1140"

#: ../Doc/library/codecs.rst:1146
msgid "ibm1140"
msgstr "ibm1140"

#: ../Doc/library/codecs.rst:1148
msgid "cp1250"
msgstr "cp1250"

#: ../Doc/library/codecs.rst:1148
msgid "windows-1250"
msgstr "windows-1250"

#: ../Doc/library/codecs.rst:1150
msgid "cp1251"
msgstr "cp1251"

#: ../Doc/library/codecs.rst:1150
msgid "windows-1251"
msgstr "windows-1251"

#: ../Doc/library/codecs.rst:1153
msgid "cp1252"
msgstr "cp1252"

#: ../Doc/library/codecs.rst:1153
msgid "windows-1252"
msgstr "windows-1252"

#: ../Doc/library/codecs.rst:1155
msgid "cp1253"
msgstr "cp1253"

#: ../Doc/library/codecs.rst:1155
msgid "windows-1253"
msgstr "windows-1253"

#: ../Doc/library/codecs.rst:1157
msgid "cp1254"
msgstr "cp1254"

#: ../Doc/library/codecs.rst:1157
msgid "windows-1254"
msgstr "windows-1254"

#: ../Doc/library/codecs.rst:1159
msgid "cp1255"
msgstr "cp1255"

#: ../Doc/library/codecs.rst:1159
msgid "windows-1255"
msgstr "windows-1255"

#: ../Doc/library/codecs.rst:1161
msgid "cp1256"
msgstr "cp1256"

#: ../Doc/library/codecs.rst:1161
msgid "windows-1256"
msgstr "windows-1256"

#: ../Doc/library/codecs.rst:1163
msgid "cp1257"
msgstr "cp1257"

#: ../Doc/library/codecs.rst:1163
msgid "windows-1257"
msgstr "windows-1257"

#: ../Doc/library/codecs.rst:1165
msgid "cp1258"
msgstr "cp1258"

#: ../Doc/library/codecs.rst:1165
msgid "windows-1258"
msgstr "windows-1258"

#: ../Doc/library/codecs.rst:1165
msgid "Vietnamese"
msgstr "Vietnamita"

#: ../Doc/library/codecs.rst:1167
msgid "euc_jp"
msgstr "euc_jp"

#: ../Doc/library/codecs.rst:1167
msgid "eucjp, ujis, u-jis"
msgstr "eucjp, ujis, u-jis"

#: ../Doc/library/codecs.rst:1169
msgid "euc_jis_2004"
msgstr "euc_jis_2004"

#: ../Doc/library/codecs.rst:1169
msgid "jisx0213, eucjis2004"
msgstr "jisx0213, eucjis2004"

#: ../Doc/library/codecs.rst:1171
msgid "euc_jisx0213"
msgstr "euc_jisx0213"

#: ../Doc/library/codecs.rst:1171
msgid "eucjisx0213"
msgstr "eucjisx0213"

#: ../Doc/library/codecs.rst:1173
msgid "euc_kr"
msgstr "euc_kr"

#: ../Doc/library/codecs.rst:1173
msgid "euckr, korean, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001"
msgstr "euckr, korean, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001"

#: ../Doc/library/codecs.rst:1177
msgid "gb2312"
msgstr "gb2312"

#: ../Doc/library/codecs.rst:1177
msgid ""
"chinese, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, "
"gb2312-80, iso-ir-58"
msgstr ""
"chinese, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, "
"gb2312-80, iso-ir-58"

#: ../Doc/library/codecs.rst:1177 ../Doc/library/codecs.rst:1186
msgid "Simplified Chinese"
msgstr "Chino simplificado"

#: ../Doc/library/codecs.rst:1182
msgid "gbk"
msgstr "gbk"

#: ../Doc/library/codecs.rst:1182
msgid "936, cp936, ms936"
msgstr "936, cp936, ms936"

#: ../Doc/library/codecs.rst:1182 ../Doc/library/codecs.rst:1184
msgid "Unified Chinese"
msgstr "Chino Unificado"

#: ../Doc/library/codecs.rst:1184
msgid "gb18030"
msgstr "gb18030"

#: ../Doc/library/codecs.rst:1184
msgid "gb18030-2000"
msgstr "gb18030-2000"

#: ../Doc/library/codecs.rst:1186
msgid "hz"
msgstr "hz"

#: ../Doc/library/codecs.rst:1186
msgid "hzgb, hz-gb, hz-gb-2312"
msgstr "hzgb, hz-gb, hz-gb-2312"

#: ../Doc/library/codecs.rst:1188
msgid "iso2022_jp"
msgstr "iso2022_jp"

#: ../Doc/library/codecs.rst:1188
msgid "csiso2022jp, iso2022jp, iso-2022-jp"
msgstr "csiso2022jp, iso2022jp, iso-2022-jp"

#: ../Doc/library/codecs.rst:1191
msgid "iso2022_jp_1"
msgstr "iso2022_jp_1"

#: ../Doc/library/codecs.rst:1191
msgid "iso2022jp-1, iso-2022-jp-1"
msgstr "iso2022jp-1, iso-2022-jp-1"

#: ../Doc/library/codecs.rst:1193
msgid "iso2022_jp_2"
msgstr "iso2022_jp_2"

#: ../Doc/library/codecs.rst:1193
msgid "iso2022jp-2, iso-2022-jp-2"
msgstr "iso2022jp-2, iso-2022-jp-2"

#: ../Doc/library/codecs.rst:1193
msgid "Japanese, Korean, Simplified Chinese, Western Europe, Greek"
msgstr "Japonés, Coreano, Chino simplificado, Europa occidental, Griego"

#: ../Doc/library/codecs.rst:1196
msgid "iso2022_jp_2004"
msgstr "iso2022_jp_2004"

#: ../Doc/library/codecs.rst:1196
msgid "iso2022jp-2004, iso-2022-jp-2004"
msgstr "iso2022jp-2004, iso-2022-jp-2004"

#: ../Doc/library/codecs.rst:1199
msgid "iso2022_jp_3"
msgstr "iso2022_jp_3"

#: ../Doc/library/codecs.rst:1199
msgid "iso2022jp-3, iso-2022-jp-3"
msgstr "iso2022jp-3, iso-2022-jp-3"

#: ../Doc/library/codecs.rst:1201
msgid "iso2022_jp_ext"
msgstr "iso2022_jp_ext"

#: ../Doc/library/codecs.rst:1201
msgid "iso2022jp-ext, iso-2022-jp-ext"
msgstr "iso2022jp-ext, iso-2022-jp-ext"

#: ../Doc/library/codecs.rst:1203
msgid "iso2022_kr"
msgstr "iso2022_kr"

#: ../Doc/library/codecs.rst:1203
msgid "csiso2022kr, iso2022kr, iso-2022-kr"
msgstr "csiso2022kr, iso2022kr, iso-2022-kr"

#: ../Doc/library/codecs.rst:1206
msgid "latin_1"
msgstr "latin_1"

#: ../Doc/library/codecs.rst:1206
msgid "iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1"
msgstr "iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1"

#: ../Doc/library/codecs.rst:1209
msgid "iso8859_2"
msgstr "iso8859_2"

#: ../Doc/library/codecs.rst:1209
msgid "iso-8859-2, latin2, L2"
msgstr "iso-8859-2, latin2, L2"

#: ../Doc/library/codecs.rst:1211
msgid "iso8859_3"
msgstr "iso8859_3"

#: ../Doc/library/codecs.rst:1211
msgid "iso-8859-3, latin3, L3"
msgstr "iso-8859-3, latin3, L3"

#: ../Doc/library/codecs.rst:1211
msgid "Esperanto, Maltese"
msgstr "Esperanto, Maltés"

#: ../Doc/library/codecs.rst:1213
msgid "iso8859_4"
msgstr "iso8859_4"

#: ../Doc/library/codecs.rst:1213
msgid "iso-8859-4, latin4, L4"
msgstr "iso-8859-4, latin4, L4"

#: ../Doc/library/codecs.rst:1215
msgid "iso8859_5"
msgstr "iso8859_5"

#: ../Doc/library/codecs.rst:1215
msgid "iso-8859-5, cyrillic"
msgstr "iso-8859-5, cyrillic"

#: ../Doc/library/codecs.rst:1218
msgid "iso8859_6"
msgstr "iso8859_6"

#: ../Doc/library/codecs.rst:1218
msgid "iso-8859-6, arabic"
msgstr "iso-8859-6, arabic"

#: ../Doc/library/codecs.rst:1220
msgid "iso8859_7"
msgstr "iso8859_7"

#: ../Doc/library/codecs.rst:1220
msgid "iso-8859-7, greek, greek8"
msgstr "iso-8859-7, greek, greek8"

#: ../Doc/library/codecs.rst:1222
msgid "iso8859_8"
msgstr "iso8859_8"

#: ../Doc/library/codecs.rst:1222
msgid "iso-8859-8, hebrew"
msgstr "iso-8859-8, hebrew"

#: ../Doc/library/codecs.rst:1224
msgid "iso8859_9"
msgstr "iso8859_9"

#: ../Doc/library/codecs.rst:1224
msgid "iso-8859-9, latin5, L5"
msgstr "iso-8859-9, latin5, L5"

#: ../Doc/library/codecs.rst:1226
msgid "iso8859_10"
msgstr "iso8859_10"

#: ../Doc/library/codecs.rst:1226
msgid "iso-8859-10, latin6, L6"
msgstr "iso-8859-10, latin6, L6"

#: ../Doc/library/codecs.rst:1226
msgid "Nordic languages"
msgstr "Lenguajes nórdicos"

#: ../Doc/library/codecs.rst:1228
msgid "iso8859_11"
msgstr "iso8859_11"

#: ../Doc/library/codecs.rst:1228
msgid "iso-8859-11, thai"
msgstr "iso-8859-11, thai"

#: ../Doc/library/codecs.rst:1228
msgid "Thai languages"
msgstr "Lenguajes tailandeses"

#: ../Doc/library/codecs.rst:1230
msgid "iso8859_13"
msgstr "iso8859_13"

#: ../Doc/library/codecs.rst:1230
msgid "iso-8859-13, latin7, L7"
msgstr "iso-8859-13, latin7, L7"

#: ../Doc/library/codecs.rst:1232
msgid "iso8859_14"
msgstr "iso8859_14"

#: ../Doc/library/codecs.rst:1232
msgid "iso-8859-14, latin8, L8"
msgstr "iso-8859-14, latin8, L8"

#: ../Doc/library/codecs.rst:1232
msgid "Celtic languages"
msgstr "Lenguajes Celtas"

#: ../Doc/library/codecs.rst:1234
msgid "iso8859_15"
msgstr "iso8859_15"

#: ../Doc/library/codecs.rst:1234
msgid "iso-8859-15, latin9, L9"
msgstr "iso-8859-15, latin9, L9"

#: ../Doc/library/codecs.rst:1236
msgid "iso8859_16"
msgstr "iso8859_16"

#: ../Doc/library/codecs.rst:1236
msgid "iso-8859-16, latin10, L10"
msgstr "iso-8859-16, latin10, L10"

#: ../Doc/library/codecs.rst:1236
msgid "South-Eastern Europe"
msgstr "Europa sudoriental"

#: ../Doc/library/codecs.rst:1238
msgid "johab"
msgstr "johab"

#: ../Doc/library/codecs.rst:1238
msgid "cp1361, ms1361"
msgstr "cp1361, ms1361"

#: ../Doc/library/codecs.rst:1240
msgid "koi8_r"
msgstr "koi8_r"

#: ../Doc/library/codecs.rst:1242
msgid "koi8_t"
msgstr "koi8_t"

#: ../Doc/library/codecs.rst:1242
msgid "Tajik"
msgstr "Tayiko"

#: ../Doc/library/codecs.rst:1246
msgid "koi8_u"
msgstr "koi8_u"

#: ../Doc/library/codecs.rst:1248
msgid "kz1048"
msgstr "kz1048"

#: ../Doc/library/codecs.rst:1248
msgid "kz_1048, strk1048_2002, rk1048"
msgstr "kz_1048, strk1048_2002, rk1048"

#: ../Doc/library/codecs.rst:1248 ../Doc/library/codecs.rst:1266
msgid "Kazakh"
msgstr "Kazajo"

#: ../Doc/library/codecs.rst:1252
msgid "mac_cyrillic"
msgstr "mac_cyrillic"

#: ../Doc/library/codecs.rst:1252
msgid "maccyrillic"
msgstr "maccyrillic"

#: ../Doc/library/codecs.rst:1255
msgid "mac_greek"
msgstr "mac_greek"

#: ../Doc/library/codecs.rst:1255
msgid "macgreek"
msgstr "macgreek"

#: ../Doc/library/codecs.rst:1257
msgid "mac_iceland"
msgstr "mac_iceland"

#: ../Doc/library/codecs.rst:1257
msgid "maciceland"
msgstr "maciceland"

#: ../Doc/library/codecs.rst:1259
msgid "mac_latin2"
msgstr "mac_latin2"

#: ../Doc/library/codecs.rst:1259
msgid "maclatin2, maccentraleurope, mac_centeuro"
msgstr "maclatin2, maccentraleurope, mac_centeuro"

#: ../Doc/library/codecs.rst:1262
msgid "mac_roman"
msgstr "mac_roman"

#: ../Doc/library/codecs.rst:1262
msgid "macroman, macintosh"
msgstr "macroman, macintosh"

#: ../Doc/library/codecs.rst:1264
msgid "mac_turkish"
msgstr "mac_turkish"

#: ../Doc/library/codecs.rst:1264
msgid "macturkish"
msgstr "macturkish"

#: ../Doc/library/codecs.rst:1266
msgid "ptcp154"
msgstr "ptcp154"

#: ../Doc/library/codecs.rst:1266
msgid "csptcp154, pt154, cp154, cyrillic-asian"
msgstr "csptcp154, pt154, cp154, cyrillic-asian"

#: ../Doc/library/codecs.rst:1269
msgid "shift_jis"
msgstr "shift_jis"

#: ../Doc/library/codecs.rst:1269
msgid "csshiftjis, shiftjis, sjis, s_jis"
msgstr "csshiftjis, shiftjis, sjis, s_jis"

#: ../Doc/library/codecs.rst:1272
msgid "shift_jis_2004"
msgstr "shift_jis_2004"

#: ../Doc/library/codecs.rst:1272
msgid "shiftjis2004, sjis_2004, sjis2004"
msgstr "shiftjis2004, sjis_2004, sjis2004"

#: ../Doc/library/codecs.rst:1275
msgid "shift_jisx0213"
msgstr "shift_jisx0213"

#: ../Doc/library/codecs.rst:1275
msgid "shiftjisx0213, sjisx0213, s_jisx0213"
msgstr "shiftjisx0213, sjisx0213, s_jisx0213"

#: ../Doc/library/codecs.rst:1278
msgid "utf_32"
msgstr "utf_32"

#: ../Doc/library/codecs.rst:1278
msgid "U32, utf32"
msgstr "U32, utf32"

#: ../Doc/library/codecs.rst:1278 ../Doc/library/codecs.rst:1280
#: ../Doc/library/codecs.rst:1282 ../Doc/library/codecs.rst:1284
#: ../Doc/library/codecs.rst:1286 ../Doc/library/codecs.rst:1288
#: ../Doc/library/codecs.rst:1290 ../Doc/library/codecs.rst:1292
#: ../Doc/library/codecs.rst:1294
msgid "all languages"
msgstr "todos los lenguajes"

#: ../Doc/library/codecs.rst:1280
msgid "utf_32_be"
msgstr "utf_32_be"

#: ../Doc/library/codecs.rst:1280
msgid "UTF-32BE"
msgstr "UTF-32BE"

#: ../Doc/library/codecs.rst:1282
msgid "utf_32_le"
msgstr "utf_32_le"

#: ../Doc/library/codecs.rst:1282
msgid "UTF-32LE"
msgstr "UTF-32LE"

#: ../Doc/library/codecs.rst:1284
msgid "utf_16"
msgstr "utf_16"

#: ../Doc/library/codecs.rst:1284
msgid "U16, utf16"
msgstr "U16, utf16"

#: ../Doc/library/codecs.rst:1286
msgid "utf_16_be"
msgstr "utf_16_be"

#: ../Doc/library/codecs.rst:1286
msgid "UTF-16BE"
msgstr "UTF-16BE"

#: ../Doc/library/codecs.rst:1288
msgid "utf_16_le"
msgstr "utf_16_le"

#: ../Doc/library/codecs.rst:1288
msgid "UTF-16LE"
msgstr "UTF-16LE"

#: ../Doc/library/codecs.rst:1290
msgid "utf_7"
msgstr "utf_7"

#: ../Doc/library/codecs.rst:1290
msgid "U7, unicode-1-1-utf-7"
msgstr "U7, unicode-1-1-utf-7"

#: ../Doc/library/codecs.rst:1292
msgid "utf_8"
msgstr "utf_8"

#: ../Doc/library/codecs.rst:1292
msgid "U8, UTF, utf8, cp65001"
msgstr "U8, UTF, utf8, cp65001"

#: ../Doc/library/codecs.rst:1294
msgid "utf_8_sig"
msgstr "utf_8_sig"

#: ../Doc/library/codecs.rst:1297
msgid ""
"The utf-16\\* and utf-32\\* encoders no longer allow surrogate code points "
"(``U+D800``--``U+DFFF``) to be encoded. The utf-32\\* decoders no longer "
"decode byte sequences that correspond to surrogate code points."
msgstr ""
"Los codificadores utf-16\\* y utf-32\\* ya no permiten codificar puntos de "
"código sustitutos (``U+D800`` -- ``U+DFFF``). Los decodificadores utf-32\\* "
"ya no decodifican secuencias de bytes que corresponden a puntos de código "
"sustituto."

#: ../Doc/library/codecs.rst:1303
msgid "``cp65001`` is now an alias to ``utf_8``."
msgstr "``cp65001`` ahora es un alias de ``utf_8``."

#: ../Doc/library/codecs.rst:1308
msgid "Python Specific Encodings"
msgstr "Codificaciones específicas de Python"

#: ../Doc/library/codecs.rst:1310
msgid ""
"A number of predefined codecs are specific to Python, so their codec names "
"have no meaning outside Python. These are listed in the tables below based "
"on the expected input and output types (note that while text encodings are "
"the most common use case for codecs, the underlying codec infrastructure "
"supports arbitrary data transforms rather than just text encodings). For "
"asymmetric codecs, the stated meaning describes the encoding direction."
msgstr ""
"Varios códecs predefinidos son específicos de Python, por lo que sus nombres "
"de códec no tienen significado fuera de Python. Estos se enumeran en las "
"tablas a continuación según los tipos de entrada y salida esperados (tenga "
"en cuenta que si bien las codificaciones de texto son el caso de uso más "
"común para los códecs, la infraestructura de códecs subyacente admite "
"transformaciones de datos arbitrarias en lugar de solo codificaciones de "
"texto). Para los códecs asimétricos, el significado indicado describe la "
"dirección de codificación."

#: ../Doc/library/codecs.rst:1318
msgid "Text Encodings"
msgstr "Codificaciones de texto"

#: ../Doc/library/codecs.rst:1320
msgid ""
"The following codecs provide :class:`str` to :class:`bytes` encoding and :"
"term:`bytes-like object` to :class:`str` decoding, similar to the Unicode "
"text encodings."
msgstr ""
"Los siguientes códecs proporcionan codificación de :class:`str` a :class:"
"`bytes` y decodificación de :term:`bytes-like object` a :class:`str`, "
"similar a las codificaciones de texto Unicode."

#: ../Doc/library/codecs.rst:1329
msgid "idna"
msgstr "idna"

#: ../Doc/library/codecs.rst:1329
msgid ""
"Implement :rfc:`3490`, see also :mod:`encodings.idna`. Only "
"``errors='strict'`` is supported."
msgstr ""
"Implementar :rfc:`3490`, ver también :mod:`encodings.idna`. Solo se admite "
"``errors='strict'``."

#: ../Doc/library/codecs.rst:1335
msgid "mbcs"
msgstr "mbcs"

#: ../Doc/library/codecs.rst:1335
msgid "ansi, dbcs"
msgstr "ansi, dbcs"

#: ../Doc/library/codecs.rst:1335
msgid ""
"Windows only: Encode the operand according to the ANSI codepage (CP_ACP)."
msgstr ""
"Solo Windows: codifique el operando de acuerdo con la página de códigos ANSI "
"(CP_ACP)."

#: ../Doc/library/codecs.rst:1339
msgid "oem"
msgstr "oem"

#: ../Doc/library/codecs.rst:1339
msgid ""
"Windows only: Encode the operand according to the OEM codepage (CP_OEMCP)."
msgstr ""
"Solo Windows: codifique el operando de acuerdo con la página de códigos OEM "
"(CP_OEMCP)."

#: ../Doc/library/codecs.rst:1345
msgid "palmos"
msgstr "palmos"

#: ../Doc/library/codecs.rst:1345
msgid "Encoding of PalmOS 3.5."
msgstr "Codificación de PalmOS 3.5."

#: ../Doc/library/codecs.rst:1347
msgid "punycode"
msgstr "punycode"

#: ../Doc/library/codecs.rst:1347
msgid "Implement :rfc:`3492`. Stateful codecs are not supported."
msgstr "Implementar :rfc:`3492`. Los códecs con estado no son compatibles."

#: ../Doc/library/codecs.rst:1351
msgid "raw_unicode_escape"
msgstr "raw_unicode_escape"

#: ../Doc/library/codecs.rst:1351
msgid ""
"Latin-1 encoding with :samp:`\\\\u{XXXX}` and :samp:`\\\\U{XXXXXXXX}` for "
"other code points. Existing backslashes are not escaped in any way. It is "
"used in the Python pickle protocol."
msgstr ""
"Codificación Latin-1 con :samp:`\\\\u{XXXX}` y :samp:`\\\\U{XXXXXXXX}` para "
"otros puntos de código. Las barras invertidas existentes no se escapan de "
"ninguna manera. Se usa en el protocolo Python *pickle*."

#: ../Doc/library/codecs.rst:1361
msgid "undefined"
msgstr "indefinido"

#: ../Doc/library/codecs.rst:1361
msgid ""
"Raise an exception for all conversions, even empty strings. The error "
"handler is ignored."
msgstr ""
"Lanza una excepción para todas las conversiones, incluso cadenas vacías. El "
"manejador de errores se ignora."

#: ../Doc/library/codecs.rst:1366
msgid "unicode_escape"
msgstr "unicode_escape"

#: ../Doc/library/codecs.rst:1366
msgid ""
"Encoding suitable as the contents of a Unicode literal in ASCII-encoded "
"Python source code, except that quotes are not escaped. Decode from Latin-1 "
"source code. Beware that Python source code actually uses UTF-8 by default."
msgstr ""
"Codificación adecuada como contenido de un literal Unicode en código fuente "
"Python codificado en ASCII, excepto que no se escapan las comillas. "
"Decodificar desde el código fuente Latin-1. Tenga en cuenta que el código "
"fuente de Python realmente usa UTF-8 por defecto."

#: ../Doc/library/codecs.rst:1378
msgid "\"unicode_internal\" codec is removed."
msgstr "Se elimina el códec \"unicode_internal\"."

#: ../Doc/library/codecs.rst:1385
msgid "Binary Transforms"
msgstr "Transformaciones Binarias"

#: ../Doc/library/codecs.rst:1387
msgid ""
"The following codecs provide binary transforms: :term:`bytes-like object` "
"to :class:`bytes` mappings. They are not supported by :meth:`bytes.decode` "
"(which only produces :class:`str` output)."
msgstr ""
"Los siguientes códecs proporcionan transformaciones binarias: mapeos de :"
"term:`bytes-like object` a :class:`bytes`. No son compatibles con :meth:"
"`bytes.decode` (que solo produce :class:`str` de salida)."

#: ../Doc/library/codecs.rst:1395
msgid "Encoder / decoder"
msgstr "Codificador / decodificador"

#: ../Doc/library/codecs.rst:1397
msgid "base64_codec [#b64]_"
msgstr "base64_codec [#b64]_"

#: ../Doc/library/codecs.rst:1397
msgid "base64, base_64"
msgstr "base64, base_64"

#: ../Doc/library/codecs.rst:1397
msgid ""
"Convert the operand to multiline MIME base64 (the result always includes a "
"trailing ``'\\n'``)."
msgstr ""
"Convierta el operando a MIME base64 multilínea (el resultado siempre incluye "
"un ``'\\n'`` final)."

#: ../Doc/library/codecs.rst:1402
msgid ""
"accepts any :term:`bytes-like object` as input for encoding and decoding"
msgstr ""
"acepta cualquier :term:`bytes-like object` como entrada para codificar y "
"decodificar"

#: ../Doc/library/codecs.rst:1397
msgid ":meth:`base64.encodebytes` / :meth:`base64.decodebytes`"
msgstr ":meth:`base64.encodebytes` / :meth:`base64.decodebytes`"

#: ../Doc/library/codecs.rst:1408
msgid "bz2_codec"
msgstr "bz2_codec"

#: ../Doc/library/codecs.rst:1408
msgid "bz2"
msgstr "bz2"

#: ../Doc/library/codecs.rst:1408
msgid "Compress the operand using bz2."
msgstr "Comprime el operando usando bz2."

#: ../Doc/library/codecs.rst:1408
msgid ":meth:`bz2.compress` / :meth:`bz2.decompress`"
msgstr ":meth:`bz2.compress` / :meth:`bz2.decompress`"

#: ../Doc/library/codecs.rst:1411
msgid "hex_codec"
msgstr "hex_codec"

#: ../Doc/library/codecs.rst:1411
msgid "hex"
msgstr "hex"

#: ../Doc/library/codecs.rst:1411
msgid ""
"Convert the operand to hexadecimal representation, with two digits per byte."
msgstr ""
"Convierte el operando en representación hexadecimal, con dos dígitos por "
"byte."

#: ../Doc/library/codecs.rst:1411
msgid ":meth:`binascii.b2a_hex` / :meth:`binascii.a2b_hex`"
msgstr ":meth:`binascii.b2a_hex` / :meth:`binascii.a2b_hex`"

#: ../Doc/library/codecs.rst:1416
msgid "quopri_codec"
msgstr "quopri_codec"

#: ../Doc/library/codecs.rst:1416
msgid "quopri, quotedprintable, quoted_printable"
msgstr "quopri, quotedprintable, quoted_printable"

#: ../Doc/library/codecs.rst:1416
msgid "Convert the operand to MIME quoted printable."
msgstr "Convierte el operando a MIME citado imprimible."

#: ../Doc/library/codecs.rst:1416
msgid ":meth:`quopri.encode` with ``quotetabs=True`` / :meth:`quopri.decode`"
msgstr ":meth:`quopri.encode` con ``quotetabs=True`` / :meth:`quopri.decode`"

#: ../Doc/library/codecs.rst:1420
msgid "uu_codec"
msgstr "uu_codec"

#: ../Doc/library/codecs.rst:1420
msgid "uu"
msgstr "uu"

#: ../Doc/library/codecs.rst:1420
msgid "Convert the operand using uuencode."
msgstr "Convierte el operando usando uuencode."

#: ../Doc/library/codecs.rst:1420
msgid ":meth:`uu.encode` / :meth:`uu.decode`"
msgstr ":meth:`uu.encode` / :meth:`uu.decode`"

#: ../Doc/library/codecs.rst:1423
msgid "zlib_codec"
msgstr "zlib_codec"

#: ../Doc/library/codecs.rst:1423
msgid "zip, zlib"
msgstr "zip, zlib"

#: ../Doc/library/codecs.rst:1423
msgid "Compress the operand using gzip."
msgstr "Comprime el operando usando gzip."

#: ../Doc/library/codecs.rst:1423
msgid ":meth:`zlib.compress` / :meth:`zlib.decompress`"
msgstr ":meth:`zlib.compress` / :meth:`zlib.decompress`"

#: ../Doc/library/codecs.rst:1427
msgid ""
"In addition to :term:`bytes-like objects <bytes-like object>`, "
"``'base64_codec'`` also accepts ASCII-only instances of :class:`str` for "
"decoding"
msgstr ""
"Además de :term:`objetos similares a bytes <bytes-like object>`, "
"``'base64_codec'`` también acepta instancias solo ASCII de :class:`str` para "
"decodificación"

#: ../Doc/library/codecs.rst:1431
msgid "Restoration of the binary transforms."
msgstr "Restauración de las transformaciones binarias."

#: ../Doc/library/codecs.rst:1434
msgid "Restoration of the aliases for the binary transforms."
msgstr "Restauración de los alias para las transformaciones binarias."

#: ../Doc/library/codecs.rst:1441
msgid "Text Transforms"
msgstr "Transformaciones de texto"

#: ../Doc/library/codecs.rst:1443
msgid ""
"The following codec provides a text transform: a :class:`str` to :class:"
"`str` mapping. It is not supported by :meth:`str.encode` (which only "
"produces :class:`bytes` output)."
msgstr ""
"El siguiente códec proporciona una transformación de texto: un mapeo de :"
"class:`str` a :class:`str`. No es compatible con :meth:`str.encode` (que "
"solo produce :class:`bytes` de salida)."

#: ../Doc/library/codecs.rst:1452
msgid "rot_13"
msgstr "rot_13"

#: ../Doc/library/codecs.rst:1452
msgid "rot13"
msgstr "rot13"

#: ../Doc/library/codecs.rst:1452
msgid "Return the Caesar-cypher encryption of the operand."
msgstr "Retorna el cifrado César (*Caesar-cypher*) del operando."

#: ../Doc/library/codecs.rst:1457
msgid "Restoration of the ``rot_13`` text transform."
msgstr "Restauración de la transformación de texto ``rot_13``."

#: ../Doc/library/codecs.rst:1460
msgid "Restoration of the ``rot13`` alias."
msgstr "Restauración del alias ``rot13``."

#: ../Doc/library/codecs.rst:1465
msgid ""
":mod:`encodings.idna` --- Internationalized Domain Names in Applications"
msgstr ""
":mod:`encodings.idna` --- Nombres de dominio internacionalizados en "
"aplicaciones"

#: ../Doc/library/codecs.rst:1471
msgid ""
"This module implements :rfc:`3490` (Internationalized Domain Names in "
"Applications) and :rfc:`3492` (Nameprep: A Stringprep Profile for "
"Internationalized Domain Names (IDN)). It builds upon the ``punycode`` "
"encoding and :mod:`stringprep`."
msgstr ""
"Este módulo implementa :rfc:`3490` (nombres de dominio internacionalizados "
"en aplicaciones) y :rfc:`3492` (*Nameprep*: un perfil de *Stringprep* para "
"nombres de dominio internacionalizados (IDN)). Se basa en la codificación "
"``punycode`` y :mod:`stringprep`."

#: ../Doc/library/codecs.rst:1476
msgid ""
"If you need the IDNA 2008 standard from :rfc:`5891` and :rfc:`5895`, use the "
"third-party `idna module <https://pypi.org/project/idna/>`_."
msgstr ""
"Si necesita el estándar IDNA 2008 de :rfc:`5891` y :rfc:`5895`, use el "
"`módulo idna <https://pypi.org/project/idna/>_` de terceros."

#: ../Doc/library/codecs.rst:1479
msgid ""
"These RFCs together define a protocol to support non-ASCII characters in "
"domain names. A domain name containing non-ASCII characters (such as ``www."
"Alliancefrançaise.nu``) is converted into an ASCII-compatible encoding (ACE, "
"such as ``www.xn--alliancefranaise-npb.nu``). The ACE form of the domain "
"name is then used in all places where arbitrary characters are not allowed "
"by the protocol, such as DNS queries, HTTP :mailheader:`Host` fields, and so "
"on. This conversion is carried out in the application; if possible invisible "
"to the user: The application should transparently convert Unicode domain "
"labels to IDNA on the wire, and convert back ACE labels to Unicode before "
"presenting them to the user."
msgstr ""
"Estas RFC juntas definen un protocolo para admitir caracteres no ASCII en "
"los nombres de dominio. Un nombre de dominio que contiene caracteres no "
"ASCII (como ``www.Alliancefrançaise.nu``) se convierte en una codificación "
"compatible con ASCII (ACE, como ``www.xn--alliancefranaise-npb.nu``). La "
"forma ACE del nombre de dominio se utiliza en todos los lugares donde el "
"protocolo no permite caracteres arbitrarios, como consultas DNS, campos "
"HTTP :mailheader:`Host`, etc. Esta conversión se lleva a cabo en la "
"aplicación; si es posible invisible para el usuario: la aplicación debe "
"convertir de forma transparente las etiquetas de dominio Unicode a IDNA en "
"el cable, y volver a convertir las etiquetas ACE a Unicode antes de "
"presentarlas al usuario."

#: ../Doc/library/codecs.rst:1490
msgid ""
"Python supports this conversion in several ways:  the ``idna`` codec "
"performs conversion between Unicode and ACE, separating an input string into "
"labels based on the separator characters defined in :rfc:`section 3.1 of RFC "
"3490 <3490#section-3.1>` and converting each label to ACE as required, and "
"conversely separating an input byte string into labels based on the ``.`` "
"separator and converting any ACE labels found into unicode. Furthermore, "
"the :mod:`socket` module transparently converts Unicode host names to ACE, "
"so that applications need not be concerned about converting host names "
"themselves when they pass them to the socket module. On top of that, modules "
"that have host names as function parameters, such as :mod:`http.client` and :"
"mod:`ftplib`, accept Unicode host names (:mod:`http.client` then also "
"transparently sends an IDNA hostname in the :mailheader:`Host` field if it "
"sends that field at all)."
msgstr ""
"Python admite esta conversión de varias maneras: el códec ``idna`` realiza "
"la conversión entre Unicode y ACE, separando una cadena de entrada en "
"etiquetas basadas en los caracteres separadores definidos en la sección 3.1 "
"de RFC 3490 :rfc:`3490#section-3.1` y convertir cada etiqueta a ACE según "
"sea necesario, y por el contrario, separar una cadena de bytes de entrada en "
"etiquetas basadas en el separador ``.`` y convertir cualquier etiqueta ACE "
"encontrada en unicode. Además, el módulo :mod:`socket` convierte de forma "
"transparente los nombres de host Unicode a ACE, por lo que las aplicaciones "
"no necesitan preocuparse por convertir los nombres de host ellos mismos "
"cuando los pasan al módulo de socket. Además de eso, los módulos que tienen "
"nombres de host como parámetros de función, como :mod:`http.client` y :mod:"
"`ftplib`, aceptan nombres de host Unicode (:mod:`http.client` y luego "
"también envían un mensaje transparente IDNA *hostname* en el campo :"
"mailheader:`Host` si envía ese campo)."

#: ../Doc/library/codecs.rst:1503
msgid ""
"When receiving host names from the wire (such as in reverse name lookup), no "
"automatic conversion to Unicode is performed: applications wishing to "
"present such host names to the user should decode them to Unicode."
msgstr ""
"Al recibir nombres de host desde el cable (como en la búsqueda inversa de "
"nombres), no se realiza una conversión automática a Unicode: las "
"aplicaciones que deseen presentar dichos nombres de host al usuario deben "
"decodificarlos en Unicode."

#: ../Doc/library/codecs.rst:1507
msgid ""
"The module :mod:`encodings.idna` also implements the nameprep procedure, "
"which performs certain normalizations on host names, to achieve case-"
"insensitivity of international domain names, and to unify similar "
"characters. The nameprep functions can be used directly if desired."
msgstr ""
"El módulo :mod:`encodings.idna` también implementa el procedimiento "
"*nameprep*, que realiza ciertas normalizaciones en los nombres de host, para "
"lograr la insensibilidad a mayúsculas y minúsculas de los nombres de dominio "
"internacionales y unificar caracteres similares. Las funciones *nameprep* se "
"pueden usar directamente si lo desea."

#: ../Doc/library/codecs.rst:1515
msgid ""
"Return the nameprepped version of *label*. The implementation currently "
"assumes query strings, so ``AllowUnassigned`` is true."
msgstr ""
"Retorna la versión pasada por *nameprep* (o versión *nameprepped*) de "
"*label*. La implementación actualmente asume cadenas de caracteres de "
"consulta, por lo que ``AllowUnassigned`` es verdadero."

#: ../Doc/library/codecs.rst:1521
msgid ""
"Convert a label to ASCII, as specified in :rfc:`3490`. ``UseSTD3ASCIIRules`` "
"is assumed to be false."
msgstr ""
"Convierte una etiqueta a ASCII, como se especifica en :rfc:`3490`. Se supone "
"que ``UseSTD3ASCIIRules`` es falso."

#: ../Doc/library/codecs.rst:1527
msgid "Convert a label to Unicode, as specified in :rfc:`3490`."
msgstr "Convierte una etiqueta a Unicode, como se especifica en :rfc:`3490`."

#: ../Doc/library/codecs.rst:1531
msgid ":mod:`encodings.mbcs` --- Windows ANSI codepage"
msgstr ":mod:`encodings.mbcs` --- Página de códigos ANSI de Windows"

#: ../Doc/library/codecs.rst:1536
msgid "This module implements the ANSI codepage (CP_ACP)."
msgstr "Este módulo implementa la página de códigos ANSI (CP_ACP)."

#: ../Doc/library/codecs.rst:1538
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Disponibilidad <availability>`: Windows."

#: ../Doc/library/codecs.rst:1540
msgid "Support any error handler."
msgstr "Admite cualquier manejador de errores."

#: ../Doc/library/codecs.rst:1543
msgid ""
"Before 3.2, the *errors* argument was ignored; ``'replace'`` was always used "
"to encode, and ``'ignore'`` to decode."
msgstr ""
"Antes de 3.2, se ignoraba el argumento *errors*; ``'replace'`` siempre se "
"usó para codificar e ``'ignore'`` para decodificar."

#: ../Doc/library/codecs.rst:1549
msgid ":mod:`encodings.utf_8_sig` --- UTF-8 codec with BOM signature"
msgstr ":mod:`encodings.utf_8_sig` --- Códec UTF-8 con firma BOM"

#: ../Doc/library/codecs.rst:1555
msgid ""
"This module implements a variant of the UTF-8 codec. On encoding, a UTF-8 "
"encoded BOM will be prepended to the UTF-8 encoded bytes. For the stateful "
"encoder this is only done once (on the first write to the byte stream). On "
"decoding, an optional UTF-8 encoded BOM at the start of the data will be "
"skipped."
msgstr ""
"Este módulo implementa una variante del códec UTF-8. Al codificar, una lista "
"de materiales codificada en UTF-8 se antepondrá a los bytes codificados en "
"UTF-8. Para el codificador con estado esto solo se hace una vez (en la "
"primera escritura en el flujo de bytes). En la decodificación, se omitirá "
"una lista de materiales opcional codificada en UTF-8 al comienzo de los "
"datos."

#: ../Doc/library/codecs.rst:13
msgid "Unicode"
msgstr "Unicode"

#: ../Doc/library/codecs.rst:13
msgid "encode"
msgstr "encode"

#: ../Doc/library/codecs.rst:13
msgid "decode"
msgstr "decode"

#: ../Doc/library/codecs.rst:13
msgid "streams"
msgstr "streams"

#: ../Doc/library/codecs.rst:13
msgid "stackable"
msgstr "stackable"

#: ../Doc/library/codecs.rst:312
msgid "strict"
msgstr "strict"

#: ../Doc/library/codecs.rst:312 ../Doc/library/codecs.rst:364
#: ../Doc/library/codecs.rst:387
msgid "error handler's name"
msgstr "nombre de gestor de errores"

#: ../Doc/library/codecs.rst:312
msgid "ignore"
msgstr "ignore"

#: ../Doc/library/codecs.rst:312
msgid "replace"
msgstr "replace"

#: ../Doc/library/codecs.rst:312
msgid "backslashreplace"
msgstr "backslashreplace"

#: ../Doc/library/codecs.rst:312
msgid "surrogateescape"
msgstr "surrogateescape"

#: ../Doc/library/codecs.rst:312
msgid "? (question mark)"
msgstr "? (signo de pregunta)"

#: ../Doc/library/codecs.rst:312
msgid "replacement character"
msgstr "caracter de reemplazo"

#: ../Doc/library/codecs.rst:312
msgid "\\ (backslash)"
msgstr "\\ (barra inversa)"

#: ../Doc/library/codecs.rst:312 ../Doc/library/codecs.rst:364
msgid "escape sequence"
msgstr "secuencia de escape"

#: ../Doc/library/codecs.rst:312
msgid "\\x"
msgstr "\\x"

#: ../Doc/library/codecs.rst:312
msgid "\\u"
msgstr "\\u"

#: ../Doc/library/codecs.rst:312
msgid "\\U"
msgstr "\\U"

#: ../Doc/library/codecs.rst:364
msgid "xmlcharrefreplace"
msgstr "xmlcharrefreplace"

#: ../Doc/library/codecs.rst:364
msgid "namereplace"
msgstr "namereplace"

#: ../Doc/library/codecs.rst:364
msgid "\\N"
msgstr "\\N"

#: ../Doc/library/codecs.rst:387
msgid "surrogatepass"
msgstr "surrogatepass"
