# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2022-10-30 14:38-0600\n"
"Last-Translator: \n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.0\n"

#: ../Doc/library/shutil.rst:2
msgid ":mod:`shutil` --- High-level file operations"
msgstr ":mod:`shutil` --- Operaciones de archivos de alto nivel"

#: ../Doc/library/shutil.rst:10
msgid "**Source code:** :source:`Lib/shutil.py`"
msgstr "Código fuente: :source:`Lib/shutil.py`"

#: ../Doc/library/shutil.rst:18
msgid ""
"The :mod:`shutil` module offers a number of high-level operations on files "
"and collections of files.  In particular, functions are provided  which "
"support file copying and removal. For operations on individual files, see "
"also the :mod:`os` module."
msgstr ""
"El módulo :mod:`shutil` ofrece varias operaciones de alto nivel en archivos "
"y colecciones de archivos. En particular, provee funciones que dan soporte a "
"la copia y remoción de archivos. Para operaciones en archivos individuales, "
"véase también el módulo :mod:`os`."

#: ../Doc/library/shutil.rst:25
msgid ""
"Even the higher-level file copying functions (:func:`shutil.copy`, :func:"
"`shutil.copy2`) cannot copy all file metadata."
msgstr ""
"Incluso las funciones de copia de archivos de nivel superior (:func:`shutil."
"copy`, :func:`shutil.copy2`) no pueden copiar todos los metadatos del "
"archivo."

#: ../Doc/library/shutil.rst:28
msgid ""
"On POSIX platforms, this means that file owner and group are lost as well as "
"ACLs.  On Mac OS, the resource fork and other metadata are not used. This "
"means that resources will be lost and file type and creator codes will not "
"be correct. On Windows, file owners, ACLs and alternate data streams are not "
"copied."
msgstr ""
"En las plataformas POSIX, esto significa que tanto el propietario como el "
"grupo del archivo se pierden, al igual que las ACLs (*access control lists* "
"o lista de control de acceso). En Mac OS, la bifurcación (*fork*) de "
"recursos y de otros metadatos no se utilizan. Esto quiere decir que los "
"recursos se perderán y que el tipo de archivo y los códigos de creador no "
"serán correctos. En Windows, los propietarios de archivos, las ACLs y "
"secuencias de datos alternativas no se copian."

#: ../Doc/library/shutil.rst:38
msgid "Directory and files operations"
msgstr "Operaciones de directorios y archivos"

#: ../Doc/library/shutil.rst:42
msgid ""
"Copy the contents of the file-like object *fsrc* to the file-like object "
"*fdst*. The integer *length*, if given, is the buffer size. In particular, a "
"negative *length* value means to copy the data without looping over the "
"source data in chunks; by default the data is read in chunks to avoid "
"uncontrolled memory consumption. Note that if the current file position of "
"the *fsrc* object is not 0, only the contents from the current file position "
"to the end of the file will be copied."
msgstr ""
"Copia los contenidos del objeto de tipo archivo *fsrc* en el objeto *fdst*. "
"El valor entero *length*, si está indicado, es el tamaño del búfer. En "
"particular, un valor *length* negativo significa copiar los datos sin "
"recorrer los datos de origen en fragmentos; los datos se leen en fragmentos "
"en forma predeterminada para evitar el consumo de memoria incontrolado. "
"Nótese que si la posición actual del archivo del objeto *fsrc* es distinto "
"de cero, solo se copiarán el contenido desde la posición actual del archivo "
"hasta el final."

#: ../Doc/library/shutil.rst:53
msgid ""
"Copy the contents (no metadata) of the file named *src* to a file named "
"*dst* and return *dst* in the most efficient way possible. *src* and *dst* "
"are path-like objects or path names given as strings."
msgstr ""
"Copia los contenidos (sin metadatos) del archivo *src* en un archivo  "
"denominado *dst* y retorna *dst* de la manera más eficaz posible. *src* y "
"*dst* son objetos de tipo ruta o nombres de ruta dados como cadenas de "
"caracteres."

#: ../Doc/library/shutil.rst:57
msgid ""
"*dst* must be the complete target file name; look at :func:`~shutil.copy` "
"for a copy that accepts a target directory path.  If *src* and *dst* specify "
"the same file, :exc:`SameFileError` is raised."
msgstr ""
"*dst* debe ser el nombre completo del archivo destino; véase :func:`shutil."
"copy` para una copia que acepta una ruta de directorio destino. Si *src* y "
"*dst* refieren al mismo archivo, se lanza :exc:`SameFileError`."

#: ../Doc/library/shutil.rst:61
msgid ""
"The destination location must be writable; otherwise, an :exc:`OSError` "
"exception will be raised. If *dst* already exists, it will be replaced. "
"Special files such as character or block devices and pipes cannot be copied "
"with this function."
msgstr ""
"El local de destino debe tener permisos de escritura; de lo contrario, se "
"genera una excepción :exc:`OSError`. Si *dst* ya existe, se reemplazará. Los "
"archivos especiales, como los dispositivos de caracteres o de bloques y "
"*pipes*, no se pueden copiar con esta función."

#: ../Doc/library/shutil.rst:66
msgid ""
"If *follow_symlinks* is false and *src* is a symbolic link, a new symbolic "
"link will be created instead of copying the file *src* points to."
msgstr ""
"Si *follow_symlinks* es falso y *src* es un enlace simbólico, un enlace "
"simbólico nuevo se creará en lugar de copiar el archivo al que *src* apunta."

#: ../Doc/library/shutil.rst:70 ../Doc/library/shutil.rst:177
#: ../Doc/library/shutil.rst:208
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copyfile`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Se genera un :ref:`evento de auditoría <auditing>` ``shutil.copyfile`` con "
"argumentos ``src``, ``dst``."

#: ../Doc/library/shutil.rst:72
msgid ""
":exc:`IOError` used to be raised instead of :exc:`OSError`. Added "
"*follow_symlinks* argument. Now returns *dst*."
msgstr ""
"Solía generarse :exc:`IOError` en lugar de :exc:`OSError`. Se añadió el "
"argumento *follow_symlinks*. Ahora retorna *dst*."

#: ../Doc/library/shutil.rst:77
msgid ""
"Raise :exc:`SameFileError` instead of :exc:`Error`.  Since the former is a "
"subclass of the latter, this change is backward compatible."
msgstr ""
"Genera :exc:`SameFileError` en lugar de :exc:`Error`. Dado que la primera es "
"una subclase de la segunda, el cambio es compatible con versiones anteriores."

#: ../Doc/library/shutil.rst:81 ../Doc/library/shutil.rst:185
#: ../Doc/library/shutil.rst:217 ../Doc/library/shutil.rst:287
#: ../Doc/library/shutil.rst:387
msgid ""
"Platform-specific fast-copy syscalls may be used internally in order to copy "
"the file more efficiently. See :ref:`shutil-platform-dependent-efficient-"
"copy-operations` section."
msgstr ""
"Las llamadas a sistema de copia rápida específicas de la plataforma se "
"pueden usar internamente para copiar el archivo de manera más eficiente. "
"Véase la sección :ref:`shutil-platform-dependent-efficient-copy-operations`."

#: ../Doc/library/shutil.rst:88
msgid ""
"This exception is raised if source and destination in :func:`copyfile` are "
"the same file."
msgstr ""
"Esta excepción se genera si el origen y destino en :func:`copyfile` son el "
"mismo archivo."

#: ../Doc/library/shutil.rst:96
msgid ""
"Copy the permission bits from *src* to *dst*.  The file contents, owner, and "
"group are unaffected.  *src* and *dst* are path-like objects or path names "
"given as strings. If *follow_symlinks* is false, and both *src* and *dst* "
"are symbolic links, :func:`copymode` will attempt to modify the mode of "
"*dst* itself (rather than the file it points to).  This functionality is not "
"available on every platform; please see :func:`copystat` for more "
"information.  If :func:`copymode` cannot modify symbolic links on the local "
"platform, and it is asked to do so, it will do nothing and return."
msgstr ""
"Copia los bits de permiso de *src* a *dst*. Los contenidos, el propietario y "
"el grupo no se ven afectados. *src* y *dst* son objetos tipo ruta o nombres "
"de ruta dados como cadenas de caracteres. Si *follow_symlinks* es falso, y "
"tanto *src* como *dst* son enlaces simbólicos, :func:`copymode` intentará "
"modificar el modo de *dst* (y no el archivo al que apunta). Esta "
"funcionalidad no está disponible en todas las plataformas; véase :func:"
"`copystat` para mayor información. Si :func:`copymode` no puede modificar "
"los enlaces simbólicos de la plataforma local y se le solicita hacerlo, no "
"hará nada y retornará."

#: ../Doc/library/shutil.rst:106 ../Doc/library/shutil.rst:179
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copymode`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Genera un :ref:`evento de auditoría <auditing>` ``shutil.copymode`` con "
"argumentos ``src``, ``dst``."

#: ../Doc/library/shutil.rst:108
msgid "Added *follow_symlinks* argument."
msgstr "Se añadió el argumento *follow_symlinks*."

#: ../Doc/library/shutil.rst:113
msgid ""
"Copy the permission bits, last access time, last modification time, and "
"flags from *src* to *dst*.  On Linux, :func:`copystat` also copies the "
"\"extended attributes\" where possible.  The file contents, owner, and group "
"are unaffected.  *src* and *dst* are path-like objects or path names given "
"as strings."
msgstr ""
"Copia los bits de permiso, la última hora de acceso, la última hora de "
"modificación y las *flags* desde *src* a *dst*. En Linux, :func:`copystat` "
"también copia los \"atributos extendidos\" siempre que sea posible. Los "
"contenidos, el propietario y el grupo del archivo no se ven afectados. *src* "
"y *dst* son objetos de tipo a ruta o nombres de ruta dados como cadenas de "
"caracteres."

#: ../Doc/library/shutil.rst:119
msgid ""
"If *follow_symlinks* is false, and *src* and *dst* both refer to symbolic "
"links, :func:`copystat` will operate on the symbolic links themselves rather "
"than the files the symbolic links refer to—reading the information from the "
"*src* symbolic link, and writing the information to the *dst* symbolic link."
msgstr ""
"Si *follow_symlinks* es falso, y *src* y *dst* hacen referencia los enlaces "
"simbólicos, :func:`copystat` funcionará con los enlaces simbólicos en lugar "
"de en los archivos a los que estos se refieren: leer la información del "
"enlace simbólico *src* y escribirla en el enlace simbólico *dst*."

#: ../Doc/library/shutil.rst:128
msgid ""
"Not all platforms provide the ability to examine and modify symbolic links.  "
"Python itself can tell you what functionality is locally available."
msgstr ""
"No todas las plataformas proporcionan la capacidad de examinar y modificar "
"enlaces simbólicos. Python puede indicarte qué funcionalidad está disponible "
"localmente."

#: ../Doc/library/shutil.rst:132
msgid ""
"If ``os.chmod in os.supports_follow_symlinks`` is ``True``, :func:`copystat` "
"can modify the permission bits of a symbolic link."
msgstr ""
"Si ``os.chmod in os.supports_follow_symlinks`` es ``True``, :func:`copystat` "
"puede modificar los bits de permiso de un enlace simbólico."

#: ../Doc/library/shutil.rst:136
msgid ""
"If ``os.utime in os.supports_follow_symlinks`` is ``True``, :func:`copystat` "
"can modify the last access and modification times of a symbolic link."
msgstr ""
"Si ``os.utime in os.supports_follow_symlinks`` es ``True``, :func:`copystat` "
"puede modificar el último acceso y las veces que un enlace simbólico fue "
"modificado."

#: ../Doc/library/shutil.rst:140
msgid ""
"If ``os.chflags in os.supports_follow_symlinks`` is ``True``, :func:"
"`copystat` can modify the flags of a symbolic link.  (``os.chflags`` is not "
"available on all platforms.)"
msgstr ""
"Si ``os.chflags in os.supports_follow_symlinks`` es ``True``, :func:"
"`copystat` puede modificar las flags de un enlace simbólico. (``os.chflags`` "
"no está disponible en todas las plataformas.)"

#: ../Doc/library/shutil.rst:145
msgid ""
"On platforms where some or all of this functionality is unavailable, when "
"asked to modify a symbolic link, :func:`copystat` will copy everything it "
"can. :func:`copystat` never returns failure."
msgstr ""
"En plataformas donde parte o toda esta funcionalidad no está disponible, "
"cuando se le pida modificar un enlace simbólico, :func:`copystat` copiará "
"todo lo que pueda. :func:`copystat` nunca retorna un error."

#: ../Doc/library/shutil.rst:150
msgid "Please see :data:`os.supports_follow_symlinks` for more information."
msgstr "Véase :data:`os.supports_follow_symlinks` para más información."

#: ../Doc/library/shutil.rst:153 ../Doc/library/shutil.rst:210
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copystat`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Genera un :ref:`evento de auditoría <auditing>` ``shutil.copystat`` con "
"argumentos ``src``, ``dst``."

#: ../Doc/library/shutil.rst:155
msgid ""
"Added *follow_symlinks* argument and support for Linux extended attributes."
msgstr ""
"Se ha añadido el argumento *follow_symlinks* y el soporte para atributos "
"extendidos de Linux."

#: ../Doc/library/shutil.rst:160
msgid ""
"Copies the file *src* to the file or directory *dst*.  *src* and *dst* "
"should be :term:`path-like objects <path-like object>` or strings.  If *dst* "
"specifies a directory, the file will be copied into *dst* using the base "
"filename from *src*. If *dst* specifies a file that already exists, it will "
"be replaced. Returns the path to the newly created file."
msgstr ""
"Copia el archivo *src* al archivo o directorio *dst*. *src* y *dst* deberían "
"ser :term:`objetos tipo ruta <path-like object>` o cadenas de caracteres "
"(*strings*). Si *dst* especifica un directorio, el archivo será copiado en "
"*dst* usando el nombre de archivo base de *src*. Si *dst* especifica un "
"archivo que existe, será reemplazado. Retorna la ruta del archivo recién "
"creado."

#: ../Doc/library/shutil.rst:166
msgid ""
"If *follow_symlinks* is false, and *src* is a symbolic link, *dst* will be "
"created as a symbolic link.  If *follow_symlinks* is true and *src* is a "
"symbolic link, *dst* will be a copy of the file *src* refers to."
msgstr ""
"Si *follow_symlinks* es falso, y *src* es un enlace simbólico, *dst* se "
"creará como enlace simbólico. Si *follow_symlinks* es verdadero y *src* es "
"un enlace simbólico, *dst* será una copia del archivo al que *src* hace "
"referencia."

#: ../Doc/library/shutil.rst:171
msgid ""
":func:`~shutil.copy` copies the file data and the file's permission mode "
"(see :func:`os.chmod`).  Other metadata, like the file's creation and "
"modification times, is not preserved. To preserve all file metadata from the "
"original, use :func:`~shutil.copy2` instead."
msgstr ""
":func:`~shutil.copy` copia los datos del archivo y el modo de permiso del "
"archivo (véase :func:`os.chmod`). Otros metadatos, como los tiempos de "
"creación y modificación de archivos, no se preservan. Para preservar todos "
"los metadatos del archivo, usa :func:`~shutil.copy2` en su lugar."

#: ../Doc/library/shutil.rst:181
msgid ""
"Added *follow_symlinks* argument. Now returns path to the newly created file."
msgstr ""
"Se ha añadido el argumento *follow_symlinks*. Ahora retorna la ruta de "
"acceso al archivo recién creado."

#: ../Doc/library/shutil.rst:192
msgid ""
"Identical to :func:`~shutil.copy` except that :func:`copy2` also attempts to "
"preserve file metadata."
msgstr ""
"Idéntico a :func:`~shutil.copy` , excepto que :func:`copy2` también intenta "
"conservar los metadatos del archivo."

#: ../Doc/library/shutil.rst:195
msgid ""
"When *follow_symlinks* is false, and *src* is a symbolic link, :func:`copy2` "
"attempts to copy all metadata from the *src* symbolic link to the newly "
"created *dst* symbolic link. However, this functionality is not available on "
"all platforms. On platforms where some or all of this functionality is "
"unavailable, :func:`copy2` will preserve all the metadata it can; :func:"
"`copy2` never raises an exception because it cannot preserve file metadata."
msgstr ""
"Cuando *follow_symlinks* es falso, y *src* es un enlace simbólico, :func:"
"`copy2` intenta copiar todos los metadatos del enlace simbólico *src* en el "
"enlace simbólico *dst* recién creado. Sin embargo, esta funcionalidad no "
"está disponible en todas las plataformas. En las plataformas donde parte o "
"toda esta funcionalidad no está disponible, :func:`copy2` conservará todos "
"los metadatos que pueda; :func:`copy2` nunca genera una excepción porque no "
"puede conservar los metadatos del archivo."

#: ../Doc/library/shutil.rst:204
msgid ""
":func:`copy2` uses :func:`copystat` to copy the file metadata. Please see :"
"func:`copystat` for more information about platform support for modifying "
"symbolic link metadata."
msgstr ""
":func:`copy2` usa :func:`copystat` para copiar todos los metadatos del "
"archivo. Véase :func:`copystat` para más información sobre la compatibilidad "
"con la plataforma para modificar los metadatos del enlace simbólico."

#: ../Doc/library/shutil.rst:212
msgid ""
"Added *follow_symlinks* argument, try to copy extended file system "
"attributes too (currently Linux only). Now returns path to the newly created "
"file."
msgstr ""
"Añadido el argumento *follow_symlinks*, intenta copiar también los atributos "
"del sistema de archivos extendidos (actualmente solo en Linux). Ahora "
"retorna la ruta de acceso al archivo recién creado."

#: ../Doc/library/shutil.rst:224
msgid ""
"This factory function creates a function that can be used as a callable for :"
"func:`copytree`\\'s *ignore* argument, ignoring files and directories that "
"match one of the glob-style *patterns* provided.  See the example below."
msgstr ""
"Esta función de fábrica crea una función que puede ser usada como un "
"invocable para el argumento *ignore* de :func:`copytree`, ignorando los "
"archivos y directorios que coinciden con uno de los patrones *patterns* de "
"estilo glob provistos. Véase el ejemplo siguiente."

#: ../Doc/library/shutil.rst:233
msgid ""
"Recursively copy an entire directory tree rooted at *src* to a directory "
"named *dst* and return the destination directory.  All intermediate "
"directories needed to contain *dst* will also be created by default."
msgstr ""
"Copia recursivamente un directorio completo que inicia en *src* hasta un "
"directorio llamado *dst* y devuelve el directorio destino. Todos los "
"directorios intermedios necesarios para contener *dst* serán creados por "
"default."

#: ../Doc/library/shutil.rst:237
msgid ""
"Permissions and times of directories are copied with :func:`copystat`, "
"individual files are copied using :func:`~shutil.copy2`."
msgstr ""
"Los permisos y los tiempos de directorios son copiados con :func:`copystat`; "
"los archivos individuales son copiados usando :func:`~shutil.copy2`."

#: ../Doc/library/shutil.rst:240
msgid ""
"If *symlinks* is true, symbolic links in the source tree are represented as "
"symbolic links in the new tree and the metadata of the original links will "
"be copied as far as the platform allows; if false or omitted, the contents "
"and metadata of the linked files are copied to the new tree."
msgstr ""
"Si *symlinks* es verdadero, los enlaces simbólicos en el árbol de origen son "
"representados como enlaces simbólicos en el árbol nuevo y los metadatos de "
"los enlaces originales serán copiados mientras la plataforma lo permita; si "
"es falso o se omite, los contenidos y los metadatos de los archivos "
"vinculados se copiarán en el árbol nuevo."

#: ../Doc/library/shutil.rst:245
msgid ""
"When *symlinks* is false, if the file pointed by the symlink doesn't exist, "
"an exception will be added in the list of errors raised in an :exc:`Error` "
"exception at the end of the copy process. You can set the optional "
"*ignore_dangling_symlinks* flag to true if you want to silence this "
"exception. Notice that this option has no effect on platforms that don't "
"support :func:`os.symlink`."
msgstr ""
"Cuando *symlinks* es falso y el archivo al que apunta no exista, se agrega "
"una excepción a la lista de errores generados en una excepción :exc:`Error` "
"al final del proceso de copia. Puedes establecer la marca opcional "
"*ignore_dangling_symlinks* en verdadero si deseas silenciar esa excepción. "
"Ten en cuenta que esta opción no tiene efecto en plataformas que no admiten :"
"func:`os.symlink`."

#: ../Doc/library/shutil.rst:252
msgid ""
"If *ignore* is given, it must be a callable that will receive as its "
"arguments the directory being visited by :func:`copytree`, and a list of its "
"contents, as returned by :func:`os.listdir`.  Since :func:`copytree` is "
"called recursively, the *ignore* callable will be called once for each "
"directory that is copied.  The callable must return a sequence of directory "
"and file names relative to the current directory (i.e. a subset of the items "
"in its second argument); these names will then be ignored in the copy "
"process.  :func:`ignore_patterns` can be used to create such a callable that "
"ignores names based on glob-style patterns."
msgstr ""
"Si se proporciona *ignore*, debe ser un invocable que recibirá como "
"argumentos el directorio visitado por :func:`copytree` y una lista de sus "
"contenidos, tal como los retorna :func:`os.listdir`. Ya que :func:`copytree` "
"se invoca recursivamente, el invocable *ignore* se llamará una vez por cada "
"directorio que se copia. El invocable debe retornar una secuencia de "
"directorio y de nombres de archivo en relación con el directorio actual (es "
"decir, un subconjunto de los elementos en su segundo argumento); estos "
"nombres serán ignorados en el proceso de copia. :func:`ignore_patterns` se "
"pueden usar para crear un invocable que ignora los nombres basados en "
"patrones de estilo gob."

#: ../Doc/library/shutil.rst:262
msgid ""
"If exception(s) occur, an :exc:`Error` is raised with a list of reasons."
msgstr ""
"Si ocurren excepciones, se genera, un :exc:`Error` con una lista de razones."

#: ../Doc/library/shutil.rst:264
msgid ""
"If *copy_function* is given, it must be a callable that will be used to copy "
"each file. It will be called with the source path and the destination path "
"as arguments. By default, :func:`~shutil.copy2` is used, but any function "
"that supports the same signature (like :func:`~shutil.copy`) can be used."
msgstr ""
"Si *copy_function* está dado, debe ser un invocable que se usará para copiar "
"cada archivo. Se le invocará con la ruta de origen y la ruta de destino como "
"argumentos. Por defecto, se usa :func:`~shutil.copy2`, pero se puede usar "
"cualquier función que admita la misma (como :func:`~shutil.copy`)."

#: ../Doc/library/shutil.rst:269
msgid ""
"If *dirs_exist_ok* is false (the default) and *dst* already exists, a :exc:"
"`FileExistsError` is raised. If *dirs_exist_ok* is true, the copying "
"operation will continue if it encounters existing directories, and files "
"within the *dst* tree will be overwritten by corresponding files from the "
"*src* tree."
msgstr ""
"Si *dirs_exist_ok* es falso (el default) y *dst* existe, la excepción :exc:"
"`FileExistsError` es lanzada. Si *dirs_exist_ok* es verdadero, la operación "
"de copiado continuara si encuentra directorios existentes, los archivos "
"dentro del árbol de *dst* serán sobreescritos por los archivos "
"correspondientes del árbol *src*."

#: ../Doc/library/shutil.rst:275
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copytree`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Se genera un :ref:`evento de auditoría <auditing>` ``shutil.copytree`` con "
"argumentos ``src``, ``dst``."

#: ../Doc/library/shutil.rst:277
msgid "Copy metadata when *symlinks* is false. Now returns *dst*."
msgstr "Copia los metadatos cuando *symlinks* es falso. Ahora retorna *dst*."

#: ../Doc/library/shutil.rst:281
msgid ""
"Added the *copy_function* argument to be able to provide a custom copy "
"function. Added the *ignore_dangling_symlinks* argument to silence dangling "
"symlinks errors when *symlinks* is false."
msgstr ""
"Se añadió el argumento *copy_function* para poder proporcionar una función "
"de copia personalizada. Se añadió el argumento *ignore_dangling_symlinks* "
"para silenciar los errores de enlaces colgantes cuando *symlinks* es falso."

#: ../Doc/library/shutil.rst:292
msgid "The *dirs_exist_ok* parameter."
msgstr "El parámetro *dirs_exist_ok*."

#: ../Doc/library/shutil.rst:299
#, fuzzy
msgid ""
"Delete an entire directory tree; *path* must point to a directory (but not a "
"symbolic link to a directory).  If *ignore_errors* is true, errors resulting "
"from failed removals will be ignored; if false or omitted, such errors are "
"handled by calling a handler specified by *onexc* or *onerror* or, if both "
"are omitted, exceptions are propagated to the caller."
msgstr ""
"Elimina un árbol de directorios entero; *path* debe apuntar a un directorio "
"(pero no a un enlace simbólico a un directorio). Si *ignore_errors* es "
"verdadero, se eliminarán los errores que resulten de eliminaciones fallidas; "
"si es falso u omitido, estos errores se controlan invocando un controlador "
"especificado por *onerror* o, si este es omitido, se genera una excepción."

#: ../Doc/library/shutil.rst:305
msgid ""
"This function can support :ref:`paths relative to directory descriptors "
"<dir_fd>`."
msgstr ""
"Esta función puede soportar :ref:`rutas relativas a descriptores de "
"directorio <dir_fd>`."

#: ../Doc/library/shutil.rst:310
msgid ""
"On platforms that support the necessary fd-based functions a symlink attack "
"resistant version of :func:`rmtree` is used by default.  On other platforms, "
"the :func:`rmtree` implementation is susceptible to a symlink attack: given "
"proper timing and circumstances, attackers can manipulate symlinks on the "
"filesystem to delete files they wouldn't be able to access otherwise.  "
"Applications can use the :data:`rmtree.avoids_symlink_attacks` function "
"attribute to determine which case applies."
msgstr ""
"En plataformas que admiten las funciones basadas en descriptores de archivo "
"necesarias, una versión resistente de :func:`rmtree` al ataque de enlace "
"simbólico se usa por defecto. En otras plataformas, la implementación :func:"
"`rmtree` es susceptible a un ataque de enlace simbólico; dados el tiempo y "
"las circunstancias adecuados, los atacantes pueden manipular los enlaces "
"simbólicos en el sistema de archivos para eliminar archivos a los que no "
"podrían acceder de otra manera. Las aplicaciones pueden usar el atributo de "
"función :data:`rmtree.avoids_symlink_attacks` para determinar qué caso "
"aplica."

#: ../Doc/library/shutil.rst:318
#, fuzzy
msgid ""
"If *onexc* is provided, it must be a callable that accepts three parameters: "
"*function*, *path*, and *excinfo*."
msgstr ""
"Si se *onerror* está dado, debe ser un invocable que acepte tres parámetros: "
"*function*, *path*, y *excinfo*."

#: ../Doc/library/shutil.rst:321
#, fuzzy
msgid ""
"The first parameter, *function*, is the function which raised the exception; "
"it depends on the platform and implementation.  The second parameter, "
"*path*, will be the path name passed to *function*.  The third parameter, "
"*excinfo*, is the exception that was raised. Exceptions raised by *onexc* "
"will not be caught."
msgstr ""
"El primer parámetro, *function*, es la función que generó la excepción; "
"depende de la plataforma y de la implementación. El segundo parámetro, "
"*path*, será el nombre de ruta pasado a *function*. El tercer parámetro, "
"*excinfo*, será la información de la excepción retornada por :func:`sys."
"exc_info`. Las excepciones generadas por *onerror* no serán tomadas."

#: ../Doc/library/shutil.rst:327
msgid ""
"The deprecated *onerror* is similar to *onexc*, except that the third "
"parameter it receives is the tuple returned from :func:`sys.exc_info`."
msgstr ""

#: ../Doc/library/shutil.rst:330
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.rmtree`` with arguments "
"``path``, ``dir_fd``."
msgstr ""
"Genera un :ref:`evento de auditoría <auditing>` ``shutil.rmtree`` con "
"argumentos ``path``, ``dir_fd``."

#: ../Doc/library/shutil.rst:332
msgid ""
"Added a symlink attack resistant version that is used automatically if "
"platform supports fd-based functions."
msgstr ""
"Se añadió una versión resistente a los ataques de enlaces simbólicos que se "
"usan automáticamente si la plataforma admite funciones pasadas en "
"descriptores de archivo."

#: ../Doc/library/shutil.rst:336
msgid ""
"On Windows, will no longer delete the contents of a directory junction "
"before removing the junction."
msgstr ""
"En Windows, ya no eliminará los contenidos de un cruce de directorios antes "
"de quitar el cruce."

#: ../Doc/library/shutil.rst:340
msgid "The *dir_fd* parameter."
msgstr "El parámetro *dir_fd*."

#: ../Doc/library/shutil.rst:343
msgid "Added the *onexc* parameter, deprecated *onerror*."
msgstr ""

#: ../Doc/library/shutil.rst:348
msgid ""
"Indicates whether the current platform and implementation provides a symlink "
"attack resistant version of :func:`rmtree`.  Currently this is only true for "
"platforms supporting fd-based directory access functions."
msgstr ""
"Indica si la plataforma actual y la implementación proporciona una versión "
"de :func:`rmtree` resistente al ataque de enlace simbólico. Actualmente, "
"esto solo sucede para plataformas que admitan funciones de acceso a "
"directorios basadas en descriptores de archivo."

#: ../Doc/library/shutil.rst:357
msgid ""
"Recursively move a file or directory (*src*) to another location (*dst*) and "
"return the destination."
msgstr ""
"Mueve de forma recursiva un archivo o directorio (*src*) a otra ubicación "
"(*dst*) y retorna el destino."

#: ../Doc/library/shutil.rst:360
msgid ""
"If the destination is an existing directory, then *src* is moved inside that "
"directory. If the destination already exists but is not a directory, it may "
"be overwritten depending on :func:`os.rename` semantics."
msgstr ""
"Si el destino es un directorio existente, entonces *src* se mueve dentro de "
"ese directorio. Si el destino existe pero no es un directorio, puede "
"sobrescribirse dependiendo de la semántica :func:`os.rename`."

#: ../Doc/library/shutil.rst:364
msgid ""
"If the destination is on the current filesystem, then :func:`os.rename` is "
"used. Otherwise, *src* is copied to *dst* using *copy_function* and then "
"removed.  In case of symlinks, a new symlink pointing to the target of *src* "
"will be created in or as *dst* and *src* will be removed."
msgstr ""
"Si el destino está en el sistema de archivos actual, entonces se usa :func:"
"`os.rename`. De lo contrario, *src* se copia en *dst* usando *copy_function "
"y luego se elimina. En el caso de los enlaces simbólicos, se creará un "
"enlace simbólico nuevo que apunta al destino de *src* en o como *dst* y será "
"eliminado."

#: ../Doc/library/shutil.rst:369
#, fuzzy
msgid ""
"If *copy_function* is given, it must be a callable that takes two arguments "
"*src* and *dst*, and will be used to copy *src* to *dst* if :func:`os."
"rename` cannot be used.  If the source is a directory, :func:`copytree` is "
"called, passing it the *copy_function*. The default *copy_function* is :func:"
"`copy2`.  Using :func:`~shutil.copy` as the *copy_function* allows the move "
"to succeed when it is not possible to also copy the metadata, at the expense "
"of not copying any of the metadata."
msgstr ""
"Si *copy_function* se proporciona, debe ser un invocable que toma dos "
"argumentos *src* y *dst*, y se usará para copiar *src* a *dest* si no se "
"puede usar :func:`os.rename`. Si el origen es un directorio, se invoca :func:"
"`copytree` y se le pasa :func:`copy_function`. El *copy_function* por "
"defecto es :func:`copy2`. El uso de :func:`~shutil.copy` como "
"*copy_function* permite que el movimiento se realice correctamente cuando no "
"es posible copiar los metadatos también, a expensas de no copiar ninguno de "
"los metadatos."

#: ../Doc/library/shutil.rst:377
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.move`` with arguments "
"``src``, ``dst``."
msgstr ""
"Genera un :ref:`evento de auditoría <auditing>` ``shutil.move`` con "
"argumentos ``src``, ``dst``."

#: ../Doc/library/shutil.rst:379
msgid ""
"Added explicit symlink handling for foreign filesystems, thus adapting it to "
"the behavior of GNU's :program:`mv`. Now returns *dst*."
msgstr ""
"Se añadió el manejo explícito de enlaces simbólicos para sistemas de "
"archivos extranjeros, de manera que se adapta al comportamiento del :program:"
"`mv` del GNU. Ahora retorna *dst*."

#: ../Doc/library/shutil.rst:384
msgid "Added the *copy_function* keyword argument."
msgstr "Se agregó el argumento de keyword *copy_function*."

#: ../Doc/library/shutil.rst:392
msgid "Accepts a :term:`path-like object` for both *src* and *dst*."
msgstr ""
"Acepta un :term:`objeto tipo ruta <path-like object>` como *src* y *dst*."

#: ../Doc/library/shutil.rst:397
msgid ""
"Return disk usage statistics about the given path as a :term:`named tuple` "
"with the attributes *total*, *used* and *free*, which are the amount of "
"total, used and free space, in bytes. *path* may be a file or a directory."
msgstr ""
"Retorna las estadísticas de uso de disco sobre la ruta de acceso dada como "
"un :term:`named tuple` con los atributos *total*, *used* y *free*, que son "
"las cantidades del espacio total, el usado y el libre, en bytes. *path* "
"puede ser un archivo o un directorio."

#: ../Doc/library/shutil.rst:404
msgid ""
"On Unix filesystems, *path* must point to a path within a **mounted** "
"filesystem partition. On those platforms, CPython doesn't attempt to "
"retrieve disk usage information from non-mounted filesystems."
msgstr ""

#: ../Doc/library/shutil.rst:410
msgid "On Windows, *path* can now be a file or directory."
msgstr "En Windows, *path* ahora puede ser un archivo o un directorio."

#: ../Doc/library/shutil.rst:413
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`Disponibilidad <availability>`: Unix, Windows."

#: ../Doc/library/shutil.rst:417
msgid "Change owner *user* and/or *group* of the given *path*."
msgstr "Cambia el propietario *user* y/o *group* de la *ruta* dada."

#: ../Doc/library/shutil.rst:419
msgid ""
"*user* can be a system user name or a uid; the same applies to *group*. At "
"least one argument is required."
msgstr ""
"*user* puede ser un nombre usuario de sistema o un UID (identificador de "
"usuario); lo mismo aplica a *group*. Se requiere al menos un argumento."

#: ../Doc/library/shutil.rst:422
msgid "See also :func:`os.chown`, the underlying function."
msgstr "Véase también :func:`os.chown`, la función subyacente."

#: ../Doc/library/shutil.rst:424
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.chown`` with arguments "
"``path``, ``user``, ``group``."
msgstr ""
"Genera un :ref:`evento de auditoría <auditing>` ``shutil.chown`` con "
"argumentos ``path``, ``user``, ``group``."

#: ../Doc/library/shutil.rst:426
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`Disponibilidad <availability>`: Unix."

#: ../Doc/library/shutil.rst:433
msgid ""
"Return the path to an executable which would be run if the given *cmd* was "
"called.  If no *cmd* would be called, return ``None``."
msgstr ""
"Retorna la ruta de acceso a un ejecutable que se ejecutaría si el *cmd* dado "
"se invoca. Si no se invoca a *cmd*, retorna ``None``."

#: ../Doc/library/shutil.rst:436
msgid ""
"*mode* is a permission mask passed to :func:`os.access`, by default "
"determining if the file exists and executable."
msgstr ""
"*mode* es una máscara de permiso que se pasa a :func:`os.access`, que "
"determinar por defecto si el archivo existe y es ejecutable."

#: ../Doc/library/shutil.rst:439
#, fuzzy
msgid ""
"When no *path* is specified, the results of :func:`os.environ` are used, "
"returning either the \"PATH\" value or a fallback of :data:`os.defpath`."
msgstr ""
"Cuando no se especifica *path*, se usan los resultados de :func:`os.environ` "
"y se retorna el valor de \"PATH\" o una reserva de :attr:`os.defpath`."

#: ../Doc/library/shutil.rst:442
msgid ""
"On Windows, the current directory is prepended to the *path* if *mode* does "
"not include ``os.X_OK``. When the *mode* does include ``os.X_OK``, the "
"Windows API ``NeedCurrentDirectoryForExePathW`` will be consulted to "
"determine if the current directory should be prepended to *path*. To avoid "
"consulting the current working directory for executables: set the "
"environment variable ``NoDefaultCurrentDirectoryInExePath``."
msgstr ""

#: ../Doc/library/shutil.rst:449
msgid ""
"Also on Windows, the ``PATHEXT`` variable is used to resolve commands that "
"may not already include an extension. For example, if you call ``shutil."
"which(\"python\")``, :func:`which` will search ``PATHEXT`` to know that it "
"should look for ``python.exe`` within the *path* directories. For example, "
"on Windows::"
msgstr ""

#: ../Doc/library/shutil.rst:458
msgid ""
"This is also applied when *cmd* is a path that contains a directory "
"component::"
msgstr ""

#: ../Doc/library/shutil.rst:466
msgid ""
"The :class:`bytes` type is now accepted.  If *cmd* type is :class:`bytes`, "
"the result type is also :class:`bytes`."
msgstr ""
"Ahora se acepta el tipo :class:`bytes`. Si el tipo *cmd* es :class:`bytes`, "
"el tipo resultante también es :class:`bytes`."

#: ../Doc/library/shutil.rst:470
msgid ""
"On Windows, the current directory is no longer prepended to the search path "
"if *mode* includes ``os.X_OK`` and WinAPI "
"``NeedCurrentDirectoryForExePathW(cmd)`` is false, else the current "
"directory is prepended even if it is already in the search path; ``PATHEXT`` "
"is used now even when *cmd* includes a directory component or ends with an "
"extension that is in ``PATHEXT``; and filenames that have no extension can "
"now be found."
msgstr ""

#: ../Doc/library/shutil.rst:481
msgid ""
"This exception collects exceptions that are raised during a multi-file "
"operation. For :func:`copytree`, the exception argument is a list of 3-"
"tuples (*srcname*, *dstname*, *exception*)."
msgstr ""
"Esta excepción recopila las excepciones que se generan durante una operación "
"de varios archivos. Para :func:`copytree`, el argumento de excepción es una "
"lista de 3 tuplas (*scrname*, *dstname*, *exception*)."

#: ../Doc/library/shutil.rst:488
msgid "Platform-dependent efficient copy operations"
msgstr "Operaciones de copia eficientes dependientes de la plataforma"

#: ../Doc/library/shutil.rst:490
msgid ""
"Starting from Python 3.8, all functions involving a file copy (:func:"
"`copyfile`, :func:`~shutil.copy`, :func:`copy2`, :func:`copytree`, and :func:"
"`move`) may use platform-specific \"fast-copy\" syscalls in order to copy "
"the file more efficiently (see :issue:`33671`). \"fast-copy\" means that the "
"copying operation occurs within the kernel, avoiding the use of userspace "
"buffers in Python as in \"``outfd.write(infd.read())``\"."
msgstr ""
"A partir de Python 3.8, todas las funciones que incluyen una copia de "
"archivo (:func:`copyfile`, :func:`copy`, :func:`copy2`, :func:`copytree`, y :"
"func:`move`) puede usar llamadas a sistema de \"copia rápida\" específicas a "
"cada plataforma para poder copiar el archivo de forma más eficiente (véase :"
"issue:`33671`). \"copia rápida\" significa que la operación de copia ocurre "
"dentro del núcleo, evitando el uso de búferes en espacio de usuario en "
"Python como en \"``outfd.write(infd.read())``\"."

#: ../Doc/library/shutil.rst:498
msgid "On macOS `fcopyfile`_ is used to copy the file content (not metadata)."
msgstr ""
"En macOS, se usa `fcopyfile`_ para copiar el contenido del archivo (pero no "
"los metadatos)."

#: ../Doc/library/shutil.rst:500
msgid "On Linux :func:`os.sendfile` is used."
msgstr "En Linux, se usa :func:`os.sendfile`."

#: ../Doc/library/shutil.rst:502
msgid ""
"On Windows :func:`shutil.copyfile` uses a bigger default buffer size (1 MiB "
"instead of 64 KiB) and a :func:`memoryview`-based variant of :func:`shutil."
"copyfileobj` is used."
msgstr ""
"En Windows, :func:`shutil.copyfile` usa un tamaño de búfer predeterminado "
"más grande (1 MiB en lugar de 64 KiB) y se usa una variante de :func:`shutil."
"copyfileobj` basada en :func:`memoryview`."

#: ../Doc/library/shutil.rst:506
msgid ""
"If the fast-copy operation fails and no data was written in the destination "
"file then shutil will silently fallback on using less efficient :func:"
"`copyfileobj` function internally."
msgstr ""
"Si ocurre un error en la operación de copia rápida y no se ha escrito ningún "
"dato en el archivo de destino, entonces shutil recurrirá silenciosamente a "
"usar la función :func:`copyfileobj` menos eficiente internamente."

#: ../Doc/library/shutil.rst:515
msgid "copytree example"
msgstr "ejemplo de *copytree*"

#: ../Doc/library/shutil.rst:517
msgid "An example that uses the :func:`ignore_patterns` helper::"
msgstr "Un ejemplo que usa el auxiliar :func:`ignore_patterns`::"

#: ../Doc/library/shutil.rst:523
msgid ""
"This will copy everything except ``.pyc`` files and files or directories "
"whose name starts with ``tmp``."
msgstr ""
"Esto copiará todo excepto archivos ``.pyc`` y archivos o directorios cuyo "
"nombre comience con ``tmp``."

#: ../Doc/library/shutil.rst:526
msgid "Another example that uses the *ignore* argument to add a logging call::"
msgstr ""
"Otro ejemplo que usa el argumento *ignore* para agregar una llamada a "
"iniciar sesión::"

#: ../Doc/library/shutil.rst:541
msgid "rmtree example"
msgstr "ejemplo de rmtree"

#: ../Doc/library/shutil.rst:543
#, fuzzy
msgid ""
"This example shows how to remove a directory tree on Windows where some of "
"the files have their read-only bit set. It uses the onexc callback to clear "
"the readonly bit and reattempt the remove. Any subsequent failure will "
"propagate. ::"
msgstr ""
"Este ejemplo muestra como eliminar un árbol de directorio en Windows donde "
"algunos de los archivos tienen configurado su *bit* de sólo lectura. Usa la "
"*onerror callback* para limpiar el *bit* de sólo lectura y reintentar "
"eliminarlo. Cualquier fallo que le siga, se propagará. ::"

#: ../Doc/library/shutil.rst:561
msgid "Archiving operations"
msgstr "Operaciones de archivado"

#: ../Doc/library/shutil.rst:565
msgid "Added support for the *xztar* format."
msgstr "Se agregó soporte para el formato *xztar*."

#: ../Doc/library/shutil.rst:569
msgid ""
"High-level utilities to create and read compressed and archived files are "
"also provided.  They rely on the :mod:`zipfile` and :mod:`tarfile` modules."
msgstr ""
"Se proveen también las utilidades de alto nivel para crear y leer archivos "
"comprimidos y archivados. Utilizan para esto los módulos :mod:`zipfile` y :"
"mod:`tarfile`."

#: ../Doc/library/shutil.rst:574
msgid "Create an archive file (such as zip or tar) and return its name."
msgstr "Crea un documento de archivado (como zip o tar) y retorna su nombre."

#: ../Doc/library/shutil.rst:576
msgid ""
"*base_name* is the name of the file to create, including the path, minus any "
"format-specific extension. *format* is the archive format: one of "
"\"zip\" (if the :mod:`zlib` module is available), \"tar\", \"gztar\" (if "
"the :mod:`zlib` module is available), \"bztar\" (if the :mod:`bz2` module is "
"available), or \"xztar\" (if the :mod:`lzma` module is available)."
msgstr ""
"*base_name* es el nombre del archivo a crear, incluyendo la ruta, menos "
"cualquier extensión que sea específica de formato. *format* es el formato de "
"archivo: uno de *zip* (si el módulo :mod:`zlib` está disponible), \"tar\", "
"\"gztar\" (si el módulo :mod:`zlib` está disponible), \"bztar\" (si el "
"módulo :mod:`bz2` está disponible), o \"xztar\" (si el módulo :mod:`lzma`)."

#: ../Doc/library/shutil.rst:582
msgid ""
"*root_dir* is a directory that will be the root directory of the archive, "
"all paths in the archive will be relative to it; for example, we typically "
"chdir into *root_dir* before creating the archive."
msgstr ""
"*root_dir* es un directorio que será el directorio raíz del archivo, todas "
"las rutas en el archivo serán relativas a él; por ejemplo, típicamente nos "
"cambiaremos de directorio (*chdir*) a *root_dir* antes de crear el archivo."

#: ../Doc/library/shutil.rst:586
msgid ""
"*base_dir* is the directory where we start archiving from; i.e. *base_dir* "
"will be the common prefix of all files and directories in the archive.  "
"*base_dir* must be given relative to *root_dir*.  See :ref:`shutil-archiving-"
"example-with-basedir` for how to use *base_dir* and *root_dir* together."
msgstr ""
"*base_dir* es el directorio desde donde iniciamos el archivado; i.e, "
"*base_dir* será el prefijo común para todos los archivos y directorios en el "
"archivo. *base_dir* debe ser dado de forma relativa a *root_dir*. En :ref:"
"`shutil-archiving-example-with-basedir` se ve un ejemplo de cómo usar "
"*base_dir* y *root_dir* juntos."

#: ../Doc/library/shutil.rst:592
msgid "*root_dir* and *base_dir* both default to the current directory."
msgstr "*root_dir* y *base_dir* irán por defecto al directorio actual."

#: ../Doc/library/shutil.rst:594
msgid ""
"If *dry_run* is true, no archive is created, but the operations that would "
"be executed are logged to *logger*."
msgstr ""
"If *dry_run* es verdadero, no se crea un archivo, pero las operaciones que "
"se ejecutarán están registradas en *logger*."

#: ../Doc/library/shutil.rst:597
msgid ""
"*owner* and *group* are used when creating a tar archive. By default, uses "
"the current owner and group."
msgstr ""
"*owner* y *group* se usan al crear un archivador tar. Por defecto, usa el "
"propietario y el grupo actual."

#: ../Doc/library/shutil.rst:600
msgid ""
"*logger* must be an object compatible with :pep:`282`, usually an instance "
"of :class:`logging.Logger`."
msgstr ""
"*logger* debe ser un objeto compatible con  :pep:`282`, usualmente una "
"instancia de :class:`logging.Logger`."

#: ../Doc/library/shutil.rst:603
msgid "The *verbose* argument is unused and deprecated."
msgstr "El argumento *verbose* está fuera de uso y es obsoleto."

#: ../Doc/library/shutil.rst:605
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.make_archive`` with "
"arguments ``base_name``, ``format``, ``root_dir``, ``base_dir``."
msgstr ""
"Genera un :ref:`evento de auditoría <auditing>` ``shutil.make_archive`` con "
"argumentos ``base_name``, ``format``, ``root_dir``, ``base_dir``."

#: ../Doc/library/shutil.rst:609
#, fuzzy
msgid ""
"This function is not thread-safe when custom archivers registered with :func:"
"`register_archive_format` do not support the *root_dir* argument.  In this "
"case it temporarily changes the current working directory of the process to "
"*root_dir* to perform archiving."
msgstr ""
"Esta función no es segura para hilos cuando son usados archivos "
"personalizados registrados con :func:`register_archive_format`. En este caso "
"temporalmente cambia el directorio de trabajo actual del proceso para "
"realizar el archivado."

#: ../Doc/library/shutil.rst:615
msgid ""
"The modern pax (POSIX.1-2001) format is now used instead of the legacy GNU "
"format for archives created with ``format=\"tar\"``."
msgstr ""
"El formato de *pax* moderno (POSIX.1-2001) se usa ahora en lugar del formato "
"de legado GNU para archivadores creados con ``format=\"tar\"``."

#: ../Doc/library/shutil.rst:619
msgid ""
"This function is now made thread-safe during creation of standard ``.zip`` "
"and tar archives."
msgstr ""
"Esta función ahora es segura para hilos durante la creación de archivos "
"estándar ``.zip`` y tar."

#: ../Doc/library/shutil.rst:625
msgid ""
"Return a list of supported formats for archiving. Each element of the "
"returned sequence is a tuple ``(name, description)``."
msgstr ""
"Retorna una lista de formatos admitidos para archivado. Cada elemento de una "
"secuencia retornada es una tupla ``(name, description)``."

#: ../Doc/library/shutil.rst:628 ../Doc/library/shutil.rst:739
msgid "By default :mod:`shutil` provides these formats:"
msgstr "Por defecto, :mod:`shutil` provee los siguientes formatos:"

#: ../Doc/library/shutil.rst:630
msgid "*zip*: ZIP file (if the :mod:`zlib` module is available)."
msgstr "*zip*: archivo ZIP (si el módulo :mod:`zlib` está disponible)."

#: ../Doc/library/shutil.rst:631
msgid ""
"*tar*: Uncompressed tar file. Uses POSIX.1-2001 pax format for new archives."
msgstr ""
"*tar*: archivo tar sin comprimir. Utiliza el formato pax POSIX.1-2001 para "
"archivos nuevos."

#: ../Doc/library/shutil.rst:632 ../Doc/library/shutil.rst:744
msgid "*gztar*: gzip'ed tar-file (if the :mod:`zlib` module is available)."
msgstr ""
"*gztar*: archivo tar comprimido con gzip (si el módulo :mod:`zlib` está "
"disponible)."

#: ../Doc/library/shutil.rst:633 ../Doc/library/shutil.rst:745
msgid "*bztar*: bzip2'ed tar-file (if the :mod:`bz2` module is available)."
msgstr ""
"*bztar*: archivo tar comprimido con bzip2 (si el módulo :mod:`bz2` está "
"disponible)."

#: ../Doc/library/shutil.rst:634 ../Doc/library/shutil.rst:746
msgid "*xztar*: xz'ed tar-file (if the :mod:`lzma` module is available)."
msgstr ""
"*xztar*: archivo tar comprimido con xz (si el módulo :mod:`lzma` está "
"disponible)."

#: ../Doc/library/shutil.rst:636
msgid ""
"You can register new formats or provide your own archiver for any existing "
"formats, by using :func:`register_archive_format`."
msgstr ""
"Puedes registrar formatos nuevos o proporcionar tu propio archivador para "
"cualquier formato existente, usando :func:`register_archive_format`."

#: ../Doc/library/shutil.rst:642
msgid "Register an archiver for the format *name*."
msgstr "Registra un archivador para el formato *name*."

#: ../Doc/library/shutil.rst:644
msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive the *base_name* of the file to create, followed by the "
"*base_dir* (which defaults to :data:`os.curdir`) to start archiving from. "
"Further arguments are passed as keyword arguments: *owner*, *group*, "
"*dry_run* and *logger* (as passed in :func:`make_archive`)."
msgstr ""
"*function* es el invocable que se usará para desempacar archivos. El "
"invocable recibirá el *base_name* del archivo para crearlo, seguido por "
"*base_dir* (que cae por defecto en :data:`os.curdir`) para comenzar a "
"archivar desde allí. Otros argumentos se pasan como argumentos de palabras "
"clave: *owner*, *group*, *dry_run* y *logger* (como se pasa en :func:"
"`make_archive`)."

#: ../Doc/library/shutil.rst:650
msgid ""
"If *function* has the custom attribute ``function.supports_root_dir`` set to "
"``True``, the *root_dir* argument is passed as a keyword argument. Otherwise "
"the current working directory of the process is temporarily changed to "
"*root_dir* before calling *function*. In this case :func:`make_archive` is "
"not thread-safe."
msgstr ""

#: ../Doc/library/shutil.rst:656
msgid ""
"If given, *extra_args* is a sequence of ``(name, value)`` pairs that will be "
"used as extra keywords arguments when the archiver callable is used."
msgstr ""
"Si está dado, *extra_args* es una secuencia de pares ``(name, value)``  que "
"se usarán como argumentos de palabras clave extra cuando se usa el "
"archivador invocable."

#: ../Doc/library/shutil.rst:659
msgid ""
"*description* is used by :func:`get_archive_formats` which returns the list "
"of archivers.  Defaults to an empty string."
msgstr ""
"*description* se usa por :func:`get_archive_formats` que retorna la lista de "
"archivadores. Cae por defecto en una cadena de caracteres vacía."

#: ../Doc/library/shutil.rst:662
#, fuzzy
msgid "Added support for functions supporting the *root_dir* argument."
msgstr "Se agregó soporte para el formato *xztar*."

#: ../Doc/library/shutil.rst:668
msgid "Remove the archive format *name* from the list of supported formats."
msgstr ""
"Elimina el formato de archivo *name* de la lista de formatos admitidos."

#: ../Doc/library/shutil.rst:673
msgid "Unpack an archive. *filename* is the full path of the archive."
msgstr "Desempaqueta un archivo. *filename* es la ruta completa del archivo."

#: ../Doc/library/shutil.rst:675
msgid ""
"*extract_dir* is the name of the target directory where the archive is "
"unpacked. If not provided, the current working directory is used."
msgstr ""
"*extract_dir* es el nombre del directorio donde se desempaca el archivo. Si "
"no está provisto, se usa el nombre del directorio actual."

#: ../Doc/library/shutil.rst:678
msgid ""
"*format* is the archive format: one of \"zip\", \"tar\", \"gztar\", "
"\"bztar\", or \"xztar\".  Or any other format registered with :func:"
"`register_unpack_format`.  If not provided, :func:`unpack_archive` will use "
"the archive file name extension and see if an unpacker was registered for "
"that extension.  In case none is found, a :exc:`ValueError` is raised."
msgstr ""
"*format* es el formato de archivo: uno de \"zip\", \"tar\", \"gztar\", "
"\"bztar\", or \"xztar\". O cualquier otra formato registrado con :func:"
"`register_unpack_format`. Si no está provisto, :func:`unpack_archive` usará "
"la extensión de archivo del archivador y verá si se registró un desempacador "
"para esa extensión. En caso de que no se encuentre ninguno, se genera un :"
"exc:`ValueError`."

#: ../Doc/library/shutil.rst:685
msgid ""
"The keyword-only *filter* argument is passed to the underlying unpacking "
"function. For zip files, *filter* is not accepted. For tar files, it is "
"recommended to set it to ``'data'``, unless using features specific to tar "
"and UNIX-like filesystems. (See :ref:`tarfile-extraction-filter` for "
"details.) The ``'data'`` filter will become the default for tar files in "
"Python 3.14."
msgstr ""

#: ../Doc/library/shutil.rst:693
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.unpack_archive`` with "
"arguments ``filename``, ``extract_dir``, ``format``."
msgstr ""
"Se genera un :ref:`evento de auditoría <auditing>` ``shutil.unpack_archive`` "
"con argumentos ``filename``, ``extract_dir``, ``format``."

#: ../Doc/library/shutil.rst:697
msgid ""
"Never extract archives from untrusted sources without prior inspection. It "
"is possible that files are created outside of the path specified in the "
"*extract_dir* argument, e.g. members that have absolute filenames starting "
"with \"/\" or filenames with two dots \"..\"."
msgstr ""
"Nunca extraiga archivos de fuentes no confiables sin una inspección previa. "
"Es posible que los archivos sean creados fuera de la ruta especificada en el "
"argumento *extract_dir*, p.e. miembros que tienen nombres de archivo "
"absolutos comenzando con \\\"/\\\" or nombres de archivos con dos puntos \\"
"\"..\\\"."

#: ../Doc/library/shutil.rst:702
msgid "Accepts a :term:`path-like object` for *filename* and *extract_dir*."
msgstr "Acepta un :term:`path-like object` como *filename* y *extract_dir*."

#: ../Doc/library/shutil.rst:705
#, fuzzy
msgid "Added the *filter* argument."
msgstr "Se agregó el argumento de keyword *copy_function*."

#: ../Doc/library/shutil.rst:710
msgid ""
"Registers an unpack format. *name* is the name of the format and "
"*extensions* is a list of extensions corresponding to the format, like ``."
"zip`` for Zip files."
msgstr ""
"Registra un formato de desempaque. *name* es el nombre del formato y "
"*extensions* es una lista de extensiones que corresponden al formato, como "
"``.zip`` para archivos zip."

#: ../Doc/library/shutil.rst:714
#, fuzzy
msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive:"
msgstr ""
"*function* es el invocable que se usará para desempacar archivadores. El "
"invocable recibirá la ruta del archivador, seguida del directorio al que el "
"archivador debe extraerse."

#: ../Doc/library/shutil.rst:717
msgid "the path of the archive, as a positional argument;"
msgstr ""

#: ../Doc/library/shutil.rst:718
msgid ""
"the directory the archive must be extracted to, as a positional argument;"
msgstr ""

#: ../Doc/library/shutil.rst:719
msgid ""
"possibly a *filter* keyword argument, if it was given to :func:"
"`unpack_archive`;"
msgstr ""

#: ../Doc/library/shutil.rst:721
msgid ""
"additional keyword arguments, specified by *extra_args* as a sequence of "
"``(name, value)`` tuples."
msgstr ""

#: ../Doc/library/shutil.rst:724
msgid ""
"*description* can be provided to describe the format, and will be returned "
"by the :func:`get_unpack_formats` function."
msgstr ""
"*description* se puede proporcionar para describir el formato y será "
"retornado por la función :func:`get_unpack_formats`."

#: ../Doc/library/shutil.rst:730
msgid "Unregister an unpack format. *name* is the name of the format."
msgstr ""
"Anula el registro del formato de desempaque. *name* es el nombre del formato."

#: ../Doc/library/shutil.rst:735
msgid ""
"Return a list of all registered formats for unpacking. Each element of the "
"returned sequence is a tuple ``(name, extensions, description)``."
msgstr ""
"Retorna una lista de todos los formatos registrados para desempaquetar. Cada "
"elemento de la secuencia es una tupla ``(name, extensions, description)``."

#: ../Doc/library/shutil.rst:741
msgid ""
"*zip*: ZIP file (unpacking compressed files works only if the corresponding "
"module is available)."
msgstr ""
"*zip*: archivo zip (desempaquetar archivos comprimidos funciona solo si el "
"módulo correspondiente está disponible)."

#: ../Doc/library/shutil.rst:743
msgid "*tar*: uncompressed tar file."
msgstr "*tar*: archivo tar sin comprimir."

#: ../Doc/library/shutil.rst:748
msgid ""
"You can register new formats or provide your own unpacker for any existing "
"formats, by using :func:`register_unpack_format`."
msgstr ""
"Puedes registrar formatos nuevos o proporcionar tu propio desempaquetado "
"para cualquier formato existente, usando :func:`register_unpack_format`."

#: ../Doc/library/shutil.rst:755
msgid "Archiving example"
msgstr "Ejemplo de archivado"

#: ../Doc/library/shutil.rst:757
msgid ""
"In this example, we create a gzip'ed tar-file archive containing all files "
"found in the :file:`.ssh` directory of the user::"
msgstr ""
"En este ejemplo, creamos un archivo tar de tipo gzip que contiene todos los "
"archivos que se encuentran en el directorio :file:`.ssh` del usuario::"

#: ../Doc/library/shutil.rst:767
msgid "The resulting archive contains:"
msgstr "El archivo resultante contiene:"

#: ../Doc/library/shutil.rst:785
msgid "Archiving example with *base_dir*"
msgstr "Ejemplo de archivado con *base_dir*"

#: ../Doc/library/shutil.rst:787
msgid ""
"In this example, similar to the `one above <shutil-archiving-example_>`_, we "
"show how to use :func:`make_archive`, but this time with the usage of "
"*base_dir*.  We now have the following directory structure:"
msgstr ""
"En este ejemplo, similar al `de arriba <shutil-archiving-example_>`_, "
"mostramos cómo usar :func:`make_archive`, pero esta vez utilizando "
"*base_dir*.  Ahora tenemos la siguiente estructura de directorios:"

#: ../Doc/library/shutil.rst:801
msgid ""
"In the final archive, :file:`please_add.txt` should be included, but :file:"
"`do_not_add.txt` should not.  Therefore we use the following::"
msgstr ""
"En el archivo final, :file:`please_add.txt` debería estar incluido, pero :"
"file:`do_not_add.txt` no.  Por lo tanto usamos lo siguiente::"

#: ../Doc/library/shutil.rst:815
msgid "Listing the files in the resulting archive gives us:"
msgstr "Listando los archivos en el archivo resultante nos da:"

#: ../Doc/library/shutil.rst:825
msgid "Querying the size of the output terminal"
msgstr "Consulta el tamaño de la terminal de salida"

#: ../Doc/library/shutil.rst:829
msgid "Get the size of the terminal window."
msgstr "Obtén el tamaño de la ventana de la terminal."

#: ../Doc/library/shutil.rst:831
msgid ""
"For each of the two dimensions, the environment variable, ``COLUMNS`` and "
"``LINES`` respectively, is checked. If the variable is defined and the value "
"is a positive integer, it is used."
msgstr ""
"Para cada una de las dos dimensiones, se comprueba la variable de entorno "
"``COLUMNS`` y ``LINES`` respectivamente. Si la variable está definida y el "
"valor es un entero positivo, se utiliza."

#: ../Doc/library/shutil.rst:835
msgid ""
"When ``COLUMNS`` or ``LINES`` is not defined, which is the common case, the "
"terminal connected to :data:`sys.__stdout__` is queried by invoking :func:"
"`os.get_terminal_size`."
msgstr ""
"Cuando ``COLUMNS`` o ``LINES`` no está definido, como suele ocurrir, la "
"terminal conectada a :data:`sys.__stdout__` se consulta invocando :func:`os."
"get_terminal_size`."

#: ../Doc/library/shutil.rst:839
msgid ""
"If the terminal size cannot be successfully queried, either because the "
"system doesn't support querying, or because we are not connected to a "
"terminal, the value given in ``fallback`` parameter is used. ``fallback`` "
"defaults to ``(80, 24)`` which is the default size used by many terminal "
"emulators."
msgstr ""
"Si el tamaño de la terminal no se puede consultar correctamente, ya sea "
"porque el sistema no admite consultas o porque no estamos conectados a una "
"terminal, se usa el valor dado en el parámetro ``fallback``. ``fallback`` "
"tiene por defecto ``(80, 24)``, que es el tamaño por defecto que se usa en "
"muchos emuladores de terminal."

#: ../Doc/library/shutil.rst:845
msgid "The value returned is a named tuple of type :class:`os.terminal_size`."
msgstr ""
"El valor retornado es una tupla con su respectivo nombre, de tipo :class:`os."
"terminal_size`."

#: ../Doc/library/shutil.rst:847
msgid ""
"See also: The Single UNIX Specification, Version 2, `Other Environment "
"Variables`_."
msgstr ""
"Ver también: *The Single UNIX Specification*, Versión 2, `Other Environment "
"Variables`_."

#: ../Doc/library/shutil.rst:852
msgid ""
"The ``fallback`` values are also used if :func:`os.get_terminal_size` "
"returns zeroes."
msgstr ""
"Los valores ``fallback`` son usados también si :func:`os.get_terminal_size` "
"devuelve zeros."

#: ../Doc/library/shutil.rst:12
msgid "file"
msgstr ""

#: ../Doc/library/shutil.rst:12
msgid "copying"
msgstr ""

#: ../Doc/library/shutil.rst:12
msgid "copying files"
msgstr ""

#: ../Doc/library/shutil.rst:297
msgid "directory"
msgstr ""

#: ../Doc/library/shutil.rst:297
msgid "deleting"
msgstr ""

#~ msgid ""
#~ "On Windows, the current directory is always prepended to the *path* "
#~ "whether or not you use the default or provide your own, which is the "
#~ "behavior the command shell uses when finding executables.  Additionally, "
#~ "when finding the *cmd* in the *path*, the ``PATHEXT`` environment "
#~ "variable is checked.  For example, if you call ``shutil."
#~ "which(\"python\")``, :func:`which` will search ``PATHEXT`` to know that "
#~ "it should look for ``python.exe`` within the *path* directories.  For "
#~ "example, on Windows::"
#~ msgstr ""
#~ "En Windows, el directorio actual siempre se antepone a *path*, "
#~ "independientemente de si usa el valor predeterminado o si tú provees el "
#~ "tuyo propio, que es el comportamiento que el comando *shell* usa cuando "
#~ "encuentra ejecutables. Además, al encontrar el *cmd* en el *path*, se "
#~ "comprueba la variable de entorno ``PATHEXT``. Por ejemplo, si invocas "
#~ "``shutil.which(\"python\")``, :func:`which` buscará ``PATHEXT`` para "
#~ "saber si debe buscar ``python.exe`` dentro de los directorios *path*. Por "
#~ "ejemplo, en Windows::"

#~ msgid ""
#~ "When provided, *extra_args* is a sequence of ``(name, value)`` tuples "
#~ "that will be passed as keywords arguments to the callable."
#~ msgstr ""
#~ "Cuando está dado, *extra_args* es una secuencia de tuplas ``(name, "
#~ "value)`` que se pasarán como argumentos de palabra clave al invocable."
