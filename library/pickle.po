
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-05 12:54+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../Doc/library/pickle.rst:2
msgid ":mod:`pickle` --- Python object serialization"
msgstr ""

#: ../Doc/library/pickle.rst:10
msgid "**Source code:** :source:`Lib/pickle.py`"
msgstr ""

#: ../Doc/library/pickle.rst:22
msgid ""
"The :mod:`pickle` module implements binary protocols for serializing and de-"
"serializing a Python object structure.  *\"Pickling\"* is the process "
"whereby a Python object hierarchy is converted into a byte stream, and *"
"\"unpickling\"* is the inverse operation, whereby a byte stream (from a :"
"term:`binary file` or :term:`bytes-like object`) is converted back into an "
"object hierarchy.  Pickling (and unpickling) is alternatively known as "
"\"serialization\", \"marshalling,\" [#]_ or \"flattening\"; however, to "
"avoid confusion, the terms used here are \"pickling\" and \"unpickling\"."
msgstr ""

#: ../Doc/library/pickle.rst:33
msgid "The ``pickle`` module **is not secure**. Only unpickle data you trust."
msgstr ""

#: ../Doc/library/pickle.rst:35
msgid ""
"It is possible to construct malicious pickle data which will **execute "
"arbitrary code during unpickling**. Never unpickle data that could have come "
"from an untrusted source, or that could have been tampered with."
msgstr ""

#: ../Doc/library/pickle.rst:39
msgid ""
"Consider signing data with :mod:`hmac` if you need to ensure that it has not "
"been tampered with."
msgstr ""

#: ../Doc/library/pickle.rst:42
msgid ""
"Safer serialization formats such as :mod:`json` may be more appropriate if "
"you are processing untrusted data. See :ref:`comparison-with-json`."
msgstr ""

#: ../Doc/library/pickle.rst:47
msgid "Relationship to other Python modules"
msgstr ""

#: ../Doc/library/pickle.rst:50
msgid "Comparison with ``marshal``"
msgstr ""

#: ../Doc/library/pickle.rst:52
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, but "
"in general :mod:`pickle` should always be the preferred way to serialize "
"Python objects.  :mod:`marshal` exists primarily to support Python's :file:`."
"pyc` files."
msgstr ""

#: ../Doc/library/pickle.rst:57
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several significant "
"ways:"
msgstr ""

#: ../Doc/library/pickle.rst:59
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be serialized "
"again. :mod:`marshal` doesn't do this."
msgstr ""

#: ../Doc/library/pickle.rst:63
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  These "
"are not handled by marshal, and in fact, attempting to marshal recursive "
"objects will crash your Python interpreter.  Object sharing happens when "
"there are multiple references to the same object in different places in the "
"object hierarchy being serialized.  :mod:`pickle` stores such objects only "
"once, and ensures that all other references point to the master copy.  "
"Shared objects remain shared, which can be very important for mutable "
"objects."
msgstr ""

#: ../Doc/library/pickle.rst:72
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their "
"instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live in "
"the same module as when the object was stored."
msgstr ""

#: ../Doc/library/pickle.rst:77
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support :file:"
"`.pyc` files, the Python implementers reserve the right to change the "
"serialization format in non-backwards compatible ways should the need arise. "
"The :mod:`pickle` serialization format is guaranteed to be backwards "
"compatible across Python releases provided a compatible pickle protocol is "
"chosen and pickling and unpickling code deals with Python 2 to Python 3 type "
"differences if your data is crossing that unique breaking change language "
"boundary."
msgstr ""

#: ../Doc/library/pickle.rst:90
msgid "Comparison with ``json``"
msgstr ""

#: ../Doc/library/pickle.rst:92
msgid ""
"There are fundamental differences between the pickle protocols and `JSON "
"(JavaScript Object Notation) <http://json.org>`_:"
msgstr ""

#: ../Doc/library/pickle.rst:95
msgid ""
"JSON is a text serialization format (it outputs unicode text, although most "
"of the time it is then encoded to ``utf-8``), while pickle is a binary "
"serialization format;"
msgstr ""

#: ../Doc/library/pickle.rst:99
msgid "JSON is human-readable, while pickle is not;"
msgstr ""

#: ../Doc/library/pickle.rst:101
msgid ""
"JSON is interoperable and widely used outside of the Python ecosystem, while "
"pickle is Python-specific;"
msgstr ""

#: ../Doc/library/pickle.rst:104
msgid ""
"JSON, by default, can only represent a subset of the Python built-in types, "
"and no custom classes; pickle can represent an extremely large number of "
"Python types (many of them automatically, by clever usage of Python's "
"introspection facilities; complex cases can be tackled by implementing :ref:"
"`specific object APIs <pickle-inst>`);"
msgstr ""

#: ../Doc/library/pickle.rst:110
msgid ""
"Unlike pickle, deserializing untrusted JSON does not in itself create an "
"arbitrary code execution vulnerability."
msgstr ""

#: ../Doc/library/pickle.rst:114
msgid ""
"The :mod:`json` module: a standard library module allowing JSON "
"serialization and deserialization."
msgstr ""

#: ../Doc/library/pickle.rst:121
msgid "Data stream format"
msgstr ""

#: ../Doc/library/pickle.rst:126
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards such "
"as JSON or XDR (which can't represent pointer sharing); however it means "
"that non-Python programs may not be able to reconstruct pickled Python "
"objects."
msgstr ""

#: ../Doc/library/pickle.rst:131
msgid ""
"By default, the :mod:`pickle` data format uses a relatively compact binary "
"representation.  If you need optimal size characteristics, you can "
"efficiently :doc:`compress <archiving>` pickled data."
msgstr ""

#: ../Doc/library/pickle.rst:135
msgid ""
"The module :mod:`pickletools` contains tools for analyzing data streams "
"generated by :mod:`pickle`.  :mod:`pickletools` source code has extensive "
"comments about opcodes used by pickle protocols."
msgstr ""

#: ../Doc/library/pickle.rst:139
msgid ""
"There are currently 6 different protocols which can be used for pickling. "
"The higher the protocol used, the more recent the version of Python needed "
"to read the pickle produced."
msgstr ""

#: ../Doc/library/pickle.rst:143
msgid ""
"Protocol version 0 is the original \"human-readable\" protocol and is "
"backwards compatible with earlier versions of Python."
msgstr ""

#: ../Doc/library/pickle.rst:146
msgid ""
"Protocol version 1 is an old binary format which is also compatible with "
"earlier versions of Python."
msgstr ""

#: ../Doc/library/pickle.rst:149
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style class`\\es.  Refer to :pep:`307` for "
"information about improvements brought by protocol 2."
msgstr ""

#: ../Doc/library/pickle.rst:153
msgid ""
"Protocol version 3 was added in Python 3.0.  It has explicit support for :"
"class:`bytes` objects and cannot be unpickled by Python 2.x.  This was the "
"default protocol in Python 3.0--3.7."
msgstr ""

#: ../Doc/library/pickle.rst:157
msgid ""
"Protocol version 4 was added in Python 3.4.  It adds support for very large "
"objects, pickling more kinds of objects, and some data format "
"optimizations.  It is the default protocol starting with Python 3.8. Refer "
"to :pep:`3154` for information about improvements brought by protocol 4."
msgstr ""

#: ../Doc/library/pickle.rst:163
msgid ""
"Protocol version 5 was added in Python 3.8.  It adds support for out-of-band "
"data and speedup for in-band data.  Refer to :pep:`574` for information "
"about improvements brought by protocol 5."
msgstr ""

#: ../Doc/library/pickle.rst:168
msgid ""
"Serialization is a more primitive notion than persistence; although :mod:"
"`pickle` reads and writes file objects, it does not handle the issue of "
"naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the byte "
"stream into an object with the same internal structure.  Perhaps the most "
"obvious thing to do with these byte streams is to write them onto a file, "
"but it is also conceivable to send them across a network or store them in a "
"database.  The :mod:`shelve` module provides a simple interface to pickle "
"and unpickle objects on DBM-style database files."
msgstr ""

#: ../Doc/library/pickle.rst:181
msgid "Module Interface"
msgstr ""

#: ../Doc/library/pickle.rst:183
msgid ""
"To serialize an object hierarchy, you simply call the :func:`dumps` "
"function. Similarly, to de-serialize a data stream, you call the :func:"
"`loads` function. However, if you want more control over serialization and "
"de-serialization, you can create a :class:`Pickler` or an :class:`Unpickler` "
"object, respectively."
msgstr ""

#: ../Doc/library/pickle.rst:188
msgid "The :mod:`pickle` module provides the following constants:"
msgstr ""

#: ../Doc/library/pickle.rst:193
msgid ""
"An integer, the highest :ref:`protocol version <pickle-protocols>` "
"available.  This value can be passed as a *protocol* value to functions :"
"func:`dump` and :func:`dumps` as well as the :class:`Pickler` constructor."
msgstr ""

#: ../Doc/library/pickle.rst:200
msgid ""
"An integer, the default :ref:`protocol version <pickle-protocols>` used for "
"pickling.  May be less than :data:`HIGHEST_PROTOCOL`.  Currently the default "
"protocol is 4, first introduced in Python 3.4 and incompatible with previous "
"versions."
msgstr ""

#: ../Doc/library/pickle.rst:207
msgid "The default protocol is 3."
msgstr ""

#: ../Doc/library/pickle.rst:211
msgid "The default protocol is 4."
msgstr ""

#: ../Doc/library/pickle.rst:213
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr ""

#: ../Doc/library/pickle.rst:218
msgid ""
"Write the pickled representation of the object *obj* to the open :term:`file "
"object` *file*.  This is equivalent to ``Pickler(file, protocol).dump(obj)``."
msgstr ""

#: ../Doc/library/pickle.rst:222
msgid ""
"Arguments *file*, *protocol*, *fix_imports* and *buffer_callback* have the "
"same meaning as in the :class:`Pickler` constructor."
msgstr ""

#: ../Doc/library/pickle.rst:225 ../Doc/library/pickle.rst:236
#: ../Doc/library/pickle.rst:328
msgid "The *buffer_callback* argument was added."
msgstr ""

#: ../Doc/library/pickle.rst:230
msgid ""
"Return the pickled representation of the object *obj* as a :class:`bytes` "
"object, instead of writing it to a file."
msgstr ""

#: ../Doc/library/pickle.rst:233
msgid ""
"Arguments *protocol*, *fix_imports* and *buffer_callback* have the same "
"meaning as in the :class:`Pickler` constructor."
msgstr ""

#: ../Doc/library/pickle.rst:241
msgid ""
"Read the pickled representation of an object from the open :term:`file "
"object` *file* and return the reconstituted object hierarchy specified "
"therein. This is equivalent to ``Unpickler(file).load()``."
msgstr ""

#: ../Doc/library/pickle.rst:245 ../Doc/library/pickle.rst:260
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed.  Bytes past the pickled representation of the object are "
"ignored."
msgstr ""

#: ../Doc/library/pickle.rst:249 ../Doc/library/pickle.rst:264
msgid ""
"Arguments *file*, *fix_imports*, *encoding*, *errors*, *strict* and "
"*buffers* have the same meaning as in the :class:`Unpickler` constructor."
msgstr ""

#: ../Doc/library/pickle.rst:252 ../Doc/library/pickle.rst:267
#: ../Doc/library/pickle.rst:429
msgid "The *buffers* argument was added."
msgstr ""

#: ../Doc/library/pickle.rst:257
msgid ""
"Return the reconstituted object hierarchy of the pickled representation "
"*data* of an object. *data* must be a :term:`bytes-like object`."
msgstr ""

#: ../Doc/library/pickle.rst:271
msgid "The :mod:`pickle` module defines three exceptions:"
msgstr ""

#: ../Doc/library/pickle.rst:275
msgid ""
"Common base class for the other pickling exceptions.  It inherits :exc:"
"`Exception`."
msgstr ""

#: ../Doc/library/pickle.rst:280
msgid ""
"Error raised when an unpicklable object is encountered by :class:`Pickler`. "
"It inherits :exc:`PickleError`."
msgstr ""

#: ../Doc/library/pickle.rst:283
msgid ""
"Refer to :ref:`pickle-picklable` to learn what kinds of objects can be "
"pickled."
msgstr ""

#: ../Doc/library/pickle.rst:288
msgid ""
"Error raised when there is a problem unpickling an object, such as a data "
"corruption or a security violation.  It inherits :exc:`PickleError`."
msgstr ""

#: ../Doc/library/pickle.rst:291
msgid ""
"Note that other exceptions may also be raised during unpickling, including "
"(but not necessarily limited to) AttributeError, EOFError, ImportError, and "
"IndexError."
msgstr ""

#: ../Doc/library/pickle.rst:296
msgid ""
"The :mod:`pickle` module exports three classes, :class:`Pickler`, :class:"
"`Unpickler` and :class:`PickleBuffer`:"
msgstr ""

#: ../Doc/library/pickle.rst:301
msgid "This takes a binary file for writing a pickle data stream."
msgstr ""

#: ../Doc/library/pickle.rst:303
msgid ""
"The optional *protocol* argument, an integer, tells the pickler to use the "
"given protocol; supported protocols are 0 to :data:`HIGHEST_PROTOCOL`. If "
"not specified, the default is :data:`DEFAULT_PROTOCOL`.  If a negative "
"number is specified, :data:`HIGHEST_PROTOCOL` is selected."
msgstr ""

#: ../Doc/library/pickle.rst:308
msgid ""
"The *file* argument must have a write() method that accepts a single bytes "
"argument.  It can thus be an on-disk file opened for binary writing, an :"
"class:`io.BytesIO` instance, or any other custom object that meets this "
"interface."
msgstr ""

#: ../Doc/library/pickle.rst:313
msgid ""
"If *fix_imports* is true and *protocol* is less than 3, pickle will try to "
"map the new Python 3 names to the old module names used in Python 2, so that "
"the pickle data stream is readable with Python 2."
msgstr ""

#: ../Doc/library/pickle.rst:317
msgid ""
"If *buffer_callback* is None (the default), buffer views are serialized into "
"*file* as part of the pickle stream."
msgstr ""

#: ../Doc/library/pickle.rst:320
msgid ""
"If *buffer_callback* is not None, then it can be called any number of times "
"with a buffer view.  If the callback returns a false value (such as None), "
"the given buffer is :ref:`out-of-band <pickle-oob>`; otherwise the buffer is "
"serialized in-band, i.e. inside the pickle stream."
msgstr ""

#: ../Doc/library/pickle.rst:325
msgid ""
"It is an error if *buffer_callback* is not None and *protocol* is None or "
"smaller than 5."
msgstr ""

#: ../Doc/library/pickle.rst:333
msgid ""
"Write the pickled representation of *obj* to the open file object given in "
"the constructor."
msgstr ""

#: ../Doc/library/pickle.rst:338
msgid "Do nothing by default.  This exists so a subclass can override it."
msgstr ""

#: ../Doc/library/pickle.rst:340
msgid ""
"If :meth:`persistent_id` returns ``None``, *obj* is pickled as usual.  Any "
"other value causes :class:`Pickler` to emit the returned value as a "
"persistent ID for *obj*.  The meaning of this persistent ID should be "
"defined by :meth:`Unpickler.persistent_load`.  Note that the value returned "
"by :meth:`persistent_id` cannot itself have a persistent ID."
msgstr ""

#: ../Doc/library/pickle.rst:346 ../Doc/library/pickle.rst:447
msgid "See :ref:`pickle-persistent` for details and examples of uses."
msgstr ""

#: ../Doc/library/pickle.rst:350
msgid ""
"A pickler object's dispatch table is a registry of *reduction functions* of "
"the kind which can be declared using :func:`copyreg.pickle`.  It is a "
"mapping whose keys are classes and whose values are reduction functions.  A "
"reduction function takes a single argument of the associated class and "
"should conform to the same interface as a :meth:`__reduce__` method."
msgstr ""

#: ../Doc/library/pickle.rst:358
msgid ""
"By default, a pickler object will not have a :attr:`dispatch_table` "
"attribute, and it will instead use the global dispatch table managed by the :"
"mod:`copyreg` module. However, to customize the pickling for a specific "
"pickler object one can set the :attr:`dispatch_table` attribute to a dict-"
"like object.  Alternatively, if a subclass of :class:`Pickler` has a :attr:"
"`dispatch_table` attribute then this will be used as the default dispatch "
"table for instances of that class."
msgstr ""

#: ../Doc/library/pickle.rst:367
msgid "See :ref:`pickle-dispatch` for usage examples."
msgstr ""

#: ../Doc/library/pickle.rst:373
msgid ""
"Special reducer that can be defined in :class:`Pickler` subclasses. This "
"method has priority over any reducer in the :attr:`dispatch_table`.  It "
"should conform to the same interface as a :meth:`__reduce__` method, and can "
"optionally return ``NotImplemented`` to fallback on :attr:`dispatch_table`-"
"registered reducers to pickle ``obj``."
msgstr ""

#: ../Doc/library/pickle.rst:379
msgid "For a detailed example, see :ref:`reducer_override`."
msgstr ""

#: ../Doc/library/pickle.rst:385
msgid ""
"Deprecated. Enable fast mode if set to a true value.  The fast mode disables "
"the usage of memo, therefore speeding the pickling process by not generating "
"superfluous PUT opcodes.  It should not be used with self-referential "
"objects, doing otherwise will cause :class:`Pickler` to recurse infinitely."
msgstr ""

#: ../Doc/library/pickle.rst:391
msgid "Use :func:`pickletools.optimize` if you need more compact pickles."
msgstr ""

#: ../Doc/library/pickle.rst:396
msgid "This takes a binary file for reading a pickle data stream."
msgstr ""

#: ../Doc/library/pickle.rst:398
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed."
msgstr ""

#: ../Doc/library/pickle.rst:401
msgid ""
"The argument *file* must have three methods, a read() method that takes an "
"integer argument, a readinto() method that takes a buffer argument and a "
"readline() method that requires no arguments, as in the :class:`io."
"BufferedIOBase` interface.  Thus *file* can be an on-disk file opened for "
"binary reading, an :class:`io.BytesIO` object, or any other custom object "
"that meets this interface."
msgstr ""

#: ../Doc/library/pickle.rst:408
msgid ""
"The optional arguments *fix_imports*, *encoding* and *errors* are used to "
"control compatibility support for pickle stream generated by Python 2. If "
"*fix_imports* is true, pickle will try to map the old Python 2 names to the "
"new names used in Python 3.  The *encoding* and *errors* tell pickle how to "
"decode 8-bit string instances pickled by Python 2; these default to 'ASCII' "
"and 'strict', respectively.  The *encoding* can be 'bytes' to read these 8-"
"bit string instances as bytes objects. Using ``encoding='latin1'`` is "
"required for unpickling NumPy arrays and instances of :class:`~datetime."
"datetime`, :class:`~datetime.date` and :class:`~datetime.time` pickled by "
"Python 2."
msgstr ""

#: ../Doc/library/pickle.rst:419
msgid ""
"If *buffers* is None (the default), then all data necessary for "
"deserialization must be contained in the pickle stream.  This means that the "
"*buffer_callback* argument was None when a :class:`Pickler` was instantiated "
"(or when :func:`dump` or :func:`dumps` was called)."
msgstr ""

#: ../Doc/library/pickle.rst:424
msgid ""
"If *buffers* is not None, it should be an iterable of buffer-enabled objects "
"that is consumed each time the pickle stream references an :ref:`out-of-band "
"<pickle-oob>` buffer view.  Such buffers have been given in order to the "
"*buffer_callback* of a Pickler object."
msgstr ""

#: ../Doc/library/pickle.rst:434
msgid ""
"Read the pickled representation of an object from the open file object given "
"in the constructor, and return the reconstituted object hierarchy specified "
"therein.  Bytes past the pickled representation of the object are ignored."
msgstr ""

#: ../Doc/library/pickle.rst:441
msgid "Raise an :exc:`UnpicklingError` by default."
msgstr ""

#: ../Doc/library/pickle.rst:443
msgid ""
"If defined, :meth:`persistent_load` should return the object specified by "
"the persistent ID *pid*.  If an invalid persistent ID is encountered, an :"
"exc:`UnpicklingError` should be raised."
msgstr ""

#: ../Doc/library/pickle.rst:451
msgid ""
"Import *module* if necessary and return the object called *name* from it, "
"where the *module* and *name* arguments are :class:`str` objects.  Note, "
"unlike its name suggests, :meth:`find_class` is also used for finding "
"functions."
msgstr ""

#: ../Doc/library/pickle.rst:456
msgid ""
"Subclasses may override this to gain control over what type of objects and "
"how they can be loaded, potentially reducing security risks. Refer to :ref:"
"`pickle-restrict` for details."
msgstr ""

#: ../Doc/library/pickle.rst:460
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pickle.find_class`` with "
"arguments ``module``, ``name``."
msgstr ""

#: ../Doc/library/pickle.rst:464
msgid ""
"A wrapper for a buffer representing picklable data.  *buffer* must be a :ref:"
"`buffer-providing <bufferobjects>` object, such as a :term:`bytes-like "
"object` or a N-dimensional array."
msgstr ""

#: ../Doc/library/pickle.rst:468
msgid ""
":class:`PickleBuffer` is itself a buffer provider, therefore it is possible "
"to pass it to other APIs expecting a buffer-providing object, such as :class:"
"`memoryview`."
msgstr ""

#: ../Doc/library/pickle.rst:472
msgid ""
":class:`PickleBuffer` objects can only be serialized using pickle protocol 5 "
"or higher.  They are eligible for :ref:`out-of-band serialization <pickle-"
"oob>`."
msgstr ""

#: ../Doc/library/pickle.rst:480
msgid ""
"Return a :class:`memoryview` of the memory area underlying this buffer. The "
"returned object is a one-dimensional, C-contiguous memoryview with format "
"``B`` (unsigned bytes).  :exc:`BufferError` is raised if the buffer is "
"neither C- nor Fortran-contiguous."
msgstr ""

#: ../Doc/library/pickle.rst:487
msgid "Release the underlying buffer exposed by the PickleBuffer object."
msgstr ""

#: ../Doc/library/pickle.rst:493
msgid "What can be pickled and unpickled?"
msgstr ""

#: ../Doc/library/pickle.rst:495
msgid "The following types can be pickled:"
msgstr ""

#: ../Doc/library/pickle.rst:497
msgid "``None``, ``True``, and ``False``"
msgstr ""

#: ../Doc/library/pickle.rst:499
msgid "integers, floating point numbers, complex numbers"
msgstr ""

#: ../Doc/library/pickle.rst:501
msgid "strings, bytes, bytearrays"
msgstr ""

#: ../Doc/library/pickle.rst:503
msgid "tuples, lists, sets, and dictionaries containing only picklable objects"
msgstr ""

#: ../Doc/library/pickle.rst:505
msgid ""
"functions defined at the top level of a module (using :keyword:`def`, not :"
"keyword:`lambda`)"
msgstr ""

#: ../Doc/library/pickle.rst:508
msgid "built-in functions defined at the top level of a module"
msgstr ""

#: ../Doc/library/pickle.rst:510
msgid "classes that are defined at the top level of a module"
msgstr ""

#: ../Doc/library/pickle.rst:512
msgid ""
"instances of such classes whose :attr:`~object.__dict__` or the result of "
"calling :meth:`__getstate__` is picklable  (see section :ref:`pickle-inst` "
"for details)."
msgstr ""

#: ../Doc/library/pickle.rst:516
msgid ""
"Attempts to pickle unpicklable objects will raise the :exc:`PicklingError` "
"exception; when this happens, an unspecified number of bytes may have "
"already been written to the underlying file.  Trying to pickle a highly "
"recursive data structure may exceed the maximum recursion depth, a :exc:"
"`RecursionError` will be raised in this case.  You can carefully raise this "
"limit with :func:`sys.setrecursionlimit`."
msgstr ""

#: ../Doc/library/pickle.rst:523
msgid ""
"Note that functions (built-in and user-defined) are pickled by \"fully "
"qualified\" name reference, not by value. [#]_  This means that only the "
"function name is pickled, along with the name of the module the function is "
"defined in.  Neither the function's code, nor any of its function attributes "
"are pickled.  Thus the defining module must be importable in the unpickling "
"environment, and the module must contain the named object, otherwise an "
"exception will be raised. [#]_"
msgstr ""

#: ../Doc/library/pickle.rst:530
msgid ""
"Similarly, classes are pickled by named reference, so the same restrictions "
"in the unpickling environment apply.  Note that none of the class's code or "
"data is pickled, so in the following example the class attribute ``attr`` is "
"not restored in the unpickling environment::"
msgstr ""

#: ../Doc/library/pickle.rst:540
msgid ""
"These restrictions are why picklable functions and classes must be defined "
"in the top level of a module."
msgstr ""

#: ../Doc/library/pickle.rst:543
msgid ""
"Similarly, when class instances are pickled, their class's code and data are "
"not pickled along with them.  Only the instance data are pickled.  This is "
"done on purpose, so you can fix bugs in a class or add methods to the class "
"and still load objects that were created with an earlier version of the "
"class.  If you plan to have long-lived objects that will see many versions "
"of a class, it may be worthwhile to put a version number in the objects so "
"that suitable conversions can be made by the class's :meth:`__setstate__` "
"method."
msgstr ""

#: ../Doc/library/pickle.rst:555
msgid "Pickling Class Instances"
msgstr ""

#: ../Doc/library/pickle.rst:559
msgid ""
"In this section, we describe the general mechanisms available to you to "
"define, customize, and control how class instances are pickled and unpickled."
msgstr ""

#: ../Doc/library/pickle.rst:562
msgid ""
"In most cases, no additional code is needed to make instances picklable.  By "
"default, pickle will retrieve the class and the attributes of an instance "
"via introspection. When a class instance is unpickled, its :meth:`__init__` "
"method is usually *not* invoked.  The default behaviour first creates an "
"uninitialized instance and then restores the saved attributes.  The "
"following code shows an implementation of this behaviour::"
msgstr ""

#: ../Doc/library/pickle.rst:577
msgid ""
"Classes can alter the default behaviour by providing one or several special "
"methods:"
msgstr ""

#: ../Doc/library/pickle.rst:582
msgid ""
"In protocols 2 and newer, classes that implements the :meth:"
"`__getnewargs_ex__` method can dictate the values passed to the :meth:"
"`__new__` method upon unpickling.  The method must return a pair ``(args, "
"kwargs)`` where *args* is a tuple of positional arguments and *kwargs* a "
"dictionary of named arguments for constructing the object.  Those will be "
"passed to the :meth:`__new__` method upon unpickling."
msgstr ""

#: ../Doc/library/pickle.rst:590
msgid ""
"You should implement this method if the :meth:`__new__` method of your class "
"requires keyword-only arguments.  Otherwise, it is recommended for "
"compatibility to implement :meth:`__getnewargs__`."
msgstr ""

#: ../Doc/library/pickle.rst:594
msgid ":meth:`__getnewargs_ex__` is now used in protocols 2 and 3."
msgstr ""

#: ../Doc/library/pickle.rst:600
msgid ""
"This method serves a similar purpose as :meth:`__getnewargs_ex__`, but "
"supports only positional arguments.  It must return a tuple of arguments "
"``args`` which will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""

#: ../Doc/library/pickle.rst:604
msgid ""
":meth:`__getnewargs__` will not be called if :meth:`__getnewargs_ex__` is "
"defined."
msgstr ""

#: ../Doc/library/pickle.rst:607
msgid ""
"Before Python 3.6, :meth:`__getnewargs__` was called instead of :meth:"
"`__getnewargs_ex__` in protocols 2 and 3."
msgstr ""

#: ../Doc/library/pickle.rst:614
msgid ""
"Classes can further influence how their instances are pickled; if the class "
"defines the method :meth:`__getstate__`, it is called and the returned "
"object is pickled as the contents for the instance, instead of the contents "
"of the instance's dictionary.  If the :meth:`__getstate__` method is absent, "
"the instance's :attr:`~object.__dict__` is pickled as usual."
msgstr ""

#: ../Doc/library/pickle.rst:623
msgid ""
"Upon unpickling, if the class defines :meth:`__setstate__`, it is called "
"with the unpickled state.  In that case, there is no requirement for the "
"state object to be a dictionary.  Otherwise, the pickled state must be a "
"dictionary and its items are assigned to the new instance's dictionary."
msgstr ""

#: ../Doc/library/pickle.rst:630
msgid ""
"If :meth:`__getstate__` returns a false value, the :meth:`__setstate__` "
"method will not be called upon unpickling."
msgstr ""

#: ../Doc/library/pickle.rst:634
msgid ""
"Refer to the section :ref:`pickle-state` for more information about how to "
"use the methods :meth:`__getstate__` and :meth:`__setstate__`."
msgstr ""

#: ../Doc/library/pickle.rst:639
msgid ""
"At unpickling time, some methods like :meth:`__getattr__`, :meth:"
"`__getattribute__`, or :meth:`__setattr__` may be called upon the instance.  "
"In case those methods rely on some internal invariant being true, the type "
"should implement :meth:`__new__` to establish such an invariant, as :meth:"
"`__init__` is not called when unpickling an instance."
msgstr ""

#: ../Doc/library/pickle.rst:648
msgid ""
"As we shall see, pickle does not use directly the methods described above.  "
"In fact, these methods are part of the copy protocol which implements the :"
"meth:`__reduce__` special method.  The copy protocol provides a unified "
"interface for retrieving the data necessary for pickling and copying "
"objects. [#]_"
msgstr ""

#: ../Doc/library/pickle.rst:654
msgid ""
"Although powerful, implementing :meth:`__reduce__` directly in your classes "
"is error prone.  For this reason, class designers should use the high-level "
"interface (i.e., :meth:`__getnewargs_ex__`, :meth:`__getstate__` and :meth:"
"`__setstate__`) whenever possible.  We will show, however, cases where "
"using :meth:`__reduce__` is the only option or leads to more efficient "
"pickling or both."
msgstr ""

#: ../Doc/library/pickle.rst:663
msgid ""
"The interface is currently defined as follows.  The :meth:`__reduce__` "
"method takes no argument and shall return either a string or preferably a "
"tuple (the returned object is often referred to as the \"reduce value\")."
msgstr ""

#: ../Doc/library/pickle.rst:667
msgid ""
"If a string is returned, the string should be interpreted as the name of a "
"global variable.  It should be the object's local name relative to its "
"module; the pickle module searches the module namespace to determine the "
"object's module.  This behaviour is typically useful for singletons."
msgstr ""

#: ../Doc/library/pickle.rst:672
msgid ""
"When a tuple is returned, it must be between two and six items long. "
"Optional items can either be omitted, or ``None`` can be provided as their "
"value.  The semantics of each item are in order:"
msgstr ""

#: ../Doc/library/pickle.rst:678
msgid ""
"A callable object that will be called to create the initial version of the "
"object."
msgstr ""

#: ../Doc/library/pickle.rst:681
msgid ""
"A tuple of arguments for the callable object.  An empty tuple must be given "
"if the callable does not accept any argument."
msgstr ""

#: ../Doc/library/pickle.rst:684
msgid ""
"Optionally, the object's state, which will be passed to the object's :meth:"
"`__setstate__` method as previously described.  If the object has no such "
"method then, the value must be a dictionary and it will be added to the "
"object's :attr:`~object.__dict__` attribute."
msgstr ""

#: ../Doc/library/pickle.rst:689
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive items. "
"These items will be appended to the object either using ``obj.append(item)`` "
"or, in batch, using ``obj.extend(list_of_items)``. This is primarily used "
"for list subclasses, but may be used by other classes as long as they have :"
"meth:`append` and :meth:`extend` methods with the appropriate signature.  "
"(Whether :meth:`append` or :meth:`extend` is used depends on which pickle "
"protocol version is used as well as the number of items to append, so both "
"must be supported.)"
msgstr ""

#: ../Doc/library/pickle.rst:698
msgid ""
"Optionally, an iterator (not a sequence) yielding successive key-value "
"pairs.  These items will be stored to the object using ``obj[key] = "
"value``.  This is primarily used for dictionary subclasses, but may be used "
"by other classes as long as they implement :meth:`__setitem__`."
msgstr ""

#: ../Doc/library/pickle.rst:703
msgid ""
"Optionally, a callable with a ``(obj, state)`` signature. This callable "
"allows the user to programmatically control the state-updating behavior of a "
"specific object, instead of using ``obj``'s static :meth:`__setstate__` "
"method. If not ``None``, this callable will have priority over ``obj``'s :"
"meth:`__setstate__`."
msgstr ""

#: ../Doc/library/pickle.rst:709
msgid "The optional sixth tuple item, ``(obj, state)``, was added."
msgstr ""

#: ../Doc/library/pickle.rst:715
msgid ""
"Alternatively, a :meth:`__reduce_ex__` method may be defined.  The only "
"difference is this method should take a single integer argument, the "
"protocol version.  When defined, pickle will prefer it over the :meth:"
"`__reduce__` method.  In addition, :meth:`__reduce__` automatically becomes "
"a synonym for the extended version.  The main use for this method is to "
"provide backwards-compatible reduce values for older Python releases."
msgstr ""

#: ../Doc/library/pickle.rst:727
msgid "Persistence of External Objects"
msgstr ""

#: ../Doc/library/pickle.rst:733
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports the "
"notion of a reference to an object outside the pickled data stream.  Such "
"objects are referenced by a persistent ID, which should be either a string "
"of alphanumeric characters (for protocol 0) [#]_ or just an arbitrary object "
"(for any newer protocol)."
msgstr ""

#: ../Doc/library/pickle.rst:739
msgid ""
"The resolution of such persistent IDs is not defined by the :mod:`pickle` "
"module; it will delegate this resolution to the user-defined methods on the "
"pickler and unpickler, :meth:`~Pickler.persistent_id` and :meth:`~Unpickler."
"persistent_load` respectively."
msgstr ""

#: ../Doc/library/pickle.rst:744
msgid ""
"To pickle objects that have an external persistent ID, the pickler must have "
"a custom :meth:`~Pickler.persistent_id` method that takes an object as an "
"argument and returns either ``None`` or the persistent ID for that object. "
"When ``None`` is returned, the pickler simply pickles the object as normal. "
"When a persistent ID string is returned, the pickler will pickle that "
"object, along with a marker so that the unpickler will recognize it as a "
"persistent ID."
msgstr ""

#: ../Doc/library/pickle.rst:751
msgid ""
"To unpickle external objects, the unpickler must have a custom :meth:"
"`~Unpickler.persistent_load` method that takes a persistent ID object and "
"returns the referenced object."
msgstr ""

#: ../Doc/library/pickle.rst:755
msgid ""
"Here is a comprehensive example presenting how persistent ID can be used to "
"pickle external objects by reference."
msgstr ""

#: ../Doc/library/pickle.rst:763
msgid "Dispatch Tables"
msgstr ""

#: ../Doc/library/pickle.rst:765
msgid ""
"If one wants to customize pickling of some classes without disturbing any "
"other code which depends on pickling, then one can create a pickler with a "
"private dispatch table."
msgstr ""

#: ../Doc/library/pickle.rst:769
msgid ""
"The global dispatch table managed by the :mod:`copyreg` module is available "
"as :data:`copyreg.dispatch_table`.  Therefore, one may choose to use a "
"modified copy of :data:`copyreg.dispatch_table` as a private dispatch table."
msgstr ""

#: ../Doc/library/pickle.rst:774
msgid "For example ::"
msgstr ""

#: ../Doc/library/pickle.rst:781
msgid ""
"creates an instance of :class:`pickle.Pickler` with a private dispatch table "
"which handles the ``SomeClass`` class specially.  Alternatively, the code ::"
msgstr ""

#: ../Doc/library/pickle.rst:791
msgid ""
"does the same, but all instances of ``MyPickler`` will by default share the "
"same dispatch table.  The equivalent code using the :mod:`copyreg` module "
"is ::"
msgstr ""

#: ../Doc/library/pickle.rst:802
msgid "Handling Stateful Objects"
msgstr ""

#: ../Doc/library/pickle.rst:808
msgid ""
"Here's an example that shows how to modify pickling behavior for a class. "
"The :class:`TextReader` class opens a text file, and returns the line number "
"and line contents each time its :meth:`!readline` method is called. If a :"
"class:`TextReader` instance is pickled, all attributes *except* the file "
"object member are saved. When the instance is unpickled, the file is "
"reopened, and reading resumes from the last location. The :meth:"
"`__setstate__` and :meth:`__getstate__` methods are used to implement this "
"behavior. ::"
msgstr ""

#: ../Doc/library/pickle.rst:854
msgid "A sample usage might be something like this::"
msgstr ""

#: ../Doc/library/pickle.rst:868
msgid "Custom Reduction for Types, Functions, and Other Objects"
msgstr ""

#: ../Doc/library/pickle.rst:872
msgid ""
"Sometimes, :attr:`~Pickler.dispatch_table` may not be flexible enough. In "
"particular we may want to customize pickling based on another criterion than "
"the object's type, or we may want to customize the pickling of functions and "
"classes."
msgstr ""

#: ../Doc/library/pickle.rst:877
msgid ""
"For those cases, it is possible to subclass from the :class:`Pickler` class "
"and implement a :meth:`~Pickler.reducer_override` method. This method can "
"return an arbitrary reduction tuple (see :meth:`__reduce__`). It can "
"alternatively return ``NotImplemented`` to fallback to the traditional "
"behavior."
msgstr ""

#: ../Doc/library/pickle.rst:882
msgid ""
"If both the :attr:`~Pickler.dispatch_table` and :meth:`~Pickler."
"reducer_override` are defined, then :meth:`~Pickler.reducer_override` method "
"takes priority."
msgstr ""

#: ../Doc/library/pickle.rst:887
msgid ""
"For performance reasons, :meth:`~Pickler.reducer_override` may not be called "
"for the following objects: ``None``, ``True``, ``False``, and exact "
"instances of :class:`int`, :class:`float`, :class:`bytes`, :class:`str`, :"
"class:`dict`, :class:`set`, :class:`frozenset`, :class:`list` and :class:"
"`tuple`."
msgstr ""

#: ../Doc/library/pickle.rst:893
msgid ""
"Here is a simple example where we allow pickling and reconstructing a given "
"class::"
msgstr ""

#: ../Doc/library/pickle.rst:928
msgid "Out-of-band Buffers"
msgstr ""

#: ../Doc/library/pickle.rst:932
msgid ""
"In some contexts, the :mod:`pickle` module is used to transfer massive "
"amounts of data.  Therefore, it can be important to minimize the number of "
"memory copies, to preserve performance and resource consumption.  However, "
"normal operation of the :mod:`pickle` module, as it transforms a graph-like "
"structure of objects into a sequential stream of bytes, intrinsically "
"involves copying data to and from the pickle stream."
msgstr ""

#: ../Doc/library/pickle.rst:939
msgid ""
"This constraint can be eschewed if both the *provider* (the implementation "
"of the object types to be transferred) and the *consumer* (the "
"implementation of the communications system) support the out-of-band "
"transfer facilities provided by pickle protocol 5 and higher."
msgstr ""

#: ../Doc/library/pickle.rst:945
msgid "Provider API"
msgstr ""

#: ../Doc/library/pickle.rst:947
msgid ""
"The large data objects to be pickled must implement a :meth:`__reduce_ex__` "
"method specialized for protocol 5 and higher, which returns a :class:"
"`PickleBuffer` instance (instead of e.g. a :class:`bytes` object) for any "
"large data."
msgstr ""

#: ../Doc/library/pickle.rst:952
msgid ""
"A :class:`PickleBuffer` object *signals* that the underlying buffer is "
"eligible for out-of-band data transfer.  Those objects remain compatible "
"with normal usage of the :mod:`pickle` module.  However, consumers can also "
"opt-in to tell :mod:`pickle` that they will handle those buffers by "
"themselves."
msgstr ""

#: ../Doc/library/pickle.rst:959
msgid "Consumer API"
msgstr ""

#: ../Doc/library/pickle.rst:961
msgid ""
"A communications system can enable custom handling of the :class:"
"`PickleBuffer` objects generated when serializing an object graph."
msgstr ""

#: ../Doc/library/pickle.rst:964
msgid ""
"On the sending side, it needs to pass a *buffer_callback* argument to :class:"
"`Pickler` (or to the :func:`dump` or :func:`dumps` function), which will be "
"called with each :class:`PickleBuffer` generated while pickling the object "
"graph.  Buffers accumulated by the *buffer_callback* will not see their data "
"copied into the pickle stream, only a cheap marker will be inserted."
msgstr ""

#: ../Doc/library/pickle.rst:971
msgid ""
"On the receiving side, it needs to pass a *buffers* argument to :class:"
"`Unpickler` (or to the :func:`load` or :func:`loads` function), which is an "
"iterable of the buffers which were passed to *buffer_callback*. That "
"iterable should produce buffers in the same order as they were passed to "
"*buffer_callback*.  Those buffers will provide the data expected by the "
"reconstructors of the objects whose pickling produced the original :class:"
"`PickleBuffer` objects."
msgstr ""

#: ../Doc/library/pickle.rst:979
msgid ""
"Between the sending side and the receiving side, the communications system "
"is free to implement its own transfer mechanism for out-of-band buffers. "
"Potential optimizations include the use of shared memory or datatype-"
"dependent compression."
msgstr ""

#: ../Doc/library/pickle.rst:985
msgid "Example"
msgstr ""

#: ../Doc/library/pickle.rst:987
msgid ""
"Here is a trivial example where we implement a :class:`bytearray` subclass "
"able to participate in out-of-band buffer pickling::"
msgstr ""

#: ../Doc/library/pickle.rst:1011
msgid ""
"The reconstructor (the ``_reconstruct`` class method) returns the buffer's "
"providing object if it has the right type.  This is an easy way to simulate "
"zero-copy behaviour on this toy example."
msgstr ""

#: ../Doc/library/pickle.rst:1015
msgid ""
"On the consumer side, we can pickle those objects the usual way, which when "
"unserialized will give us a copy of the original object::"
msgstr ""

#: ../Doc/library/pickle.rst:1024
msgid ""
"But if we pass a *buffer_callback* and then give back the accumulated "
"buffers when unserializing, we are able to get back the original object::"
msgstr ""

#: ../Doc/library/pickle.rst:1034
msgid ""
"This example is limited by the fact that :class:`bytearray` allocates its "
"own memory: you cannot create a :class:`bytearray` instance that is backed "
"by another object's memory.  However, third-party datatypes such as NumPy "
"arrays do not have this limitation, and allow use of zero-copy pickling (or "
"making as few copies as possible) when transferring between distinct "
"processes or systems."
msgstr ""

#: ../Doc/library/pickle.rst:1041
msgid ":pep:`574` -- Pickle protocol 5 with out-of-band data"
msgstr ""

#: ../Doc/library/pickle.rst:1047
msgid "Restricting Globals"
msgstr ""

#: ../Doc/library/pickle.rst:1052
msgid ""
"By default, unpickling will import any class or function that it finds in "
"the pickle data.  For many applications, this behaviour is unacceptable as "
"it permits the unpickler to import and invoke arbitrary code.  Just consider "
"what this hand-crafted pickle data stream does when loaded::"
msgstr ""

#: ../Doc/library/pickle.rst:1062
msgid ""
"In this example, the unpickler imports the :func:`os.system` function and "
"then apply the string argument \"echo hello world\".  Although this example "
"is inoffensive, it is not difficult to imagine one that could damage your "
"system."
msgstr ""

#: ../Doc/library/pickle.rst:1066
msgid ""
"For this reason, you may want to control what gets unpickled by customizing :"
"meth:`Unpickler.find_class`.  Unlike its name suggests, :meth:`Unpickler."
"find_class` is called whenever a global (i.e., a class or a function) is "
"requested.  Thus it is possible to either completely forbid globals or "
"restrict them to a safe subset."
msgstr ""

#: ../Doc/library/pickle.rst:1072
msgid ""
"Here is an example of an unpickler allowing only few safe classes from the :"
"mod:`builtins` module to be loaded::"
msgstr ""

#: ../Doc/library/pickle.rst:1101
msgid "A sample usage of our unpickler working has intended::"
msgstr ""

#: ../Doc/library/pickle.rst:1120
msgid ""
"As our examples shows, you have to be careful with what you allow to be "
"unpickled.  Therefore if security is a concern, you may want to consider "
"alternatives such as the marshalling API in :mod:`xmlrpc.client` or third-"
"party solutions."
msgstr ""

#: ../Doc/library/pickle.rst:1127
msgid "Performance"
msgstr ""

#: ../Doc/library/pickle.rst:1129
msgid ""
"Recent versions of the pickle protocol (from protocol 2 and upwards) feature "
"efficient binary encodings for several common features and built-in types. "
"Also, the :mod:`pickle` module has a transparent optimizer written in C."
msgstr ""

#: ../Doc/library/pickle.rst:1137
msgid "Examples"
msgstr ""

#: ../Doc/library/pickle.rst:1139
msgid ""
"For the simplest code, use the :func:`dump` and :func:`load` functions. ::"
msgstr ""

#: ../Doc/library/pickle.rst:1155
msgid "The following example reads the resulting pickled data. ::"
msgstr ""

#: ../Doc/library/pickle.rst:1172
msgid "Module :mod:`copyreg`"
msgstr ""

#: ../Doc/library/pickle.rst:1172
msgid "Pickle interface constructor registration for extension types."
msgstr ""

#: ../Doc/library/pickle.rst:1175
msgid "Module :mod:`pickletools`"
msgstr ""

#: ../Doc/library/pickle.rst:1175
msgid "Tools for working with and analyzing pickled data."
msgstr ""

#: ../Doc/library/pickle.rst:1178
msgid "Module :mod:`shelve`"
msgstr ""

#: ../Doc/library/pickle.rst:1178
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr ""

#: ../Doc/library/pickle.rst:1181
msgid "Module :mod:`copy`"
msgstr ""

#: ../Doc/library/pickle.rst:1181
msgid "Shallow and deep object copying."
msgstr ""

#: ../Doc/library/pickle.rst:1183
msgid "Module :mod:`marshal`"
msgstr ""

#: ../Doc/library/pickle.rst:1184
msgid "High-performance serialization of built-in types."
msgstr ""

#: ../Doc/library/pickle.rst:1188
msgid "Footnotes"
msgstr ""

#: ../Doc/library/pickle.rst:1189
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr ""

#: ../Doc/library/pickle.rst:1191
msgid ""
"This is why :keyword:`lambda` functions cannot be pickled:  all :keyword:`!"
"lambda` functions share the same name:  ``<lambda>``."
msgstr ""

#: ../Doc/library/pickle.rst:1194
msgid ""
"The exception raised will likely be an :exc:`ImportError` or an :exc:"
"`AttributeError` but it could be something else."
msgstr ""

#: ../Doc/library/pickle.rst:1197
msgid ""
"The :mod:`copy` module uses this protocol for shallow and deep copying "
"operations."
msgstr ""

#: ../Doc/library/pickle.rst:1200
msgid ""
"The limitation on alphanumeric characters is due to the fact the persistent "
"IDs, in protocol 0, are delimited by the newline character.  Therefore if "
"any kind of newline characters occurs in persistent IDs, the resulting "
"pickle will become unreadable."
msgstr ""
=======
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-05 12:54+0200\n"
"PO-Revision-Date: 2020-09-19 20:01-0300\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: Manuel Ramos <manuelramos175@gmail.com>\n"
"Language: es\n"
"X-Generator: Poedit 2.4.1\n"

#: ../Doc/library/pickle.rst:2
msgid ":mod:`pickle` --- Python object serialization"
msgstr ":mod:`pickle` --- Serializacin de objetos Python"

#: ../Doc/library/pickle.rst:10
msgid "**Source code:** :source:`Lib/pickle.py`"
msgstr "**Cdigo fuente:** :source:`Lib/pickle.py`"

#: ../Doc/library/pickle.rst:22
msgid ""
"The :mod:`pickle` module implements binary protocols for serializing and de-"
"serializing a Python object structure.  *\"Pickling\"* is the process "
"whereby a Python object hierarchy is converted into a byte stream, and *"
"\"unpickling\"* is the inverse operation, whereby a byte stream (from a :"
"term:`binary file` or :term:`bytes-like object`) is converted back into an "
"object hierarchy.  Pickling (and unpickling) is alternatively known as "
"\"serialization\", \"marshalling,\" [#]_ or \"flattening\"; however, to "
"avoid confusion, the terms used here are \"pickling\" and \"unpickling\"."
msgstr ""
"El modulo :mod:`pickle` implementa protocolos binarios para serializar y "
"deserializar una estructura de objetos Python.  *\"Pickling\"* es el proceso "
"mediante el cual una jerarqua de objetos de Python se convierte en una "
"secuencia de bytes, y el *\"unpickling\"* es la operacin inversa, mediante "
"la cual una secuencia de bytes de un archivo binario (:term:`binary file`)  "
"un objeto tipo binario (:term:`bytes-like object`) es convertido nuevamente "
"en una jerarqua de objetos.  `Pickling` (y `unpickling`) son "
"alternativamente conocidos como \"serializacin\", \"ensamblaje,\" [#]_ o "
"\"aplanamiento\"; sin embargo, para evitar confusiones, los trminos "
"utilizados aqu son \"pickling\" y \"unpickling\"."

#: ../Doc/library/pickle.rst:33
msgid "The ``pickle`` module **is not secure**. Only unpickle data you trust."
msgstr ""
"El modulo ``pickle`` **no es seguro**. Solo deserialize con `pickle` los "
"datos en los que confa."

#: ../Doc/library/pickle.rst:35
msgid ""
"It is possible to construct malicious pickle data which will **execute "
"arbitrary code during unpickling**. Never unpickle data that could have come "
"from an untrusted source, or that could have been tampered with."
msgstr ""
"Es posible construir datos maliciosos con `pickle` que **ejecuten cdigo "
"arbitrario durante el proceso de `unpickling`**. Nunca deserialize datos con "
"`pickle` que podran haber venido de una fuente no confiable, o que podran "
"haber sido manipulados."

#: ../Doc/library/pickle.rst:39
msgid ""
"Consider signing data with :mod:`hmac` if you need to ensure that it has not "
"been tampered with."
msgstr ""
"Considere firmar los datos con :mod:`hmac` si necesita asegurarse de que no "
"hayan sido alterados."

#: ../Doc/library/pickle.rst:42
msgid ""
"Safer serialization formats such as :mod:`json` may be more appropriate if "
"you are processing untrusted data. See :ref:`comparison-with-json`."
msgstr ""
"Los formatos de serializacin ms seguros como :mod:`json` pueden ser ms "
"apropiados si est procesando datos no confiables. Ver :ref:`comparison-with-"
"json`."

#: ../Doc/library/pickle.rst:47
msgid "Relationship to other Python modules"
msgstr "Relacin con otros mdulos de Python"

#: ../Doc/library/pickle.rst:50
msgid "Comparison with ``marshal``"
msgstr "Comparacin con ``marshal``"

#: ../Doc/library/pickle.rst:52
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, but "
"in general :mod:`pickle` should always be the preferred way to serialize "
"Python objects.  :mod:`marshal` exists primarily to support Python's :file:`."
"pyc` files."
msgstr ""
"Python tiene un mdulo de serializacin ms primitivo llamado :mod:"
"`marshal`, pero en general :mod:`pickle` debera ser siempre la forma "
"preferida de serializar objetos de Python.  :mod:`marshal` existe "
"principalmente para soportar archivos Python :file:`.pyc`."

#: ../Doc/library/pickle.rst:57
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several significant "
"ways:"
msgstr ""
"El modulo :mod:`pickle` difiere de :mod:`marshal` en varias formas "
"significativas:"

#: ../Doc/library/pickle.rst:59
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be serialized "
"again. :mod:`marshal` doesn't do this."
msgstr ""
"El modulo :mod:`pickle` realiza un seguimiento de los objetos que ya ha "
"serializado, para que las referencias posteriores al mismo objeto no se "
"serializen nuevamente. :mod:`marshal` no hace esto."

#: ../Doc/library/pickle.rst:63
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  These "
"are not handled by marshal, and in fact, attempting to marshal recursive "
"objects will crash your Python interpreter.  Object sharing happens when "
"there are multiple references to the same object in different places in the "
"object hierarchy being serialized.  :mod:`pickle` stores such objects only "
"once, and ensures that all other references point to the master copy.  "
"Shared objects remain shared, which can be very important for mutable "
"objects."
msgstr ""
"Esto tiene implicaciones tanto para los objetos recursivos como para "
"compartir objetos.  Los objetos recursivos son objetos que contienen "
"referencias a s mismos.  `Marshal` no los maneja y, de hecho, intentar "
"agrupar objetos recursivos bloquear su intrprete de Python.  El "
"intercambio de objetos ocurre cuando hay mltiples referencias al mismo "
"objeto en diferentes lugares de la jerarqua de objetos que se serializan.  :"
"mod:`pickle` almacena dichos objetos solo una vez y garantiza que todas las "
"dems referencias apunten a la copia maestra.  Los objetos compartidos "
"permanecen compartidos, lo cual puede ser muy importante para los objetos "
"mutables."

#: ../Doc/library/pickle.rst:72
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their "
"instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live in "
"the same module as when the object was stored."
msgstr ""
":mod:`marshal` no se puede usar para serializar clases definidas por el "
"usuario y sus instancias.  :mod:`pickle` puede guardar y restaurar "
"instancias de clase de forma transparente, sin embargo, la definicin de "
"clase debe ser importable y vivir en el mismo mdulo que cuando se almacen "
"el objeto."

#: ../Doc/library/pickle.rst:77
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support :file:"
"`.pyc` files, the Python implementers reserve the right to change the "
"serialization format in non-backwards compatible ways should the need arise. "
"The :mod:`pickle` serialization format is guaranteed to be backwards "
"compatible across Python releases provided a compatible pickle protocol is "
"chosen and pickling and unpickling code deals with Python 2 to Python 3 type "
"differences if your data is crossing that unique breaking change language "
"boundary."
msgstr ""
"No se garantiza que el formato de serializacin :mod:`marshal` sea portable "
"a travs de todas las versiones de Python.  Debido a que su trabajo "
"principal es dar soporte a archivos :file:`.pyc`, los implementadores de "
"Python se reservan el derecho de cambiar el formato de serializacin de "
"formas no compatibles con versiones anteriores si surge la necesidad. El "
"formato de serializacin :mod:`pickle` est garantizado para ser compatible "
"con versiones anteriores de Python siempre que se elija un protocolo de "
"`pickle` compatible y el serializado y deserializado de cdigo con `pickle` "
"se encargue de lidiar con las diferencias de tipos entre Python 2 y Python 3 "
"si sus datos estn cruzando ese limite nico entre las versiones del "
"lenguaje."

#: ../Doc/library/pickle.rst:90
msgid "Comparison with ``json``"
msgstr "Comparacin con ``json``"

#: ../Doc/library/pickle.rst:92
msgid ""
"There are fundamental differences between the pickle protocols and `JSON "
"(JavaScript Object Notation) <http://json.org>`_:"
msgstr ""
"Existen diferencias fundamentales entre los protocolos de `pickle` y `JSON "
"(acrnimo de JavaScript Object Notation, notacin de objeto de JavaScript) "
"<http://json.org>`_:"

#: ../Doc/library/pickle.rst:95
msgid ""
"JSON is a text serialization format (it outputs unicode text, although most "
"of the time it is then encoded to ``utf-8``), while pickle is a binary "
"serialization format;"
msgstr ""
"JSON es un formato de serializacin de texto (genera texto unicode, aunque "
"la mayora de las veces se codifica a ``utf-8``), mientras que `pickle` es "
"un formato de serializacin binario;"

#: ../Doc/library/pickle.rst:99
msgid "JSON is human-readable, while pickle is not;"
msgstr "JSON es legible por humanos, mientras que `pickle` no lo es;"

#: ../Doc/library/pickle.rst:101
msgid ""
"JSON is interoperable and widely used outside of the Python ecosystem, while "
"pickle is Python-specific;"
msgstr ""
"JSON es interoperable y ampliamente utilizado fuera del ecosistema de "
"Python, mientras que `pickle` es especfico de Python;"

#: ../Doc/library/pickle.rst:104
msgid ""
"JSON, by default, can only represent a subset of the Python built-in types, "
"and no custom classes; pickle can represent an extremely large number of "
"Python types (many of them automatically, by clever usage of Python's "
"introspection facilities; complex cases can be tackled by implementing :ref:"
"`specific object APIs <pickle-inst>`);"
msgstr ""
"JSON, por defecto, solo puede representar un subconjunto de los tipos "
"integrados de Python, y no clases personalizadas; `pickle` puede representar "
"un nmero extremadamente grande de tipos de Python (muchos de ellos "
"automticamente, mediante el uso inteligente de la introspeccin de objetos "
"en Python; los casos complejos se pueden abordar implementando API de "
"objetos especficos, :ref:`specific object APIs <pickle-inst>`);"

#: ../Doc/library/pickle.rst:110
msgid ""
"Unlike pickle, deserializing untrusted JSON does not in itself create an "
"arbitrary code execution vulnerability."
msgstr ""
"A diferencia de `pickle`, deserializar JSON no confiable no crea en s mismo "
"una vulnerabilidad de ejecucin de cdigo arbitraria."

#: ../Doc/library/pickle.rst:114
msgid ""
"The :mod:`json` module: a standard library module allowing JSON "
"serialization and deserialization."
msgstr ""
"El modulo :mod:`json`: un mdulo de la biblioteca estndar que permite la "
"serializacin y deserializacin de JSON."

#: ../Doc/library/pickle.rst:121
msgid "Data stream format"
msgstr "Formato de flujo de datos"

#: ../Doc/library/pickle.rst:126
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards such "
"as JSON or XDR (which can't represent pointer sharing); however it means "
"that non-Python programs may not be able to reconstruct pickled Python "
"objects."
msgstr ""
"El formato de datos utilizado por :mod:`pickle` es especfico de Python.  "
"Esto tiene la ventaja de que no hay restricciones impuestas por estndares "
"externos como JSON o XDR (que no pueden representar el uso compartido de "
"punteros); sin embargo, significa que los programas que no son de Python "
"pueden no ser capaces de reconstruir objetos Python serialzados con `pickle`."

#: ../Doc/library/pickle.rst:131
msgid ""
"By default, the :mod:`pickle` data format uses a relatively compact binary "
"representation.  If you need optimal size characteristics, you can "
"efficiently :doc:`compress <archiving>` pickled data."
msgstr ""
"Por defecto, el formato de datos :mod:`pickle` utiliza una representacin "
"binaria relativamente compacta.  Si necesita caractersticas de tamao "
"ptimas, puede eficientemente :doc:`comprimir <archiving>` datos "
"serializados con `pickle`."

#: ../Doc/library/pickle.rst:135
msgid ""
"The module :mod:`pickletools` contains tools for analyzing data streams "
"generated by :mod:`pickle`.  :mod:`pickletools` source code has extensive "
"comments about opcodes used by pickle protocols."
msgstr ""
"El modulo :mod:`pickletools` contiene herramientas para analizar flujos de "
"datos generados por :mod:`pickle`.  El cdigo fuente de :mod:`pickletools` "
"tiene comentarios extensos sobre los cdigos de operacin utilizados por los "
"protocolos de `pickle`."

#: ../Doc/library/pickle.rst:139
msgid ""
"There are currently 6 different protocols which can be used for pickling. "
"The higher the protocol used, the more recent the version of Python needed "
"to read the pickle produced."
msgstr ""
"Actualmente hay 6 protocolos diferentes que se pueden utilizar para "
"serializar con `pickle`. Cuanto mayor sea el protocolo utilizado, ms "
"reciente ser la versin de Python necesaria para leer el `pickle` producido."

#: ../Doc/library/pickle.rst:143
msgid ""
"Protocol version 0 is the original \"human-readable\" protocol and is "
"backwards compatible with earlier versions of Python."
msgstr ""
"La versin 0 del protocolo es el protocolo original \"legible para humanos\" "
"y es compatible con versiones anteriores de Python."

#: ../Doc/library/pickle.rst:146
msgid ""
"Protocol version 1 is an old binary format which is also compatible with "
"earlier versions of Python."
msgstr ""
"La versin 1 del protocolo es un formato binario antiguo que tambin es "
"compatible con versiones anteriores de Python."

#: ../Doc/library/pickle.rst:149
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style class`\\es.  Refer to :pep:`307` for "
"information about improvements brought by protocol 2."
msgstr ""
"La versin 2 del protocolo se introdujo en Python 2.3. Proporciona un "
"serializado con `pickle` mucho ms eficiente de clases de estilo nuevo (:"
"term:`new-style class`).  Consulte :pep:`307` para obtener informacin sobre "
"las mejoras aportadas por el protocolo 2."

#: ../Doc/library/pickle.rst:153
msgid ""
"Protocol version 3 was added in Python 3.0.  It has explicit support for :"
"class:`bytes` objects and cannot be unpickled by Python 2.x.  This was the "
"default protocol in Python 3.0--3.7."
msgstr ""
"Se agreg la versin 3 del protocolo en Python 3.0.  Tiene soporte explcito "
"para objetos :class:`bytes` y no puede ser deserializado con `pickle` por "
"Python 2.x.  Este era el protocolo predeterminado en Python 3.0--3.7."

#: ../Doc/library/pickle.rst:157
msgid ""
"Protocol version 4 was added in Python 3.4.  It adds support for very large "
"objects, pickling more kinds of objects, and some data format "
"optimizations.  It is the default protocol starting with Python 3.8. Refer "
"to :pep:`3154` for information about improvements brought by protocol 4."
msgstr ""
"Se agreg la versin 4 del protocolo en Python 3.4.  Agrega soporte para "
"objetos muy grandes, `pickling` de mas tipos de objetos y algunas "
"optimizaciones de formato de datos.  Es el protocolo predeterminado que "
"comienza con Python 3.8. Consulte :pep:`3154` para obtener informacin sobre "
"las mejoras aportadas por el protocolo 4."

#: ../Doc/library/pickle.rst:163
msgid ""
"Protocol version 5 was added in Python 3.8.  It adds support for out-of-band "
"data and speedup for in-band data.  Refer to :pep:`574` for information "
"about improvements brought by protocol 5."
msgstr ""
"Se agreg la versin 5 del protocolo en Python 3.8.  Agrega soporte para "
"datos fuera de banda y aceleracin para datos dentro de banda.  Consulte :"
"pep:`574` para obtener informacin sobre las mejoras aportadas por el "
"protocolo 5."

#: ../Doc/library/pickle.rst:168
msgid ""
"Serialization is a more primitive notion than persistence; although :mod:"
"`pickle` reads and writes file objects, it does not handle the issue of "
"naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the byte "
"stream into an object with the same internal structure.  Perhaps the most "
"obvious thing to do with these byte streams is to write them onto a file, "
"but it is also conceivable to send them across a network or store them in a "
"database.  The :mod:`shelve` module provides a simple interface to pickle "
"and unpickle objects on DBM-style database files."
msgstr ""
"La serializacin es una nocin ms primitiva que la persistencia; aunque :"
"mod:`pickle` lee y escribe objetos de archivo, no maneja el problema de "
"nombrar objetos persistentes, ni el problema (an ms complicado) de acceso "
"concurrente a objetos persistentes.  El mdulo :mod:`pickle` puede "
"transformar un objeto complejo en una secuencia de bytes y puede transformar "
"la secuencia de bytes en un objeto con la misma estructura interna.  Quizs "
"lo ms obvio que hacer con estos flujos de bytes es escribirlos en un "
"archivo, pero tambin es concebible enviarlos a travs de una red o "
"almacenarlos en una base de datos.  El mdulo :mod:`shelve` proporciona una "
"interfaz simple para serializar y deserializar objetos con `pickle` en "
"archivos de bases de datos de estilo DBM."

#: ../Doc/library/pickle.rst:181
msgid "Module Interface"
msgstr "Interfaz del mdulo"

#: ../Doc/library/pickle.rst:183
msgid ""
"To serialize an object hierarchy, you simply call the :func:`dumps` "
"function. Similarly, to de-serialize a data stream, you call the :func:"
"`loads` function. However, if you want more control over serialization and "
"de-serialization, you can create a :class:`Pickler` or an :class:`Unpickler` "
"object, respectively."
msgstr ""
"Para serializar una jerarqua de objetos, simplemente llame a la funcin :"
"func:`dumps`. De manera similar, para deserializar un flujo de datos, llama "
"a la funcin :func:`loads`. Sin embargo, si desea tener ms control sobre la "
"serializacin y la deserializacin, puede crear un objeto :class:`Pickler` "
"o :class:`Unpickler`, respectivamente."

#: ../Doc/library/pickle.rst:188
msgid "The :mod:`pickle` module provides the following constants:"
msgstr "El mdulo :mod:`pickle` proporciona las siguientes constantes:"

#: ../Doc/library/pickle.rst:193
msgid ""
"An integer, the highest :ref:`protocol version <pickle-protocols>` "
"available.  This value can be passed as a *protocol* value to functions :"
"func:`dump` and :func:`dumps` as well as the :class:`Pickler` constructor."
msgstr ""
"Un entero, la versin de protocolo (:ref:`protocol version <pickle-"
"protocols>`) ms alta disponible.  Este valor se puede pasar como un valor "
"de *protocolo* a las funciones :func:`dump` y :func:`dumps` as como al "
"constructor :class:`Pickler`."

#: ../Doc/library/pickle.rst:200
msgid ""
"An integer, the default :ref:`protocol version <pickle-protocols>` used for "
"pickling.  May be less than :data:`HIGHEST_PROTOCOL`.  Currently the default "
"protocol is 4, first introduced in Python 3.4 and incompatible with previous "
"versions."
msgstr ""
"Un entero, la versin de protocolo (:ref:`protocol version <pickle-"
"protocols>`) predeterminada utilizada para el serializado con `pickle`.  "
"Puede ser menor que :data:`HIGHEST_PROTOCOL`.  Actualmente, el protocolo "
"predeterminado es 4, introducido por primera vez en Python 3.4 e "
"incompatible con versiones anteriores."

#: ../Doc/library/pickle.rst:207
msgid "The default protocol is 3."
msgstr "El protocolo predeterminado es 3."

#: ../Doc/library/pickle.rst:211
msgid "The default protocol is 4."
msgstr "El protocolo predeterminado es 4."

#: ../Doc/library/pickle.rst:213
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr ""
"El mdulo :mod:`pickle` proporciona las siguientes funciones para que el "
"proceso de `pickling` sea ms conveniente:"

#: ../Doc/library/pickle.rst:218
msgid ""
"Write the pickled representation of the object *obj* to the open :term:`file "
"object` *file*.  This is equivalent to ``Pickler(file, protocol).dump(obj)``."
msgstr ""
"Escribe la representacin `pickle` del objeto *obj* en el *archivo* abierto :"
"term:`file object`.  Esto es equivalente a ``Pickler(file, protocol)."
"dump(obj)``."

#: ../Doc/library/pickle.rst:222
msgid ""
"Arguments *file*, *protocol*, *fix_imports* and *buffer_callback* have the "
"same meaning as in the :class:`Pickler` constructor."
msgstr ""
"Los argumentos *file*, *protocol*, *fix_imports* y *buffer_callback* tienen "
"el mismo significado que en el constructor :class:`Pickler`."

#: ../Doc/library/pickle.rst:225 ../Doc/library/pickle.rst:236
#: ../Doc/library/pickle.rst:328
msgid "The *buffer_callback* argument was added."
msgstr "Se agreg el argumento *buffer_callback*."

#: ../Doc/library/pickle.rst:230
msgid ""
"Return the pickled representation of the object *obj* as a :class:`bytes` "
"object, instead of writing it to a file."
msgstr ""
"Devuelva la representacin `pickle` del objeto *obj* como un objeto :class:"
"`bytes`, en lugar de escribirlo en un archivo."

#: ../Doc/library/pickle.rst:233
msgid ""
"Arguments *protocol*, *fix_imports* and *buffer_callback* have the same "
"meaning as in the :class:`Pickler` constructor."
msgstr ""
"Los argumentos *protocol*, *fix_imports* y *buffer_callback* tienen el mismo "
"significado que en el constructor :class:`Pickler`."

#: ../Doc/library/pickle.rst:241
msgid ""
"Read the pickled representation of an object from the open :term:`file "
"object` *file* and return the reconstituted object hierarchy specified "
"therein. This is equivalent to ``Unpickler(file).load()``."
msgstr ""
"Lee la representacin `pickle` de un objeto desde un *archivo* abierto :term:"
"`file object` y devuelva la jerarqua de objetos reconstituidos especificada "
"en el mismo. Esto es equivalente a ``Unpickler(file).load()``."

#: ../Doc/library/pickle.rst:245 ../Doc/library/pickle.rst:260
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed.  Bytes past the pickled representation of the object are "
"ignored."
msgstr ""
"La versin de protocolo del `pickle` se detecta automticamente, por lo que "
"no se necesita ningn argumento de protocolo.  Los bytes ms all de la "
"representacin empaquetada son ignorados."

#: ../Doc/library/pickle.rst:249 ../Doc/library/pickle.rst:264
msgid ""
"Arguments *file*, *fix_imports*, *encoding*, *errors*, *strict* and "
"*buffers* have the same meaning as in the :class:`Unpickler` constructor."
msgstr ""
"Los argumentos *file*, *fix_imports*, *encoding*, *errors*, *strict* y "
"*buffers* tienen el mismo significado que en el constructor :class:"
"`Unpickler`."

#: ../Doc/library/pickle.rst:252 ../Doc/library/pickle.rst:267
#: ../Doc/library/pickle.rst:429
msgid "The *buffers* argument was added."
msgstr "Se agreg el argumento *buffers*."

#: ../Doc/library/pickle.rst:257
msgid ""
"Return the reconstituted object hierarchy of the pickled representation "
"*data* of an object. *data* must be a :term:`bytes-like object`."
msgstr ""
"Devuelve la jerarqua de objetos reconstruida de la representacin `pickle` "
"*data* de un objeto. *data* debe ser un objeto tipo binario (:term:`bytes-"
"like object`)."

#: ../Doc/library/pickle.rst:271
msgid "The :mod:`pickle` module defines three exceptions:"
msgstr "El mdulo :mod:`pickle` define tres excepciones:"

# Agregar empaquetamiento al diccionario
#: ../Doc/library/pickle.rst:275
msgid ""
"Common base class for the other pickling exceptions.  It inherits :exc:"
"`Exception`."
msgstr ""
"Clase base comn para las otras excepciones de `pickling`.  Hereda de :exc:"
"`Exception`."

#: ../Doc/library/pickle.rst:280
msgid ""
"Error raised when an unpicklable object is encountered by :class:`Pickler`. "
"It inherits :exc:`PickleError`."
msgstr ""
"Error generado cuando :class:`Pickler` encuentra un objeto que no se puede "
"serializar con `pickle` . Hereda de :exc:`PickleError`."

# el texto :ref:`pickle-picklable` hace referencia a una seccion dentro de este archivo. Mas adelante hay que traducir esa seccion y en consecuencia actualizar esta linea.
#: ../Doc/library/pickle.rst:283
msgid ""
"Refer to :ref:`pickle-picklable` to learn what kinds of objects can be "
"pickled."
msgstr ""
"Consulte :ref:`pickle-picklable` para aprender qu tipos de objetos se "
"pueden serializar con `pickle`."

#: ../Doc/library/pickle.rst:288
msgid ""
"Error raised when there is a problem unpickling an object, such as a data "
"corruption or a security violation.  It inherits :exc:`PickleError`."
msgstr ""
"Se produce un error cuando hay un problema al deserializar un objeto con "
"`pickle`, por ejemplo como una corrupcin de datos o una violacin de "
"seguridad.  Hereda de :exc:`PickleError`."

#: ../Doc/library/pickle.rst:291
msgid ""
"Note that other exceptions may also be raised during unpickling, including "
"(but not necessarily limited to) AttributeError, EOFError, ImportError, and "
"IndexError."
msgstr ""
"Tenga en cuenta que tambin se pueden generar otras excepciones durante la "
"deserializacion con `pickle`, incluyendo (pero no necesariamente limitado a) "
"`AttributeError`, `EOFError`, `ImportError`, e `IndexError`."

#: ../Doc/library/pickle.rst:296
msgid ""
"The :mod:`pickle` module exports three classes, :class:`Pickler`, :class:"
"`Unpickler` and :class:`PickleBuffer`:"
msgstr ""
"El mdulo :mod:`pickle` exporta tres clases, :class:`Pickler`, :class:"
"`Unpickler` y :class:`PickleBuffer`:"

#: ../Doc/library/pickle.rst:301
msgid "This takes a binary file for writing a pickle data stream."
msgstr ""
"Esto toma un archivo binario para escribir un flujo de datos de `pickle`."

#: ../Doc/library/pickle.rst:303
msgid ""
"The optional *protocol* argument, an integer, tells the pickler to use the "
"given protocol; supported protocols are 0 to :data:`HIGHEST_PROTOCOL`. If "
"not specified, the default is :data:`DEFAULT_PROTOCOL`.  If a negative "
"number is specified, :data:`HIGHEST_PROTOCOL` is selected."
msgstr ""
"El argumento opcional *protocol* , un entero, le dice al `pickler` que use "
"el protocolo dado; los protocolos admitidos son 0 para :data:"
"`HIGHEST_PROTOCOL`. Si no se especifica, el valor predeterminado es :data:"
"`DEFAULT_PROTOCOL`.  Si se especifica un nmero negativo, :data:"
"`HIGHEST_PROTOCOL` es seleccionado."

#: ../Doc/library/pickle.rst:308
msgid ""
"The *file* argument must have a write() method that accepts a single bytes "
"argument.  It can thus be an on-disk file opened for binary writing, an :"
"class:`io.BytesIO` instance, or any other custom object that meets this "
"interface."
msgstr ""
"El argumento *file* debe tener un mtodo *write()* que acepte un argumento "
"de bytes individuales.  Por lo tanto, puede ser un archivo en disco abierto "
"para escritura binaria, una instancia :class:`io.BytesIO` , o cualquier otro "
"objeto personalizado que cumpla con esta interfaz."

#: ../Doc/library/pickle.rst:313
msgid ""
"If *fix_imports* is true and *protocol* is less than 3, pickle will try to "
"map the new Python 3 names to the old module names used in Python 2, so that "
"the pickle data stream is readable with Python 2."
msgstr ""
"Si *fix_imports* es verdadero y *protocol* es menor que 3, `pickle` "
"intentar asignar los nuevos nombres de Python 3 a los nombres de mdulos "
"antiguos utilizados en Python 2, de modo que la secuencia de datos de "
"`pickle` sea legible con Python 2."

# Agregar `None` al diccionario
#: ../Doc/library/pickle.rst:317
msgid ""
"If *buffer_callback* is None (the default), buffer views are serialized into "
"*file* as part of the pickle stream."
msgstr ""
"Si *buffer_callback* es None (el valor predeterminado), las vistas de bfer "
"se serializan en *file* como parte de la secuencia de `pickle`."

#: ../Doc/library/pickle.rst:320
msgid ""
"If *buffer_callback* is not None, then it can be called any number of times "
"with a buffer view.  If the callback returns a false value (such as None), "
"the given buffer is :ref:`out-of-band <pickle-oob>`; otherwise the buffer is "
"serialized in-band, i.e. inside the pickle stream."
msgstr ""
"Si *buffer_callback* no es None, entonces se puede llamar cualquier nmero "
"de veces con una vista de bfer.  Si la `callback` devuelve un valor falso "
"(como None), el bfer dado est fuera de banda (:ref:`out-of-band <pickle-"
"oob>`); de lo contrario, el bfer se serializa en banda, es decir, dentro "
"del flujo de `pickle`."

#: ../Doc/library/pickle.rst:325
msgid ""
"It is an error if *buffer_callback* is not None and *protocol* is None or "
"smaller than 5."
msgstr ""
"Es un error si *buffer_callback* no es None y *protocol* es None o menor que "
"5."

#: ../Doc/library/pickle.rst:333
msgid ""
"Write the pickled representation of *obj* to the open file object given in "
"the constructor."
msgstr ""
"Escribe la representacin serializada con `pickle` del objeto *obj* en el "
"objeto archivo abierto dado en el constructor."

#: ../Doc/library/pickle.rst:338
msgid "Do nothing by default.  This exists so a subclass can override it."
msgstr ""
"No hacer nada por defecto. Esto existe para que una subclase pueda "
"sobreescribirlo."

#: ../Doc/library/pickle.rst:340
msgid ""
"If :meth:`persistent_id` returns ``None``, *obj* is pickled as usual.  Any "
"other value causes :class:`Pickler` to emit the returned value as a "
"persistent ID for *obj*.  The meaning of this persistent ID should be "
"defined by :meth:`Unpickler.persistent_load`.  Note that the value returned "
"by :meth:`persistent_id` cannot itself have a persistent ID."
msgstr ""
"Si :meth:`persistent_id` devuelve ``None``, *obj* es serializado con "
"`pickle` como siempre.  Cualquier otro valor hace que :class:`Pickler` emita "
"el valor devuelto como un ID persistente para *obj*.  El significado de este "
"ID persistente debe definirse por :meth:`Unpickler.persistent_load`.  Tenga "
"en cuenta que el valor devuelto por :meth:`persistent_id` no puede tener una "
"ID persistente."

#: ../Doc/library/pickle.rst:346 ../Doc/library/pickle.rst:447
msgid "See :ref:`pickle-persistent` for details and examples of uses."
msgstr "Ver :ref:`pickle-persistent` para detalles y ejemplos de uso."

#: ../Doc/library/pickle.rst:350
msgid ""
"A pickler object's dispatch table is a registry of *reduction functions* of "
"the kind which can be declared using :func:`copyreg.pickle`.  It is a "
"mapping whose keys are classes and whose values are reduction functions.  A "
"reduction function takes a single argument of the associated class and "
"should conform to the same interface as a :meth:`__reduce__` method."
msgstr ""
"La tabla de envo de un objeto `Pickler` es un registro de *funciones de "
"reduccin* del tipo que se puede declarar usando :func:`copyreg.pickle`.  Es "
"un mapeo cuyas claves son clases y cuyos valores son funciones de "
"reduccin.  Una funcin de reduccin toma un solo argumento de la clase "
"asociada y debe ajustarse a la misma interfaz que un mtodo :meth:"
"`__reduce__`."

#: ../Doc/library/pickle.rst:358
msgid ""
"By default, a pickler object will not have a :attr:`dispatch_table` "
"attribute, and it will instead use the global dispatch table managed by the :"
"mod:`copyreg` module. However, to customize the pickling for a specific "
"pickler object one can set the :attr:`dispatch_table` attribute to a dict-"
"like object.  Alternatively, if a subclass of :class:`Pickler` has a :attr:"
"`dispatch_table` attribute then this will be used as the default dispatch "
"table for instances of that class."
msgstr ""
"Por defecto, un objeto de `pickle` no tendr un atributo :attr:"
"`dispatch_table`, y en su lugar utilizar la tabla de despacho global "
"administrada por el mdulo :mod:`copyreg`. Sin embargo, para personalizar el "
"`pickling` para un objeto de `pickle` especfico, se puede establecer el "
"atributo :attr:`dispatch_table` en un objeto tipo dict.  Alternativamente, "
"si una subclase de :class:`Pickler` tiene un atributo :attr:`dispatch_table` "
"esto se usar como la tabla de despacho predeterminada para instancias de "
"esa clase."

#: ../Doc/library/pickle.rst:367
msgid "See :ref:`pickle-dispatch` for usage examples."
msgstr "Ver :ref:`pickle-dispatch` para ejemplos de uso."

#: ../Doc/library/pickle.rst:373
msgid ""
"Special reducer that can be defined in :class:`Pickler` subclasses. This "
"method has priority over any reducer in the :attr:`dispatch_table`.  It "
"should conform to the same interface as a :meth:`__reduce__` method, and can "
"optionally return ``NotImplemented`` to fallback on :attr:`dispatch_table`-"
"registered reducers to pickle ``obj``."
msgstr ""
"Reductor especial que se puede definir en subclases de :class:`Pickler`. "
"Este mtodo tiene prioridad sobre cualquier reductor en :attr:"
"`dispatch_table`.  Debe cumplir con la misma interfaz que un mtodo :meth:"
"`__reduce__`, y opcionalmente puede devolver ``NotImplemented`` para "
"recurrir a reductores registrados en :attr:`dispatch_table` el objeto "
"`pickle` ``obj``."

#: ../Doc/library/pickle.rst:379
msgid "For a detailed example, see :ref:`reducer_override`."
msgstr "Para un ejemplo detallado, ver :ref:`reducer_override`."

#: ../Doc/library/pickle.rst:385
msgid ""
"Deprecated. Enable fast mode if set to a true value.  The fast mode disables "
"the usage of memo, therefore speeding the pickling process by not generating "
"superfluous PUT opcodes.  It should not be used with self-referential "
"objects, doing otherwise will cause :class:`Pickler` to recurse infinitely."
msgstr ""
"Obsoleto. Habilite el modo rpido si se establece en un valor verdadero. El "
"modo rpido deshabilita el uso de memo, por lo tanto, acelera el proceso de "
"`pickling` al no generar cdigos de operacin PUT superfluos. No debe usarse "
"con objetos autorreferenciales; de lo contrario, la clase :class:`Pickler` "
"se repetir infinitamente."

#: ../Doc/library/pickle.rst:391
msgid "Use :func:`pickletools.optimize` if you need more compact pickles."
msgstr "Use :func:`pickletools.optimize` si necesita `pickles` ms compactos."

#: ../Doc/library/pickle.rst:396
msgid "This takes a binary file for reading a pickle data stream."
msgstr "Esto toma un archivo binario para leer un flujo de datos de `pickle`."

#: ../Doc/library/pickle.rst:398
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed."
msgstr ""
"La versin de protocolo de `pickle` se detecta automticamente, por lo que "
"no se necesita ningn argumento de protocolo."

#: ../Doc/library/pickle.rst:401
msgid ""
"The argument *file* must have three methods, a read() method that takes an "
"integer argument, a readinto() method that takes a buffer argument and a "
"readline() method that requires no arguments, as in the :class:`io."
"BufferedIOBase` interface.  Thus *file* can be an on-disk file opened for "
"binary reading, an :class:`io.BytesIO` object, or any other custom object "
"that meets this interface."
msgstr ""
"El argumento *file* debe tener tres mtodos, un mtodo read() que toma un "
"argumento entero, un mtodo `readinto()` que toma un argumento bfer y un "
"mtodo `readline()` que no requiere argumentos, como en la interfaz :class:"
"`io.BufferedIOBase`.  Por lo tanto *file* puede ser un archivo en disco "
"abierto para lectura binaria, un objeto :class:`io.BytesIO`, o cualquier "
"otro objeto personalizado que cumpla con esta interfaz."

#: ../Doc/library/pickle.rst:408
msgid ""
"The optional arguments *fix_imports*, *encoding* and *errors* are used to "
"control compatibility support for pickle stream generated by Python 2. If "
"*fix_imports* is true, pickle will try to map the old Python 2 names to the "
"new names used in Python 3.  The *encoding* and *errors* tell pickle how to "
"decode 8-bit string instances pickled by Python 2; these default to 'ASCII' "
"and 'strict', respectively.  The *encoding* can be 'bytes' to read these 8-"
"bit string instances as bytes objects. Using ``encoding='latin1'`` is "
"required for unpickling NumPy arrays and instances of :class:`~datetime."
"datetime`, :class:`~datetime.date` and :class:`~datetime.time` pickled by "
"Python 2."
msgstr ""
"Los argumentos opcionales *fix_imports*, *encoding* and *errors* se utilizan "
"para controlar el soporte de compatibilidad para el flujo de `pickle` "
"generado por Python 2. Si *fix_imports* es verdadero, `pickle` intentar "
"asignar los nombres antiguos de Python 2 a los nuevos nombres utilizados en "
"Python 3.  Tanto *encoding* como *errors* le indican a `pickle` cmo "
"decodificar instancias de cadenas de 8 bits seleccionadas por Python 2; "
"estos son predeterminados a 'ASCII' y 'strict', respectivamente.  *encoding* "
"puede ser 'bytes' para leer estas instancias de cadena de 8 bits como "
"objetos de bytes. Se requiere el uso de ``encoding='latin1'`` para realizar "
"el `unpickling` de arreglos de NumPy e instancias de :class:`~datetime."
"datetime`, :class:`~datetime.date` y :class:`~datetime.time` serializados "
"con `pickle` por Python 2."

#: ../Doc/library/pickle.rst:419
msgid ""
"If *buffers* is None (the default), then all data necessary for "
"deserialization must be contained in the pickle stream.  This means that the "
"*buffer_callback* argument was None when a :class:`Pickler` was instantiated "
"(or when :func:`dump` or :func:`dumps` was called)."
msgstr ""
"Si *buffers* es None (el valor predeterminado), todos los datos necesarios "
"para la deserializacin deben estar contenidos en el flujo de `pickle`.  "
"Esto significa que el argumento *buffer_callback* era None cuando se "
"instanciaba una clase :class:`Pickler` (o cuando se llamaba a :func:`dump` "
"o :func:`dumps`)."

#: ../Doc/library/pickle.rst:424
msgid ""
"If *buffers* is not None, it should be an iterable of buffer-enabled objects "
"that is consumed each time the pickle stream references an :ref:`out-of-band "
"<pickle-oob>` buffer view.  Such buffers have been given in order to the "
"*buffer_callback* of a Pickler object."
msgstr ""
"Si *buffers* no es None, debera ser un iterable de objetos habilitados para "
"almacenamiento intermedio que se consumen cada vez que el flujo de `pickle` "
"hace referencia a una vista de buffer fuera de banda (:ref:`out-of-band "
"<pickle-oob>`).  Tales buffers se han dado para el *buffer_callback* de un "
"objeto `Pickler`."

#: ../Doc/library/pickle.rst:434
msgid ""
"Read the pickled representation of an object from the open file object given "
"in the constructor, and return the reconstituted object hierarchy specified "
"therein.  Bytes past the pickled representation of the object are ignored."
msgstr ""
"Lee la representacin serializada con `pickle` de un objeto desde el objeto "
"de archivo abierto dado en el constructor, y devuelva la jerarqua de "
"objetos reconstituidos especificada all.  Los Bytes ms all de la "
"representacin serializada con `pickle` del objeto se ignoran."

#: ../Doc/library/pickle.rst:441
msgid "Raise an :exc:`UnpicklingError` by default."
msgstr "Lanza un :exc:`UnpicklingError` de forma predeterminada."

#: ../Doc/library/pickle.rst:443
msgid ""
"If defined, :meth:`persistent_load` should return the object specified by "
"the persistent ID *pid*.  If an invalid persistent ID is encountered, an :"
"exc:`UnpicklingError` should be raised."
msgstr ""
"Si se define, :meth:`persistent_load` debera devolver el objeto "
"especificado por el ID persistente *pid*.  Si se encuentra un ID persistente "
"no vlido, se debe lanzar un :exc:`UnpicklingError`."

#: ../Doc/library/pickle.rst:451
msgid ""
"Import *module* if necessary and return the object called *name* from it, "
"where the *module* and *name* arguments are :class:`str` objects.  Note, "
"unlike its name suggests, :meth:`find_class` is also used for finding "
"functions."
msgstr ""
"Importa *module* si es necesario y devuelve el objeto llamado *name* desde "
"el, donde los argumentos *module* y *name* son objetos de :class:`str`.  "
"Tenga en cuenta que, a diferencia de lo que sugiere su nombre, :meth:"
"`find_class` tambin se usa para buscar funciones."

#: ../Doc/library/pickle.rst:456
msgid ""
"Subclasses may override this to gain control over what type of objects and "
"how they can be loaded, potentially reducing security risks. Refer to :ref:"
"`pickle-restrict` for details."
msgstr ""
"Las subclases pueden sobreescribir esto para obtener control sobre qu tipo "
"de objetos y cmo se pueden cargar, reduciendo potencialmente los riesgos de "
"seguridad. Consulte :ref:`pickle-restrict` para obtener ms detalles."

#: ../Doc/library/pickle.rst:460
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pickle.find_class`` with "
"arguments ``module``, ``name``."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``pickle.find_class`` con "
"argumentos ``module``, ``name``."

#: ../Doc/library/pickle.rst:464
msgid ""
"A wrapper for a buffer representing picklable data.  *buffer* must be a :ref:"
"`buffer-providing <bufferobjects>` object, such as a :term:`bytes-like "
"object` or a N-dimensional array."
msgstr ""
"Un envoltorio (`wrapper`) para un bfer que representa datos serializables "
"con `pickle` (`picklable data`).  *buffer* debe ser un objeto que "
"proporciona un bfer (:ref:`buffer-providing <bufferobjects>`), como objeto "
"tipo binario (:term:`bytes-like object`) o un arreglo N-dimensional."

#: ../Doc/library/pickle.rst:468
msgid ""
":class:`PickleBuffer` is itself a buffer provider, therefore it is possible "
"to pass it to other APIs expecting a buffer-providing object, such as :class:"
"`memoryview`."
msgstr ""
":class:`PickleBuffer` es en s mismo un proveedor de bfer, por lo que es "
"posible pasarlo a otras API que esperan un objeto que provea un bfer, como :"
"class:`memoryview`."

#: ../Doc/library/pickle.rst:472
msgid ""
":class:`PickleBuffer` objects can only be serialized using pickle protocol 5 "
"or higher.  They are eligible for :ref:`out-of-band serialization <pickle-"
"oob>`."
msgstr ""
"Los objetos :class:`PickleBuffer` solo se pueden serializar usando el "
"protocolo `pickle` 5 o superior.  Son elegibles para serializacin fuera de "
"banda (:ref:`out-of-band serialization <pickle-oob>`)."

#: ../Doc/library/pickle.rst:480
msgid ""
"Return a :class:`memoryview` of the memory area underlying this buffer. The "
"returned object is a one-dimensional, C-contiguous memoryview with format "
"``B`` (unsigned bytes).  :exc:`BufferError` is raised if the buffer is "
"neither C- nor Fortran-contiguous."
msgstr ""
"Devuelve un :class:`memoryview` del rea de memoria subyacente a este bfer. "
"El objeto devuelto es una vista de memoria unidimensional, C-contigua con "
"formato ``B`` (bytes sin firmar).  :exc:`BufferError` es lanzado si el bfer "
"no es contiguo a C ni a Fortran."

#: ../Doc/library/pickle.rst:487
msgid "Release the underlying buffer exposed by the PickleBuffer object."
msgstr "Libera el bfer subyacente expuesto por el objeto PickleBuffer."

#: ../Doc/library/pickle.rst:493
msgid "What can be pickled and unpickled?"
msgstr ""
"Qu se puede serializar (pickled) y deserializar (unpickled) con `pickle`?"

#: ../Doc/library/pickle.rst:495
msgid "The following types can be pickled:"
msgstr "Los siguientes tipos se pueden serializar con `pickle` (pickled):"

#: ../Doc/library/pickle.rst:497
msgid "``None``, ``True``, and ``False``"
msgstr "``None``, ``True``, y ``False``"

#: ../Doc/library/pickle.rst:499
msgid "integers, floating point numbers, complex numbers"
msgstr "enteros, nmeros de coma flotante, nmeros complejos"

#: ../Doc/library/pickle.rst:501
msgid "strings, bytes, bytearrays"
msgstr "cadenas, bytes, bytearrays"

#: ../Doc/library/pickle.rst:503
msgid "tuples, lists, sets, and dictionaries containing only picklable objects"
msgstr ""
"tuplas, listas, conjuntos y diccionarios que contiene solo objetos "
"serializables con `pickle`"

#: ../Doc/library/pickle.rst:505
msgid ""
"functions defined at the top level of a module (using :keyword:`def`, not :"
"keyword:`lambda`)"
msgstr ""
"funciones definidas en el nivel superior de un mdulo (usando :keyword:"
"`def`, no :keyword:`lambda`)"

#: ../Doc/library/pickle.rst:508
msgid "built-in functions defined at the top level of a module"
msgstr "funciones integradas definidas en el nivel superior de un mdulo"

#: ../Doc/library/pickle.rst:510
msgid "classes that are defined at the top level of a module"
msgstr "clases que se definen en el nivel superior de un mdulo"

#: ../Doc/library/pickle.rst:512
msgid ""
"instances of such classes whose :attr:`~object.__dict__` or the result of "
"calling :meth:`__getstate__` is picklable  (see section :ref:`pickle-inst` "
"for details)."
msgstr ""
"instancias de tales clases cuyo :attr:`~object.__dict__` o el resultado de "
"llamar a :meth:`__getstate__` es serializable con `pickle` (picklable)  "
"(consulte la seccin :ref:`pickle-inst` para obtener ms detalles)."

#: ../Doc/library/pickle.rst:516
msgid ""
"Attempts to pickle unpicklable objects will raise the :exc:`PicklingError` "
"exception; when this happens, an unspecified number of bytes may have "
"already been written to the underlying file.  Trying to pickle a highly "
"recursive data structure may exceed the maximum recursion depth, a :exc:"
"`RecursionError` will be raised in this case.  You can carefully raise this "
"limit with :func:`sys.setrecursionlimit`."
msgstr ""
"Los intentos de serializar objetos no serializables con `pickle` lanzaran la "
"excepcin :exc:`PicklingError`; cuando esto sucede, es posible que ya se "
"haya escrito una cantidad no especificada de bytes en el archivo "
"subyacente.  Intentar serializar con `pickle` una estructura de datos "
"altamente recursiva puede exceder la profundidad mxima de recursividad, en "
"este caso se lanzar  un :exc:`RecursionError`.  Puede aumentar "
"cuidadosamente este lmite con :func:`sys.setrecursionlimit`."

#: ../Doc/library/pickle.rst:523
msgid ""
"Note that functions (built-in and user-defined) are pickled by \"fully "
"qualified\" name reference, not by value. [#]_  This means that only the "
"function name is pickled, along with the name of the module the function is "
"defined in.  Neither the function's code, nor any of its function attributes "
"are pickled.  Thus the defining module must be importable in the unpickling "
"environment, and the module must contain the named object, otherwise an "
"exception will be raised. [#]_"
msgstr ""
"Tenga en cuenta que las funciones (integradas y definidas por el usuario) se "
"serializan con `pickle` por referencia de nombre \"totalmente calificado\", "
"no por valor. [#]_  Esto significa que solo se serializa con `pickle` el "
"nombre de la funcin, junto con el nombre del mdulo en el que est definida "
"la funcin.  Ni el cdigo de la funcin, ni ninguno de sus atributos de "
"funcin se serializa.  Por lo tanto, el mdulo de definicin debe ser "
"importable en el entorno donde se har el `unpickling`, y el mdulo debe "
"contener el objeto nombrado; de lo contrario, se lanzar una excepcin. [#]_"

#: ../Doc/library/pickle.rst:530
msgid ""
"Similarly, classes are pickled by named reference, so the same restrictions "
"in the unpickling environment apply.  Note that none of the class's code or "
"data is pickled, so in the following example the class attribute ``attr`` is "
"not restored in the unpickling environment::"
msgstr ""
"De manera similar, las clases se serializan con `pickle` por referencia con "
"nombre, por lo que se aplican las mismas restricciones en el entorno donde "
"se har el `unpickling`.  Tenga en cuenta que ninguno de los datos o el "
"cdigo de la clase son serializados con `pickle`, por lo que en el siguiente "
"ejemplo el atributo de clase ``attr`` no se restaura en el entorno donde se "
"har el `unpickling`::"

#: ../Doc/library/pickle.rst:540
msgid ""
"These restrictions are why picklable functions and classes must be defined "
"in the top level of a module."
msgstr ""
"Estas restricciones son la razn por la que las funciones y clases "
"serializables con `pickle` deben definirse en el nivel superior de un mdulo."

#: ../Doc/library/pickle.rst:543
msgid ""
"Similarly, when class instances are pickled, their class's code and data are "
"not pickled along with them.  Only the instance data are pickled.  This is "
"done on purpose, so you can fix bugs in a class or add methods to the class "
"and still load objects that were created with an earlier version of the "
"class.  If you plan to have long-lived objects that will see many versions "
"of a class, it may be worthwhile to put a version number in the objects so "
"that suitable conversions can be made by the class's :meth:`__setstate__` "
"method."
msgstr ""
"De manera similar, cuando las instancias de clases son serializadas con "
"`pickle`, el cdigo y los datos de la clase no son serializadas junto con "
"ella.  Solo los datos de la instancia son serializados con `pickle` "
"(`pickled`).  Esto se hace a propsito, por lo que puede corregir errores en "
"una clase o agregar mtodos a la clase y an cargar objetos que fueron "
"creados con una versin anterior de la clase.  Si planea tener objetos de "
"larga duracin que vern muchas versiones de una clase, puede valer la pena "
"poner un nmero de versin en los objetos para que las conversiones "
"adecuadas se puedan realizar mediante el mtodo :meth:`__setstate__`."

#: ../Doc/library/pickle.rst:555
msgid "Pickling Class Instances"
msgstr "`Pickling` de Instancias de clases"

#: ../Doc/library/pickle.rst:559
msgid ""
"In this section, we describe the general mechanisms available to you to "
"define, customize, and control how class instances are pickled and unpickled."
msgstr ""
"En esta seccin, describimos los mecanismos generales disponibles para que "
"usted defina, personalice y controle cmo se serializan y deserializan con "
"`Pickle` las instancias de clase."

#: ../Doc/library/pickle.rst:562
msgid ""
"In most cases, no additional code is needed to make instances picklable.  By "
"default, pickle will retrieve the class and the attributes of an instance "
"via introspection. When a class instance is unpickled, its :meth:`__init__` "
"method is usually *not* invoked.  The default behaviour first creates an "
"uninitialized instance and then restores the saved attributes.  The "
"following code shows an implementation of this behaviour::"
msgstr ""
"En la mayora de los casos, no se necesita cdigo adicional para hacer que "
"las instancias sean `picklable` (serializables con `pickle`).  Por defecto, "
"`pickle` recuperar la clase y los atributos de una instancia a travs de la "
"introspeccin. Cuando una instancia de clase es deserializada con `pickle` "
"(`unpickled`), su mtodo :meth:`__init__` generalmente *no* se invoca.  El "
"comportamiento predeterminado es que primero crea una instancia no "
"inicializada y luego restaura los atributos guardados.  El siguiente cdigo "
"muestra una implementacin de este comportamiento::"

#: ../Doc/library/pickle.rst:577
msgid ""
"Classes can alter the default behaviour by providing one or several special "
"methods:"
msgstr ""
"Las clases pueden alterar el comportamiento predeterminado proporcionando "
"uno o varios mtodos especiales:"

#: ../Doc/library/pickle.rst:582
msgid ""
"In protocols 2 and newer, classes that implements the :meth:"
"`__getnewargs_ex__` method can dictate the values passed to the :meth:"
"`__new__` method upon unpickling.  The method must return a pair ``(args, "
"kwargs)`` where *args* is a tuple of positional arguments and *kwargs* a "
"dictionary of named arguments for constructing the object.  Those will be "
"passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"En los protocolos 2 y ms recientes, las clases que implementan el mtodo :"
"meth:`__getnewargs_ex__` pueden dictar los valores pasados al mtodo :meth:"
"`__new__` al hacer`unpickling`.  El mtodo debe devolver un par ``(args, "
"kwargs)`` donde *args* es una tupla de argumentos posicionales y *kwargs* un "
"diccionario de argumentos con nombre para construir el objeto.  Estos se "
"pasarn al mtodo :meth:`__new__` al hacer `unpickling`."

#: ../Doc/library/pickle.rst:590
msgid ""
"You should implement this method if the :meth:`__new__` method of your class "
"requires keyword-only arguments.  Otherwise, it is recommended for "
"compatibility to implement :meth:`__getnewargs__`."
msgstr ""
"Debes implementar este mtodo si el mtodo :meth:`__new__` de tu clase "
"requiere argumentos de solo palabras clave.  De lo contrario, se recomienda "
"para la compatibilidad implementar :meth:`__getnewargs__`."

#: ../Doc/library/pickle.rst:594
msgid ":meth:`__getnewargs_ex__` is now used in protocols 2 and 3."
msgstr ":meth:`__getnewargs_ex__` ahora se usa en los protocolos 2 y 3."

#: ../Doc/library/pickle.rst:600
msgid ""
"This method serves a similar purpose as :meth:`__getnewargs_ex__`, but "
"supports only positional arguments.  It must return a tuple of arguments "
"``args`` which will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"Este mtodo tiene un propsito similar a :meth:`__getnewargs_ex__`, pero "
"solo admite argumentos posicionales.  Debe devolver una tupla de argumentos "
"``args`` que se pasarn al mtodo :meth:`__new__` al hacer `unpickling`."

#: ../Doc/library/pickle.rst:604
msgid ""
":meth:`__getnewargs__` will not be called if :meth:`__getnewargs_ex__` is "
"defined."
msgstr ""
":meth:`__getnewargs__` no se llamar si :meth:`__getnewargs_ex__` est "
"definido."

#: ../Doc/library/pickle.rst:607
msgid ""
"Before Python 3.6, :meth:`__getnewargs__` was called instead of :meth:"
"`__getnewargs_ex__` in protocols 2 and 3."
msgstr ""
"Antes de Python 3.6, se llamaba a, :meth:`__getnewargs__` en lugar de :meth:"
"`__getnewargs_ex__` en los protocolos 2 y 3."

#: ../Doc/library/pickle.rst:614
msgid ""
"Classes can further influence how their instances are pickled; if the class "
"defines the method :meth:`__getstate__`, it is called and the returned "
"object is pickled as the contents for the instance, instead of the contents "
"of the instance's dictionary.  If the :meth:`__getstate__` method is absent, "
"the instance's :attr:`~object.__dict__` is pickled as usual."
msgstr ""
"Las clases pueden influir an ms en cmo sus instancias se serializan con "
"`pickle`; si la clase define el mtodo :meth:`__getstate__`, este es llamado "
"y el objeto devuelto se selecciona como contenido de la instancia, en lugar "
"del contenido del diccionario de la instancia.  Si el mtodo :meth:"
"`__getstate__` est ausente, el :attr:`~object.__dict__` de la instancia se "
"conserva como de costumbre."

#: ../Doc/library/pickle.rst:623
msgid ""
"Upon unpickling, if the class defines :meth:`__setstate__`, it is called "
"with the unpickled state.  In that case, there is no requirement for the "
"state object to be a dictionary.  Otherwise, the pickled state must be a "
"dictionary and its items are assigned to the new instance's dictionary."
msgstr ""
"Al hacer `unpickling`, si la clase define :meth:`__setstate__`, este es "
"llamado con el estado `unpickled` (no serializado con `pickle`).  En ese "
"caso, no es necesario que el objeto de estado sea un diccionario.  De lo "
"contrario, el estado `pickled` (`pickled state`) debe ser un diccionario y "
"sus elementos se asignan al diccionario de la nueva instancia."

#: ../Doc/library/pickle.rst:630
msgid ""
"If :meth:`__getstate__` returns a false value, the :meth:`__setstate__` "
"method will not be called upon unpickling."
msgstr ""
"Si :meth:`__getstate__` devuelve un valor falso, el mtodo :meth:"
"`__setstate__` no se llamar al hacer `unpickling`."

#: ../Doc/library/pickle.rst:634
msgid ""
"Refer to the section :ref:`pickle-state` for more information about how to "
"use the methods :meth:`__getstate__` and :meth:`__setstate__`."
msgstr ""
"Consulte la seccin :ref:`pickle-state` para obtener ms informacin sobre "
"cmo utilizar los mtodos :meth:`__getstate__` y :meth:`__setstate__`."

#: ../Doc/library/pickle.rst:639
msgid ""
"At unpickling time, some methods like :meth:`__getattr__`, :meth:"
"`__getattribute__`, or :meth:`__setattr__` may be called upon the instance.  "
"In case those methods rely on some internal invariant being true, the type "
"should implement :meth:`__new__` to establish such an invariant, as :meth:"
"`__init__` is not called when unpickling an instance."
msgstr ""
"Al momento de hacer `unpickling`, algunos mtodos como :meth:`__getattr__`, :"
"meth:`__getattribute__`, o :meth:`__setattr__` pueden invocarse sobre la "
"instancia.  En caso de que esos mtodos dependan de que algn invariante "
"interno sea verdadero, el tipo debera implementar :meth:`__new__` para "
"establecer tal invariante, ya que :meth:`__init__` no se llama cuando se "
"hace `unpickling` de una instancia."

#: ../Doc/library/pickle.rst:648
msgid ""
"As we shall see, pickle does not use directly the methods described above.  "
"In fact, these methods are part of the copy protocol which implements the :"
"meth:`__reduce__` special method.  The copy protocol provides a unified "
"interface for retrieving the data necessary for pickling and copying "
"objects. [#]_"
msgstr ""
"Como veremos, `pickle` no utiliza directamente los mtodos descritos "
"anteriormente.  De hecho, estos mtodos son parte del protocolo de copia que "
"implementa el mtodo especial :meth:`__reduce__`.  El protocolo de copia "
"proporciona una interfaz unificada para recuperar los datos necesarios para "
"hacer el `pickling` y la copia de objetos. [#]_"

#: ../Doc/library/pickle.rst:654
msgid ""
"Although powerful, implementing :meth:`__reduce__` directly in your classes "
"is error prone.  For this reason, class designers should use the high-level "
"interface (i.e., :meth:`__getnewargs_ex__`, :meth:`__getstate__` and :meth:"
"`__setstate__`) whenever possible.  We will show, however, cases where "
"using :meth:`__reduce__` is the only option or leads to more efficient "
"pickling or both."
msgstr ""
"Aunque es poderoso, implementar :meth:`__reduce__` directamente en sus "
"clases es propenso a errores.  Por esta razn, los diseadores de clases "
"deben usar la interfaz de alto nivel (es decir, :meth:`__getnewargs_ex__`, :"
"meth:`__getstate__` y :meth:`__setstate__`) siempre que sea posible.  Sin "
"embargo, mostraremos casos en los que usar :meth:`__reduce__` es la nica "
"opcin o conduce a un `pickling` ms eficiente o ambos."

#: ../Doc/library/pickle.rst:663
msgid ""
"The interface is currently defined as follows.  The :meth:`__reduce__` "
"method takes no argument and shall return either a string or preferably a "
"tuple (the returned object is often referred to as the \"reduce value\")."
msgstr ""
"La interfaz se define actualmente de la siguiente manera. El mtodo :meth:"
"`__reduce__` no toma ningn argumento y devolver una cadena o "
"preferiblemente una tupla (el objeto devuelto a menudo se denomina \"valor "
"reducido\")."

#: ../Doc/library/pickle.rst:667
msgid ""
"If a string is returned, the string should be interpreted as the name of a "
"global variable.  It should be the object's local name relative to its "
"module; the pickle module searches the module namespace to determine the "
"object's module.  This behaviour is typically useful for singletons."
msgstr ""
"Si se devuelve una cadena, la cadena debe interpretarse como el nombre de "
"una variable global.  Debe ser el nombre local del objeto relativo a su "
"mdulo; el mdulo `pickle` busca en el espacio de nombres del mdulo para "
"determinar el mdulo del objeto. Este comportamiento suele ser til para "
"singletons."

#: ../Doc/library/pickle.rst:672
msgid ""
"When a tuple is returned, it must be between two and six items long. "
"Optional items can either be omitted, or ``None`` can be provided as their "
"value.  The semantics of each item are in order:"
msgstr ""
"Cuando se devuelve una tupla, debe tener entre dos y seis elementos. Los "
"elementos opcionales se pueden omitir o se puede proporcionar ``None`` como "
"su valor.  La semntica de cada elemento est en orden:"

#: ../Doc/library/pickle.rst:678
msgid ""
"A callable object that will be called to create the initial version of the "
"object."
msgstr ""
"Un objeto invocable que se llamar para crear la versin inicial del objeto."

#: ../Doc/library/pickle.rst:681
msgid ""
"A tuple of arguments for the callable object.  An empty tuple must be given "
"if the callable does not accept any argument."
msgstr ""
"Una tupla de argumentos para el objeto invocable. Se debe proporcionar una "
"tupla vaca si el invocable no acepta ningn argumento."

#: ../Doc/library/pickle.rst:684
msgid ""
"Optionally, the object's state, which will be passed to the object's :meth:"
"`__setstate__` method as previously described.  If the object has no such "
"method then, the value must be a dictionary and it will be added to the "
"object's :attr:`~object.__dict__` attribute."
msgstr ""
"Opcionalmente, el estado del objeto, que se pasar al mtodo :meth:"
"`__setstate__` del objeto como se describi anteriormente. Si el objeto no "
"tiene dicho mtodo, el valor debe ser un diccionario y se agregar al "
"atributo :attr:`~object.__dict__` del objeto."

#: ../Doc/library/pickle.rst:689
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive items. "
"These items will be appended to the object either using ``obj.append(item)`` "
"or, in batch, using ``obj.extend(list_of_items)``. This is primarily used "
"for list subclasses, but may be used by other classes as long as they have :"
"meth:`append` and :meth:`extend` methods with the appropriate signature.  "
"(Whether :meth:`append` or :meth:`extend` is used depends on which pickle "
"protocol version is used as well as the number of items to append, so both "
"must be supported.)"
msgstr ""
"Opcionalmente, un iterador (y no una secuencia) produce elementos sucesivos. "
"Estos elementos se agregarn al objeto usando ``obj.append(item)`` o, por "
"lotes, usando ``obj.extend(list_of_items)``. Esto se usa principalmente para "
"subclases de lista, pero puede ser usado por otras clases siempre que tengan "
"los mtodos :meth:`append` y :meth:`extend` con la firma apropiada.  (El uso "
"de :meth:`append` o :meth:`extend` depende de la versin del protocolo "
"`pickle` que se use, as como de la cantidad de elementos que se agregarn, "
"por lo que ambos deben ser soportados.)"

#: ../Doc/library/pickle.rst:698
msgid ""
"Optionally, an iterator (not a sequence) yielding successive key-value "
"pairs.  These items will be stored to the object using ``obj[key] = "
"value``.  This is primarily used for dictionary subclasses, but may be used "
"by other classes as long as they implement :meth:`__setitem__`."
msgstr ""
"Opcionalmente, un iterador (no una secuencia) que produce pares clave-valor "
"sucesivos.  Estos elementos se almacenarn en el objeto usando ``obj[key] = "
"value``.  Esto se usa principalmente para subclases de diccionario, pero "
"otras clases pueden usarlo siempre que implementen :meth:`__setitem__`."

#: ../Doc/library/pickle.rst:703
msgid ""
"Optionally, a callable with a ``(obj, state)`` signature. This callable "
"allows the user to programmatically control the state-updating behavior of a "
"specific object, instead of using ``obj``'s static :meth:`__setstate__` "
"method. If not ``None``, this callable will have priority over ``obj``'s :"
"meth:`__setstate__`."
msgstr ""
"Opcionalmente, un invocable con una firma ``(obj, state)``. Este invocable "
"permite al usuario controlar programticamente el comportamiento de "
"actualizacin de estado de un objeto especfico, en lugar de usar el mtodo "
"esttico de ``obj`` :meth:`__setstate__`. Si no es ``None``, este invocable "
"tendr prioridad sobre ``obj``'s :meth:`__setstate__`."

#: ../Doc/library/pickle.rst:709
msgid "The optional sixth tuple item, ``(obj, state)``, was added."
msgstr "Se agreg el sexto elemento opcional de tupla ``(obj, state)``."

#: ../Doc/library/pickle.rst:715
msgid ""
"Alternatively, a :meth:`__reduce_ex__` method may be defined.  The only "
"difference is this method should take a single integer argument, the "
"protocol version.  When defined, pickle will prefer it over the :meth:"
"`__reduce__` method.  In addition, :meth:`__reduce__` automatically becomes "
"a synonym for the extended version.  The main use for this method is to "
"provide backwards-compatible reduce values for older Python releases."
msgstr ""
"Alternativamente, se puede definir un mtodo :meth:`__reduce_ex__`.  La "
"nica diferencia es que este mtodo debe tomar un nico argumento entero, la "
"versin del protocolo.  Cuando est definido, `pickle` lo preferir en lugar "
"del mtodo :meth:`__reduce__`.  Adems, :meth:`__reduce__` se convierte "
"automticamente en sinnimo de la versin extendida.  El uso principal de "
"este mtodo es proporcionar valores reducidos compatibles con versiones "
"anteriores para versiones anteriores de Python."

#: ../Doc/library/pickle.rst:727
msgid "Persistence of External Objects"
msgstr "Persistencia de objetos externos"

#: ../Doc/library/pickle.rst:733
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports the "
"notion of a reference to an object outside the pickled data stream.  Such "
"objects are referenced by a persistent ID, which should be either a string "
"of alphanumeric characters (for protocol 0) [#]_ or just an arbitrary object "
"(for any newer protocol)."
msgstr ""
"Para el beneficio de la persistencia del objeto, el mdulo :mod:`pickle` "
"admite la nocin de una referencia a un objeto fuera del flujo de datos "
"serializados con `pickle`.  Dichos objetos son referenciados por un ID "
"persistente, que debe ser una cadena de caracteres alfanumricos (para el "
"protocolo 0) [#]_ o simplemente un objeto arbitrario (para cualquier "
"protocolo ms nuevo)."

#: ../Doc/library/pickle.rst:739
msgid ""
"The resolution of such persistent IDs is not defined by the :mod:`pickle` "
"module; it will delegate this resolution to the user-defined methods on the "
"pickler and unpickler, :meth:`~Pickler.persistent_id` and :meth:`~Unpickler."
"persistent_load` respectively."
msgstr ""
"La resolucin de tales ID persistentes no est definida por el mdulo :mod:"
"`pickle`; delegar esta resolucin a los mtodos definidos por el usuario en "
"el `pickler` y el `unpickler`, :meth:`~Pickler.persistent_id` y :meth:"
"`~Unpickler.persistent_load` respectivamente."

#: ../Doc/library/pickle.rst:744
msgid ""
"To pickle objects that have an external persistent ID, the pickler must have "
"a custom :meth:`~Pickler.persistent_id` method that takes an object as an "
"argument and returns either ``None`` or the persistent ID for that object. "
"When ``None`` is returned, the pickler simply pickles the object as normal. "
"When a persistent ID string is returned, the pickler will pickle that "
"object, along with a marker so that the unpickler will recognize it as a "
"persistent ID."
msgstr ""
"Para seleccionar objetos que tienen una ID persistente externo, el `pickler` "
"debe tener un mtodo personalizado :meth:`~Pickler.persistent_id` que toma "
"un objeto como argumento y devuelve ``None`` o el ID persistente para ese "
"objeto. Cuando se devuelve ``None``, el `pickler` simplemente serializar el "
"objeto de forma normal. Cuando se devuelve una cadena de identificacin "
"persistente, el `pickler` serializar ese objeto, junto con un marcador para "
"que el `unpickler` lo reconozca como una identificacin persistente."

#: ../Doc/library/pickle.rst:751
msgid ""
"To unpickle external objects, the unpickler must have a custom :meth:"
"`~Unpickler.persistent_load` method that takes a persistent ID object and "
"returns the referenced object."
msgstr ""
"Para hacer el `unpickling` objetos externos, el `unpickler` debe tener un "
"mtodo personalizado :meth:`~Unpickler.persistent_load` que toma un objeto "
"de identificacin persistente y devuelve el objeto referenciado."

#: ../Doc/library/pickle.rst:755
msgid ""
"Here is a comprehensive example presenting how persistent ID can be used to "
"pickle external objects by reference."
msgstr ""
"Aqu hay un ejemplo completo que presenta cmo se puede usar la "
"identificacin persistente para hacer el `pickling` objetos externos por "
"referencia."

#: ../Doc/library/pickle.rst:763
msgid "Dispatch Tables"
msgstr "Tablas de despacho"

#: ../Doc/library/pickle.rst:765
msgid ""
"If one wants to customize pickling of some classes without disturbing any "
"other code which depends on pickling, then one can create a pickler with a "
"private dispatch table."
msgstr ""
"Si se desea personalizar el `pickling` de algunas clases sin alterar ningn "
"otro cdigo que dependa del `pickling`, se puede crear un `pickler` con una "
"tabla de despacho privada."

#: ../Doc/library/pickle.rst:769
msgid ""
"The global dispatch table managed by the :mod:`copyreg` module is available "
"as :data:`copyreg.dispatch_table`.  Therefore, one may choose to use a "
"modified copy of :data:`copyreg.dispatch_table` as a private dispatch table."
msgstr ""
"La tabla de despacho global administrada por el mdulo :mod:`copyreg` est "
"disponible como :data:`copyreg.dispatch_table`.  Por lo tanto, se puede "
"optar por utilizar una copia modificada de :data:`copyreg.dispatch_table` "
"como tabla de envo privada."

#: ../Doc/library/pickle.rst:774
msgid "For example ::"
msgstr "Por ejemplo ::"

#: ../Doc/library/pickle.rst:781
msgid ""
"creates an instance of :class:`pickle.Pickler` with a private dispatch table "
"which handles the ``SomeClass`` class specially.  Alternatively, the code ::"
msgstr ""
"crea una instancia de :class:`pickle.Pickler` con una tabla de despacho "
"privada que maneja la clase ``AlgunaClase`` especialmente.  "
"Alternativamente, el cdigo ::"

#: ../Doc/library/pickle.rst:791
msgid ""
"does the same, but all instances of ``MyPickler`` will by default share the "
"same dispatch table.  The equivalent code using the :mod:`copyreg` module "
"is ::"
msgstr ""
"hace lo mismo, pero todas las instancias de ``MiPickler`` compartirn por "
"defecto la misma tabla de despacho. El cdigo equivalente que usa el mdulo :"
"mod:`copyreg` es ::"

#: ../Doc/library/pickle.rst:802
msgid "Handling Stateful Objects"
msgstr "Manejo de objetos con estado"

#: ../Doc/library/pickle.rst:808
msgid ""
"Here's an example that shows how to modify pickling behavior for a class. "
"The :class:`TextReader` class opens a text file, and returns the line number "
"and line contents each time its :meth:`!readline` method is called. If a :"
"class:`TextReader` instance is pickled, all attributes *except* the file "
"object member are saved. When the instance is unpickled, the file is "
"reopened, and reading resumes from the last location. The :meth:"
"`__setstate__` and :meth:`__getstate__` methods are used to implement this "
"behavior. ::"
msgstr ""
"Aqu hay un ejemplo que muestra cmo modificar el comportamiento del "
"`pickling` de una clase. La clase :class:`TextReader` abre un archivo de "
"texto y devuelve el nmero de lnea y el contenido de la lnea cada vez que "
"se llama a su mtodo :meth:`!readline` . Si se selecciona una instancia de :"
"class:`TextReader` se guardan todos los atributos *excepto* el miembro del "
"objeto de archivo. Cuando se hace el `unpickling` de la instancia, el "
"archivo se vuelve a abrir y la lectura se reanuda desde la ltima ubicacin. "
"Los mtodos :meth:`__setstate__` y :meth:`__getstate__` se utilizan para "
"implementar este comportamiento. ::"

#: ../Doc/library/pickle.rst:854
msgid "A sample usage might be something like this::"
msgstr "Un ejemplo de uso podra ser algo como esto::"

#: ../Doc/library/pickle.rst:868
msgid "Custom Reduction for Types, Functions, and Other Objects"
msgstr "Reduccin personalizada para tipos, funciones y otros objetos"

#: ../Doc/library/pickle.rst:872
msgid ""
"Sometimes, :attr:`~Pickler.dispatch_table` may not be flexible enough. In "
"particular we may want to customize pickling based on another criterion than "
"the object's type, or we may want to customize the pickling of functions and "
"classes."
msgstr ""
"A veces, :attr:`~Pickler.dispatch_table` puede no ser lo suficientemente "
"flexible. En particular, es posible que deseemos personalizar el `pickling` "
"en funcin de otro criterio que no sea el tipo de objeto, o es posible que "
"deseemos personalizar el `pickling` de funciones y clases."

#: ../Doc/library/pickle.rst:877
msgid ""
"For those cases, it is possible to subclass from the :class:`Pickler` class "
"and implement a :meth:`~Pickler.reducer_override` method. This method can "
"return an arbitrary reduction tuple (see :meth:`__reduce__`). It can "
"alternatively return ``NotImplemented`` to fallback to the traditional "
"behavior."
msgstr ""
"Para esos casos, es posible crear una subclase de la clase :class:`Pickler` "
"e implementar el mtodo :meth:`~Pickler.reducer_override`. Este mtodo puede "
"devolver una tupla de reduccin arbitraria (ver :meth:`__reduce__`). "
"Alternativamente, puede devolver ``NotImplemented`` para volver al "
"comportamiento tradicional."

#: ../Doc/library/pickle.rst:882
msgid ""
"If both the :attr:`~Pickler.dispatch_table` and :meth:`~Pickler."
"reducer_override` are defined, then :meth:`~Pickler.reducer_override` method "
"takes priority."
msgstr ""
"Si se definen tanto :attr:`~Pickler.dispatch_table` como :meth:`~Pickler."
"reducer_override`, entonces :meth:`~Pickler.reducer_override` tiene "
"prioridad."

#: ../Doc/library/pickle.rst:887
msgid ""
"For performance reasons, :meth:`~Pickler.reducer_override` may not be called "
"for the following objects: ``None``, ``True``, ``False``, and exact "
"instances of :class:`int`, :class:`float`, :class:`bytes`, :class:`str`, :"
"class:`dict`, :class:`set`, :class:`frozenset`, :class:`list` and :class:"
"`tuple`."
msgstr ""
"Por motivos de rendimiento, no se puede llamar a :meth:`~Pickler."
"reducer_override` para los siguientes objetos: ``None``, ``True``, "
"``False``, e instancias exactas de :class:`int`, :class:`float`, :class:"
"`bytes`, :class:`str`, :class:`dict`, :class:`set`, :class:`frozenset`, :"
"class:`list` y :class:`tuple`."

#: ../Doc/library/pickle.rst:893
msgid ""
"Here is a simple example where we allow pickling and reconstructing a given "
"class::"
msgstr ""
"Aqu hay un ejemplo simple donde permitimos el `pickling` y reconstruir una "
"clase dada class::"

#: ../Doc/library/pickle.rst:928
msgid "Out-of-band Buffers"
msgstr "Bferes fuera de banda"

#: ../Doc/library/pickle.rst:932
msgid ""
"In some contexts, the :mod:`pickle` module is used to transfer massive "
"amounts of data.  Therefore, it can be important to minimize the number of "
"memory copies, to preserve performance and resource consumption.  However, "
"normal operation of the :mod:`pickle` module, as it transforms a graph-like "
"structure of objects into a sequential stream of bytes, intrinsically "
"involves copying data to and from the pickle stream."
msgstr ""
"En algunos contextos, el mdulo :mod:`pickle` se usa para transferir "
"cantidades masivas de datos.  Por lo tanto, puede ser importante minimizar "
"el nmero de copias de memoria para preservar el rendimiento y el consumo de "
"recursos.  Sin embargo, el funcionamiento normal del mdulo :mod:`pickle`, "
"ya que transforma una estructura grfica de objetos en un flujo secuencial "
"de bytes, implica intrnsecamente copiar datos hacia y desde el flujo "
"`pickle`."

#: ../Doc/library/pickle.rst:939
msgid ""
"This constraint can be eschewed if both the *provider* (the implementation "
"of the object types to be transferred) and the *consumer* (the "
"implementation of the communications system) support the out-of-band "
"transfer facilities provided by pickle protocol 5 and higher."
msgstr ""
"Esta restriccin puede evitarse si tanto el *proveedor* (la implementacin "
"de los tipos de objeto a transferir) como el *consumidor* (a implementacin "
"del sistema de comunicaciones) admiten las facilidades de transferencia "
"fuera de banda proporcionadas por el protocolo `pickle` 5 y mayor."

#: ../Doc/library/pickle.rst:945
msgid "Provider API"
msgstr "API de proveedor"

#: ../Doc/library/pickle.rst:947
msgid ""
"The large data objects to be pickled must implement a :meth:`__reduce_ex__` "
"method specialized for protocol 5 and higher, which returns a :class:"
"`PickleBuffer` instance (instead of e.g. a :class:`bytes` object) for any "
"large data."
msgstr ""
"Los objetos de datos grandes que se van a serializar con `pickle` deben "
"implementar un mtodo :meth:`__reduce_ex__` especializado para el protocolo "
"5 y superior, que devuelve una instancia de :class:`PickleBuffer` (en lugar "
"de, por ejemplo, un objeto :class:`bytes` object) para cualquier datos."

#: ../Doc/library/pickle.rst:952
msgid ""
"A :class:`PickleBuffer` object *signals* that the underlying buffer is "
"eligible for out-of-band data transfer.  Those objects remain compatible "
"with normal usage of the :mod:`pickle` module.  However, consumers can also "
"opt-in to tell :mod:`pickle` that they will handle those buffers by "
"themselves."
msgstr ""
"Un objeto :class:`PickleBuffer` *indica* que el bfer subyacente es elegible "
"para la transferencia de datos fuera de banda.  Estos objetos siguen siendo "
"compatibles con el uso normal del mdulo :mod:`pickle` .  Sin embargo, los "
"consumidores tambin pueden optar por decirle a :mod:`pickle` que manejarn "
"esos bferes por s mismos."

#: ../Doc/library/pickle.rst:959
msgid "Consumer API"
msgstr "API de consumidor"

#: ../Doc/library/pickle.rst:961
msgid ""
"A communications system can enable custom handling of the :class:"
"`PickleBuffer` objects generated when serializing an object graph."
msgstr ""
"Un sistema de comunicaciones puede permitir el manejo personalizado de los "
"objetos :class:`PickleBuffer` generados al serializar un grfico de objetos."

#: ../Doc/library/pickle.rst:964
msgid ""
"On the sending side, it needs to pass a *buffer_callback* argument to :class:"
"`Pickler` (or to the :func:`dump` or :func:`dumps` function), which will be "
"called with each :class:`PickleBuffer` generated while pickling the object "
"graph.  Buffers accumulated by the *buffer_callback* will not see their data "
"copied into the pickle stream, only a cheap marker will be inserted."
msgstr ""
"En el lado del envo, necesita pasar un argumento *buffer_callback* a :class:"
"`Pickler` (o a las funciones :func:`dump` o :func:`dumps`), que se llamar "
"con cada :class:`PickleBuffer` generado al hacer `pickling` del grfico del "
"objeto.  Los bferes acumulados por *buffer_callback* no vern sus datos "
"copiados en el flujo de `pickle`, solo se insertar un marcador barato."

#: ../Doc/library/pickle.rst:971
msgid ""
"On the receiving side, it needs to pass a *buffers* argument to :class:"
"`Unpickler` (or to the :func:`load` or :func:`loads` function), which is an "
"iterable of the buffers which were passed to *buffer_callback*. That "
"iterable should produce buffers in the same order as they were passed to "
"*buffer_callback*.  Those buffers will provide the data expected by the "
"reconstructors of the objects whose pickling produced the original :class:"
"`PickleBuffer` objects."
msgstr ""
"En el lado receptor, necesita pasar un argumento *buffers* a :class:"
"`Unpickler` (o a las funciones :func:`load` o :func:`loads`), que es un "
"iterable de los bferes que fueron pasado a *buffer_callback*. Ese iterable "
"debera producir bferes en el mismo orden en que se pasaron a "
"*buffer_callback*.   Esos bferes proporcionarn los datos esperados por los "
"reconstructores de los objetos cuyo `pickling` produjo los objetos "
"originales :class:`PickleBuffer`."

#: ../Doc/library/pickle.rst:979
msgid ""
"Between the sending side and the receiving side, the communications system "
"is free to implement its own transfer mechanism for out-of-band buffers. "
"Potential optimizations include the use of shared memory or datatype-"
"dependent compression."
msgstr ""
"Entre el lado de envo y el lado de recepcin, el sistema de comunicaciones "
"es libre de implementar su propio mecanismo de transferencia para memorias "
"intermedias fuera de banda. Las posibles optimizaciones incluyen el uso de "
"memoria compartida o compresin dependiente del tipo de datos."

#: ../Doc/library/pickle.rst:985
msgid "Example"
msgstr "Ejemplo"

#: ../Doc/library/pickle.rst:987
msgid ""
"Here is a trivial example where we implement a :class:`bytearray` subclass "
"able to participate in out-of-band buffer pickling::"
msgstr ""
"Aqu hay un ejemplo trivial donde implementamos una subclase :class:"
"`bytearray` capaz de participar en el `pickling` de un bfer fuera de banda::"

#: ../Doc/library/pickle.rst:1011
msgid ""
"The reconstructor (the ``_reconstruct`` class method) returns the buffer's "
"providing object if it has the right type.  This is an easy way to simulate "
"zero-copy behaviour on this toy example."
msgstr ""
"El reconstructor (el mtodo de clase ``_reconstruct``) devuelve el objeto "
"que proporciona el bfer si tiene el tipo correcto.  Esta es una manera "
"fcil de simular el comportamiento de copia cero en este ejemplo de juguete."

#: ../Doc/library/pickle.rst:1015
msgid ""
"On the consumer side, we can pickle those objects the usual way, which when "
"unserialized will give us a copy of the original object::"
msgstr ""
"En el lado del consumidor, podemos serializar con `pickle` esos objetos de "
"la forma habitual, que cuando no se serializan nos dar una copia del objeto "
"original::"

#: ../Doc/library/pickle.rst:1024
msgid ""
"But if we pass a *buffer_callback* and then give back the accumulated "
"buffers when unserializing, we are able to get back the original object::"
msgstr ""
"Pero si pasamos un *buffer_callback* y luego devolvemos los bferes "
"acumulados al anular la serializacin, podemos recuperar el objeto original::"

#: ../Doc/library/pickle.rst:1034
msgid ""
"This example is limited by the fact that :class:`bytearray` allocates its "
"own memory: you cannot create a :class:`bytearray` instance that is backed "
"by another object's memory.  However, third-party datatypes such as NumPy "
"arrays do not have this limitation, and allow use of zero-copy pickling (or "
"making as few copies as possible) when transferring between distinct "
"processes or systems."
msgstr ""
"Este ejemplo est limitado por el hecho de que :class:`bytearray` asigna su "
"propia memoria: no puedes crear una instancia de :class:`bytearray` que est "
"respaldada por la memoria de otro objeto.  Sin embargo, los tipos de datos "
"de terceros, como las matrices NumPy no tienen esta limitacin y permiten el "
"uso de `pickling` de copia cero (o realizar la menor cantidad de copias "
"posible) cuando se transfieren entre procesos o sistemas distintos."

#: ../Doc/library/pickle.rst:1041
msgid ":pep:`574` -- Pickle protocol 5 with out-of-band data"
msgstr ":pep:`574` -- Protocolo Pickle 5 con datos fuera de banda"

#: ../Doc/library/pickle.rst:1047
msgid "Restricting Globals"
msgstr "Restriccin de Globals"

#: ../Doc/library/pickle.rst:1052
msgid ""
"By default, unpickling will import any class or function that it finds in "
"the pickle data.  For many applications, this behaviour is unacceptable as "
"it permits the unpickler to import and invoke arbitrary code.  Just consider "
"what this hand-crafted pickle data stream does when loaded::"
msgstr ""
"De forma predeterminada, el `unpickling` importar cualquier clase o funcin "
"que encuentre en los datos de `pickle`.  Para muchas aplicaciones, este "
"comportamiento es inaceptable, ya que permite al `unpickler` importar e "
"invocar cdigo arbitrario.  Solo considere lo que hace este flujo de datos "
"de `pickle` hechos a mano cuando se carga::"

#: ../Doc/library/pickle.rst:1062
msgid ""
"In this example, the unpickler imports the :func:`os.system` function and "
"then apply the string argument \"echo hello world\".  Although this example "
"is inoffensive, it is not difficult to imagine one that could damage your "
"system."
msgstr ""
"En este ejemplo, el `unpickler` importa la funcin :func:`os.system` y luego "
"aplica el argumento de cadena `\"echo hello world\"`.  Aunque este ejemplo "
"es inofensivo, no es difcil imaginar uno que pueda daar su sistema."

#: ../Doc/library/pickle.rst:1066
msgid ""
"For this reason, you may want to control what gets unpickled by customizing :"
"meth:`Unpickler.find_class`.  Unlike its name suggests, :meth:`Unpickler."
"find_class` is called whenever a global (i.e., a class or a function) is "
"requested.  Thus it is possible to either completely forbid globals or "
"restrict them to a safe subset."
msgstr ""
"Por esta razn, es posible que desee controlar lo que se deserializa con "
"`pickle` personalizando :meth:`Unpickler.find_class`.  A diferencia de lo "
"que sugiere su nombre, :meth:`Unpickler.find_class` se llama siempre que se "
"solicita un global (es decir, una clase o una funcin).  Por lo tanto, es "
"posible prohibir completamente los globales o restringirlos a un subconjunto "
"seguro."

#: ../Doc/library/pickle.rst:1072
msgid ""
"Here is an example of an unpickler allowing only few safe classes from the :"
"mod:`builtins` module to be loaded::"
msgstr ""
"Aqu hay un ejemplo de un `unpickler` que permite cargar solo unas pocas "
"clases seguras del mdulo :mod:`builtins`::"

#: ../Doc/library/pickle.rst:1101
msgid "A sample usage of our unpickler working has intended::"
msgstr ""
"Un uso de muestra de nuestro `unpickler` trabajando tiene la intencin de::"

#: ../Doc/library/pickle.rst:1120
msgid ""
"As our examples shows, you have to be careful with what you allow to be "
"unpickled.  Therefore if security is a concern, you may want to consider "
"alternatives such as the marshalling API in :mod:`xmlrpc.client` or third-"
"party solutions."
msgstr ""
"Como muestran nuestros ejemplos, debes tener cuidado con lo que permites que "
"se deserialize con `pickle`.  Por lo tanto, si la seguridad es un problema, "
"puede considerar alternativas como la API de `marshalling` en :mod:`xmlrpc."
"client` o soluciones de terceros."

#: ../Doc/library/pickle.rst:1127
msgid "Performance"
msgstr "Performance"

#: ../Doc/library/pickle.rst:1129
msgid ""
"Recent versions of the pickle protocol (from protocol 2 and upwards) feature "
"efficient binary encodings for several common features and built-in types. "
"Also, the :mod:`pickle` module has a transparent optimizer written in C."
msgstr ""
"Las versiones recientes del protocolo `pickle` (desde el protocolo 2 en "
"adelante) cuentan con codificaciones binarias eficientes para varias "
"caractersticas comunes y tipos integrados. Adems, el mdulo :mod:`pickle` "
"tiene un optimizador transparente escrito en C."

#: ../Doc/library/pickle.rst:1137
msgid "Examples"
msgstr "Ejemplos"

#: ../Doc/library/pickle.rst:1139
msgid ""
"For the simplest code, use the :func:`dump` and :func:`load` functions. ::"
msgstr ""
"Para obtener el cdigo ms simple, use las funciones :func:`dump` y :func:"
"`load`. ::"

#: ../Doc/library/pickle.rst:1155
msgid "The following example reads the resulting pickled data. ::"
msgstr ""
"El siguiente ejemplo lee los datos serializados con `pickle` resultantes. ::"

#: ../Doc/library/pickle.rst:1172
msgid "Module :mod:`copyreg`"
msgstr "Mdulo :mod:`copyreg`"

#: ../Doc/library/pickle.rst:1172
msgid "Pickle interface constructor registration for extension types."
msgstr "Registro de constructor de interfaz `Pickle` para tipos de extensin."

#: ../Doc/library/pickle.rst:1175
msgid "Module :mod:`pickletools`"
msgstr "Mdulo :mod:`pickletools`"

#: ../Doc/library/pickle.rst:1175
msgid "Tools for working with and analyzing pickled data."
msgstr "Herramientas para trabajar y analizar datos serializados con `pickle`."

#: ../Doc/library/pickle.rst:1178
msgid "Module :mod:`shelve`"
msgstr "Mdulo :mod:`shelve`"

#: ../Doc/library/pickle.rst:1178
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr "Bases de datos indexadas de objetos; usa :mod:`pickle`."

#: ../Doc/library/pickle.rst:1181
msgid "Module :mod:`copy`"
msgstr "Module :mod:`copy`"

#: ../Doc/library/pickle.rst:1181
msgid "Shallow and deep object copying."
msgstr "Copia de objetos superficial y profunda."

#: ../Doc/library/pickle.rst:1183
msgid "Module :mod:`marshal`"
msgstr "Mdulo :mod:`marshal`"

#: ../Doc/library/pickle.rst:1184
msgid "High-performance serialization of built-in types."
msgstr "Serializacin de alto rendimiento de tipos integrados."

#: ../Doc/library/pickle.rst:1188
msgid "Footnotes"
msgstr "Notas al pie"

#: ../Doc/library/pickle.rst:1189
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr "No confunda esto con el mdulo :mod:`marshal`"

#: ../Doc/library/pickle.rst:1191
msgid ""
"This is why :keyword:`lambda` functions cannot be pickled:  all :keyword:`!"
"lambda` functions share the same name:  ``<lambda>``."
msgstr ""
"Esta es la razn por la que las funciones :keyword:`lambda` no se pueden "
"serializar con `pickle`:  todas las funciones :keyword:`!lambda` comparten "
"el mismo nombre:  ``<lambda>``."

#: ../Doc/library/pickle.rst:1194
msgid ""
"The exception raised will likely be an :exc:`ImportError` or an :exc:"
"`AttributeError` but it could be something else."
msgstr ""
"La excepcin generada probablemente ser un :exc:`ImportError` o un :exc:"
"`AttributeError` pero podra ser otra cosa."

#: ../Doc/library/pickle.rst:1197
msgid ""
"The :mod:`copy` module uses this protocol for shallow and deep copying "
"operations."
msgstr ""
"El mdulo :mod:`copy` utiliza este protocolo para operaciones de copia "
"superficial y profunda."

#: ../Doc/library/pickle.rst:1200
msgid ""
"The limitation on alphanumeric characters is due to the fact the persistent "
"IDs, in protocol 0, are delimited by the newline character.  Therefore if "
"any kind of newline characters occurs in persistent IDs, the resulting "
"pickle will become unreadable."
msgstr ""
"La limitacin de caracteres alfanumricos se debe al hecho de que los ID "
"persistentes, en el protocolo 0, estn delimitados por el carcter de nueva "
"lnea.  Por lo tanto, si se produce algn tipo de carcter de nueva lnea en "
"los ID persistentes, el serializado con `pickle` resultante se volver "
"ilegible."

