# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-25 19:47+0200\n"
"PO-Revision-Date: 2023-11-02 09:24+0100\n"
"Last-Translator: Marcos Medrano <marcosmedrano0@gmail.com>\n"
"Language-Team: python-doc-es\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.10.3\n"
"X-Generator: Poedit 3.4\n"

#: ../Doc/library/asyncio-protocol.rst:9
msgid "Transports and Protocols"
msgstr "Transportes y protocolos"

#: ../Doc/library/asyncio-protocol.rst:12
msgid "Preface"
msgstr "Prefacio"

#: ../Doc/library/asyncio-protocol.rst:13
msgid ""
"Transports and Protocols are used by the **low-level** event loop APIs such "
"as :meth:`loop.create_connection`.  They use callback-based programming "
"style and enable high-performance implementations of network or IPC "
"protocols (e.g. HTTP)."
msgstr ""
"Los transportes y protocolos son utilizados por las APIs de **bajo nivel** "
"de los bucles de eventos, como :meth:`loop.create_connection`. Utilizan un "
"estilo de programación basado en retrollamadas y permiten implementaciones "
"de alto rendimiento de protocolos de red o IPC (p. ej. HTTP)."

#: ../Doc/library/asyncio-protocol.rst:18
msgid ""
"Essentially, transports and protocols should only be used in libraries and "
"frameworks and never in high-level asyncio applications."
msgstr ""
"Esencialmente, los transportes y protocolos solo deben usarse en bibliotecas "
"y frameworks, nunca en aplicaciones asyncio de alto nivel."

#: ../Doc/library/asyncio-protocol.rst:22
msgid "This documentation page covers both `Transports`_ and `Protocols`_."
msgstr ""
"Esta página de la documentación cubre tanto `Transports`_ como `Protocols`_."

#: ../Doc/library/asyncio-protocol.rst:25
msgid "Introduction"
msgstr "Introducción"

#: ../Doc/library/asyncio-protocol.rst:26
msgid ""
"At the highest level, the transport is concerned with *how* bytes are "
"transmitted, while the protocol determines *which* bytes to transmit (and to "
"some extent when)."
msgstr ""
"En el nivel más alto, el transporte se ocupa de *cómo* se transmiten los "
"bytes, mientras que el protocolo determina *qué* bytes transmitir (y hasta "
"cierto punto cuándo)."

#: ../Doc/library/asyncio-protocol.rst:30
msgid ""
"A different way of saying the same thing: a transport is an abstraction for "
"a socket (or similar I/O endpoint) while a protocol is an abstraction for an "
"application, from the transport's point of view."
msgstr ""
"Una forma diferente de decir lo mismo: Un transporte es una abstracción para "
"un socket (o un punto final de E/S similar) mientras que un protocolo es una "
"abstracción para una aplicación, desde el punto de vista del transporte."

#: ../Doc/library/asyncio-protocol.rst:35
msgid ""
"Yet another view is the transport and protocol interfaces together define an "
"abstract interface for using network I/O and interprocess I/O."
msgstr ""
"Otro punto de vista más es que las interfaces de transporte y protocolo "
"definen juntas una interfaz abstracta para usar E/S de red y E/S entre "
"procesos."

#: ../Doc/library/asyncio-protocol.rst:39
msgid ""
"There is always a 1:1 relationship between transport and protocol objects: "
"the protocol calls transport methods to send data, while the transport calls "
"protocol methods to pass it data that has been received."
msgstr ""
"Siempre existe una relación 1:1 entre el transporte y los objetos protocolo: "
"el protocolo llama a los métodos del transporte para enviar datos, mientras "
"que el transporte llama a los métodos del protocolo para enviarle los datos "
"que se han recibido."

#: ../Doc/library/asyncio-protocol.rst:44
msgid ""
"Most of connection oriented event loop methods (such as :meth:`loop."
"create_connection`) usually accept a *protocol_factory* argument used to "
"create a *Protocol* object for an accepted connection, represented by a "
"*Transport* object. Such methods usually return a tuple of ``(transport, "
"protocol)``."
msgstr ""
"La mayoría de los métodos del bucle de eventos orientados a la conexión "
"(como :meth:`loop.create_connection`) aceptan generalmente un argumento "
"*protocol_factory* que es usado para crear un objeto *Protocol* para una "
"conexión aceptada, representada por un objeto *Transport*. Estos métodos "
"suelen retornar una tupla de la forma ``(transporte, protocolo)``."

#: ../Doc/library/asyncio-protocol.rst:51
msgid "Contents"
msgstr "Contenidos"

#: ../Doc/library/asyncio-protocol.rst:52
msgid "This documentation page contains the following sections:"
msgstr "Esta página de la documentación contiene las siguientes secciones:"

#: ../Doc/library/asyncio-protocol.rst:54
msgid ""
"The `Transports`_ section documents asyncio :class:`BaseTransport`, :class:"
"`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, :class:"
"`DatagramTransport`, and :class:`SubprocessTransport` classes."
msgstr ""
"La sección `Transports`_ documenta las clases asyncio :class:"
"`BaseTransport`, :class:`ReadTransport`, :class:`WriteTransport`, :class:"
"`Transport`, :class:`DatagramTransport` y :class:`SubprocessTransport`."

#: ../Doc/library/asyncio-protocol.rst:59
msgid ""
"The `Protocols`_ section documents asyncio :class:`BaseProtocol`, :class:"
"`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol`, and :class:"
"`SubprocessProtocol` classes."
msgstr ""
"La sección `Protocols`_ documenta las clases asyncio :class:`BaseProtocol`, :"
"class:`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol` y :"
"class:`SubprocessProtocol`."

#: ../Doc/library/asyncio-protocol.rst:63
msgid ""
"The `Examples`_ section showcases how to work with transports, protocols, "
"and low-level event loop APIs."
msgstr ""
"La sección `Examples`_ muestra cómo trabajar con transportes, protocolos y "
"las APIs de bajo nivel del bucle de eventos."

#: ../Doc/library/asyncio-protocol.rst:70
msgid "Transports"
msgstr "Transportes"

#: ../Doc/library/asyncio-protocol.rst:72
msgid "**Source code:** :source:`Lib/asyncio/transports.py`"
msgstr "**Código fuente:** :source:`Lib/asyncio/transports.py`"

#: ../Doc/library/asyncio-protocol.rst:76
msgid ""
"Transports are classes provided by :mod:`asyncio` in order to abstract "
"various kinds of communication channels."
msgstr ""
"Los transportes son clases proporcionadas por :mod:`asyncio` para abstraer "
"varios tipos de canales de comunicación."

#: ../Doc/library/asyncio-protocol.rst:79
msgid ""
"Transport objects are always instantiated by an :ref:`asyncio event loop "
"<asyncio-event-loop>`."
msgstr ""
"Los objetos transporte siempre son instanciados por un :ref:`bucle de "
"eventos asyncio <asyncio-event-loop>`."

#: ../Doc/library/asyncio-protocol.rst:82
msgid ""
"asyncio implements transports for TCP, UDP, SSL, and subprocess pipes. The "
"methods available on a transport depend on the transport's kind."
msgstr ""
"asyncio implementa transportes para TCP, UDP, SSL y pipes de subprocesos. "
"Los métodos disponibles en un transporte dependen del tipo de transporte."

#: ../Doc/library/asyncio-protocol.rst:85
msgid ""
"The transport classes are :ref:`not thread safe <asyncio-multithreading>`."
msgstr ""
"Las clases transporte :ref:`no son seguras en hilos <asyncio-"
"multithreading>`."

#: ../Doc/library/asyncio-protocol.rst:89
msgid "Transports Hierarchy"
msgstr "Jerarquía de transportes"

#: ../Doc/library/asyncio-protocol.rst:93
msgid ""
"Base class for all transports.  Contains methods that all asyncio transports "
"share."
msgstr ""
"Clase base para todos los transportes. Contiene métodos que todos los "
"transportes asyncio comparten."

#: ../Doc/library/asyncio-protocol.rst:98
msgid "A base transport for write-only connections."
msgstr "Un transporte base para conexiones de solo escritura."

#: ../Doc/library/asyncio-protocol.rst:100
msgid ""
"Instances of the *WriteTransport* class are returned from the :meth:`loop."
"connect_write_pipe` event loop method and are also used by subprocess-"
"related methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Las instancias de la clase *WriteTransport* se retornan desde el método del "
"bucle de eventos :meth:`loop.connect_write_pipe` y también se utilizan en "
"métodos relacionados con subprocesos como :meth:`loop.subprocess_exec`."

#: ../Doc/library/asyncio-protocol.rst:107
msgid "A base transport for read-only connections."
msgstr "Un transporte base para conexiones de solo lectura."

#: ../Doc/library/asyncio-protocol.rst:109
msgid ""
"Instances of the *ReadTransport* class are returned from the :meth:`loop."
"connect_read_pipe` event loop method and are also used by subprocess-related "
"methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Las instancias de la clase *ReadTransport* se retornan desde el método del "
"bucle de eventos :meth:`loop.connect_read_pipe` y también se utilizan en "
"métodos relacionados con subprocesos como :meth:`loop.subprocess_exec`."

#: ../Doc/library/asyncio-protocol.rst:116
msgid ""
"Interface representing a bidirectional transport, such as a TCP connection."
msgstr ""
"Interfaz que representa un transporte bidireccional, como una conexión TCP."

#: ../Doc/library/asyncio-protocol.rst:119
msgid ""
"The user does not instantiate a transport directly; they call a utility "
"function, passing it a protocol factory and other information necessary to "
"create the transport and protocol."
msgstr ""
"El usuario no crea una instancia de transporte directamente; en su lugar se "
"llama a una función de utilidad, pasándole una fábrica de protocolos junto a "
"otra información necesaria para crear el transporte y el protocolo."

#: ../Doc/library/asyncio-protocol.rst:123
msgid ""
"Instances of the *Transport* class are returned from or used by event loop "
"methods like :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop.sendfile`, "
"etc."
msgstr ""
"Las instancias de la clase *Transport* son retornadas o utilizadas por "
"métodos del bucle de eventos como :meth:`loop.create_connection`, :meth:"
"`loop.create_unix_connection`, :meth:`loop.create_server`, :meth:`loop."
"sendfile`, etc."

#: ../Doc/library/asyncio-protocol.rst:131
msgid "A transport for datagram (UDP) connections."
msgstr "Un transporte para conexiones de datagramas (UDP)."

#: ../Doc/library/asyncio-protocol.rst:133
msgid ""
"Instances of the *DatagramTransport* class are returned from the :meth:`loop."
"create_datagram_endpoint` event loop method."
msgstr ""
"Las instancias de la clase *DatagramTransport* se retornan desde el método :"
"meth:`loop.create_datagram_endpoint` del bucle de eventos."

#: ../Doc/library/asyncio-protocol.rst:139
msgid ""
"An abstraction to represent a connection between a parent and its child OS "
"process."
msgstr ""
"Una abstracción para representar una conexión entre un proceso padre y su "
"proceso OS hijo."

#: ../Doc/library/asyncio-protocol.rst:142
msgid ""
"Instances of the *SubprocessTransport* class are returned from event loop "
"methods :meth:`loop.subprocess_shell` and :meth:`loop.subprocess_exec`."
msgstr ""
"Las instancias de la clase *SubprocessTransport* se retornan desde los "
"métodos del bucle de eventos :meth:`loop.subprocess_shell` y :meth:`loop."
"subprocess_exec`."

#: ../Doc/library/asyncio-protocol.rst:148
msgid "Base Transport"
msgstr "Transporte base"

#: ../Doc/library/asyncio-protocol.rst:152
msgid "Close the transport."
msgstr "Cierra el transporte."

#: ../Doc/library/asyncio-protocol.rst:154
msgid ""
"If the transport has a buffer for outgoing data, buffered data will be "
"flushed asynchronously.  No more data will be received.  After all buffered "
"data is flushed, the protocol's :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` method will be called with :const:`None` as "
"its argument. The transport should not be used once it is closed."
msgstr ""
"Si el transporte tiene un búfer para datos de salida, los datos almacenados "
"en el búfer se eliminarán de forma asincrónica. No se recibirán más datos. "
"Después de que se vacíen todos los datos almacenados en el búfer, el método :"
"meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` del "
"protocolo se llamará con :const:`None` como argumento. El transporte no "
"debería ser usado luego de haber sido cerrado."

#: ../Doc/library/asyncio-protocol.rst:164
msgid "Return ``True`` if the transport is closing or is closed."
msgstr "Retorna ``True`` si el transporte se está cerrando o está ya cerrado."

#: ../Doc/library/asyncio-protocol.rst:168
msgid "Return information about the transport or underlying resources it uses."
msgstr ""
"Retorna información sobre el transporte o los recursos subyacentes que "
"utiliza."

#: ../Doc/library/asyncio-protocol.rst:171
msgid ""
"*name* is a string representing the piece of transport-specific information "
"to get."
msgstr ""
"*name* es una cadena de caracteres que representa la información específica "
"del transporte que se va a obtener."

#: ../Doc/library/asyncio-protocol.rst:174
msgid ""
"*default* is the value to return if the information is not available, or if "
"the transport does not support querying it with the given third-party event "
"loop implementation or on the current platform."
msgstr ""
"*default* es el valor que se retornará si la información no está disponible "
"o si el transporte no admite la consulta con la implementación del bucle de "
"eventos de terceros dada o en la plataforma actual."

#: ../Doc/library/asyncio-protocol.rst:179
msgid ""
"For example, the following code attempts to get the underlying socket object "
"of the transport::"
msgstr ""
"Por ejemplo, el siguiente código intenta obtener el objeto socket subyacente "
"del transporte:"

#: ../Doc/library/asyncio-protocol.rst:186
msgid "Categories of information that can be queried on some transports:"
msgstr ""
"Categorías de información que se pueden consultar sobre algunos transportes:"

#: ../Doc/library/asyncio-protocol.rst:188
msgid "socket:"
msgstr "socket:"

#: ../Doc/library/asyncio-protocol.rst:190
msgid ""
"``'peername'``: the remote address to which the socket is connected, result "
"of :meth:`socket.socket.getpeername` (``None`` on error)"
msgstr ""
"``'peername'``: la dirección remota a la que está conectado el socket, "
"resultado de :meth:`socket.socket.getpeername` (``None`` en caso de error)"

#: ../Doc/library/asyncio-protocol.rst:194
msgid "``'socket'``: :class:`socket.socket` instance"
msgstr "``'socket'``: instancia de :class:`socket.socket`"

#: ../Doc/library/asyncio-protocol.rst:196
msgid ""
"``'sockname'``: the socket's own address, result of :meth:`socket.socket."
"getsockname`"
msgstr ""
"``'sockname'``: la dirección propia del socket, resultado de :meth:`socket."
"socket.getsockname`"

#: ../Doc/library/asyncio-protocol.rst:199
msgid "SSL socket:"
msgstr "socket SSL:"

#: ../Doc/library/asyncio-protocol.rst:201
msgid ""
"``'compression'``: the compression algorithm being used as a string, or "
"``None`` if the connection isn't compressed; result of :meth:`ssl.SSLSocket."
"compression`"
msgstr ""
"``'compression'``: el algoritmo de compresión que se está usando como una "
"cadena de caracteres o ``None`` si la conexión no está comprimida; resultado "
"de :meth:`ssl.SSLSocket.compression`"

#: ../Doc/library/asyncio-protocol.rst:205
msgid ""
"``'cipher'``: a three-value tuple containing the name of the cipher being "
"used, the version of the SSL protocol that defines its use, and the number "
"of secret bits being used; result of :meth:`ssl.SSLSocket.cipher`"
msgstr ""
"``'cipher'``: una tupla de tres valores que contiene el nombre del cifrado "
"que se está utilizando, la versión del protocolo SSL que define su uso y la "
"cantidad de bits de la clave secreta que se utilizan; resultado de :meth:"
"`ssl.SSLSocket.cipher`"

#: ../Doc/library/asyncio-protocol.rst:210
msgid ""
"``'peercert'``: peer certificate; result of :meth:`ssl.SSLSocket.getpeercert`"
msgstr ""
"``'peercert'``: certificado de pares; resultado de :meth:`ssl.SSLSocket."
"getpeercert`"

#: ../Doc/library/asyncio-protocol.rst:213
msgid "``'sslcontext'``: :class:`ssl.SSLContext` instance"
msgstr "``'sslcontext'``: instancia de :class:`ssl.SSLContext`"

#: ../Doc/library/asyncio-protocol.rst:215
msgid ""
"``'ssl_object'``: :class:`ssl.SSLObject` or :class:`ssl.SSLSocket` instance"
msgstr ""
"``'ssl_object'``: instancia de :class:`ssl.SSLObject` o :class:`ssl."
"SSLSocket`"

#: ../Doc/library/asyncio-protocol.rst:218
msgid "pipe:"
msgstr "pipe:"

#: ../Doc/library/asyncio-protocol.rst:220
msgid "``'pipe'``: pipe object"
msgstr "``'pipe'``: objeto pipe"

#: ../Doc/library/asyncio-protocol.rst:222
msgid "subprocess:"
msgstr "subproceso:"

#: ../Doc/library/asyncio-protocol.rst:224
msgid "``'subprocess'``: :class:`subprocess.Popen` instance"
msgstr "``'subprocess'``: instancia de :class:`subprocess.Popen`"

#: ../Doc/library/asyncio-protocol.rst:228
msgid "Set a new protocol."
msgstr "Establece un nuevo protocolo."

#: ../Doc/library/asyncio-protocol.rst:230
msgid ""
"Switching protocol should only be done when both protocols are documented to "
"support the switch."
msgstr ""
"El cambio de protocolo solo debe realizarse cuando esté documentado que "
"ambos protocolos admiten el cambio."

#: ../Doc/library/asyncio-protocol.rst:235
msgid "Return the current protocol."
msgstr "Retorna el protocolo actual."

#: ../Doc/library/asyncio-protocol.rst:239
msgid "Read-only Transports"
msgstr "Transportes de solo lectura"

#: ../Doc/library/asyncio-protocol.rst:243
msgid "Return ``True`` if the transport is receiving new data."
msgstr "Retorna ``True`` si el transporte está recibiendo nuevos datos."

#: ../Doc/library/asyncio-protocol.rst:249
msgid ""
"Pause the receiving end of the transport.  No data will be passed to the "
"protocol's :meth:`protocol.data_received() <Protocol.data_received>` method "
"until :meth:`resume_reading` is called."
msgstr ""
"Pausa el extremo receptor del transporte. No se pasarán datos al método :"
"meth:`protocol.data_received() <Protocol.data_received>` del protocolo hasta "
"que se llame a :meth:`resume_reading`."

#: ../Doc/library/asyncio-protocol.rst:253
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already paused or closed."
msgstr ""
"El método es idempotente, es decir, se puede llamar cuando el transporte ya "
"está en pausa o cerrado."

#: ../Doc/library/asyncio-protocol.rst:259
msgid ""
"Resume the receiving end.  The protocol's :meth:`protocol.data_received() "
"<Protocol.data_received>` method will be called once again if some data is "
"available for reading."
msgstr ""
"Reanuda el extremo receptor. El método :meth:`protocol.data_received() "
"<Protocol.data_received>` del protocolo se llamará una vez más si hay "
"algunos datos disponibles para su lectura."

#: ../Doc/library/asyncio-protocol.rst:263
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already reading."
msgstr ""
"El método es idempotente, es decir, se puede llamar cuando el transporte "
"está leyendo."

#: ../Doc/library/asyncio-protocol.rst:269
msgid "Write-only Transports"
msgstr "Transportes de solo escritura"

#: ../Doc/library/asyncio-protocol.rst:273
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost.  No more data will be received. The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Cierra el transporte inmediatamente, sin esperar a que finalicen las "
"operaciones pendientes. Se perderán los datos almacenados en el búfer. No se "
"recibirán más datos. El método :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` del protocolo será llamado eventualmente "
"con :const:`None` como argumento."

#: ../Doc/library/asyncio-protocol.rst:281
msgid ""
"Return :const:`True` if the transport supports :meth:`~WriteTransport."
"write_eof`, :const:`False` if not."
msgstr ""
"Retorna :const:`True` si el transporte admite :meth:`~WriteTransport."
"write_eof`, en caso contrario :const:`False`."

#: ../Doc/library/asyncio-protocol.rst:286
msgid "Return the current size of the output buffer used by the transport."
msgstr ""
"Retorna el tamaño actual del búfer de salida utilizado por el transporte."

#: ../Doc/library/asyncio-protocol.rst:290
msgid ""
"Get the *high* and *low* watermarks for write flow control. Return a tuple "
"``(low, high)`` where *low* and *high* are positive number of bytes."
msgstr ""
"Obtiene los límites superior e inferior para el control del flujo de "
"escritura. Retorna una tupla ``(low, high)`` donde *low* ('inferior') y "
"*high* ('superior') son un número de bytes positivo."

#: ../Doc/library/asyncio-protocol.rst:294
msgid "Use :meth:`set_write_buffer_limits` to set the limits."
msgstr "Usa :meth:`set_write_buffer_limits` para establecer los límites."

#: ../Doc/library/asyncio-protocol.rst:300
msgid "Set the *high* and *low* watermarks for write flow control."
msgstr ""
"Establece los límites *high* ('superior') y *low* ('inferior') para el "
"control del flujo de escritura."

#: ../Doc/library/asyncio-protocol.rst:302
msgid ""
"These two values (measured in number of bytes) control when the protocol's :"
"meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` and :meth:"
"`protocol.resume_writing() <BaseProtocol.resume_writing>` methods are "
"called. If specified, the low watermark must be less than or equal to the "
"high watermark.  Neither *high* nor *low* can be negative."
msgstr ""
"Estos dos valores (medidos en número de bytes) controlan cuándo se llaman "
"los métodos :meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` y :"
"meth:`protocol.resume_writing() <BaseProtocol.resume_writing>` del "
"protocolo . Si se especifica, el límite inferior debe ser menor o igual que "
"el límite superior. Ni *high* ni *low* pueden ser negativos."

#: ../Doc/library/asyncio-protocol.rst:310
msgid ""
":meth:`~BaseProtocol.pause_writing` is called when the buffer size becomes "
"greater than or equal to the *high* value. If writing has been paused, :meth:"
"`~BaseProtocol.resume_writing` is called when the buffer size becomes less "
"than or equal to the *low* value."
msgstr ""
":meth:`~BaseProtocol.pause_writing` se llama cuando el tamaño del búfer es "
"mayor o igual que el valor *high* ('superior'). Si se ha pausado la "
"escritura, se llama a :meth:`~BaseProtocol.resume_writing` cuando el tamaño "
"del búfer es menor o igual que el valor *low* ('inferior')."

#: ../Doc/library/asyncio-protocol.rst:315
msgid ""
"The defaults are implementation-specific.  If only the high watermark is "
"given, the low watermark defaults to an implementation-specific value less "
"than or equal to the high watermark.  Setting *high* to zero forces *low* to "
"zero as well, and causes :meth:`~BaseProtocol.pause_writing` to be called "
"whenever the buffer becomes non-empty.  Setting *low* to zero causes :meth:"
"`~BaseProtocol.resume_writing` to be called only once the buffer is empty. "
"Use of zero for either limit is generally sub-optimal as it reduces "
"opportunities for doing I/O and computation concurrently."
msgstr ""
"Los valores por defecto son específicos de la implementación. Si solo se "
"proporciona el límite superior, el inferior toma de forma predeterminada un "
"valor específico, dependiente de la implementación, menor o igual que el "
"límite superior. Establecer *high* ('superior') en cero fuerza *low* "
"('inferior') a cero también y hace que :meth:`~BaseProtocol.pause_writing` "
"sea llamado siempre que el búfer no esté vacío. Establecer *low* "
"('inferior') en cero hace que :meth:`~BaseProtocol.resume_writing` sea "
"llamado únicamente cuando el búfer esté vacío. El uso de cero para "
"cualquiera de los límites es generalmente subóptimo, ya que reduce las "
"oportunidades para realizar E/S y cálculos simultáneamente."

#: ../Doc/library/asyncio-protocol.rst:326
msgid "Use :meth:`~WriteTransport.get_write_buffer_limits` to get the limits."
msgstr ""
"Usa :meth:`~WriteTransport.get_write_buffer_limits` para obtener los límites."

#: ../Doc/library/asyncio-protocol.rst:331
msgid "Write some *data* bytes to the transport."
msgstr "Escribe los bytes de *data* en el transporte."

#: ../Doc/library/asyncio-protocol.rst:333
#: ../Doc/library/asyncio-protocol.rst:362
msgid ""
"This method does not block; it buffers the data and arranges for it to be "
"sent out asynchronously."
msgstr ""
"Este método no bloquea; almacena los datos en el búfer y organiza que se "
"envíen de forma asincrónica."

#: ../Doc/library/asyncio-protocol.rst:338
msgid ""
"Write a list (or any iterable) of data bytes to the transport. This is "
"functionally equivalent to calling :meth:`write` on each element yielded by "
"the iterable, but may be implemented more efficiently."
msgstr ""
"Escribe una lista (o cualquier iterable) de bytes de datos en el transporte. "
"Esto es funcionalmente equivalente a llamar a :meth:`write` en cada elemento "
"generado por el iterable, pero puede ser implementado de manera más "
"eficiente."

#: ../Doc/library/asyncio-protocol.rst:345
msgid ""
"Close the write end of the transport after flushing all buffered data. Data "
"may still be received."
msgstr ""
"Cierra el extremo de escritura del transporte después de vaciar todos los "
"datos almacenados en el búfer. Aún es posible recibir datos."

#: ../Doc/library/asyncio-protocol.rst:348
msgid ""
"This method can raise :exc:`NotImplementedError` if the transport (e.g. SSL) "
"doesn't support half-closed connections."
msgstr ""
"Este método puede lanzar una excepción :exc:`NotImplementedError` si el "
"transporte (p. ej. SSL) no soporta conexiones semicerradas (*half-closed*)."

#: ../Doc/library/asyncio-protocol.rst:353
msgid "Datagram Transports"
msgstr "Transportes de datagramas"

#: ../Doc/library/asyncio-protocol.rst:357
msgid ""
"Send the *data* bytes to the remote peer given by *addr* (a transport-"
"dependent target address).  If *addr* is :const:`None`, the data is sent to "
"the target address given on transport creation."
msgstr ""
"Envía los bytes *data* al par remoto proporcionado por *addr* (una dirección "
"de destino dependiente del transporte). Si *addr* es :const:`None`, los "
"datos se envían a la dirección de destino proporcionada en la creación del "
"transporte."

#: ../Doc/library/asyncio-protocol.rst:367
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost. No more data will be received.  The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Cierra el transporte inmediatamente, sin esperar a que finalicen las "
"operaciones pendientes. Se perderán los datos almacenados en el búfer. No se "
"recibirán más datos. El método :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` del protocolo será llamado eventualmente "
"con :const:`None` como argumento."

#: ../Doc/library/asyncio-protocol.rst:377
msgid "Subprocess Transports"
msgstr "Transportes de subprocesos"

#: ../Doc/library/asyncio-protocol.rst:381
msgid "Return the subprocess process id as an integer."
msgstr "Retorna la id del subproceso como un número entero."

#: ../Doc/library/asyncio-protocol.rst:385
msgid ""
"Return the transport for the communication pipe corresponding to the integer "
"file descriptor *fd*:"
msgstr ""
"Retorna el transporte para la pipe de comunicación correspondiente al "
"descriptor de archivo entero *fd*:"

#: ../Doc/library/asyncio-protocol.rst:388
msgid ""
"``0``: readable streaming transport of the standard input (*stdin*), or :"
"const:`None` if the subprocess was not created with ``stdin=PIPE``"
msgstr ""
"``0``: transporte de *streaming* para lectura de la entrada estándar "
"(*stdin*) o :const:`None` si el subproceso no se creó con ``stdin = PIPE``"

#: ../Doc/library/asyncio-protocol.rst:390
msgid ""
"``1``: writable streaming transport of the standard output (*stdout*), or :"
"const:`None` if the subprocess was not created with ``stdout=PIPE``"
msgstr ""
"``1``: transporte de *streaming* para escritura de la salida estándar "
"(*stdout*) o :const:`None` si el subproceso no se creó con ``stdout = PIPE``"

#: ../Doc/library/asyncio-protocol.rst:392
msgid ""
"``2``: writable streaming transport of the standard error (*stderr*), or :"
"const:`None` if the subprocess was not created with ``stderr=PIPE``"
msgstr ""
"``2``: transporte de *streaming* para escritura del error estándar "
"(*stderr*) o :const:`None` si el subproceso no se creó con ``stderr = PIPE``"

#: ../Doc/library/asyncio-protocol.rst:394
msgid "other *fd*: :const:`None`"
msgstr "otro *fd*: :const:`None`"

#: ../Doc/library/asyncio-protocol.rst:398
msgid ""
"Return the subprocess return code as an integer or :const:`None` if it "
"hasn't returned, which is similar to the :attr:`subprocess.Popen.returncode` "
"attribute."
msgstr ""
"Retorna el código de retorno del subproceso como un entero o :const:`None` "
"si no ha retornado aún, lo que es similar al atributo :attr:`subprocess."
"Popen.returncode`."

#: ../Doc/library/asyncio-protocol.rst:404
msgid "Kill the subprocess."
msgstr "Mata al subproceso."

#: ../Doc/library/asyncio-protocol.rst:406
msgid ""
"On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, "
"this method is an alias for :meth:`terminate`."
msgstr ""
"En los sistemas POSIX, la función envía SIGKILL al subproceso. En Windows, "
"este método es un alias para :meth:`terminate`."

#: ../Doc/library/asyncio-protocol.rst:409
msgid "See also :meth:`subprocess.Popen.kill`."
msgstr "Ver también :meth:`subprocess.Popen.kill`."

#: ../Doc/library/asyncio-protocol.rst:413
msgid ""
"Send the *signal* number to the subprocess, as in :meth:`subprocess.Popen."
"send_signal`."
msgstr ""
"Envía el número de *señal* al subproceso, como en :meth:`subprocess.Popen."
"send_signal`."

#: ../Doc/library/asyncio-protocol.rst:418
msgid "Stop the subprocess."
msgstr "Detiene el subproceso."

#: ../Doc/library/asyncio-protocol.rst:420
msgid ""
"On POSIX systems, this method sends SIGTERM to the subprocess. On Windows, "
"the Windows API function TerminateProcess() is called to stop the subprocess."
msgstr ""
"En los sistemas POSIX, este método envía SIGTERM al subproceso. En Windows, "
"se llama a la función de la API de Windows *TerminateProcess()* para detener "
"el subproceso."

#: ../Doc/library/asyncio-protocol.rst:424
msgid "See also :meth:`subprocess.Popen.terminate`."
msgstr "Ver también :meth:`subprocess.Popen.terminate`."

#: ../Doc/library/asyncio-protocol.rst:428
msgid "Kill the subprocess by calling the :meth:`kill` method."
msgstr "Mata al subproceso llamando al método :meth:`kill`."

#: ../Doc/library/asyncio-protocol.rst:430
msgid ""
"If the subprocess hasn't returned yet, and close transports of *stdin*, "
"*stdout*, and *stderr* pipes."
msgstr ""
"Si el subproceso aún no ha retornado, cierra los transportes de las pipes "
"*stdin*, *stdout* y *stderr*."

#: ../Doc/library/asyncio-protocol.rst:437
msgid "Protocols"
msgstr "Protocolos"

#: ../Doc/library/asyncio-protocol.rst:439
msgid "**Source code:** :source:`Lib/asyncio/protocols.py`"
msgstr "**Código fuente:** :source:`Lib/asyncio/protocols.py`"

#: ../Doc/library/asyncio-protocol.rst:443
msgid ""
"asyncio provides a set of abstract base classes that should be used to "
"implement network protocols.  Those classes are meant to be used together "
"with :ref:`transports <asyncio-transport>`."
msgstr ""
"asyncio proporciona un conjunto de clases base abstractas que pueden usarse "
"para implementar protocolos de red. Estas clases están destinadas a ser "
"utilizadas junto con los :ref:`transportes <asyncio-transport>`."

#: ../Doc/library/asyncio-protocol.rst:447
msgid ""
"Subclasses of abstract base protocol classes may implement some or all "
"methods.  All these methods are callbacks: they are called by transports on "
"certain events, for example when some data is received. A base protocol "
"method should be called by the corresponding transport."
msgstr ""
"Las subclases de las clases abstractas de protocolos base pueden implementar "
"algunos o todos los métodos. Todos estos métodos son retrollamadas: son "
"llamados por los transportes en ciertos eventos, por ejemplo, cuando se "
"reciben algunos datos. Un método del protocolo base debe ser llamado por el "
"transporte correspondiente."

#: ../Doc/library/asyncio-protocol.rst:454
msgid "Base Protocols"
msgstr "Protocolos base"

#: ../Doc/library/asyncio-protocol.rst:458
msgid "Base protocol with methods that all protocols share."
msgstr "Protocolo base con métodos que comparten todos los demás protocolos."

#: ../Doc/library/asyncio-protocol.rst:462
msgid ""
"The base class for implementing streaming protocols (TCP, Unix sockets, etc)."
msgstr ""
"La clase base para implementar protocolos de *streaming* (TCP, sockets Unix, "
"etc)."

#: ../Doc/library/asyncio-protocol.rst:467
msgid ""
"A base class for implementing streaming protocols with manual control of the "
"receive buffer."
msgstr ""
"Una clase base para implementar protocolos de *streaming* con control manual "
"del búfer de recepción."

#: ../Doc/library/asyncio-protocol.rst:472
msgid "The base class for implementing datagram (UDP) protocols."
msgstr "La clase base para implementar protocolos de datagramas (UDP)."

#: ../Doc/library/asyncio-protocol.rst:476
msgid ""
"The base class for implementing protocols communicating with child processes "
"(unidirectional pipes)."
msgstr ""
"La clase base para implementar protocolos que se comunican con procesos "
"secundarios (pipes unidireccionales)."

#: ../Doc/library/asyncio-protocol.rst:481
msgid "Base Protocol"
msgstr "Protocolo base"

#: ../Doc/library/asyncio-protocol.rst:483
msgid "All asyncio protocols can implement Base Protocol callbacks."
msgstr ""
"Todos los protocolos asyncio pueden implementar las retrollamadas del "
"protocolo base."

#: ../Doc/library/asyncio-protocol.rst:486
msgid "Connection Callbacks"
msgstr "Retrollamadas de conexión"

#: ../Doc/library/asyncio-protocol.rst:487
msgid ""
"Connection callbacks are called on all protocols, exactly once per a "
"successful connection.  All other protocol callbacks can only be called "
"between those two methods."
msgstr ""
"Las retrollamadas de conexión son llamadas exactamente una vez por conexión "
"establecida en todos los protocolos. Todas las demás retrollamadas del "
"protocolo solo pueden ser llamadas entre estos dos métodos."

#: ../Doc/library/asyncio-protocol.rst:493
msgid "Called when a connection is made."
msgstr "Se llama cuando se establece una conexión."

#: ../Doc/library/asyncio-protocol.rst:495
msgid ""
"The *transport* argument is the transport representing the connection.  The "
"protocol is responsible for storing the reference to its transport."
msgstr ""
"El argumento *transport* es el transporte que representa la conexión. El "
"protocolo se encarga de almacenar la referencia a su propio transporte."

#: ../Doc/library/asyncio-protocol.rst:501
msgid "Called when the connection is lost or closed."
msgstr "Se llama cuando la conexión se pierde o se cierra."

#: ../Doc/library/asyncio-protocol.rst:503
msgid ""
"The argument is either an exception object or :const:`None`. The latter "
"means a regular EOF is received, or the connection was aborted or closed by "
"this side of the connection."
msgstr ""
"El argumento es un objeto excepción o :const:`None`. Esto último significa "
"que se recibió un EOF regular o que la conexión fue cancelada o cerrada por "
"este lado de la conexión."

#: ../Doc/library/asyncio-protocol.rst:509
msgid "Flow Control Callbacks"
msgstr "Retrollamadas de control de flujo"

#: ../Doc/library/asyncio-protocol.rst:510
msgid ""
"Flow control callbacks can be called by transports to pause or resume "
"writing performed by the protocol."
msgstr ""
"Los transportes pueden llamar a las retrollamadas de control de flujo para "
"pausar o reanudar la escritura llevada a cabo por el protocolo."

#: ../Doc/library/asyncio-protocol.rst:513
msgid ""
"See the documentation of the :meth:`~WriteTransport.set_write_buffer_limits` "
"method for more details."
msgstr ""
"Consulta la documentación del método :meth:`~WriteTransport."
"set_write_buffer_limits` para obtener más detalles."

#: ../Doc/library/asyncio-protocol.rst:518
msgid "Called when the transport's buffer goes over the high watermark."
msgstr "Se llama cuando el búfer del transporte supera el límite superior."

#: ../Doc/library/asyncio-protocol.rst:522
msgid "Called when the transport's buffer drains below the low watermark."
msgstr ""
"Se llama cuando el búfer del transporte se vacía por debajo del límite "
"inferior."

#: ../Doc/library/asyncio-protocol.rst:524
msgid ""
"If the buffer size equals the high watermark, :meth:`~BaseProtocol."
"pause_writing` is not called: the buffer size must go strictly over."
msgstr ""
"Si el tamaño del búfer es igual al límite superior, :meth:`~BaseProtocol."
"pause_writing` no será llamado: el tamaño del búfer debe superarse "
"estrictamente."

#: ../Doc/library/asyncio-protocol.rst:528
msgid ""
"Conversely, :meth:`~BaseProtocol.resume_writing` is called when the buffer "
"size is equal or lower than the low watermark.  These end conditions are "
"important to ensure that things go as expected when either mark is zero."
msgstr ""
"Por el contrario, se llama a :meth:`~BaseProtocol.resume_writing` cuando el "
"tamaño del búfer es igual o menor que el límite inferior. Estas condiciones "
"finales son importantes para garantizar que todo salga como se espera cuando "
"cualquiera de los dos límites sea cero."

#: ../Doc/library/asyncio-protocol.rst:535
msgid "Streaming Protocols"
msgstr "Protocolos de *streaming*"

#: ../Doc/library/asyncio-protocol.rst:537
msgid ""
"Event methods, such as :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe`, and :meth:`loop.connect_write_pipe` accept factories "
"that return streaming protocols."
msgstr ""
"Los métodos de eventos, como :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe`, y :meth:`loop.connect_write_pipe` aceptan fábricas que "
"retornan protocolos de *streaming*."

#: ../Doc/library/asyncio-protocol.rst:545
msgid ""
"Called when some data is received.  *data* is a non-empty bytes object "
"containing the incoming data."
msgstr ""
"Se llama cuando se reciben algunos datos. *data* es un objeto bytes no vacío "
"que contiene los datos entrantes."

#: ../Doc/library/asyncio-protocol.rst:548
msgid ""
"Whether the data is buffered, chunked or reassembled depends on the "
"transport.  In general, you shouldn't rely on specific semantics and instead "
"make your parsing generic and flexible. However, data is always received in "
"the correct order."
msgstr ""
"Que los datos se almacenen en un búfer, que se fragmenten o se vuelvan a "
"ensamblar depende del transporte. En general, no debe confiar en semánticas "
"específicas y, en cambio, hacer que su análisis sea genérico y flexible. Sin "
"embargo, los datos siempre se reciben en el orden correcto."

#: ../Doc/library/asyncio-protocol.rst:553
msgid ""
"The method can be called an arbitrary number of times while a connection is "
"open."
msgstr ""
"El método se puede llamar un número arbitrario de veces mientras una "
"conexión esté abierta."

#: ../Doc/library/asyncio-protocol.rst:556
msgid ""
"However, :meth:`protocol.eof_received() <Protocol.eof_received>` is called "
"at most once.  Once ``eof_received()`` is called, ``data_received()`` is not "
"called anymore."
msgstr ""
"Sin embargo, :meth:`protocol.eof_received() <Protocol.eof_received>` se "
"llama como máximo una vez. Luego de llamar a ``eof_received()``, ya no se "
"llama más a ``data_received()``."

#: ../Doc/library/asyncio-protocol.rst:562
msgid ""
"Called when the other end signals it won't send any more data (for example "
"by calling :meth:`transport.write_eof() <WriteTransport.write_eof>`, if the "
"other end also uses asyncio)."
msgstr ""
"Se llama cuando el otro extremo indica que no enviará más datos (por "
"ejemplo, llamando a :meth:`transport.write_eof() <WriteTransport.write_eof>` "
"si el otro extremo también usa asyncio)."

#: ../Doc/library/asyncio-protocol.rst:567
msgid ""
"This method may return a false value (including ``None``), in which case the "
"transport will close itself.  Conversely, if this method returns a true "
"value, the protocol used determines whether to close the transport. Since "
"the default implementation returns ``None``, it implicitly closes the "
"connection."
msgstr ""
"Este método puede retornar un valor falso (incluido ``None``), en cuyo caso "
"el transporte se cerrará solo. Por el contrario, si este método retorna un "
"valor verdadero, el protocolo utilizado determina si se debe cerrar el "
"transporte. Dado que la implementación por defecto retorna ``None``, en éste "
"caso, se cierra implícitamente la conexión."

#: ../Doc/library/asyncio-protocol.rst:573
msgid ""
"Some transports, including SSL, don't support half-closed connections, in "
"which case returning true from this method will result in the connection "
"being closed."
msgstr ""
"Algunos transportes, incluido SSL, no admiten conexiones semicerradas (*half-"
"closed*), en cuyo caso retornar verdadero desde este método resultará en el "
"cierre de la conexión."

#: ../Doc/library/asyncio-protocol.rst:578
#: ../Doc/library/asyncio-protocol.rst:636
msgid "State machine:"
msgstr "Máquina de estado:"

#: ../Doc/library/asyncio-protocol.rst:589
msgid "Buffered Streaming Protocols"
msgstr "Protocolos de *streaming* mediante búfer"

#: ../Doc/library/asyncio-protocol.rst:593
msgid ""
"Buffered Protocols can be used with any event loop method that supports "
"`Streaming Protocols`_."
msgstr ""
"Los protocolos que hacen uso de un búfer se pueden utilizar con cualquier "
"método del bucle de eventos que admita `Streaming Protocols`_."

#: ../Doc/library/asyncio-protocol.rst:596
msgid ""
"``BufferedProtocol`` implementations allow explicit manual allocation and "
"control of the receive buffer.  Event loops can then use the buffer provided "
"by the protocol to avoid unnecessary data copies.  This can result in "
"noticeable performance improvement for protocols that receive big amounts of "
"data.  Sophisticated protocol implementations can significantly reduce the "
"number of buffer allocations."
msgstr ""
"Las implementaciones de ``BufferedProtocol`` permiten la asignación manual "
"explícita y el control del búfer de recepción. Los bucles de eventos pueden "
"utilizar el búfer proporcionado por el protocolo para evitar copias de datos "
"innecesarias. Esto puede resultar en una mejora notable del rendimiento de "
"los protocolos que reciben grandes cantidades de datos. Las implementaciones "
"de protocolos sofisticados pueden reducir significativamente la cantidad de "
"asignaciones de búfer."

#: ../Doc/library/asyncio-protocol.rst:603
msgid ""
"The following callbacks are called on :class:`BufferedProtocol` instances:"
msgstr ""
"Las siguientes retrollamadas son llamadas en instancias :class:"
"`BufferedProtocol`:"

#: ../Doc/library/asyncio-protocol.rst:608
msgid "Called to allocate a new receive buffer."
msgstr "Se llama para asignar un nuevo búfer de recepción."

#: ../Doc/library/asyncio-protocol.rst:610
msgid ""
"*sizehint* is the recommended minimum size for the returned buffer.  It is "
"acceptable to return smaller or larger buffers than what *sizehint* "
"suggests.  When set to -1, the buffer size can be arbitrary. It is an error "
"to return a buffer with a zero size."
msgstr ""
"*sizehint* es el tamaño mínimo recomendado para el búfer retornado. Es "
"aceptable retornar búferes más pequeños o más grandes de lo que sugiere "
"*sizehint*. Cuando se establece en -1, el tamaño del búfer puede ser "
"arbitrario. Es un error retornar un búfer con tamaño cero."

#: ../Doc/library/asyncio-protocol.rst:615
msgid ""
"``get_buffer()`` must return an object implementing the :ref:`buffer "
"protocol <bufferobjects>`."
msgstr ""
"``get_buffer()`` debe retornar un objeto que implemente el :ref:`protocolo "
"de búfer <bufferobjects>`."

#: ../Doc/library/asyncio-protocol.rst:620
msgid "Called when the buffer was updated with the received data."
msgstr "Se llama cuando el búfer se ha actualizado con los datos recibidos."

#: ../Doc/library/asyncio-protocol.rst:622
msgid "*nbytes* is the total number of bytes that were written to the buffer."
msgstr "*nbytes* es el número total de bytes que se escribieron en el búfer."

#: ../Doc/library/asyncio-protocol.rst:626
msgid ""
"See the documentation of the :meth:`protocol.eof_received() <Protocol."
"eof_received>` method."
msgstr ""
"Consulte la documentación del método :meth:`protocol.eof_received() "
"<Protocol.eof_received>`."

#: ../Doc/library/asyncio-protocol.rst:630
msgid ""
":meth:`~BufferedProtocol.get_buffer` can be called an arbitrary number of "
"times during a connection.  However, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` is called at most once and, if called, :meth:"
"`~BufferedProtocol.get_buffer` and :meth:`~BufferedProtocol.buffer_updated` "
"won't be called after it."
msgstr ""
":meth:`~BufferedProtocol.get_buffer` se puede llamar un número arbitrario de "
"veces durante una conexión. Sin embargo, :meth:`protocol.eof_received () "
"<Protocol.eof_received>` se llama como máximo una vez y, si se llama, :meth:"
"`~BufferedProtocol.get_buffer` y :meth:`~BufferedProtocol.buffer_updated` no "
"serán llamados después de eso."

#: ../Doc/library/asyncio-protocol.rst:649
msgid "Datagram Protocols"
msgstr "Protocolos de datagramas"

#: ../Doc/library/asyncio-protocol.rst:651
msgid ""
"Datagram Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.create_datagram_endpoint` method."
msgstr ""
"Las instancias del protocolo de datagramas deben ser construidas por "
"fábricas de protocolos pasadas al método :meth:`loop."
"create_datagram_endpoint`."

#: ../Doc/library/asyncio-protocol.rst:656
msgid ""
"Called when a datagram is received.  *data* is a bytes object containing the "
"incoming data.  *addr* is the address of the peer sending the data; the "
"exact format depends on the transport."
msgstr ""
"Se llama cuando se recibe un datagrama. *data* es un objeto bytes que "
"contiene los datos entrantes. *addr* es la dirección del par que envía los "
"datos; el formato exacto depende del transporte."

#: ../Doc/library/asyncio-protocol.rst:662
msgid ""
"Called when a previous send or receive operation raises an :class:"
"`OSError`.  *exc* is the :class:`OSError` instance."
msgstr ""
"Se llama cuando una operación de envío o recepción anterior genera una :"
"class:`OSError`. *exc* es la instancia :class:`OSError`."

#: ../Doc/library/asyncio-protocol.rst:665
msgid ""
"This method is called in rare conditions, when the transport (e.g. UDP) "
"detects that a datagram could not be delivered to its recipient. In many "
"conditions though, undeliverable datagrams will be silently dropped."
msgstr ""
"Este método se llama en condiciones excepcionales, cuando el transporte (por "
"ejemplo, UDP) detecta que un datagrama no se pudo entregar a su "
"destinatario. Sin embargo, en la mayoría de casos, los datagramas que no se "
"puedan entregar se eliminarán silenciosamente."

#: ../Doc/library/asyncio-protocol.rst:672
msgid ""
"On BSD systems (macOS, FreeBSD, etc.) flow control is not supported for "
"datagram protocols, because there is no reliable way to detect send failures "
"caused by writing too many packets."
msgstr ""
"En los sistemas BSD (macOS, FreeBSD, etc.) el control de flujo no es "
"compatible con los protocolos de datagramas, esto se debe a que no hay una "
"forma confiable de detectar fallos de envío causados por escribir demasiados "
"paquetes."

#: ../Doc/library/asyncio-protocol.rst:676
msgid ""
"The socket always appears 'ready' and excess packets are dropped. An :class:"
"`OSError` with ``errno`` set to :const:`errno.ENOBUFS` may or may not be "
"raised; if it is raised, it will be reported to :meth:`DatagramProtocol."
"error_received` but otherwise ignored."
msgstr ""
"El socket siempre aparece como disponible ('ready') y se eliminan los "
"paquetes sobrantes. Un error :class:`OSError` con ``errno`` establecido en :"
"const:`errno.ENOBUFS` puede o no ser generado; si se genera, se informará a :"
"meth:`DatagramProtocol.error_received` pero en caso contrario se ignorará."

#: ../Doc/library/asyncio-protocol.rst:685
msgid "Subprocess Protocols"
msgstr "Protocolos de subprocesos"

#: ../Doc/library/asyncio-protocol.rst:687
msgid ""
"Subprocess Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` "
"methods."
msgstr ""
"Las instancias de protocolo de subproceso deben ser construidas por fábricas "
"de protocolos pasadas a los métodos :meth:`loop.subprocess_exec` y :meth:"
"`loop.subprocess_shell`."

#: ../Doc/library/asyncio-protocol.rst:693
msgid ""
"Called when the child process writes data into its stdout or stderr pipe."
msgstr ""
"Se llama cuando el proceso hijo escribe datos en su pipe stdout o stderr."

#: ../Doc/library/asyncio-protocol.rst:696
msgid "*fd* is the integer file descriptor of the pipe."
msgstr "*fd* es el descriptor de archivo entero de la pipe."

#: ../Doc/library/asyncio-protocol.rst:698
msgid "*data* is a non-empty bytes object containing the received data."
msgstr "*data* es un objeto bytes no vacío que contiene los datos recibidos."

#: ../Doc/library/asyncio-protocol.rst:702
msgid ""
"Called when one of the pipes communicating with the child process is closed."
msgstr ""
"Se llama cuando se cierra una de las pipes que se comunican con el proceso "
"hijo."

#: ../Doc/library/asyncio-protocol.rst:705
msgid "*fd* is the integer file descriptor that was closed."
msgstr "*fd* es el descriptor de archivo entero que se cerró."

#: ../Doc/library/asyncio-protocol.rst:709
msgid "Called when the child process has exited."
msgstr "Se llama cuando el proceso hijo ha finalizado."

#: ../Doc/library/asyncio-protocol.rst:713
msgid "Examples"
msgstr "Ejemplos"

#: ../Doc/library/asyncio-protocol.rst:718
msgid "TCP Echo Server"
msgstr "Servidor de eco TCP"

#: ../Doc/library/asyncio-protocol.rst:720
msgid ""
"Create a TCP echo server using the :meth:`loop.create_server` method, send "
"back received data, and close the connection::"
msgstr ""
"Crear un servidor de eco TCP usando el método :meth:`loop.create_server`, "
"enviar de vuelta los datos recibidos y cerrar la conexión::"

#: ../Doc/library/asyncio-protocol.rst:761
msgid ""
"The :ref:`TCP echo server using streams <asyncio-tcp-echo-server-streams>` "
"example uses the high-level :func:`asyncio.start_server` function."
msgstr ""
"El ejemplo :ref:`Servidor de eco TCP usando streams <asyncio-tcp-echo-server-"
"streams>` usa la función de alto nivel :func:`asyncio.start_server`."

#: ../Doc/library/asyncio-protocol.rst:767
msgid "TCP Echo Client"
msgstr "Cliente de eco TCP"

#: ../Doc/library/asyncio-protocol.rst:769
msgid ""
"A TCP echo client using the :meth:`loop.create_connection` method, sends "
"data, and waits until the connection is closed::"
msgstr ""
"Un cliente de eco TCP usando el método :meth:`loop.create_connection`, envía "
"datos y espera hasta que la conexión se cierre::"

#: ../Doc/library/asyncio-protocol.rst:817
msgid ""
"The :ref:`TCP echo client using streams <asyncio-tcp-echo-client-streams>` "
"example uses the high-level :func:`asyncio.open_connection` function."
msgstr ""
"El ejemplo :ref:`Cliente de eco TCP usando streams <asyncio-tcp-echo-client-"
"streams>` usa la función de alto nivel :func:`asyncio.open_connection`."

#: ../Doc/library/asyncio-protocol.rst:824
msgid "UDP Echo Server"
msgstr "Servidor de eco UDP"

#: ../Doc/library/asyncio-protocol.rst:826
msgid ""
"A UDP echo server, using the :meth:`loop.create_datagram_endpoint` method, "
"sends back received data::"
msgstr ""
"Un servidor de eco UDP, usando el método :meth:`loop."
"create_datagram_endpoint`, envía de vuelta los datos recibidos::"

#: ../Doc/library/asyncio-protocol.rst:868
msgid "UDP Echo Client"
msgstr "Cliente de eco UDP"

#: ../Doc/library/asyncio-protocol.rst:870
msgid ""
"A UDP echo client, using the :meth:`loop.create_datagram_endpoint` method, "
"sends data and closes the transport when it receives the answer::"
msgstr ""
"Un cliente de eco UDP, usando el método :meth:`loop."
"create_datagram_endpoint`, envía datos y cierra el transporte cuando recibe "
"la respuesta:"

#: ../Doc/library/asyncio-protocol.rst:925
msgid "Connecting Existing Sockets"
msgstr "Conectando sockets existentes"

#: ../Doc/library/asyncio-protocol.rst:927
msgid ""
"Wait until a socket receives data using the :meth:`loop.create_connection` "
"method with a protocol::"
msgstr ""
"Espera hasta que un socket reciba datos usando el método :meth:`loop."
"create_connection` mediante un protocolo::"

#: ../Doc/library/asyncio-protocol.rst:981
msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level :meth:`loop."
"add_reader` method to register an FD."
msgstr ""
"El ejemplo :ref:`monitorizar eventos de lectura en un descriptor de archivo "
"<asyncio_example_watch_fd>` utiliza el método de bajo nivel :meth:`loop."
"add_reader` para registrar un descriptor de archivo."

#: ../Doc/library/asyncio-protocol.rst:985
msgid ""
"The :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` example uses high-level streams "
"created by the :func:`open_connection` function in a coroutine."
msgstr ""
"El ejemplo :ref:`registrar un socket abierto a la espera de datos usando "
"streams <asyncio_example_create_connection-streams>` usa *streams* de alto "
"nivel creados por la función :func:`open_connection` en una corrutina."

#: ../Doc/library/asyncio-protocol.rst:992
msgid "loop.subprocess_exec() and SubprocessProtocol"
msgstr "*loop.subprocess_exec()* y *SubprocessProtocol*"

#: ../Doc/library/asyncio-protocol.rst:994
msgid ""
"An example of a subprocess protocol used to get the output of a subprocess "
"and to wait for the subprocess exit."
msgstr ""
"Un ejemplo de un protocolo de subproceso que se utiliza para obtener la "
"salida de un subproceso y esperar su terminación."

#: ../Doc/library/asyncio-protocol.rst:997
msgid "The subprocess is created by the :meth:`loop.subprocess_exec` method::"
msgstr "El subproceso es creado por el método :meth:`loop.subprocess_exec` ::"

#: ../Doc/library/asyncio-protocol.rst:1043
msgid ""
"See also the :ref:`same example <asyncio_example_create_subprocess_exec>` "
"written using high-level APIs."
msgstr ""
"Consulte también el :ref:`mismo ejemplo "
"<asyncio_example_create_subprocess_exec>` escrito utilizando la API de alto "
"nivel."
