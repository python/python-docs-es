# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-05 12:54+0200\n"
"PO-Revision-Date: 2020-09-07 15:02+0200\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: Francisco Jesús Sevilla García <fjsevilla.dev@gmail.com>\n"
"Language: es\n"
"X-Generator: Poedit 2.4.1\n"

#: ../Doc/library/asyncio-protocol.rst:9
msgid "Transports and Protocols"
msgstr "Transportes y protocolos"

#: ../Doc/library/asyncio-protocol.rst:12
msgid "Preface"
msgstr "Prefacio"

#: ../Doc/library/asyncio-protocol.rst:13
msgid ""
"Transports and Protocols are used by the **low-level** event loop APIs such "
"as :meth:`loop.create_connection`.  They use callback-based programming "
"style and enable high-performance implementations of network or IPC "
"protocols (e.g. HTTP)."
msgstr ""
"Los transportes y protocolos son utilizados por las APIs de **bajo nivel** "
"de los bucles de eventos, como :meth:`loop.create_connection`. Utilizan un "
"estilo de programación basado en retrollamadas y permiten implementaciones "
"de alto rendimiento de protocolos de red o IPC (p. ej. HTTP)."

#: ../Doc/library/asyncio-protocol.rst:18
msgid ""
"Essentially, transports and protocols should only be used in libraries and "
"frameworks and never in high-level asyncio applications."
msgstr ""
"Esencialmente, los transportes y protocolos solo deben usarse en bibliotecas "
"y frameworks, nunca en aplicaciones asyncio de alto nivel."

#: ../Doc/library/asyncio-protocol.rst:22
msgid "This documentation page covers both `Transports`_ and `Protocols`_."
msgstr ""
"Esta página de la documentación cubre tanto `Transports`_ como `Protocols`_."

#: ../Doc/library/asyncio-protocol.rst:25
msgid "Introduction"
msgstr "Introducción"

#: ../Doc/library/asyncio-protocol.rst:26
msgid ""
"At the highest level, the transport is concerned with *how* bytes are "
"transmitted, while the protocol determines *which* bytes to transmit (and to "
"some extent when)."
msgstr ""
"En el nivel más alto, el transporte se ocupa de *cómo* se transmiten los "
"bytes, mientras que el protocolo determina *qué* bytes transmitir (y hasta "
"cierto punto cuándo)."

#: ../Doc/library/asyncio-protocol.rst:30
msgid ""
"A different way of saying the same thing: a transport is an abstraction for "
"a socket (or similar I/O endpoint) while a protocol is an abstraction for an "
"application, from the transport's point of view."
msgstr ""
"Una forma diferente de decir lo mismo: Un transporte es una abstracción para "
"un socket (o un punto final de E/S similar) mientras que un protocolo es una "
"abstracción para una aplicación, desde el punto de vista del transporte."

#: ../Doc/library/asyncio-protocol.rst:35
msgid ""
"Yet another view is the transport and protocol interfaces together define an "
"abstract interface for using network I/O and interprocess I/O."
msgstr ""
"Otro punto de vista más es que las interfaces de transporte y protocolo "
"definen juntas una interfaz abstracta para usar E/S de red y E/S entre "
"procesos."

#: ../Doc/library/asyncio-protocol.rst:39
msgid ""
"There is always a 1:1 relationship between transport and protocol objects: "
"the protocol calls transport methods to send data, while the transport calls "
"protocol methods to pass it data that has been received."
msgstr ""
"Siempre existe una relación 1:1 entre el transporte y los objetos protocolo: "
"el protocolo llama a los métodos del transporte para enviar datos, mientras "
"que el transporte llama a los métodos del protocolo para enviarle los datos "
"que se han recibido."

#: ../Doc/library/asyncio-protocol.rst:44
msgid ""
"Most of connection oriented event loop methods (such as :meth:`loop."
"create_connection`) usually accept a *protocol_factory* argument used to "
"create a *Protocol* object for an accepted connection, represented by a "
"*Transport* object. Such methods usually return a tuple of ``(transport, "
"protocol)``."
msgstr ""
"La mayoría de los métodos del bucle de eventos orientados a la conexión "
"(como :meth:`loop.create_connection`) aceptan generalmente un argumento "
"*protocol_factory* que es usado para crear un objeto *Protocol* para una "
"conexión aceptada, representada por un objeto *Transport*. Estos métodos "
"suelen retornar una tupla de la forma ``(transporte, protocolo)``."

#: ../Doc/library/asyncio-protocol.rst:51
msgid "Contents"
msgstr "Contenidos"

#: ../Doc/library/asyncio-protocol.rst:52
msgid "This documentation page contains the following sections:"
msgstr "Esta página de la documentación contiene las siguientes secciones:"

#: ../Doc/library/asyncio-protocol.rst:54
msgid ""
"The `Transports`_ section documents asyncio :class:`BaseTransport`, :class:"
"`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, :class:"
"`DatagramTransport`, and :class:`SubprocessTransport` classes."
msgstr ""
"La sección `Transports`_ documenta las clases asyncio :class:"
"`BaseTransport`, :class:`ReadTransport`, :class:`WriteTransport`, :class:"
"`Transport`, :class:`DatagramTransport` y :class:`SubprocessTransport`."

#: ../Doc/library/asyncio-protocol.rst:59
msgid ""
"The `Protocols`_ section documents asyncio :class:`BaseProtocol`, :class:"
"`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol`, and :class:"
"`SubprocessProtocol` classes."
msgstr ""
"La sección `Protocols`_ documenta las clases asyncio :class:`BaseProtocol`, :"
"class:`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol` y :"
"class:`SubprocessProtocol`."

#: ../Doc/library/asyncio-protocol.rst:63
msgid ""
"The `Examples`_ section showcases how to work with transports, protocols, "
"and low-level event loop APIs."
msgstr ""
"La sección `Examples`_ muestra cómo trabajar con transportes, protocolos y "
"las APIs de bajo nivel del bucle de eventos."

#: ../Doc/library/asyncio-protocol.rst:70
msgid "Transports"
msgstr "Transportes"

#: ../Doc/library/asyncio-protocol.rst:72
msgid "**Source code:** :source:`Lib/asyncio/transports.py`"
msgstr "**Código fuente:** :source:`Lib/asyncio/transports.py`"

#: ../Doc/library/asyncio-protocol.rst:76
msgid ""
"Transports are classes provided by :mod:`asyncio` in order to abstract "
"various kinds of communication channels."
msgstr ""
"Los transportes son clases proporcionadas por :mod:`asyncio` para abstraer "
"varios tipos de canales de comunicación."

#: ../Doc/library/asyncio-protocol.rst:79
msgid ""
"Transport objects are always instantiated by an :ref:`asyncio event loop "
"<asyncio-event-loop>`."
msgstr ""
"Los objetos transporte siempre son instanciados por un :ref:`bucle de "
"eventos asyncio <asyncio-event-loop>`."

#: ../Doc/library/asyncio-protocol.rst:82
msgid ""
"asyncio implements transports for TCP, UDP, SSL, and subprocess pipes. The "
"methods available on a transport depend on the transport's kind."
msgstr ""
"asyncio implementa transportes para TCP, UDP, SSL y pipes de subprocesos. "
"Los métodos disponibles en un transporte dependen del tipo de transporte."

#: ../Doc/library/asyncio-protocol.rst:85
msgid ""
"The transport classes are :ref:`not thread safe <asyncio-multithreading>`."
msgstr ""
"Las clases transporte :ref:`no son seguras en hilos <asyncio-"
"multithreading>`."

#: ../Doc/library/asyncio-protocol.rst:89
msgid "Transports Hierarchy"
msgstr "Jerarquía de transportes"

#: ../Doc/library/asyncio-protocol.rst:93
msgid ""
"Base class for all transports.  Contains methods that all asyncio transports "
"share."
msgstr ""
"Clase base para todos los transportes. Contiene métodos que todos los "
"transportes asyncio comparten."

#: ../Doc/library/asyncio-protocol.rst:98
msgid "A base transport for write-only connections."
msgstr "Un transporte base para conexiones de solo escritura."

#: ../Doc/library/asyncio-protocol.rst:100
msgid ""
"Instances of the *WriteTransport* class are returned from the :meth:`loop."
"connect_write_pipe` event loop method and are also used by subprocess-"
"related methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Las instancias de la clase *WriteTransport* se retornan desde el método del "
"bucle de eventos :meth:`loop.connect_write_pipe` y también se utilizan en "
"métodos relacionados con subprocesos como :meth:`loop.subprocess_exec`."

#: ../Doc/library/asyncio-protocol.rst:107
msgid "A base transport for read-only connections."
msgstr "Un transporte base para conexiones de solo lectura."

#: ../Doc/library/asyncio-protocol.rst:109
msgid ""
"Instances of the *ReadTransport* class are returned from the :meth:`loop."
"connect_read_pipe` event loop method and are also used by subprocess-related "
"methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Las instancias de la clase *ReadTransport* se retornan desde el método del "
"bucle de eventos :meth:`loop.connect_read_pipe` y también se utilizan en "
"métodos relacionados con subprocesos como :meth:`loop.subprocess_exec`."

#: ../Doc/library/asyncio-protocol.rst:116
msgid ""
"Interface representing a bidirectional transport, such as a TCP connection."
msgstr ""
"Interfaz que representa un transporte bidireccional, como una conexión TCP."

#: ../Doc/library/asyncio-protocol.rst:119
msgid ""
"The user does not instantiate a transport directly; they call a utility "
"function, passing it a protocol factory and other information necessary to "
"create the transport and protocol."
msgstr ""
"El usuario no crea una instancia de transporte directamente; en su lugar se "
"llama a una función de utilidad, pasándole una fábrica de protocolos junto a "
"otra información necesaria para crear el transporte y el protocolo."

#: ../Doc/library/asyncio-protocol.rst:123
msgid ""
"Instances of the *Transport* class are returned from or used by event loop "
"methods like :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop.sendfile`, "
"etc."
msgstr ""
"Las instancias de la clase *Transport* son retornadas o utilizadas por "
"métodos del bucle de eventos como :meth:`loop.create_connection`, :meth:"
"`loop.create_unix_connection`, :meth:`loop.create_server`, :meth:`loop."
"sendfile`, etc."

#: ../Doc/library/asyncio-protocol.rst:131
msgid "A transport for datagram (UDP) connections."
msgstr "Un transporte para conexiones de datagramas (UDP)."

#: ../Doc/library/asyncio-protocol.rst:133
msgid ""
"Instances of the *DatagramTransport* class are returned from the :meth:`loop."
"create_datagram_endpoint` event loop method."
msgstr ""
"Las instancias de la clase *DatagramTransport* se retornan desde el método :"
"meth:`loop.create_datagram_endpoint` del bucle de eventos."

#: ../Doc/library/asyncio-protocol.rst:139
msgid ""
"An abstraction to represent a connection between a parent and its child OS "
"process."
msgstr ""
"Una abstracción para representar una conexión entre un proceso padre y su "
"proceso OS hijo."

#: ../Doc/library/asyncio-protocol.rst:142
msgid ""
"Instances of the *SubprocessTransport* class are returned from event loop "
"methods :meth:`loop.subprocess_shell` and :meth:`loop.subprocess_exec`."
msgstr ""
"Las instancias de la clase *SubprocessTransport* se retornan desde los "
"métodos del bucle de eventos :meth:`loop.subprocess_shell` y :meth:`loop."
"subprocess_exec`."

#: ../Doc/library/asyncio-protocol.rst:148
msgid "Base Transport"
msgstr "Transporte base"

#: ../Doc/library/asyncio-protocol.rst:152
msgid "Close the transport."
msgstr "Cierra el transporte."

#: ../Doc/library/asyncio-protocol.rst:154
msgid ""
"If the transport has a buffer for outgoing data, buffered data will be "
"flushed asynchronously.  No more data will be received.  After all buffered "
"data is flushed, the protocol's :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` method will be called with :const:`None` as "
"its argument."
msgstr ""
"Si el transporte tiene un búfer para datos de salida, los datos almacenados "
"en el búfer se eliminarán de forma asincrónica. No se recibirán más datos. "
"Después de que se vacíen todos los datos almacenados en el búfer, el método :"
"meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` del "
"protocolo se llamará con :const:`None` como argumento."

#: ../Doc/library/asyncio-protocol.rst:163
msgid "Return ``True`` if the transport is closing or is closed."
msgstr "Retorna ``True`` si el transporte se está cerrando o está ya cerrado."

#: ../Doc/library/asyncio-protocol.rst:167
msgid "Return information about the transport or underlying resources it uses."
msgstr ""
"Retorna información sobre el transporte o los recursos subyacentes que "
"utiliza."

#: ../Doc/library/asyncio-protocol.rst:170
msgid ""
"*name* is a string representing the piece of transport-specific information "
"to get."
msgstr ""
"*name* es una cadena de caracteres que representa la información específica "
"del transporte que se va a obtener."

#: ../Doc/library/asyncio-protocol.rst:173
msgid ""
"*default* is the value to return if the information is not available, or if "
"the transport does not support querying it with the given third-party event "
"loop implementation or on the current platform."
msgstr ""
"*default* es el valor que se retornará si la información no está disponible "
"o si el transporte no admite la consulta con la implementación del bucle de "
"eventos de terceros dada o en la plataforma actual."

#: ../Doc/library/asyncio-protocol.rst:178
msgid ""
"For example, the following code attempts to get the underlying socket object "
"of the transport::"
msgstr ""
"Por ejemplo, el siguiente código intenta obtener el objeto socket subyacente "
"del transporte:"

#: ../Doc/library/asyncio-protocol.rst:185
msgid "Categories of information that can be queried on some transports:"
msgstr ""
"Categorías de información que se pueden consultar sobre algunos transportes:"

#: ../Doc/library/asyncio-protocol.rst:187
msgid "socket:"
msgstr "socket:"

#: ../Doc/library/asyncio-protocol.rst:189
msgid ""
"``'peername'``: the remote address to which the socket is connected, result "
"of :meth:`socket.socket.getpeername` (``None`` on error)"
msgstr ""
"``'peername'``: la dirección remota a la que está conectado el socket, "
"resultado de :meth:`socket.socket.getpeername` (``None`` en caso de error)"

#: ../Doc/library/asyncio-protocol.rst:193
msgid "``'socket'``: :class:`socket.socket` instance"
msgstr "``'socket'``: instancia de :class:`socket.socket`"

#: ../Doc/library/asyncio-protocol.rst:195
msgid ""
"``'sockname'``: the socket's own address, result of :meth:`socket.socket."
"getsockname`"
msgstr ""
"``'sockname'``: la dirección propia del socket, resultado de :meth:`socket."
"socket.getsockname`"

#: ../Doc/library/asyncio-protocol.rst:198
msgid "SSL socket:"
msgstr "socket SSL:"

#: ../Doc/library/asyncio-protocol.rst:200
msgid ""
"``'compression'``: the compression algorithm being used as a string, or "
"``None`` if the connection isn't compressed; result of :meth:`ssl.SSLSocket."
"compression`"
msgstr ""
"``'compression'``: el algoritmo de compresión que se está usando como una "
"cadena de caracteres o ``None`` si la conexión no está comprimida; resultado "
"de :meth:`ssl.SSLSocket.compression`"

#: ../Doc/library/asyncio-protocol.rst:204
msgid ""
"``'cipher'``: a three-value tuple containing the name of the cipher being "
"used, the version of the SSL protocol that defines its use, and the number "
"of secret bits being used; result of :meth:`ssl.SSLSocket.cipher`"
msgstr ""
"``'cipher'``: una tupla de tres valores que contiene el nombre del cifrado "
"que se está utilizando, la versión del protocolo SSL que define su uso y la "
"cantidad de bits de la clave secreta que se utilizan; resultado de :meth:"
"`ssl.SSLSocket.cipher`"

#: ../Doc/library/asyncio-protocol.rst:209
msgid ""
"``'peercert'``: peer certificate; result of :meth:`ssl.SSLSocket.getpeercert`"
msgstr ""
"``'peercert'``: certificado de pares; resultado de :meth:`ssl.SSLSocket."
"getpeercert`"

#: ../Doc/library/asyncio-protocol.rst:212
msgid "``'sslcontext'``: :class:`ssl.SSLContext` instance"
msgstr "``'sslcontext'``: instancia de :class:`ssl.SSLContext`"

#: ../Doc/library/asyncio-protocol.rst:214
msgid ""
"``'ssl_object'``: :class:`ssl.SSLObject` or :class:`ssl.SSLSocket` instance"
msgstr ""
"``'ssl_object'``: instancia de :class:`ssl.SSLObject` o :class:`ssl."
"SSLSocket`"

#: ../Doc/library/asyncio-protocol.rst:217
msgid "pipe:"
msgstr "pipe:"

#: ../Doc/library/asyncio-protocol.rst:219
msgid "``'pipe'``: pipe object"
msgstr "``'pipe'``: objeto pipe"

#: ../Doc/library/asyncio-protocol.rst:221
msgid "subprocess:"
msgstr "subproceso:"

#: ../Doc/library/asyncio-protocol.rst:223
msgid "``'subprocess'``: :class:`subprocess.Popen` instance"
msgstr "``'subprocess'``: instancia de :class:`subprocess.Popen`"

#: ../Doc/library/asyncio-protocol.rst:227
msgid "Set a new protocol."
msgstr "Establece un nuevo protocolo."

#: ../Doc/library/asyncio-protocol.rst:229
msgid ""
"Switching protocol should only be done when both protocols are documented to "
"support the switch."
msgstr ""
"El cambio de protocolo solo debe realizarse cuando esté documentado que "
"ambos protocolos admiten el cambio."

#: ../Doc/library/asyncio-protocol.rst:234
msgid "Return the current protocol."
msgstr "Retorna el protocolo actual."

#: ../Doc/library/asyncio-protocol.rst:238
msgid "Read-only Transports"
msgstr "Transportes de solo lectura"

#: ../Doc/library/asyncio-protocol.rst:242
msgid "Return ``True`` if the transport is receiving new data."
msgstr "Retorna ``True`` si el transporte está recibiendo nuevos datos."

#: ../Doc/library/asyncio-protocol.rst:248
msgid ""
"Pause the receiving end of the transport.  No data will be passed to the "
"protocol's :meth:`protocol.data_received() <Protocol.data_received>` method "
"until :meth:`resume_reading` is called."
msgstr ""
"Pausa el extremo receptor del transporte. No se pasarán datos al método :"
"meth:`protocol.data_received() <Protocol.data_received>` del protocolo hasta "
"que se llame a :meth:`resume_reading`."

#: ../Doc/library/asyncio-protocol.rst:252
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already paused or closed."
msgstr ""
"El método es idempotente, es decir, se puede llamar cuando el transporte ya "
"está en pausa o cerrado."

#: ../Doc/library/asyncio-protocol.rst:258
msgid ""
"Resume the receiving end.  The protocol's :meth:`protocol.data_received() "
"<Protocol.data_received>` method will be called once again if some data is "
"available for reading."
msgstr ""
"Reanuda el extremo receptor. El método :meth:`protocol.data_received() "
"<Protocol.data_received>` del protocolo se llamará una vez más si hay "
"algunos datos disponibles para su lectura."

#: ../Doc/library/asyncio-protocol.rst:262
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already reading."
msgstr ""
"El método es idempotente, es decir, se puede llamar cuando el transporte "
"está leyendo."

#: ../Doc/library/asyncio-protocol.rst:268
msgid "Write-only Transports"
msgstr "Transportes de solo escritura"

#: ../Doc/library/asyncio-protocol.rst:272
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost.  No more data will be received. The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Cierra el transporte inmediatamente, sin esperar a que finalicen las "
"operaciones pendientes. Se perderán los datos almacenados en el búfer. No se "
"recibirán más datos. El método :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` del protocolo será llamado eventualmente "
"con :const:`None` como argumento."

#: ../Doc/library/asyncio-protocol.rst:280
msgid ""
"Return :const:`True` if the transport supports :meth:`~WriteTransport."
"write_eof`, :const:`False` if not."
msgstr ""
"Retorna :const:`True` si el transporte admite :meth:`~WriteTransport."
"write_eof`, en caso contrario :const:`False`."

#: ../Doc/library/asyncio-protocol.rst:285
msgid "Return the current size of the output buffer used by the transport."
msgstr ""
"Retorna el tamaño actual del búfer de salida utilizado por el transporte."

#: ../Doc/library/asyncio-protocol.rst:289
msgid ""
"Get the *high* and *low* watermarks for write flow control. Return a tuple "
"``(low, high)`` where *low* and *high* are positive number of bytes."
msgstr ""
"Obtiene los límites superior e inferior para el control del flujo de "
"escritura. Retorna una tupla ``(low, high)`` donde *low* ('inferior') y "
"*high* ('superior') son un número de bytes positivo."

#: ../Doc/library/asyncio-protocol.rst:293
msgid "Use :meth:`set_write_buffer_limits` to set the limits."
msgstr "Usa :meth:`set_write_buffer_limits` para establecer los límites."

#: ../Doc/library/asyncio-protocol.rst:299
msgid "Set the *high* and *low* watermarks for write flow control."
msgstr ""
"Establece los límites *high* ('superior') y *low* ('inferior') para el "
"control del flujo de escritura."

#: ../Doc/library/asyncio-protocol.rst:301
msgid ""
"These two values (measured in number of bytes) control when the protocol's :"
"meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` and :meth:"
"`protocol.resume_writing() <BaseProtocol.resume_writing>` methods are "
"called. If specified, the low watermark must be less than or equal to the "
"high watermark.  Neither *high* nor *low* can be negative."
msgstr ""
"Estos dos valores (medidos en número de bytes) controlan cuándo se llaman "
"los métodos :meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` y :"
"meth:`protocol.resume_writing() <BaseProtocol.resume_writing>` del "
"protocolo . Si se especifica, el límite inferior debe ser menor o igual que "
"el límite superior. Ni *high* ni *low* pueden ser negativos."

#: ../Doc/library/asyncio-protocol.rst:309
msgid ""
":meth:`~BaseProtocol.pause_writing` is called when the buffer size becomes "
"greater than or equal to the *high* value. If writing has been paused, :meth:"
"`~BaseProtocol.resume_writing` is called when the buffer size becomes less "
"than or equal to the *low* value."
msgstr ""
":meth:`~BaseProtocol.pause_writing` se llama cuando el tamaño del búfer es "
"mayor o igual que el valor *high* ('superior'). Si se ha pausado la "
"escritura, se llama a :meth:`~BaseProtocol.resume_writing` cuando el tamaño "
"del búfer es menor o igual que el valor *low* ('inferior')."

#: ../Doc/library/asyncio-protocol.rst:314
msgid ""
"The defaults are implementation-specific.  If only the high watermark is "
"given, the low watermark defaults to an implementation-specific value less "
"than or equal to the high watermark.  Setting *high* to zero forces *low* to "
"zero as well, and causes :meth:`~BaseProtocol.pause_writing` to be called "
"whenever the buffer becomes non-empty.  Setting *low* to zero causes :meth:"
"`~BaseProtocol.resume_writing` to be called only once the buffer is empty. "
"Use of zero for either limit is generally sub-optimal as it reduces "
"opportunities for doing I/O and computation concurrently."
msgstr ""
"Los valores por defecto son específicos de la implementación. Si solo se "
"proporciona el límite superior, el inferior toma de forma predeterminada un "
"valor específico, dependiente de la implementación, menor o igual que el "
"límite superior. Establecer *high* ('superior') en cero fuerza *low* "
"('inferior') a cero también y hace que :meth:`~BaseProtocol.pause_writing` "
"sea llamado siempre que el búfer no esté vacío. Establecer *low* "
"('inferior') en cero hace que :meth:`~BaseProtocol.resume_writing` sea "
"llamado únicamente cuando el búfer esté vacío. El uso de cero para "
"cualquiera de los límites es generalmente subóptimo, ya que reduce las "
"oportunidades para realizar E/S y cálculos simultáneamente."

#: ../Doc/library/asyncio-protocol.rst:325
msgid "Use :meth:`~WriteTransport.get_write_buffer_limits` to get the limits."
msgstr ""
"Usa :meth:`~WriteTransport.get_write_buffer_limits` para obtener los límites."

#: ../Doc/library/asyncio-protocol.rst:330
msgid "Write some *data* bytes to the transport."
msgstr "Escribe los bytes de *data* en el transporte."

#: ../Doc/library/asyncio-protocol.rst:332
#: ../Doc/library/asyncio-protocol.rst:361
msgid ""
"This method does not block; it buffers the data and arranges for it to be "
"sent out asynchronously."
msgstr ""
"Este método no bloquea; almacena los datos en el búfer y organiza que se "
"envíen de forma asincrónica."

#: ../Doc/library/asyncio-protocol.rst:337
msgid ""
"Write a list (or any iterable) of data bytes to the transport. This is "
"functionally equivalent to calling :meth:`write` on each element yielded by "
"the iterable, but may be implemented more efficiently."
msgstr ""
"Escribe una lista (o cualquier iterable) de bytes de datos en el transporte. "
"Esto es funcionalmente equivalente a llamar a :meth:`write` en cada elemento "
"generado por el iterable, pero puede ser implementado de manera más "
"eficiente."

#: ../Doc/library/asyncio-protocol.rst:344
msgid ""
"Close the write end of the transport after flushing all buffered data. Data "
"may still be received."
msgstr ""
"Cierra el extremo de escritura del transporte después de vaciar todos los "
"datos almacenados en el búfer. Aún es posible recibir datos."

#: ../Doc/library/asyncio-protocol.rst:347
msgid ""
"This method can raise :exc:`NotImplementedError` if the transport (e.g. SSL) "
"doesn't support half-closed connections."
msgstr ""
"Este método puede lanzar una excepción :exc:`NotImplementedError` si el "
"transporte (p. ej. SSL) no soporta conexiones half-closed ('semi-cerradas')."

#: ../Doc/library/asyncio-protocol.rst:352
msgid "Datagram Transports"
msgstr "Transportes de datagramas"

#: ../Doc/library/asyncio-protocol.rst:356
msgid ""
"Send the *data* bytes to the remote peer given by *addr* (a transport-"
"dependent target address).  If *addr* is :const:`None`, the data is sent to "
"the target address given on transport creation."
msgstr ""
"Envía los bytes *data* al par remoto proporcionado por *addr* (una dirección "
"de destino dependiente del transporte). Si *addr* es :const:`None`, los "
"datos se envían a la dirección de destino proporcionada en la creación del "
"transporte."

#: ../Doc/library/asyncio-protocol.rst:366
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost. No more data will be received.  The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Cierra el transporte inmediatamente, sin esperar a que finalicen las "
"operaciones pendientes. Se perderán los datos almacenados en el búfer. No se "
"recibirán más datos. El método :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` del protocolo será llamado eventualmente "
"con :const:`None` como argumento."

#: ../Doc/library/asyncio-protocol.rst:376
msgid "Subprocess Transports"
msgstr "Transportes de subprocesos"

#: ../Doc/library/asyncio-protocol.rst:380
msgid "Return the subprocess process id as an integer."
msgstr "Retorna la id del subproceso como un número entero."

#: ../Doc/library/asyncio-protocol.rst:384
msgid ""
"Return the transport for the communication pipe corresponding to the integer "
"file descriptor *fd*:"
msgstr ""
"Retorna el transporte para la pipe de comunicación correspondiente al "
"descriptor de archivo entero *fd*:"

#: ../Doc/library/asyncio-protocol.rst:387
msgid ""
"``0``: readable streaming transport of the standard input (*stdin*), or :"
"const:`None` if the subprocess was not created with ``stdin=PIPE``"
msgstr ""
"``0``: transporte de *streaming* para lectura de la entrada estándar "
"(*stdin*) o :const:`None` si el subproceso no se creó con ``stdin = PIPE``"

#: ../Doc/library/asyncio-protocol.rst:389
msgid ""
"``1``: writable streaming transport of the standard output (*stdout*), or :"
"const:`None` if the subprocess was not created with ``stdout=PIPE``"
msgstr ""
"``1``: transporte de *streaming* para escritura de la salida estándar "
"(*stdout*) o :const:`None` si el subproceso no se creó con ``stdout = PIPE``"

#: ../Doc/library/asyncio-protocol.rst:391
msgid ""
"``2``: writable streaming transport of the standard error (*stderr*), or :"
"const:`None` if the subprocess was not created with ``stderr=PIPE``"
msgstr ""
"`2``: transporte de *streaming* para escritura del error estándar (*stderr*) "
"o :const:`None` si el subproceso no se creó con ``stderr = PIPE``"

#: ../Doc/library/asyncio-protocol.rst:393
msgid "other *fd*: :const:`None`"
msgstr "otro *fd*: :const:`None`"

#: ../Doc/library/asyncio-protocol.rst:397
msgid ""
"Return the subprocess return code as an integer or :const:`None` if it "
"hasn't returned, which is similar to the :attr:`subprocess.Popen.returncode` "
"attribute."
msgstr ""
"Retorna el código de retorno del subproceso como un entero o :const:`None` "
"si no ha retornado aún, lo que es similar al atributo :attr:`subprocess."
"Popen.returncode`."

#: ../Doc/library/asyncio-protocol.rst:403
msgid "Kill the subprocess."
msgstr "Mata al subproceso."

#: ../Doc/library/asyncio-protocol.rst:405
msgid ""
"On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, "
"this method is an alias for :meth:`terminate`."
msgstr ""
"En los sistemas POSIX, la función envía SIGKILL al subproceso. En Windows, "
"este método es un alias para :meth:`terminate`."

#: ../Doc/library/asyncio-protocol.rst:408
msgid "See also :meth:`subprocess.Popen.kill`."
msgstr "Ver también :meth:`subprocess.Popen.kill`."

#: ../Doc/library/asyncio-protocol.rst:412
msgid ""
"Send the *signal* number to the subprocess, as in :meth:`subprocess.Popen."
"send_signal`."
msgstr ""
"Envía el número de *señal* al subproceso, como en :meth:`subprocess.Popen."
"send_signal`."

#: ../Doc/library/asyncio-protocol.rst:417
msgid "Stop the subprocess."
msgstr "Detiene el subproceso."

#: ../Doc/library/asyncio-protocol.rst:419
msgid ""
"On POSIX systems, this method sends SIGTERM to the subprocess. On Windows, "
"the Windows API function TerminateProcess() is called to stop the subprocess."
msgstr ""
"En los sistemas POSIX, este método envía SIGTERM al subproceso. En Windows, "
"se llama a la función de la API de Windows *TerminateProcess()* para detener "
"el subproceso."

#: ../Doc/library/asyncio-protocol.rst:423
msgid "See also :meth:`subprocess.Popen.terminate`."
msgstr "Ver también :meth:`subprocess.Popen.terminate`."

#: ../Doc/library/asyncio-protocol.rst:427
msgid "Kill the subprocess by calling the :meth:`kill` method."
msgstr "Mata al subproceso llamando al método :meth:`kill`."

#: ../Doc/library/asyncio-protocol.rst:429
msgid ""
"If the subprocess hasn't returned yet, and close transports of *stdin*, "
"*stdout*, and *stderr* pipes."
msgstr ""
"Si el subproceso aún no ha retornado, cierra los transportes de las pipes "
"*stdin*, *stdout* y *stderr*."

#: ../Doc/library/asyncio-protocol.rst:436
msgid "Protocols"
msgstr "Protocolos"

#: ../Doc/library/asyncio-protocol.rst:438
msgid "**Source code:** :source:`Lib/asyncio/protocols.py`"
msgstr "**Código fuente:** :source:`Lib/asyncio/protocols.py`"

#: ../Doc/library/asyncio-protocol.rst:442
msgid ""
"asyncio provides a set of abstract base classes that should be used to "
"implement network protocols.  Those classes are meant to be used together "
"with :ref:`transports <asyncio-transport>`."
msgstr ""
"asyncio proporciona un conjunto de clases base abstractas que pueden usarse "
"para implementar protocolos de red. Estas clases están destinadas a ser "
"utilizadas junto con los :ref:`transportes <asyncio-transport>`."

#: ../Doc/library/asyncio-protocol.rst:446
msgid ""
"Subclasses of abstract base protocol classes may implement some or all "
"methods.  All these methods are callbacks: they are called by transports on "
"certain events, for example when some data is received. A base protocol "
"method should be called by the corresponding transport."
msgstr ""
"Las subclases de las clases abstractas de protocolos base pueden implementar "
"algunos o todos los métodos. Todos estos métodos son retrollamadas: son "
"llamados por los transportes en ciertos eventos, por ejemplo, cuando se "
"reciben algunos datos. Un método del protocolo base debe ser llamado por el "
"transporte correspondiente."

#: ../Doc/library/asyncio-protocol.rst:453
msgid "Base Protocols"
msgstr "Protocolos base"

#: ../Doc/library/asyncio-protocol.rst:457
msgid "Base protocol with methods that all protocols share."
msgstr "Protocolo base con métodos que comparten todos los demás protocolos."

#: ../Doc/library/asyncio-protocol.rst:461
msgid ""
"The base class for implementing streaming protocols (TCP, Unix sockets, etc)."
msgstr ""
"La clase base para implementar protocolos de *streaming* (TCP, sockets Unix, "
"etc)."

#: ../Doc/library/asyncio-protocol.rst:466
msgid ""
"A base class for implementing streaming protocols with manual control of the "
"receive buffer."
msgstr ""
"Una clase base para implementar protocolos de *streaming* con control manual "
"del búfer de recepción."

#: ../Doc/library/asyncio-protocol.rst:471
msgid "The base class for implementing datagram (UDP) protocols."
msgstr "La clase base para implementar protocolos de datagramas (UDP)."

#: ../Doc/library/asyncio-protocol.rst:475
msgid ""
"The base class for implementing protocols communicating with child processes "
"(unidirectional pipes)."
msgstr ""
"La clase base para implementar protocolos que se comunican con procesos "
"secundarios (pipes unidireccionales)."

#: ../Doc/library/asyncio-protocol.rst:480
msgid "Base Protocol"
msgstr "Protocolo base"

#: ../Doc/library/asyncio-protocol.rst:482
msgid "All asyncio protocols can implement Base Protocol callbacks."
msgstr ""
"Todos los protocolos asyncio pueden implementar las retrollamadas del "
"protocolo base."

#: ../Doc/library/asyncio-protocol.rst:485
msgid "Connection Callbacks"
msgstr "Retrollamadas de conexión"

#: ../Doc/library/asyncio-protocol.rst:486
msgid ""
"Connection callbacks are called on all protocols, exactly once per a "
"successful connection.  All other protocol callbacks can only be called "
"between those two methods."
msgstr ""
"Las retrollamadas de conexión son llamadas exactamente una vez por conexión "
"establecida en todos los protocolos. Todas las demás retrollamadas del "
"protocolo solo pueden ser llamadas entre estos dos métodos."

#: ../Doc/library/asyncio-protocol.rst:492
msgid "Called when a connection is made."
msgstr "Se llama cuando se establece una conexión."

#: ../Doc/library/asyncio-protocol.rst:494
msgid ""
"The *transport* argument is the transport representing the connection.  The "
"protocol is responsible for storing the reference to its transport."
msgstr ""
"El argumento *transport* es el transporte que representa la conexión. El "
"protocolo se encarga de almacenar la referencia a su propio transporte."

#: ../Doc/library/asyncio-protocol.rst:500
msgid "Called when the connection is lost or closed."
msgstr "Se llama cuando la conexión se pierde o se cierra."

#: ../Doc/library/asyncio-protocol.rst:502
msgid ""
"The argument is either an exception object or :const:`None`. The latter "
"means a regular EOF is received, or the connection was aborted or closed by "
"this side of the connection."
msgstr ""
"El argumento es un objeto excepción o :const:`None`. Esto último significa "
"que se recibió un EOF regular o que la conexión fue cancelada o cerrada por "
"este lado de la conexión."

#: ../Doc/library/asyncio-protocol.rst:508
msgid "Flow Control Callbacks"
msgstr "Retrollamadas de control de flujo"

#: ../Doc/library/asyncio-protocol.rst:509
msgid ""
"Flow control callbacks can be called by transports to pause or resume "
"writing performed by the protocol."
msgstr ""
"Los transportes pueden llamar a las retrollamadas de control de flujo para "
"pausar o reanudar la escritura llevada a cabo por el protocolo."

#: ../Doc/library/asyncio-protocol.rst:512
msgid ""
"See the documentation of the :meth:`~WriteTransport.set_write_buffer_limits` "
"method for more details."
msgstr ""
"Consulta la documentación del método :meth:`~WriteTransport."
"set_write_buffer_limits` para obtener más detalles."

#: ../Doc/library/asyncio-protocol.rst:517
msgid "Called when the transport's buffer goes over the high watermark."
msgstr "Se llama cuando el búfer del transporte supera el límite superior."

#: ../Doc/library/asyncio-protocol.rst:521
msgid "Called when the transport's buffer drains below the low watermark."
msgstr ""
"Se llama cuando el búfer del transporte se vacía por debajo del límite "
"inferior."

#: ../Doc/library/asyncio-protocol.rst:523
msgid ""
"If the buffer size equals the high watermark, :meth:`~BaseProtocol."
"pause_writing` is not called: the buffer size must go strictly over."
msgstr ""
"Si el tamaño del búfer es igual al límite superior, :meth:`~BaseProtocol."
"pause_writing` no será llamado: el tamaño del búfer debe superarse "
"estrictamente."

#: ../Doc/library/asyncio-protocol.rst:527
msgid ""
"Conversely, :meth:`~BaseProtocol.resume_writing` is called when the buffer "
"size is equal or lower than the low watermark.  These end conditions are "
"important to ensure that things go as expected when either mark is zero."
msgstr ""
"Por el contrario, se llama a :meth:`~BaseProtocol.resume_writing` cuando el "
"tamaño del búfer es igual o menor que el límite inferior. Estas condiciones "
"finales son importantes para garantizar que todo salga como se espera cuando "
"cualquiera de los dos límites sea cero."

#: ../Doc/library/asyncio-protocol.rst:534
msgid "Streaming Protocols"
msgstr "Protocolos de *streaming*"

#: ../Doc/library/asyncio-protocol.rst:536
msgid ""
"Event methods, such as :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe`, and :meth:`loop.connect_write_pipe` accept factories "
"that return streaming protocols."
msgstr ""
"Los métodos de eventos, como :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe`, y :meth:`loop.connect_write_pipe` aceptan fábricas que "
"retornan protocolos de *streaming*."

#: ../Doc/library/asyncio-protocol.rst:544
msgid ""
"Called when some data is received.  *data* is a non-empty bytes object "
"containing the incoming data."
msgstr ""
"Se llama cuando se reciben algunos datos. *data* es un objeto bytes no vacío "
"que contiene los datos entrantes."

#: ../Doc/library/asyncio-protocol.rst:547
msgid ""
"Whether the data is buffered, chunked or reassembled depends on the "
"transport.  In general, you shouldn't rely on specific semantics and instead "
"make your parsing generic and flexible. However, data is always received in "
"the correct order."
msgstr ""
"Que los datos se almacenen en un búfer, que se fragmenten o se vuelvan a "
"ensamblar depende del transporte. En general, no debe confiar en semánticas "
"específicas y, en cambio, hacer que su análisis sea genérico y flexible. Sin "
"embargo, los datos siempre se reciben en el orden correcto."

#: ../Doc/library/asyncio-protocol.rst:552
msgid ""
"The method can be called an arbitrary number of times while a connection is "
"open."
msgstr ""
"El método se puede llamar un número arbitrario de veces mientras una "
"conexión esté abierta."

#: ../Doc/library/asyncio-protocol.rst:555
msgid ""
"However, :meth:`protocol.eof_received() <Protocol.eof_received>` is called "
"at most once.  Once `eof_received()` is called, ``data_received()`` is not "
"called anymore."
msgstr ""
"Sin embargo, :meth:`protocol.eof_received() <Protocol.eof_received>` se "
"llama como máximo una vez. En el momento que se llama a `eof_received()`, ya "
"no se llama a ``data_received()``."

#: ../Doc/library/asyncio-protocol.rst:561
msgid ""
"Called when the other end signals it won't send any more data (for example "
"by calling :meth:`transport.write_eof() <WriteTransport.write_eof>`, if the "
"other end also uses asyncio)."
msgstr ""
"Se llama cuando el otro extremo indica que no enviará más datos (por "
"ejemplo, llamando a :meth:`transport.write_eof() <WriteTransport.write_eof>` "
"si el otro extremo también usa asyncio)."

#: ../Doc/library/asyncio-protocol.rst:566
msgid ""
"This method may return a false value (including ``None``), in which case the "
"transport will close itself.  Conversely, if this method returns a true "
"value, the protocol used determines whether to close the transport. Since "
"the default implementation returns ``None``, it implicitly closes the "
"connection."
msgstr ""
"Este método puede retornar un valor falso (incluido ``None``), en cuyo caso "
"el transporte se cerrará solo. Por el contrario, si este método retorna un "
"valor verdadero, el protocolo utilizado determina si se debe cerrar el "
"transporte. Dado que la implementación por defecto retorna ``None``, en éste "
"caso, se cierra implícitamente la conexión."

#: ../Doc/library/asyncio-protocol.rst:572
msgid ""
"Some transports, including SSL, don't support half-closed connections, in "
"which case returning true from this method will result in the connection "
"being closed."
msgstr ""
"Algunos transportes, incluido SSL, no admiten conexiones half-closed ('semi-"
"cerradas'), en cuyo caso retornar verdadero desde este método resultará en "
"el cierre de la conexión."

#: ../Doc/library/asyncio-protocol.rst:577
#: ../Doc/library/asyncio-protocol.rst:638
msgid "State machine:"
msgstr "Máquina de estado:"

#: ../Doc/library/asyncio-protocol.rst:588
msgid "Buffered Streaming Protocols"
msgstr "Protocolos de *streaming* mediante búfer"

#: ../Doc/library/asyncio-protocol.rst:590
msgid ""
"**Important:** this has been added to asyncio in Python 3.7 *on a "
"provisional basis*!  This is as an experimental API that might be changed or "
"removed completely in Python 3.8."
msgstr ""
"**Importante:** ¡esto se ha agregado a asyncio en Python 3.7 *de forma "
"provisional*! Debe tratarse como una API experimental que puede cambiarse o "
"eliminarse por completo en Python 3.8."

#: ../Doc/library/asyncio-protocol.rst:595
msgid ""
"Buffered Protocols can be used with any event loop method that supports "
"`Streaming Protocols`_."
msgstr ""
"Los protocolos que hacen uso de un búfer se pueden utilizar con cualquier "
"método del bucle de eventos que admita `Streaming Protocols`_."

#: ../Doc/library/asyncio-protocol.rst:598
msgid ""
"``BufferedProtocol`` implementations allow explicit manual allocation and "
"control of the receive buffer.  Event loops can then use the buffer provided "
"by the protocol to avoid unnecessary data copies.  This can result in "
"noticeable performance improvement for protocols that receive big amounts of "
"data.  Sophisticated protocol implementations can significantly reduce the "
"number of buffer allocations."
msgstr ""
"Las implementaciones de ``BufferedProtocol`` permiten la asignación manual "
"explícita y el control del búfer de recepción. Los bucles de eventos pueden "
"utilizar el búfer proporcionado por el protocolo para evitar copias de datos "
"innecesarias. Esto puede resultar en una mejora notable del rendimiento de "
"los protocolos que reciben grandes cantidades de datos. Las implementaciones "
"de protocolos sofisticados pueden reducir significativamente la cantidad de "
"asignaciones de búfer."

#: ../Doc/library/asyncio-protocol.rst:605
msgid ""
"The following callbacks are called on :class:`BufferedProtocol` instances:"
msgstr ""
"Las siguientes retrollamadas son llamadas en instancias :class:"
"`BufferedProtocol`:"

#: ../Doc/library/asyncio-protocol.rst:610
msgid "Called to allocate a new receive buffer."
msgstr "Se llama para asignar un nuevo búfer de recepción."

#: ../Doc/library/asyncio-protocol.rst:612
msgid ""
"*sizehint* is the recommended minimum size for the returned buffer.  It is "
"acceptable to return smaller or larger buffers than what *sizehint* "
"suggests.  When set to -1, the buffer size can be arbitrary. It is an error "
"to return a buffer with a zero size."
msgstr ""
"*sizehint* es el tamaño mínimo recomendado para el búfer retornado. Es "
"aceptable retornar búferes más pequeños o más grandes de lo que sugiere "
"*sizehint*. Cuando se establece en -1, el tamaño del búfer puede ser "
"arbitrario. Es un error retornar un búfer con tamaño cero."

#: ../Doc/library/asyncio-protocol.rst:617
msgid ""
"``get_buffer()`` must return an object implementing the :ref:`buffer "
"protocol <bufferobjects>`."
msgstr ""
"``get_buffer()`` debe retornar un objeto que implemente el :ref:`protocolo "
"de búfer <bufferobjects>`."

#: ../Doc/library/asyncio-protocol.rst:622
msgid "Called when the buffer was updated with the received data."
msgstr "Se llama cuando el búfer se ha actualizado con los datos recibidos."

#: ../Doc/library/asyncio-protocol.rst:624
msgid "*nbytes* is the total number of bytes that were written to the buffer."
msgstr "*nbytes* es el número total de bytes que se escribieron en el búfer."

#: ../Doc/library/asyncio-protocol.rst:628
msgid ""
"See the documentation of the :meth:`protocol.eof_received() <Protocol."
"eof_received>` method."
msgstr ""
"Consulte la documentación del método :meth:`protocol.eof_received() "
"<Protocol.eof_received>`."

#: ../Doc/library/asyncio-protocol.rst:632
msgid ""
":meth:`~BufferedProtocol.get_buffer` can be called an arbitrary number of "
"times during a connection.  However, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` is called at most once and, if called, :meth:"
"`~BufferedProtocol.get_buffer` and :meth:`~BufferedProtocol.buffer_updated` "
"won't be called after it."
msgstr ""
":meth:`~BufferedProtocol.get_buffer` se puede llamar un número arbitrario de "
"veces durante una conexión. Sin embargo, :meth:`protocol.eof_received () "
"<Protocol.eof_received>` se llama como máximo una vez y, si se llama, :meth:"
"`~BufferedProtocol.get_buffer` y :meth:`~BufferedProtocol.buffer_updated` no "
"serán llamados después de eso."

#: ../Doc/library/asyncio-protocol.rst:651
msgid "Datagram Protocols"
msgstr "Protocolos de datagramas"

#: ../Doc/library/asyncio-protocol.rst:653
msgid ""
"Datagram Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.create_datagram_endpoint` method."
msgstr ""
"Las instancias del protocolo de datagramas deben ser construidas por "
"fábricas de protocolos pasadas al método :meth:`loop."
"create_datagram_endpoint`."

#: ../Doc/library/asyncio-protocol.rst:658
msgid ""
"Called when a datagram is received.  *data* is a bytes object containing the "
"incoming data.  *addr* is the address of the peer sending the data; the "
"exact format depends on the transport."
msgstr ""
"Se llama cuando se recibe un datagrama. *data* es un objeto bytes que "
"contiene los datos entrantes. *addr* es la dirección del par que envía los "
"datos; el formato exacto depende del transporte."

#: ../Doc/library/asyncio-protocol.rst:664
msgid ""
"Called when a previous send or receive operation raises an :class:"
"`OSError`.  *exc* is the :class:`OSError` instance."
msgstr ""
"Se llama cuando una operación de envío o recepción anterior genera una :"
"class:`OSError`. *exc* es la instancia :class:`OSError`."

#: ../Doc/library/asyncio-protocol.rst:667
msgid ""
"This method is called in rare conditions, when the transport (e.g. UDP) "
"detects that a datagram could not be delivered to its recipient. In many "
"conditions though, undeliverable datagrams will be silently dropped."
msgstr ""
"Este método se llama en condiciones excepcionales, cuando el transporte (por "
"ejemplo, UDP) detecta que un datagrama no se pudo entregar a su "
"destinatario. Sin embargo, en la mayoría de casos, los datagramas que no se "
"puedan entregar se eliminarán silenciosamente."

#: ../Doc/library/asyncio-protocol.rst:674
msgid ""
"On BSD systems (macOS, FreeBSD, etc.) flow control is not supported for "
"datagram protocols, because there is no reliable way to detect send failures "
"caused by writing too many packets."
msgstr ""
"En los sistemas BSD (macOS, FreeBSD, etc.) el control de flujo no es "
"compatible con los protocolos de datagramas, esto se debe a que no hay una "
"forma confiable de detectar fallos de envío causados por escribir demasiados "
"paquetes."

#: ../Doc/library/asyncio-protocol.rst:678
msgid ""
"The socket always appears 'ready' and excess packets are dropped. An :class:"
"`OSError` with ``errno`` set to :const:`errno.ENOBUFS` may or may not be "
"raised; if it is raised, it will be reported to :meth:`DatagramProtocol."
"error_received` but otherwise ignored."
msgstr ""
"El socket siempre aparece como disponible ('ready') y se eliminan los "
"paquetes sobrantes. Un error :class:`OSError` con ``errno`` establecido en :"
"const:`errno.ENOBUFS` puede o no ser generado; si se genera, se informará a :"
"meth:`DatagramProtocol.error_received` pero en caso contrario se ignorará."

#: ../Doc/library/asyncio-protocol.rst:687
msgid "Subprocess Protocols"
msgstr "Protocolos de subprocesos"

#: ../Doc/library/asyncio-protocol.rst:689
msgid ""
"Datagram Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` "
"methods."
msgstr ""
"Las instancias del protocolo de datagramas deben ser construidas por "
"fábricas de protocolos pasadas a los métodos :meth:`loop.subprocess_exec` y :"
"meth:`loop.subprocess_shell`."

#: ../Doc/library/asyncio-protocol.rst:695
msgid ""
"Called when the child process writes data into its stdout or stderr pipe."
msgstr ""
"Se llama cuando el proceso hijo escribe datos en su pipe stdout o stderr."

#: ../Doc/library/asyncio-protocol.rst:698
msgid "*fd* is the integer file descriptor of the pipe."
msgstr "*fd* es el descriptor de archivo entero de la pipe."

#: ../Doc/library/asyncio-protocol.rst:700
msgid "*data* is a non-empty bytes object containing the received data."
msgstr "*data* es un objeto bytes no vacío que contiene los datos recibidos."

#: ../Doc/library/asyncio-protocol.rst:704
msgid ""
"Called when one of the pipes communicating with the child process is closed."
msgstr ""
"Se llama cuando se cierra una de las pipes que se comunican con el proceso "
"hijo."

#: ../Doc/library/asyncio-protocol.rst:707
msgid "*fd* is the integer file descriptor that was closed."
msgstr "*fd* es el descriptor de archivo entero que se cerró."

#: ../Doc/library/asyncio-protocol.rst:711
msgid "Called when the child process has exited."
msgstr "Se llama cuando el proceso hijo ha finalizado."

#: ../Doc/library/asyncio-protocol.rst:715
msgid "Examples"
msgstr "Ejemplos"

#: ../Doc/library/asyncio-protocol.rst:720
msgid "TCP Echo Server"
msgstr "Servidor de eco TCP"

#: ../Doc/library/asyncio-protocol.rst:722
msgid ""
"Create a TCP echo server using the :meth:`loop.create_server` method, send "
"back received data, and close the connection::"
msgstr ""
"Crear un servidor de eco TCP usando el método :meth:`loop.create_server`, "
"enviar de vuelta los datos recibidos y cerrar la conexión::"

#: ../Doc/library/asyncio-protocol.rst:763
msgid ""
"The :ref:`TCP echo server using streams <asyncio-tcp-echo-server-streams>` "
"example uses the high-level :func:`asyncio.start_server` function."
msgstr ""
"El ejemplo :ref:`Servidor de eco TCP usando streams <asyncio-tcp-echo-server-"
"streams>` usa la función de alto nivel :func:`asyncio.start_server`."

#: ../Doc/library/asyncio-protocol.rst:769
msgid "TCP Echo Client"
msgstr "Cliente de eco TCP"

#: ../Doc/library/asyncio-protocol.rst:771
msgid ""
"A TCP echo client using the :meth:`loop.create_connection` method, sends "
"data, and waits until the connection is closed::"
msgstr ""
"Un cliente de eco TCP usando el método :meth:`loop.create_connection`, envía "
"datos y espera hasta que la conexión se cierre::"

#: ../Doc/library/asyncio-protocol.rst:819
msgid ""
"The :ref:`TCP echo client using streams <asyncio-tcp-echo-client-streams>` "
"example uses the high-level :func:`asyncio.open_connection` function."
msgstr ""
"El ejemplo :ref:`Cliente de eco TCP usando streams <asyncio-tcp-echo-client-"
"streams>` usa la función de alto nivel :func:`asyncio.open_connection`."

#: ../Doc/library/asyncio-protocol.rst:826
msgid "UDP Echo Server"
msgstr "Servidor de eco UDP"

#: ../Doc/library/asyncio-protocol.rst:828
msgid ""
"A UDP echo server, using the :meth:`loop.create_datagram_endpoint` method, "
"sends back received data::"
msgstr ""
"Un servidor de eco UDP, usando el método :meth:`loop."
"create_datagram_endpoint`, envía de vuelta los datos recibidos::"

#: ../Doc/library/asyncio-protocol.rst:870
msgid "UDP Echo Client"
msgstr "Cliente de eco UDP"

#: ../Doc/library/asyncio-protocol.rst:872
msgid ""
"A UDP echo client, using the :meth:`loop.create_datagram_endpoint` method, "
"sends data and closes the transport when it receives the answer::"
msgstr ""
"Un cliente de eco UDP, usando el método :meth:`loop."
"create_datagram_endpoint`, envía datos y cierra el transporte cuando recibe "
"la respuesta:"

#: ../Doc/library/asyncio-protocol.rst:927
msgid "Connecting Existing Sockets"
msgstr "Conectando sockets existentes"

#: ../Doc/library/asyncio-protocol.rst:929
msgid ""
"Wait until a socket receives data using the :meth:`loop.create_connection` "
"method with a protocol::"
msgstr ""
"Espera hasta que un socket reciba datos usando el método :meth:`loop."
"create_connection` mediante un protocolo::"

#: ../Doc/library/asyncio-protocol.rst:983
msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level :meth:`loop."
"add_reader` method to register an FD."
msgstr ""
"El ejemplo :ref:`monitorizar eventos de lectura en un descriptor de archivo "
"<asyncio_example_watch_fd>` utiliza el método de bajo nivel :meth:`loop."
"add_reader` para registrar un descriptor de archivo."

#: ../Doc/library/asyncio-protocol.rst:987
msgid ""
"The :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` example uses high-level streams "
"created by the :func:`open_connection` function in a coroutine."
msgstr ""
"El ejemplo :ref:`registrar un socket abierto a la espera de datos usando "
"streams <asyncio_example_create_connection-streams>` usa *streams* de alto "
"nivel creados por la función :func:`open_connection` en una corrutina."

#: ../Doc/library/asyncio-protocol.rst:994
msgid "loop.subprocess_exec() and SubprocessProtocol"
msgstr "*loop.subprocess_exec()* y *SubprocessProtocol*"

#: ../Doc/library/asyncio-protocol.rst:996
msgid ""
"An example of a subprocess protocol used to get the output of a subprocess "
"and to wait for the subprocess exit."
msgstr ""
"Un ejemplo de un protocolo de subproceso que se utiliza para obtener la "
"salida de un subproceso y esperar su terminación."

#: ../Doc/library/asyncio-protocol.rst:999
msgid "The subprocess is created by th :meth:`loop.subprocess_exec` method::"
msgstr "El subproceso es creado por el método :meth:`loop.subprocess_exec`::"

#: ../Doc/library/asyncio-protocol.rst:1045
msgid ""
"See also the :ref:`same example <asyncio_example_create_subprocess_exec>` "
"written using high-level APIs."
msgstr ""
"Consulte también el :ref:`mismo ejemplo "
"<asyncio_example_create_subprocess_exec>` escrito utilizando la API de alto "
"nivel."
