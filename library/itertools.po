# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2021-08-04 21:35+0200\n"
"Last-Translator: Cristián Maureira-Fredes <cmaureirafredes@gmail.com>\n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.0\n"

#: ../Doc/library/itertools.rst:2
msgid ":mod:`itertools` --- Functions creating iterators for efficient looping"
msgstr ""
":mod:`itertools` --- Funciones que crean iteradores para bucles eficientes"

#: ../Doc/library/itertools.rst:20
msgid ""
"This module implements a number of :term:`iterator` building blocks inspired "
"by constructs from APL, Haskell, and SML.  Each has been recast in a form "
"suitable for Python."
msgstr ""
"Este módulo implementa un número de piezas básicas :term:`iterator` "
"inspiradas en *constructs* de APL, Haskell y SML.  Cada pieza ha sido "
"reconvertida a una forma apropiada para Python."

#: ../Doc/library/itertools.rst:24
msgid ""
"The module standardizes a core set of fast, memory efficient tools that are "
"useful by themselves or in combination.  Together, they form an \"iterator "
"algebra\" making it possible to construct specialized tools succinctly and "
"efficiently in pure Python."
msgstr ""
"El módulo estandariza un conjunto base de herramientas rápidas y eficientes "
"en memoria, útiles por sí mismas o en combinación con otras.  Juntas, forman "
"un \"álgebra de iteradores\", haciendo posible la construcción de "
"herramientas especializadas, sucintas y eficientes, en Python puro."

#: ../Doc/library/itertools.rst:29
msgid ""
"For instance, SML provides a tabulation tool: ``tabulate(f)`` which produces "
"a sequence ``f(0), f(1), ...``.  The same effect can be achieved in Python "
"by combining :func:`map` and :func:`count` to form ``map(f, count())``."
msgstr ""
"Por ejemplo, SML provee una herramienta de tabulación ``tabulate(f)``, que "
"produce una secuencia ``f(0), f(1), ...``.  En Python, se puede lograr el "
"mismo efecto al combinar :func:`map` y :func:`count` para formar ``map(f, "
"count())``."

#: ../Doc/library/itertools.rst:33
#, fuzzy
msgid ""
"These tools and their built-in counterparts also work well with the high-"
"speed functions in the :mod:`operator` module.  For example, the "
"multiplication operator can be mapped across two vectors to form an "
"efficient dot-product: ``sum(starmap(operator.mul, zip(vec1, vec2, "
"strict=True)))``."
msgstr ""
"Estas herramientas y sus contrapartes incorporadas también funcionan bien "
"con funciones de alta velocidad del módulo :mod:`operator`.  Por ejemplo, el "
"operador de multiplicación se puede mapear a lo largo de dos vectores para "
"formar un eficiente producto escalar: ``sum(map(operator.mul, vector1, "
"vector2))``."

#: ../Doc/library/itertools.rst:39
msgid "**Infinite iterators:**"
msgstr "**Iteradores infinitos:**"

#: ../Doc/library/itertools.rst:42 ../Doc/library/itertools.rst:52
#: ../Doc/library/itertools.rst:73
msgid "Iterator"
msgstr "Iterador"

#: ../Doc/library/itertools.rst:42 ../Doc/library/itertools.rst:52
#: ../Doc/library/itertools.rst:73
msgid "Arguments"
msgstr "Argumentos"

#: ../Doc/library/itertools.rst:42 ../Doc/library/itertools.rst:52
#: ../Doc/library/itertools.rst:73 ../Doc/library/itertools.rst:82
msgid "Results"
msgstr "Resultados"

#: ../Doc/library/itertools.rst:42 ../Doc/library/itertools.rst:52
msgid "Example"
msgstr "Ejemplo"

#: ../Doc/library/itertools.rst:44
msgid ":func:`count`"
msgstr ":func:`count`"

#: ../Doc/library/itertools.rst:44
msgid "start, [step]"
msgstr "start, [step]"

#: ../Doc/library/itertools.rst:44
msgid "start, start+step, start+2*step, ..."
msgstr "start, start+step, start+2*step, ..."

#: ../Doc/library/itertools.rst:44
msgid "``count(10) --> 10 11 12 13 14 ...``"
msgstr "``count(10) --> 10 11 12 13 14 ...``"

#: ../Doc/library/itertools.rst:45
msgid ":func:`cycle`"
msgstr ":func:`cycle`"

#: ../Doc/library/itertools.rst:45
msgid "p"
msgstr "p"

#: ../Doc/library/itertools.rst:45
msgid "p0, p1, ... plast, p0, p1, ..."
msgstr "p0, p1, ... plast, p0, p1, ..."

#: ../Doc/library/itertools.rst:45
msgid "``cycle('ABCD') --> A B C D A B C D ...``"
msgstr "``cycle('ABCD') --> A B C D A B C D ...``"

#: ../Doc/library/itertools.rst:46
msgid ":func:`repeat`"
msgstr ":func:`repeat`"

#: ../Doc/library/itertools.rst:46
msgid "elem [,n]"
msgstr "elem [,n]"

#: ../Doc/library/itertools.rst:46
msgid "elem, elem, elem, ... endlessly or up to n times"
msgstr "elem, elem, elem, ... indefinidamente o hasta n veces"

#: ../Doc/library/itertools.rst:46
msgid "``repeat(10, 3) --> 10 10 10``"
msgstr "``repeat(10, 3) --> 10 10 10``"

#: ../Doc/library/itertools.rst:49
msgid "**Iterators terminating on the shortest input sequence:**"
msgstr "**Iteradores que terminan en la secuencia de entrada más corta:**"

#: ../Doc/library/itertools.rst:54
msgid ":func:`accumulate`"
msgstr ":func:`accumulate`"

#: ../Doc/library/itertools.rst:54
msgid "p [,func]"
msgstr "p [,func]"

#: ../Doc/library/itertools.rst:54
msgid "p0, p0+p1, p0+p1+p2, ..."
msgstr "p0, p0+p1, p0+p1+p2, ..."

#: ../Doc/library/itertools.rst:54
msgid "``accumulate([1,2,3,4,5]) --> 1 3 6 10 15``"
msgstr "``accumulate([1,2,3,4,5]) --> 1 3 6 10 15``"

#: ../Doc/library/itertools.rst:55
#, fuzzy
msgid ":func:`batched`"
msgstr ":func:`tee`"

#: ../Doc/library/itertools.rst:55
#, fuzzy
msgid "p, n"
msgstr "p, r"

#: ../Doc/library/itertools.rst:55
#, fuzzy
msgid "(p0, p1, ..., p_n-1), ..."
msgstr "p0, p1, ... plast, p0, p1, ..."

#: ../Doc/library/itertools.rst:55
#, fuzzy
msgid "``batched('ABCDEFG', n=3) --> ABC DEF G``"
msgstr "``islice('ABCDEFG', 2, None) --> C D E F G``"

#: ../Doc/library/itertools.rst:56
msgid ":func:`chain`"
msgstr ":func:`chain`"

#: ../Doc/library/itertools.rst:56 ../Doc/library/itertools.rst:67
msgid "p, q, ..."
msgstr "p, q, ..."

#: ../Doc/library/itertools.rst:56 ../Doc/library/itertools.rst:57
msgid "p0, p1, ... plast, q0, q1, ..."
msgstr "p0, p1, ... plast, q0, q1, ..."

#: ../Doc/library/itertools.rst:56
msgid "``chain('ABC', 'DEF') --> A B C D E F``"
msgstr "``chain('ABC', 'DEF') --> A B C D E F``"

#: ../Doc/library/itertools.rst:57
msgid ":func:`chain.from_iterable`"
msgstr ":func:`chain.from_iterable`"

#: ../Doc/library/itertools.rst:57 ../Doc/library/itertools.rst:63
msgid "iterable"
msgstr "iterable"

#: ../Doc/library/itertools.rst:57
msgid "``chain.from_iterable(['ABC', 'DEF']) --> A B C D E F``"
msgstr "``chain.from_iterable(['ABC', 'DEF']) --> A B C D E F``"

#: ../Doc/library/itertools.rst:58
msgid ":func:`compress`"
msgstr ":func:`compress`"

#: ../Doc/library/itertools.rst:58
msgid "data, selectors"
msgstr "data, selectors"

#: ../Doc/library/itertools.rst:58
msgid "(d[0] if s[0]), (d[1] if s[1]), ..."
msgstr "(d[0] if s[0]), (d[1] if s[1]), ..."

#: ../Doc/library/itertools.rst:58
msgid "``compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F``"
msgstr "``compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F``"

#: ../Doc/library/itertools.rst:59
msgid ":func:`dropwhile`"
msgstr ":func:`dropwhile`"

#: ../Doc/library/itertools.rst:59 ../Doc/library/itertools.rst:60
#: ../Doc/library/itertools.rst:65
msgid "pred, seq"
msgstr "pred, seq"

#: ../Doc/library/itertools.rst:59
msgid "seq[n], seq[n+1], starting when pred fails"
msgstr "seq[n], seq[n+1], comenzando cuando pred falla"

#: ../Doc/library/itertools.rst:59
msgid "``dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1``"
msgstr "``dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1``"

#: ../Doc/library/itertools.rst:60
msgid ":func:`filterfalse`"
msgstr ":func:`filterfalse`"

#: ../Doc/library/itertools.rst:60
msgid "elements of seq where pred(elem) is false"
msgstr "elementos de seq donde pred(elem) es falso"

#: ../Doc/library/itertools.rst:60
msgid "``filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``"
msgstr "``filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``"

#: ../Doc/library/itertools.rst:61
msgid ":func:`groupby`"
msgstr ":func:`groupby`"

#: ../Doc/library/itertools.rst:61
msgid "iterable[, key]"
msgstr "iterable[, key]"

#: ../Doc/library/itertools.rst:61
msgid "sub-iterators grouped by value of key(v)"
msgstr "sub-iteradores agrupados según el valor de key(v)"

#: ../Doc/library/itertools.rst:62
msgid ":func:`islice`"
msgstr ":func:`islice`"

#: ../Doc/library/itertools.rst:62
msgid "seq, [start,] stop [, step]"
msgstr "seq, [start,] stop [, step]"

#: ../Doc/library/itertools.rst:62
msgid "elements from seq[start:stop:step]"
msgstr "elementos de seq[start:stop:step]"

#: ../Doc/library/itertools.rst:62
msgid "``islice('ABCDEFG', 2, None) --> C D E F G``"
msgstr "``islice('ABCDEFG', 2, None) --> C D E F G``"

#: ../Doc/library/itertools.rst:63
msgid ":func:`pairwise`"
msgstr ":func:`pairwise`"

#: ../Doc/library/itertools.rst:63
msgid "(p[0], p[1]), (p[1], p[2])"
msgstr "(p[0], p[1]), (p[1], p[2])"

#: ../Doc/library/itertools.rst:63
msgid "``pairwise('ABCDEFG') --> AB BC CD DE EF FG``"
msgstr "``pairwise('ABCDEFG') --> AB BC CD DE EF FG``"

#: ../Doc/library/itertools.rst:64
msgid ":func:`starmap`"
msgstr ":func:`starmap`"

#: ../Doc/library/itertools.rst:64
msgid "func, seq"
msgstr "func, seq"

#: ../Doc/library/itertools.rst:64
msgid "func(\\*seq[0]), func(\\*seq[1]), ..."
msgstr "func(\\*seq[0]), func(\\*seq[1]), ..."

#: ../Doc/library/itertools.rst:64
msgid "``starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000``"
msgstr "``starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000``"

#: ../Doc/library/itertools.rst:65
msgid ":func:`takewhile`"
msgstr ":func:`takewhile`"

#: ../Doc/library/itertools.rst:65
msgid "seq[0], seq[1], until pred fails"
msgstr "seq[0], seq[1], hasta que pred falle"

#: ../Doc/library/itertools.rst:65
msgid "``takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4``"
msgstr "``takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4``"

#: ../Doc/library/itertools.rst:66
msgid ":func:`tee`"
msgstr ":func:`tee`"

#: ../Doc/library/itertools.rst:66
msgid "it, n"
msgstr "it, n"

#: ../Doc/library/itertools.rst:66
msgid "it1, it2, ... itn  splits one iterator into n"
msgstr "it1, it2, ... itn  divide un iterador en n"

#: ../Doc/library/itertools.rst:67
msgid ":func:`zip_longest`"
msgstr ":func:`zip_longest`"

#: ../Doc/library/itertools.rst:67
msgid "(p[0], q[0]), (p[1], q[1]), ..."
msgstr "(p[0], q[0]), (p[1], q[1]), ..."

#: ../Doc/library/itertools.rst:67
msgid "``zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-``"
msgstr "``zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-``"

#: ../Doc/library/itertools.rst:70
msgid "**Combinatoric iterators:**"
msgstr "**Iteradores combinatorios:**"

#: ../Doc/library/itertools.rst:75
msgid ":func:`product`"
msgstr ":func:`product`"

#: ../Doc/library/itertools.rst:75
msgid "p, q, ... [repeat=1]"
msgstr "p, q, ... [repeat=1]"

#: ../Doc/library/itertools.rst:75
msgid "cartesian product, equivalent to a nested for-loop"
msgstr "producto cartesiano, equivalente a un bucle `for` anidado"

#: ../Doc/library/itertools.rst:76
msgid ":func:`permutations`"
msgstr ":func:`permutations`"

#: ../Doc/library/itertools.rst:76
msgid "p[, r]"
msgstr "p[, r]"

#: ../Doc/library/itertools.rst:76
msgid "r-length tuples, all possible orderings, no repeated elements"
msgstr ""
"tuplas de longitud r, en todas los órdenes posibles, sin elementos repetidos"

#: ../Doc/library/itertools.rst:77
msgid ":func:`combinations`"
msgstr ":func:`combinations`"

#: ../Doc/library/itertools.rst:77 ../Doc/library/itertools.rst:78
msgid "p, r"
msgstr "p, r"

#: ../Doc/library/itertools.rst:77
msgid "r-length tuples, in sorted order, no repeated elements"
msgstr "tuplas de longitud r, ordenadas, sin elementos repetidos"

#: ../Doc/library/itertools.rst:78
msgid ":func:`combinations_with_replacement`"
msgstr ":func:`combinations_with_replacement`"

#: ../Doc/library/itertools.rst:78
msgid "r-length tuples, in sorted order, with repeated elements"
msgstr "tuplas de longitud r, ordenadas, con elementos repetidos"

#: ../Doc/library/itertools.rst:82
msgid "Examples"
msgstr "Ejemplos"

#: ../Doc/library/itertools.rst:84
msgid "``product('ABCD', repeat=2)``"
msgstr "``product('ABCD', repeat=2)``"

#: ../Doc/library/itertools.rst:84
msgid "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"
msgstr "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"

#: ../Doc/library/itertools.rst:85
msgid "``permutations('ABCD', 2)``"
msgstr "``permutations('ABCD', 2)``"

#: ../Doc/library/itertools.rst:85
msgid "``AB AC AD BA BC BD CA CB CD DA DB DC``"
msgstr "``AB AC AD BA BC BD CA CB CD DA DB DC``"

#: ../Doc/library/itertools.rst:86
msgid "``combinations('ABCD', 2)``"
msgstr "``combinations('ABCD', 2)``"

#: ../Doc/library/itertools.rst:86
msgid "``AB AC AD BC BD CD``"
msgstr "``AB AC AD BC BD CD``"

#: ../Doc/library/itertools.rst:87
msgid "``combinations_with_replacement('ABCD', 2)``"
msgstr "``combinations_with_replacement('ABCD', 2)``"

#: ../Doc/library/itertools.rst:87
msgid "``AA AB AC AD BB BC BD CC CD DD``"
msgstr "``AA AB AC AD BB BC BD CC CD DD``"

#: ../Doc/library/itertools.rst:94
msgid "Itertool functions"
msgstr "Funciones de itertools"

#: ../Doc/library/itertools.rst:96
msgid ""
"The following module functions all construct and return iterators. Some "
"provide streams of infinite length, so they should only be accessed by "
"functions or loops that truncate the stream."
msgstr ""
"Todas las funciones del siguiente módulo construyen y retornan iteradores. "
"Algunas proveen flujos infinitos, por lo que deberían ser sólo manipuladas "
"por funciones o bucles que cortan el flujo."

#: ../Doc/library/itertools.rst:102
msgid ""
"Make an iterator that returns accumulated sums, or accumulated results of "
"other binary functions (specified via the optional *func* argument)."
msgstr ""
"Crea un iterador que retorna sumas acumuladas o resultados acumulados de "
"otra función binaria (especificada a través del argumento opcional *func*)."

#: ../Doc/library/itertools.rst:106
msgid ""
"If *func* is supplied, it should be a function of two arguments. Elements of "
"the input *iterable* may be any type that can be accepted as arguments to "
"*func*. (For example, with the default operation of addition, elements may "
"be any addable type including :class:`~decimal.Decimal` or :class:"
"`~fractions.Fraction`.)"
msgstr ""
"Si *func* es definido, debería ser una función de 2 argumentos. Los "
"elementos de entrada de *iterable* pueden ser de cualquier tipo que puedan "
"ser aceptados como argumentos de *func*. (Por ejemplo, con la operación por "
"defecto –adición, los elementos pueden ser cualquier tipo que sea sumable, "
"incluyendo :class:`~decimal.Decimal` o :class:`~fractions.Fraction`.)"

#: ../Doc/library/itertools.rst:113
msgid ""
"Usually, the number of elements output matches the input iterable. However, "
"if the keyword argument *initial* is provided, the accumulation leads off "
"with the *initial* value so that the output has one more element than the "
"input iterable."
msgstr ""
"Usualmente el número de elementos de salida corresponde con el número de "
"elementos del iterador de entrada. Sin embargo, si el argumento clave "
"*initial* es suministrado, la acumulación empieza con *initial* como valor "
"inicial y el resultado contiene un elemento más que el iterador de entrada."

#: ../Doc/library/itertools.rst:118 ../Doc/library/itertools.rst:191
#: ../Doc/library/itertools.rst:242 ../Doc/library/itertools.rst:291
#: ../Doc/library/itertools.rst:491 ../Doc/library/itertools.rst:527
#: ../Doc/library/itertools.rst:554 ../Doc/library/itertools.rst:634
msgid "Roughly equivalent to::"
msgstr "Aproximadamente equivalente a::"

#: ../Doc/library/itertools.rst:137
msgid ""
"There are a number of uses for the *func* argument.  It can be set to :func:"
"`min` for a running minimum, :func:`max` for a running maximum, or :func:"
"`operator.mul` for a running product.  Amortization tables can be built by "
"accumulating interest and applying payments:"
msgstr ""
"Hay varios usos para el argumento *func*. Se puede establecer en :func:`min` "
"para un mínimo en ejecución, :func:`max` para un máximo en ejecución o :func:"
"`operator.mul` para un producto en ejecución. Las tablas de amortización se "
"pueden construir acumulando intereses y aplicando pagos:"

#: ../Doc/library/itertools.rst:155
msgid ""
"See :func:`functools.reduce` for a similar function that returns only the "
"final accumulated value."
msgstr ""
"Para una función similar que retorne únicamente el valor final acumulado, "
"revisa :func:`functools.reduce`."

#: ../Doc/library/itertools.rst:160
msgid "Added the optional *func* parameter."
msgstr "Adicionó el argumento opcional *func*."

#: ../Doc/library/itertools.rst:163
msgid "Added the optional *initial* parameter."
msgstr "Adicionó el argumento opcional *initial*."

#: ../Doc/library/itertools.rst:169
msgid ""
"Batch data from the *iterable* into tuples of length *n*. The last batch may "
"be shorter than *n*."
msgstr ""

#: ../Doc/library/itertools.rst:172
msgid ""
"Loops over the input iterable and accumulates data into tuples up to size "
"*n*.  The input is consumed lazily, just enough to fill a batch. The result "
"is yielded as soon as the batch is full or when the input iterable is "
"exhausted:"
msgstr ""

#: ../Doc/library/itertools.rst:206
msgid ""
"Make an iterator that returns elements from the first iterable until it is "
"exhausted, then proceeds to the next iterable, until all of the iterables "
"are exhausted.  Used for treating consecutive sequences as a single "
"sequence. Roughly equivalent to::"
msgstr ""
"Crea un iterador que retorna elementos del primer iterable hasta que es "
"consumido, para luego proceder con el siguiente iterable, hasta que todos "
"los iterables son consumidos.  Se utiliza para tratar secuencias "
"consecutivas como unas sola secuencia. Aproximadamente equivalente a::"

#: ../Doc/library/itertools.rst:220
msgid ""
"Alternate constructor for :func:`chain`.  Gets chained inputs from a single "
"iterable argument that is evaluated lazily.  Roughly equivalent to::"
msgstr ""
"Constructor alternativo para :func:`chain`.  Obtiene entradas enlazadas de "
"un mismo argumento que se evalúa perezosamente.  Aproximadamente equivalente "
"a::"

#: ../Doc/library/itertools.rst:232
msgid "Return *r* length subsequences of elements from the input *iterable*."
msgstr ""
"Retorna subsecuencias de longitud *r* con elementos del *iterable* de "
"entrada."

#: ../Doc/library/itertools.rst:234 ../Doc/library/itertools.rst:283
msgid ""
"The combination tuples are emitted in lexicographic ordering according to "
"the order of the input *iterable*. So, if the input *iterable* is sorted, "
"the output tuples will be produced in sorted order."
msgstr ""
"Las tuplas de combinación se emiten en orden lexicográfico según el orden de "
"la entrada *iterable*. Por lo tanto, si se ordena la entrada *iterable*, las "
"tuplas de salida se producirán en orden."

#: ../Doc/library/itertools.rst:238
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"So if the input elements are unique, there will be no repeated values in "
"each combination."
msgstr ""
"Los elementos se tratan como únicos en función de su posición, no de su "
"valor. Entonces, si los elementos de entrada son únicos, no habrá valores "
"repetidos en cada combinación."

#: ../Doc/library/itertools.rst:264
msgid ""
"The code for :func:`combinations` can be also expressed as a subsequence of :"
"func:`permutations` after filtering entries where the elements are not in "
"sorted order (according to their position in the input pool)::"
msgstr ""
"El código para :func:`combinations` se puede expresar también como una "
"subsecuencia de :func:`permutations`, luego de filtrar entradas donde los "
"elementos no están ordenados (de acuerdo a su posición en el conjunto de "
"entrada)::"

#: ../Doc/library/itertools.rst:275
msgid ""
"The number of items returned is ``n! / r! / (n-r)!`` when ``0 <= r <= n`` or "
"zero when ``r > n``."
msgstr ""
"El número de elementos retornados es ``n! / r! / (n-r)!`` cuando ``0 <= r <= "
"n`` o cero cuando ``r > n``."

#: ../Doc/library/itertools.rst:280
msgid ""
"Return *r* length subsequences of elements from the input *iterable* "
"allowing individual elements to be repeated more than once."
msgstr ""
"Retorna subsecuencias, de longitud *r*, con elementos del *iterable* de "
"entrada, permitiendo que haya elementos individuales repetidos más de una "
"vez."

#: ../Doc/library/itertools.rst:287
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"So if the input elements are unique, the generated combinations will also be "
"unique."
msgstr ""
"Los elementos son tratados como únicos basados en su posición, no en su "
"valor.  De esta manera, si los elementos de entrada son únicos, las "
"combinaciones generadas también serán únicas."

#: ../Doc/library/itertools.rst:310
msgid ""
"The code for :func:`combinations_with_replacement` can be also expressed as "
"a subsequence of :func:`product` after filtering entries where the elements "
"are not in sorted order (according to their position in the input pool)::"
msgstr ""
"El código para :func:`combinations_with_replacement` se puede expresar "
"también como una subsecuencia de :func:`product`, luego de filtrar entradas "
"donde los elementos no están ordenados (de acuerdo a su posición en el "
"conjunto de entrada)::"

#: ../Doc/library/itertools.rst:321
msgid ""
"The number of items returned is ``(n+r-1)! / r! / (n-1)!`` when ``n > 0``."
msgstr ""
"El número de elementos retornados es ``(n+r-1)! / r! / (n-1)!`` cuando ``n > "
"0``."

#: ../Doc/library/itertools.rst:328
msgid ""
"Make an iterator that filters elements from *data* returning only those that "
"have a corresponding element in *selectors* that evaluates to ``True``. "
"Stops when either the *data* or *selectors* iterables has been exhausted. "
"Roughly equivalent to::"
msgstr ""
"Crea un iterador que filtra elementos de *data*, retornando sólo aquellos "
"que tienen un elemento correspondiente en *selectors* que evalúa a ``True``. "
"El iterador se detiene cuando alguno de los iterables (*data* o *selectors*) "
"ha sido consumido. Aproximadamente equivalente a::"

#: ../Doc/library/itertools.rst:342
msgid ""
"Make an iterator that returns evenly spaced values starting with number "
"*start*. Often used as an argument to :func:`map` to generate consecutive "
"data points. Also, used with :func:`zip` to add sequence numbers.  Roughly "
"equivalent to::"
msgstr ""
"Crea un iterador que retorna valores espaciados uniformemente, comenzando "
"con el número *start*. Usualmente se utiliza como argumento en :func:`map` "
"para generar puntos de datos consecutivos. También se utiliza en :func:`zip` "
"para agregar secuencias de números.  Aproximadamente equivalente a::"

#: ../Doc/library/itertools.rst:354
msgid ""
"When counting with floating point numbers, better accuracy can sometimes be "
"achieved by substituting multiplicative code such as: ``(start + step * i "
"for i in count())``."
msgstr ""
"Cuando se hace conteo con números de punto flotante, se puede lograr una "
"mejor precisión al sustituir código multiplicativo como: ``(start + step * i "
"for i in count())``."

#: ../Doc/library/itertools.rst:358
msgid "Added *step* argument and allowed non-integer arguments."
msgstr ""
"Se adicionó el argumento *step* y se permitieron argumentos diferentes a "
"enteros."

#: ../Doc/library/itertools.rst:363
msgid ""
"Make an iterator returning elements from the iterable and saving a copy of "
"each. When the iterable is exhausted, return elements from the saved copy.  "
"Repeats indefinitely.  Roughly equivalent to::"
msgstr ""
"Crea un iterador que retorna elementos del iterable y hace una copia de cada "
"uno. Cuando el iterable es consumido, retornar los elementos de la copia "
"almacenada.  Se repite indefinidamente.  Aproximadamente equivalente a::"

#: ../Doc/library/itertools.rst:377
msgid ""
"Note, this member of the toolkit may require significant auxiliary storage "
"(depending on the length of the iterable)."
msgstr ""
"Ten en cuenta, este miembro del conjunto de herramientas puede requerir "
"almacenamiento auxiliar importante (dependiendo de la longitud del iterable)."

#: ../Doc/library/itertools.rst:383
msgid ""
"Make an iterator that drops elements from the iterable as long as the "
"predicate is true; afterwards, returns every element.  Note, the iterator "
"does not produce *any* output until the predicate first becomes false, so it "
"may have a lengthy start-up time.  Roughly equivalent to::"
msgstr ""
"Crea un iterador que descarta elementos del iterable, siempre y cuando el "
"predicado sea verdadero; después, retorna cada elemento.  Ten en cuenta, el "
"iterador no produce *ningún* resultado hasta que el predicado se hace falso, "
"pudiendo incurrir en un tiempo de arranque extenso.  Aproximadamente "
"equivalente a::"

#: ../Doc/library/itertools.rst:400
#, fuzzy
msgid ""
"Make an iterator that filters elements from iterable returning only those "
"for which the predicate is false. If *predicate* is ``None``, return the "
"items that are false. Roughly equivalent to::"
msgstr ""
"Crea un iterador que filtra elementos de un iterable, retornando sólo "
"aquellos para los cuales el predicado es ``False``. Si *predicate* es "
"``None``, retorna los elementos que son falsos. Aproximadamente equivalente "
"a::"

#: ../Doc/library/itertools.rst:415
msgid ""
"Make an iterator that returns consecutive keys and groups from the "
"*iterable*. The *key* is a function computing a key value for each element.  "
"If not specified or is ``None``, *key* defaults to an identity function and "
"returns the element unchanged.  Generally, the iterable needs to already be "
"sorted on the same key function."
msgstr ""
"Crea un iterador que retorna claves consecutivas y grupos del *iterable*. "
"*key* es una función que calcula un valor clave para cada elemento.  Si no "
"se especifica o es ``None``, *key* es una función de identidad por defecto y "
"retorna el elemento sin cambios.  Generalmente, el iterable necesita estar "
"ordenado con la misma función *key*."

#: ../Doc/library/itertools.rst:421
msgid ""
"The operation of :func:`groupby` is similar to the ``uniq`` filter in Unix.  "
"It generates a break or new group every time the value of the key function "
"changes (which is why it is usually necessary to have sorted the data using "
"the same key function).  That behavior differs from SQL's GROUP BY which "
"aggregates common elements regardless of their input order."
msgstr ""
"El funcionamiento de :func:`groupby` es similar al del filtro ``uniq`` en "
"Unix.  Genera un salto o un nuevo grupo cada vez que el valor de la función "
"clave cambia (por lo que usualmente es necesario ordenar los datos usando la "
"misma función clave).  Ese comportamiento difiere del de GROUP BY de SQL, el "
"cual agrega elementos comunes sin importar el orden de entrada."

#: ../Doc/library/itertools.rst:427
msgid ""
"The returned group is itself an iterator that shares the underlying iterable "
"with :func:`groupby`.  Because the source is shared, when the :func:"
"`groupby` object is advanced, the previous group is no longer visible.  So, "
"if that data is needed later, it should be stored as a list::"
msgstr ""
"El grupo retornado es un iterador mismo que comparte el iterable subyacente "
"con :func:`groupby`.  Al compartir la fuente, cuando el objeto :func:"
"`groupby` se avanza, el grupo previo deja de ser visible.  En ese caso, si "
"los datos se necesitan posteriormente, se deberían almacenar como lista::"

#: ../Doc/library/itertools.rst:439
msgid ":func:`groupby` is roughly equivalent to::"
msgstr ":func:`groupby` es aproximadamente equivalente a::"

#: ../Doc/library/itertools.rst:476
msgid ""
"Make an iterator that returns selected elements from the iterable. If "
"*start* is non-zero, then elements from the iterable are skipped until start "
"is reached. Afterward, elements are returned consecutively unless *step* is "
"set higher than one which results in items being skipped.  If *stop* is "
"``None``, then iteration continues until the iterator is exhausted, if at "
"all; otherwise, it stops at the specified position."
msgstr ""
"Crea un iterador que retorna los elementos seleccionados del iterable. Si "
"*start* es distinto de cero, los elementos del iterable se omiten hasta que "
"se alcanza el inicio. Posteriormente, los elementos se devuelven "
"consecutivamente a menos que *step* se establezca en un valor superior a "
"uno, lo que da como resultado que se omitan los elementos. Si *stop* es "
"``None``, la iteración continúa hasta que se agota el iterador, si es que se "
"agota; de lo contrario, se detiene en la posición especificada."

#: ../Doc/library/itertools.rst:483
msgid ""
"If *start* is ``None``, then iteration starts at zero. If *step* is "
"``None``, then the step defaults to one."
msgstr ""
"Si *start* es ``None``, la iteración empieza en cero. Si *step* es ``None``, "
"step se establece en uno por defecto."

#: ../Doc/library/itertools.rst:486
msgid ""
"Unlike regular slicing, :func:`islice` does not support negative values for "
"*start*, *stop*, or *step*.  Can be used to extract related fields from data "
"where the internal structure has been flattened (for example, a multi-line "
"report may list a name field on every third line)."
msgstr ""
"A diferencia del corte normal, :func:`islice` no admite valores negativos "
"para *start*, *stop* o *step*. Se puede usar para extraer campos "
"relacionados de datos donde la estructura interna se ha aplanado (por "
"ejemplo, un informe de varias líneas puede incluir un campo de nombre cada "
"tres líneas)."

#: ../Doc/library/itertools.rst:521
msgid "Return successive overlapping pairs taken from the input *iterable*."
msgstr ""
"Retorna los sucesivos pares superpuestos tomados de la entrada *iterable*."

#: ../Doc/library/itertools.rst:523
msgid ""
"The number of 2-tuples in the output iterator will be one fewer than the "
"number of inputs.  It will be empty if the input iterable has fewer than two "
"values."
msgstr ""
"El número de tuplas de 2 elementos en el iterador de salida será uno menos "
"que el número de entradas. Estará vacío si la entrada iterable tiene menos "
"de dos valores."

#: ../Doc/library/itertools.rst:540
msgid ""
"Return successive *r* length permutations of elements in the *iterable*."
msgstr ""
"Retorna permutaciones de elementos sucesivas de longitud *r* en el "
"*iterable*."

#: ../Doc/library/itertools.rst:542
msgid ""
"If *r* is not specified or is ``None``, then *r* defaults to the length of "
"the *iterable* and all possible full-length permutations are generated."
msgstr ""
"Si *r* no es especificado o si es ``None``, entonces por defecto *r* será "
"igual a la longitud de *iterable* y todas las permutaciones de máxima "
"longitud serán generadas."

#: ../Doc/library/itertools.rst:546
msgid ""
"The permutation tuples are emitted in lexicographic order according to the "
"order of the input *iterable*. So, if the input *iterable* is sorted, the "
"output tuples will be produced in sorted order."
msgstr ""
"Las tuplas de permutación se emiten en orden lexicográfico según el orden de "
"la entrada *iterable*. Por lo tanto, si se ordena la entrada *iterable*, las "
"tuplas de salida se producirán en orden."

#: ../Doc/library/itertools.rst:550
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"So if the input elements are unique, there will be no repeated values within "
"a permutation."
msgstr ""
"Los elementos se tratan como únicos en función de su posición, no de su "
"valor. Entonces, si los elementos de entrada son únicos, no habrá valores "
"repetidos dentro de una permutación."

#: ../Doc/library/itertools.rst:581
msgid ""
"The code for :func:`permutations` can be also expressed as a subsequence of :"
"func:`product`, filtered to exclude entries with repeated elements (those "
"from the same position in the input pool)::"
msgstr ""
"El código para :func:`permutations` también se puede expresar como una "
"subsecuencia de :func:`product`, filtrado para excluir registros con "
"elementos repetidos (aquellos en la misma posición que en el conjunto de "
"entrada)::"

#: ../Doc/library/itertools.rst:593
msgid ""
"The number of items returned is ``n! / (n-r)!`` when ``0 <= r <= n`` or zero "
"when ``r > n``."
msgstr ""
"El número de elementos retornados es ``n! / (n-r)!`` cuando ``0 <= r <= n`` "
"o cero cuando ``r > n``."

#: ../Doc/library/itertools.rst:598
msgid "Cartesian product of input iterables."
msgstr "Producto cartesiano de los iterables de entrada."

#: ../Doc/library/itertools.rst:600
msgid ""
"Roughly equivalent to nested for-loops in a generator expression. For "
"example, ``product(A, B)`` returns the same as ``((x,y) for x in A for y in "
"B)``."
msgstr ""
"Aproximadamente equivalente a tener bucles `for` anidados en un generador. "
"Por ejemplo, ``product(A, B)`` es equivalente a ``((x,y) for x in A for y in "
"B)``."

#: ../Doc/library/itertools.rst:603
msgid ""
"The nested loops cycle like an odometer with the rightmost element advancing "
"on every iteration.  This pattern creates a lexicographic ordering so that "
"if the input's iterables are sorted, the product tuples are emitted in "
"sorted order."
msgstr ""
"Los bucles anidados hacen ciclos como un cuentapasos o taxímetro, con el "
"elemento más hacia la derecha avanzando en cada iteración.  Este patrón crea "
"un orden lexicográfico en el que, si los iterables de entrada están "
"ordenados, las tuplas producidas son emitidas de manera ordenada."

#: ../Doc/library/itertools.rst:608
msgid ""
"To compute the product of an iterable with itself, specify the number of "
"repetitions with the optional *repeat* keyword argument.  For example, "
"``product(A, repeat=4)`` means the same as ``product(A, A, A, A)``."
msgstr ""
"Para calcular el producto de un iterable consigo mismo, especifica el número "
"de repeticiones con el argumento opcional *repeat*.  Por ejemplo, "
"``product(A, repeat=4)`` es equivalente a ``product(A, A, A, A)``."

#: ../Doc/library/itertools.rst:612
msgid ""
"This function is roughly equivalent to the following code, except that the "
"actual implementation does not build up intermediate results in memory::"
msgstr ""
"Esta función es aproximadamente equivalente al código siguiente, exceptuando "
"que la implementación real no acumula resultados intermedios en memoria::"

#: ../Doc/library/itertools.rst:625
msgid ""
"Before :func:`product` runs, it completely consumes the input iterables, "
"keeping pools of values in memory to generate the products.  Accordingly, it "
"is only useful with finite inputs."
msgstr ""
"Antes de que :func:`product` se ejecute, consume completamente los iterables "
"de entrada, manteniendo grupos de valores en la memoria para generar los "
"productos. En consecuencia, solo es útil con entradas finitas."

#: ../Doc/library/itertools.rst:631
msgid ""
"Make an iterator that returns *object* over and over again. Runs "
"indefinitely unless the *times* argument is specified."
msgstr ""
"Crea un iterador que retorna *object* una y otra vez. Se ejecuta "
"indefinidamente a menos que se especifique el argumento *times*."

#: ../Doc/library/itertools.rst:645
msgid ""
"A common use for *repeat* is to supply a stream of constant values to *map* "
"or *zip*:"
msgstr ""
"Un uso común de *repeat* es proporcionar un flujo de valores constantes a "
"*map* o *zip*:"

#: ../Doc/library/itertools.rst:655
msgid ""
"Make an iterator that computes the function using arguments obtained from "
"the iterable.  Used instead of :func:`map` when argument parameters are "
"already grouped in tuples from a single iterable (when the data has been "
"\"pre-zipped\")."
msgstr ""
"Crea un iterador que calcula la función usando argumentos obtenidos del "
"iterable. Se usa en lugar de :func:`map` cuando los parámetros de argumento "
"ya están agrupados en tuplas de un solo iterable (cuando los datos se han "
"\"comprimido previamente\")."

#: ../Doc/library/itertools.rst:660
msgid ""
"The difference between :func:`map` and :func:`starmap` parallels the "
"distinction between ``function(a,b)`` and ``function(*c)``. Roughly "
"equivalent to::"
msgstr ""
"La diferencia entre :func:`map` y :func:`starmap` es paralela a la "
"distinción entre ``function(a,b)`` y ``function(*c)``. Aproximadamente "
"equivalente a:"

#: ../Doc/library/itertools.rst:672
msgid ""
"Make an iterator that returns elements from the iterable as long as the "
"predicate is true.  Roughly equivalent to::"
msgstr ""
"Crea un iterador que retorna elementos del iterador siempre y cuando el "
"predicado sea cierto.  Aproximadamente equivalente a::"

#: ../Doc/library/itertools.rst:686
msgid "Return *n* independent iterators from a single iterable."
msgstr "Retorna *n* iteradores independientes de un mismo iterador."

#: ../Doc/library/itertools.rst:688
msgid ""
"The following Python code helps explain what *tee* does (although the actual "
"implementation is more complex and uses only a single underlying :abbr:`FIFO "
"(first-in, first-out)` queue)::"
msgstr ""
"El siguiente código de Python ayuda a explicar lo que hace *tee* (aunque la "
"implementación real es más compleja y usa solo una sola cola subyacente :"
"abbr:`FIFO (primero en entrar, primero en salir)`):"

#: ../Doc/library/itertools.rst:707
msgid ""
"Once a :func:`tee` has been created, the original *iterable* should not be "
"used anywhere else; otherwise, the *iterable* could get advanced without the "
"tee objects being informed."
msgstr ""
"Una vez que se ha creado un :func:`tee`, el *iterable* original no debe "
"usarse en ningún otro lugar; de lo contrario, el *iterable* podría avanzar "
"sin que se informe a los objetos en T."

#: ../Doc/library/itertools.rst:711
#, fuzzy
msgid ""
"``tee`` iterators are not threadsafe. A :exc:`RuntimeError` may be raised "
"when simultaneously using iterators returned by the same :func:`tee` call, "
"even if the original *iterable* is threadsafe."
msgstr ""
"Los iteradores ``tee`` no son *threadsafe*. :exc:`RuntimeError` puede "
"ocurrir si se usan simultáneamente iteradores retornados por la misma "
"llamada a :func:`tee` call, aún cuando el *iterable* original sea "
"*threadsafe*."

#: ../Doc/library/itertools.rst:715
msgid ""
"This itertool may require significant auxiliary storage (depending on how "
"much temporary data needs to be stored). In general, if one iterator uses "
"most or all of the data before another iterator starts, it is faster to use :"
"func:`list` instead of :func:`tee`."
msgstr ""
"Esta herramienta de iteración puede requerir almacenamiento auxiliar "
"significativo (dependiendo de qué tantos datos necesitan ser almacenados). "
"En general, si un iterador utiliza todos o la mayoría de los datos antes que "
"otro iterador comience, es más rápido utilizar :func:`list` en vez de :func:"
"`tee`."

#: ../Doc/library/itertools.rst:723
msgid ""
"Make an iterator that aggregates elements from each of the iterables. If the "
"iterables are of uneven length, missing values are filled-in with "
"*fillvalue*. Iteration continues until the longest iterable is exhausted.  "
"Roughly equivalent to::"
msgstr ""
"Crea un iterador que agrega elementos de cada uno de los iterables. Si los "
"iterables tiene longitud impar, los valores sin encontrar serán iguales a "
"*fillvalue*. La iteración continúa hasta que el iterable más largo sea "
"consumido.  Aproximadamente equivalente a::"

#: ../Doc/library/itertools.rst:747
msgid ""
"If one of the iterables is potentially infinite, then the :func:"
"`zip_longest` function should be wrapped with something that limits the "
"number of calls (for example :func:`islice` or :func:`takewhile`).  If not "
"specified, *fillvalue* defaults to ``None``."
msgstr ""
"Si alguno de los iterables es potencialmente infinito, la función :func:"
"`zip_longest` debería ser recubierta por otra que limite el número de "
"llamadas (por ejemplo, :func:`islice` o :func:`takewhile`).  Si no se "
"especifica, *fillvalue* es ``None`` por defecto."

#: ../Doc/library/itertools.rst:756
msgid "Itertools Recipes"
msgstr "Fórmulas con itertools"

#: ../Doc/library/itertools.rst:758
msgid ""
"This section shows recipes for creating an extended toolset using the "
"existing itertools as building blocks."
msgstr ""
"Esta sección muestra fórmulas para crear un conjunto de herramientas "
"extendido usando las herramientas de itertools como piezas básicas."

#: ../Doc/library/itertools.rst:761
#, fuzzy
msgid ""
"The primary purpose of the itertools recipes is educational.  The recipes "
"show various ways of thinking about individual tools — for example, that "
"``chain.from_iterable`` is related to the concept of flattening.  The "
"recipes also give ideas about ways that the tools can be combined — for "
"example, how ``compress()`` and ``range()`` can work together.  The recipes "
"also show patterns for using itertools with the :mod:`operator` and :mod:"
"`collections` modules as well as with the built-in itertools such as "
"``map()``, ``filter()``, ``reversed()``, and ``enumerate()``."
msgstr ""
"El propósito principal de las recetas de itertools es educativo. Las recetas "
"muestran varias formas de pensar sobre herramientas individuales; por "
"ejemplo, que ``chain.from_iterable`` está relacionado con el concepto de "
"aplanamiento. Las recetas también brindan ideas sobre las formas en que se "
"pueden combinar las herramientas, por ejemplo, cómo `compress()` y `range()` "
"pueden funcionar juntas. Las recetas también muestran patrones para usar "
"itertools con los módulos :mod:`operator` y :mod:`collections`, así como con "
"las itertools integradas, como ``map()``, ``filter()``, ``reversed()`` y "
"``enumerate()``."

#: ../Doc/library/itertools.rst:770
#, fuzzy
msgid ""
"A secondary purpose of the recipes is to serve as an incubator.  The "
"``accumulate()``, ``compress()``, and ``pairwise()`` itertools started out "
"as recipes.  Currently, the ``sliding_window()`` and ``iter_index()`` "
"recipes are being tested to see whether they prove their worth."
msgstr ""
"Un propósito secundario de las recetas es servir como incubadora. Las "
"itertools ``accumulate()``, ``compress()`` y ``pairwise()`` comenzaron como "
"recetas. Actualmente, la receta ``iter_index()`` se está probando para ver "
"si demuestra su valor."

#: ../Doc/library/itertools.rst:775
msgid ""
"Substantially all of these recipes and many, many others can be installed "
"from the `more-itertools project <https://pypi.org/project/more-itertools/"
">`_ found on the Python Package Index::"
msgstr ""
"De manera considerable, todas estas fórmulas y muchos otras se pueden "
"instalar desde el `proyecto more-itertools <https://pypi.org/project/more-"
"itertools/>`_, ubicado en el Python Package Index::"

#: ../Doc/library/itertools.rst:781
msgid ""
"Many of the recipes offer the same high performance as the underlying "
"toolset. Superior memory performance is kept by processing elements one at a "
"time rather than bringing the whole iterable into memory all at once. Code "
"volume is kept small by linking the tools together in a functional style "
"which helps eliminate temporary variables.  High speed is retained by "
"preferring \"vectorized\" building blocks over the use of for-loops and :"
"term:`generator`\\s which incur interpreter overhead."
msgstr ""
"Muchas de las recetas ofrecen el mismo alto rendimiento que el conjunto de "
"herramientas subyacente. El rendimiento superior de la memoria se mantiene "
"procesando los elementos de uno en uno en lugar de llevar todo el iterable a "
"la memoria de una sola vez. El volumen del código se mantiene pequeño al "
"vincular las herramientas en un estilo funcional que ayuda a eliminar las "
"variables temporales. Se mantiene la alta velocidad al preferir bloques de "
"construcción \"vectorizados\" sobre el uso de bucles for y :term:"
"`generator`\\s que incurren en una sobrecarga del intérprete."

#: ../Doc/library/itertools.rst:1022
msgid "The following recipes have a more mathematical flavor:"
msgstr ""
