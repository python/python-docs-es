# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2023-11-27 13:14-0500\n"
"Last-Translator: \n"
"Language-Team: python-doc-es\n"
"Language: es_ES\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.13.0\n"
"X-Generator: Poedit 3.4.1\n"

#: ../Doc/library/socket.rst:2
msgid ":mod:`socket` --- Low-level networking interface"
msgstr ":mod:`socket` --- interfaz de red de bajo nivel"

#: ../Doc/library/socket.rst:7
msgid "**Source code:** :source:`Lib/socket.py`"
msgstr "**Código fuente:** :source:`Lib/socket.py`"

#: ../Doc/library/socket.rst:11
msgid ""
"This module provides access to the BSD *socket* interface. It is available "
"on all modern Unix systems, Windows, MacOS, and probably additional "
"platforms."
msgstr ""
"Este módulo proporciona acceso a la interfaz BSD *socket*. Está disponible "
"en todos los sistemas Unix modernos, Windows, MacOS y probablemente "
"plataformas adicionales."

#: ../Doc/library/socket.rst:16
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs."
msgstr ""
"Algunos comportamientos pueden depender de la plataforma, ya que las "
"llamadas se realizan a las API de socket del sistema operativo."

#: ../Doc/includes/wasm-notavail.rst:3
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ":ref:`Availability <availability>`: no escritos, no WASI."

#: ../Doc/includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"Este módulo no funciona o no está disponible en las plataformas WebAssembly "
"``wasm32-emscripten`` y ``wasm32-wasi``. Véase :ref:`wasm-availability` para "
"más información."

#: ../Doc/library/socket.rst:24
msgid ""
"The Python interface is a straightforward transliteration of the Unix system "
"call and library interface for sockets to Python's object-oriented style: "
"the :func:`.socket` function returns a :dfn:`socket object` whose methods "
"implement the various socket system calls.  Parameter types are somewhat "
"higher-level than in the C interface: as with :meth:`read` and :meth:`write` "
"operations on Python files, buffer allocation on receive operations is "
"automatic, and buffer length is implicit on send operations."
msgstr ""
"La interfaz de Python es una transcripción sencilla de la llamada al sistema "
"Unix y la interfaz de la biblioteca para sockets al estilo orientado a "
"objetos de Python: la función :func:`.socket` devuelve a :dfn:`socket "
"object` cuyos métodos implementan las diversas llamadas al sistema de "
"socket. Los tipos de parámetros tienen un nivel algo más alto que en la "
"interfaz C: como con :meth:`read` y :meth:`write` en las operaciones en los "
"archivos Python, la asignación del buffer en las operaciones de recepción es "
"automática y la longitud del buffer está implícita en las operaciones de "
"envío."

#: ../Doc/library/socket.rst:36
msgid "Module :mod:`socketserver`"
msgstr "Módulo :mod:`socketserver`"

#: ../Doc/library/socket.rst:36
msgid "Classes that simplify writing network servers."
msgstr "Clases que simplifican la escritura de servidores de red."

#: ../Doc/library/socket.rst:38
msgid "Module :mod:`ssl`"
msgstr "Módulo :mod:`ssl`"

#: ../Doc/library/socket.rst:39
msgid "A TLS/SSL wrapper for socket objects."
msgstr "Un contenedor TLS/SSL para objetos de socket."

#: ../Doc/library/socket.rst:43
msgid "Socket families"
msgstr "Familias Socket"

#: ../Doc/library/socket.rst:45
msgid ""
"Depending on the system and the build options, various socket families are "
"supported by this module."
msgstr ""
"Dependiendo del sistema y de las opciones de compilación, este módulo admite "
"varias familias de sockets."

#: ../Doc/library/socket.rst:48
msgid ""
"The address format required by a particular socket object is automatically "
"selected based on the address family specified when the socket object was "
"created.  Socket addresses are represented as follows:"
msgstr ""
"El formato de dirección requerido por un objeto de socket determinado se "
"selecciona automáticamente en función de la familia de direcciones "
"especificada cuando se creó el objeto de socket.  Las direcciones de socket "
"se representan de la siguiente manera:"

#: ../Doc/library/socket.rst:52
msgid ""
"The address of an :const:`AF_UNIX` socket bound to a file system node is "
"represented as a string, using the file system encoding and the "
"``'surrogateescape'`` error handler (see :pep:`383`).  An address in Linux's "
"abstract namespace is returned as a :term:`bytes-like object` with an "
"initial null byte; note that sockets in this namespace can communicate with "
"normal file system sockets, so programs intended to run on Linux may need to "
"deal with both types of address.  A string or bytes-like object can be used "
"for either type of address when passing it as an argument."
msgstr ""
"La dirección de un socket :const:`AF_UNIX` enlazado a un nodo del sistema de "
"archivos es representado como una cadena de caracteres, utilizando la "
"codificación del sistema de archivos y el controlador de errores "
"``'surrogateescape'`` (Observar :pep:`383`). Una dirección en el espacio de "
"nombre abstracto de Linux es devuelvo como un :term:`bytes-like object` con "
"un byte inicial nulo; tenga en cuenta que los sockets en este nombre de "
"espacio puede comunicarse con sockets normales del sistema de archivos, así "
"que los programas destinados a correr en Linux podrían necesitar tratar con "
"ambos tipos de direcciones. Se puede pasar un objeto similar a una cadena de "
"caracteres o bytes para cualquier tipo de dirección al pasarlo como "
"argumento."

#: ../Doc/library/socket.rst:62
msgid ""
"Previously, :const:`AF_UNIX` socket paths were assumed to use UTF-8 encoding."
msgstr ""
"Anteriormente, se suponía que las rutas de socket :const:`AF_UNIX` "
"utilizaban codificación UTF-8."

#: ../Doc/library/socket.rst:66 ../Doc/library/socket.rst:1142
#: ../Doc/library/socket.rst:1184 ../Doc/library/socket.rst:1943
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "Ahora se acepta la grabación :term:`bytes-like object`."

#: ../Doc/library/socket.rst:71
msgid ""
"A pair ``(host, port)`` is used for the :const:`AF_INET` address family, "
"where *host* is a string representing either a hostname in internet domain "
"notation like ``'daring.cwi.nl'`` or an IPv4 address like "
"``'100.50.200.5'``, and *port* is an integer."
msgstr ""
"Se utiliza un par ``(host, port)`` para la familia de direcciones :const:"
"`AF_INET`, donde *host* es una cadena que representa un nombre de host en "
"notación de dominio de Internet como ``'daring.cwi.nl'`` o una dirección "
"IPv4 como ``'100.50.200.5'``, y *port* es un número entero."

#: ../Doc/library/socket.rst:76
msgid ""
"For IPv4 addresses, two special forms are accepted instead of a host "
"address: ``''`` represents :const:`INADDR_ANY`, which is used to bind to all "
"interfaces, and the string ``'<broadcast>'`` represents :const:"
"`INADDR_BROADCAST`.  This behavior is not compatible with IPv6, therefore, "
"you may want to avoid these if you intend to support IPv6 with your Python "
"programs."
msgstr ""
"Para direcciones IPv4, se aceptan dos formas especiales en lugar de una "
"dirección de host: ``’’`` representa :const:`INADDR_ANY`, que se utiliza "
"para enlazar a todas las interfaces, y la cadena de caracteres "
"``'<broadcast>'`` representa :const:`INADDR_BROADCAST`. Este comportamiento "
"no es compatible con IPv6, por lo tanto, es posible que desee evitarlos sí "
"tiene la intención de admitir IPv6 con sus programas Python."

#: ../Doc/library/socket.rst:83
msgid ""
"For :const:`AF_INET6` address family, a four-tuple ``(host, port, flowinfo, "
"scope_id)`` is used, where *flowinfo* and *scope_id* represent the "
"``sin6_flowinfo`` and ``sin6_scope_id`` members in :const:`struct "
"sockaddr_in6` in C.  For :mod:`socket` module methods, *flowinfo* and "
"*scope_id* can be omitted just for backward compatibility.  Note, however, "
"omission of *scope_id* can cause problems in manipulating scoped IPv6 "
"addresses."
msgstr ""
"Para la familia de direcciones :const:`AF_INET6`, se utiliza una ``(host, "
"port, flowinfo, scope_id)`` de cuatro tuplas, donde *flowinfo* y *scope_id* "
"representan los miembros ``sin6_flowinfo`` y ``sin6_scope_id`` en :const:"
"`struct sockaddr_in6` en C. Para los métodos de los módulos :mod:`socket`, "
"*flowinfo* y *scope_id* pueden ser omitidos solo por compatibilidad con "
"versiones anteriores. Sin embargo la omisión de *scope_id* puede causar "
"problemas en la manipulación de direcciones IPv6 con ámbito."

#: ../Doc/library/socket.rst:90
#, python-format
msgid ""
"For multicast addresses (with *scope_id* meaningful) *address* may not "
"contain ``%scope_id`` (or ``zone id``) part. This information is superfluous "
"and may be safely omitted (recommended)."
msgstr ""
"Para direcciones de multidifusión (con *scopeid* significativo) *address* "
"puede no contener la parte ``%scope`` (o ``zone id``). Esta información es "
"superflua y puede omitirse de forma segura (recomendado)."

#: ../Doc/library/socket.rst:95
msgid ":const:`AF_NETLINK` sockets are represented as pairs ``(pid, groups)``."
msgstr ""
":const:`AF_NETLINK` sockets se representan como pares ``(pid, groups)``."

#: ../Doc/library/socket.rst:97
msgid ""
"Linux-only support for TIPC is available using the :const:`AF_TIPC` address "
"family.  TIPC is an open, non-IP based networked protocol designed for use "
"in clustered computer environments.  Addresses are represented by a tuple, "
"and the fields depend on the address type. The general tuple form is "
"``(addr_type, v1, v2, v3 [, scope])``, where:"
msgstr ""
"La compatibilidad con LINUX solo para TIPC está disponible mediante la "
"familia de direcciones :const:`AF_TIPC`.  TIPC es un protocolo en red "
"abierto y no basado en IP diseñado para su uso en entornos informáticos "
"agrupados.  Las direcciones se representan mediante una tupla y los campos "
"dependen del tipo de dirección. El formulario de tupla general es "
"``(addr_type, v1, v2, v3 [, scope])``, donde:"

#: ../Doc/library/socket.rst:103
msgid ""
"*addr_type* is one of :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, "
"or :const:`TIPC_ADDR_ID`."
msgstr ""
"*addr_type* es uno de :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, "
"o :const:`TIPC_ADDR_ID`."

#: ../Doc/library/socket.rst:105
msgid ""
"*scope* is one of :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, "
"and :const:`TIPC_NODE_SCOPE`."
msgstr ""
"*scope* es una de :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, y :"
"const:`TIPC_NODE_SCOPE`."

#: ../Doc/library/socket.rst:107
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAME`, then *v1* is the server type, "
"*v2* is the port identifier, and *v3* should be 0."
msgstr ""
"Si *addr_type* es :const:`TIPC_ADDR_NAME`, entonces *v1* es el tipo de "
"servidor, *v2* es el identificador de puerto, y *v3* debe ser 0."

#: ../Doc/library/socket.rst:110
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAMESEQ`, then *v1* is the server type, "
"*v2* is the lower port number, and *v3* is the upper port number."
msgstr ""
"Si *addr_type* es :const:`TIPC_ADDR_NAMESEQ`, entonces  *v1* es el tipo de "
"servidor, *v2* es el numero de puerto inferior, y *v3* es el numero de "
"puerto superior."

#: ../Doc/library/socket.rst:113
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_ID`, then *v1* is the node, *v2* is the "
"reference, and *v3* should be set to 0."
msgstr ""
"Si *addr_type* es :const:`TIPC_ADDR_ID`, *v1* es el nodo, *v2* es la "
"referencia y *v3* debe establecerse en 0."

#: ../Doc/library/socket.rst:116
msgid ""
"A tuple ``(interface, )`` is used for the :const:`AF_CAN` address family, "
"where *interface* is a string representing a network interface name like "
"``'can0'``. The network interface name ``''`` can be used to receive packets "
"from all network interfaces of this family."
msgstr ""
"Una tupla ``(interface, )`` es usada para la dirección de familia :const:"
"`AF_CAN`, donde *interface* es una cadena de caracteres representando a un "
"nombre de interfaz de red como ``’can0’``. La interfaz de red llamada ``''`` "
"puede ser usada para recibir paquetes de todas las interfaces de red de esta "
"familia."

#: ../Doc/library/socket.rst:121
msgid ""
":const:`CAN_ISOTP` protocol require a tuple ``(interface, rx_addr, "
"tx_addr)`` where both additional parameters are unsigned long integer that "
"represent a CAN identifier (standard or extended)."
msgstr ""
"Protocolo :const:`CAN_ISOTP` requiere una tupla ``(interface, rx_addr, "
"tx_addr)`` donde ambos tiene parámetros adicionales son enteres largos sin "
"símbolos que representan una identificador CAN (estándar o extendido)."

#: ../Doc/library/socket.rst:124
msgid ""
":const:`CAN_J1939` protocol require a tuple ``(interface, name, pgn, addr)`` "
"where additional parameters are 64-bit unsigned integer representing the ECU "
"name, a 32-bit unsigned integer representing the Parameter Group Number "
"(PGN), and an 8-bit integer representing the address."
msgstr ""
"Protocolo :const:`CAN_J1939` requiere una tupla ``(interface, name, pgn, "
"addr)`` donde los parámetros adicionales son números enteros sin signo de 64 "
"bits representando el nombre ECU, los enteros sin signo de 32-bits "
"representan el numero de grupo de parámetros(PGN), y los enteros de 8-bit "
"representan la dirección."

#: ../Doc/library/socket.rst:129
msgid ""
"A string or a tuple ``(id, unit)`` is used for the :const:`SYSPROTO_CONTROL` "
"protocol of the :const:`PF_SYSTEM` family. The string is the name of a "
"kernel control using a dynamically assigned ID. The tuple can be used if ID "
"and unit number of the kernel control are known or if a registered ID is "
"used."
msgstr ""
"Se utiliza una cadena o una tupla ``(id, unit)`` para el protocolo :const:"
"`SYSPROTO_CONTROL` de la familia :const:`PF_SYSTEM`. La cadena es el nombre "
"de un control de kernel mediante un ID asignado dinámicamente. La tupla se "
"puede utilizar si se conoce el ID y el número de unidad del control del "
"kernel o si se utiliza un ID registrado."

#: ../Doc/library/socket.rst:137
msgid ""
":const:`AF_BLUETOOTH` supports the following protocols and address formats:"
msgstr ""
":const:`AF_BLUETOOTH` admite los siguientes protocolos y formatos de "
"dirección:"

#: ../Doc/library/socket.rst:140
msgid ""
":const:`BTPROTO_L2CAP` accepts ``(bdaddr, psm)`` where ``bdaddr`` is the "
"Bluetooth address as a string and ``psm`` is an integer."
msgstr ""
":const:`BTPROTO_L2CAP` acepta ``(bdaddr, psm)`` donde ``bdaddr`` es la "
"dirección Bluetooth como una cadena de caracteres y ``psm`` es un entero."

#: ../Doc/library/socket.rst:143
msgid ""
":const:`BTPROTO_RFCOMM` accepts ``(bdaddr, channel)`` where ``bdaddr`` is "
"the Bluetooth address as a string and ``channel`` is an integer."
msgstr ""
":const:`BTPROTO_RFCOMM` acepta ``(bdaddr, channel)`` donde ``bdaddr`` es la "
"dirección Bluetooth como una cadena de caracteres y ``channel`` es un entero."

#: ../Doc/library/socket.rst:146
msgid ""
":const:`BTPROTO_HCI` accepts ``(device_id,)`` where ``device_id`` is either "
"an integer or a string with the Bluetooth address of the interface. (This "
"depends on your OS; NetBSD and DragonFlyBSD expect a Bluetooth address while "
"everything else expects an integer.)"
msgstr ""
":const:`BTPROTO_HCI` acepta ``(device_id,)`` donde ``device_id`` es un "
"numero entero o una cadena de caracteres con la dirección Bluetooth de la "
"interfaz. (Esto depende de tu OS; NetBSD y DragonFlyBSD supone una dirección "
"Bluetooth mientras todo lo demás espera un entero.)"

#: ../Doc/library/socket.rst:151
msgid "NetBSD and DragonFlyBSD support added."
msgstr "Se ha añadido compatibilidad con NetBSD y DragonFlyBSD."

#: ../Doc/library/socket.rst:154
msgid ""
":const:`BTPROTO_SCO` accepts ``bdaddr`` where ``bdaddr`` is a :class:`bytes` "
"object containing the Bluetooth address in a string format. (ex. "
"``b'12:23:34:45:56:67'``) This protocol is not supported under FreeBSD."
msgstr ""
":const:`BTPROTO_SCO` acepta ``bdaddr`` donde ``bdaddr`` es un objeto :class:"
"`bytes` que contiene la dirección Bluetooth en un formato cadena. (ex. "
"``b’12:23:34:45:56:67’``) este protocolo no es admitido bajo FreeBSD."

#: ../Doc/library/socket.rst:159
msgid ""
":const:`AF_ALG` is a Linux-only socket based interface to Kernel "
"cryptography. An algorithm socket is configured with a tuple of two to four "
"elements ``(type, name [, feat [, mask]])``, where:"
msgstr ""
":const:`AF_ALG` es una interfaz basada en socket solo Linux para la "
"criptografía del núcleo. Un socket de algoritmo se configura con una tupla "
"de dos a cuatro elementos ``(type, name [, feat [, mask]])``, donde:"

#: ../Doc/library/socket.rst:163
msgid ""
"*type* is the algorithm type as string, e.g. ``aead``, ``hash``, "
"``skcipher`` or ``rng``."
msgstr ""
"*type* es el tipo de algoritmos como cadenas de caracteres, e.g. ``aead``, "
"``hash``, ``skcipher`` o ``rng``."

#: ../Doc/library/socket.rst:166
msgid ""
"*name* is the algorithm name and operation mode as string, e.g. ``sha256``, "
"``hmac(sha256)``, ``cbc(aes)`` or ``drbg_nopr_ctr_aes256``."
msgstr ""
"*name* es el nombre del algoritmo y el modo de operación como cadena de "
"caracteres, e.g. ``sha256``, ``hmac(sha256)``, ``cbc(aes)`` o "
"``drbg_nopr_ctr_aes256``."

#: ../Doc/library/socket.rst:169
msgid "*feat* and *mask* are unsigned 32bit integers."
msgstr "*feat* y *mask* son enteros de 32 bits sin signo."

#: ../Doc/library/socket.rst:171 ../Doc/library/socket.rst:583
#: ../Doc/library/socket.rst:1865
msgid ":ref:`Availability <availability>`: Linux >= 2.6.38."
msgstr ":ref:`Availability <availability>`: Linux >= 2.6.38."

#: ../Doc/library/socket.rst:173
msgid "Some algorithm types require more recent Kernels."
msgstr "Algunos tipos de algoritmos requieren Kernels mas recientes."

#: ../Doc/library/socket.rst:177
msgid ""
":const:`AF_VSOCK` allows communication between virtual machines and their "
"hosts. The sockets are represented as a ``(CID, port)`` tuple where the "
"context ID or CID and port are integers."
msgstr ""
":const:`AF_VSOCK` permite comunicación entre maquinas virtuales y sus hosts. "
"Los sockets están representando como una tupla ``(CID, port)`` donde el "
"contexto del ID o CID y el puerto son enteros."

#: ../Doc/library/socket.rst:181 ../Doc/library/socket.rst:656
msgid ":ref:`Availability <availability>`: Linux >= 3.9"
msgstr ":ref:`Availability <availability>`: Linux >= 3.9"

#: ../Doc/library/socket.rst:183
msgid "See :manpage:`vsock(7)`"
msgstr "Véase :manpage:`vsock(7)`"

#: ../Doc/library/socket.rst:187
msgid ""
":const:`AF_PACKET` is a low-level interface directly to network devices. The "
"packets are represented by the tuple ``(ifname, proto[, pkttype[, hatype[, "
"addr]]])`` where:"
msgstr ""
":const:`AF_PACKET` es una interfaz de bajo nivel directa con los "
"dispositivos de red. Los paquetes están representados por la tupla "
"``(ifname, proto[, pkttype[, hatype[, addr]]])`` donde:"

#: ../Doc/library/socket.rst:191
msgid "*ifname* - String specifying the device name."
msgstr "*ifname* - Cadena que especifica el nombre del dispositivo."

#: ../Doc/library/socket.rst:192
msgid ""
"*proto* - The Ethernet protocol number. May be :data:`ETH_P_ALL` to capture "
"all protocols, one of the :ref:`ETHERTYPE_* constants <socket-ethernet-"
"types>` or any other Ethernet protocol number. Value must be in network-byte-"
"order."
msgstr ""
"*proto* - El número del protocolo Ethernet. Puede ser :data:`ETH_P_ALL` para "
"capturar todos los protocolos, una de las :ref:`constantes ETHERTYPE_* "
"<socket-ethernet-types>` o cualquier otro número de protocolo Ethernet. El "
"valor debe estar en bytes de red-orden."

#: ../Doc/library/socket.rst:197
msgid "*pkttype* - Optional integer specifying the packet type:"
msgstr "*pkttype* - Entero opcional especificando el tipo de paquete:"

#: ../Doc/library/socket.rst:199
msgid "``PACKET_HOST`` (the default) - Packet addressed to the local host."
msgstr "``PACKET_HOST`` (por defecto) - Paquetes diseccionado al local host."

#: ../Doc/library/socket.rst:200
msgid "``PACKET_BROADCAST`` - Physical-layer broadcast packet."
msgstr "``PACKET_BROADCAST`` - Paquete de transmisión de la capa física."

#: ../Doc/library/socket.rst:201
msgid ""
"``PACKET_MULTICAST`` - Packet sent to a physical-layer multicast address."
msgstr ""
"``PACKET_MULTICAST`` - Paquete enviado a una dirección de multidifusión de "
"capa física."

#: ../Doc/library/socket.rst:202
msgid ""
"``PACKET_OTHERHOST`` - Packet to some other host that has been caught by a "
"device driver in promiscuous mode."
msgstr ""
"``PACKET_OTHERHOST`` - Paquete a otro host que haya sido capturado por un "
"controlador de dispositivo en modo promiscuo."

#: ../Doc/library/socket.rst:204
msgid ""
"``PACKET_OUTGOING`` - Packet originating from the local host that is looped "
"back to a packet socket."
msgstr ""
"``PACKET_OUTGOING`` - Paquete originalmente desde el local host que se "
"enlaza de nuevo a un conector de paquetes."

#: ../Doc/library/socket.rst:206
msgid "*hatype* - Optional integer specifying the ARP hardware address type."
msgstr ""
"*hatype* - Entero opcional que especifica el tipo de dirección de hardware "
"ARP."

#: ../Doc/library/socket.rst:207
msgid ""
"*addr* - Optional bytes-like object specifying the hardware physical "
"address, whose interpretation depends on the device."
msgstr ""
"*addr* - Objeto opcional en forma de bytes que especifica la dirección "
"física del hardware, cuya interpretación depende del dispositivo."

#: ../Doc/library/socket.rst:210 ../Doc/library/socket.rst:531
msgid ":ref:`Availability <availability>`: Linux >= 2.2."
msgstr ":ref:`Availability <availability>`: Linux >= 2.2."

#: ../Doc/library/socket.rst:212
msgid ""
":const:`AF_QIPCRTR` is a Linux-only socket based interface for communicating "
"with services running on co-processors in Qualcomm platforms. The address "
"family is represented as a ``(node, port)`` tuple where the *node* and "
"*port* are non-negative integers."
msgstr ""
":const:`AF_QIPCRTR` es una interfaz basada en sockets solo para Linux para "
"comunicarse con servicios que se ejecutan en co-procesadores en plataformas "
"Qualcomm. La familia de direcciones se representa como una tupla ``(node, "
"port)`` donde el *node* y *port* son enteros no negativos."

#: ../Doc/library/socket.rst:217 ../Doc/library/socket.rst:632
msgid ":ref:`Availability <availability>`: Linux >= 4.7."
msgstr ":ref:`Availability <availability>`: Linux >= 4.7."

#: ../Doc/library/socket.rst:221
msgid ""
":const:`IPPROTO_UDPLITE` is a variant of UDP which allows you to specify "
"what portion of a packet is covered with the checksum. It adds two socket "
"options that you can change. ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_SEND_CSCOV, length)`` will change what portion of outgoing packets "
"are covered by the checksum and ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_RECV_CSCOV, length)`` will filter out packets which cover too little "
"of their data. In both cases ``length`` should be in ``range(8, 2**16, 8)``."
msgstr ""
":const:`IPPROTO_UDPLITE` es una variante de UDO que te permite especificar "
"que porción del paquete es cubierta con la suma de comprobación. Esto agrega "
"dos opciones al socket que pueden cambiar. ``self."
"setsockopt(IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV, length)`` cambiara que parte "
"de los paquetes salientes están cubierta por la suma de comprobación y "
"``self.setsockopt(IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV, length)`` filtrara "
"los paquetes que permitirá cubrir una pequeña parte de tu datos. En ambos "
"casos ``length`` deben estar en ``range(8, 2**16, 8)``."

#: ../Doc/library/socket.rst:230
msgid ""
"Such a socket should be constructed with ``socket(AF_INET, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv4 or ``socket(AF_INET6, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv6."
msgstr ""
"Tal socket debe construirse como ``socket(AF_INET, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` para IPV4 o ``socket(AF_INET6, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` para IPV6."

#: ../Doc/library/socket.rst:234
msgid ":ref:`Availability <availability>`: Linux >= 2.6.20, FreeBSD >= 10.1"
msgstr ":ref:`Availability <availability>`: Linux >= 2.6.20, NetBSD >= 10.1"

#: ../Doc/library/socket.rst:238
msgid ""
":const:`AF_HYPERV` is a Windows-only socket based interface for "
"communicating with Hyper-V hosts and guests. The address family is "
"represented as a ``(vm_id, service_id)`` tuple where the ``vm_id`` and "
"``service_id`` are UUID strings."
msgstr ""
":const:`AF_HYPERV` es una interfaz basada en sockets exclusiva de Windows "
"para comunicarse con hosts e invitados de Hyper-V. La familia de direcciones "
"se representa como una tupla ``(vm_id, service_id)`` donde ``vm_id`` y "
"``service_id`` son cadenas UUID."

#: ../Doc/library/socket.rst:243
msgid ""
"The ``vm_id`` is the virtual machine identifier or a set of known VMID "
"values if the target is not a specific virtual machine. Known VMID constants "
"defined on ``socket`` are:"
msgstr ""
"El ``vm_id`` es el identificador de la máquina virtual o un conjunto de VMID "
"conocidos valores si el objetivo no es una máquina virtual específica. "
"Constantes VMID conocidas definidos en ``socket`` son:"

#: ../Doc/library/socket.rst:247
msgid "``HV_GUID_ZERO``"
msgstr "``HV_GUID_ZERO``"

#: ../Doc/library/socket.rst:248
msgid "``HV_GUID_BROADCAST``"
msgstr "``HV_GUID_BROADCAST``"

#: ../Doc/library/socket.rst:249
msgid ""
"``HV_GUID_WILDCARD`` - Used to bind on itself and accept connections from "
"all partitions."
msgstr ""
"``HV_GUID_WILDCARD`` - Se utiliza para vincularse a sí mismo y aceptar "
"conexiones de todas las particiones."

#: ../Doc/library/socket.rst:251
msgid ""
"``HV_GUID_CHILDREN`` - Used to bind on itself and accept connection from "
"child partitions."
msgstr ""
"``HV_GUID_CHILDREN`` - Se utiliza para vincularse a sí mismo y aceptar "
"conexiones desde particiones secundarias."

#: ../Doc/library/socket.rst:253
msgid "``HV_GUID_LOOPBACK`` - Used as a target to itself."
msgstr "``HV_GUID_LOOPBACK`` - Se utiliza como objetivo para sí mismo."

#: ../Doc/library/socket.rst:254
msgid ""
"``HV_GUID_PARENT`` - When used as a bind accepts connection from the parent "
"partition. When used as an address target it will connect to the parent "
"partition."
msgstr ""
"``HV_GUID_PARENT`` - Cuando se usa como enlace, acepta la conexión del padre "
"partición. Cuando se utiliza como dirección de destino, se conectará al "
"padre dividir."

#: ../Doc/library/socket.rst:257
msgid "The ``service_id`` is the service identifier of the registered service."
msgstr "El ``service_id`` es el identificador del servicio registrado."

#: ../Doc/library/socket.rst:261
msgid ""
"If you use a hostname in the *host* portion of IPv4/v6 socket address, the "
"program may show a nondeterministic behavior, as Python uses the first "
"address returned from the DNS resolution.  The socket address will be "
"resolved differently into an actual IPv4/v6 address, depending on the "
"results from DNS resolution and/or the host configuration.  For "
"deterministic behavior use a numeric address in *host* portion."
msgstr ""
"Si utiliza un nombre de host en la parte *host* de la dirección de socket "
"IPv4/v6, el programa puede mostrar un comportamiento no determinista, ya que "
"Python utiliza la primera dirección devuelta por la resolución DNS.  La "
"dirección del socket se resolverá de manera diferente en una dirección IPv4/"
"v6 real, dependiendo de los resultados de la resolución DNS y/o la "
"configuración del host.  Para un comportamiento determinista, utilice una "
"dirección numérica en la parte *host*."

#: ../Doc/library/socket.rst:268
msgid ""
"All errors raise exceptions.  The normal exceptions for invalid argument "
"types and out-of-memory conditions can be raised. Errors related to socket "
"or address semantics raise :exc:`OSError` or one of its subclasses."
msgstr ""
"Todos los errores generan excepciones. Las excepciones normales para tipos "
"de argumentos inválidos y condiciones de falta de memoria pueden ser "
"lanzadas. Los errores relacionados con la semántica de los sockets o de las "
"direcciones lanzan :exc:`OSError` o una de sus subclases."

#: ../Doc/library/socket.rst:273
msgid ""
"Non-blocking mode is supported through :meth:`~socket.setblocking`.  A "
"generalization of this based on timeouts is supported through :meth:`~socket."
"settimeout`."
msgstr ""
"El modo de no bloqueo es compatible a través de :meth:`~socket."
"setblocking`.  Se admite una generalización de esto basada en los tiempos de "
"espera a través de :meth:`~socket.settimeout`."

#: ../Doc/library/socket.rst:279
msgid "Module contents"
msgstr "Contenido del módulo"

#: ../Doc/library/socket.rst:281
msgid "The module :mod:`socket` exports the following elements."
msgstr "El módulo :mod:`socket` exporta los siguientes elementos."

#: ../Doc/library/socket.rst:285
msgid "Exceptions"
msgstr "Excepciones"

#: ../Doc/library/socket.rst:289
msgid "A deprecated alias of :exc:`OSError`."
msgstr "Un alias en desuso de :exc:`OSError`."

#: ../Doc/library/socket.rst:291
msgid "Following :pep:`3151`, this class was made an alias of :exc:`OSError`."
msgstr ""
"Siguiendo :pep:`3151`, es clase fue creada como un alias de :exc:`OSError`."

#: ../Doc/library/socket.rst:297
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors, i.e. for functions that use *h_errno* in the POSIX C API, including :"
"func:`gethostbyname_ex` and :func:`gethostbyaddr`. The accompanying value is "
"a pair ``(h_errno, string)`` representing an error returned by a library "
"call.  *h_errno* is a numeric value, while *string* represents the "
"description of *h_errno*, as returned by the :c:func:`hstrerror` C function."
msgstr ""
"Una subclase de :exc:`OSError`, esta excepción se produce para los errores "
"relacionados con la dirección, es decir, para las funciones que utilizan "
"*h_errno* en la API de POSIX C, incluidas :func:`gethostbyname_ex` y :func:"
"`gethostbyaddr`. El valor adjunto es un par ``(h_errno, string)`` que "
"representa un error devuelto por una llamada a la biblioteca.  *h_errno* es "
"un valor numérico, mientras que *string* representa la descripción de "
"*h_errno*, devuelta por la función :c:func:`hstrerror` C."

#: ../Doc/library/socket.rst:305 ../Doc/library/socket.rst:318
#: ../Doc/library/socket.rst:331
msgid "This class was made a subclass of :exc:`OSError`."
msgstr "Esta clase fue creada como una subclase de :exc:`OSError`."

#: ../Doc/library/socket.rst:310
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors by :func:`getaddrinfo` and :func:`getnameinfo`. The accompanying "
"value is a pair ``(error, string)`` representing an error returned by a "
"library call.  *string* represents the description of *error*, as returned "
"by the :c:func:`gai_strerror` C function.  The numeric *error* value will "
"match one of the :const:`EAI_\\*` constants defined in this module."
msgstr ""
"Una subclase de :exc:`OSError`, esta excepción se genera por errores "
"relacionados a la dirección por :func:`getaddrinfo` y :func:`getnameinfo`. "
"El valor de acompañamiento es un par ``(error, string)`` representado un "
"error retornado por una llamada de librería. *string* representa la "
"descripción del *error*, tal como es retornado por la función C :c:func:"
"`gai_strerror`. El valor numérico *error* coincide con una de las "
"constantes :const:`EAI_\\*` definidas en este modulo."

#: ../Doc/library/socket.rst:323
msgid "A deprecated alias of :exc:`TimeoutError`."
msgstr "Un alias obsoleto de :exc:`TimeoutError`."

#: ../Doc/library/socket.rst:325
msgid ""
"A subclass of :exc:`OSError`, this exception is raised when a timeout occurs "
"on a socket which has had timeouts enabled via a prior call to :meth:"
"`~socket.settimeout` (or implicitly through :func:`~socket."
"setdefaulttimeout`).  The accompanying value is a string whose value is "
"currently always \"timed out\"."
msgstr ""
"Una subclase de :exc:`OSError`, esta excepción se genera cuando ocurre un "
"*timeout* en un socket que ha tenido tiempos de espera habilitados a través "
"de una llamada previa a :meth:`~socket.settimeout` ( o implícitamente "
"mediante :func:`~socket.setdefaulttimeout`). El valor del acompañamiento es "
"una cadena de caracteres cuyo valor es actualmente siempre “tiempo de "
"espera”."

#: ../Doc/library/socket.rst:334
msgid "This class was made an alias of :exc:`TimeoutError`."
msgstr "Esta clase se convirtió en un alias de :exc:`TimeoutError`."

#: ../Doc/library/socket.rst:339
msgid "Constants"
msgstr "Constantes"

#: ../Doc/library/socket.rst:341
msgid ""
"The AF_* and SOCK_* constants are now :class:`AddressFamily` and :class:"
"`SocketKind` :class:`.IntEnum` collections."
msgstr ""
"Las constantes AF_* y SOCK_* ahora son colecciones: :class:`AddressFamily` "
"y :class:`SocketKind` :class:`.IntEnum`."

#: ../Doc/library/socket.rst:350
msgid ""
"These constants represent the address (and protocol) families, used for the "
"first argument to :func:`.socket`.  If the :const:`AF_UNIX` constant is not "
"defined then this protocol is unsupported.  More constants may be available "
"depending on the system."
msgstr ""
"Estas constantes representan la familias de direcciones (y protocolos), "
"usados para el primer argumento para :func:`.socket`. Si la constante :const:"
"`AF_UNIX` no esta definida entonces este protocolo no es compatible. Mas "
"constantes podrían estar disponibles dependiendo del sistema."

#: ../Doc/library/socket.rst:362
msgid ""
"These constants represent the socket types, used for the second argument to :"
"func:`.socket`.  More constants may be available depending on the system. "
"(Only :const:`SOCK_STREAM` and :const:`SOCK_DGRAM` appear to be generally "
"useful.)"
msgstr ""
"Estas constantes representan los tipos de socket, usadas por el segundo "
"argumento para :func:`.socket`. Mas constante podrían estar disponibles "
"dependiendo del sistema. ( Solamente :const:`SOCK_STREAM` y :const:"
"`SOCK_DGRAM` parecen ser útiles en general.)"

#: ../Doc/library/socket.rst:370
msgid ""
"These two constants, if defined, can be combined with the socket types and "
"allow you to set some flags atomically (thus avoiding possible race "
"conditions and the need for separate calls)."
msgstr ""
"Estas dos constantes, si se definen, se pueden combinar con los tipos de "
"socket y le permiten establecer algunas banderas atómicamente (evitando así "
"posibles condiciones de carrera y la necesidad de llamadas separadas)."

#: ../Doc/library/socket.rst:376
msgid ""
"`Secure File Descriptor Handling <https://udrepper.livejournal.com/20407."
"html>`_ for a more thorough explanation."
msgstr ""
"`Secure File Descriptor Handling <http://udrepper.livejournal.com/20407."
"html>`_ para una explicación más completa."

#: ../Doc/library/socket.rst:379
msgid ":ref:`Availability <availability>`: Linux >= 2.6.27."
msgstr ":ref:`Availability <availability>`: Linux >= 2.6.27."

#: ../Doc/library/socket.rst:398
msgid ""
"Many constants of these forms, documented in the Unix documentation on "
"sockets and/or the IP protocol, are also defined in the socket module. They "
"are generally used in arguments to the :meth:`setsockopt` and :meth:"
"`getsockopt` methods of socket objects.  In most cases, only those symbols "
"that are defined in the Unix header files are defined; for a few symbols, "
"default values are provided."
msgstr ""
"Muchas constantes de estos formularios, documentadas en la documentación de "
"Unix en sockets y/o el protocolo IP, también se definen en el módulo de "
"socket. Generalmente se utilizan en argumentos de los métodos :meth:"
"`setsockopt` y :meth:`getsockopt` de objetos socket.  En la mayoría de los "
"casos, solo se definen los símbolos definidos en los archivos de encabezado "
"Unix; para algunos símbolos, se proporcionan valores predeterminados."

#: ../Doc/library/socket.rst:405
msgid ""
"``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION`` were added."
msgstr ""
"``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION`` han sido agregados."

#: ../Doc/library/socket.rst:409
msgid ""
"On Windows, ``TCP_FASTOPEN``, ``TCP_KEEPCNT`` appear if run-time Windows "
"supports."
msgstr ""
"En Windows, ``TCP_FASTOPEN``, ``TCP_KEEPCNT`` aparecen si el tiempo de "
"ejecución de Windows lo admite."

#: ../Doc/library/socket.rst:413
msgid "``TCP_NOTSENT_LOWAT`` was added."
msgstr "``TCP_NOTSENT_LOWAT`` ha sido agregada."

#: ../Doc/library/socket.rst:416
msgid ""
"On Windows, ``TCP_KEEPIDLE``, ``TCP_KEEPINTVL`` appear if run-time Windows "
"supports."
msgstr ""
"En Windows, ``TCP_KEEPIDLE``, ``TCP_KEEPINTVL`` aparecen si el tiempo de "
"ejecución de Windows lo admite."

#: ../Doc/library/socket.rst:419
msgid ""
"``IP_RECVTOS`` was added.  Added ``TCP_KEEPALIVE``. On MacOS this constant "
"can be used in the same  way that ``TCP_KEEPIDLE`` is used on Linux."
msgstr ""
"Se agregó ``IP_RECVTOS``. Se agregó ``TCP_KEEPALIVE``. En MacOS, esta "
"constante se puede utilizar de la misma forma que ``TCP_KEEPIDLE`` en Linux."

#: ../Doc/library/socket.rst:424
msgid ""
"Added ``TCP_CONNECTION_INFO``. On MacOS this constant can be used in the "
"same way that ``TCP_INFO`` is used on Linux and BSD."
msgstr ""
"Se agregó ``TCP_CONNECTION_INFO``. En MacOS esta constante se puede utilizar "
"de la misma manera que ``TCP_INFO`` se utiliza en Linux y BSD."

#: ../Doc/library/socket.rst:428
msgid ""
"Added ``SO_RTABLE`` and ``SO_USER_COOKIE``. On OpenBSD and FreeBSD "
"respectively those constants can be used in the same way that ``SO_MARK`` is "
"used on Linux. Also added missing TCP socket options from Linux: "
"``TCP_MD5SIG``, ``TCP_THIN_LINEAR_TIMEOUTS``, ``TCP_THIN_DUPACK``, "
"``TCP_REPAIR``, ``TCP_REPAIR_QUEUE``, ``TCP_QUEUE_SEQ``, "
"``TCP_REPAIR_OPTIONS``, ``TCP_TIMESTAMP``, ``TCP_CC_INFO``, "
"``TCP_SAVE_SYN``, ``TCP_SAVED_SYN``, ``TCP_REPAIR_WINDOW``, "
"``TCP_FASTOPEN_CONNECT``, ``TCP_ULP``, ``TCP_MD5SIG_EXT``, "
"``TCP_FASTOPEN_KEY``, ``TCP_FASTOPEN_NO_COOKIE``, ``TCP_ZEROCOPY_RECEIVE``, "
"``TCP_INQ``, ``TCP_TX_DELAY``. Added ``IP_PKTINFO``, ``IP_UNBLOCK_SOURCE``, "
"``IP_BLOCK_SOURCE``, ``IP_ADD_SOURCE_MEMBERSHIP``, "
"``IP_DROP_SOURCE_MEMBERSHIP``."
msgstr ""
"Se agregaron ``SO_RTABLE`` y ``SO_USER_COOKIE``. En OpenBSD y FreeBSD "
"respectivamente, esas constantes se pueden usar de la misma manera que "
"``SO_MARK`` es usado en Linux. También se agregaron opciones de socket TCP "
"faltantes de Linux: ``TCP_MD5SIG``, ``TCP_THIN_LINEAR_TIMEOUTS``, "
"``TCP_THIN_DUPACK``, ``TCP_REPAIR``, ``TCP_REPAIR_QUEUE``, "
"``TCP_QUEUE_SEQ``, ``TCP_REPAIR_OPTIONS``, ``TCP_TIMESTAMP``, "
"``TCP_CC_INFO``, ``TCP_SAVE_SYN``, ``TCP_SAVED_SYN``, ``TCP_REPAIR_WINDOW``, "
"``TCP_FASTOPEN_CONNECT``, ``TCP_ULP``, ``TCP_MD5SIG_EXT``, "
"``TCP_FASTOPEN_KEY``, ``TCP_FASTOPEN_NO_COOKIE``, ``TCP_ZEROCOPY_RECEIVE``, "
"``TCP_INQ``, ``TCP_TX_DELAY``. Se agregó ``IP_PKTINFO``, "
"``IP_UNBLOCK_SOURCE``, ``IP_BLOCK_SOURCE``, ``IP_ADD_SOURCE_MEMBERSHIP``, "
"``IP_DROP_SOURCE_MEMBERSHIP``."

#: ../Doc/library/socket.rst:447 ../Doc/library/socket.rst:528
#: ../Doc/library/socket.rst:552
msgid ""
"Many constants of these forms, documented in the Linux documentation, are "
"also defined in the socket module."
msgstr ""
"Muchas constantes de estos formularios, documentadas en la documentación de "
"Linux, también se definen en el módulo de socket."

#: ../Doc/library/socket.rst:450
msgid ":ref:`Availability <availability>`: Linux >= 2.6.25, NetBSD >= 8."
msgstr ":ref:`Availability <availability>`: Linux >= 2.6.25, NetBSD >= 8."

#: ../Doc/library/socket.rst:454
msgid "NetBSD support was added."
msgstr "Se ha agregado compatibilidad con NetBSD."

#: ../Doc/library/socket.rst:460
msgid ""
"CAN_BCM, in the CAN protocol family, is the broadcast manager (BCM) "
"protocol. Broadcast manager constants, documented in the Linux "
"documentation, are also defined in the socket module."
msgstr ""
"CAN_BCM, en la familia de protocolo CAN, es el protocolo del administrador "
"de difusión (BCM. Las constantes del administrador de difusión, documentada "
"en la documentación de Linux, también esta definidos en el modulo socket."

#: ../Doc/library/socket.rst:464 ../Doc/library/socket.rst:499
msgid ":ref:`Availability <availability>`: Linux >= 2.6.25."
msgstr ":ref:`Availability <availability>`: Linux >= 2.6.25."

#: ../Doc/library/socket.rst:467
msgid ""
"The :data:`CAN_BCM_CAN_FD_FRAME` flag is only available on Linux >= 4.8."
msgstr ""
"El indicador :data:`CAN_BCM_CAN_FD_FRAME` esta solamente disponible en Linux "
">= 4.8."

#: ../Doc/library/socket.rst:473
msgid ""
"Enables CAN FD support in a CAN_RAW socket. This is disabled by default. "
"This allows your application to send both CAN and CAN FD frames; however, "
"you must accept both CAN and CAN FD frames when reading from the socket."
msgstr ""
"Habilita la compatibilidad con CAN FD en un socket CAN_RAW. Esta opción está "
"deshabilitada de forma predeterminada. Esto permite que la aplicación envíe "
"tramas CAN y CAN FD; sin embargo, debe aceptar las tramas CAN y CAN FD al "
"leer desde el socket."

#: ../Doc/library/socket.rst:477 ../Doc/library/socket.rst:488
msgid "This constant is documented in the Linux documentation."
msgstr "Esta constante se documenta en la documentación de Linux."

#: ../Doc/library/socket.rst:479
msgid ":ref:`Availability <availability>`: Linux >= 3.6."
msgstr ":ref:`Availability <availability>`: Linux >= 3.6."

#: ../Doc/library/socket.rst:485
msgid ""
"Joins the applied CAN filters such that only CAN frames that match all given "
"CAN filters are passed to user space."
msgstr ""
"Se une a los filtros CAN aplicados de modo que solo las tramas CAN que "
"coinciden con todos los filtros CAN dados se pasan al espacio del usuario."

#: ../Doc/library/socket.rst:490
msgid ":ref:`Availability <availability>`: Linux >= 4.1."
msgstr ":ref:`Availability <availability>`: Linux >= 4.1."

#: ../Doc/library/socket.rst:496
msgid ""
"CAN_ISOTP, in the CAN protocol family, is the ISO-TP (ISO 15765-2) protocol. "
"ISO-TP constants, documented in the Linux documentation."
msgstr ""
"CAN_ISOTP, en el protocolo de familia CAN, es el protocolo  ISO-TP (ISO "
"15765-2). Constantes ISO-TP, documentadas en la documentación Linux."

#: ../Doc/library/socket.rst:505
msgid ""
"CAN_J1939, in the CAN protocol family, is the SAE J1939 protocol. J1939 "
"constants, documented in the Linux documentation."
msgstr ""
"CAN_J1939, en el protocolo de familias CAN, es el protocolo SAE J1939. "
"Constantes J1939, documentadas en el documentación Linux."

#: ../Doc/library/socket.rst:508
msgid ":ref:`Availability <availability>`: Linux >= 5.4."
msgstr ":ref:`Availability <availability>`: Linux >= 5.4."

#: ../Doc/library/socket.rst:516
msgid ""
"These two constants, documented in the FreeBSD divert(4) manual page, are "
"also defined in the socket module."
msgstr ""
"Estas dos constantes, documentadas en la página del manual de FreeBSD "
"divert(4), también están definidas en el módulo de socket."

#: ../Doc/library/socket.rst:519
msgid ":ref:`Availability <availability>`: FreeBSD >= 14.0."
msgstr ":ref:`Availability <availability>`: FreeBSD >= 14.0."

#: ../Doc/library/socket.rst:536
msgid ""
":data:`!ETH_P_ALL` can be used in the :class:`~socket.socket` constructor as "
"*proto* for the :const:`AF_PACKET` family in order to capture every packet, "
"regardless of protocol."
msgstr ""
"El ``service_id`` es el identificador del servicio registrado.:data:`!"
"ETH_P_ALL` se puede utilizar en el constructor :class:`~socket.socket` como "
"*proto* para la familia :const:`AF_PACKET` para capturar cada paquete, "
"independientemente del protocolo."

#: ../Doc/library/socket.rst:540
msgid "For more information, see the :manpage:`packet(7)` manpage."
msgstr ""
"Para obtener más información, consulte la página de manual :manpage:"
"`packet(7)`."

#: ../Doc/library/socket.rst:542
msgid ":ref:`Availability <availability>`: Linux."
msgstr ":ref:`Availability <availability>`: Linux."

#: ../Doc/library/socket.rst:555
msgid ":ref:`Availability <availability>`: Linux >= 2.6.30."
msgstr ":ref:`Availability <availability>`: Linux >= 2.6.30."

#: ../Doc/library/socket.rst:565
msgid ""
"Constants for Windows' WSAIoctl(). The constants are used as arguments to "
"the :meth:`~socket.socket.ioctl` method of socket objects."
msgstr ""
"Constantes para Windows’ WSAIoctl(). Las constantes se utiliza como "
"argumentos al método :meth:`~socket.socket.ioctl` de objetos de sockets."

#: ../Doc/library/socket.rst:568 ../Doc/library/socket.rst:1557
msgid "``SIO_LOOPBACK_FAST_PATH`` was added."
msgstr "``SIO_LOOPBACK_FAST_PATH`` ha sido agregado."

#: ../Doc/library/socket.rst:574
msgid ""
"TIPC related constants, matching the ones exported by the C socket API. See "
"the TIPC documentation for more information."
msgstr ""
"LAS constantes relacionadas con TIPC, que coinciden con las exportadas por "
"la API de socket de C. Consulte la documentación de TIPC para obtener más "
"información."

#: ../Doc/library/socket.rst:581
msgid "Constants for Linux Kernel cryptography."
msgstr "Constantes para la criptográfica del Kernel de Linux."

#: ../Doc/library/socket.rst:593
msgid "Constants for Linux host/guest communication."
msgstr "Constantes para la comunicación host/invitado de Linux."

#: ../Doc/library/socket.rst:595
msgid ":ref:`Availability <availability>`: Linux >= 4.8."
msgstr ":ref:`Availability <availability>`: Linux >= 4.8."

#: ../Doc/library/socket.rst:601
msgid ":ref:`Availability <availability>`: BSD, macOS."
msgstr ":ref:`Availability <availability>`: BSD, macOS."

#: ../Doc/library/socket.rst:607
msgid ""
"This constant contains a boolean value which indicates if IPv6 is supported "
"on this platform."
msgstr ""
"Esta constante contiene un valor booleano que indica si IPv6 se admite en "
"esta plataforma."

#: ../Doc/library/socket.rst:613
msgid ""
"These are string constants containing Bluetooth addresses with special "
"meanings. For example, :const:`BDADDR_ANY` can be used to indicate any "
"address when specifying the binding socket with :const:`BTPROTO_RFCOMM`."
msgstr ""
"Estas son constantes de cadenas que contienen direcciones Bluetooth con "
"significados especiales. Por ejemplo :const:`BDADDR_ANY` son usados para "
"indicar cualquier dirección al especificar el socket vinculante con :const:"
"`BTPROTO_RFCOMM`."

#: ../Doc/library/socket.rst:622
msgid ""
"For use with :const:`BTPROTO_HCI`. :const:`HCI_FILTER` is not available for "
"NetBSD or DragonFlyBSD. :const:`HCI_TIME_STAMP` and :const:`HCI_DATA_DIR` "
"are not available for FreeBSD, NetBSD, or DragonFlyBSD."
msgstr ""
"Para usar con :const:`BTPROTO_HCI`. :const:`HCI_FILTER` no esta disponible "
"para NetBSD o DragonFlyBSD. :const:`HCI_TIME_STAMP` y :const:`HCI_DATA_DIR` "
"no esta disponible para FreeBSD, NetBSD, o DragonFlyBSD."

#: ../Doc/library/socket.rst:629
msgid ""
"Constant for Qualcomm's IPC router protocol, used to communicate with "
"service providing remote processors."
msgstr ""
"Constante para el protocolo de router IPC de Qualcomm, que se utiliza para "
"comunicarse con procesadores remotos que brindan servicios."

#: ../Doc/library/socket.rst:638
msgid ""
"LOCAL_CREDS and LOCAL_CREDS_PERSISTENT can be used with SOCK_DGRAM, "
"SOCK_STREAM sockets, equivalent to Linux/DragonFlyBSD SO_PASSCRED, while "
"LOCAL_CREDS sends the credentials at first read, LOCAL_CREDS_PERSISTENT "
"sends for each read, SCM_CREDS2 must be then used for the latter for the "
"message type."
msgstr ""
"LOCAL_CREDS y LOCAL_CREDS_PERSISTENT pueden usarse con sockets SOCK_DGRAM, "
"SOCK_STREAM, equivalente a Linux/DragonFlyBSD SO_PASSCRED, mientras que "
"LOCAL_CREDS envía las credenciales en la primera lectura, "
"LOCAL_CREDS_PERSISTENT envía para cada lectura, SCM_CREDS2 debe entonces ser "
"usado para este último para el tipo de mensaje."

#: ../Doc/library/socket.rst:647
msgid ":ref:`Availability <availability>`: FreeBSD."
msgstr ":ref:`Availability <availability>`: FreeBSD."

#: ../Doc/library/socket.rst:651
msgid ""
"Constant to optimize CPU locality, to be used in conjunction with :data:"
"`SO_REUSEPORT`."
msgstr ""
"Constante para optimizar la localidad CPU, a ser usada en conjunto con :data:"
"`SO_REUSEPORT`."

#: ../Doc/library/socket.rst:671
msgid "Constants for Windows Hyper-V sockets for host/guest communications."
msgstr ""
"Constantes para sockets Windows Hyper-V para comunicaciones host/invitado."

#: ../Doc/library/socket.rst:673 ../Doc/library/socket.rst:880
#: ../Doc/library/socket.rst:1971
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Availability <availability>`: Windows."

#: ../Doc/library/socket.rst:684
msgid ""
"`IEEE 802.3 protocol number <https://www.iana.org/assignments/ieee-802-"
"numbers/ieee-802-numbers.txt>`_. constants."
msgstr ""
"`Número de protocolo IEEE 802.3 <https://www.iana.org/assignments/ieee-802-"
"números/ieee-802-numbers.txt>`_. constantes."

#: ../Doc/library/socket.rst:688
msgid ":ref:`Availability <availability>`: Linux, FreeBSD, macOS."
msgstr ":ref:`Availability <availability>`: Linux, FreeBSD, macOS."

#: ../Doc/library/socket.rst:694
msgid "Functions"
msgstr "Funciones"

#: ../Doc/library/socket.rst:697
msgid "Creating sockets"
msgstr "Creación de sockets"

#: ../Doc/library/socket.rst:699
msgid ""
"The following functions all create :ref:`socket objects <socket-objects>`."
msgstr ""
"Todas las siguientes funciones crean :ref:`socket objects <socket-objects>`."

#: ../Doc/library/socket.rst:704
msgid ""
"Create a new socket using the given address family, socket type and protocol "
"number.  The address family should be :const:`AF_INET` (the default), :const:"
"`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, :const:`AF_PACKET`, or :const:"
"`AF_RDS`. The socket type should be :const:`SOCK_STREAM` (the default), :"
"const:`SOCK_DGRAM`, :const:`SOCK_RAW` or perhaps one of the other ``SOCK_`` "
"constants. The protocol number is usually zero and may be omitted or in the "
"case where the address family is :const:`AF_CAN` the protocol should be one "
"of :const:`CAN_RAW`, :const:`CAN_BCM`, :const:`CAN_ISOTP` or :const:"
"`CAN_J1939`."
msgstr ""
"Crear un nuevo socket usando la dirección de familia dada, tipo de socket y "
"el numero de protocolo. La dirección de familia debería ser :const:`AF_INET` "
"(por defecto), :const:`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, :const:"
"`AF_PACKET`, o :const:`AF_RDS`. El tipo de socket debería ser :const:"
"`SOCK_STREAM` (por defecto), :const:`SOCK_DGRAM`, :const:`SOCK_RAW` o quizás "
"una de las otras constantes ``SOCK_``. El numero de protocolo es usualmente "
"cero u omitirse o en el caso donde la familia de dirección es :const:"
"`AF_CAN` el protocolo debería ser uno de :const:`CAN_RAW`, :const:"
"`CAN_BCM`, :const:`CAN_ISOTP` o :const:`CAN_J1939`."

#: ../Doc/library/socket.rst:714
msgid ""
"If *fileno* is specified, the values for *family*, *type*, and *proto* are "
"auto-detected from the specified file descriptor.  Auto-detection can be "
"overruled by calling the function with explicit *family*, *type*, or *proto* "
"arguments.  This only affects how Python represents e.g. the return value "
"of :meth:`socket.getpeername` but not the actual OS resource.  Unlike :func:"
"`socket.fromfd`, *fileno* will return the same socket and not a duplicate. "
"This may help close a detached socket using :meth:`socket.close()`."
msgstr ""
"Si *fileno* esta especificado, el valor de *family*, *type*, y *proto* son "
"detectados automáticamente por el descriptor especificado de archivo. La "
"detección automática se puede anular llamado la función con los argumentos "
"explícitos *family*, *type*, o *proto*. Esto solamente afecta como Python "
"representa e.g. el valor de retorno de  :meth:`socket.getpeername` pero no "
"del recurso actual del OS. Diferente a  :func:`socket.fromfd`, *fileno* "
"retornara el mismo socket y no un duplicado. Esto puede ayudar a cerrar un "
"socket desconectado usando :meth:`socket.close()`."

#: ../Doc/library/socket.rst:723 ../Doc/library/socket.rst:869
#: ../Doc/library/socket.rst:1376 ../Doc/library/socket.rst:1470
msgid "The newly created socket is :ref:`non-inheritable <fd_inheritance>`."
msgstr "El socket recién creado es :ref:`non-inheritable <fd_inheritance>`."

#: ../Doc/library/socket.rst:734
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.__new__`` with arguments "
"``self``, ``family``, ``type``, ``protocol``."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.__new__`` con los "
"argumentos ``self``, ``family``, ``type``, ``protocol``."

#: ../Doc/library/socket.rst:727
msgid "The AF_CAN family was added. The AF_RDS family was added."
msgstr "Se añadió la familia AF_CAN. Se añadió la familia AF_RDS."

#: ../Doc/library/socket.rst:731
msgid "The CAN_BCM protocol was added."
msgstr "El protocolo CAN_BCM ha sido agregado."

#: ../Doc/library/socket.rst:734 ../Doc/library/socket.rst:871
msgid "The returned socket is now non-inheritable."
msgstr "Los sockets devueltos ahora no son heredables."

#: ../Doc/library/socket.rst:737
msgid "The CAN_ISOTP protocol was added."
msgstr "El protocolo CAN_ISOTP ha sido agregado."

#: ../Doc/library/socket.rst:740
msgid ""
"When :const:`SOCK_NONBLOCK` or :const:`SOCK_CLOEXEC` bit flags are applied "
"to *type* they are cleared, and :attr:`socket.type` will not reflect them.  "
"They are still passed to the underlying system ``socket()`` call.  Therefore,"
msgstr ""
"Cuando las banderas bit :const:`SOCK_NONBLOCK` or :const:`SOCK_CLOEXEC` "
"están aplicadas a *type*, se borran, y :attr:`socket.type` no las reflejará. "
"Igual se pasan a la llamada `socket ()` del sistema subyacente. Por lo tanto,"

#: ../Doc/library/socket.rst:752
msgid ""
"will still create a non-blocking socket on OSes that support "
"``SOCK_NONBLOCK``, but ``sock.type`` will be set to ``socket.SOCK_STREAM``."
msgstr ""
"seguirá creando un socket sin bloqueo en los sistemas operativos que admiten "
"``SOCK_NONBLOCK``, pero ``sock.type`` se establecerá en ``socket."
"SOCK_STREAM``."

#: ../Doc/library/socket.rst:756
msgid "The CAN_J1939 protocol was added."
msgstr "El protocolo CAN_J1939 ha sido agregado."

#: ../Doc/library/socket.rst:759
msgid "The IPPROTO_MPTCP protocol was added."
msgstr "Se agregó el protocolo IPPROTO_MPTCP."

#: ../Doc/library/socket.rst:764
msgid ""
"Build a pair of connected socket objects using the given address family, "
"socket type, and protocol number.  Address family, socket type, and protocol "
"number are as for the :func:`.socket` function above. The default family is :"
"const:`AF_UNIX` if defined on the platform; otherwise, the default is :const:"
"`AF_INET`."
msgstr ""
"Cree un par de objetos de socket conectados utilizando la familia de "
"direcciones, el tipo de socket y el número de protocolo especificados.  La "
"familia de direcciones, el tipo de socket y el número de protocolo son los "
"siguientes para la función :func:`.socket` anterior. La familia "
"predeterminada es :const:`AF_UNIX` si se define en la plataforma; de lo "
"contrario, el valor predeterminado es :const:`AF_INET`."

#: ../Doc/library/socket.rst:769
msgid "The newly created sockets are :ref:`non-inheritable <fd_inheritance>`."
msgstr ""
"Los sockets creados recientemente son :ref:`non-inheritable "
"<fd_inheritance>`."

#: ../Doc/library/socket.rst:771
msgid ""
"The returned socket objects now support the whole socket API, rather than a "
"subset."
msgstr ""
"Los objetos de socket devueltos ahora admiten toda la API de socket, en "
"lugar de un subconjunto."

#: ../Doc/library/socket.rst:775
msgid "The returned sockets are now non-inheritable."
msgstr "Los sockets devueltos ahora no son heredables."

#: ../Doc/library/socket.rst:778
msgid "Windows support added."
msgstr "Se ha agregado compatibilidad con Windows."

#: ../Doc/library/socket.rst:784
msgid ""
"Connect to a TCP service listening on the internet *address* (a 2-tuple "
"``(host, port)``), and return the socket object.  This is a higher-level "
"function than :meth:`socket.connect`: if *host* is a non-numeric hostname, "
"it will try to resolve it for both :data:`AF_INET` and :data:`AF_INET6`, and "
"then try to connect to all possible addresses in turn until a connection "
"succeeds.  This makes it easy to write clients that are compatible to both "
"IPv4 and IPv6."
msgstr ""
"Se conecta a un servicio TCP que esté escuchando en Internet *address* (un "
"``(host, port)`` de 2 tuplas) y retorna el objeto de socket. Esta es una "
"función de nivel superior que :meth:`socket.connect`: si *host* es un nombre "
"de host no numérico, intentará resolverlo para :data:`AF_INET` y :data:"
"`AF_INET6`, y luego intentará conectarse a todas las direcciones posibles "
"sucesivamente hasta que la conexión se realice correctamente. Esto facilita "
"la escritura de clientes que sean compatibles con IPv4 e IPv6."

#: ../Doc/library/socket.rst:792
msgid ""
"Passing the optional *timeout* parameter will set the timeout on the socket "
"instance before attempting to connect.  If no *timeout* is supplied, the "
"global default timeout setting returned by :func:`getdefaulttimeout` is used."
msgstr ""
"Pasando el parámetro opcional *timeout* establece el tiempo de espera dentro "
"de la instancia del socket. Si no es proporcionado *timeout*, la "
"configuración global de tiempo de espera predeterminada retornada por :func:"
"`getdefaulttimeout` es usada."

#: ../Doc/library/socket.rst:797
msgid ""
"If supplied, *source_address* must be a 2-tuple ``(host, port)`` for the "
"socket to bind to as its source address before connecting.  If host or port "
"are '' or 0 respectively the OS default behavior will be used."
msgstr ""
"Si se suministra, *source_address* debe ser una ''(host, puerto)'' de 2 "
"tuplas para que el socket se enlace como su dirección de origen antes de "
"conectarse.  Si el host o el puerto son '' o 0 respectivamente, se utilizará "
"el comportamiento predeterminado del sistema operativo."

#: ../Doc/library/socket.rst:801
msgid ""
"When a connection cannot be created, an exception is raised. By default, it "
"is the exception from the last address in the list. If *all_errors* is "
"``True``, it is an :exc:`ExceptionGroup` containing the errors of all "
"attempts."
msgstr ""
"Cuando una conexión no puede ser creada, se lanza una exception. Por "
"defecto, es la excepción de la última dirección en la lista. Si *all_errors* "
"es ``True``, es un :exc:`ExceptionGroup` conteniendo los errores de todos "
"los intentos."

#: ../Doc/library/socket.rst:806
msgid "*source_address* was added."
msgstr "*source_address* ha sido agregado."

#: ../Doc/library/socket.rst:809
msgid "*all_errors* was added."
msgstr "*all_errors* ha sido agregado."

#: ../Doc/library/socket.rst:815
msgid ""
"Convenience function which creates a TCP socket bound to *address* (a 2-"
"tuple ``(host, port)``) and returns the socket object."
msgstr ""
"Función conveniente que crea un socket TCP vinculado a *dirección* (un "
"``(host, puerto)`` de 2 tuplas) y devuelve el objeto del socket."

#: ../Doc/library/socket.rst:818
msgid ""
"*family* should be either :data:`AF_INET` or :data:`AF_INET6`. *backlog* is "
"the queue size passed to :meth:`socket.listen`; if not specified , a default "
"reasonable value is chosen. *reuse_port* dictates whether to set the :data:"
"`SO_REUSEPORT` socket option."
msgstr ""
"*familia* debe ser :data:`AF_INET` o :data:`AF_INET6`. *backlog* es el "
"tamaño de la cola pasado a :meth:`socket.listen`; cuando ``0`` se elige un "
"valor predeterminado razonable. *reuse_port* dicta si se debe establecer la "
"opción de socket :data:`SO_REUSEPORT`."

#: ../Doc/library/socket.rst:823
msgid ""
"If *dualstack_ipv6* is true and the platform supports it the socket will be "
"able to accept both IPv4 and IPv6 connections, else it will raise :exc:"
"`ValueError`. Most POSIX platforms and Windows are supposed to support this "
"functionality. When this functionality is enabled the address returned by :"
"meth:`socket.getpeername` when an IPv4 connection occurs will be an IPv6 "
"address represented as an IPv4-mapped IPv6 address. If *dualstack_ipv6* is "
"false it will explicitly disable this functionality on platforms that enable "
"it by default (e.g. Linux). This parameter can be used in conjunction with :"
"func:`has_dualstack_ipv6`:"
msgstr ""
"Si *dualstack_ipv6* es true y la plataforma lo admite el socket podrá "
"aceptar conexiones IPv4 e IPv6, de lo contrario lanzará :exc:`ValueError`. "
"Se supone que la mayoría de las plataformas POSIX y Windows admiten esta "
"funcionalidad. Cuando esta funcionalidad está habilitada, la dirección "
"devuelta por :meth:`socket.getpeername` cuando se produce una conexión IPv4 "
"será una dirección IPv6 representada como una dirección IPv4 asignada6. Si "
"*dualstack_ipv6* es false, deshabilitará explícitamente esta funcionalidad "
"en las plataformas que la habilitan de forma predeterminada (por ejemplo, "
"Linux). Este parámetro se puede utilizar junto con :func:"
"`has_dualstack_ipv6`:"

#: ../Doc/library/socket.rst:845
msgid ""
"On POSIX platforms the :data:`SO_REUSEADDR` socket option is set in order to "
"immediately reuse previous sockets which were bound on the same *address* "
"and remained in TIME_WAIT state."
msgstr ""
"En plataformas POSIX la opción del socket :data:`SO_REUSEADDR` está "
"configurado para inmediatamente rehusar los sockets previos que estaban "
"vinculados la misma *address* y permanecer en estado TIME_WAIT."

#: ../Doc/library/socket.rst:853
msgid ""
"Return ``True`` if the platform supports creating a TCP socket which can "
"handle both IPv4 and IPv6 connections."
msgstr ""
"Retorna ``True`` si la plataforma admite la creación de un socket TCP que "
"pueda manejar conexiones IPv4 e IPv6."

#: ../Doc/library/socket.rst:860
msgid ""
"Duplicate the file descriptor *fd* (an integer as returned by a file "
"object's :meth:`fileno` method) and build a socket object from the result.  "
"Address family, socket type and protocol number are as for the :func:`."
"socket` function above. The file descriptor should refer to a socket, but "
"this is not checked --- subsequent operations on the object may fail if the "
"file descriptor is invalid. This function is rarely needed, but can be used "
"to get or set socket options on a socket passed to a program as standard "
"input or output (such as a server started by the Unix inet daemon).  The "
"socket is assumed to be in blocking mode."
msgstr ""
"Duplica el descriptor de archivo *fd* (un entero retornado por el método :"
"meth:`fileno` de un objeto archivo) y crea un objeto socket a partir del "
"resultado.  La familia de direcciones, el tipo de socket y el número de "
"protocolo son como para la función :func:`.socket` anterior. El descriptor "
"de archivo debe hacer referencia a un socket, pero esto no se comprueba --- "
"las operaciones posteriores en el objeto pueden fallar si el descriptor de "
"archivo no es válido. Esta función rara vez se necesita, pero se puede usar "
"para obtener o establecer opciones de socket en un socket pasado a un "
"programa como entrada o salida estándar (como un servidor iniciado por el "
"demonio inet de Unix).  Se supone que el socket está en modo de bloqueo."

#: ../Doc/library/socket.rst:877
msgid ""
"Instantiate a socket from data obtained from the :meth:`socket.share` "
"method.  The socket is assumed to be in blocking mode."
msgstr ""
"Cree una instancia de un socket a partir de los datos obtenidos del método :"
"meth:`socket.share`.  Se supone que el socket está en modo de bloqueo."

#: ../Doc/library/socket.rst:887
msgid ""
"This is a Python type object that represents the socket object type. It is "
"the same as ``type(socket(...))``."
msgstr ""
"Este es un tipo de objeto Python que representa el tipo de objeto del "
"socket. Es lo mismo que decir ``type(socket(…))``."

#: ../Doc/library/socket.rst:892
msgid "Other functions"
msgstr "Otras funciones"

#: ../Doc/library/socket.rst:894
msgid "The :mod:`socket` module also offers various network-related services:"
msgstr ""
"El modulo :mod:`socket` también ofrece varios servicios de red relacionados:"

#: ../Doc/library/socket.rst:899
msgid ""
"Close a socket file descriptor. This is like :func:`os.close`, but for "
"sockets. On some platforms (most noticeable Windows) :func:`os.close` does "
"not work for socket file descriptors."
msgstr ""
"Cierre un descriptor de archivo de socket. Esto es como :func:`os.close`, "
"pero para sockets. En algunas plataformas (la mayoría notable de Windows) :"
"func:`os.close` no funciona para descriptores de archivos de socket."

#: ../Doc/library/socket.rst:907
msgid ""
"Translate the *host*/*port* argument into a sequence of 5-tuples that "
"contain all the necessary arguments for creating a socket connected to that "
"service. *host* is a domain name, a string representation of an IPv4/v6 "
"address or ``None``. *port* is a string service name such as ``'http'``, a "
"numeric port number or ``None``.  By passing ``None`` as the value of *host* "
"and *port*, you can pass ``NULL`` to the underlying C API."
msgstr ""
"Traduce el argumento *host*/*port* dentro de una secuencia de 5 tuplas que "
"contiene todo los argumentos necesarios para crear un socket conectado a ese "
"servicio. *host* es un nombre de dominio, una cadena en representación de "
"una dirección IPV4/IPV6 o ``None``. *port* es una nombre de una cadena de "
"servicio como ``'http'``, un numero de puerto numérico o ``None``. Pasando "
"``None`` como el valor del  *host* y *port*, pasando ``NULL`` a la API C "
"subyacente."

#: ../Doc/library/socket.rst:914
msgid ""
"The *family*, *type* and *proto* arguments can be optionally specified in "
"order to narrow the list of addresses returned.  Passing zero as a value for "
"each of these arguments selects the full range of results. The *flags* "
"argument can be one or several of the ``AI_*`` constants, and will influence "
"how results are computed and returned. For example, :const:`AI_NUMERICHOST` "
"will disable domain name resolution and will raise an error if *host* is a "
"domain name."
msgstr ""
"Los argumentos *family*, *type* y *proto* se puede especificar opcionalmente "
"para reducir la lista de direcciones retornadas. Pasando cero como un valor "
"para cada uno de estos argumentos se selecciona la gama completa de "
"resultados. El argumento *flags* puede ser uno o varios de los argumentos "
"``AI_*``, y pueden influenciar como los resultados son computados y "
"devueltos. Por ejemplo, :const:`AI_NUMERICHOST` desactivará la resolución de "
"nombres de dominio y lanzará un error sí *host* es un nombre de dominio."

#: ../Doc/library/socket.rst:922
msgid "The function returns a list of 5-tuples with the following structure:"
msgstr "La función devuelve una lista de 5 tuplas con la siguiente estructura:"

#: ../Doc/library/socket.rst:924
msgid "``(family, type, proto, canonname, sockaddr)``"
msgstr "``(family, type, proto, canonname, sockaddr)``"

#: ../Doc/library/socket.rst:926
msgid ""
"In these tuples, *family*, *type*, *proto* are all integers and are meant to "
"be passed to the :func:`.socket` function.  *canonname* will be a string "
"representing the canonical name of the *host* if :const:`AI_CANONNAME` is "
"part of the *flags* argument; else *canonname* will be empty.  *sockaddr* is "
"a tuple describing a socket address, whose format depends on the returned "
"*family* (a ``(address, port)`` 2-tuple for :const:`AF_INET`, a ``(address, "
"port, flowinfo, scope_id)`` 4-tuple for :const:`AF_INET6`), and is meant to "
"be passed to the :meth:`socket.connect` method."
msgstr ""
"En estas tuplas, *family*, *type*, *proto* son todos enteros y están "
"destinados a ser pasados por la función :func:`.socket`.  *canonname* debe "
"ser una cadena que representa el nombre canónico del *host* si :const:"
"`AI_CANONNAME` es parte de el argumento *flags*; de lo contrario *canonname* "
"estará vacía.  *sockaddr* es un tupla describiendo una dirección de socket, "
"cuyo formato depende del devuelto *family* (una ``(address, port)`` tupla de "
"2 para :const:`AF_INET`, una ``(address, port, flowinfo, scope_id)`` una "
"tupla de 4 para una :const:`AF_INET6`), y está destinado a ser pasado a el "
"método :meth:`socket.connect`."

#: ../Doc/library/socket.rst:945
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getaddrinfo`` with "
"arguments ``host``, ``port``, ``family``, ``type``, ``protocol``."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.getaddrinfo`` con los "
"argumentos ``host``, ``port``, ``family``, ``type``, ``protocol``."

#: ../Doc/library/socket.rst:938
msgid ""
"The following example fetches address information for a hypothetical TCP "
"connection to ``example.org`` on port 80 (results may differ on your system "
"if IPv6 isn't enabled)::"
msgstr ""
"En el ejemplo siguiente se obtiene información de dirección para una "
"conexión TCP hipotética a ``example.org`` en el puerto 80 (los resultados "
"pueden diferir en el sistema si IPv6 no está habilitado)::"

#: ../Doc/library/socket.rst:948
msgid "parameters can now be passed using keyword arguments."
msgstr ""
"los parámetros ahora se pueden pasar mediante argumentos de palabra clave."

#: ../Doc/library/socket.rst:951
#, python-format
msgid ""
"for IPv6 multicast addresses, string representing an address will not "
"contain ``%scope_id`` part."
msgstr ""
"para direcciones de multidifusión IPv6, la cadena que representa una "
"dirección no contendrá partes ``%scope_id``."

#: ../Doc/library/socket.rst:957
msgid ""
"Return a fully qualified domain name for *name*. If *name* is omitted or "
"empty, it is interpreted as the local host.  To find the fully qualified "
"name, the hostname returned by :func:`gethostbyaddr` is checked, followed by "
"aliases for the host, if available.  The first name which includes a period "
"is selected.  In case no fully qualified domain name is available and *name* "
"was provided, it is returned unchanged.  If *name* was empty or equal to "
"``'0.0.0.0'``, the hostname from :func:`gethostname` is returned."
msgstr ""
"Retorna un nombre de dominio completo para *name*. Si *name* se omite o está "
"vacío, se interpreta como el host local. Para encontrar el nombre completo, "
"se comprueba el nombre de host retornado por :func:`gethostbyaddr`, seguido "
"de los alias del host, si están disponibles. Se selecciona el primer nombre "
"que incluye un punto. En caso de que no haya disponible un nombre de dominio "
"completo y se haya proporcionado *name*, se retorna sin cambios. Si *name* "
"estaba vacío o era igual a ``'0.0.0.0'``, se retorna el nombre de host de :"
"func:`gethostname`."

#: ../Doc/library/socket.rst:968
msgid ""
"Translate a host name to IPv4 address format.  The IPv4 address is returned "
"as a string, such as  ``'100.50.200.5'``.  If the host name is an IPv4 "
"address itself it is returned unchanged.  See :func:`gethostbyname_ex` for a "
"more complete interface. :func:`gethostbyname` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"Traduce un nombre de host a un formato de dirección IPV4. La dirección IPV4 "
"es retornada como una cadena, como ``’100.50.200.5’``. Si el nombre de host "
"es una dirección IPV4 en sí, se devuelve sin cambios. Observa :func:"
"`gethostbyname_ex` para una interfaz mas completa. :func:`gethostbyname` no "
"soporta la resolución de nombres IPV6, y :func:`getaddrinfo` debe utilizarse "
"en su lugar para compatibilidad con doble pila IPv4/v6."

#: ../Doc/library/socket.rst:983 ../Doc/library/socket.rst:999
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyname`` with "
"argument ``hostname``."
msgstr ""
"Genera un evento :ref:`auditing <auditing>` ``socket.gethostbyname`` con el "
"argumento ``hostname``."

#: ../Doc/library/socket.rst:976 ../Doc/library/socket.rst:992
#: ../Doc/library/socket.rst:1005 ../Doc/library/socket.rst:1020
#: ../Doc/library/socket.rst:1037 ../Doc/library/socket.rst:1048
#: ../Doc/library/socket.rst:1059 ../Doc/library/socket.rst:1070
#: ../Doc/library/socket.rst:1394 ../Doc/library/socket.rst:1441
#: ../Doc/library/socket.rst:1455 ../Doc/library/socket.rst:1475
#: ../Doc/library/socket.rst:1522 ../Doc/library/socket.rst:1567
#: ../Doc/library/socket.rst:1949 ../Doc/library/socket.rst:1959
msgid ":ref:`Availability <availability>`: not WASI."
msgstr ":ref:`Availability <availability>`: no WASI."

#: ../Doc/library/socket.rst:981
msgid ""
"Translate a host name to IPv4 address format, extended interface. Return a 3-"
"tuple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is the host's "
"primary host name, *aliaslist* is a (possibly empty) list of alternative "
"host names for the same address, and *ipaddrlist* is a list of IPv4 "
"addresses for the same interface on the same host (often but not always a "
"single address). :func:`gethostbyname_ex` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"Traducir un nombre de host a IPv4, formato de dirección de interfaz "
"extendida. Devuelve una tupla de 3 elementos ``(hostname, aliaslist, "
"ipaddrlist)`` donde *hostname* es el nombre de host principal del host, "
"*aliaslist* es una lista (posiblemente vacía) de nombres de host "
"alternativos para la misma dirección y *ipaddrlist* es una lista de "
"direcciones IPv4 para la misma interfaz en el mismo host (a menudo, pero no "
"siempre, una única dirección). :func:`gethostbyname_ex` no admite la "
"resolución de nombres IPv6 y :func:`getaddrinfo` debe usarse en su lugar "
"para la compatibilidad con doble pila IPv4/v6."

#: ../Doc/library/socket.rst:997
msgid ""
"Return a string containing the hostname of the machine where  the Python "
"interpreter is currently executing."
msgstr ""
"Retorna una cadena que contenga el nombre de host de la máquina donde se "
"está ejecutando actualmente el intérprete de Python."

#: ../Doc/library/socket.rst:1009
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostname`` with no "
"arguments."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.gethostname`` sin "
"argumentos."

#: ../Doc/library/socket.rst:1002
msgid ""
"Note: :func:`gethostname` doesn't always return the fully qualified domain "
"name; use :func:`getfqdn` for that."
msgstr ""
"Nota: :func:`gethostname` no siempre retorna el nombre de dominio completo, "
"usa :func:`getfqdn` para eso."

#: ../Doc/library/socket.rst:1010
msgid ""
"Return a 3-tuple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is "
"the primary host name responding to the given *ip_address*, *aliaslist* is a "
"(possibly empty) list of alternative host names for the same address, and "
"*ipaddrlist* is a list of IPv4/v6 addresses for the same interface on the "
"same host (most likely containing only a single address). To find the fully "
"qualified domain name, use the function :func:`getfqdn`. :func:"
"`gethostbyaddr` supports both IPv4 and IPv6."
msgstr ""
"Devuelve una tupla de 3 elementos ``(nombre de host, lista de alias, lista "
"de ipaddr)`` donde *nombre de host* es el nombre de host principal que "
"responde a la *dirección_ip* dada, *lista de alias* es una lista "
"(posiblemente vacía) de nombres de host alternativos para el mismo "
"dirección, y *ipaddrlist* es una lista de direcciones IPv4/v6 para la misma "
"interfaz en el mismo host (lo más probable es que contenga solo una "
"dirección). Para encontrar el nombre de dominio completo, utilice la "
"función :func:`getfqdn`. :func:`gethostbyaddr` admite tanto IPv4 como IPv6."

#: ../Doc/library/socket.rst:1027
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyaddr`` with "
"argument ``ip_address``."
msgstr ""
"Generar un :ref:`auditing event <auditing>` ``socket.gethostbyaddr`` con los "
"argumentos ``ip_address``."

#: ../Doc/library/socket.rst:1025
msgid ""
"Translate a socket address *sockaddr* into a 2-tuple ``(host, port)``. "
"Depending on the settings of *flags*, the result can contain a fully "
"qualified domain name or numeric address representation in *host*.  "
"Similarly, *port* can contain a string port name or a numeric port number."
msgstr ""
"Traduce una dirección de socket  *sockaddr* en una 2-tupla ``(host, port)``. "
"Dependiendo de la configuraciones de *flags*, el resultado puede contener un "
"nombre de dominio completo o una representación numérica de la dirección en "
"*host*. De igual manera, *port* puede contener un nombre de puerto de cadena "
"de caracteres o un numero de puerto numérico."

#: ../Doc/library/socket.rst:1030
#, python-format
msgid ""
"For IPv6 addresses, ``%scope_id`` is appended to the host part if *sockaddr* "
"contains meaningful *scope_id*. Usually this happens for multicast addresses."
msgstr ""
"Para las direcciones IPv6, ``%scope`` se anexa a la parte del host si "
"*sockaddr* contiene *scopeid* significativo. Generalmente esto sucede para "
"las direcciones de multidifusión."

#: ../Doc/library/socket.rst:1033
msgid ""
"For more information about *flags* you can consult :manpage:`getnameinfo(3)`."
msgstr ""
"Para mas información sobre *flags* pueden consultar :manpage:"
"`getnameinfo(3)`."

#: ../Doc/library/socket.rst:1044
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getnameinfo`` with "
"argument ``sockaddr``."
msgstr ""
"Plantea un :ref:`auditing event <auditing>` ``socket.getnameinfo`` con el "
"argumento ``sockaddr``."

#: ../Doc/library/socket.rst:1042
msgid ""
"Translate an internet protocol name (for example, ``'icmp'``) to a constant "
"suitable for passing as the (optional) third argument to the :func:`.socket` "
"function.  This is usually only needed for sockets opened in \"raw\" mode (:"
"const:`SOCK_RAW`); for the normal socket modes, the correct protocol is "
"chosen automatically if the protocol is omitted or zero."
msgstr ""
"Traduzca un nombre de protocolo de Internet (por ejemplo, ``'icmp'``) a una "
"constante adecuada para pasar como tercer argumento (opcional) a la función :"
"func:`.socket`. Esto normalmente solo es necesario para sockets abiertos en "
"modo \"raw\" (:const:`SOCK_RAW`); para los modos de conexión normales, el "
"protocolo correcto se elige automáticamente si el protocolo se omite o se "
"pone a cero."

#: ../Doc/library/socket.rst:1053
msgid ""
"Translate an internet service name and protocol name to a port number for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""
"Traduzca un nombre de servicio de Internet y un nombre de protocolo a un "
"número de puerto para ese servicio. El nombre de protocolo opcional, si se "
"proporciona, debe ser ``'tcp'`` o ``'udp'``; de lo contrario, cualquier "
"protocolo coincidirá."

#: ../Doc/library/socket.rst:1066
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyname`` with "
"arguments ``servicename``, ``protocolname``."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.getservbyname`` con los "
"argumentos ``servicename``, ``protocolname``."

#: ../Doc/library/socket.rst:1064
msgid ""
"Translate an internet port number and protocol name to a service name for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""
"Traduzca un número de puerto de Internet y un nombre de protocolo a un "
"nombre de servicio para ese servicio. El nombre de protocolo opcional, si se "
"proporciona, debe ser ``'tcp'`` o ``'udp'``; de lo contrario, cualquier "
"protocolo coincidirá."

#: ../Doc/library/socket.rst:1077
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyport`` with "
"arguments ``port``, ``protocolname``."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.getservbyport`` con los "
"argumentos ``port``, ``protocolname``."

#: ../Doc/library/socket.rst:1075
msgid ""
"Convert 32-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"Convierta enteros positivos de 32 bits de red a orden de bytes de host.  En "
"equipos donde el orden de bytes de host es el mismo que el orden de bytes de "
"red, se trata de un no-op; de lo contrario, realiza una operación de "
"intercambio de 4 bytes."

#: ../Doc/library/socket.rst:1082
msgid ""
"Convert 16-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"Convierta enteros positivos de 16 bits de red a orden de bytes de host.  En "
"equipos donde el orden de bytes de host es el mismo que el orden de bytes de "
"red, se trata de un no-op; de lo contrario, realiza una operación de "
"intercambio de 2 bytes."

#: ../Doc/library/socket.rst:1086 ../Doc/library/socket.rst:1104
msgid ""
"Raises :exc:`OverflowError` if *x* does not fit in a 16-bit unsigned integer."
msgstr ""
"Lanza :exc:`OverflowError` si *x* no cabe en un entero sin signo de 16 bits."

#: ../Doc/library/socket.rst:1093
msgid ""
"Convert 32-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"Convierta enteros positivos de 32 bits del host al orden de bytes de red.  "
"En equipos donde el orden de bytes de host es el mismo que el orden de bytes "
"de red, se trata de un no-op; de lo contrario, realiza una operación de "
"intercambio de 4 bytes."

#: ../Doc/library/socket.rst:1100
msgid ""
"Convert 16-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"Convierta enteros positivos de 16 bits del host al orden de bytes de red.  "
"En equipos donde el orden de bytes de host es el mismo que el orden de bytes "
"de red, se trata de un no-op; de lo contrario, realiza una operación de "
"intercambio de 2 bytes."

#: ../Doc/library/socket.rst:1111
msgid ""
"Convert an IPv4 address from dotted-quad string format (for example, "
"'123.45.67.89') to 32-bit packed binary format, as a bytes object four "
"characters in length.  This is useful when conversing with a program that "
"uses the standard C library and needs objects of type :c:struct:`in_addr`, "
"which is the C type for the 32-bit packed binary this function returns."
msgstr ""
"Convierte una dirección IPv4 desde el formato de cadena de cuatro puntos "
"(por ejemplo, ‘123.45.67.89’) a formato binario empaquetado de 32 bits, como "
"un objeto de bytes de cuatro caracteres de longitud. Esto es útil cuando se "
"convierte con un programa que usa la librería estándar C y necesita objetos "
"de tipo :c:struct:`in_addr`, que es el tipo C para el binario empaquetado de "
"32 bits que devuelve esta función."

#: ../Doc/library/socket.rst:1117
msgid ""
":func:`inet_aton` also accepts strings with less than three dots; see the "
"Unix manual page :manpage:`inet(3)` for details."
msgstr ""
"Ademas :func:`inet_aton`acepta cadena de caracteres con menos de tres "
"puntos, observar la pagina del manual Unix :manpage:`inet(3)` para mas "
"detalles."

#: ../Doc/library/socket.rst:1120
msgid ""
"If the IPv4 address string passed to this function is invalid, :exc:"
"`OSError` will be raised. Note that exactly what is valid depends on the "
"underlying C implementation of :c:func:`inet_aton`."
msgstr ""
"Si la cadena de dirección IPv4 es pasada a esta función es invalido, :exc:"
"`OSError` se lanzará. Tenga en cuenta que exactamente lo que es valido "
"depende de la implementación C de :c:func:`inet_aton`."

#: ../Doc/library/socket.rst:1124
msgid ""
":func:`inet_aton` does not support IPv6, and :func:`inet_pton` should be "
"used instead for IPv4/v6 dual stack support."
msgstr ""
":func:`inet_aton` no admite IPV6, y :func:`inet_pton` deberían utilizarse en "
"su lugar para compatibilidad con doble pilas IPV4/v6."

#: ../Doc/library/socket.rst:1130
msgid ""
"Convert a 32-bit packed IPv4 address (a :term:`bytes-like object` four bytes "
"in length) to its standard dotted-quad string representation (for example, "
"'123.45.67.89').  This is useful when conversing with a program that uses "
"the standard C library and needs objects of type :c:struct:`in_addr`, which "
"is the C type for the 32-bit packed binary data this function takes as an "
"argument."
msgstr ""
"Convierte una dirección IPv4 empaquetada de 32 bits (un :term:`bytes-like "
"object` cuatro bytes de longitud) a su representación estándar de cadena de "
"cuatro puntos (por ejemplo ‘123.45.67.89’). Esto es útil cuando convertimos "
"con un programa que usa la librería estándar C y necesita objetos de tipo :c:"
"struct:`in_addr`, que es el tipo C para los datos binarios empaquetados de "
"32 bits que esta función toma como argumento."

#: ../Doc/library/socket.rst:1137
msgid ""
"If the byte sequence passed to this function is not exactly 4 bytes in "
"length, :exc:`OSError` will be raised. :func:`inet_ntoa` does not support "
"IPv6, and :func:`inet_ntop` should be used instead for IPv4/v6 dual stack "
"support."
msgstr ""
"Si la secuencia de byte pasada a esta función no es exactamente 4 bytes de "
"longitud  :exc:`OSError` podría generarse :func:`inet_ntoa` no soporta IPV6, "
"y :func:`inet_ntop` debe utilizarse en su lugar para compatibilidad con "
"doble pila IPv4 / v6."

#: ../Doc/library/socket.rst:1148
msgid ""
"Convert an IP address from its family-specific string format to a packed, "
"binary format. :func:`inet_pton` is useful when a library or network "
"protocol calls for an object of type :c:struct:`in_addr` (similar to :func:"
"`inet_aton`) or :c:struct:`in6_addr`."
msgstr ""
"Convierte una dirección IP desde su formato de cadena específico de la "
"familia a un formato binario empaquetado. :func:`inet_pton` es útil cuando "
"una librería o protocolo de red llama desde un objeto de tipo :c:struct:"
"`in_addr` (similar a :func:`inet_aton`) o :c:struct:`in6_addr`."

#: ../Doc/library/socket.rst:1153
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and :"
"const:`AF_INET6`. If the IP address string *ip_string* is invalid, :exc:"
"`OSError` will be raised. Note that exactly what is valid depends on both "
"the value of *address_family* and the underlying implementation of :c:func:"
"`inet_pton`."
msgstr ""
"Los Valores soportados para *address_family* son actualmente :const:"
"`AF_INET` y :const:`AF_INET6`. Si la cadena de dirección IP *ip_string* no "
"es válida, :exc:`OSError` se genera. Tenga en cuenta que exactamente lo que "
"es válido depende tanto del valor de *address_family* como de la "
"implementación subyacente de :c:func:`inet_pton`."

#: ../Doc/library/socket.rst:1159 ../Doc/library/socket.rst:1179
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`Availability <availability>`: Unix, Windows."

#: ../Doc/library/socket.rst:1161 ../Doc/library/socket.rst:1181
msgid "Windows support added"
msgstr "Se ha añadido compatibilidad con Windows"

#: ../Doc/library/socket.rst:1167
msgid ""
"Convert a packed IP address (a :term:`bytes-like object` of some number of "
"bytes) to its standard, family-specific string representation (for example, "
"``'7.10.0.5'`` or ``'5aef:2b::8'``). :func:`inet_ntop` is useful when a "
"library or network protocol returns an object of type :c:struct:`in_addr` "
"(similar to :func:`inet_ntoa`) or :c:struct:`in6_addr`."
msgstr ""
"Convierte una dirección IP empaquetada (un :term:`bytes-like object` de "
"algún numero de bytes) a su representación estándar de cadena específica de "
"la familia (por ejemplo ``’7.10.0.5’`` o ``’5aef:2b::8’``). :func:"
"`inet_ntop` es útil cuando una librería o protocolo de red retorna un objeto "
"de tipo :c:struct:`in_addr` (similar para :func:`inet_ntoa`) o :c:struct:"
"`in6_addr`."

#: ../Doc/library/socket.rst:1174
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and :"
"const:`AF_INET6`. If the bytes object *packed_ip* is not the correct length "
"for the specified address family, :exc:`ValueError` will be raised. :exc:"
"`OSError` is raised for errors from the call to :func:`inet_ntop`."
msgstr ""
"Los valores soportados para *address_family* actualmente son :const:"
"`AF_INET` y :const:`AF_INET6`. Si los objetos de bytes *packed_ip* no tienen "
"la longitud correcta para la familia de direcciones especificas, :exc:"
"`ValueError` podría generarse. :exc:`OSError` se genera para errores desde "
"la llamada a :func:`inet_ntop`."

#: ../Doc/library/socket.rst:1196
msgid ""
"Return the total length, without trailing padding, of an ancillary data item "
"with associated data of the given *length*.  This value can often be used as "
"the buffer size for :meth:`~socket.recvmsg` to receive a single item of "
"ancillary data, but :rfc:`3542` requires portable applications to use :func:"
"`CMSG_SPACE` and thus include space for padding, even when the item will be "
"the last in the buffer.  Raises :exc:`OverflowError` if *length* is outside "
"the permissible range of values."
msgstr ""
"Retorna la longitud total, sin relleno de arrastre, de un elemento de datos "
"auxiliares con datos asociados del *length*. Este valor se puede utilizar a "
"menudo como tamaño de búfer para :meth:`~socket.recvmsg` para recibir un "
"solo valor de datos auxiliares, pero :rfc:`3542` requiere aplicaciones "
"portables para usar :func:`CMSG_SPACE` y así incluir espacio para el "
"relleno, incluso cuando el elemento será el último en el búfer. Genera  :exc:"
"`OverflowError` si *length* está fuera del rango de valores permitido."

#: ../Doc/library/socket.rst:1205 ../Doc/library/socket.rst:1228
msgid ":ref:`Availability <availability>`: Unix, not Emscripten, not WASI."
msgstr ":ref:`Availability <availability>`: Unix, no escritos, no WASI."

#: ../Doc/library/socket.rst:1207 ../Doc/library/socket.rst:1697
#: ../Doc/library/socket.rst:1741 ../Doc/library/socket.rst:1849
msgid "Most Unix platforms."
msgstr "La mayoría de las plataformas Unix."

#: ../Doc/library/socket.rst:1214
msgid ""
"Return the buffer size needed for :meth:`~socket.recvmsg` to receive an "
"ancillary data item with associated data of the given *length*, along with "
"any trailing padding.  The buffer space needed to receive multiple items is "
"the sum of the :func:`CMSG_SPACE` values for their associated data lengths.  "
"Raises :exc:`OverflowError` if *length* is outside the permissible range of "
"values."
msgstr ""
"Retorna el tamaño del buffer necesario por :meth:`~socket.recvmsg` para "
"recibir un elemento de datos auxiliares con datos asociados del *length* "
"dado, junto con cualquier relleno final. El espacio de buffer necesario para "
"recibir múltiples elementos es la suma de los valores de :func:`CMSG_SPACE` "
"para los datos asociados con la longitudes. Genera :exc:`OverflowError` si "
"*length* está fuera del rango de valores permitido."

#: ../Doc/library/socket.rst:1222
msgid ""
"Note that some systems might support ancillary data without providing this "
"function.  Also note that setting the buffer size using the results of this "
"function may not precisely limit the amount of ancillary data that can be "
"received, since additional data may be able to fit into the padding area."
msgstr ""
"Tenga en cuenta que algunos sistemas pueden admitir datos auxiliares sin "
"proporcionar esta función.  Tenga en cuenta también que establecer el tamaño "
"del búfer utilizando los resultados de esta función puede no limitar con "
"precisión la cantidad de datos auxiliares que se pueden recibir, ya que los "
"datos adicionales pueden caber en el área de relleno."

#: ../Doc/library/socket.rst:1230
msgid "most Unix platforms."
msgstr "la mayoría de las plataformas Unix."

#: ../Doc/library/socket.rst:1237
msgid ""
"Return the default timeout in seconds (float) for new socket objects. A "
"value of ``None`` indicates that new socket objects have no timeout. When "
"the socket module is first imported, the default is ``None``."
msgstr ""
"Retorna el tiempo de espera por defecto en segundos (flotante) para los "
"objetos de un nuevo socket. Un valor de ``None`` indicada que los objetos "
"del nuevo socket no tiene un tiempo de espera. Cuando el modulo socket es "
"importado primero, por defecto es ``None``."

#: ../Doc/library/socket.rst:1244
msgid ""
"Set the default timeout in seconds (float) for new socket objects.  When the "
"socket module is first imported, the default is ``None``.  See :meth:"
"`~socket.settimeout` for possible values and their respective meanings."
msgstr ""
"Selecciona el tiempo de espera por defecto en segundos (flotante ) para los "
"objetos nuevos del socket. Cuando el modulo socket es importado primero, el "
"valor por defecto es ``None``. Observar :meth:`~socket.settimeout` para "
"posible valores y sus respectivos significados."

#: ../Doc/library/socket.rst:1252
msgid ""
"Set the machine's hostname to *name*.  This will raise an :exc:`OSError` if "
"you don't have enough rights."
msgstr ""
"Establece el nombre de host de la maquina en *name*. Esto genera un  :exc:"
"`OSError` si no tiene suficientes derechos."

#: ../Doc/library/socket.rst:1264
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sethostname`` with "
"argument ``name``."
msgstr ""
"Plantea un :ref:`auditing event <auditing>` ``socket.sethostname`` con el "
"argumento ``name``."

#: ../Doc/library/socket.rst:1257 ../Doc/library/socket.rst:1695
#: ../Doc/library/socket.rst:1739
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`Availability <availability>`: Unix."

#: ../Doc/library/socket.rst:1264
msgid ""
"Return a list of network interface information (index int, name string) "
"tuples. :exc:`OSError` if the system call fails."
msgstr ""
"Retorna una lista de tuplas de información de interfaz de red (índice int, "
"cadena de nombre). :exc:`OSError` si se produce un error en la llamada del "
"sistema."

#: ../Doc/library/socket.rst:1268 ../Doc/library/socket.rst:1295
#: ../Doc/library/socket.rst:1312 ../Doc/library/socket.rst:1329
#: ../Doc/library/socket.rst:1343
msgid ""
":ref:`Availability <availability>`: Unix, Windows, not Emscripten, not WASI."
msgstr ""
":ref:`Availability <availability>`: Unix, Windows, no Escritos, no WASI."

#: ../Doc/library/socket.rst:1272 ../Doc/library/socket.rst:1299
#: ../Doc/library/socket.rst:1316
msgid "Windows support was added."
msgstr "Se ha agregado compatibilidad con Windows."

#: ../Doc/library/socket.rst:1277
msgid ""
"On Windows network interfaces have different names in different contexts "
"(all names are examples):"
msgstr ""
"En Windows las interfaces de redes tienen diferentes nombres en diferentes "
"contextos (todos los nombres son ejemplos):"

#: ../Doc/library/socket.rst:1280
msgid "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"
msgstr "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"

#: ../Doc/library/socket.rst:1281
msgid "name: ``ethernet_32770``"
msgstr "nombre: ``ethernet_32770``"

#: ../Doc/library/socket.rst:1282
msgid "friendly name: ``vEthernet (nat)``"
msgstr "nombre amigable: ``vEthernet (nat)``"

#: ../Doc/library/socket.rst:1283
msgid "description: ``Hyper-V Virtual Ethernet Adapter``"
msgstr "descripción: ``Hyper-V Virtual Ethernet Adapter``"

#: ../Doc/library/socket.rst:1285
msgid ""
"This function returns names of the second form from the list, "
"``ethernet_32770`` in this example case."
msgstr ""
"Esta función retorna los nombres del segundo formulario de la lista, en este "
"caso de ejemplo ``ethernet_32770``."

#: ../Doc/library/socket.rst:1291
msgid ""
"Return a network interface index number corresponding to an interface name. :"
"exc:`OSError` if no interface with the given name exists."
msgstr ""
"Retorna un número de índice de interfaz de red correspondiente a un nombre "
"de interfaz. :exc:`OSError` si no existe ninguna interfaz con el nombre "
"especificado."

#: ../Doc/library/socket.rst:1303 ../Doc/library/socket.rst:1320
msgid "\"Interface name\" is a name as documented in :func:`if_nameindex`."
msgstr ""
"“\\”Interface name\\” es un nombre como se documenta en :func:`if_nameindex`."

#: ../Doc/library/socket.rst:1308
msgid ""
"Return a network interface name corresponding to an interface index number. :"
"exc:`OSError` if no interface with the given index exists."
msgstr ""
"Retorna un nombre de interfaz de red correspondiente a un número de índice "
"de interfaz. :exc:`OSError` si no existe ninguna interfaz con el índice dado."

#: ../Doc/library/socket.rst:1325
msgid ""
"Send the list of file descriptors *fds* over an :const:`AF_UNIX` socket "
"*sock*. The *fds* parameter is a sequence of file descriptors. Consult :meth:"
"`sendmsg` for the documentation of these parameters."
msgstr ""
"Envíe la lista de descriptores de archivo *fds* a través de un conector :"
"const:`AF_UNIX` *sock*. El parámetro *fds* es una secuencia de descriptores "
"de archivo. Consulte :meth:`sendmsg` para obtener la documentación de estos "
"parámetros."

#: ../Doc/library/socket.rst:1331 ../Doc/library/socket.rst:1345
msgid ""
"Unix platforms supporting :meth:`~socket.sendmsg` and :const:`SCM_RIGHTS` "
"mechanism."
msgstr ""
"Plataformas Unix que soporten :meth:`~socket.sendmsg` y el mecanismo :const:"
"`SCM_RIGHTS`."

#: ../Doc/library/socket.rst:1339
msgid ""
"Receive up to *maxfds* file descriptors from an :const:`AF_UNIX` socket "
"*sock*. Return ``(msg, list(fds), flags, addr)``. Consult :meth:`recvmsg` "
"for the documentation of these parameters."
msgstr ""
"Reciba descriptores de archivo hasta *maxfds* desde un socket :const:"
"`AF_UNIX` *sock*. Retorna ``(msg, list(fds), flags, addr)``. Consulte :meth:"
"`recvmsg` para obtener la documentación de estos parámetros."

#: ../Doc/library/socket.rst:1352
msgid "Any truncated integers at the end of the list of file descriptors."
msgstr ""
"Cualquier número entero truncado al final de la lista de descriptores de "
"archivo."

#: ../Doc/library/socket.rst:1358
msgid "Socket Objects"
msgstr "Objetos Socket"

#: ../Doc/library/socket.rst:1360
msgid ""
"Socket objects have the following methods.  Except for :meth:`~socket."
"makefile`, these correspond to Unix system calls applicable to sockets."
msgstr ""
"Los objetos socket tienen los siguientes métodos. Excepto para :meth:"
"`~socket.makefile`, esto corresponde al sistema de llamadas Unix para "
"sockets."

#: ../Doc/library/socket.rst:1364
msgid ""
"Support for the :term:`context manager` protocol was added.  Exiting the "
"context manager is equivalent to calling :meth:`~socket.close`."
msgstr ""
"El soporte para el protocolo :term:`context manager` ha sido agregado. Salir "
"del gestor de contexto es equivalente para el llamado :meth:`~socket.close`."

#: ../Doc/library/socket.rst:1371
msgid ""
"Accept a connection. The socket must be bound to an address and listening "
"for connections. The return value is a pair ``(conn, address)`` where *conn* "
"is a *new* socket object usable to send and receive data on the connection, "
"and *address* is the address bound to the socket on the other end of the "
"connection."
msgstr ""
"Acepta una conexión. El socket debe estar vinculado a una dirección y estar "
"escuchando las conexiones. El valor de retorno es el par ``(conn, address)`` "
"cuando *conn* es un *new* objeto socket usado para enviar y recibir "
"información en la conexión, y *address* es la dirección vinculada al socket "
"en el extremo de la conexión."

#: ../Doc/library/socket.rst:1378 ../Doc/library/socket.rst:1472
msgid "The socket is now non-inheritable."
msgstr "El socket ahora no es heredable."

#: ../Doc/library/socket.rst:1381 ../Doc/library/socket.rst:1610
#: ../Doc/library/socket.rst:1624 ../Doc/library/socket.rst:1701
#: ../Doc/library/socket.rst:1774 ../Doc/library/socket.rst:1793
#: ../Doc/library/socket.rst:1810 ../Doc/library/socket.rst:1855
msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the method now retries the system call instead of raising an :exc:"
"`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"Si se interrumpe la llamada del sistema y el controlador de señal no genera "
"una excepción, el método ahora vuelve a intentar la llamada del sistema en "
"lugar de generar una excepción :exc:`InterruptedError` (consulte :pep:`475` "
"para la lógica)."

#: ../Doc/library/socket.rst:1389
msgid ""
"Bind the socket to *address*.  The socket must not already be bound. (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"Enlaza el socket a *address*. El socket no debe estar ya unido. (El formato "
"de *address* depende de la familia de direcciones, consulte más arriba)."

#: ../Doc/library/socket.rst:1401
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.bind`` with arguments "
"``self``, ``address``."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.getaddrinfo`` con los "
"argumentos ``host``, ``port``, ``family``, ``type``, ``protocol``."

#: ../Doc/library/socket.rst:1399
msgid ""
"Mark the socket closed.  The underlying system resource (e.g. a file "
"descriptor) is also closed when all file objects from :meth:`makefile()` are "
"closed.  Once that happens, all future operations on the socket object will "
"fail. The remote end will receive no more data (after queued data is "
"flushed)."
msgstr ""
"Marca el socket cerrado. El recurso del sistema subyacente (ej. un "
"descriptor de archivo) también se cierra cuando todos los objetos de archivo "
"de :meth:`makefile()` están cerrados. Una vez que eso suceda, todas las "
"operaciones futuras en el objeto socket fallarán. El extremo remoto no "
"recibirá más datos (después de que se vacíen los datos en cola)."

#: ../Doc/library/socket.rst:1405
msgid ""
"Sockets are automatically closed when they are garbage-collected, but it is "
"recommended to :meth:`close` them explicitly, or to use a :keyword:`with` "
"statement around them."
msgstr ""
"Los sockets se cierran automáticamente cuando se recogen basura, pero se "
"recomienda :meth:`cerrarlos` explícitamente, o usar una instrucción :keyword:"
"`with` alrededor de ellos."

#: ../Doc/library/socket.rst:1409
msgid ""
":exc:`OSError` is now raised if an error occurs when the underlying :c:func:"
"`close` call is made."
msgstr ""
":exc:`OSError` ahora se lanza si se produce un error cuando se realiza la "
"llamada :c:func:`close` subyacente."

#: ../Doc/library/socket.rst:1415
msgid ""
":meth:`close()` releases the resource associated with a connection but does "
"not necessarily close the connection immediately.  If you want to close the "
"connection in a timely fashion, call :meth:`shutdown()` before :meth:"
"`close()`."
msgstr ""
":meth:`close()` libera el recurso asociado a una conexión, pero no "
"necesariamente cierra la conexión inmediatamente.  Si desea cerrar la "
"conexión a tiempo, llame a :meth:`shutdown()` antes de :meth:`close()`."

#: ../Doc/library/socket.rst:1423
msgid ""
"Connect to a remote socket at *address*. (The format of *address* depends on "
"the address family --- see above.)"
msgstr ""
"Conectar a un socket remoto en *address*. (El formato de *address* depende "
"de la familia de direcciones --- ver arriba.)"

#: ../Doc/library/socket.rst:1426
msgid ""
"If the connection is interrupted by a signal, the method waits until the "
"connection completes, or raise a :exc:`TimeoutError` on timeout, if the "
"signal handler doesn't raise an exception and the socket is blocking or has "
"a timeout. For non-blocking sockets, the method raises an :exc:"
"`InterruptedError` exception if the connection is interrupted by a signal "
"(or the exception raised by the signal handler)."
msgstr ""
"Si la conexión es interrumpida por una señal, el método espera hasta que se "
"complete la conexión, o lanza un :exc:`TimeoutError` en el tiempo de espera, "
"si el manejador de señales no lanza una excepción y el socket se bloquea o "
"tiene un tiempo de espera. Para sockets sin bloqueo, el método lanza una "
"excepción :exc:`InterruptedError` si la conexión es interrumpida por una "
"señal (o la excepción lanzada por el manejador de señales)."

#: ../Doc/library/socket.rst:1442 ../Doc/library/socket.rst:1462
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.connect`` with arguments "
"``self``, ``address``."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.connect`` con los "
"argumentos ``self``, ``address``."

#: ../Doc/library/socket.rst:1435
msgid ""
"The method now waits until the connection completes instead of raising an :"
"exc:`InterruptedError` exception if the connection is interrupted by a "
"signal, the signal handler doesn't raise an exception and the socket is "
"blocking or has a timeout (see the :pep:`475` for the rationale)."
msgstr ""
"El método ahora espera hasta que se completa la conexión en lugar de generar "
"una excepción :exc:`InterruptedError` si la conexión se interrumpe por una "
"señal, el controlador de señal no genera una excepción y el socket está "
"bloqueando o tiene un tiempo de espera (consulte el :pep:`475` para la razón "
"de ser)."

#: ../Doc/library/socket.rst:1446
msgid ""
"Like ``connect(address)``, but return an error indicator instead of raising "
"an exception for errors returned by the C-level :c:func:`connect` call "
"(other problems, such as \"host not found,\" can still raise exceptions).  "
"The error indicator is ``0`` if the operation succeeded, otherwise the value "
"of the :c:data:`errno` variable.  This is useful to support, for example, "
"asynchronous connects."
msgstr ""
"Similar a ``connect(address)``, pero retorna un indicador de error en lugar "
"de generar una excepción para los errores retornados por la llamada de nivel "
"C :c:func:`connect` (otros problemas, como “host no encontrado”, aún pueden "
"generar excepciones). El indicador de error es ``0`` si la operación tuvo "
"éxito, caso contrario es el valor de la variable :c:data:`errno`. Esto es "
"útil para admitir, por ejemplo, conexiones asincrónicas."

#: ../Doc/library/socket.rst:1459
msgid ""
"Put the socket object into closed state without actually closing the "
"underlying file descriptor.  The file descriptor is returned, and can be "
"reused for other purposes."
msgstr ""
"Coloque el objeto de socket en estado cerrado sin cerrar realmente el "
"descriptor de archivo subyacente.  Se devuelve el descriptor de archivo y se "
"puede reutilizar para otros fines."

#: ../Doc/library/socket.rst:1468
msgid "Duplicate the socket."
msgstr "Duplica el socket."

#: ../Doc/library/socket.rst:1480
msgid ""
"Return the socket's file descriptor (a small integer), or -1 on failure. "
"This is useful with :func:`select.select`."
msgstr ""
"Retorna un archivo descriptor del socket (un entero pequeño), o -1 si falla. "
"Esto es útil con :func:`select.select`."

#: ../Doc/library/socket.rst:1483
msgid ""
"Under Windows the small integer returned by this method cannot be used where "
"a file descriptor can be used (such as :func:`os.fdopen`).  Unix does not "
"have this limitation."
msgstr ""
"En Windows el pequeño entero retornado por este método no puede ser usado "
"donde un descriptor de un archivo pueda ser usado (como una :func:`os."
"fdopen`). Unix no tiene esta limitación."

#: ../Doc/library/socket.rst:1489
msgid ""
"Get the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle: ``True`` if the socket can be inherited in "
"child processes, ``False`` if it cannot."
msgstr ""
"Obtiene el :ref:`inheritable flag <fd_inheritance>` del descriptor del "
"archivo del socket o el controlador del socket: ``True`` si el socket puede "
"ser heredada en procesos secundarios, ``False`` si falla."

#: ../Doc/library/socket.rst:1498
msgid ""
"Return the remote address to which the socket is connected.  This is useful "
"to find out the port number of a remote IPv4/v6 socket, for instance. (The "
"format of the address returned depends on the address family --- see "
"above.)  On some systems this function is not supported."
msgstr ""
"Retorna la dirección remota a la que esta conectado el socket. Esto es útil "
"para averiguar el número de puerto de un socket IPv4/v6 remoto, por ejemplo. "
"(El formato de la dirección devuelta depende de la familia de direcciones, "
"consulte más arriba). En algunos sistemas, esta función no es compatible."

#: ../Doc/library/socket.rst:1506
msgid ""
"Return the socket's own address.  This is useful to find out the port number "
"of an IPv4/v6 socket, for instance. (The format of the address returned "
"depends on the address family --- see above.)"
msgstr ""
"Retorna la dirección del propio socket. Esto es útil para descubrir el "
"numero de puerto de un socket IPv4/IPv6, por ejemplo. (El formato de la "
"dirección devuelta depende de la familia de direcciones, consulte más "
"arriba)."

#: ../Doc/library/socket.rst:1513
msgid ""
"Return the value of the given socket option (see the Unix man page :manpage:"
"`getsockopt(2)`).  The needed symbolic constants (:const:`SO_\\*` etc.) are "
"defined in this module.  If *buflen* is absent, an integer option is assumed "
"and its integer value is returned by the function.  If *buflen* is present, "
"it specifies the maximum length of the buffer used to receive the option in, "
"and this buffer is returned as a bytes object.  It is up to the caller to "
"decode the contents of the buffer (see the optional built-in module :mod:"
"`struct` for a way to decode C structures encoded as byte strings)."
msgstr ""
"Retorna el valor de la opción de socket dada (consulte la página de comando "
"man de Unix :manpage:`getsockopt(2)`).  Las constantes simbólicas necesarias "
"(:const:`SO_\\*` etc.) se definen en este módulo.  Si *buflen* está ausente, "
"se asume una opción de entero y la función retorna su valor entero.  Si "
"*buflen* está presente, especifica la longitud máxima del búfer utilizado "
"para recibir la opción y este búfer se devuelve como un objeto bytes.  "
"Depende del autor de la llamada descodificar el contenido del búfer "
"(consulte el módulo integrado opcional :mod:`struct` para obtener una manera "
"de decodificar las estructuras C codificadas como cadenas de bytes)."

#: ../Doc/library/socket.rst:1527
msgid ""
"Return ``True`` if socket is in blocking mode, ``False`` if in non-blocking."
msgstr ""
"Retorna ``True`` si el socket está en modo de bloqueo, ``False`` si está en "
"sin bloqueo."

#: ../Doc/library/socket.rst:1530
msgid "This is equivalent to checking ``socket.gettimeout() != 0``."
msgstr "Esto es equivalente a comprobar ``socket.gettimeout() != 0``."

#: ../Doc/library/socket.rst:1537
msgid ""
"Return the timeout in seconds (float) associated with socket operations, or "
"``None`` if no timeout is set.  This reflects the last call to :meth:"
"`setblocking` or :meth:`settimeout`."
msgstr ""
"Retorna el tiempo de espera en segundos (flotante) asociado con las "
"operaciones del socket, o ``None`` si el tiempo de espera no es "
"seleccionado. Esto refleja la ultima llamada al :meth:`setblocking` o :meth:"
"`settimeout`."

#: ../Doc/library/socket.rst
msgid "platform"
msgstr "plataforma"

#: ../Doc/library/socket.rst:1544
msgid "Windows"
msgstr "Windows"

#: ../Doc/library/socket.rst:1546
msgid ""
"The :meth:`ioctl` method is a limited interface to the WSAIoctl system "
"interface.  Please refer to the `Win32 documentation <https://msdn.microsoft."
"com/en-us/library/ms741621%28VS.85%29.aspx>`_ for more information."
msgstr ""
"El método :meth:`ioctl` es una interfaz limitada para el sistema de "
"interfaces WSAIoctl. Por favor refiérase a `Win32 documentation <https://"
"msdn.microsoft.com/en-us/library/ms741621%28VS.85%29.aspx>`_ para mas "
"información."

#: ../Doc/library/socket.rst:1551
msgid ""
"On other platforms, the generic :func:`fcntl.fcntl` and :func:`fcntl.ioctl` "
"functions may be used; they accept a socket object as their first argument."
msgstr ""
"En otras plataformas, las funciones genéricas :func:`fcntl.fcntl` y :func:"
"`fcntl.ioctl` podrían ser usadas; ellas aceptan un objeto socket como su "
"primer argumento."

#: ../Doc/library/socket.rst:1554
msgid ""
"Currently only the following control codes are supported: ``SIO_RCVALL``, "
"``SIO_KEEPALIVE_VALS``, and ``SIO_LOOPBACK_FAST_PATH``."
msgstr ""
"Actualmente solo el siguiente control de códigos está soportados: "
"``SIO_RCVALL``, ``SIO_KEEPALIVE_VALS``, y ``SIO_LOOPBACK_FAST_PATH``."

#: ../Doc/library/socket.rst:1562
msgid ""
"Enable a server to accept connections.  If *backlog* is specified, it must "
"be at least 0 (if it is lower, it is set to 0); it specifies the number of "
"unaccepted connections that the system will allow before refusing new "
"connections. If not specified, a default reasonable value is chosen."
msgstr ""
"Habilita un servidor para aceptar conexiones. Si *backlog* es especifico, "
"debe ser al menos 0 (si es menor, se establece en 0); especifica el número "
"de conexiones no aceptadas que permitirá el sistema antes de rechazar nuevas "
"conexiones. Si no se especifica, se elige un valor razonable predeterminado."

#: ../Doc/library/socket.rst:1569
msgid "The *backlog* parameter is now optional."
msgstr "El parámetro *backlog* ahora es opcional."

#: ../Doc/library/socket.rst:1578
msgid ""
"Return a :term:`file object` associated with the socket.  The exact returned "
"type depends on the arguments given to :meth:`makefile`.  These arguments "
"are interpreted the same way as by the built-in :func:`open` function, "
"except the only supported *mode* values are ``'r'`` (default), ``'w'`` and "
"``'b'``."
msgstr ""
"Retorna un :term:`file object` asociado con el socket. El tipo exacto "
"retornado depende de los argumentos dados a :meth:`makefile`. Estos "
"argumentos se interpretan de la misma forma que la función :func:`open`, "
"excepto que los únicos valores de *mode* admitidos son ``’r’`` (default), "
"``’w’`` and ``’b’``."

#: ../Doc/library/socket.rst:1583
msgid ""
"The socket must be in blocking mode; it can have a timeout, but the file "
"object's internal buffer may end up in an inconsistent state if a timeout "
"occurs."
msgstr ""
"El socket debe estar en modo de bloqueo; puede tener un tiempo de espera, "
"pero el búfer interno del objeto de archivo puede terminar en un estado "
"incoherente si se produce un tiempo de espera."

#: ../Doc/library/socket.rst:1587
msgid ""
"Closing the file object returned by :meth:`makefile` won't close the "
"original socket unless all other file objects have been closed and :meth:"
"`socket.close` has been called on the socket object."
msgstr ""
"Cerrar el objeto de archivo devuelto por :meth:`makefile` no cerrará el "
"socket original a menos que se hayan cerrado todos los demás objetos de "
"archivo y :meth:`socket.close` se haya llamado al objeto socket."

#: ../Doc/library/socket.rst:1593
msgid ""
"On Windows, the file-like object created by :meth:`makefile` cannot be used "
"where a file object with a file descriptor is expected, such as the stream "
"arguments of :meth:`subprocess.Popen`."
msgstr ""
"En Windows, el objeto similar a un archivo creado por :meth:`makefile` no se "
"puede utilizar cuando se espera un objeto de archivo con un descriptor de "
"archivo, como los argumentos de secuencia de :meth:`subprocess.Popen`."

#: ../Doc/library/socket.rst:1600
msgid ""
"Receive data from the socket.  The return value is a bytes object "
"representing the data received.  The maximum amount of data to be received "
"at once is specified by *bufsize*.  See the Unix manual page :manpage:"
"`recv(2)` for the meaning of the optional argument *flags*; it defaults to "
"zero."
msgstr ""
"Recibir datos del socket.  El valor devuelto es un objeto bytes que "
"representa los datos recibidos.  *bufsize* especifica la cantidad máxima de "
"datos que se recibirán a la vez.  Consulte la página del manual de Unix :"
"manpage:`recv(2)` para conocer el significado del argumento opcional "
"*flags*; por defecto es cero."

#: ../Doc/library/socket.rst:1607
msgid ""
"For best match with hardware and network realities, the value of  *bufsize* "
"should be a relatively small power of 2, for example, 4096."
msgstr ""
"Para una mejor coincidencia con las realidades de hardware y red, el valor "
"de *bufsize* debe ser una potencia relativamente pequeña de 2, por ejemplo, "
"4096."

#: ../Doc/library/socket.rst:1618
msgid ""
"Receive data from the socket.  The return value is a pair ``(bytes, "
"address)`` where *bytes* is a bytes object representing the data received "
"and *address* is the address of the socket sending the data.  See the Unix "
"manual page :manpage:`recv(2)` for the meaning of the optional argument "
"*flags*; it defaults to zero. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"Recibe datos desde el socket. El valor de retorno es un par ``(bytes, "
"address)`` donde *bytes* es un objeto de bytes que representa los datos "
"recibidos y *address* es la dirección de el socket enviando los datos. "
"Observar la pagina del manual Unix :manpage:`recv(2)` para el significado "
"del argumento opcional *flags*; por defecto es cero. (El formato de "
"*address* depende de la familia de direcciones, consulte más arriba)."

#: ../Doc/library/socket.rst:1629
#, python-format
msgid ""
"For multicast IPv6 address, first item of *address* does not contain "
"``%scope_id`` part anymore. In order to get full IPv6 address use :func:"
"`getnameinfo`."
msgstr ""
"Para direcciones IPv6 de multidifusión, el primer elemento de *address* ya "
"no contiene la parte ``%scope_id``. Para obtener la dirección IPV6 completa, "
"use :func:`getnameinfo`."

#: ../Doc/library/socket.rst:1636
msgid ""
"Receive normal data (up to *bufsize* bytes) and ancillary data from the "
"socket.  The *ancbufsize* argument sets the size in bytes of the internal "
"buffer used to receive the ancillary data; it defaults to 0, meaning that no "
"ancillary data will be received.  Appropriate buffer sizes for ancillary "
"data can be calculated using :func:`CMSG_SPACE` or :func:`CMSG_LEN`, and "
"items which do not fit into the buffer might be truncated or discarded.  The "
"*flags* argument defaults to 0 and has the same meaning as for :meth:`recv`."
msgstr ""
"Reciba datos normales (hasta *bufsize* bytes) y datos auxiliares del "
"socket.  El argumento *ancbufsize* establece el tamaño en bytes del búfer "
"interno utilizado para recibir los datos auxiliares; el valor predeterminado "
"es 0, lo que significa que no se recibirán datos auxiliares.  Los tamaños de "
"búfer adecuados para los datos auxiliares se pueden calcular mediante :func:"
"`CMSG_SPACE` o :func:`CMSG_LEN`, y los elementos que no caben en el búfer "
"pueden truncarse o descartarse.  El valor predeterminado del argumento "
"*flags* es 0 y tiene el mismo significado que para :meth:`recv`."

#: ../Doc/library/socket.rst:1646
msgid ""
"The return value is a 4-tuple: ``(data, ancdata, msg_flags, address)``.  The "
"*data* item is a :class:`bytes` object holding the non-ancillary data "
"received.  The *ancdata* item is a list of zero or more tuples "
"``(cmsg_level, cmsg_type, cmsg_data)`` representing the ancillary data "
"(control messages) received: *cmsg_level* and *cmsg_type* are integers "
"specifying the protocol level and protocol-specific type respectively, and "
"*cmsg_data* is a :class:`bytes` object holding the associated data.  The "
"*msg_flags* item is the bitwise OR of various flags indicating conditions on "
"the received message; see your system documentation for details. If the "
"receiving socket is unconnected, *address* is the address of the sending "
"socket, if available; otherwise, its value is unspecified."
msgstr ""
"El valor de retorno es una tupla de 4: ``(data, ancdata, msg_flags, "
"address)``. El valor *data* es un objeto :class:`bytes` que contiene los "
"datos no auxiliares recibidos. El valor *ancdata* es una lista de cero o mas "
"tuplas ``(cmsg_level, cmsg_type, cmsg_data)`` representado los datos "
"auxiliares (control de mensajes) recibidos: *cmsg_level* y *cmsg_type* son "
"enteros especificando el nivel de protocolo y tipo específico de protocolo "
"respectivamente, y *cmsg_data* es un objeto :class:`bytes` sosteniendo los "
"datos asociados. El valor *msg_flags* es el OR bit a bit de varios "
"indicadores que indican condiciones en el mensaje recibido; consulte la "
"documentación de su sistema para obtener más detalles. Si la toma de "
"recepción no está conectada, *address* es la dirección de el socket enviado, "
"si está disponible; de lo contrario, su valor no se especifica."

#: ../Doc/library/socket.rst:1660
msgid ""
"On some systems, :meth:`sendmsg` and :meth:`recvmsg` can be used to pass "
"file descriptors between processes over an :const:`AF_UNIX` socket.  When "
"this facility is used (it is often restricted to :const:`SOCK_STREAM` "
"sockets), :meth:`recvmsg` will return, in its ancillary data, items of the "
"form ``(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)``, where *fds* is a :"
"class:`bytes` object representing the new file descriptors as a binary array "
"of the native C :c:expr:`int` type.  If :meth:`recvmsg` raises an exception "
"after the system call returns, it will first attempt to close any file "
"descriptors received via this mechanism."
msgstr ""
"En algunos sistemas, :meth:`sendmsg` y :meth:`recvmsg` pueden utilizarse "
"para pasar descriptores de fichero entre procesos a través de un socket :"
"const:`AF_UNIX`.  Cuando se utiliza esta funcionalidad (a menudo está "
"restringida a los sockets :const:`SOCK_STREAM`), :meth:`recvmsg` devolverá, "
"en sus datos auxiliares, elementos del formulario ``(socket.SOL_SOCKET, "
"socket.SCM_RIGHTS, fds)``, donde *fds* es un objeto :class:`bytes` que "
"representa los nuevos descriptores de archivo como una arreglo binario del "
"tipo nativo C :c:expr:`int`.  Si :meth:`recvmsg` lanza una excepción después "
"del retorno de la llamada al sistema, primero intentará cerrar cualquier "
"descriptor de fichero recibido a través de este mecanismo."

#: ../Doc/library/socket.rst:1671
msgid ""
"Some systems do not indicate the truncated length of ancillary data items "
"which have been only partially received.  If an item appears to extend "
"beyond the end of the buffer, :meth:`recvmsg` will issue a :exc:"
"`RuntimeWarning`, and will return the part of it which is inside the buffer "
"provided it has not been truncated before the start of its associated data."
msgstr ""
"Algunos sistemas no indican la longitud truncada de los elementos de datos "
"auxiliares que solo se han recibido parcialmente.  Si un elemento parece "
"extenderse más allá del final del búfer, :meth:`recvmsg` emitirá un :exc:"
"`RuntimeWarning`, y devolverá la parte de él que está dentro del búfer "
"siempre que no se haya truncado antes del inicio de sus datos asociados."

#: ../Doc/library/socket.rst:1678
msgid ""
"On systems which support the :const:`SCM_RIGHTS` mechanism, the following "
"function will receive up to *maxfds* file descriptors, returning the message "
"data and a list containing the descriptors (while ignoring unexpected "
"conditions such as unrelated control messages being received).  See also :"
"meth:`sendmsg`. ::"
msgstr ""
"En sistemas donde soporta el mecanismo :const:`SCM_RIGHTS`, la siguiente "
"función recibirá un descriptor de archivos *maxfds*, devolviendo el mensaje "
"de datos y un lista que contiene los descriptores (mientras se ignoran las "
"condiciones inesperadas, como la recepción de mensajes de control no "
"relacionados). Ver también :meth:`sendmsg`. ::"

#: ../Doc/library/socket.rst:1709
msgid ""
"Receive normal data and ancillary data from the socket, behaving as :meth:"
"`recvmsg` would, but scatter the non-ancillary data into a series of buffers "
"instead of returning a new bytes object.  The *buffers* argument must be an "
"iterable of objects that export writable buffers (e.g. :class:`bytearray` "
"objects); these will be filled with successive chunks of the non-ancillary "
"data until it has all been written or there are no more buffers.  The "
"operating system may set a limit (:func:`~os.sysconf` value ``SC_IOV_MAX``) "
"on the number of buffers that can be used.  The *ancbufsize* and *flags* "
"arguments have the same meaning as for :meth:`recvmsg`."
msgstr ""
"Recibir datos normales y datos auxiliares desde el socket, comportándose "
"como :meth:`recvmsg` lo haría, pero dispersar los datos no auxiliares en una "
"serie de buffers en lugar de devolver un nuevo objeto bytes.  El argumento "
"*buffers* debe ser un iterable de objetos que exportan buffers de escritura "
"(por ejemplo, objetos :class:`bytearray`); estos se llenarán con fragmentos "
"sucesivos de los datos no auxiliares hasta que se hayan escrito todos o no "
"haya más buffers.  El sistema operativo puede establecer un límite (:func:"
"`~os.sysconf` valor ``SC_IOV_MAX``) en el número de buffers que se pueden "
"utilizar.  Los argumentos *ancbufsize* y *flags* tienen el mismo significado "
"que para :meth:`recvmsg`."

#: ../Doc/library/socket.rst:1720
msgid ""
"The return value is a 4-tuple: ``(nbytes, ancdata, msg_flags, address)``, "
"where *nbytes* is the total number of bytes of non-ancillary data written "
"into the buffers, and *ancdata*, *msg_flags* and *address* are the same as "
"for :meth:`recvmsg`."
msgstr ""
"El valor de retorno es tupla de 4: ``(nbytes, ancdata, msg_flags, "
"address)``, donde *nbytes* es el numero total de bytes de datos no "
"auxiliares escrito dentro de los bufetes, y *ancdata*, *msg_flags* y "
"*address* son lo mismo que para :meth:`recvmsg`."

#: ../Doc/library/socket.rst:1725
msgid "Example::"
msgstr "Ejemplo::"

#: ../Doc/library/socket.rst:1748
msgid ""
"Receive data from the socket, writing it into *buffer* instead of creating a "
"new bytestring.  The return value is a pair ``(nbytes, address)`` where "
"*nbytes* is the number of bytes received and *address* is the address of the "
"socket sending the data.  See the Unix manual page :manpage:`recv(2)` for "
"the meaning of the optional argument *flags*; it defaults to zero.  (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"Reciba datos del socket, escribiéndolo en *buffer* en lugar de crear una "
"nueva cadena de bytes.  El valor devuelto es un par ``(nbytes, address)`` "
"donde *nbytes* es el número de bytes recibidos y *address* es la dirección "
"del socket que envía los datos.  Consulte la página del manual de Unix :"
"manpage:`recv(2)` para conocer el significado del argumento opcional "
"*flags*; por defecto es cero.  (El formato de *address* depende de la "
"familia de direcciones --- ver arriba.)"

#: ../Doc/library/socket.rst:1758
msgid ""
"Receive up to *nbytes* bytes from the socket, storing the data into a buffer "
"rather than creating a new bytestring.  If *nbytes* is not specified (or 0), "
"receive up to the size available in the given buffer.  Returns the number of "
"bytes received.  See the Unix manual page :manpage:`recv(2)` for the meaning "
"of the optional argument *flags*; it defaults to zero."
msgstr ""
"Recibe hasta *nbytes* bytes desde el socket, almacenado los datos en un "
"búfer en lugar de crear una nueva cadena de bytes. Si *nbytes* no esta "
"especificado (o 0), recibir hasta el tamaño disponible en el búfer dado. "
"Retorna  el número de bytes recibidos. Ver la página del manual de Unix :"
"manpage:`recv(2)` para el significado del argumento opcional *flags*; por "
"defecto es cero."

#: ../Doc/library/socket.rst:1767
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Returns the number of bytes sent. Applications are responsible for "
"checking that all data has been sent; if only some of the data was "
"transmitted, the application needs to attempt delivery of the remaining "
"data. For further information on this topic, consult the :ref:`socket-howto`."
msgstr ""
"Enviar datos al socket.  El socket debe estar conectado a un socket remoto.  "
"El argumento opcional *flags* tiene el mismo significado que para :meth:"
"`recv` arriba. Retorna el número de bytes enviados. Las aplicaciones son "
"responsables de comprobar que se han enviado todos los datos; si solo se "
"transmitieron algunos de los datos, la aplicación debe intentar la entrega "
"de los datos restantes. Para obtener más información sobre este tema, "
"consulte :ref:`socket-howto`."

#: ../Doc/library/socket.rst:1782
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Unlike :meth:`send`, this method continues to send data from *bytes* "
"until either all data has been sent or an error occurs.  ``None`` is "
"returned on success.  On error, an exception is raised, and there is no way "
"to determine how much data, if any, was successfully sent."
msgstr ""
"Enviar datos al socket.  El socket debe estar conectado a un socket remoto.  "
"El argumento opcional *flags* tiene el mismo significado que para :meth:"
"`recv` arriba. A diferencia de :meth:`send`, este método continúa enviando "
"datos desde *bytes* hasta que se han enviado todos los datos o se produce un "
"error.  ``Ninguno`` se devuelve en caso de éxito.  Por error, se genera una "
"excepción y no hay forma de determinar cuántos datos, si los hay, se "
"enviaron correctamente."

#: ../Doc/library/socket.rst:1789
msgid ""
"The socket timeout is no longer reset each time data is sent successfully. "
"The socket timeout is now the maximum total duration to send all data."
msgstr ""
"El tiempo de espera del socket ya no se restablece cada vez que los datos se "
"envían correctamente. El tiempo de espera del socket es ahora la duración "
"total máxima para enviar todos los datos."

#: ../Doc/library/socket.rst:1802
msgid ""
"Send data to the socket.  The socket should not be connected to a remote "
"socket, since the destination socket is specified by *address*.  The "
"optional *flags* argument has the same meaning as for :meth:`recv` above.  "
"Return the number of bytes sent. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"Enviar datos al socket.  El socket no debe estar conectado a un socket "
"remoto, ya que el socket de destino se especifica mediante *address*.  El "
"argumento opcional *flags* tiene el mismo significado que para :meth:`recv` "
"arriba.  Devolver el número de bytes enviados. (El formato de *address* "
"depende de la familia de direcciones --- ver arriba.)"

#: ../Doc/library/socket.rst:1817
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendto`` with arguments "
"``self``, ``address``."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.sendto`` con los "
"argumentos ``self``, ``address``."

#: ../Doc/library/socket.rst:1818
msgid ""
"Send normal and ancillary data to the socket, gathering the non-ancillary "
"data from a series of buffers and concatenating it into a single message.  "
"The *buffers* argument specifies the non-ancillary data as an iterable of :"
"term:`bytes-like objects <bytes-like object>` (e.g. :class:`bytes` objects); "
"the operating system may set a limit (:func:`~os.sysconf` value "
"``SC_IOV_MAX``) on the number of buffers that can be used.  The *ancdata* "
"argument specifies the ancillary data (control messages) as an iterable of "
"zero or more tuples ``(cmsg_level, cmsg_type, cmsg_data)``, where "
"*cmsg_level* and *cmsg_type* are integers specifying the protocol level and "
"protocol-specific type respectively, and *cmsg_data* is a bytes-like object "
"holding the associated data.  Note that some systems (in particular, systems "
"without :func:`CMSG_SPACE`) might support sending only one control message "
"per call.  The *flags* argument defaults to 0 and has the same meaning as "
"for :meth:`send`.  If *address* is supplied and not ``None``, it sets a "
"destination address for the message.  The return value is the number of "
"bytes of non-ancillary data sent."
msgstr ""
"Enviar datos normales y auxiliares al socket, recopilar los datos no "
"auxiliares de una serie de buffers y concatenando en un único mensaje.  El "
"argumento *buffers* especifica los datos no auxiliares como un iterable de :"
"term:`bytes-como objetos <bytes-like object>` (por ejemplo: objetos :class:"
"`bytes`); el sistema operativo puede establecer un límite (:func:`os."
"sysconf` valor ``SC_IOV_MAX``) en el número de buffers que se pueden "
"utilizar.  El argumento *ancdata* especifica los datos auxiliares (mensajes "
"de control) como un iterable de cero o más tuplas ``(cmsg_level, cmsg_type, "
"cmsg_data)``, donde *cmsg_level* y *cmsg_type* son enteros que especifican "
"el nivel de protocolo y el tipo específico del protocolo respectivamente, y "
"*cmsg_data* es un objeto similar a bytes que contiene los datos asociados.  "
"Tenga en cuenta que algunos sistemas (en particular, sistemas sin :func:"
"`CMSG_SPACE`) pueden admitir el envío de solo un mensaje de control por "
"llamada.  El valor predeterminado del argumento *flags* es 0 y tiene el "
"mismo significado que para :meth:`send`.  Si se proporciona *address* y no "
"``None``, establece una dirección de destino para el mensaje.  El valor "
"devuelto es el número de bytes de datos no auxiliares enviados."

#: ../Doc/library/socket.rst:1838
msgid ""
"The following function sends the list of file descriptors *fds* over an :"
"const:`AF_UNIX` socket, on systems which support the :const:`SCM_RIGHTS` "
"mechanism.  See also :meth:`recvmsg`. ::"
msgstr ""
"La siguiente función envía la lista de descriptores de archivos *fds* sobre "
"un socket :const:`AF_UNIX`, estos sistemas pueden soportar la mecánica :"
"const:`SCM_RIGHTS`. Observar también :meth:`recvmsg`. ::"

#: ../Doc/library/socket.rst:1847
msgid ":ref:`Availability <availability>`: Unix, not WASI."
msgstr ":ref:`Availability <availability>`: Unix, no WASI."

#: ../Doc/library/socket.rst:1860
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendmsg`` with arguments "
"``self``, ``address``."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.sendmsg`` con los "
"argumentos ``self``, ``address``."

#: ../Doc/library/socket.rst:1862
msgid ""
"Specialized version of :meth:`~socket.sendmsg` for :const:`AF_ALG` socket. "
"Set mode, IV, AEAD associated data length and flags for :const:`AF_ALG` "
"socket."
msgstr ""
"Versión especializada de :meth:`~socket.sendmsg` para el socket :const:"
"`AF_ALG`. Modo de ajuste, IV, longitud de datos asociados a AEAD y banderas "
"para el socket :const:`AF_ALG`."

#: ../Doc/library/socket.rst:1871
msgid ""
"Send a file until EOF is reached by using high-performance :mod:`os."
"sendfile` and return the total number of bytes which were sent. *file* must "
"be a regular file object opened in binary mode. If :mod:`os.sendfile` is not "
"available (e.g. Windows) or *file* is not a regular file :meth:`send` will "
"be used instead. *offset* tells from where to start reading the file. If "
"specified, *count* is the total number of bytes to transmit as opposed to "
"sending the file until EOF is reached. File position is updated on return or "
"also in case of error in which case :meth:`file.tell() <io.IOBase.tell>` can "
"be used to figure out the number of bytes which were sent. The socket must "
"be of :const:`SOCK_STREAM` type. Non-blocking sockets are not supported."
msgstr ""
"Enviar un archivo hasta que se alcance EOF mediante el uso de alto "
"rendimiento :mod:`os.sendfile` y devolver el número total de bytes que se "
"enviaron. *file* debe ser un objeto de archivo normal abierto en modo "
"binario. Si :mod:`os.sendfile` no está disponible (por ejemplo, Windows) o "
"*file* no es un archivo normal :meth:`send` se utilizará en su lugar. "
"*offset* indica desde dónde empezar a leer el archivo. Si se especifica, "
"*count* es el número total de bytes para transmitir en lugar de enviar el "
"archivo hasta que se alcance EOF. La posición del archivo se actualiza a la "
"vuelta o también en caso de error en cuyo caso :meth:`file.tell() <io.IOBase."
"tell>` se puede utilizar para averiguar el número de bytes que se enviaron. "
"El socket debe ser de tipo :const:`SOCK_STREAM` No se admiten sockets sin "
"bloqueo."

#: ../Doc/library/socket.rst:1887
msgid ""
"Set the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle."
msgstr ""
"Selecciona el :ref:`inheritable flag <fd_inheritance>` descriptor del "
"archivo del socket o el controlador del socket."

#: ../Doc/library/socket.rst:1895
msgid ""
"Set blocking or non-blocking mode of the socket: if *flag* is false, the "
"socket is set to non-blocking, else to blocking mode."
msgstr ""
"Establecer el modo de bloqueo o no bloqueo del socket: si *flag* es false, "
"el socket se establece en modo sin bloqueo, de lo contrario en modo de "
"bloqueo."

#: ../Doc/library/socket.rst:1898
msgid ""
"This method is a shorthand for certain :meth:`~socket.settimeout` calls:"
msgstr ""
"El método es una abreviatura para ciertas llamadas :meth:`~socket."
"settimeout`:"

#: ../Doc/library/socket.rst:1900
msgid "``sock.setblocking(True)`` is equivalent to ``sock.settimeout(None)``"
msgstr "``sock.setblocking(True)`` es equivalente a ``sock.settimeout(None)``"

#: ../Doc/library/socket.rst:1902
msgid "``sock.setblocking(False)`` is equivalent to ``sock.settimeout(0.0)``"
msgstr "``sock.setblocking(False)`` es equivalente a ``sock.settimeout(0.0)``"

#: ../Doc/library/socket.rst:1904
msgid ""
"The method no longer applies :const:`SOCK_NONBLOCK` flag on :attr:`socket."
"type`."
msgstr ""
"El método ya no aplica la bandera :const:`SOCK_NONBLOCK` en :attr:`socket."
"type`."

#: ../Doc/library/socket.rst:1911
msgid ""
"Set a timeout on blocking socket operations.  The *value* argument can be a "
"nonnegative floating point number expressing seconds, or ``None``. If a non-"
"zero value is given, subsequent socket operations will raise a :exc:"
"`timeout` exception if the timeout period *value* has elapsed before the "
"operation has completed.  If zero is given, the socket is put in non-"
"blocking mode. If ``None`` is given, the socket is put in blocking mode."
msgstr ""
"Establece un tiempo de espera para bloquear las operaciones de socket. El "
"argumento *value* puede ser un número de punto flotante no negativo que "
"exprese segundos, o ``None``. Si se da un valor distinto de cero, las "
"operaciones subsiguientes de socket lanzarán una excepción :exc:`timeout` si "
"el período de tiempo de espera *value* ha transcurrido antes de que se "
"complete la operación. Si se da cero, el socket se pone en modo sin bloqueo. "
"Si se da ``None``, el enchufe se pone en modo de bloqueo."

#: ../Doc/library/socket.rst:1918
msgid ""
"For further information, please consult the :ref:`notes on socket timeouts "
"<socket-timeouts>`."
msgstr ""
"Para obtener más información, consulte las notas :ref:`notas sobre los "
"tiempos de espera del socket <socket-timeouts>`."

#: ../Doc/library/socket.rst:1920
msgid ""
"The method no longer toggles :const:`SOCK_NONBLOCK` flag on :attr:`socket."
"type`."
msgstr ""
"El método ya no cambia la bandera :const:`SOCK_NONBLOCK` en  :attr:`socket."
"type`."

#: ../Doc/library/socket.rst:1933
msgid ""
"Set the value of the given socket option (see the Unix manual page :manpage:"
"`setsockopt(2)`).  The needed symbolic constants are defined in the :mod:"
"`socket` module (:const:`SO_\\*` etc.).  The value can be an integer, "
"``None`` or a :term:`bytes-like object` representing a buffer. In the later "
"case it is up to the caller to ensure that the bytestring contains the "
"proper bits (see the optional built-in module :mod:`struct` for a way to "
"encode C structures as bytestrings). When *value* is set to ``None``, "
"*optlen* argument is required. It's equivalent to call :c:func:`setsockopt` "
"C function with ``optval=NULL`` and ``optlen=optlen``."
msgstr ""
"Establece el valor de la opción de socket dada (consulte la página de manual "
"de Unix :manpage:`setsockopt(2)`). Las constantes simbólicas necesarias se "
"definen en el modulo :mod:`socket` (:const:`SO_\\*` etc.). El valor puede "
"ser un entero, ``None`` o un :term:`bytes-like object` representan un "
"buffer. En el último caso, depende de la persona que llama asegurarse de que "
"la cadena de bytes contenga los bits adecuados (consulte el módulo integrado "
"opcional :mod:`struct` para una forma de codificar estructuras C como "
"cadenas de bytes). Cuando *value* se establece en ``None``, el argumento "
"*optlen* es requerido. Esto es equivalente a llamar a una función C :c:func:"
"`setsockopt` con ``optval=NULL`` y ``optlen=optlen``."

#: ../Doc/library/socket.rst:1946
msgid "setsockopt(level, optname, None, optlen: int) form added."
msgstr "setsockopt(level, optname, None, optlen: int) form added."

#: ../Doc/library/socket.rst:1954
msgid ""
"Shut down one or both halves of the connection.  If *how* is :const:"
"`SHUT_RD`, further receives are disallowed.  If *how* is :const:`SHUT_WR`, "
"further sends are disallowed.  If *how* is :const:`SHUT_RDWR`, further sends "
"and receives are disallowed."
msgstr ""
"Apague una o ambas mitades de la conexión. Si *how* es :const:`SHUT_RD`, más "
"recibe no se permiten. Si *how* es  :const:`SHUT_WR`, mas recibe no se "
"permiten. Si *how* es :const:`SHUT_RDWR`, más recibe no se permiten."

#: ../Doc/library/socket.rst:1964
msgid ""
"Duplicate a socket and prepare it for sharing with a target process.  The "
"target process must be provided with *process_id*.  The resulting bytes "
"object can then be passed to the target process using some form of "
"interprocess communication and the socket can be recreated there using :func:"
"`fromshare`. Once this method has been called, it is safe to close the "
"socket since the operating system has already duplicated it for the target "
"process."
msgstr ""
"Duplica un socket y lo prepara para compartirlo con el proceso de destino. "
"El proceso de destino debe estar provisto de *process_id*. el objeto de "
"bytes resultante luego se puede pasar al proceso de destino usando alguna "
"forma de comunicación entre procesos y el socket se puede recrear allí "
"usando  :func:`fromshare`. Una vez que se ha llamado a este método, es "
"seguro cerrar el socket ya que el sistema operativo ya lo ha duplicado para "
"el proceso de destino."

#: ../Doc/library/socket.rst:1976
msgid ""
"Note that there are no methods :meth:`read` or :meth:`write`; use :meth:"
"`~socket.recv` and :meth:`~socket.send` without *flags* argument instead."
msgstr ""
"Tenga en cuenta que no hay métodos :meth:`read` o :meth:`write`; use :meth:"
"`~socket.recv` y :meth:`~socket.send` sin el argumento *flags* en su lugar."

#: ../Doc/library/socket.rst:1979
msgid ""
"Socket objects also have these (read-only) attributes that correspond to the "
"values given to the :class:`~socket.socket` constructor."
msgstr ""
"Los objetos de socket también tienen estos atributos (de solo lectura) que "
"corresponden a los valores dados al constructor :class:`~socket.socket`."

#: ../Doc/library/socket.rst:1985
msgid "The socket family."
msgstr "La familia socket."

#: ../Doc/library/socket.rst:1990
msgid "The socket type."
msgstr "El tipo de socket."

#: ../Doc/library/socket.rst:1995
msgid "The socket protocol."
msgstr "The socket protocol."

#: ../Doc/library/socket.rst:2002
msgid "Notes on socket timeouts"
msgstr "Notas sobre los tiempos de espera del socket"

#: ../Doc/library/socket.rst:2004
msgid ""
"A socket object can be in one of three modes: blocking, non-blocking, or "
"timeout.  Sockets are by default always created in blocking mode, but this "
"can be changed by calling :func:`setdefaulttimeout`."
msgstr ""
"Un objeto de socket puede estar en uno de los tres modos: bloqueo, no "
"bloqueo o tiempo de espera.  Los sockets se crean de forma predeterminada "
"siempre en modo de bloqueo, pero esto se puede cambiar llamando a :func:"
"`setdefaulttimeout`."

#: ../Doc/library/socket.rst:2008
msgid ""
"In *blocking mode*, operations block until complete or the system returns an "
"error (such as connection timed out)."
msgstr ""
"En el modo *bloqueo*, las operaciones se bloquean hasta que se completan o "
"el sistema devuelve un error (como tiempo de espera de conexión agotado)."

#: ../Doc/library/socket.rst:2011
msgid ""
"In *non-blocking mode*, operations fail (with an error that is unfortunately "
"system-dependent) if they cannot be completed immediately: functions from "
"the :mod:`select` module can be used to know when and whether a socket is "
"available for reading or writing."
msgstr ""
"En *modo sin bloqueo*, las operaciones fallan (con un error que "
"desafortunadamente depende del sistema) si no se pueden completar "
"inmediatamente: las funciones del módulo :mod:`select` se pueden usar para "
"saber cuándo y si un socket está disponible para leer o escribir."

#: ../Doc/library/socket.rst:2016
msgid ""
"In *timeout mode*, operations fail if they cannot be completed within the "
"timeout specified for the socket (they raise a :exc:`timeout` exception) or "
"if the system returns an error."
msgstr ""
"En *timeout mode*, las operaciones fallan si no se puede completan el tiempo "
"de espera especifico para el socket (ellos lanzan una excepción :exc:"
"`timeout`) o si el sistema devuelve un error."

#: ../Doc/library/socket.rst:2021
msgid ""
"At the operating system level, sockets in *timeout mode* are internally set "
"in non-blocking mode.  Also, the blocking and timeout modes are shared "
"between file descriptors and socket objects that refer to the same network "
"endpoint. This implementation detail can have visible consequences if e.g. "
"you decide to use the :meth:`~socket.fileno()` of a socket."
msgstr ""
"En el nivel del sistema operativo, los sockets en el *timeout mode* se "
"establecen internamente en modo sin bloqueo.  Además, los modos de bloqueo y "
"tiempo de espera se comparten entre descriptores de archivo y objetos de "
"socket que hacen referencia al mismo punto de conexión de red. Este detalle "
"de implementación puede tener consecuencias visibles si, por ejemplo, decide "
"utilizar el :meth:`~socket.fileno()` de un socket."

#: ../Doc/library/socket.rst:2028
msgid "Timeouts and the ``connect`` method"
msgstr "Tiempos de espera y el método ``connect``"

#: ../Doc/library/socket.rst:2030
msgid ""
"The :meth:`~socket.connect` operation is also subject to the timeout "
"setting, and in general it is recommended to call :meth:`~socket.settimeout` "
"before calling :meth:`~socket.connect` or pass a timeout parameter to :meth:"
"`create_connection`.  However, the system network stack may also return a "
"connection timeout error of its own regardless of any Python socket timeout "
"setting."
msgstr ""
"La operación :meth:`~socket.connect` también está sujeta a la configuración "
"de tiempo de espera, y en general se recomienda llamar a :meth:`~socket."
"settimeout` antes de llamar a :meth:`~socket.connect` o pasar un parámetro "
"de tiempo de espera a :meth:`create_connection`.  Sin embargo, la pila de "
"red del sistema también puede devolver un error de tiempo de espera de "
"conexión propio independientemente de cualquier configuración de tiempo de "
"espera del socket de Python."

#: ../Doc/library/socket.rst:2038
msgid "Timeouts and the ``accept`` method"
msgstr "Tiempos de espera y el método ``accept``"

#: ../Doc/library/socket.rst:2040
msgid ""
"If :func:`getdefaulttimeout` is not :const:`None`, sockets returned by the :"
"meth:`~socket.accept` method inherit that timeout.  Otherwise, the behaviour "
"depends on settings of the listening socket:"
msgstr ""
"Si :func:`getdefaulttimeout` no es una :const:`None`, los sockets devuelto "
"por el método :meth:`~socket.accept` heredan ese tiempo de espera. De lo "
"contrario, el comportamiento depende de la configuración de la toma de "
"escucha:"

#: ../Doc/library/socket.rst:2044
msgid ""
"if the listening socket is in *blocking mode* or in *timeout mode*, the "
"socket returned by :meth:`~socket.accept` is in *blocking mode*;"
msgstr ""
"si los sockets están escuchando en *blocking mode* o en el *timeout mode*, "
"el socket devuelve el :meth:`~socket.accept` en un *blocking mode*;"

#: ../Doc/library/socket.rst:2047
msgid ""
"if the listening socket is in *non-blocking mode*, whether the socket "
"returned by :meth:`~socket.accept` is in blocking or non-blocking mode is "
"operating system-dependent.  If you want to ensure cross-platform behaviour, "
"it is recommended you manually override this setting."
msgstr ""
"si los sockets están escuchando en *non-blocking mode*, ya sea el socket "
"devuelto por :meth:`~socket.accept` es un modo de bloqueo o no bloque "
"depende del sistema operativo. Si desea garantizar un comportamiento "
"multiplataforma, se recomienda que se anule manualmente esta configuración."

#: ../Doc/library/socket.rst:2056
msgid "Example"
msgstr "Ejemplo"

#: ../Doc/library/socket.rst:2058
msgid ""
"Here are four minimal example programs using the TCP/IP protocol: a server "
"that echoes all data that it receives back (servicing only one client), and "
"a client using it.  Note that a server must perform the sequence :func:`."
"socket`, :meth:`~socket.bind`, :meth:`~socket.listen`, :meth:`~socket."
"accept` (possibly repeating the :meth:`~socket.accept` to service more than "
"one client), while a client only needs the sequence :func:`.socket`, :meth:"
"`~socket.connect`.  Also note that the server does not :meth:`~socket."
"sendall`/:meth:`~socket.recv` on the socket it is listening on but on the "
"new socket returned by :meth:`~socket.accept`."
msgstr ""
"Aquí están cuatro programas mínimos usando el protocolo TCP/IP: un servidor "
"que hace eco de todos los datos que reciban de vuelta ( Servicio a un solo "
"cliente), y un cliente usando esto. Recuerde que un servidor debe llevar a "
"cabo la secuencia :func:`.socket`, :meth:`~socket.bind`, :meth:`~socket."
"listen`, :meth:`~socket.accept` (posiblemente repitiendo la :meth:`~socket."
"accept` para un servicio mas que un cliente), mientras un cliente solamente "
"necesita la secuencia :func:`.socket`, :meth:`~socket.connect`. También "
"recuerde que el servidor no :meth:`~socket.sendall`/:meth:`~socket.recv` en "
"el socket esta escuchando pero en el nuevo socket devuelto por :meth:"
"`~socket.accept`."

#: ../Doc/library/socket.rst:2068
msgid "The first two examples support IPv4 only. ::"
msgstr "Los dos primeros ejemplos solo admiten IPv4. ::"

#: ../Doc/library/socket.rst:2099
msgid ""
"The next two examples are identical to the above two, but support both IPv4 "
"and IPv6. The server side will listen to the first address family available "
"(it should listen to both instead). On most of IPv6-ready systems, IPv6 will "
"take precedence and the server may not accept IPv4 traffic. The client side "
"will try to connect to the all addresses returned as a result of the name "
"resolution, and sends traffic to the first one connected successfully. ::"
msgstr ""
"Los dos ejemplos siguientes son idénticos a los dos anteriores, pero admiten "
"IPv4 e IPv6. El lado del servidor escuchará la primera familia de "
"direcciones disponible (debe escuchar ambas en su lugar). En la mayoría de "
"los sistemas listos para IPv6, IPv6 tendrá prioridad y es posible que el "
"servidor no acepte tráfico IPv4. El lado del cliente intentará conectarse a "
"todas las direcciones devueltas como resultado de la resolución de nombres y "
"enviará el tráfico al primero conectado correctamente. ::"

#: ../Doc/library/socket.rst:2171
msgid ""
"The next example shows how to write a very simple network sniffer with raw "
"sockets on Windows. The example requires administrator privileges to modify "
"the interface::"
msgstr ""
"El siguiente ejemplo muestra cómo escribir un rastreador de red muy simple "
"con sockets sin procesar en Windows. El ejemplo requiere privilegios de "
"administrador para modificar la interfaz:"

#: ../Doc/library/socket.rst:2196
msgid ""
"The next example shows how to use the socket interface to communicate to a "
"CAN network using the raw socket protocol. To use CAN with the broadcast "
"manager protocol instead, open a socket with::"
msgstr ""
"En el ejemplo siguiente se muestra cómo utilizar la interfaz de socket para "
"comunicarse con una red CAN mediante el protocolo de socket sin procesar. "
"Para utilizar CAN con el protocolo de gestor de difusión en su lugar, abra "
"un socket con:"

#: ../Doc/library/socket.rst:2202
msgid ""
"After binding (:const:`CAN_RAW`) or connecting (:const:`CAN_BCM`) the "
"socket, you can use the :meth:`socket.send` and :meth:`socket.recv` "
"operations (and their counterparts) on the socket object as usual."
msgstr ""
"Después de vincular (:const:`CAN_RAW`) o conectar (:const:`CAN_BCM`) el "
"socket, puede usar las operaciones :meth:`socket.send` y :meth:`socket.recv` "
"(y sus contrapartes) en el objeto socket como de costumbre."

#: ../Doc/library/socket.rst:2206
msgid "This last example might require special privileges::"
msgstr "Este último ejemplo puede requerir privilegios especiales:"

#: ../Doc/library/socket.rst:2246
msgid ""
"Running an example several times with too small delay between executions, "
"could lead to this error::"
msgstr ""
"Ejecutar un ejemplo varias veces con un retraso demasiado pequeño entre "
"ejecuciones, podría dar lugar a este error::"

#: ../Doc/library/socket.rst:2251
msgid ""
"This is because the previous execution has left the socket in a "
"``TIME_WAIT`` state, and can't be immediately reused."
msgstr ""
"Esto se debe a que la ejecución anterior ha dejado el socket en un estado "
"``TIME_WAIT`` y no se puede reutilizar inmediatamente."

#: ../Doc/library/socket.rst:2254
msgid ""
"There is a :mod:`socket` flag to set, in order to prevent this, :const:"
"`socket.SO_REUSEADDR`::"
msgstr ""
"Hay un indicador :mod:`socket` para configurar, para evitar esto, :const:"
"`socket.SO_REUSEADDR`::"

#: ../Doc/library/socket.rst:2261
msgid ""
"the :data:`SO_REUSEADDR` flag tells the kernel to reuse a local socket in "
"``TIME_WAIT`` state, without waiting for its natural timeout to expire."
msgstr ""
"el indicador :data:`SO_REUSEADDR` indica al kernel que reutilice un socket "
"local en estado ``TIME_WAIT``, sin esperar a que expire su tiempo de espera "
"natural."

#: ../Doc/library/socket.rst:2267
msgid ""
"For an introduction to socket programming (in C), see the following papers:"
msgstr ""
"Para obtener una introducción a la programación de sockets (en C), consulte "
"los siguientes documentos:"

#: ../Doc/library/socket.rst:2269
msgid ""
"*An Introductory 4.3BSD Interprocess Communication Tutorial*, by Stuart "
"Sechrest"
msgstr ""
"*An Introductory 4.3BSD Interprocess Communication Tutorial*, por Stuart "
"Sechrest"

#: ../Doc/library/socket.rst:2271
msgid ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*, by Samuel J.  "
"Leffler et al,"
msgstr ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*, por Samuel J.  "
"Leffler et al,"

#: ../Doc/library/socket.rst:2274
msgid ""
"both in the UNIX Programmer's Manual, Supplementary Documents 1 (sections "
"PS1:7 and PS1:8).  The platform-specific reference material for the various "
"socket-related system calls are also a valuable source of information on the "
"details of socket semantics.  For Unix, refer to the manual pages; for "
"Windows, see the WinSock (or Winsock 2) specification.  For IPv6-ready APIs, "
"readers may want to refer to :rfc:`3493` titled Basic Socket Interface "
"Extensions for IPv6."
msgstr ""
"ambos en el manual del programador de Unix, documentos suplementarios 1 "
"( secciones  PS1:7 y PS1:8). La plataforma especifica material de referencia "
"para las diversas llamadas al sistema también son una valiosa fuente de "
"información en los detalles de la semántica del socket. Para Unix, "
"referencia a las paginas del manual, para Windows, observa la especificación "
"WinSock (o WinSock 2). Para APIS listas IPV6, los lectores pueden querer "
"referirse al titulado Extensiones básicas de interfaz de socket para IPv6 :"
"rfc:`3493` ."

#: ../Doc/library/socket.rst:22
msgid "object"
msgstr "objetos Socket"

#: ../Doc/library/socket.rst:22
msgid "socket"
msgstr "objetos Socket"

#: ../Doc/library/socket.rst:1576
msgid "I/O control"
msgstr "I/O control de salida y entrada"

#: ../Doc/library/socket.rst:1576
msgid "buffering"
msgstr "almacenamiento en búfer"

#: ../Doc/library/socket.rst:1931
msgid "module"
msgstr "modulo"

#: ../Doc/library/socket.rst:1931
msgid "struct"
msgstr "estructura"

#~ msgid ""
#~ "*proto* - An in network-byte-order integer specifying the Ethernet "
#~ "protocol number."
#~ msgstr ""
#~ "*proto* - Un entero en orden de byte de red que especifica el número de "
#~ "protocolo Ethernet."
