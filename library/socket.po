# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-25 19:47+0200\n"
"PO-Revision-Date: 2022-10-30 15:53+0100\n"
"Last-Translator: \n"
"Language-Team: python-doc-es\n"
"Language: es_ES\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.10.3\n"
"X-Generator: Poedit 3.1.1\n"

#: ../Doc/library/socket.rst:2
msgid ":mod:`socket` --- Low-level networking interface"
msgstr ":mod:`socket` --- interfaz de red de bajo nivel"

#: ../Doc/library/socket.rst:7
msgid "**Source code:** :source:`Lib/socket.py`"
msgstr "**Código fuente:** :source:`Lib/socket.py`"

#: ../Doc/library/socket.rst:11
msgid ""
"This module provides access to the BSD *socket* interface. It is available "
"on all modern Unix systems, Windows, MacOS, and probably additional "
"platforms."
msgstr ""
"Este módulo proporciona acceso a la interfaz BSD *socket*. Está disponible "
"en todos los sistemas Unix modernos, Windows, MacOS y probablemente "
"plataformas adicionales."

#: ../Doc/library/socket.rst:16
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs."
msgstr ""
"Algunos comportamientos pueden depender de la plataforma, ya que las "
"llamadas se realizan a las API de socket del sistema operativo."

#, fuzzy
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ":ref:`Availability <availability>`: no Emscripten, no WASI."

#: ../Doc/library/cpython/Doc/includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"Este módulo no funciona o no está disponible en las plataformas WebAssembly "
"``wasm32-emscripten`` y ``wasm32-wasi``. Véase :ref:`wasm-availability` para "
"más información."

#: ../Doc/library/socket.rst:24
msgid ""
"The Python interface is a straightforward transliteration of the Unix system "
"call and library interface for sockets to Python's object-oriented style: "
"the :func:`.socket` function returns a :dfn:`socket object` whose methods "
"implement the various socket system calls.  Parameter types are somewhat "
"higher-level than in the C interface: as with :meth:`read` and :meth:`write` "
"operations on Python files, buffer allocation on receive operations is "
"automatic, and buffer length is implicit on send operations."
msgstr ""
"La interfaz de Python es una transcripción sencilla de la llamada al sistema "
"Unix y la interfaz de la biblioteca para sockets al estilo orientado a "
"objetos de Python: la función :func:`.socket` devuelve a :dfn:`socket "
"object` cuyos métodos implementan las diversas llamadas al sistema de "
"socket. Los tipos de parámetros tienen un nivel algo más alto que en la "
"interfaz C: como con :meth:`read` y :meth:`write` en las operaciones en los "
"archivos Python, la asignación del buffer en las operaciones de recepción es "
"automática y la longitud del buffer está implícita en las operaciones de "
"envío."

#: ../Doc/library/socket.rst:36
msgid "Module :mod:`socketserver`"
msgstr "Módulo :mod:`socketserver`"

#: ../Doc/library/socket.rst:36
msgid "Classes that simplify writing network servers."
msgstr "Clases que simplifican la escritura de servidores de red."

#: ../Doc/library/socket.rst:38
msgid "Module :mod:`ssl`"
msgstr "Módulo :mod:`ssl`"

#: ../Doc/library/socket.rst:39
msgid "A TLS/SSL wrapper for socket objects."
msgstr "Un contenedor TLS/SSL para objetos de socket."

#: ../Doc/library/socket.rst:43
msgid "Socket families"
msgstr "Familias Socket"

#: ../Doc/library/socket.rst:45
msgid ""
"Depending on the system and the build options, various socket families are "
"supported by this module."
msgstr ""
"Dependiendo del sistema y de las opciones de compilación, este módulo admite "
"varias familias de sockets."

#: ../Doc/library/socket.rst:48
msgid ""
"The address format required by a particular socket object is automatically "
"selected based on the address family specified when the socket object was "
"created.  Socket addresses are represented as follows:"
msgstr ""
"El formato de dirección requerido por un objeto de socket determinado se "
"selecciona automáticamente en función de la familia de direcciones "
"especificada cuando se creó el objeto de socket.  Las direcciones de socket "
"se representan de la siguiente manera:"

#: ../Doc/library/socket.rst:52
msgid ""
"The address of an :const:`AF_UNIX` socket bound to a file system node is "
"represented as a string, using the file system encoding and the "
"``'surrogateescape'`` error handler (see :pep:`383`).  An address in Linux's "
"abstract namespace is returned as a :term:`bytes-like object` with an "
"initial null byte; note that sockets in this namespace can communicate with "
"normal file system sockets, so programs intended to run on Linux may need to "
"deal with both types of address.  A string or bytes-like object can be used "
"for either type of address when passing it as an argument."
msgstr ""
"La dirección de un socket :const:`AF_UNIX` enlazado a un nodo del sistema de "
"archivos es representado como una cadena de caracteres, utilizando la "
"codificación del sistema de archivos y el controlador de errores "
"``'surrogateescape'`` (Observar :pep:`383`). Una dirección en el espacio de "
"nombre abstracto de Linux es devuelvo como un :term:`bytes-like object` con "
"un byte inicial nulo; tenga en cuenta que los sockets en este nombre de "
"espacio puede comunicarse con sockets normales del sistema de archivos, así "
"que los programas destinados a correr en Linux podrían necesitar tratar con "
"ambos tipos de direcciones. Se puede pasar un objeto similar a una cadena de "
"caracteres o bytes para cualquier tipo de dirección al pasarlo como "
"argumento."

#: ../Doc/library/socket.rst:62
msgid ""
"Previously, :const:`AF_UNIX` socket paths were assumed to use UTF-8 encoding."
msgstr ""
"Anteriormente, se suponía que las rutas de socket :const:`AF_UNIX` "
"utilizaban codificación UTF-8."

#: ../Doc/library/socket.rst:66 ../Doc/library/socket.rst:1043
#: ../Doc/library/socket.rst:1085 ../Doc/library/socket.rst:1844
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "Ahora se acepta la grabación :term:`bytes-like object`."

#: ../Doc/library/socket.rst:71
msgid ""
"A pair ``(host, port)`` is used for the :const:`AF_INET` address family, "
"where *host* is a string representing either a hostname in internet domain "
"notation like ``'daring.cwi.nl'`` or an IPv4 address like "
"``'100.50.200.5'``, and *port* is an integer."
msgstr ""
"Se utiliza un par ``(host, port)`` para la familia de direcciones :const:"
"`AF_INET`, donde *host* es una cadena que representa un nombre de host en "
"notación de dominio de Internet como ``'daring.cwi.nl'`` o una dirección "
"IPv4 como ``'100.50.200.5'``, y *port* es un número entero."

#: ../Doc/library/socket.rst:76
msgid ""
"For IPv4 addresses, two special forms are accepted instead of a host "
"address: ``''`` represents :const:`INADDR_ANY`, which is used to bind to all "
"interfaces, and the string ``'<broadcast>'`` represents :const:"
"`INADDR_BROADCAST`.  This behavior is not compatible with IPv6, therefore, "
"you may want to avoid these if you intend to support IPv6 with your Python "
"programs."
msgstr ""
"Para direcciones IPv4, se aceptan dos formas especiales en lugar de una "
"dirección de host: ``’’`` representa :const:`INADDR_ANY`, que se utiliza "
"para enlazar a todas las interfaces, y la cadena de caracteres "
"``'<broadcast>'`` representa :const:`INADDR_BROADCAST`. Este comportamiento "
"no es compatible con IPv6, por lo tanto, es posible que desee evitarlos sí "
"tiene la intención de admitir IPv6 con sus programas Python."

#: ../Doc/library/socket.rst:83
msgid ""
"For :const:`AF_INET6` address family, a four-tuple ``(host, port, flowinfo, "
"scope_id)`` is used, where *flowinfo* and *scope_id* represent the "
"``sin6_flowinfo`` and ``sin6_scope_id`` members in :const:`struct "
"sockaddr_in6` in C.  For :mod:`socket` module methods, *flowinfo* and "
"*scope_id* can be omitted just for backward compatibility.  Note, however, "
"omission of *scope_id* can cause problems in manipulating scoped IPv6 "
"addresses."
msgstr ""
"Para la familia de direcciones :const:`AF_INET6`, se utiliza una ``(host, "
"port, flowinfo, scope_id)`` de cuatro tuplas, donde *flowinfo* y *scope_id* "
"representan los miembros ``sin6_flowinfo`` y ``sin6_scope_id`` en :const:"
"`struct sockaddr_in6` en C. Para los métodos de los módulos :mod:`socket`, "
"*flowinfo* y *scope_id* pueden ser omitidos solo por compatibilidad con "
"versiones anteriores. Sin embargo la omisión de *scope_id* puede causar "
"problemas en la manipulación de direcciones IPv6 con ámbito."

#: ../Doc/library/socket.rst:90
#, python-format
msgid ""
"For multicast addresses (with *scope_id* meaningful) *address* may not "
"contain ``%scope_id`` (or ``zone id``) part. This information is superfluous "
"and may be safely omitted (recommended)."
msgstr ""
"Para direcciones de multidifusión (con *scopeid* significativo) *address* "
"puede no contener la parte ``%scope`` (o ``zone id``). Esta información es "
"superflua y puede omitirse de forma segura (recomendado)."

#: ../Doc/library/socket.rst:95
msgid ":const:`AF_NETLINK` sockets are represented as pairs ``(pid, groups)``."
msgstr ""
":const:`AF_NETLINK` sockets se representan como pares ``(pid, groups)``."

#: ../Doc/library/socket.rst:97
msgid ""
"Linux-only support for TIPC is available using the :const:`AF_TIPC` address "
"family.  TIPC is an open, non-IP based networked protocol designed for use "
"in clustered computer environments.  Addresses are represented by a tuple, "
"and the fields depend on the address type. The general tuple form is "
"``(addr_type, v1, v2, v3 [, scope])``, where:"
msgstr ""
"La compatibilidad con LINUX solo para TIPC está disponible mediante la "
"familia de direcciones :const:`AF_TIPC`.  TIPC es un protocolo en red "
"abierto y no basado en IP diseñado para su uso en entornos informáticos "
"agrupados.  Las direcciones se representan mediante una tupla y los campos "
"dependen del tipo de dirección. El formulario de tupla general es "
"``(addr_type, v1, v2, v3 [, scope])``, donde:"

#: ../Doc/library/socket.rst:103
msgid ""
"*addr_type* is one of :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, "
"or :const:`TIPC_ADDR_ID`."
msgstr ""
"*addr_type* es uno de :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, "
"o :const:`TIPC_ADDR_ID`."

#: ../Doc/library/socket.rst:105
msgid ""
"*scope* is one of :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, "
"and :const:`TIPC_NODE_SCOPE`."
msgstr ""
"*scope* es una de :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, y :"
"const:`TIPC_NODE_SCOPE`."

#: ../Doc/library/socket.rst:107
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAME`, then *v1* is the server type, "
"*v2* is the port identifier, and *v3* should be 0."
msgstr ""
"Si *addr_type* es :const:`TIPC_ADDR_NAME`, entonces *v1* es el tipo de "
"servidor, *v2* es el identificador de puerto, y *v3* debe ser 0."

#: ../Doc/library/socket.rst:110
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAMESEQ`, then *v1* is the server type, "
"*v2* is the lower port number, and *v3* is the upper port number."
msgstr ""
"Si *addr_type* es :const:`TIPC_ADDR_NAMESEQ`, entonces  *v1* es el tipo de "
"servidor, *v2* es el numero de puerto inferior, y *v3* es el numero de "
"puerto superior."

#: ../Doc/library/socket.rst:113
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_ID`, then *v1* is the node, *v2* is the "
"reference, and *v3* should be set to 0."
msgstr ""
"Si *addr_type* es :const:`TIPC_ADDR_ID`, *v1* es el nodo, *v2* es la "
"referencia y *v3* debe establecerse en 0."

#: ../Doc/library/socket.rst:116
msgid ""
"A tuple ``(interface, )`` is used for the :const:`AF_CAN` address family, "
"where *interface* is a string representing a network interface name like "
"``'can0'``. The network interface name ``''`` can be used to receive packets "
"from all network interfaces of this family."
msgstr ""
"Una tupla ``(interface, )`` es usada para la dirección de familia :const:"
"`AF_CAN`, donde *interface* es una cadena de caracteres representando a un "
"nombre de interfaz de red como ``’can0’``. La interfaz de red llamada ``''`` "
"puede ser usada para recibir paquetes de todas las interfaces de red de esta "
"familia."

#: ../Doc/library/socket.rst:121
msgid ""
":const:`CAN_ISOTP` protocol require a tuple ``(interface, rx_addr, "
"tx_addr)`` where both additional parameters are unsigned long integer that "
"represent a CAN identifier (standard or extended)."
msgstr ""
"Protocolo :const:`CAN_ISOTP` requiere una tupla ``(interface, rx_addr, "
"tx_addr)`` donde ambos tiene parámetros adicionales son enteres largos sin "
"símbolos que representan una identificador CAN (estándar o extendido)."

#: ../Doc/library/socket.rst:124
msgid ""
":const:`CAN_J1939` protocol require a tuple ``(interface, name, pgn, addr)`` "
"where additional parameters are 64-bit unsigned integer representing the ECU "
"name, a 32-bit unsigned integer representing the Parameter Group Number "
"(PGN), and an 8-bit integer representing the address."
msgstr ""
"Protocolo :const:`CAN_J1939` requiere una tupla ``(interface, name, pgn, "
"addr)`` donde los parámetros adicionales son números enteros sin signo de 64 "
"bits representando el nombre ECU, los enteros sin signo de 32-bits "
"representan el numero de grupo de parámetros(PGN), y los enteros de 8-bit "
"representan la dirección."

#: ../Doc/library/socket.rst:129
msgid ""
"A string or a tuple ``(id, unit)`` is used for the :const:`SYSPROTO_CONTROL` "
"protocol of the :const:`PF_SYSTEM` family. The string is the name of a "
"kernel control using a dynamically assigned ID. The tuple can be used if ID "
"and unit number of the kernel control are known or if a registered ID is "
"used."
msgstr ""
"Se utiliza una cadena o una tupla ``(id, unit)`` para el protocolo :const:"
"`SYSPROTO_CONTROL` de la familia :const:`PF_SYSTEM`. La cadena es el nombre "
"de un control de kernel mediante un ID asignado dinámicamente. La tupla se "
"puede utilizar si se conoce el ID y el número de unidad del control del "
"kernel o si se utiliza un ID registrado."

#: ../Doc/library/socket.rst:137
msgid ""
":const:`AF_BLUETOOTH` supports the following protocols and address formats:"
msgstr ""
":const:`AF_BLUETOOTH` admite los siguientes protocolos y formatos de "
"dirección:"

#: ../Doc/library/socket.rst:140
msgid ""
":const:`BTPROTO_L2CAP` accepts ``(bdaddr, psm)`` where ``bdaddr`` is the "
"Bluetooth address as a string and ``psm`` is an integer."
msgstr ""
":const:`BTPROTO_L2CAP` acepta ``(bdaddr, psm)`` donde ``bdaddr`` es la "
"dirección Bluetooth como una cadena de caracteres y ``psm`` es un entero."

#: ../Doc/library/socket.rst:143
msgid ""
":const:`BTPROTO_RFCOMM` accepts ``(bdaddr, channel)`` where ``bdaddr`` is "
"the Bluetooth address as a string and ``channel`` is an integer."
msgstr ""
":const:`BTPROTO_RFCOMM` acepta ``(bdaddr, channel)`` donde ``bdaddr`` es la "
"dirección Bluetooth como una cadena de caracteres y ``channel`` es un entero."

#: ../Doc/library/socket.rst:146
msgid ""
":const:`BTPROTO_HCI` accepts ``(device_id,)`` where ``device_id`` is either "
"an integer or a string with the Bluetooth address of the interface. (This "
"depends on your OS; NetBSD and DragonFlyBSD expect a Bluetooth address while "
"everything else expects an integer.)"
msgstr ""
":const:`BTPROTO_HCI` acepta ``(device_id,)`` donde ``device_id`` es un "
"numero entero o una cadena de caracteres con la dirección Bluetooth de la "
"interfaz. (Esto depende de tu OS; NetBSD y DragonFlyBSD supone una dirección "
"Bluetooth mientras todo lo demás espera un entero.)"

#: ../Doc/library/socket.rst:151
msgid "NetBSD and DragonFlyBSD support added."
msgstr "Se ha añadido compatibilidad con NetBSD y DragonFlyBSD."

#: ../Doc/library/socket.rst:154
msgid ""
":const:`BTPROTO_SCO` accepts ``bdaddr`` where ``bdaddr`` is a :class:`bytes` "
"object containing the Bluetooth address in a string format. (ex. "
"``b'12:23:34:45:56:67'``) This protocol is not supported under FreeBSD."
msgstr ""
":const:`BTPROTO_SCO` acepta ``bdaddr`` donde ``bdaddr`` es un objeto :class:"
"`bytes` que contiene la dirección Bluetooth en un formato cadena. (ex. "
"``b’12:23:34:45:56:67’``) este protocolo no es admitido bajo FreeBSD."

#: ../Doc/library/socket.rst:159
msgid ""
":const:`AF_ALG` is a Linux-only socket based interface to Kernel "
"cryptography. An algorithm socket is configured with a tuple of two to four "
"elements ``(type, name [, feat [, mask]])``, where:"
msgstr ""
":const:`AF_ALG` es una interfaz basada en socket sólo Linux para la "
"criptografía del núcleo. Un socket de algoritmo se configura con una tupla "
"de dos a cuatro elementos ``(type, name [, feat [, mask]])``, donde:"

#: ../Doc/library/socket.rst:163
msgid ""
"*type* is the algorithm type as string, e.g. ``aead``, ``hash``, "
"``skcipher`` or ``rng``."
msgstr ""
"*type* es el tipo de algoritmos como cadenas de caracteres, e.g. ``aead``, "
"``hash``, ``skcipher`` o ``rng``."

#: ../Doc/library/socket.rst:166
msgid ""
"*name* is the algorithm name and operation mode as string, e.g. ``sha256``, "
"``hmac(sha256)``, ``cbc(aes)`` or ``drbg_nopr_ctr_aes256``."
msgstr ""
"*name* es el nombre del algoritmo y el modo de operación como cadena de "
"caracteres, e.g. ``sha256``, ``hmac(sha256)``, ``cbc(aes)`` o "
"``drbg_nopr_ctr_aes256``."

#: ../Doc/library/socket.rst:169
msgid "*feat* and *mask* are unsigned 32bit integers."
msgstr "*feat* y *mask* son enteros de 32 bits sin signo."

#: ../Doc/library/socket.rst:173
msgid "Some algorithm types require more recent Kernels."
msgstr "Algunos tipos de algoritmos requieren Kernels mas recientes."

#: ../Doc/library/socket.rst:177
msgid ""
":const:`AF_VSOCK` allows communication between virtual machines and their "
"hosts. The sockets are represented as a ``(CID, port)`` tuple where the "
"context ID or CID and port are integers."
msgstr ""
":const:`AF_VSOCK` permite comunicación entre maquinas virtuales y sus hosts. "
"Los sockets están representando como una tupla ``(CID, port)`` donde el "
"contexto del ID o CID y el puerto son enteros."

#: ../Doc/library/socket.rst:183
msgid "See :manpage:`vsock(7)`"
msgstr "Véase :manpage:`vsock(7)`"

#: ../Doc/library/socket.rst:187
msgid ""
":const:`AF_PACKET` is a low-level interface directly to network devices. The "
"packets are represented by the tuple ``(ifname, proto[, pkttype[, hatype[, "
"addr]]])`` where:"
msgstr ""
":const:`AF_PACKET` es una interfaz de bajo nivel directa con los "
"dispositivos de red. Los paquetes están representados por la tupla "
"``(ifname, proto[, pkttype[, hatype[, addr]]])`` donde:"

#: ../Doc/library/socket.rst:191
msgid "*ifname* - String specifying the device name."
msgstr "*ifname* - Cadena que especifica el nombre del dispositivo."

#: ../Doc/library/socket.rst:192
msgid ""
"*proto* - An in network-byte-order integer specifying the Ethernet protocol "
"number."
msgstr ""
"*proto* - Un entero en orden de byte de red que especifica el número de "
"protocolo Ethernet."

#: ../Doc/library/socket.rst:194
msgid "*pkttype* - Optional integer specifying the packet type:"
msgstr "*pkttype* - Entero opcional especificando el tipo de paquete:"

#: ../Doc/library/socket.rst:196
msgid "``PACKET_HOST`` (the default) - Packet addressed to the local host."
msgstr "``PACKET_HOST`` (por defecto) - Paquetes diseccionado al local host."

#: ../Doc/library/socket.rst:197
msgid "``PACKET_BROADCAST`` - Physical-layer broadcast packet."
msgstr "``PACKET_BROADCAST`` - Paquete de transmisión de la capa física."

#: ../Doc/library/socket.rst:198
msgid ""
"``PACKET_MULTICAST`` - Packet sent to a physical-layer multicast address."
msgstr ""
"``PACKET_MULTICAST`` - Paquete enviado a una dirección de multidifusión de "
"capa física."

#: ../Doc/library/socket.rst:199
msgid ""
"``PACKET_OTHERHOST`` - Packet to some other host that has been caught by a "
"device driver in promiscuous mode."
msgstr ""
"``PACKET_OTHERHOST`` - Paquete a otro host que haya sido capturado por un "
"controlador de dispositivo en modo promiscuo."

#: ../Doc/library/socket.rst:201
msgid ""
"``PACKET_OUTGOING`` - Packet originating from the local host that is looped "
"back to a packet socket."
msgstr ""
"``PACKET_OUTGOING`` - Paquete originalmente desde el local host que se "
"enlaza de nuevo a un conector de paquetes."

#: ../Doc/library/socket.rst:203
msgid "*hatype* - Optional integer specifying the ARP hardware address type."
msgstr ""
"*hatype* - Entero opcional que especifica el tipo de dirección de hardware "
"ARP."

#: ../Doc/library/socket.rst:204
msgid ""
"*addr* - Optional bytes-like object specifying the hardware physical "
"address, whose interpretation depends on the device."
msgstr ""
"*addr* - Objeto opcional en forma de bytes que especifica la dirección "
"física del hardware, cuya interpretación depende del dispositivo."

#: ../Doc/library/socket.rst:209
msgid ""
":const:`AF_QIPCRTR` is a Linux-only socket based interface for communicating "
"with services running on co-processors in Qualcomm platforms. The address "
"family is represented as a ``(node, port)`` tuple where the *node* and "
"*port* are non-negative integers."
msgstr ""
":const:`AF_QIPCRTR` es una interfaz basada en sockets solo para Linux para "
"comunicarse con servicios que se ejecutan en co-procesadores en plataformas "
"Qualcomm. La familia de direcciones se representa como una tupla ``(node, "
"port)`` donde el *node* y *port* son enteros no negativos."

#: ../Doc/library/socket.rst:218
msgid ""
":const:`IPPROTO_UDPLITE` is a variant of UDP which allows you to specify "
"what portion of a packet is covered with the checksum. It adds two socket "
"options that you can change. ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_SEND_CSCOV, length)`` will change what portion of outgoing packets "
"are covered by the checksum and ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_RECV_CSCOV, length)`` will filter out packets which cover too little "
"of their data. In both cases ``length`` should be in ``range(8, 2**16, 8)``."
msgstr ""
":const:`IPPROTO_UDPLITE` es una variante de UDO que te permite especificar "
"que porción del paquete es cubierta con la suma de comprobación. Esto agrega "
"dos opciones al socket que pueden cambiar. ``self."
"setsockopt(IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV, length)`` cambiara que parte "
"de los paquetes salientes están cubierta por la suma de comprobación y "
"``self.setsockopt(IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV, length)`` filtrara "
"los paquetes que permitirá cubrir una pequeña parte de tu datos. En ambos "
"casos ``length`` deben estar en ``range(8, 2**16, 8)``."

#: ../Doc/library/socket.rst:227
msgid ""
"Such a socket should be constructed with ``socket(AF_INET, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv4 or ``socket(AF_INET6, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv6."
msgstr ""
"Tal socket debe construirse como ``socket(AF_INET, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` para IPV4 o ``socket(AF_INET6, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` para IPV6."

#: ../Doc/library/socket.rst:235
msgid ""
"If you use a hostname in the *host* portion of IPv4/v6 socket address, the "
"program may show a nondeterministic behavior, as Python uses the first "
"address returned from the DNS resolution.  The socket address will be "
"resolved differently into an actual IPv4/v6 address, depending on the "
"results from DNS resolution and/or the host configuration.  For "
"deterministic behavior use a numeric address in *host* portion."
msgstr ""
"Si utiliza un nombre de host en la parte *host* de la dirección de socket "
"IPv4/v6, el programa puede mostrar un comportamiento no determinista, ya que "
"Python utiliza la primera dirección devuelta por la resolución DNS.  La "
"dirección del socket se resolverá de manera diferente en una dirección IPv4/"
"v6 real, dependiendo de los resultados de la resolución DNS y/o la "
"configuración del host.  Para un comportamiento determinista, utilice una "
"dirección numérica en la parte *host*."

#: ../Doc/library/socket.rst:242
msgid ""
"All errors raise exceptions.  The normal exceptions for invalid argument "
"types and out-of-memory conditions can be raised. Errors related to socket "
"or address semantics raise :exc:`OSError` or one of its subclasses."
msgstr ""
"Todos los errores generan excepciones. Las excepciones normales para tipos "
"de argumentos inválidos y condiciones de falta de memoria pueden ser "
"lanzadas. Los errores relacionados con la semántica de los sockets o de las "
"direcciones lanzan :exc:`OSError` o una de sus subclases."

#: ../Doc/library/socket.rst:247
msgid ""
"Non-blocking mode is supported through :meth:`~socket.setblocking`.  A "
"generalization of this based on timeouts is supported through :meth:`~socket."
"settimeout`."
msgstr ""
"El modo de no bloqueo es compatible a través de :meth:`~socket."
"setblocking`.  Se admite una generalización de esto basada en los tiempos de "
"espera a través de :meth:`~socket.settimeout`."

#: ../Doc/library/socket.rst:253
msgid "Module contents"
msgstr "Contenido del módulo"

#: ../Doc/library/socket.rst:255
msgid "The module :mod:`socket` exports the following elements."
msgstr "El módulo :mod:`socket` exporta los siguientes elementos."

#: ../Doc/library/socket.rst:259
msgid "Exceptions"
msgstr "Excepciones"

#: ../Doc/library/socket.rst:263
msgid "A deprecated alias of :exc:`OSError`."
msgstr "Un alias en desuso de :exc:`OSError`."

#: ../Doc/library/socket.rst:265
msgid "Following :pep:`3151`, this class was made an alias of :exc:`OSError`."
msgstr ""
"Siguiendo :pep:`3151`, es clase fue creada como un alias de :exc:`OSError`."

#: ../Doc/library/socket.rst:271
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors, i.e. for functions that use *h_errno* in the POSIX C API, including :"
"func:`gethostbyname_ex` and :func:`gethostbyaddr`. The accompanying value is "
"a pair ``(h_errno, string)`` representing an error returned by a library "
"call.  *h_errno* is a numeric value, while *string* represents the "
"description of *h_errno*, as returned by the :c:func:`hstrerror` C function."
msgstr ""
"Una subclase de :exc:`OSError`, esta excepción se produce para los errores "
"relacionados con la dirección, es decir, para las funciones que utilizan "
"*h_errno* en la API de POSIX C, incluidas :func:`gethostbyname_ex` y :func:"
"`gethostbyaddr`. El valor adjunto es un par ``(h_errno, string)`` que "
"representa un error devuelto por una llamada a la biblioteca.  *h_errno* es "
"un valor numérico, mientras que *string* representa la descripción de "
"*h_errno*, devuelta por la función :c:func:`hstrerror` C."

#: ../Doc/library/socket.rst:279 ../Doc/library/socket.rst:292
#: ../Doc/library/socket.rst:305
msgid "This class was made a subclass of :exc:`OSError`."
msgstr "Esta clase fue creada como una subclase de :exc:`OSError`."

#: ../Doc/library/socket.rst:284
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors by :func:`getaddrinfo` and :func:`getnameinfo`. The accompanying "
"value is a pair ``(error, string)`` representing an error returned by a "
"library call.  *string* represents the description of *error*, as returned "
"by the :c:func:`gai_strerror` C function.  The numeric *error* value will "
"match one of the :const:`EAI_\\*` constants defined in this module."
msgstr ""
"Una subclase de :exc:`OSError`, esta excepción se genera por errores "
"relacionados a la dirección por :func:`getaddrinfo` y :func:`getnameinfo`. "
"El valor de acompañamiento es un par ``(error, string)`` representado un "
"error retornado por una llamada de librería. *string* representa la "
"descripción del *error*, tal como es retornado por la función C :c:func:"
"`gai_strerror`. El valor numérico *error* coincide con una de las "
"constantes :const:`EAI_\\*` definidas en este modulo."

#: ../Doc/library/socket.rst:297
msgid "A deprecated alias of :exc:`TimeoutError`."
msgstr "Un alias obsoleto de :exc:`TimeoutError`."

#: ../Doc/library/socket.rst:299
msgid ""
"A subclass of :exc:`OSError`, this exception is raised when a timeout occurs "
"on a socket which has had timeouts enabled via a prior call to :meth:"
"`~socket.settimeout` (or implicitly through :func:`~socket."
"setdefaulttimeout`).  The accompanying value is a string whose value is "
"currently always \"timed out\"."
msgstr ""
"Una subclase de :exc:`OSError`, esta excepción se genera cuando ocurre un "
"*timeout* en un socket que ha tenido tiempos de espera habilitados a través "
"de una llamada previa a :meth:`~socket.settimeout` ( o implícitamente "
"mediante :func:`~socket.setdefaulttimeout`). El valor del acompañamiento es "
"una cadena de caracteres cuyo valor es actualmente siempre “tiempo de "
"espera”."

#: ../Doc/library/socket.rst:308
msgid "This class was made an alias of :exc:`TimeoutError`."
msgstr "Esta clase se convirtió en un alias de :exc:`TimeoutError`."

#: ../Doc/library/socket.rst:313
msgid "Constants"
msgstr "Constantes"

#: ../Doc/library/socket.rst:315
msgid ""
"The AF_* and SOCK_* constants are now :class:`AddressFamily` and :class:"
"`SocketKind` :class:`.IntEnum` collections."
msgstr ""
"Las constantes AF_* y SOCK_* ahora son colecciones: :class:`AddressFamily` "
"y :class:`SocketKind` :class:`.IntEnum`."

#: ../Doc/library/socket.rst:324
msgid ""
"These constants represent the address (and protocol) families, used for the "
"first argument to :func:`.socket`.  If the :const:`AF_UNIX` constant is not "
"defined then this protocol is unsupported.  More constants may be available "
"depending on the system."
msgstr ""
"Estas constantes representan la familias de direcciones (y protocolos), "
"usados para el primer argumento para :func:`.socket`. Si la constante :const:"
"`AF_UNIX` no esta definida entonces este protocolo no es compatible. Mas "
"constantes podrían estar disponibles dependiendo del sistema."

#: ../Doc/library/socket.rst:336
msgid ""
"These constants represent the socket types, used for the second argument to :"
"func:`.socket`.  More constants may be available depending on the system. "
"(Only :const:`SOCK_STREAM` and :const:`SOCK_DGRAM` appear to be generally "
"useful.)"
msgstr ""
"Estas constantes representan los tipos de socket, usadas por el segundo "
"argumento para :func:`.socket`. Mas constante podrían estar disponibles "
"dependiendo del sistema. ( Solamente :const:`SOCK_STREAM` y :const:"
"`SOCK_DGRAM` parecen ser útiles en general.)"

#: ../Doc/library/socket.rst:344
msgid ""
"These two constants, if defined, can be combined with the socket types and "
"allow you to set some flags atomically (thus avoiding possible race "
"conditions and the need for separate calls)."
msgstr ""
"Estas dos constantes, si se definen, se pueden combinar con los tipos de "
"socket y le permiten establecer algunas banderas atómicamente (evitando así "
"posibles condiciones de carrera y la necesidad de llamadas separadas)."

#: ../Doc/library/socket.rst:350
msgid ""
"`Secure File Descriptor Handling <https://udrepper.livejournal.com/20407."
"html>`_ for a more thorough explanation."
msgstr ""
"`Secure File Descriptor Handling <http://udrepper.livejournal.com/20407."
"html>`_ para una explicación más completa."

#: ../Doc/library/socket.rst:354
msgid ":ref:`Availability <availability>`: Linux >= 2.6.27."
msgstr ":ref:`Availability <availability>`: Linux >= 2.6.27."

#: ../Doc/library/socket.rst:372
msgid ""
"Many constants of these forms, documented in the Unix documentation on "
"sockets and/or the IP protocol, are also defined in the socket module. They "
"are generally used in arguments to the :meth:`setsockopt` and :meth:"
"`getsockopt` methods of socket objects.  In most cases, only those symbols "
"that are defined in the Unix header files are defined; for a few symbols, "
"default values are provided."
msgstr ""
"Muchas constantes de estos formularios, documentadas en la documentación de "
"Unix en sockets y/o el protocolo IP, también se definen en el módulo de "
"socket. Generalmente se utilizan en argumentos de los métodos :meth:"
"`setsockopt` y :meth:`getsockopt` de objetos socket.  En la mayoría de los "
"casos, solo se definen los símbolos definidos en los archivos de encabezado "
"Unix; para algunos símbolos, se proporcionan valores predeterminados."

#: ../Doc/library/socket.rst:379
msgid ""
"``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION`` were added."
msgstr ""
"``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION`` han sido agregados."

#: ../Doc/library/socket.rst:383
msgid ""
"On Windows, ``TCP_FASTOPEN``, ``TCP_KEEPCNT`` appear if run-time Windows "
"supports."
msgstr ""
"En Windows, ``TCP_FASTOPEN``, ``TCP_KEEPCNT`` aparecen si el tiempo de "
"ejecución de Windows lo admite."

#: ../Doc/library/socket.rst:387
msgid "``TCP_NOTSENT_LOWAT`` was added."
msgstr "``TCP_NOTSENT_LOWAT`` ha sido agregada."

#: ../Doc/library/socket.rst:390
msgid ""
"On Windows, ``TCP_KEEPIDLE``, ``TCP_KEEPINTVL`` appear if run-time Windows "
"supports."
msgstr ""
"En Windows, ``TCP_KEEPIDLE``, ``TCP_KEEPINTVL`` aparecen si el tiempo de "
"ejecución de Windows lo admite."

#: ../Doc/library/socket.rst:393
msgid ""
"``IP_RECVTOS`` was added.  Added ``TCP_KEEPALIVE``. On MacOS this constant "
"can be used in the same  way that ``TCP_KEEPIDLE`` is used on Linux."
msgstr ""
"Se agregó ``IP_RECVTOS``. Se agregó ``TCP_KEEPALIVE``. En MacOS, esta "
"constante se puede utilizar de la misma forma que ``TCP_KEEPIDLE`` en Linux."

#: ../Doc/library/socket.rst:398
msgid ""
"Added ``TCP_CONNECTION_INFO``. On MacOS this constant can be used in the "
"same way that ``TCP_INFO`` is used on Linux and BSD."
msgstr ""
"Se agregó ``TCP_CONNECTION_INFO``. En MacOS esta constante se puede utilizar "
"de la misma manera que ``TCP_INFO`` se utiliza en Linux y BSD."

#: ../Doc/library/socket.rst:407 ../Doc/library/socket.rst:477
#: ../Doc/library/socket.rst:488
msgid ""
"Many constants of these forms, documented in the Linux documentation, are "
"also defined in the socket module."
msgstr ""
"Muchas constantes de estos formularios, documentadas en la documentación de "
"Linux, también se definen en el módulo de socket."

#: ../Doc/library/socket.rst:411
msgid ":ref:`Availability <availability>`: Linux >= 2.6.25, NetBSD >= 8."
msgstr ":ref:`Availability <availability>`: Linux >= 2.6.25, NetBSD >= 8."

#: ../Doc/library/socket.rst:414
msgid "NetBSD support was added."
msgstr "Se ha agregado compatibilidad con NetBSD."

#: ../Doc/library/socket.rst:420
msgid ""
"CAN_BCM, in the CAN protocol family, is the broadcast manager (BCM) "
"protocol. Broadcast manager constants, documented in the Linux "
"documentation, are also defined in the socket module."
msgstr ""
"CAN_BCM, en la familia de protocolo CAN, es el protocolo del administrador "
"de difusión (BCM. Las constantes del administrador de difusión, documentada "
"en la documentación de Linux, también esta definidos en el modulo socket."

#: ../Doc/library/socket.rst:425 ../Doc/library/socket.rst:460
msgid ":ref:`Availability <availability>`: Linux >= 2.6.25."
msgstr ":ref:`Availability <availability>`: Linux >= 2.6.25."

#: ../Doc/library/socket.rst:427
msgid ""
"The :data:`CAN_BCM_CAN_FD_FRAME` flag is only available on Linux >= 4.8."
msgstr ""
"El indicador :data:`CAN_BCM_CAN_FD_FRAME` esta solamente disponible en Linux "
">= 4.8."

#: ../Doc/library/socket.rst:433
msgid ""
"Enables CAN FD support in a CAN_RAW socket. This is disabled by default. "
"This allows your application to send both CAN and CAN FD frames; however, "
"you must accept both CAN and CAN FD frames when reading from the socket."
msgstr ""
"Habilita la compatibilidad con CAN FD en un socket CAN_RAW. Esta opción está "
"deshabilitada de forma predeterminada. Esto permite que la aplicación envíe "
"tramas CAN y CAN FD; sin embargo, debe aceptar las tramas CAN y CAN FD al "
"leer desde el socket."

#: ../Doc/library/socket.rst:437 ../Doc/library/socket.rst:448
msgid "This constant is documented in the Linux documentation."
msgstr "Esta constante se documenta en la documentación de Linux."

#: ../Doc/library/socket.rst:440
msgid ":ref:`Availability <availability>`: Linux >= 3.6."
msgstr ":ref:`Availability <availability>`: Linux >= 3.6."

#: ../Doc/library/socket.rst:445
msgid ""
"Joins the applied CAN filters such that only CAN frames that match all given "
"CAN filters are passed to user space."
msgstr ""
"Se une a los filtros CAN aplicados de modo que solo las tramas CAN que "
"coinciden con todos los filtros CAN dados se pasan al espacio del usuario."

#: ../Doc/library/socket.rst:451
msgid ":ref:`Availability <availability>`: Linux >= 4.1."
msgstr ":ref:`Availability <availability>`: Linux >= 4.1."

#: ../Doc/library/socket.rst:456
msgid ""
"CAN_ISOTP, in the CAN protocol family, is the ISO-TP (ISO 15765-2) protocol. "
"ISO-TP constants, documented in the Linux documentation."
msgstr ""
"CAN_ISOTP, en el protocolo de familia CAN, es el protocolo  ISO-TP (ISO "
"15765-2). Constantes ISO-TP, documentadas en la documentación Linux."

#: ../Doc/library/socket.rst:465
msgid ""
"CAN_J1939, in the CAN protocol family, is the SAE J1939 protocol. J1939 "
"constants, documented in the Linux documentation."
msgstr ""
"CAN_J1939, en el protocolo de familias CAN, es el protocolo SAE J1939. "
"Constantes J1939, documentadas en el documentación Linux."

#: ../Doc/library/socket.rst:469
msgid ":ref:`Availability <availability>`: Linux >= 5.4."
msgstr ":ref:`Availability <availability>`: Linux >= 5.4."

#: ../Doc/library/socket.rst:480
msgid ":ref:`Availability <availability>`: Linux >= 2.2."
msgstr ":ref:`Availability <availability>`: Linux >= 2.2."

#: ../Doc/library/socket.rst:492
msgid ":ref:`Availability <availability>`: Linux >= 2.6.30."
msgstr ":ref:`Availability <availability>`: Linux >= 2.6.30."

#: ../Doc/library/socket.rst:501
msgid ""
"Constants for Windows' WSAIoctl(). The constants are used as arguments to "
"the :meth:`~socket.socket.ioctl` method of socket objects."
msgstr ""
"Constantes para Windows’ WSAIoctl(). Las constantes se utiliza como "
"argumentos al método :meth:`~socket.socket.ioctl` de objetos de sockets."

#: ../Doc/library/socket.rst:504 ../Doc/library/socket.rst:1458
msgid "``SIO_LOOPBACK_FAST_PATH`` was added."
msgstr "``SIO_LOOPBACK_FAST_PATH`` ha sido agregado."

#: ../Doc/library/socket.rst:510
msgid ""
"TIPC related constants, matching the ones exported by the C socket API. See "
"the TIPC documentation for more information."
msgstr ""
"LAS constantes relacionadas con TIPC, que coinciden con las exportadas por "
"la API de socket de C. Consulte la documentación de TIPC para obtener más "
"información."

#: ../Doc/library/socket.rst:517
msgid "Constants for Linux Kernel cryptography."
msgstr "Constantes para la criptográfica del Kernel de Linux."

#: ../Doc/library/socket.rst:520 ../Doc/library/socket.rst:1767
msgid ":ref:`Availability <availability>`: Linux >= 2.6.38."
msgstr ":ref:`Availability <availability>`: Linux >= 2.6.38."

#: ../Doc/library/socket.rst:529
msgid "Constants for Linux host/guest communication."
msgstr "Constantes para la comunicación host/invitado de Linux."

#: ../Doc/library/socket.rst:532
msgid ":ref:`Availability <availability>`: Linux >= 4.8."
msgstr ":ref:`Availability <availability>`: Linux >= 4.8."

#: ../Doc/library/socket.rst:538
msgid ":ref:`Availability <availability>`: BSD, macOS."
msgstr ":ref:`Availability <availability>`: BSD, macOS."

#: ../Doc/library/socket.rst:543
msgid ""
"This constant contains a boolean value which indicates if IPv6 is supported "
"on this platform."
msgstr ""
"Esta constante contiene un valor booleano que indica si IPv6 se admite en "
"esta plataforma."

#: ../Doc/library/socket.rst:549
msgid ""
"These are string constants containing Bluetooth addresses with special "
"meanings. For example, :const:`BDADDR_ANY` can be used to indicate any "
"address when specifying the binding socket with :const:`BTPROTO_RFCOMM`."
msgstr ""
"Estas son constantes de cadenas que contienen direcciones Bluetooth con "
"significados especiales. Por ejemplo :const:`BDADDR_ANY` son usados para "
"indicar cualquier dirección al especificar el socket vinculante con :const:"
"`BTPROTO_RFCOMM`."

#: ../Doc/library/socket.rst:558
msgid ""
"For use with :const:`BTPROTO_HCI`. :const:`HCI_FILTER` is not available for "
"NetBSD or DragonFlyBSD. :const:`HCI_TIME_STAMP` and :const:`HCI_DATA_DIR` "
"are not available for FreeBSD, NetBSD, or DragonFlyBSD."
msgstr ""
"Para usar con :const:`BTPROTO_HCI`. :const:`HCI_FILTER` no esta disponible "
"para NetBSD o DragonFlyBSD. :const:`HCI_TIME_STAMP` y :const:`HCI_DATA_DIR` "
"no esta disponible para FreeBSD, NetBSD, o DragonFlyBSD."

#: ../Doc/library/socket.rst:565
msgid ""
"Constant for Qualcomm's IPC router protocol, used to communicate with "
"service providing remote processors."
msgstr ""
"Constante para el protocolo de router IPC de Qualcomm, que se utiliza para "
"comunicarse con procesadores remotos que brindan servicios."

#: ../Doc/library/socket.rst:568
msgid ":ref:`Availability <availability>`: Linux >= 4.7."
msgstr ":ref:`Availability <availability>`: Linux >= 4.7."

#: ../Doc/library/socket.rst:574
msgid ""
"LOCAL_CREDS and LOCAL_CREDS_PERSISTENT can be used with SOCK_DGRAM, "
"SOCK_STREAM sockets, equivalent to Linux/DragonFlyBSD SO_PASSCRED, while "
"LOCAL_CREDS sends the credentials at first read, LOCAL_CREDS_PERSISTENT "
"sends for each read, SCM_CREDS2 must be then used for the latter for the "
"message type."
msgstr ""
"LOCAL_CREDS y LOCAL_CREDS_PERSISTENT pueden usarse con sockets SOCK_DGRAM, "
"SOCK_STREAM, equivalente a Linux/DragonFlyBSD SO_PASSCRED, mientras que "
"LOCAL_CREDS envía las credenciales en la primera lectura, "
"LOCAL_CREDS_PERSISTENT envía para cada lectura, SCM_CREDS2 debe entonces ser "
"usado para este último para el tipo de mensaje."

#: ../Doc/library/socket.rst:583
msgid ":ref:`Availability <availability>`: FreeBSD."
msgstr ":ref:`Availability <availability>`: FreeBSD."

#: ../Doc/library/socket.rst:587
msgid ""
"Constant to optimize CPU locality, to be used in conjunction with :data:"
"`SO_REUSEPORT`."
msgstr ""
"Constante para optimizar la localidad CPU, a ser usada en conjunto con :data:"
"`SO_REUSEPORT`."

#: ../Doc/library/socket.rst:592
msgid ":ref:`Availability <availability>`: Linux >= 3.9"
msgstr ":ref:`Availability <availability>`: Linux >= 3.9"

#: ../Doc/library/socket.rst:595
msgid "Functions"
msgstr "Funciones"

#: ../Doc/library/socket.rst:598
msgid "Creating sockets"
msgstr "Creación de sockets"

#: ../Doc/library/socket.rst:600
msgid ""
"The following functions all create :ref:`socket objects <socket-objects>`."
msgstr ""
"Todas las siguientes funciones crean :ref:`socket objects <socket-objects>`."

#: ../Doc/library/socket.rst:605
msgid ""
"Create a new socket using the given address family, socket type and protocol "
"number.  The address family should be :const:`AF_INET` (the default), :const:"
"`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, :const:`AF_PACKET`, or :const:"
"`AF_RDS`. The socket type should be :const:`SOCK_STREAM` (the default), :"
"const:`SOCK_DGRAM`, :const:`SOCK_RAW` or perhaps one of the other ``SOCK_`` "
"constants. The protocol number is usually zero and may be omitted or in the "
"case where the address family is :const:`AF_CAN` the protocol should be one "
"of :const:`CAN_RAW`, :const:`CAN_BCM`, :const:`CAN_ISOTP` or :const:"
"`CAN_J1939`."
msgstr ""
"Crear un nuevo socket usando la dirección de familia dada, tipo de socket y "
"el numero de protocolo. La dirección de familia debería ser :const:`AF_INET` "
"(por defecto), :const:`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, :const:"
"`AF_PACKET`, o :const:`AF_RDS`. El tipo de socket debería ser :const:"
"`SOCK_STREAM` (por defecto), :const:`SOCK_DGRAM`, :const:`SOCK_RAW` o quizás "
"una de las otras constantes ``SOCK_``. El numero de protocolo es usualmente "
"cero u omitirse o en el caso donde la familia de dirección es :const:"
"`AF_CAN` el protocolo debería ser uno de :const:`CAN_RAW`, :const:"
"`CAN_BCM`, :const:`CAN_ISOTP` o :const:`CAN_J1939`."

#: ../Doc/library/socket.rst:615
msgid ""
"If *fileno* is specified, the values for *family*, *type*, and *proto* are "
"auto-detected from the specified file descriptor.  Auto-detection can be "
"overruled by calling the function with explicit *family*, *type*, or *proto* "
"arguments.  This only affects how Python represents e.g. the return value "
"of :meth:`socket.getpeername` but not the actual OS resource.  Unlike :func:"
"`socket.fromfd`, *fileno* will return the same socket and not a duplicate. "
"This may help close a detached socket using :meth:`socket.close()`."
msgstr ""
"Si *fileno* esta especificado, el valor de *family*, *type*, y *proto* son "
"detectados automáticamente por el descriptor especificado de archivo. La "
"detección automática se puede anular llamado la función con los argumentos "
"explícitos *family*, *type*, o *proto*. Esto solamente afecta como Python "
"representa e.g. el valor de retorno de  :meth:`socket.getpeername` pero no "
"del recurso actual del OS. Diferente a  :func:`socket.fromfd`, *fileno* "
"retornara el mismo socket y no un duplicado. Esto puede ayudar a cerrar un "
"socket desconectado usando :meth:`socket.close()`."

#: ../Doc/library/socket.rst:624 ../Doc/library/socket.rst:770
#: ../Doc/library/socket.rst:1277 ../Doc/library/socket.rst:1371
msgid "The newly created socket is :ref:`non-inheritable <fd_inheritance>`."
msgstr "El socket recién creado es :ref:`non-inheritable <fd_inheritance>`."

#: ../Doc/library/socket.rst:635
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.__new__`` with arguments "
"``self``, ``family``, ``type``, ``protocol``."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.__new__`` con los "
"argumentos ``self``, ``family``, ``type``, ``protocol``."

#: ../Doc/library/socket.rst:628
msgid "The AF_CAN family was added. The AF_RDS family was added."
msgstr "Se añadió la familia AF_CAN. Se añadió la familia AF_RDS."

#: ../Doc/library/socket.rst:632
msgid "The CAN_BCM protocol was added."
msgstr "El protocolo CAN_BCM ha sido agregado."

#: ../Doc/library/socket.rst:635 ../Doc/library/socket.rst:772
msgid "The returned socket is now non-inheritable."
msgstr "Los sockets devueltos ahora no son heredables."

#: ../Doc/library/socket.rst:638
msgid "The CAN_ISOTP protocol was added."
msgstr "El protocolo CAN_ISOTP ha sido agregado."

#: ../Doc/library/socket.rst:641
msgid ""
"When :const:`SOCK_NONBLOCK` or :const:`SOCK_CLOEXEC` bit flags are applied "
"to *type* they are cleared, and :attr:`socket.type` will not reflect them.  "
"They are still passed to the underlying system ``socket()`` call.  Therefore,"
msgstr ""
"Cuando las banderas bit :const:`SOCK_NONBLOCK` or :const:`SOCK_CLOEXEC` "
"están aplicadas a *type*, se borran, y :attr:`socket.type` no las reflejará. "
"Igual se pasan a la llamada `socket ()` del sistema subyacente. Por lo tanto,"

#: ../Doc/library/socket.rst:653
msgid ""
"will still create a non-blocking socket on OSes that support "
"``SOCK_NONBLOCK``, but ``sock.type`` will be set to ``socket.SOCK_STREAM``."
msgstr ""
"seguirá creando un socket sin bloqueo en los sistemas operativos que admiten "
"``SOCK_NONBLOCK``, pero ``sock.type`` se establecerá en ``socket."
"SOCK_STREAM``."

#: ../Doc/library/socket.rst:657
msgid "The CAN_J1939 protocol was added."
msgstr "El protocolo CAN_J1939 ha sido agregado."

#: ../Doc/library/socket.rst:660
msgid "The IPPROTO_MPTCP protocol was added."
msgstr "Se agregó el protocolo IPPROTO_MPTCP."

#: ../Doc/library/socket.rst:665
msgid ""
"Build a pair of connected socket objects using the given address family, "
"socket type, and protocol number.  Address family, socket type, and protocol "
"number are as for the :func:`.socket` function above. The default family is :"
"const:`AF_UNIX` if defined on the platform; otherwise, the default is :const:"
"`AF_INET`."
msgstr ""
"Cree un par de objetos de socket conectados utilizando la familia de "
"direcciones, el tipo de socket y el número de protocolo especificados.  La "
"familia de direcciones, el tipo de socket y el número de protocolo son los "
"siguientes para la función :func:`.socket` anterior. La familia "
"predeterminada es :const:`AF_UNIX` si se define en la plataforma; de lo "
"contrario, el valor predeterminado es :const:`AF_INET`."

#: ../Doc/library/socket.rst:670
msgid "The newly created sockets are :ref:`non-inheritable <fd_inheritance>`."
msgstr ""
"Los sockets creados recientemente son :ref:`non-inheritable "
"<fd_inheritance>`."

#: ../Doc/library/socket.rst:672
msgid ""
"The returned socket objects now support the whole socket API, rather than a "
"subset."
msgstr ""
"Los objetos de socket devueltos ahora admiten toda la API de socket, en "
"lugar de un subconjunto."

#: ../Doc/library/socket.rst:676
msgid "The returned sockets are now non-inheritable."
msgstr "Los sockets devueltos ahora no son heredables."

#: ../Doc/library/socket.rst:679
msgid "Windows support added."
msgstr "Se ha agregado compatibilidad con Windows."

#: ../Doc/library/socket.rst:685
msgid ""
"Connect to a TCP service listening on the internet *address* (a 2-tuple "
"``(host, port)``), and return the socket object.  This is a higher-level "
"function than :meth:`socket.connect`: if *host* is a non-numeric hostname, "
"it will try to resolve it for both :data:`AF_INET` and :data:`AF_INET6`, and "
"then try to connect to all possible addresses in turn until a connection "
"succeeds.  This makes it easy to write clients that are compatible to both "
"IPv4 and IPv6."
msgstr ""
"Se conecta a un servicio TCP que esté escuchando en Internet *address* (un "
"``(host, port)`` de 2 tuplas) y retorna el objeto de socket. Esta es una "
"función de nivel superior que :meth:`socket.connect`: si *host* es un nombre "
"de host no numérico, intentará resolverlo para :data:`AF_INET` y :data:"
"`AF_INET6`, y luego intentará conectarse a todas las direcciones posibles "
"sucesivamente hasta que la conexión se realice correctamente. Esto facilita "
"la escritura de clientes que sean compatibles con IPv4 e IPv6."

#: ../Doc/library/socket.rst:693
msgid ""
"Passing the optional *timeout* parameter will set the timeout on the socket "
"instance before attempting to connect.  If no *timeout* is supplied, the "
"global default timeout setting returned by :func:`getdefaulttimeout` is used."
msgstr ""
"Pasando el parámetro opcional *timeout* establece el tiempo de espera dentro "
"de la instancia del socket. Si no es proporcionado *timeout*, la "
"configuración global de tiempo de espera predeterminada retornada por :func:"
"`getdefaulttimeout` es usada."

#: ../Doc/library/socket.rst:698
msgid ""
"If supplied, *source_address* must be a 2-tuple ``(host, port)`` for the "
"socket to bind to as its source address before connecting.  If host or port "
"are '' or 0 respectively the OS default behavior will be used."
msgstr ""
"Si se suministra, *source_address* debe ser una ''(host, puerto)'' de 2 "
"tuplas para que el socket se enlace como su dirección de origen antes de "
"conectarse.  Si el host o el puerto son '' o 0 respectivamente, se utilizará "
"el comportamiento predeterminado del sistema operativo."

#: ../Doc/library/socket.rst:702
msgid ""
"When a connection cannot be created, an exception is raised. By default, it "
"is the exception from the last address in the list. If *all_errors* is "
"``True``, it is an :exc:`ExceptionGroup` containing the errors of all "
"attempts."
msgstr ""
"Cuando una conexión no puede ser creada, se lanza una exception. Por "
"defecto, es la excepción de la última dirección en la lista. Si *all_errors* "
"es ``True``, es un :exc:`ExceptionGroup` conteniendo los errores de todos "
"los intentos."

#: ../Doc/library/socket.rst:707
msgid "*source_address* was added."
msgstr "*source_address* ha sido agregado."

#: ../Doc/library/socket.rst:710
msgid "*all_errors* was added."
msgstr "*all_errors* ha sido agregado."

#: ../Doc/library/socket.rst:716
msgid ""
"Convenience function which creates a TCP socket bound to *address* (a 2-"
"tuple ``(host, port)``) and return the socket object."
msgstr ""
"Función de conveniencia que crea un socket TCP enlazado a *address* (una "
"tupla de 2 ``(host, puerto)``) y devuelve el objeto de socket."

#: ../Doc/library/socket.rst:719
msgid ""
"*family* should be either :data:`AF_INET` or :data:`AF_INET6`. *backlog* is "
"the queue size passed to :meth:`socket.listen`; when ``0`` a default "
"reasonable value is chosen. *reuse_port* dictates whether to set the :data:"
"`SO_REUSEPORT` socket option."
msgstr ""
"*family* debe ser :data:`AF_INET` o :data:`AF_INET6`. *backlog* es el tamaño "
"de la cola pasado a :meth:`socket.listen`; cuando ``0`` se elige un valor "
"predeterminado razonable. *reuse_port* dicta si se debe establecer la opción "
"de socket :data:`SO_REUSEPORT`."

#: ../Doc/library/socket.rst:724
msgid ""
"If *dualstack_ipv6* is true and the platform supports it the socket will be "
"able to accept both IPv4 and IPv6 connections, else it will raise :exc:"
"`ValueError`. Most POSIX platforms and Windows are supposed to support this "
"functionality. When this functionality is enabled the address returned by :"
"meth:`socket.getpeername` when an IPv4 connection occurs will be an IPv6 "
"address represented as an IPv4-mapped IPv6 address. If *dualstack_ipv6* is "
"false it will explicitly disable this functionality on platforms that enable "
"it by default (e.g. Linux). This parameter can be used in conjunction with :"
"func:`has_dualstack_ipv6`:"
msgstr ""
"Si *dualstack_ipv6* es true y la plataforma lo admite el socket podrá "
"aceptar conexiones IPv4 e IPv6, de lo contrario lanzará :exc:`ValueError`. "
"Se supone que la mayoría de las plataformas POSIX y Windows admiten esta "
"funcionalidad. Cuando esta funcionalidad está habilitada, la dirección "
"devuelta por :meth:`socket.getpeername` cuando se produce una conexión IPv4 "
"será una dirección IPv6 representada como una dirección IPv4 asignada6. Si "
"*dualstack_ipv6* es false, deshabilitará explícitamente esta funcionalidad "
"en las plataformas que la habilitan de forma predeterminada (por ejemplo, "
"Linux). Este parámetro se puede utilizar junto con :func:"
"`has_dualstack_ipv6`:"

#: ../Doc/library/socket.rst:746
msgid ""
"On POSIX platforms the :data:`SO_REUSEADDR` socket option is set in order to "
"immediately reuse previous sockets which were bound on the same *address* "
"and remained in TIME_WAIT state."
msgstr ""
"En plataformas POSIX la opción del socket :data:`SO_REUSEADDR` está "
"configurado para inmediatamente rehusar los sockets previos que estaban "
"vinculados la misma *address* y permanecer en estado TIME_WAIT."

#: ../Doc/library/socket.rst:754
msgid ""
"Return ``True`` if the platform supports creating a TCP socket which can "
"handle both IPv4 and IPv6 connections."
msgstr ""
"Retorna ``True`` si la plataforma admite la creación de un socket TCP que "
"pueda manejar conexiones IPv4 e IPv6."

#: ../Doc/library/socket.rst:761
msgid ""
"Duplicate the file descriptor *fd* (an integer as returned by a file "
"object's :meth:`fileno` method) and build a socket object from the result.  "
"Address family, socket type and protocol number are as for the :func:`."
"socket` function above. The file descriptor should refer to a socket, but "
"this is not checked --- subsequent operations on the object may fail if the "
"file descriptor is invalid. This function is rarely needed, but can be used "
"to get or set socket options on a socket passed to a program as standard "
"input or output (such as a server started by the Unix inet daemon).  The "
"socket is assumed to be in blocking mode."
msgstr ""
"Duplica el descriptor de archivo *fd* (un entero retornado por el método :"
"meth:`fileno` de un objeto archivo) y crea un objeto socket a partir del "
"resultado.  La familia de direcciones, el tipo de socket y el número de "
"protocolo son como para la función :func:`.socket` anterior. El descriptor "
"de archivo debe hacer referencia a un socket, pero esto no se comprueba --- "
"las operaciones posteriores en el objeto pueden fallar si el descriptor de "
"archivo no es válido. Esta función rara vez se necesita, pero se puede usar "
"para obtener o establecer opciones de socket en un socket pasado a un "
"programa como entrada o salida estándar (como un servidor iniciado por el "
"demonio inet de Unix).  Se supone que el socket está en modo de bloqueo."

#: ../Doc/library/socket.rst:778
msgid ""
"Instantiate a socket from data obtained from the :meth:`socket.share` "
"method.  The socket is assumed to be in blocking mode."
msgstr ""
"Cree una instancia de un socket a partir de los datos obtenidos del método :"
"meth:`socket.share`.  Se supone que el socket está en modo de bloqueo."

#: ../Doc/library/socket.rst:782 ../Doc/library/socket.rst:1873
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Availability <availability>`: Windows."

#: ../Doc/library/socket.rst:788
msgid ""
"This is a Python type object that represents the socket object type. It is "
"the same as ``type(socket(...))``."
msgstr ""
"Este es un tipo de objeto Python que representa el tipo de objeto del "
"socket. Es lo mismo que decir ``type(socket(…))``."

#: ../Doc/library/socket.rst:793
msgid "Other functions"
msgstr "Otras funciones"

#: ../Doc/library/socket.rst:795
msgid "The :mod:`socket` module also offers various network-related services:"
msgstr ""
"El modulo :mod:`socket` también ofrece varios servicios de red relacionados:"

#: ../Doc/library/socket.rst:800
msgid ""
"Close a socket file descriptor. This is like :func:`os.close`, but for "
"sockets. On some platforms (most noticeable Windows) :func:`os.close` does "
"not work for socket file descriptors."
msgstr ""
"Cierre un descriptor de archivo de socket. Esto es como :func:`os.close`, "
"pero para sockets. En algunas plataformas (la mayoría notable de Windows) :"
"func:`os.close` no funciona para descriptores de archivos de socket."

#: ../Doc/library/socket.rst:808
msgid ""
"Translate the *host*/*port* argument into a sequence of 5-tuples that "
"contain all the necessary arguments for creating a socket connected to that "
"service. *host* is a domain name, a string representation of an IPv4/v6 "
"address or ``None``. *port* is a string service name such as ``'http'``, a "
"numeric port number or ``None``.  By passing ``None`` as the value of *host* "
"and *port*, you can pass ``NULL`` to the underlying C API."
msgstr ""
"Traduce el argumento *host*/*port* dentro de una secuencia de 5 tuplas que "
"contiene todo los argumentos necesarios para crear un socket conectado a ese "
"servicio. *host* es un nombre de dominio, una cadena en representación de "
"una dirección IPV4/IPV6 o ``None``. *port* es una nombre de una cadena de "
"servicio como ``'http'``, un numero de puerto numérico o ``None``. Pasando "
"``None`` como el valor del  *host* y *port*, pasando ``NULL`` a la API C "
"subyacente."

#: ../Doc/library/socket.rst:815
msgid ""
"The *family*, *type* and *proto* arguments can be optionally specified in "
"order to narrow the list of addresses returned.  Passing zero as a value for "
"each of these arguments selects the full range of results. The *flags* "
"argument can be one or several of the ``AI_*`` constants, and will influence "
"how results are computed and returned. For example, :const:`AI_NUMERICHOST` "
"will disable domain name resolution and will raise an error if *host* is a "
"domain name."
msgstr ""
"Los argumentos *family*, *type* y *proto* se puede especificar opcionalmente "
"para reducir la lista de direcciones retornadas. Pasando cero como un valor "
"para cada uno de estos argumentos se selecciona la gama completa de "
"resultados. El argumento *flags* puede ser uno o varios de los argumentos "
"``AI_*``, y pueden influenciar como los resultados son computados y "
"devueltos. Por ejemplo, :const:`AI_NUMERICHOST` desactivará la resolución de "
"nombres de dominio y lanzará un error sí *host* es un nombre de dominio."

#: ../Doc/library/socket.rst:823
msgid "The function returns a list of 5-tuples with the following structure:"
msgstr "La función devuelve una lista de 5 tuplas con la siguiente estructura:"

#: ../Doc/library/socket.rst:825
msgid "``(family, type, proto, canonname, sockaddr)``"
msgstr "``(family, type, proto, canonname, sockaddr)``"

#: ../Doc/library/socket.rst:827
msgid ""
"In these tuples, *family*, *type*, *proto* are all integers and are meant to "
"be passed to the :func:`.socket` function.  *canonname* will be a string "
"representing the canonical name of the *host* if :const:`AI_CANONNAME` is "
"part of the *flags* argument; else *canonname* will be empty.  *sockaddr* is "
"a tuple describing a socket address, whose format depends on the returned "
"*family* (a ``(address, port)`` 2-tuple for :const:`AF_INET`, a ``(address, "
"port, flowinfo, scope_id)`` 4-tuple for :const:`AF_INET6`), and is meant to "
"be passed to the :meth:`socket.connect` method."
msgstr ""
"En estas tuplas, *family*, *type*, *proto* son todos enteros y están "
"destinados a ser pasados por la función :func:`.socket`.  *canonname* debe "
"ser una cadena que representa el nombre canónico del *host* si :const:"
"`AI_CANONNAME` es parte de el argumento *flags*; de lo contrario *canonname* "
"estará vacía.  *sockaddr* es un tupla describiendo una dirección de socket, "
"cuyo formato depende del devuelto *family* (una ``(address, port)`` tupla de "
"2 para :const:`AF_INET`, una ``(address, port, flowinfo, scope_id)`` una "
"tupla de 4 para una :const:`AF_INET6`), y está destinado a ser pasado a el "
"método :meth:`socket.connect`."

#: ../Doc/library/socket.rst:846
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getaddrinfo`` with "
"arguments ``host``, ``port``, ``family``, ``type``, ``protocol``."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.getaddrinfo`` con los "
"argumentos ``host``, ``port``, ``family``, ``type``, ``protocol``."

#: ../Doc/library/socket.rst:839
msgid ""
"The following example fetches address information for a hypothetical TCP "
"connection to ``example.org`` on port 80 (results may differ on your system "
"if IPv6 isn't enabled)::"
msgstr ""
"En el ejemplo siguiente se obtiene información de dirección para una "
"conexión TCP hipotética a ``example.org`` en el puerto 80 (los resultados "
"pueden diferir en el sistema si IPv6 no está habilitado)::"

#: ../Doc/library/socket.rst:849
msgid "parameters can now be passed using keyword arguments."
msgstr ""
"los parámetros ahora se pueden pasar mediante argumentos de palabra clave."

#: ../Doc/library/socket.rst:852
#, python-format
msgid ""
"for IPv6 multicast addresses, string representing an address will not "
"contain ``%scope_id`` part."
msgstr ""
"para direcciones de multidifusión IPv6, la cadena que representa una "
"dirección no contendrá partes ``%scope_id``."

#: ../Doc/library/socket.rst:858
msgid ""
"Return a fully qualified domain name for *name*. If *name* is omitted or "
"empty, it is interpreted as the local host.  To find the fully qualified "
"name, the hostname returned by :func:`gethostbyaddr` is checked, followed by "
"aliases for the host, if available.  The first name which includes a period "
"is selected.  In case no fully qualified domain name is available and *name* "
"was provided, it is returned unchanged.  If *name* was empty or equal to "
"``'0.0.0.0'``, the hostname from :func:`gethostname` is returned."
msgstr ""
"Retorna un nombre de dominio completo para *name*. Si *name* se omite o está "
"vacío, se interpreta como el host local. Para encontrar el nombre completo, "
"se comprueba el nombre de host retornado por :func:`gethostbyaddr`, seguido "
"de los alias del host, si están disponibles. Se selecciona el primer nombre "
"que incluye un punto. En caso de que no haya disponible un nombre de dominio "
"completo y se haya proporcionado *name*, se retorna sin cambios. Si *name* "
"estaba vacío o era igual a ``'0.0.0.0'``, se retorna el nombre de host de :"
"func:`gethostname`."

#: ../Doc/library/socket.rst:869
msgid ""
"Translate a host name to IPv4 address format.  The IPv4 address is returned "
"as a string, such as  ``'100.50.200.5'``.  If the host name is an IPv4 "
"address itself it is returned unchanged.  See :func:`gethostbyname_ex` for a "
"more complete interface. :func:`gethostbyname` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"Traduce un nombre de host a un formato de dirección IPV4. La dirección IPV4 "
"es retornada como una cadena, como ``’100.50.200.5’``. Si el nombre de host "
"es una dirección IPV4 en sí, se devuelve sin cambios. Observa :func:"
"`gethostbyname_ex` para una interfaz mas completa. :func:`gethostbyname` no "
"soporta la resolución de nombres IPV6, y :func:`getaddrinfo` debe utilizarse "
"en su lugar para compatibilidad con doble pila IPv4/v6."

#: ../Doc/library/socket.rst:884 ../Doc/library/socket.rst:900
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyname`` with "
"argument ``hostname``."
msgstr ""
"Genera un evento :ref:`auditing <auditing>` ``socket.gethostbyname`` con el "
"argumento ``hostname``."

#: ../Doc/library/socket.rst:877 ../Doc/library/socket.rst:893
#: ../Doc/library/socket.rst:906 ../Doc/library/socket.rst:921
#: ../Doc/library/socket.rst:938 ../Doc/library/socket.rst:949
#: ../Doc/library/socket.rst:960 ../Doc/library/socket.rst:971
#: ../Doc/library/socket.rst:1295 ../Doc/library/socket.rst:1342
#: ../Doc/library/socket.rst:1356 ../Doc/library/socket.rst:1376
#: ../Doc/library/socket.rst:1423 ../Doc/library/socket.rst:1469
#: ../Doc/library/socket.rst:1850 ../Doc/library/socket.rst:1860
#, fuzzy
msgid ":ref:`Availability <availability>`: not WASI."
msgstr ":ref:`Availability <availability>`: no WASI."

#: ../Doc/library/socket.rst:882
msgid ""
"Translate a host name to IPv4 address format, extended interface. Return a "
"triple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is the host's "
"primary host name, *aliaslist* is a (possibly empty) list of alternative "
"host names for the same address, and *ipaddrlist* is a list of IPv4 "
"addresses for the same interface on the same host (often but not always a "
"single address). :func:`gethostbyname_ex` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"Traduce un nombre de host al formato de dirección IPv4, interfaz ampliada. "
"Retorna un triple ``(hostname, aliaslist, ipaddrlist)`` donde *hostname* es "
"el nombre de host principal del host, *aliaslist* es una lista (posiblemente "
"vacía) de nombres de host alternativos para la misma dirección y "
"*ipaddrlist* es una lista de direcciones IPv4 para la misma interfaz en el "
"mismo host (a menudo, pero no siempre una sola dirección). :func:"
"`gethostbyname_ex` no es compatible con la resolución de nombres IPv6 y, en "
"su lugar, se debe utilizar :func:`getaddrinfo` para el soporte de pila dual "
"IPv4 / v6."

#: ../Doc/library/socket.rst:898
msgid ""
"Return a string containing the hostname of the machine where  the Python "
"interpreter is currently executing."
msgstr ""
"Retorna una cadena que contenga el nombre de host de la máquina donde se "
"está ejecutando actualmente el intérprete de Python."

#: ../Doc/library/socket.rst:910
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostname`` with no "
"arguments."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.gethostname`` sin "
"argumentos."

#: ../Doc/library/socket.rst:903
msgid ""
"Note: :func:`gethostname` doesn't always return the fully qualified domain "
"name; use :func:`getfqdn` for that."
msgstr ""
"Nota: :func:`gethostname` no siempre retorna el nombre de dominio completo, "
"usa :func:`getfqdn` para eso."

#: ../Doc/library/socket.rst:911
msgid ""
"Return a triple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is "
"the primary host name responding to the given *ip_address*, *aliaslist* is a "
"(possibly empty) list of alternative host names for the same address, and "
"*ipaddrlist* is a list of IPv4/v6 addresses for the same interface on the "
"same host (most likely containing only a single address). To find the fully "
"qualified domain name, use the function :func:`getfqdn`. :func:"
"`gethostbyaddr` supports both IPv4 and IPv6."
msgstr ""
"Retorna un triple ``(hostname, aliaslist, ipaddrlist)`` donde *hostname* es "
"el nombre del host primario respondiendo de la misma *ip_address*, "
"*aliaslist* es una (posiblemente vacía) lista de nombres de hosts "
"alternativa, y *ipaddrlist* es una lista de direcciones IPV4/IPV6 para la "
"misma interfaz y en el mismo host ( lo más probable es que contenga solo una "
"dirección ). Para encontrar el nombre de dominio completo, use la función :"
"func:`getfqdn`. :func:`gethostbyaddr` admite tanto IPv4 como IPv6."

#: ../Doc/library/socket.rst:928
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyaddr`` with "
"argument ``ip_address``."
msgstr ""
"Generar un :ref:`auditing event <auditing>` ``socket.gethostbyaddr`` con los "
"argumentos ``ip_address``."

#: ../Doc/library/socket.rst:926
msgid ""
"Translate a socket address *sockaddr* into a 2-tuple ``(host, port)``. "
"Depending on the settings of *flags*, the result can contain a fully "
"qualified domain name or numeric address representation in *host*.  "
"Similarly, *port* can contain a string port name or a numeric port number."
msgstr ""
"Traduce una dirección de socket  *sockaddr* en una 2-tupla ``(host, port)``. "
"Dependiendo de la configuraciones de *flags*, el resultado puede contener un "
"nombre de dominio completo o una representación numérica de la dirección en "
"*host*. De igual manera, *port* puede contener un nombre de puerto de cadena "
"de caracteres o un numero de puerto numérico."

#: ../Doc/library/socket.rst:931
#, python-format
msgid ""
"For IPv6 addresses, ``%scope_id`` is appended to the host part if *sockaddr* "
"contains meaningful *scope_id*. Usually this happens for multicast addresses."
msgstr ""
"Para las direcciones IPv6, ``%scope`` se anexa a la parte del host si "
"*sockaddr* contiene *scopeid* significativo. Generalmente esto sucede para "
"las direcciones de multidifusión."

#: ../Doc/library/socket.rst:934
msgid ""
"For more information about *flags* you can consult :manpage:`getnameinfo(3)`."
msgstr ""
"Para mas información sobre *flags* pueden consultar :manpage:"
"`getnameinfo(3)`."

#: ../Doc/library/socket.rst:945
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getnameinfo`` with "
"argument ``sockaddr``."
msgstr ""
"Plantea un :ref:`auditing event <auditing>` ``socket.getnameinfo`` con el "
"argumento ``sockaddr``."

#: ../Doc/library/socket.rst:943
msgid ""
"Translate an internet protocol name (for example, ``'icmp'``) to a constant "
"suitable for passing as the (optional) third argument to the :func:`.socket` "
"function.  This is usually only needed for sockets opened in \"raw\" mode (:"
"const:`SOCK_RAW`); for the normal socket modes, the correct protocol is "
"chosen automatically if the protocol is omitted or zero."
msgstr ""
"Traduzca un nombre de protocolo de Internet (por ejemplo, ``'icmp'``) a una "
"constante adecuada para pasar como tercer argumento (opcional) a la función :"
"func:`.socket`. Esto normalmente sólo es necesario para sockets abiertos en "
"modo \"raw\" (:const:`SOCK_RAW`); para los modos de conexión normales, el "
"protocolo correcto se elige automáticamente si el protocolo se omite o se "
"pone a cero."

#: ../Doc/library/socket.rst:954
msgid ""
"Translate an internet service name and protocol name to a port number for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""
"Traduzca un nombre de servicio de Internet y un nombre de protocolo a un "
"número de puerto para ese servicio. El nombre de protocolo opcional, si se "
"proporciona, debe ser ``'tcp'`` o ``'udp'``; de lo contrario, cualquier "
"protocolo coincidirá."

#: ../Doc/library/socket.rst:967
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyname`` with "
"arguments ``servicename``, ``protocolname``."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.getservbyname`` con los "
"argumentos ``servicename``, ``protocolname``."

#: ../Doc/library/socket.rst:965
msgid ""
"Translate an internet port number and protocol name to a service name for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""
"Traduzca un número de puerto de Internet y un nombre de protocolo a un "
"nombre de servicio para ese servicio. El nombre de protocolo opcional, si se "
"proporciona, debe ser ``'tcp'`` o ``'udp'``; de lo contrario, cualquier "
"protocolo coincidirá."

#: ../Doc/library/socket.rst:978
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyport`` with "
"arguments ``port``, ``protocolname``."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.getservbyport`` con los "
"argumentos ``port``, ``protocolname``."

#: ../Doc/library/socket.rst:976
msgid ""
"Convert 32-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"Convierta enteros positivos de 32 bits de red a orden de bytes de host.  En "
"equipos donde el orden de bytes de host es el mismo que el orden de bytes de "
"red, se trata de un no-op; de lo contrario, realiza una operación de "
"intercambio de 4 bytes."

#: ../Doc/library/socket.rst:983
msgid ""
"Convert 16-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"Convierta enteros positivos de 16 bits de red a orden de bytes de host.  En "
"equipos donde el orden de bytes de host es el mismo que el orden de bytes de "
"red, se trata de un no-op; de lo contrario, realiza una operación de "
"intercambio de 2 bytes."

#: ../Doc/library/socket.rst:987 ../Doc/library/socket.rst:1005
msgid ""
"Raises :exc:`OverflowError` if *x* does not fit in a 16-bit unsigned integer."
msgstr ""
"Lanza :exc:`OverflowError` si *x* no cabe en un entero sin signo de 16 bits."

#: ../Doc/library/socket.rst:994
msgid ""
"Convert 32-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"Convierta enteros positivos de 32 bits del host al orden de bytes de red.  "
"En equipos donde el orden de bytes de host es el mismo que el orden de bytes "
"de red, se trata de un no-op; de lo contrario, realiza una operación de "
"intercambio de 4 bytes."

#: ../Doc/library/socket.rst:1001
msgid ""
"Convert 16-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"Convierta enteros positivos de 16 bits del host al orden de bytes de red.  "
"En equipos donde el orden de bytes de host es el mismo que el orden de bytes "
"de red, se trata de un no-op; de lo contrario, realiza una operación de "
"intercambio de 2 bytes."

#: ../Doc/library/socket.rst:1012
msgid ""
"Convert an IPv4 address from dotted-quad string format (for example, "
"'123.45.67.89') to 32-bit packed binary format, as a bytes object four "
"characters in length.  This is useful when conversing with a program that "
"uses the standard C library and needs objects of type :c:struct:`in_addr`, "
"which is the C type for the 32-bit packed binary this function returns."
msgstr ""
"Convierte una dirección IPv4 desde el formato de cadena de cuatro puntos "
"(por ejemplo, ‘123.45.67.89’) a formato binario empaquetado de 32 bits, como "
"un objeto de bytes de cuatro caracteres de longitud. Esto es útil cuando se "
"convierte con un programa que usa la librería estándar C y necesita objetos "
"de tipo :c:struct:`in_addr`, que es el tipo C para el binario empaquetado de "
"32 bits que devuelve esta función."

#: ../Doc/library/socket.rst:1018
msgid ""
":func:`inet_aton` also accepts strings with less than three dots; see the "
"Unix manual page :manpage:`inet(3)` for details."
msgstr ""
"Ademas :func:`inet_aton`acepta cadena de caracteres con menos de tres "
"puntos, observar la pagina del manual Unix :manpage:`inet(3)` para mas "
"detalles."

#: ../Doc/library/socket.rst:1021
msgid ""
"If the IPv4 address string passed to this function is invalid, :exc:"
"`OSError` will be raised. Note that exactly what is valid depends on the "
"underlying C implementation of :c:func:`inet_aton`."
msgstr ""
"Si la cadena de dirección IPv4 es pasada a esta función es invalido, :exc:"
"`OSError` se lanzará. Tenga en cuenta que exactamente lo que es valido "
"depende de la implementación C de :c:func:`inet_aton`."

#: ../Doc/library/socket.rst:1025
msgid ""
":func:`inet_aton` does not support IPv6, and :func:`inet_pton` should be "
"used instead for IPv4/v6 dual stack support."
msgstr ""
":func:`inet_aton` no admite IPV6, y :func:`inet_pton` deberían utilizarse en "
"su lugar para compatibilidad con doble pilas IPV4/v6."

#: ../Doc/library/socket.rst:1031
msgid ""
"Convert a 32-bit packed IPv4 address (a :term:`bytes-like object` four bytes "
"in length) to its standard dotted-quad string representation (for example, "
"'123.45.67.89').  This is useful when conversing with a program that uses "
"the standard C library and needs objects of type :c:struct:`in_addr`, which "
"is the C type for the 32-bit packed binary data this function takes as an "
"argument."
msgstr ""
"Convierte una dirección IPv4 empaquetada de 32 bits (un :term:`bytes-like "
"object` cuatro bytes de longitud) a su representación estándar de cadena de "
"cuatro puntos (por ejemplo ‘123.45.67.89’). Esto es útil cuando convertimos "
"con un programa que usa la librería estándar C y necesita objetos de tipo :c:"
"struct:`in_addr`, que es el tipo C para los datos binarios empaquetados de "
"32 bits que esta función toma como argumento."

#: ../Doc/library/socket.rst:1038
msgid ""
"If the byte sequence passed to this function is not exactly 4 bytes in "
"length, :exc:`OSError` will be raised. :func:`inet_ntoa` does not support "
"IPv6, and :func:`inet_ntop` should be used instead for IPv4/v6 dual stack "
"support."
msgstr ""
"Si la secuencia de byte pasada a esta función no es exactamente 4 bytes de "
"longitud  :exc:`OSError` podría generarse :func:`inet_ntoa` no soporta IPV6, "
"y :func:`inet_ntop` debe utilizarse en su lugar para compatibilidad con "
"doble pila IPv4 / v6."

#: ../Doc/library/socket.rst:1049
msgid ""
"Convert an IP address from its family-specific string format to a packed, "
"binary format. :func:`inet_pton` is useful when a library or network "
"protocol calls for an object of type :c:struct:`in_addr` (similar to :func:"
"`inet_aton`) or :c:struct:`in6_addr`."
msgstr ""
"Convierte una dirección IP desde su formato de cadena específico de la "
"familia a un formato binario empaquetado. :func:`inet_pton` es útil cuando "
"una librería o protocolo de red llama desde un objeto de tipo :c:struct:"
"`in_addr` (similar a :func:`inet_aton`) o :c:struct:`in6_addr`."

#: ../Doc/library/socket.rst:1054
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and :"
"const:`AF_INET6`. If the IP address string *ip_string* is invalid, :exc:"
"`OSError` will be raised. Note that exactly what is valid depends on both "
"the value of *address_family* and the underlying implementation of :c:func:"
"`inet_pton`."
msgstr ""
"Los Valores soportados para *address_family* son actualmente :const:"
"`AF_INET` y :const:`AF_INET6`. Si la cadena de dirección IP *ip_string* no "
"es válida, :exc:`OSError` se genera. Tenga en cuenta que exactamente lo que "
"es válido depende tanto del valor de *address_family* como de la "
"implementación subyacente de :c:func:`inet_pton`."

#: ../Doc/library/socket.rst:1061 ../Doc/library/socket.rst:1081
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`Availability <availability>`: Unix, Windows."

#: ../Doc/library/socket.rst:1062 ../Doc/library/socket.rst:1082
msgid "Windows support added"
msgstr "Se ha añadido compatibilidad con Windows"

#: ../Doc/library/socket.rst:1068
msgid ""
"Convert a packed IP address (a :term:`bytes-like object` of some number of "
"bytes) to its standard, family-specific string representation (for example, "
"``'7.10.0.5'`` or ``'5aef:2b::8'``). :func:`inet_ntop` is useful when a "
"library or network protocol returns an object of type :c:struct:`in_addr` "
"(similar to :func:`inet_ntoa`) or :c:struct:`in6_addr`."
msgstr ""
"Convierte una dirección IP empaquetada (un :term:`bytes-like object` de "
"algún numero de bytes) a su representación estándar de cadena específica de "
"la familia (por ejemplo ``’7.10.0.5’`` o ``’5aef:2b::8’``). :func:"
"`inet_ntop` es útil cuando una librería o protocolo de red retorna un objeto "
"de tipo :c:struct:`in_addr` (similar para :func:`inet_ntoa`) o :c:struct:"
"`in6_addr`."

#: ../Doc/library/socket.rst:1075
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and :"
"const:`AF_INET6`. If the bytes object *packed_ip* is not the correct length "
"for the specified address family, :exc:`ValueError` will be raised. :exc:"
"`OSError` is raised for errors from the call to :func:`inet_ntop`."
msgstr ""
"Los valores soportados para *address_family* actualmente son :const:"
"`AF_INET` y :const:`AF_INET6`. Si los objetos de bytes *packed_ip* no tienen "
"la longitud correcta para la familia de direcciones especificas, :exc:"
"`ValueError` podría generarse. :exc:`OSError` se genera para errores desde "
"la llamada a :func:`inet_ntop`."

#: ../Doc/library/socket.rst:1097
msgid ""
"Return the total length, without trailing padding, of an ancillary data item "
"with associated data of the given *length*.  This value can often be used as "
"the buffer size for :meth:`~socket.recvmsg` to receive a single item of "
"ancillary data, but :rfc:`3542` requires portable applications to use :func:"
"`CMSG_SPACE` and thus include space for padding, even when the item will be "
"the last in the buffer.  Raises :exc:`OverflowError` if *length* is outside "
"the permissible range of values."
msgstr ""
"Retorna la longitud total, sin relleno de arrastre, de un elemento de datos "
"auxiliares con datos asociados del *length*. Este valor se puede utilizar a "
"menudo como tamaño de búfer para :meth:`~socket.recvmsg` para recibir un "
"solo valor de datos auxiliares, pero :rfc:`3542` requiere aplicaciones "
"portables para usar :func:`CMSG_SPACE` y así incluir espacio para el "
"relleno, incluso cuando el elemento será el último en el búfer. Genera  :exc:"
"`OverflowError` si *length* está fuera del rango de valores permitido."

#, fuzzy
msgid ":ref:`Availability <availability>`: Unix, not Emscripten, not WASI."
msgstr ":ref:`Availability <availability>`: Unix, no Emscripten, no WASI."

#: ../Doc/library/socket.rst:1108 ../Doc/library/socket.rst:1598
#: ../Doc/library/socket.rst:1642 ../Doc/library/socket.rst:1750
msgid "Most Unix platforms."
msgstr "La mayoría de las plataformas Unix."

#: ../Doc/library/socket.rst:1115
msgid ""
"Return the buffer size needed for :meth:`~socket.recvmsg` to receive an "
"ancillary data item with associated data of the given *length*, along with "
"any trailing padding.  The buffer space needed to receive multiple items is "
"the sum of the :func:`CMSG_SPACE` values for their associated data lengths.  "
"Raises :exc:`OverflowError` if *length* is outside the permissible range of "
"values."
msgstr ""
"Retorna el tamaño del buffer necesario por :meth:`~socket.recvmsg` para "
"recibir un elemento de datos auxiliares con datos asociados del *length* "
"dado, junto con cualquier relleno final. El espacio de buffer necesario para "
"recibir múltiples elementos es la suma de los valores de :func:`CMSG_SPACE` "
"para los datos asociados con la longitudes. Genera :exc:`OverflowError` si "
"*length* está fuera del rango de valores permitido."

#: ../Doc/library/socket.rst:1123
msgid ""
"Note that some systems might support ancillary data without providing this "
"function.  Also note that setting the buffer size using the results of this "
"function may not precisely limit the amount of ancillary data that can be "
"received, since additional data may be able to fit into the padding area."
msgstr ""
"Tenga en cuenta que algunos sistemas pueden admitir datos auxiliares sin "
"proporcionar esta función.  Tenga en cuenta también que establecer el tamaño "
"del búfer utilizando los resultados de esta función puede no limitar con "
"precisión la cantidad de datos auxiliares que se pueden recibir, ya que los "
"datos adicionales pueden caber en el área de relleno."

#: ../Doc/library/socket.rst:1131
msgid "most Unix platforms."
msgstr "la mayoría de las plataformas Unix."

#: ../Doc/library/socket.rst:1138
msgid ""
"Return the default timeout in seconds (float) for new socket objects. A "
"value of ``None`` indicates that new socket objects have no timeout. When "
"the socket module is first imported, the default is ``None``."
msgstr ""
"Retorna el tiempo de espera por defecto en segundos (flotante) para los "
"objetos de un nuevo socket. Un valor de ``None`` indicada que los objetos "
"del nuevo socket no tiene un tiempo de espera. Cuando el modulo socket es "
"importado primero, por defecto es ``None``."

#: ../Doc/library/socket.rst:1145
msgid ""
"Set the default timeout in seconds (float) for new socket objects.  When the "
"socket module is first imported, the default is ``None``.  See :meth:"
"`~socket.settimeout` for possible values and their respective meanings."
msgstr ""
"Selecciona el tiempo de espera por defecto en segundos (flotante ) para los "
"objetos nuevos del socket. Cuando el modulo socket es importado primero, el "
"valor por defecto es ``None``. Observar :meth:`~socket.settimeout` para "
"posible valores y sus respectivos significados."

#: ../Doc/library/socket.rst:1153
msgid ""
"Set the machine's hostname to *name*.  This will raise an :exc:`OSError` if "
"you don't have enough rights."
msgstr ""
"Establece el nombre de host de la maquina en *name*. Esto genera un  :exc:"
"`OSError` si no tiene suficientes derechos."

#: ../Doc/library/socket.rst:1165
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sethostname`` with "
"argument ``name``."
msgstr ""
"Plantea un :ref:`auditing event <auditing>` ``socket.sethostname`` con el "
"argumento ``name``."

#: ../Doc/library/socket.rst:1159
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`Availability <availability>`: Unix."

#: ../Doc/library/socket.rst:1165
msgid ""
"Return a list of network interface information (index int, name string) "
"tuples. :exc:`OSError` if the system call fails."
msgstr ""
"Retorna una lista de tuplas de información de interfaz de red (índice int, "
"cadena de nombre). :exc:`OSError` si se produce un error en la llamada del "
"sistema."

#: ../Doc/library/socket.rst:1170 ../Doc/library/socket.rst:1197
#: ../Doc/library/socket.rst:1214
#, fuzzy
msgid ""
":ref:`Availability <availability>`: Unix, Windows, not Emscripten, not WASI."
msgstr ""
":ref:`Availability <availability>`: Unix, Windows, no Emscripten, no WASI."

#: ../Doc/library/socket.rst:1173 ../Doc/library/socket.rst:1200
#: ../Doc/library/socket.rst:1217
msgid "Windows support was added."
msgstr "Se ha agregado compatibilidad con Windows."

#: ../Doc/library/socket.rst:1178
msgid ""
"On Windows network interfaces have different names in different contexts "
"(all names are examples):"
msgstr ""
"En Windows las interfaces de redes tienen diferentes nombres en diferentes "
"contextos (todos los nombres son ejemplos):"

#: ../Doc/library/socket.rst:1181
msgid "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"
msgstr "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"

#: ../Doc/library/socket.rst:1182
msgid "name: ``ethernet_32770``"
msgstr "nombre: ``ethernet_32770``"

#: ../Doc/library/socket.rst:1183
msgid "friendly name: ``vEthernet (nat)``"
msgstr "nombre amigable: ``vEthernet (nat)``"

#: ../Doc/library/socket.rst:1184
msgid "description: ``Hyper-V Virtual Ethernet Adapter``"
msgstr "descripción: ``Hyper-V Virtual Ethernet Adapter``"

#: ../Doc/library/socket.rst:1186
msgid ""
"This function returns names of the second form from the list, "
"``ethernet_32770`` in this example case."
msgstr ""
"Esta función retorna los nombres del segundo formulario de la lista, en este "
"caso de ejemplo ``ethernet_32770``."

#: ../Doc/library/socket.rst:1192
msgid ""
"Return a network interface index number corresponding to an interface name. :"
"exc:`OSError` if no interface with the given name exists."
msgstr ""
"Retorna un número de índice de interfaz de red correspondiente a un nombre "
"de interfaz. :exc:`OSError` si no existe ninguna interfaz con el nombre "
"especificado."

#: ../Doc/library/socket.rst:1204 ../Doc/library/socket.rst:1221
msgid "\"Interface name\" is a name as documented in :func:`if_nameindex`."
msgstr ""
"“\\”Interface name\\” es un nombre como se documenta en :func:`if_nameindex`."

#: ../Doc/library/socket.rst:1209
msgid ""
"Return a network interface name corresponding to an interface index number. :"
"exc:`OSError` if no interface with the given index exists."
msgstr ""
"Retorna un nombre de interfaz de red correspondiente a un número de índice "
"de interfaz. :exc:`OSError` si no existe ninguna interfaz con el índice dado."

#: ../Doc/library/socket.rst:1226
msgid ""
"Send the list of file descriptors *fds* over an :const:`AF_UNIX` socket "
"*sock*. The *fds* parameter is a sequence of file descriptors. Consult :meth:"
"`sendmsg` for the documentation of these parameters."
msgstr ""
"Envíe la lista de descriptores de archivo *fds* a través de un conector :"
"const:`AF_UNIX` *sock*. El parámetro *fds* es una secuencia de descriptores "
"de archivo. Consulte :meth:`sendmsg` para obtener la documentación de estos "
"parámetros."

#: ../Doc/library/socket.rst:1232 ../Doc/library/socket.rst:1246
msgid ""
"Unix platforms supporting :meth:`~socket.sendmsg` and :const:`SCM_RIGHTS` "
"mechanism."
msgstr ""
"Plataformas Unix que soporten :meth:`~socket.sendmsg` y el mecanismo :const:"
"`SCM_RIGHTS`."

#: ../Doc/library/socket.rst:1240
msgid ""
"Receive up to *maxfds* file descriptors from an :const:`AF_UNIX` socket "
"*sock*. Return ``(msg, list(fds), flags, addr)``. Consult :meth:`recvmsg` "
"for the documentation of these parameters."
msgstr ""
"Reciba descriptores de archivo hasta *maxfds* desde un socket :const:"
"`AF_UNIX` *sock*. Retorna ``(msg, list(fds), flags, addr)``. Consulte :meth:"
"`recvmsg` para obtener la documentación de estos parámetros."

#: ../Doc/library/socket.rst:1253
msgid "Any truncated integers at the end of the list of file descriptors."
msgstr ""
"Cualquier número entero truncado al final de la lista de descriptores de "
"archivo."

#: ../Doc/library/socket.rst:1259
msgid "Socket Objects"
msgstr "Objetos Socket"

#: ../Doc/library/socket.rst:1261
msgid ""
"Socket objects have the following methods.  Except for :meth:`~socket."
"makefile`, these correspond to Unix system calls applicable to sockets."
msgstr ""
"Los objetos socket tienen los siguientes métodos. Excepto para :meth:"
"`~socket.makefile`, esto corresponde al sistema de llamadas Unix para "
"sockets."

#: ../Doc/library/socket.rst:1265
msgid ""
"Support for the :term:`context manager` protocol was added.  Exiting the "
"context manager is equivalent to calling :meth:`~socket.close`."
msgstr ""
"El soporte para el protocolo :term:`context manager` ha sido agregado. Salir "
"del gestor de contexto es equivalente para el llamado :meth:`~socket.close`."

#: ../Doc/library/socket.rst:1272
msgid ""
"Accept a connection. The socket must be bound to an address and listening "
"for connections. The return value is a pair ``(conn, address)`` where *conn* "
"is a *new* socket object usable to send and receive data on the connection, "
"and *address* is the address bound to the socket on the other end of the "
"connection."
msgstr ""
"Acepta una conexión. El socket debe estar vinculado a una dirección y estar "
"escuchando las conexiones. El valor de retorno es el par ``(conn, address)`` "
"cuando *conn* es un *new* objeto socket usado para enviar y recibir "
"información en la conexión, y *address* es la dirección vinculada al socket "
"en el extremo de la conexión."

#: ../Doc/library/socket.rst:1279 ../Doc/library/socket.rst:1373
msgid "The socket is now non-inheritable."
msgstr "El socket ahora no es heredable."

#: ../Doc/library/socket.rst:1282 ../Doc/library/socket.rst:1511
#: ../Doc/library/socket.rst:1525 ../Doc/library/socket.rst:1602
#: ../Doc/library/socket.rst:1675 ../Doc/library/socket.rst:1694
#: ../Doc/library/socket.rst:1711 ../Doc/library/socket.rst:1756
msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the method now retries the system call instead of raising an :exc:"
"`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"Si se interrumpe la llamada del sistema y el controlador de señal no genera "
"una excepción, el método ahora vuelve a intentar la llamada del sistema en "
"lugar de generar una excepción :exc:`InterruptedError` (consulte :pep:`475` "
"para la lógica)."

#: ../Doc/library/socket.rst:1290
msgid ""
"Bind the socket to *address*.  The socket must not already be bound. (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"Enlaza el socket a *address*. El socket no debe estar ya unido. (El formato "
"de *address* depende de la familia de direcciones, consulte más arriba)."

#: ../Doc/library/socket.rst:1302
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.bind`` with arguments "
"``self``, ``address``."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.getaddrinfo`` con los "
"argumentos ``host``, ``port``, ``family``, ``type``, ``protocol``."

#: ../Doc/library/socket.rst:1300
msgid ""
"Mark the socket closed.  The underlying system resource (e.g. a file "
"descriptor) is also closed when all file objects from :meth:`makefile()` are "
"closed.  Once that happens, all future operations on the socket object will "
"fail. The remote end will receive no more data (after queued data is "
"flushed)."
msgstr ""
"Marca el socket cerrado. El recurso del sistema subyacente (ej. un "
"descriptor de archivo) también se cierra cuando todos los objetos de archivo "
"de :meth:`makefile()` están cerrados. Una vez que eso suceda, todas las "
"operaciones futuras en el objeto socket fallarán. El extremo remoto no "
"recibirá más datos (después de que se vacíen los datos en cola)."

#: ../Doc/library/socket.rst:1306
msgid ""
"Sockets are automatically closed when they are garbage-collected, but it is "
"recommended to :meth:`close` them explicitly, or to use a :keyword:`with` "
"statement around them."
msgstr ""
"Los sockets se cierran automáticamente cuando se recogen basura, pero se "
"recomienda :meth:`cerrarlos` explícitamente, o usar una instrucción :keyword:"
"`with` alrededor de ellos."

#: ../Doc/library/socket.rst:1310
msgid ""
":exc:`OSError` is now raised if an error occurs when the underlying :c:func:"
"`close` call is made."
msgstr ""
":exc:`OSError` ahora se lanza si se produce un error cuando se realiza la "
"llamada :c:func:`close` subyacente."

#: ../Doc/library/socket.rst:1316
msgid ""
":meth:`close()` releases the resource associated with a connection but does "
"not necessarily close the connection immediately.  If you want to close the "
"connection in a timely fashion, call :meth:`shutdown()` before :meth:"
"`close()`."
msgstr ""
":meth:`close()` libera el recurso asociado a una conexión, pero no "
"necesariamente cierra la conexión inmediatamente.  Si desea cerrar la "
"conexión a tiempo, llame a :meth:`shutdown()` antes de :meth:`close()`."

#: ../Doc/library/socket.rst:1324
msgid ""
"Connect to a remote socket at *address*. (The format of *address* depends on "
"the address family --- see above.)"
msgstr ""
"Conectar a un socket remoto en *address*. (El formato de *address* depende "
"de la familia de direcciones --- ver arriba.)"

#: ../Doc/library/socket.rst:1327
msgid ""
"If the connection is interrupted by a signal, the method waits until the "
"connection completes, or raise a :exc:`TimeoutError` on timeout, if the "
"signal handler doesn't raise an exception and the socket is blocking or has "
"a timeout. For non-blocking sockets, the method raises an :exc:"
"`InterruptedError` exception if the connection is interrupted by a signal "
"(or the exception raised by the signal handler)."
msgstr ""
"Si la conexión es interrumpida por una señal, el método espera hasta que se "
"complete la conexión, o lanza un :exc:`TimeoutError` en el tiempo de espera, "
"si el manejador de señales no lanza una excepción y el socket se bloquea o "
"tiene un tiempo de espera. Para sockets sin bloqueo, el método lanza una "
"excepción :exc:`InterruptedError` si la conexión es interrumpida por una "
"señal (o la excepción lanzada por el manejador de señales)."

#: ../Doc/library/socket.rst:1343 ../Doc/library/socket.rst:1363
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.connect`` with arguments "
"``self``, ``address``."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.connect`` con los "
"argumentos ``self``, ``address``."

#: ../Doc/library/socket.rst:1336
msgid ""
"The method now waits until the connection completes instead of raising an :"
"exc:`InterruptedError` exception if the connection is interrupted by a "
"signal, the signal handler doesn't raise an exception and the socket is "
"blocking or has a timeout (see the :pep:`475` for the rationale)."
msgstr ""
"El método ahora espera hasta que se completa la conexión en lugar de generar "
"una excepción :exc:`InterruptedError` si la conexión se interrumpe por una "
"señal, el controlador de señal no genera una excepción y el socket está "
"bloqueando o tiene un tiempo de espera (consulte el :pep:`475` para la razón "
"de ser)."

#: ../Doc/library/socket.rst:1347
msgid ""
"Like ``connect(address)``, but return an error indicator instead of raising "
"an exception for errors returned by the C-level :c:func:`connect` call "
"(other problems, such as \"host not found,\" can still raise exceptions).  "
"The error indicator is ``0`` if the operation succeeded, otherwise the value "
"of the :c:data:`errno` variable.  This is useful to support, for example, "
"asynchronous connects."
msgstr ""
"Similar a ``connect(address)``, pero retorna un indicador de error en lugar "
"de generar una excepción para los errores retornados por la llamada de nivel "
"C :c:func:`connect` (otros problemas, como “host no encontrado”, aún pueden "
"generar excepciones). El indicador de error es ``0`` si la operación tuvo "
"éxito, caso contrario es el valor de la variable :c:data:`errno`. Esto es "
"útil para admitir, por ejemplo, conexiones asincrónicas."

#: ../Doc/library/socket.rst:1360
msgid ""
"Put the socket object into closed state without actually closing the "
"underlying file descriptor.  The file descriptor is returned, and can be "
"reused for other purposes."
msgstr ""
"Coloque el objeto de socket en estado cerrado sin cerrar realmente el "
"descriptor de archivo subyacente.  Se devuelve el descriptor de archivo y se "
"puede reutilizar para otros fines."

#: ../Doc/library/socket.rst:1369
msgid "Duplicate the socket."
msgstr "Duplica el socket."

#: ../Doc/library/socket.rst:1381
msgid ""
"Return the socket's file descriptor (a small integer), or -1 on failure. "
"This is useful with :func:`select.select`."
msgstr ""
"Retorna un archivo descriptor del socket (un entero pequeño), o -1 si falla. "
"Esto es útil con :func:`select.select`."

#: ../Doc/library/socket.rst:1384
msgid ""
"Under Windows the small integer returned by this method cannot be used where "
"a file descriptor can be used (such as :func:`os.fdopen`).  Unix does not "
"have this limitation."
msgstr ""
"En Windows el pequeño entero retornado por este método no puede ser usado "
"donde un descriptor de un archivo pueda ser usado (como una :func:`os."
"fdopen`). Unix no tiene esta limitación."

#: ../Doc/library/socket.rst:1390
msgid ""
"Get the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle: ``True`` if the socket can be inherited in "
"child processes, ``False`` if it cannot."
msgstr ""
"Obtiene el :ref:`inheritable flag <fd_inheritance>` del descriptor del "
"archivo del socket o el controlador del socket: ``True`` si el socket puede "
"ser heredada en procesos secundarios, ``False`` si falla."

#: ../Doc/library/socket.rst:1399
msgid ""
"Return the remote address to which the socket is connected.  This is useful "
"to find out the port number of a remote IPv4/v6 socket, for instance. (The "
"format of the address returned depends on the address family --- see "
"above.)  On some systems this function is not supported."
msgstr ""
"Retorna la dirección remota a la que esta conectado el socket. Esto es útil "
"para averiguar el número de puerto de un socket IPv4/v6 remoto, por ejemplo. "
"(El formato de la dirección devuelta depende de la familia de direcciones, "
"consulte más arriba). En algunos sistemas, esta función no es compatible."

#: ../Doc/library/socket.rst:1407
msgid ""
"Return the socket's own address.  This is useful to find out the port number "
"of an IPv4/v6 socket, for instance. (The format of the address returned "
"depends on the address family --- see above.)"
msgstr ""
"Retorna la dirección del propio socket. Esto es útil para descubrir el "
"numero de puerto de un socket IPv4/IPv6, por ejemplo. (El formato de la "
"dirección devuelta depende de la familia de direcciones, consulte más "
"arriba)."

#: ../Doc/library/socket.rst:1414
msgid ""
"Return the value of the given socket option (see the Unix man page :manpage:"
"`getsockopt(2)`).  The needed symbolic constants (:const:`SO_\\*` etc.) are "
"defined in this module.  If *buflen* is absent, an integer option is assumed "
"and its integer value is returned by the function.  If *buflen* is present, "
"it specifies the maximum length of the buffer used to receive the option in, "
"and this buffer is returned as a bytes object.  It is up to the caller to "
"decode the contents of the buffer (see the optional built-in module :mod:"
"`struct` for a way to decode C structures encoded as byte strings)."
msgstr ""
"Retorna el valor de la opción de socket dada (consulte la página de comando "
"man de Unix :manpage:`getsockopt(2)`).  Las constantes simbólicas necesarias "
"(:const:`SO_\\*` etc.) se definen en este módulo.  Si *buflen* está ausente, "
"se asume una opción de entero y la función retorna su valor entero.  Si "
"*buflen* está presente, especifica la longitud máxima del búfer utilizado "
"para recibir la opción y este búfer se devuelve como un objeto bytes.  "
"Depende del autor de la llamada descodificar el contenido del búfer "
"(consulte el módulo integrado opcional :mod:`struct` para obtener una manera "
"de decodificar las estructuras C codificadas como cadenas de bytes)."

#: ../Doc/library/socket.rst:1428
msgid ""
"Return ``True`` if socket is in blocking mode, ``False`` if in non-blocking."
msgstr ""
"Retorna ``True`` si el socket está en modo de bloqueo, ``False`` si está en "
"sin bloqueo."

#: ../Doc/library/socket.rst:1431
msgid "This is equivalent to checking ``socket.gettimeout() == 0``."
msgstr "Esto es equivalente a comprobar ``socket.gettimeout() == 0``."

#: ../Doc/library/socket.rst:1438
msgid ""
"Return the timeout in seconds (float) associated with socket operations, or "
"``None`` if no timeout is set.  This reflects the last call to :meth:"
"`setblocking` or :meth:`settimeout`."
msgstr ""
"Retorna el tiempo de espera en segundos (flotante) asociado con las "
"operaciones del socket, o ``None`` si el tiempo de espera no es "
"seleccionado. Esto refleja la ultima llamada al :meth:`setblocking` o :meth:"
"`settimeout`."

#: ../Doc/library/socket.rst
msgid "platform"
msgstr "plataforma"

#: ../Doc/library/socket.rst:1445
msgid "Windows"
msgstr "Windows"

#: ../Doc/library/socket.rst:1447
msgid ""
"The :meth:`ioctl` method is a limited interface to the WSAIoctl system "
"interface.  Please refer to the `Win32 documentation <https://msdn.microsoft."
"com/en-us/library/ms741621%28VS.85%29.aspx>`_ for more information."
msgstr ""
"El método :meth:`ioctl` es una interfaz limitada para el sistema de "
"interfaces WSAIoctl. Por favor refiérase a `Win32 documentation <https://"
"msdn.microsoft.com/en-us/library/ms741621%28VS.85%29.aspx>`_ para mas "
"información."

#: ../Doc/library/socket.rst:1452
msgid ""
"On other platforms, the generic :func:`fcntl.fcntl` and :func:`fcntl.ioctl` "
"functions may be used; they accept a socket object as their first argument."
msgstr ""
"En otras plataformas, las funciones genéricas :func:`fcntl.fcntl` y :func:"
"`fcntl.ioctl` podrían ser usadas; ellas aceptan un objeto socket como su "
"primer argumento."

#: ../Doc/library/socket.rst:1455
msgid ""
"Currently only the following control codes are supported: ``SIO_RCVALL``, "
"``SIO_KEEPALIVE_VALS``, and ``SIO_LOOPBACK_FAST_PATH``."
msgstr ""
"Actualmente solo el siguiente control de códigos está soportados: "
"``SIO_RCVALL``, ``SIO_KEEPALIVE_VALS``, y ``SIO_LOOPBACK_FAST_PATH``."

#: ../Doc/library/socket.rst:1463
msgid ""
"Enable a server to accept connections.  If *backlog* is specified, it must "
"be at least 0 (if it is lower, it is set to 0); it specifies the number of "
"unaccepted connections that the system will allow before refusing new "
"connections. If not specified, a default reasonable value is chosen."
msgstr ""
"Habilita un servidor para aceptar conexiones. Si *backlog* es especifico, "
"debe ser al menos 0 (si es menor, se establece en 0); especifica el número "
"de conexiones no aceptadas que permitirá el sistema antes de rechazar nuevas "
"conexiones. Si no se especifica, se elige un valor razonable predeterminado."

#: ../Doc/library/socket.rst:1470
msgid "The *backlog* parameter is now optional."
msgstr "El parámetro *backlog* ahora es opcional."

#: ../Doc/library/socket.rst:1479
msgid ""
"Return a :term:`file object` associated with the socket.  The exact returned "
"type depends on the arguments given to :meth:`makefile`.  These arguments "
"are interpreted the same way as by the built-in :func:`open` function, "
"except the only supported *mode* values are ``'r'`` (default), ``'w'`` and "
"``'b'``."
msgstr ""
"Retorna un :term:`file object` asociado con el socket. El tipo exacto "
"retornado depende de los argumentos dados a :meth:`makefile`. Estos "
"argumentos se interpretan de la misma forma que la función :func:`open`, "
"excepto que los únicos valores de *mode* admitidos son ``’r’`` (default), "
"``’w’`` and ``’b’``."

#: ../Doc/library/socket.rst:1484
msgid ""
"The socket must be in blocking mode; it can have a timeout, but the file "
"object's internal buffer may end up in an inconsistent state if a timeout "
"occurs."
msgstr ""
"El socket debe estar en modo de bloqueo; puede tener un tiempo de espera, "
"pero el búfer interno del objeto de archivo puede terminar en un estado "
"incoherente si se produce un tiempo de espera."

#: ../Doc/library/socket.rst:1488
msgid ""
"Closing the file object returned by :meth:`makefile` won't close the "
"original socket unless all other file objects have been closed and :meth:"
"`socket.close` has been called on the socket object."
msgstr ""
"Cerrar el objeto de archivo devuelto por :meth:`makefile` no cerrará el "
"socket original a menos que se hayan cerrado todos los demás objetos de "
"archivo y :meth:`socket.close` se haya llamado al objeto socket."

#: ../Doc/library/socket.rst:1494
msgid ""
"On Windows, the file-like object created by :meth:`makefile` cannot be used "
"where a file object with a file descriptor is expected, such as the stream "
"arguments of :meth:`subprocess.Popen`."
msgstr ""
"En Windows, el objeto similar a un archivo creado por :meth:`makefile` no se "
"puede utilizar cuando se espera un objeto de archivo con un descriptor de "
"archivo, como los argumentos de secuencia de :meth:`subprocess.Popen`."

#: ../Doc/library/socket.rst:1501
msgid ""
"Receive data from the socket.  The return value is a bytes object "
"representing the data received.  The maximum amount of data to be received "
"at once is specified by *bufsize*.  See the Unix manual page :manpage:"
"`recv(2)` for the meaning of the optional argument *flags*; it defaults to "
"zero."
msgstr ""
"Recibir datos del socket.  El valor devuelto es un objeto bytes que "
"representa los datos recibidos.  *bufsize* especifica la cantidad máxima de "
"datos que se recibirán a la vez.  Consulte la página del manual de Unix :"
"manpage:`recv(2)` para conocer el significado del argumento opcional "
"*flags*; por defecto es cero."

#: ../Doc/library/socket.rst:1508
msgid ""
"For best match with hardware and network realities, the value of  *bufsize* "
"should be a relatively small power of 2, for example, 4096."
msgstr ""
"Para una mejor coincidencia con las realidades de hardware y red, el valor "
"de *bufsize* debe ser una potencia relativamente pequeña de 2, por ejemplo, "
"4096."

#: ../Doc/library/socket.rst:1519
msgid ""
"Receive data from the socket.  The return value is a pair ``(bytes, "
"address)`` where *bytes* is a bytes object representing the data received "
"and *address* is the address of the socket sending the data.  See the Unix "
"manual page :manpage:`recv(2)` for the meaning of the optional argument "
"*flags*; it defaults to zero. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"Recibe datos desde el socket. El valor de retorno es un par ``(bytes, "
"address)`` donde *bytes* es un objeto de bytes que representa los datos "
"recibidos y *address* es la dirección de el socket enviando los datos. "
"Observar la pagina del manual Unix :manpage:`recv(2)` para el significado "
"del argumento opcional *flags*; por defecto es cero. (El formato de "
"*address* depende de la familia de direcciones, consulte más arriba)."

#: ../Doc/library/socket.rst:1530
#, python-format
msgid ""
"For multicast IPv6 address, first item of *address* does not contain "
"``%scope_id`` part anymore. In order to get full IPv6 address use :func:"
"`getnameinfo`."
msgstr ""
"Para direcciones IPv6 de multidifusión, el primer elemento de *address* ya "
"no contiene la parte ``%scope_id``. Para obtener la dirección IPV6 completa, "
"use :func:`getnameinfo`."

#: ../Doc/library/socket.rst:1537
msgid ""
"Receive normal data (up to *bufsize* bytes) and ancillary data from the "
"socket.  The *ancbufsize* argument sets the size in bytes of the internal "
"buffer used to receive the ancillary data; it defaults to 0, meaning that no "
"ancillary data will be received.  Appropriate buffer sizes for ancillary "
"data can be calculated using :func:`CMSG_SPACE` or :func:`CMSG_LEN`, and "
"items which do not fit into the buffer might be truncated or discarded.  The "
"*flags* argument defaults to 0 and has the same meaning as for :meth:`recv`."
msgstr ""
"Reciba datos normales (hasta *bufsize* bytes) y datos auxiliares del "
"socket.  El argumento *ancbufsize* establece el tamaño en bytes del búfer "
"interno utilizado para recibir los datos auxiliares; el valor predeterminado "
"es 0, lo que significa que no se recibirán datos auxiliares.  Los tamaños de "
"búfer adecuados para los datos auxiliares se pueden calcular mediante :func:"
"`CMSG_SPACE` o :func:`CMSG_LEN`, y los elementos que no caben en el búfer "
"pueden truncarse o descartarse.  El valor predeterminado del argumento "
"*flags* es 0 y tiene el mismo significado que para :meth:`recv`."

#: ../Doc/library/socket.rst:1547
msgid ""
"The return value is a 4-tuple: ``(data, ancdata, msg_flags, address)``.  The "
"*data* item is a :class:`bytes` object holding the non-ancillary data "
"received.  The *ancdata* item is a list of zero or more tuples "
"``(cmsg_level, cmsg_type, cmsg_data)`` representing the ancillary data "
"(control messages) received: *cmsg_level* and *cmsg_type* are integers "
"specifying the protocol level and protocol-specific type respectively, and "
"*cmsg_data* is a :class:`bytes` object holding the associated data.  The "
"*msg_flags* item is the bitwise OR of various flags indicating conditions on "
"the received message; see your system documentation for details. If the "
"receiving socket is unconnected, *address* is the address of the sending "
"socket, if available; otherwise, its value is unspecified."
msgstr ""
"El valor de retorno es una tupla de 4: ``(data, ancdata, msg_flags, "
"address)``. El valor *data* es un objeto :class:`bytes` que contiene los "
"datos no auxiliares recibidos. El valor *ancdata* es una lista de cero o mas "
"tuplas ``(cmsg_level, cmsg_type, cmsg_data)`` representado los datos "
"auxiliares (control de mensajes) recibidos: *cmsg_level* y *cmsg_type* son "
"enteros especificando el nivel de protocolo y tipo específico de protocolo "
"respectivamente, y *cmsg_data* es un objeto :class:`bytes` sosteniendo los "
"datos asociados. El valor *msg_flags* es el OR bit a bit de varios "
"indicadores que indican condiciones en el mensaje recibido; consulte la "
"documentación de su sistema para obtener más detalles. Si la toma de "
"recepción no está conectada, *address* es la dirección de el socket enviado, "
"si está disponible; de lo contrario, su valor no se especifica."

#: ../Doc/library/socket.rst:1561
msgid ""
"On some systems, :meth:`sendmsg` and :meth:`recvmsg` can be used to pass "
"file descriptors between processes over an :const:`AF_UNIX` socket.  When "
"this facility is used (it is often restricted to :const:`SOCK_STREAM` "
"sockets), :meth:`recvmsg` will return, in its ancillary data, items of the "
"form ``(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)``, where *fds* is a :"
"class:`bytes` object representing the new file descriptors as a binary array "
"of the native C :c:expr:`int` type.  If :meth:`recvmsg` raises an exception "
"after the system call returns, it will first attempt to close any file "
"descriptors received via this mechanism."
msgstr ""
"En algunos sistemas, :meth:`sendmsg` y :meth:`recvmsg` pueden utilizarse "
"para pasar descriptores de fichero entre procesos a través de un socket :"
"const:`AF_UNIX`.  Cuando se utiliza esta funcionalidad (a menudo está "
"restringida a los sockets :const:`SOCK_STREAM`), :meth:`recvmsg` devolverá, "
"en sus datos auxiliares, elementos del formulario ``(socket.SOL_SOCKET, "
"socket.SCM_RIGHTS, fds)``, donde *fds* es un objeto :class:`bytes` que "
"representa los nuevos descriptores de archivo como una arreglo binario del "
"tipo nativo C :c:expr:`int`.  Si :meth:`recvmsg` lanza una excepción después "
"del retorno de la llamada al sistema, primero intentará cerrar cualquier "
"descriptor de fichero recibido a través de este mecanismo."

#: ../Doc/library/socket.rst:1572
msgid ""
"Some systems do not indicate the truncated length of ancillary data items "
"which have been only partially received.  If an item appears to extend "
"beyond the end of the buffer, :meth:`recvmsg` will issue a :exc:"
"`RuntimeWarning`, and will return the part of it which is inside the buffer "
"provided it has not been truncated before the start of its associated data."
msgstr ""
"Algunos sistemas no indican la longitud truncada de los elementos de datos "
"auxiliares que solo se han recibido parcialmente.  Si un elemento parece "
"extenderse más allá del final del búfer, :meth:`recvmsg` emitirá un :exc:"
"`RuntimeWarning`, y devolverá la parte de él que está dentro del búfer "
"siempre que no se haya truncado antes del inicio de sus datos asociados."

#: ../Doc/library/socket.rst:1579
msgid ""
"On systems which support the :const:`SCM_RIGHTS` mechanism, the following "
"function will receive up to *maxfds* file descriptors, returning the message "
"data and a list containing the descriptors (while ignoring unexpected "
"conditions such as unrelated control messages being received).  See also :"
"meth:`sendmsg`. ::"
msgstr ""
"En sistemas donde soporta el mecanismo :const:`SCM_RIGHTS`, la siguiente "
"función recibirá un descriptor de archivos *maxfds*, devolviendo el mensaje "
"de datos y un lista que contiene los descriptores (mientras se ignoran las "
"condiciones inesperadas, como la recepción de mensajes de control no "
"relacionados). Ver también :meth:`sendmsg`. ::"

#: ../Doc/library/socket.rst:1610
msgid ""
"Receive normal data and ancillary data from the socket, behaving as :meth:"
"`recvmsg` would, but scatter the non-ancillary data into a series of buffers "
"instead of returning a new bytes object.  The *buffers* argument must be an "
"iterable of objects that export writable buffers (e.g. :class:`bytearray` "
"objects); these will be filled with successive chunks of the non-ancillary "
"data until it has all been written or there are no more buffers.  The "
"operating system may set a limit (:func:`~os.sysconf` value ``SC_IOV_MAX``) "
"on the number of buffers that can be used.  The *ancbufsize* and *flags* "
"arguments have the same meaning as for :meth:`recvmsg`."
msgstr ""
"Recibir datos normales y datos auxiliares desde el socket, comportándose "
"como :meth:`recvmsg` lo haría, pero dispersar los datos no auxiliares en una "
"serie de buffers en lugar de devolver un nuevo objeto bytes.  El argumento "
"*buffers* debe ser un iterable de objetos que exportan buffers de escritura "
"(por ejemplo, objetos :class:`bytearray`); estos se llenarán con fragmentos "
"sucesivos de los datos no auxiliares hasta que se hayan escrito todos o no "
"haya más buffers.  El sistema operativo puede establecer un límite (:func:"
"`~os.sysconf` valor ``SC_IOV_MAX``) en el número de buffers que se pueden "
"utilizar.  Los argumentos *ancbufsize* y *flags* tienen el mismo significado "
"que para :meth:`recvmsg`."

#: ../Doc/library/socket.rst:1621
msgid ""
"The return value is a 4-tuple: ``(nbytes, ancdata, msg_flags, address)``, "
"where *nbytes* is the total number of bytes of non-ancillary data written "
"into the buffers, and *ancdata*, *msg_flags* and *address* are the same as "
"for :meth:`recvmsg`."
msgstr ""
"El valor de retorno es tupla de 4: ``(nbytes, ancdata, msg_flags, "
"address)``, donde *nbytes* es el numero total de bytes de datos no "
"auxiliares escrito dentro de los bufetes, y *ancdata*, *msg_flags* y "
"*address* son lo mismo que para :meth:`recvmsg`."

#: ../Doc/library/socket.rst:1626
msgid "Example::"
msgstr "Ejemplo::"

#: ../Doc/library/socket.rst:1649
msgid ""
"Receive data from the socket, writing it into *buffer* instead of creating a "
"new bytestring.  The return value is a pair ``(nbytes, address)`` where "
"*nbytes* is the number of bytes received and *address* is the address of the "
"socket sending the data.  See the Unix manual page :manpage:`recv(2)` for "
"the meaning of the optional argument *flags*; it defaults to zero.  (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"Reciba datos del socket, escribiéndolo en *buffer* en lugar de crear una "
"nueva cadena de bytes.  El valor devuelto es un par ``(nbytes, address)`` "
"donde *nbytes* es el número de bytes recibidos y *address* es la dirección "
"del socket que envía los datos.  Consulte la página del manual de Unix :"
"manpage:`recv(2)` para conocer el significado del argumento opcional "
"*flags*; por defecto es cero.  (El formato de *address* depende de la "
"familia de direcciones --- ver arriba.)"

#: ../Doc/library/socket.rst:1659
msgid ""
"Receive up to *nbytes* bytes from the socket, storing the data into a buffer "
"rather than creating a new bytestring.  If *nbytes* is not specified (or 0), "
"receive up to the size available in the given buffer.  Returns the number of "
"bytes received.  See the Unix manual page :manpage:`recv(2)` for the meaning "
"of the optional argument *flags*; it defaults to zero."
msgstr ""
"Recibe hasta *nbytes* bytes desde el socket, almacenado los datos en un "
"búfer en lugar de crear una nueva cadena de bytes. Si *nbytes* no esta "
"especificado (o 0), recibir hasta el tamaño disponible en el búfer dado. "
"Retorna  el número de bytes recibidos. Ver la página del manual de Unix :"
"manpage:`recv(2)` para el significado del argumento opcional *flags*; por "
"defecto es cero."

#: ../Doc/library/socket.rst:1668
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Returns the number of bytes sent. Applications are responsible for "
"checking that all data has been sent; if only some of the data was "
"transmitted, the application needs to attempt delivery of the remaining "
"data. For further information on this topic, consult the :ref:`socket-howto`."
msgstr ""
"Enviar datos al socket.  El socket debe estar conectado a un socket remoto.  "
"El argumento opcional *flags* tiene el mismo significado que para :meth:"
"`recv` arriba. Retorna el número de bytes enviados. Las aplicaciones son "
"responsables de comprobar que se han enviado todos los datos; si sólo se "
"transmitieron algunos de los datos, la aplicación debe intentar la entrega "
"de los datos restantes. Para obtener más información sobre este tema, "
"consulte :ref:`socket-howto`."

#: ../Doc/library/socket.rst:1683
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Unlike :meth:`send`, this method continues to send data from *bytes* "
"until either all data has been sent or an error occurs.  ``None`` is "
"returned on success.  On error, an exception is raised, and there is no way "
"to determine how much data, if any, was successfully sent."
msgstr ""
"Enviar datos al socket.  El socket debe estar conectado a un socket remoto.  "
"El argumento opcional *flags* tiene el mismo significado que para :meth:"
"`recv` arriba. A diferencia de :meth:`send`, este método continúa enviando "
"datos desde *bytes* hasta que se han enviado todos los datos o se produce un "
"error.  ``Ninguno`` se devuelve en caso de éxito.  Por error, se genera una "
"excepción y no hay forma de determinar cuántos datos, si los hay, se "
"enviaron correctamente."

#: ../Doc/library/socket.rst:1690
msgid ""
"The socket timeout is no more reset each time data is sent successfully. The "
"socket timeout is now the maximum total duration to send all data."
msgstr ""
"El tiempo de espera del socket no se restablece más cada vez que los datos "
"se envían correctamente. El tiempo de espera del socket es ahora la duración "
"total máxima para enviar todos los datos."

#: ../Doc/library/socket.rst:1703
msgid ""
"Send data to the socket.  The socket should not be connected to a remote "
"socket, since the destination socket is specified by *address*.  The "
"optional *flags* argument has the same meaning as for :meth:`recv` above.  "
"Return the number of bytes sent. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"Enviar datos al socket.  El socket no debe estar conectado a un socket "
"remoto, ya que el socket de destino se especifica mediante *address*.  El "
"argumento opcional *flags* tiene el mismo significado que para :meth:`recv` "
"arriba.  Devolver el número de bytes enviados. (El formato de *address* "
"depende de la familia de direcciones --- ver arriba.)"

#: ../Doc/library/socket.rst:1718
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendto`` with arguments "
"``self``, ``address``."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.sendto`` con los "
"argumentos ``self``, ``address``."

#: ../Doc/library/socket.rst:1719
msgid ""
"Send normal and ancillary data to the socket, gathering the non-ancillary "
"data from a series of buffers and concatenating it into a single message.  "
"The *buffers* argument specifies the non-ancillary data as an iterable of :"
"term:`bytes-like objects <bytes-like object>` (e.g. :class:`bytes` objects); "
"the operating system may set a limit (:func:`~os.sysconf` value "
"``SC_IOV_MAX``) on the number of buffers that can be used.  The *ancdata* "
"argument specifies the ancillary data (control messages) as an iterable of "
"zero or more tuples ``(cmsg_level, cmsg_type, cmsg_data)``, where "
"*cmsg_level* and *cmsg_type* are integers specifying the protocol level and "
"protocol-specific type respectively, and *cmsg_data* is a bytes-like object "
"holding the associated data.  Note that some systems (in particular, systems "
"without :func:`CMSG_SPACE`) might support sending only one control message "
"per call.  The *flags* argument defaults to 0 and has the same meaning as "
"for :meth:`send`.  If *address* is supplied and not ``None``, it sets a "
"destination address for the message.  The return value is the number of "
"bytes of non-ancillary data sent."
msgstr ""
"Enviar datos normales y auxiliares al socket, recopilar los datos no "
"auxiliares de una serie de buffers y concatenando en un único mensaje.  El "
"argumento *buffers* especifica los datos no auxiliares como un iterable de :"
"term:`bytes-como objetos <bytes-like object>` (por ejemplo: objetos :class:"
"`bytes`); el sistema operativo puede establecer un límite (:func:`os."
"sysconf` valor ``SC_IOV_MAX``) en el número de buffers que se pueden "
"utilizar.  El argumento *ancdata* especifica los datos auxiliares (mensajes "
"de control) como un iterable de cero o más tuplas ``(cmsg_level, cmsg_type, "
"cmsg_data)``, donde *cmsg_level* y *cmsg_type* son enteros que especifican "
"el nivel de protocolo y el tipo específico del protocolo respectivamente, y "
"*cmsg_data* es un objeto similar a bytes que contiene los datos asociados.  "
"Tenga en cuenta que algunos sistemas (en particular, sistemas sin :func:"
"`CMSG_SPACE`) pueden admitir el envío de solo un mensaje de control por "
"llamada.  El valor predeterminado del argumento *flags* es 0 y tiene el "
"mismo significado que para :meth:`send`.  Si se proporciona *address* y no "
"``None``, establece una dirección de destino para el mensaje.  El valor "
"devuelto es el número de bytes de datos no auxiliares enviados."

#: ../Doc/library/socket.rst:1739
msgid ""
"The following function sends the list of file descriptors *fds* over an :"
"const:`AF_UNIX` socket, on systems which support the :const:`SCM_RIGHTS` "
"mechanism.  See also :meth:`recvmsg`. ::"
msgstr ""
"La siguiente función envía la lista de descriptores de archivos *fds* sobre "
"un socket :const:`AF_UNIX`, estos sistemas pueden soportar la mecánica :"
"const:`SCM_RIGHTS`. Observar también :meth:`recvmsg`. ::"

#, fuzzy
msgid ":ref:`Availability <availability>`: Unix, not WASI."
msgstr ":ref:`Availability <availability>`: Unix, no WASI."

#: ../Doc/library/socket.rst:1761
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendmsg`` with arguments "
"``self``, ``address``."
msgstr ""
"Genera un :ref:`auditing event <auditing>` ``socket.sendmsg`` con los "
"argumentos ``self``, ``address``."

#: ../Doc/library/socket.rst:1763
msgid ""
"Specialized version of :meth:`~socket.sendmsg` for :const:`AF_ALG` socket. "
"Set mode, IV, AEAD associated data length and flags for :const:`AF_ALG` "
"socket."
msgstr ""
"Versión especializada de :meth:`~socket.sendmsg` para el socket :const:"
"`AF_ALG`. Modo de ajuste, IV, longitud de datos asociados a AEAD y banderas "
"para el socket :const:`AF_ALG`."

#: ../Doc/library/socket.rst:1772
msgid ""
"Send a file until EOF is reached by using high-performance :mod:`os."
"sendfile` and return the total number of bytes which were sent. *file* must "
"be a regular file object opened in binary mode. If :mod:`os.sendfile` is not "
"available (e.g. Windows) or *file* is not a regular file :meth:`send` will "
"be used instead. *offset* tells from where to start reading the file. If "
"specified, *count* is the total number of bytes to transmit as opposed to "
"sending the file until EOF is reached. File position is updated on return or "
"also in case of error in which case :meth:`file.tell() <io.IOBase.tell>` can "
"be used to figure out the number of bytes which were sent. The socket must "
"be of :const:`SOCK_STREAM` type. Non-blocking sockets are not supported."
msgstr ""
"Enviar un archivo hasta que se alcance EOF mediante el uso de alto "
"rendimiento :mod:`os.sendfile` y devolver el número total de bytes que se "
"enviaron. *file* debe ser un objeto de archivo normal abierto en modo "
"binario. Si :mod:`os.sendfile` no está disponible (por ejemplo, Windows) o "
"*file* no es un archivo normal :meth:`send` se utilizará en su lugar. "
"*offset* indica desde dónde empezar a leer el archivo. Si se especifica, "
"*count* es el número total de bytes para transmitir en lugar de enviar el "
"archivo hasta que se alcance EOF. La posición del archivo se actualiza a la "
"vuelta o también en caso de error en cuyo caso :meth:`file.tell() <io.IOBase."
"tell>` se puede utilizar para averiguar el número de bytes que se enviaron. "
"El socket debe ser de tipo :const:`SOCK_STREAM` No se admiten sockets sin "
"bloqueo."

#: ../Doc/library/socket.rst:1788
msgid ""
"Set the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle."
msgstr ""
"Selecciona el :ref:`inheritable flag <fd_inheritance>` descriptor del "
"archivo del socket o el controlador del socket."

#: ../Doc/library/socket.rst:1796
msgid ""
"Set blocking or non-blocking mode of the socket: if *flag* is false, the "
"socket is set to non-blocking, else to blocking mode."
msgstr ""
"Establecer el modo de bloqueo o no bloqueo del socket: si *flag* es false, "
"el socket se establece en modo sin bloqueo, de lo contrario en modo de "
"bloqueo."

#: ../Doc/library/socket.rst:1799
msgid ""
"This method is a shorthand for certain :meth:`~socket.settimeout` calls:"
msgstr ""
"El método es una abreviatura para ciertas llamadas :meth:`~socket."
"settimeout`:"

#: ../Doc/library/socket.rst:1801
msgid "``sock.setblocking(True)`` is equivalent to ``sock.settimeout(None)``"
msgstr "``sock.setblocking(True)`` es equivalente a ``sock.settimeout(None)``"

#: ../Doc/library/socket.rst:1803
msgid "``sock.setblocking(False)`` is equivalent to ``sock.settimeout(0.0)``"
msgstr "``sock.setblocking(False)`` es equivalente a ``sock.settimeout(0.0)``"

#: ../Doc/library/socket.rst:1805
msgid ""
"The method no longer applies :const:`SOCK_NONBLOCK` flag on :attr:`socket."
"type`."
msgstr ""
"El método ya no aplica la bandera :const:`SOCK_NONBLOCK` en :attr:`socket."
"type`."

#: ../Doc/library/socket.rst:1812
msgid ""
"Set a timeout on blocking socket operations.  The *value* argument can be a "
"nonnegative floating point number expressing seconds, or ``None``. If a non-"
"zero value is given, subsequent socket operations will raise a :exc:"
"`timeout` exception if the timeout period *value* has elapsed before the "
"operation has completed.  If zero is given, the socket is put in non-"
"blocking mode. If ``None`` is given, the socket is put in blocking mode."
msgstr ""
"Establece un tiempo de espera para bloquear las operaciones de socket. El "
"argumento *value* puede ser un número de punto flotante no negativo que "
"exprese segundos, o ``None``. Si se da un valor distinto de cero, las "
"operaciones subsiguientes de socket lanzarán una excepción :exc:`timeout` si "
"el período de tiempo de espera *value* ha transcurrido antes de que se "
"complete la operación. Si se da cero, el socket se pone en modo sin bloqueo. "
"Si se da ``None``, el enchufe se pone en modo de bloqueo."

#: ../Doc/library/socket.rst:1819
msgid ""
"For further information, please consult the :ref:`notes on socket timeouts "
"<socket-timeouts>`."
msgstr ""
"Para obtener más información, consulte las notas :ref:`notas sobre los "
"tiempos de espera del socket <socket-timeouts>`."

#: ../Doc/library/socket.rst:1821
msgid ""
"The method no longer toggles :const:`SOCK_NONBLOCK` flag on :attr:`socket."
"type`."
msgstr ""
"El método ya no cambia la bandera :const:`SOCK_NONBLOCK` en  :attr:`socket."
"type`."

#: ../Doc/library/socket.rst:1834
msgid ""
"Set the value of the given socket option (see the Unix manual page :manpage:"
"`setsockopt(2)`).  The needed symbolic constants are defined in the :mod:"
"`socket` module (:const:`SO_\\*` etc.).  The value can be an integer, "
"``None`` or a :term:`bytes-like object` representing a buffer. In the later "
"case it is up to the caller to ensure that the bytestring contains the "
"proper bits (see the optional built-in module :mod:`struct` for a way to "
"encode C structures as bytestrings). When *value* is set to ``None``, "
"*optlen* argument is required. It's equivalent to call :c:func:`setsockopt` "
"C function with ``optval=NULL`` and ``optlen=optlen``."
msgstr ""
"Establece el valor de la opción de socket dada (consulte la página de manual "
"de Unix :manpage:`setsockopt(2)`). Las constantes simbólicas necesarias se "
"definen en el modulo :mod:`socket` (:const:`SO_\\*` etc.). El valor puede "
"ser un entero, ``None`` o un :term:`bytes-like object` representan un "
"buffer. En el último caso, depende de la persona que llama asegurarse de que "
"la cadena de bytes contenga los bits adecuados (consulte el módulo integrado "
"opcional :mod:`struct` para una forma de codificar estructuras C como "
"cadenas de bytes). Cuando *value* se establece en ``None``, el argumento "
"*optlen* es requerido. Esto es equivalente a llamar a una función C :c:func:"
"`setsockopt` con ``optval=NULL`` y ``optlen=optlen``."

#: ../Doc/library/socket.rst:1847
msgid "setsockopt(level, optname, None, optlen: int) form added."
msgstr "setsockopt(level, optname, None, optlen: int) form added."

#: ../Doc/library/socket.rst:1855
msgid ""
"Shut down one or both halves of the connection.  If *how* is :const:"
"`SHUT_RD`, further receives are disallowed.  If *how* is :const:`SHUT_WR`, "
"further sends are disallowed.  If *how* is :const:`SHUT_RDWR`, further sends "
"and receives are disallowed."
msgstr ""
"Apague una o ambas mitades de la conexión. Si *how* es :const:`SHUT_RD`, más "
"recibe no se permiten. Si *how* es  :const:`SHUT_WR`, mas recibe no se "
"permiten. Si *how* es :const:`SHUT_RDWR`, más recibe no se permiten."

#: ../Doc/library/socket.rst:1865
msgid ""
"Duplicate a socket and prepare it for sharing with a target process.  The "
"target process must be provided with *process_id*.  The resulting bytes "
"object can then be passed to the target process using some form of "
"interprocess communication and the socket can be recreated there using :func:"
"`fromshare`. Once this method has been called, it is safe to close the "
"socket since the operating system has already duplicated it for the target "
"process."
msgstr ""
"Duplica un socket y lo prepara para compartirlo con el proceso de destino. "
"El proceso de destino debe estar provisto de *process_id*. el objeto de "
"bytes resultante luego se puede pasar al proceso de destino usando alguna "
"forma de comunicación entre procesos y el socket se puede recrear allí "
"usando  :func:`fromshare`. Una vez que se ha llamado a este método, es "
"seguro cerrar el socket ya que el sistema operativo ya lo ha duplicado para "
"el proceso de destino."

#: ../Doc/library/socket.rst:1877
msgid ""
"Note that there are no methods :meth:`read` or :meth:`write`; use :meth:"
"`~socket.recv` and :meth:`~socket.send` without *flags* argument instead."
msgstr ""
"Tenga en cuenta que no hay métodos :meth:`read` o :meth:`write`; use :meth:"
"`~socket.recv` y :meth:`~socket.send` sin el argumento *flags* en su lugar."

#: ../Doc/library/socket.rst:1880
msgid ""
"Socket objects also have these (read-only) attributes that correspond to the "
"values given to the :class:`~socket.socket` constructor."
msgstr ""
"Los objetos de socket también tienen estos atributos (de solo lectura) que "
"corresponden a los valores dados al constructor :class:`~socket.socket`."

#: ../Doc/library/socket.rst:1886
msgid "The socket family."
msgstr "La familia socket."

#: ../Doc/library/socket.rst:1891
msgid "The socket type."
msgstr "El tipo de socket."

#: ../Doc/library/socket.rst:1896
msgid "The socket protocol."
msgstr "The socket protocol."

#: ../Doc/library/socket.rst:1903
msgid "Notes on socket timeouts"
msgstr "Notas sobre los tiempos de espera del socket"

#: ../Doc/library/socket.rst:1905
msgid ""
"A socket object can be in one of three modes: blocking, non-blocking, or "
"timeout.  Sockets are by default always created in blocking mode, but this "
"can be changed by calling :func:`setdefaulttimeout`."
msgstr ""
"Un objeto de socket puede estar en uno de los tres modos: bloqueo, no "
"bloqueo o tiempo de espera.  Los sockets se crean de forma predeterminada "
"siempre en modo de bloqueo, pero esto se puede cambiar llamando a :func:"
"`setdefaulttimeout`."

#: ../Doc/library/socket.rst:1909
msgid ""
"In *blocking mode*, operations block until complete or the system returns an "
"error (such as connection timed out)."
msgstr ""
"En el modo *bloqueo*, las operaciones se bloquean hasta que se completan o "
"el sistema devuelve un error (como tiempo de espera de conexión agotado)."

#: ../Doc/library/socket.rst:1912
msgid ""
"In *non-blocking mode*, operations fail (with an error that is unfortunately "
"system-dependent) if they cannot be completed immediately: functions from "
"the :mod:`select` can be used to know when and whether a socket is available "
"for reading or writing."
msgstr ""
"En el modo *sin bloqueo*, las operaciones fallan (con un error que, por "
"desgracia, depende del sistema) si no se pueden completar inmediatamente: "
"las funciones de :mod:`select` se pueden utilizar para saber cuándo y si un "
"socket está disponible para leer o escribir."

#: ../Doc/library/socket.rst:1917
msgid ""
"In *timeout mode*, operations fail if they cannot be completed within the "
"timeout specified for the socket (they raise a :exc:`timeout` exception) or "
"if the system returns an error."
msgstr ""
"En *timeout mode*, las operaciones fallan si no se puede completan el tiempo "
"de espera especifico para el socket (ellos lanzan una excepción :exc:"
"`timeout`) o si el sistema devuelve un error."

#: ../Doc/library/socket.rst:1922
msgid ""
"At the operating system level, sockets in *timeout mode* are internally set "
"in non-blocking mode.  Also, the blocking and timeout modes are shared "
"between file descriptors and socket objects that refer to the same network "
"endpoint. This implementation detail can have visible consequences if e.g. "
"you decide to use the :meth:`~socket.fileno()` of a socket."
msgstr ""
"En el nivel del sistema operativo, los sockets en el *timeout mode* se "
"establecen internamente en modo sin bloqueo.  Además, los modos de bloqueo y "
"tiempo de espera se comparten entre descriptores de archivo y objetos de "
"socket que hacen referencia al mismo punto de conexión de red. Este detalle "
"de implementación puede tener consecuencias visibles si, por ejemplo, decide "
"utilizar el :meth:`~socket.fileno()` de un socket."

#: ../Doc/library/socket.rst:1929
msgid "Timeouts and the ``connect`` method"
msgstr "Tiempos de espera y el método ``connect``"

#: ../Doc/library/socket.rst:1931
msgid ""
"The :meth:`~socket.connect` operation is also subject to the timeout "
"setting, and in general it is recommended to call :meth:`~socket.settimeout` "
"before calling :meth:`~socket.connect` or pass a timeout parameter to :meth:"
"`create_connection`.  However, the system network stack may also return a "
"connection timeout error of its own regardless of any Python socket timeout "
"setting."
msgstr ""
"La operación :meth:`~socket.connect` también está sujeta a la configuración "
"de tiempo de espera, y en general se recomienda llamar a :meth:`~socket."
"settimeout` antes de llamar a :meth:`~socket.connect` o pasar un parámetro "
"de tiempo de espera a :meth:`create_connection`.  Sin embargo, la pila de "
"red del sistema también puede devolver un error de tiempo de espera de "
"conexión propio independientemente de cualquier configuración de tiempo de "
"espera del socket de Python."

#: ../Doc/library/socket.rst:1939
msgid "Timeouts and the ``accept`` method"
msgstr "Tiempos de espera y el método ``accept``"

#: ../Doc/library/socket.rst:1941
msgid ""
"If :func:`getdefaulttimeout` is not :const:`None`, sockets returned by the :"
"meth:`~socket.accept` method inherit that timeout.  Otherwise, the behaviour "
"depends on settings of the listening socket:"
msgstr ""
"Si :func:`getdefaulttimeout` no es una :const:`None`, los sockets devuelto "
"por el método :meth:`~socket.accept` heredan ese tiempo de espera. De lo "
"contrario, el comportamiento depende de la configuración de la toma de "
"escucha:"

#: ../Doc/library/socket.rst:1945
msgid ""
"if the listening socket is in *blocking mode* or in *timeout mode*, the "
"socket returned by :meth:`~socket.accept` is in *blocking mode*;"
msgstr ""
"si los sockets están escuchando en *blocking mode* o en el *timeout mode*, "
"el socket devuelve el :meth:`~socket.accept` en un *blocking mode*;"

#: ../Doc/library/socket.rst:1948
msgid ""
"if the listening socket is in *non-blocking mode*, whether the socket "
"returned by :meth:`~socket.accept` is in blocking or non-blocking mode is "
"operating system-dependent.  If you want to ensure cross-platform behaviour, "
"it is recommended you manually override this setting."
msgstr ""
"si los sockets están escuchando en *non-blocking mode*, ya sea el socket "
"devuelto por :meth:`~socket.accept` es un modo de bloqueo o no bloque "
"depende del sistema operativo. Si desea garantizar un comportamiento "
"multiplataforma, se recomienda que se anule manualmente esta configuración."

#: ../Doc/library/socket.rst:1957
msgid "Example"
msgstr "Ejemplo"

#: ../Doc/library/socket.rst:1959
msgid ""
"Here are four minimal example programs using the TCP/IP protocol: a server "
"that echoes all data that it receives back (servicing only one client), and "
"a client using it.  Note that a server must perform the sequence :func:`."
"socket`, :meth:`~socket.bind`, :meth:`~socket.listen`, :meth:`~socket."
"accept` (possibly repeating the :meth:`~socket.accept` to service more than "
"one client), while a client only needs the sequence :func:`.socket`, :meth:"
"`~socket.connect`.  Also note that the server does not :meth:`~socket."
"sendall`/:meth:`~socket.recv` on the socket it is listening on but on the "
"new socket returned by :meth:`~socket.accept`."
msgstr ""
"Aquí están cuatro programas mínimos usando el protocolo TCP/IP: un servidor "
"que hace eco de todos los datos que reciban de vuelta ( Servicio a un solo "
"cliente), y un cliente usando esto. Recuerde que un servidor debe llevar a "
"cabo la secuencia :func:`.socket`, :meth:`~socket.bind`, :meth:`~socket."
"listen`, :meth:`~socket.accept` (posiblemente repitiendo la :meth:`~socket."
"accept` para un servicio mas que un cliente), mientras un cliente solamente "
"necesita la secuencia :func:`.socket`, :meth:`~socket.connect`. También "
"recuerde que el servidor no :meth:`~socket.sendall`/:meth:`~socket.recv` en "
"el socket esta escuchando pero en el nuevo socket devuelto por :meth:"
"`~socket.accept`."

#: ../Doc/library/socket.rst:1969
msgid "The first two examples support IPv4 only. ::"
msgstr "Los dos primeros ejemplos solo admiten IPv4. ::"

#: ../Doc/library/socket.rst:2000
msgid ""
"The next two examples are identical to the above two, but support both IPv4 "
"and IPv6. The server side will listen to the first address family available "
"(it should listen to both instead). On most of IPv6-ready systems, IPv6 will "
"take precedence and the server may not accept IPv4 traffic. The client side "
"will try to connect to the all addresses returned as a result of the name "
"resolution, and sends traffic to the first one connected successfully. ::"
msgstr ""
"Los dos ejemplos siguientes son idénticos a los dos anteriores, pero admiten "
"IPv4 e IPv6. El lado del servidor escuchará la primera familia de "
"direcciones disponible (debe escuchar ambas en su lugar). En la mayoría de "
"los sistemas listos para IPv6, IPv6 tendrá prioridad y es posible que el "
"servidor no acepte tráfico IPv4. El lado del cliente intentará conectarse a "
"todas las direcciones devueltas como resultado de la resolución de nombres y "
"enviará el tráfico al primero conectado correctamente. ::"

#: ../Doc/library/socket.rst:2072
msgid ""
"The next example shows how to write a very simple network sniffer with raw "
"sockets on Windows. The example requires administrator privileges to modify "
"the interface::"
msgstr ""
"El siguiente ejemplo muestra cómo escribir un rastreador de red muy simple "
"con sockets sin procesar en Windows. El ejemplo requiere privilegios de "
"administrador para modificar la interfaz:"

#: ../Doc/library/socket.rst:2097
msgid ""
"The next example shows how to use the socket interface to communicate to a "
"CAN network using the raw socket protocol. To use CAN with the broadcast "
"manager protocol instead, open a socket with::"
msgstr ""
"En el ejemplo siguiente se muestra cómo utilizar la interfaz de socket para "
"comunicarse con una red CAN mediante el protocolo de socket sin procesar. "
"Para utilizar CAN con el protocolo de gestor de difusión en su lugar, abra "
"un socket con:"

#: ../Doc/library/socket.rst:2103
msgid ""
"After binding (:const:`CAN_RAW`) or connecting (:const:`CAN_BCM`) the "
"socket, you can use the :meth:`socket.send`, and the :meth:`socket.recv` "
"operations (and their counterparts) on the socket object as usual."
msgstr ""
"Después de enlazar (:const:`CAN_RAW`) o conectar (:const:`CAN_BCM`) el "
"socket, puede usar las operaciones :meth:`socket.send` y :meth:`socket.recv` "
"(y sus contrapartes) en el objeto de socket como de costumbre."

#: ../Doc/library/socket.rst:2107
msgid "This last example might require special privileges::"
msgstr "Este último ejemplo puede requerir privilegios especiales:"

#: ../Doc/library/socket.rst:2147
msgid ""
"Running an example several times with too small delay between executions, "
"could lead to this error::"
msgstr ""
"Ejecutar un ejemplo varias veces con un retraso demasiado pequeño entre "
"ejecuciones, podría dar lugar a este error::"

#: ../Doc/library/socket.rst:2152
msgid ""
"This is because the previous execution has left the socket in a "
"``TIME_WAIT`` state, and can't be immediately reused."
msgstr ""
"Esto se debe a que la ejecución anterior ha dejado el socket en un estado "
"``TIME_WAIT`` y no se puede reutilizar inmediatamente."

#: ../Doc/library/socket.rst:2155
msgid ""
"There is a :mod:`socket` flag to set, in order to prevent this, :data:"
"`socket.SO_REUSEADDR`::"
msgstr ""
"Este es una bandera :mod:`socket` para establecer, en orden para prevenir "
"esto, :data:`socket.SO_REUSEADDR`::"

#: ../Doc/library/socket.rst:2162
msgid ""
"the :data:`SO_REUSEADDR` flag tells the kernel to reuse a local socket in "
"``TIME_WAIT`` state, without waiting for its natural timeout to expire."
msgstr ""
"el indicador :data:`SO_REUSEADDR` indica al kernel que reutilice un socket "
"local en estado ``TIME_WAIT``, sin esperar a que expire su tiempo de espera "
"natural."

#: ../Doc/library/socket.rst:2168
msgid ""
"For an introduction to socket programming (in C), see the following papers:"
msgstr ""
"Para obtener una introducción a la programación de sockets (en C), consulte "
"los siguientes documentos:"

#: ../Doc/library/socket.rst:2170
msgid ""
"*An Introductory 4.3BSD Interprocess Communication Tutorial*, by Stuart "
"Sechrest"
msgstr ""
"*An Introductory 4.3BSD Interprocess Communication Tutorial*, por Stuart "
"Sechrest"

#: ../Doc/library/socket.rst:2172
msgid ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*, by Samuel J.  "
"Leffler et al,"
msgstr ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*, por Samuel J.  "
"Leffler et al,"

#: ../Doc/library/socket.rst:2175
msgid ""
"both in the UNIX Programmer's Manual, Supplementary Documents 1 (sections "
"PS1:7 and PS1:8).  The platform-specific reference material for the various "
"socket-related system calls are also a valuable source of information on the "
"details of socket semantics.  For Unix, refer to the manual pages; for "
"Windows, see the WinSock (or Winsock 2) specification.  For IPv6-ready APIs, "
"readers may want to refer to :rfc:`3493` titled Basic Socket Interface "
"Extensions for IPv6."
msgstr ""
"ambos en el manual del programador de Unix, documentos suplementarios 1 "
"( secciones  PS1:7 y PS1:8). La plataforma especifica material de referencia "
"para las diversas llamadas al sistema también son una valiosa fuente de "
"información en los detalles de la semántica del socket. Para Unix, "
"referencia a las paginas del manual, para Windows, observa la especificación "
"WinSock (o WinSock 2). Para APIS listas IPV6, los lectores pueden querer "
"referirse al titulado Extensiones básicas de interfaz de socket para IPv6 :"
"rfc:`3493` ."

#~ msgid ""
#~ ":ref:`Availability <availability>`: Unix (maybe not all platforms), "
#~ "Windows."
#~ msgstr ""
#~ ":ref:`Disponibilidad <availability>`: Unix(Tal vez no todas las "
#~ "plataformas), Windows."

#~ msgid ""
#~ ":ref:`Availability <availability>`: most Unix platforms, possibly others."
#~ msgstr ""
#~ ":ref:`Availability <availability>`: la mayoría de plataformas Unix, "
#~ "posiblemente otras."

#~ msgid ""
#~ ":ref:`Availability <availability>`: Unix supporting :meth:`~socket."
#~ "recvmsg` and :const:`SCM_RIGHTS` mechanism."
#~ msgstr ""
#~ ":ref:`Availability <availability>`: Soporte para Unix :meth:`~socket."
#~ "recvmsg` y el mecanismo :const:`SCM_RIGHTS`."
