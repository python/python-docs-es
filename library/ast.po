# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2023-10-22 21:17-0500\n"
"Last-Translator: Marco Richetta <marcorichetta@gmail.com>\n"
"Language-Team: python-doc-es\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.13.0\n"
"X-Generator: Poedit 2.3\n"

#: ../Doc/library/ast.rst:2
msgid ":mod:`ast` --- Abstract Syntax Trees"
msgstr ":mod:`ast` --- Árboles de sintaxis abstracta"

#: ../Doc/library/ast.rst:14
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**Código fuente:** :source:`Lib/ast.py`"

#: ../Doc/library/ast.rst:18
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""
"El módulo :mod:`ast` ayuda a las aplicaciones de Python a procesar árboles "
"de la gramática de sintaxis abstracta de Python. La sintaxis abstracta en sí "
"misma puede cambiar con cada versión de Python; Este módulo ayuda a "
"descubrir mediante programación cómo se ve la gramática actual."

#: ../Doc/library/ast.rst:23
msgid ""
"An abstract syntax tree can be generated by passing :data:`ast."
"PyCF_ONLY_AST` as a flag to the :func:`compile` built-in function, or using "
"the :func:`parse` helper provided in this module.  The result will be a tree "
"of objects whose classes all inherit from :class:`ast.AST`.  An abstract "
"syntax tree can be compiled into a Python code object using the built-in :"
"func:`compile` function."
msgstr ""
"Se puede generar un árbol de sintaxis abstracta pasando :data:`ast."
"PyCF_ONLY_AST` como un indicador de la función incorporada :func:`compile`, "
"o usando el ayudante :func:`parse` provisto en este módulo. El resultado "
"será un árbol de objetos cuyas clases todas heredan de :class:`ast.AST`. Se "
"puede compilar un árbol de sintaxis abstracta en un objeto de código Python "
"utilizando la función incorporada :func:`compile`."

#: ../Doc/library/ast.rst:33
msgid "Abstract Grammar"
msgstr "Gramática abstracta"

#: ../Doc/library/ast.rst:35
msgid "The abstract grammar is currently defined as follows:"
msgstr "La gramática abstracta se define actualmente de la siguiente manera:"

#: ../Doc/library/ast.rst:42
msgid "Node classes"
msgstr "Clases nodo"

#: ../Doc/library/ast.rst:46
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced :ref:"
"`above <abstract-grammar>`.  They are defined in the :mod:`_ast` C module "
"and re-exported in :mod:`ast`."
msgstr ""
"Esta es la base de todas las clases de nodo AST.  Las clases de nodo reales "
"se derivan del archivo :file:`Parser/Python.asdl`, que se reproduce :ref:"
"`abajo <abstract-grammar>`.  Se definen en el módulo :mod:`_ast` C y se "
"reexportan en :mod:`ast`."

#: ../Doc/library/ast.rst:51
msgid ""
"There is one class defined for each left-hand side symbol in the abstract "
"grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In addition, "
"there is one class defined for each constructor on the right-hand side; "
"these classes inherit from the classes for the left-hand side trees.  For "
"example, :class:`ast.BinOp` inherits from :class:`ast.expr`.  For production "
"rules with alternatives (aka \"sums\"), the left-hand side class is "
"abstract: only instances of specific constructor nodes are ever created."
msgstr ""
"Hay una clase definida para cada símbolo del lado izquierdo en la gramática "
"abstracta (por ejemplo, :class:`ast.stmt` o :class:`ast.expr`). Además, hay "
"una clase definida para cada constructor en el lado derecho; estas clases "
"heredan de las clases para los árboles del lado izquierdo. Por ejemplo, :"
"class:`ast.BinOp` hereda de :class:`ast.expr`. Para las reglas de producción "
"con alternativas (también conocidas como \"sumas\"), la clase del lado "
"izquierdo es abstracta: solo se crean instancias de nodos de constructor "
"específicos."

#: ../Doc/library/ast.rst:64
msgid ""
"Each concrete class has an attribute :attr:`_fields` which gives the names "
"of all child nodes."
msgstr ""
"Cada clase concreta tiene un atributo :attr:`_fields` que proporciona los "
"nombres de todos los nodos secundarios."

#: ../Doc/library/ast.rst:67
msgid ""
"Each instance of a concrete class has one attribute for each child node, of "
"the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""
"Cada instancia de una clase concreta tiene un atributo para cada nodo "
"secundario, del tipo definido en la gramática. Por ejemplo, las instancias :"
"class:`ast.BinOp` tienen un atributo :attr:`left` de tipo :class:`ast.expr`."

#: ../Doc/library/ast.rst:71
msgid ""
"If these attributes are marked as optional in the grammar (using a question "
"mark), the value might be ``None``.  If the attributes can have zero-or-more "
"values (marked with an asterisk), the values are represented as Python "
"lists.  All possible attributes must be present and have valid values when "
"compiling an AST with :func:`compile`."
msgstr ""
"Si estos atributos están marcados como opcionales en la gramática (usando un "
"signo de interrogación), el valor podría ser ``None``. Si los atributos "
"pueden tener cero o más valores (marcados con un asterisco), los valores se "
"representan como listas de Python. Todos los atributos posibles deben estar "
"presentes y tener valores válidos al compilar un AST con :func:`compile`."

#: ../Doc/library/ast.rst:82
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have :attr:"
"`lineno`, :attr:`col_offset`, :attr:`end_lineno`, and :attr:`end_col_offset` "
"attributes.  The :attr:`lineno` and :attr:`end_lineno` are the first and "
"last line numbers of source text span (1-indexed so the first line is line "
"1) and the :attr:`col_offset` and :attr:`end_col_offset` are the "
"corresponding UTF-8 byte offsets of the first and last tokens that generated "
"the node. The UTF-8 offset is recorded because the parser uses UTF-8 "
"internally."
msgstr ""
"Las instancias de las subclases :class:`ast.expr` y :class:`ast.stmt` tienen "
"atributos :attr:`lineno`, :attr:`col_offset`, :attr:`lineno`, y :attr:"
"`col_offset`. :attr:`lineno` y :attr:`end_lineno` son los números de la "
"primera y última línea del intervalo de texto de origen (1 indexado, por lo "
"que la primera línea es la línea 1), y :attr:`col_offset` y :attr:"
"`end_col_offset` son las correspondientes compensaciones de bytes UTF-8 del "
"primer y último token que generó el nodo. El desplazamiento UTF-8 se "
"registra porque el analizador utiliza UTF-8 internamente."

#: ../Doc/library/ast.rst:91
msgid ""
"Note that the end positions are not required by the compiler and are "
"therefore optional. The end offset is *after* the last symbol, for example "
"one can get the source segment of a one-line expression node using "
"``source_line[node.col_offset : node.end_col_offset]``."
msgstr ""
"Tenga en cuenta que el compilador no requiere las posiciones finales y, por "
"lo tanto, son opcionales. El desplazamiento final es *después* del último "
"símbolo, por ejemplo, uno puede obtener el segmento fuente de un nodo de "
"expresión de una línea usando ``source_line[node.col_offset: node."
"end_col_offset]``."

#: ../Doc/library/ast.rst:96
msgid ""
"The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr ""
"El constructor de una clase :class:`ast.T` analiza sus argumentos de la "
"siguiente manera:"

#: ../Doc/library/ast.rst:98
msgid ""
"If there are positional arguments, there must be as many as there are items "
"in :attr:`T._fields`; they will be assigned as attributes of these names."
msgstr ""
"Si hay argumentos posicionales, debe haber tantos como elementos en :attr:`T."
"_fields`; serán asignados como atributos de estos nombres."

#: ../Doc/library/ast.rst:100
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr ""
"Si hay argumentos de palabras clave, establecerán los atributos de los "
"mismos nombres a los valores dados."

#: ../Doc/library/ast.rst:103
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you could "
"use ::"
msgstr ""
"Por ejemplo, para crear y completar un nodo :class:`ast.UnaryOp`, puede "
"usar ::"

#: ../Doc/library/ast.rst:115
msgid "or the more compact ::"
msgstr "o la más compacta ::"

#: ../Doc/library/ast.rst:122
msgid "Class :class:`ast.Constant` is now used for all constants."
msgstr "La clase :class:`ast.Constant` ahora se usa para todas las constantes."

#: ../Doc/library/ast.rst:126
msgid ""
"Simple indices are represented by their value, extended slices are "
"represented as tuples."
msgstr ""
"Los índices simples se representan por su valor, los segmentos extendidos se "
"representan como tuplas."

#: ../Doc/library/ast.rst:131
msgid ""
"Old classes :class:`ast.Num`, :class:`ast.Str`, :class:`ast.Bytes`, :class:"
"`ast.NameConstant` and :class:`ast.Ellipsis` are still available, but they "
"will be removed in future Python releases.  In the meantime, instantiating "
"them will return an instance of a different class."
msgstr ""
"Las clases antiguas :class:`ast. Num`, :class:`ast. Str`, :class:`ast. "
"Bytes`, :class:`ast. NameConstant` y :class:`ast.Ellipsis` todavía están "
"disponibles, pero se eliminarán en futuras versiones de Python. Mientras "
"tanto, crear sus instancias retornará una instancia de una clase diferente."

#: ../Doc/library/ast.rst:138
msgid ""
"Old classes :class:`ast.Index` and :class:`ast.ExtSlice` are still "
"available, but they will be removed in future Python releases. In the "
"meantime, instantiating them will return an instance of a different class."
msgstr ""
"Las clases antiguas :class:`ast.Index` y :class:`ast.ExtSlice` todavía están "
"disponibles, pero se eliminarán en futuras versiones de Python. Mientras "
"tanto, crear sus instancias retornará una instancia de una clase diferente."

#: ../Doc/library/ast.rst:144
msgid ""
"The descriptions of the specific node classes displayed here were initially "
"adapted from the fantastic `Green Tree Snakes <https://greentreesnakes."
"readthedocs.io/en/latest/>`__ project and all its contributors."
msgstr ""
"Las descripciones de las clases de nodo específicas mostradas aquí fueron "
"adaptadas inicialmente del fantástico proyecto `Green Tree Snakes <https://"
"greentreesnakes.readthedocs.io/en/latest/>`__ y todos sus contribuidores."

#: ../Doc/library/ast.rst:153
msgid "Root nodes"
msgstr "Nodos raíz"

#: ../Doc/library/ast.rst:157
msgid ""
"A Python module, as with :ref:`file input <file-input>`. Node type generated "
"by :func:`ast.parse` in the default ``\"exec\"`` *mode*."
msgstr ""
"Un módulo de Python, como con :ref:`archivo-entrada <file-input>`. Tipo de "
"nodo generado por :func:`ast.parse` en el modo por defecto ``\"exec\"`` "
"*mode*.*mode*."

#: ../Doc/library/ast.rst:160
msgid "*body* is a :class:`list` of the module's :ref:`ast-statements`."
msgstr "*body* es una :class:`list` de las :ref:`ast-statements` del módulo."

#: ../Doc/library/ast.rst:162
msgid ""
"*type_ignores* is a :class:`list` of the module's type ignore comments; see :"
"func:`ast.parse` for more details."
msgstr ""
"*type_ignores* es una :class:`list` de los comentarios para ignorar tipos "
"del módulo; véase :func:`ast.parse` para más detalles."

#: ../Doc/library/ast.rst:179
msgid ""
"A single Python :ref:`expression input <expression-input>`. Node type "
"generated by :func:`ast.parse` when *mode* is ``\"eval\"``."
msgstr ""
"Una única :ref:`expression input <expression-input>` de Python. Tipo de nodo "
"generado por :func:`ast.parse` cuando *mode* es ``\"eval\"``."

#: ../Doc/library/ast.rst:182
msgid ""
"*body* is a single node, one of the :ref:`expression types <ast-"
"expressions>`."
msgstr ""
"*body* es un único nodo, uno de los :ref:`tipos de expresión <ast-"
"expressions>`."

#: ../Doc/library/ast.rst:194
msgid ""
"A single :ref:`interactive input <interactive>`, like in :ref:`tut-interac`. "
"Node type generated by :func:`ast.parse` when *mode* is ``\"single\"``."
msgstr ""
"Una única :ref:`entrada interactiva <interactive>`, como en :ref:`tut-"
"interac`. Tipo de nodo generado por :func:`ast.parse` cuando *mode* es "
"``\"single\"``."

#: ../Doc/library/ast.rst:197
msgid "*body* is a :class:`list` of :ref:`statement nodes <ast-statements>`."
msgstr ""
"*body* es una :class:`list` de :ref:`nodos de declaración <ast-statements>`."

#: ../Doc/library/ast.rst:216
msgid ""
"A representation of an old-style type comments for functions, as Python "
"versions prior to 3.5 didn't support :pep:`484` annotations. Node type "
"generated by :func:`ast.parse` when *mode* is ``\"func_type\"``."
msgstr ""
"Una interpretación de un comentario de tipo de estilo antiguo para "
"funciones, ya que las versiones de Python anteriores a la 3.5 no soportaban "
"anotaciones :pep:`484`. Tipo de nodo generado por :func:`ast.parse` cuando "
"*mode* es ``\"func_type\"``."

#: ../Doc/library/ast.rst:220
msgid "Such type comments would look like this::"
msgstr "Los comentarios de este tipo tendrían el siguiente aspecto::"

#: ../Doc/library/ast.rst:226
msgid ""
"*argtypes* is a :class:`list` of :ref:`expression nodes <ast-expressions>`."
msgstr ""
"*argtypes* es una :class:`list` de :ref:`nodos de expresión <ast-"
"expressions>`."

#: ../Doc/library/ast.rst:228
msgid "*returns* is a single :ref:`expression node <ast-expressions>`."
msgstr "*returns* es un único :ref:`nodo de expresión <ast-expressions>`."

#: ../Doc/library/ast.rst:246
msgid "Literals"
msgstr "Literales"

#: ../Doc/library/ast.rst:250
msgid ""
"A constant value. The ``value`` attribute of the ``Constant`` literal "
"contains the Python object it represents. The values represented can be "
"simple types such as a number, string or ``None``, but also immutable "
"container types (tuples and frozensets) if all of their elements are "
"constant."
msgstr ""
"Un valor constante. El atributo ``value`` del literal ``Constant`` contiene "
"el objeto de Python que este representa. Los valores representados pueden "
"ser de tipos simple como un número, una cadena de caracteres o ``None``; "
"pero también pueden ser de tipos de contenedores inmutables (tuplas y "
"``frozensets``) si todos sus elementos son constantes."

#: ../Doc/library/ast.rst:264
msgid ""
"Node representing a single formatting field in an f-string. If the string "
"contains a single formatting field and nothing else the node can be isolated "
"otherwise it appears in :class:`JoinedStr`."
msgstr ""
"Nodo que representa un único campo de formato en una ``f-string``. Si la "
"cadena de caracteres contiene un único campo de formato y nada más, el nodo "
"puede estar aislado de otra manera aparece en  :class:`JoinedStr`."

#: ../Doc/library/ast.rst:268
msgid ""
"``value`` is any expression node (such as a literal, a variable, or a "
"function call)."
msgstr ""
"``value`` es cualquier nodo de expresión (como un literal, una variable o "
"una llamada a función)."

#: ../Doc/library/ast.rst:270
msgid "``conversion`` is an integer:"
msgstr "``conversion`` es un entero:"

#: ../Doc/library/ast.rst:272
msgid "-1: no formatting"
msgstr "-1: sin formato"

#: ../Doc/library/ast.rst:273
msgid "115: ``!s`` string formatting"
msgstr "115: ``!s`` formato de cadena de caracteres"

#: ../Doc/library/ast.rst:274
msgid "114: ``!r`` repr formatting"
msgstr "114: ``!r`` formato repr"

#: ../Doc/library/ast.rst:275
msgid "97: ``!a`` ascii formatting"
msgstr "97: ``!a`` formato ascii"

#: ../Doc/library/ast.rst:277
msgid ""
"``format_spec`` is a :class:`JoinedStr` node representing the formatting of "
"the value, or ``None`` if no format was specified. Both ``conversion`` and "
"``format_spec`` can be set at the same time."
msgstr ""
"``format_spec`` es un nodo :class:`JoinedStr` que representa el formato del "
"valor, o ``None`` si no se ha especificado un formato. Ambos, ``conversion`` "
"y ``format_spec``, pueden estar especificados al mismo tiempo."

#: ../Doc/library/ast.rst:284
msgid ""
"An f-string, comprising a series of :class:`FormattedValue` and :class:"
"`Constant` nodes."
msgstr ""
"Un f-string que comprende una serie de nodos :class:`FormattedValue` y :"
"class:`Constant`."

#: ../Doc/library/ast.rst:313
msgid ""
"A list or tuple. ``elts`` holds a list of nodes representing the elements. "
"``ctx`` is :class:`Store` if the container is an assignment target (i.e. "
"``(x,y)=something``), and :class:`Load` otherwise."
msgstr ""
"Una lista o tupla. ``elts`` contiene una lista de nodos que representa a los "
"elementos. ``ctx`` es :class:`Store` si el contenedor es un objetivo de "
"asignación (por ejemplo ``(x,y)=something``), y :class:`Load` en cualquier "
"otro caso."

#: ../Doc/library/ast.rst:339
msgid "A set. ``elts`` holds a list of nodes representing the set's elements."
msgstr ""
"Un set. ``elts`` contiene una lista de nodos que representa a un set de "
"elementos."

#: ../Doc/library/ast.rst:354
msgid ""
"A dictionary. ``keys`` and ``values`` hold lists of nodes representing the "
"keys and the values respectively, in matching order (what would be returned "
"when calling :code:`dictionary.keys()` and :code:`dictionary.values()`)."
msgstr ""
"Un diccionario. ``keys`` y ``values`` contienen listas de nodos que "
"representan las claves y los valores respectivamente en el orden "
"correspondiente (el orden que retornaría :code:`dictionary.keys()` y :code:"
"`dictionary.values()`)."

#: ../Doc/library/ast.rst:358
msgid ""
"When doing dictionary unpacking using dictionary literals the expression to "
"be expanded goes in the ``values`` list, with a ``None`` at the "
"corresponding position in ``keys``."
msgstr ""
"Cuando se desempaqueta un diccionario utilizando literales de diccionario, "
"la expresión a ser expandida va en la lista ``values``, con ``None`` en la "
"posición correspondiente en ``keys``."

#: ../Doc/library/ast.rst:376
msgid "Variables"
msgstr "Variables"

#: ../Doc/library/ast.rst:380
msgid ""
"A variable name. ``id`` holds the name as a string, and ``ctx`` is one of "
"the following types."
msgstr ""
"Un nombre de variable. ``id`` contiene el nombre de una cadena de caracteres "
"y ``ctx`` es uno de los siguientes tipos."

#: ../Doc/library/ast.rst:388
msgid ""
"Variable references can be used to load the value of a variable, to assign a "
"new value to it, or to delete it. Variable references are given a context to "
"distinguish these cases."
msgstr ""
"Referencias a variables que pueden ser usadas para cargar el valor de una "
"variable, asignar un nuevo valor o borrarlo. Las referencias a variables "
"reciben un contexto para distinguir entre estos casos."

#: ../Doc/library/ast.rst:421
msgid ""
"A ``*var`` variable reference. ``value`` holds the variable, typically a :"
"class:`Name` node. This type must be used when building a :class:`Call` node "
"with ``*args``."
msgstr ""
"Una referencia a variable ``*var``. ``value`` contiene la variable, "
"típicamente un nodo :class:`Name`. Este tipo puede ser usado cuando se "
"construye un nodo :class:`Call` con ``*args``."

#: ../Doc/library/ast.rst:446
msgid "Expressions"
msgstr "Expresiones"

#: ../Doc/library/ast.rst:450
msgid ""
"When an expression, such as a function call, appears as a statement by "
"itself with its return value not used or stored, it is wrapped in this "
"container. ``value`` holds one of the other nodes in this section, a :class:"
"`Constant`, a :class:`Name`, a :class:`Lambda`, a :class:`Yield` or :class:"
"`YieldFrom` node."
msgstr ""
"Cuando una expresión, como un llamado a función, aparece como una "
"declaración por sí misma sin que su valor de retorno se use o se almacene, "
"está dentro de este contenedor. ``value`` contiene uno de los otros nodos en "
"esta sección, un nodo :class:`Constant`, :class:`Name`, :class:`Lambda`, :"
"class:`Yield` o :class:`YieldFrom`."

#: ../Doc/library/ast.rst:469
msgid ""
"A unary operation. ``op`` is the operator, and ``operand`` any expression "
"node."
msgstr ""
"Una operación unaria. ``op`` es el operador y ``operand`` es cualquier nodo "
"de expresión."

#: ../Doc/library/ast.rst:478
msgid ""
"Unary operator tokens. :class:`Not` is the ``not`` keyword, :class:`Invert` "
"is the ``~`` operator."
msgstr ""
"Tokens de operador unario. :class:`Not` es la palabra clave ``not``, :class:"
"`Invert` es el operador ``~``."

#: ../Doc/library/ast.rst:492
msgid ""
"A binary operation (like addition or division). ``op`` is the operator, and "
"``left`` and ``right`` are any expression nodes."
msgstr ""
"Una operación binaria (como la suma o división(. ``op`` es el operador, y "
"``left`` y ``right`` son cualquier nodo de expresión."

#: ../Doc/library/ast.rst:519
msgid "Binary operator tokens."
msgstr "Tokens de operador binario."

#: ../Doc/library/ast.rst:524
msgid ""
"A boolean operation, 'or' or 'and'. ``op`` is :class:`Or` or :class:`And`. "
"``values`` are the values involved. Consecutive operations with the same "
"operator, such as ``a or b or c``, are collapsed into one node with several "
"values."
msgstr ""
"Una operación booleana, 'or' y 'and'. ``op`` es :class:`Or` o :class:`And`. "
"``values`` son los valores involucrados. Operaciones consecutivas con el "
"mismo operador, como ``a or b or c``, colapsan en un nodo con varios valores."

#: ../Doc/library/ast.rst:529
msgid "This doesn't include ``not``, which is a :class:`UnaryOp`."
msgstr "Esto no incluye ``not``, el cual es un :class:`UnaryOp`."

#: ../Doc/library/ast.rst:545
msgid "Boolean operator tokens."
msgstr "Tokens de operador booleano."

#: ../Doc/library/ast.rst:550
msgid ""
"A comparison of two or more values. ``left`` is the first value in the "
"comparison, ``ops`` the list of operators, and ``comparators`` the list of "
"values after the first element in the comparison."
msgstr ""
"Una comparación de dos o más valores. ``left`` es el primer valor en la "
"comparación, ``ops`` es la lista de operadores, y ``comparators`` es la "
"lista de valores después de el primer elemento en la comparación."

#: ../Doc/library/ast.rst:579
msgid "Comparison operator tokens."
msgstr "Tokens de operador de comparación."

#: ../Doc/library/ast.rst:584
msgid ""
"A function call. ``func`` is the function, which will often be a :class:"
"`Name` or :class:`Attribute` object. Of the arguments:"
msgstr ""
"Un llamado a función. ``func`` is la función, la cual suele ser un objeto :"
"class:`Name` o :class:`Attribute`. De los argumentos:"

#: ../Doc/library/ast.rst:587
msgid "``args`` holds a list of the arguments passed by position."
msgstr "``args`` contiene una lista de argumentos pasados por posición."

#: ../Doc/library/ast.rst:588
msgid ""
"``keywords`` holds a list of :class:`.keyword` objects representing "
"arguments passed by keyword."
msgstr ""
"``keywords`` contiene una lista de objetos :class:`.keyword` que representan "
"argumentos pasados por nombre clave."

#: ../Doc/library/ast.rst:591
msgid ""
"When creating a ``Call`` node, ``args`` and ``keywords`` are required, but "
"they can be empty lists."
msgstr ""
"Cuando se crea un nodo ``Call``, ``args`` y ``keywords`` son requeridos pero "
"pueden ser listas vacías."

#: ../Doc/library/ast.rst:615
msgid ""
"A keyword argument to a function call or class definition. ``arg`` is a raw "
"string of the parameter name, ``value`` is a node to pass in."
msgstr ""
"Un argumento de palabra clave para una llamada de función o definición de "
"clase. ``arg`` es una cadena de caracteres sin formato del nombre del "
"parámetro, ``valor`` es un nodo para pasar."

#: ../Doc/library/ast.rst:621
msgid ""
"An expression such as ``a if b else c``. Each field holds a single node, so "
"in the following example, all three are :class:`Name` nodes."
msgstr ""
"Una expresión como ``a if b else c``. Cada campo contiene un único nodo, por "
"lo que en el siguiente ejemplo, todos son nodos  :class:`Name`."

#: ../Doc/library/ast.rst:636
msgid ""
"Attribute access, e.g. ``d.keys``. ``value`` is a node, typically a :class:"
"`Name`. ``attr`` is a bare string giving the name of the attribute, and "
"``ctx`` is :class:`Load`, :class:`Store` or :class:`Del` according to how "
"the attribute is acted on."
msgstr ""
"Acceso a atributos, por ejemplo ``d.keys``. ``value`` es un nodo, "
"típicamente un :class:`Name`. ``attr`` es una simple cadena de caracteres "
"que da el nombre del atributo, y ``ctx`` es :class:`Load`, :class:`Store` o :"
"class:`Del` de acuerdo a cómo se actúe sobre el atributo."

#: ../Doc/library/ast.rst:653
msgid ""
"A named expression. This AST node is produced by the assignment expressions "
"operator (also known as the walrus operator). As opposed to the :class:"
"`Assign` node in which the first argument can be multiple nodes, in this "
"case both ``target`` and ``value`` must be single nodes."
msgstr ""
"Una expresión con nombre. Este nodo AST es producido por el operador de "
"expresiones de asignación (también conocido como el operador walrus). A "
"diferencia del nodo :class:`Assign` en el cual el primer argumento puede ser "
"varios nodos, en este caso ``target`` y ``value`` deben ser nodos únicos."

#: ../Doc/library/ast.rst:669
msgid "Subscripting"
msgstr "Subindexado"

#: ../Doc/library/ast.rst:673
msgid ""
"A subscript, such as ``l[1]``. ``value`` is the subscripted object (usually "
"sequence or mapping). ``slice`` is an index, slice or key. It can be a :"
"class:`Tuple` and contain a :class:`Slice`. ``ctx`` is :class:`Load`, :class:"
"`Store` or :class:`Del` according to the action performed with the subscript."
msgstr ""
"Un subíndice, como ``l[1]``. ``value`` es el objeto subindicado (usualmente "
"una secuencia o mapeo). ``slice`` es un índice, un segmento o una clave. "
"Este puede ser una :class:`Tuple` y contener un :class:`Slice`. ``ctx`` es :"
"class:`Load`, :class:`Store` or :class:`Del` de acuerdo a la acción tomada "
"con el subíndice."

#: ../Doc/library/ast.rst:697
msgid ""
"Regular slicing (on the form ``lower:upper`` or ``lower:upper:step``). Can "
"occur only inside the *slice* field of :class:`Subscript`, either directly "
"or as an element of :class:`Tuple`."
msgstr ""
"Una segmentación regular (en la forma ``lower:upper`` o ``lower:upper:"
"step``). Puede ocurrir solamente dentro del campo *slice* de :class:"
"`Subscript`, ya sea directamente o como un elemento de :class:`Tuple`."

#: ../Doc/library/ast.rst:714
msgid "Comprehensions"
msgstr "Comprensiones"

#: ../Doc/library/ast.rst:721
msgid ""
"List and set comprehensions, generator expressions, and dictionary "
"comprehensions. ``elt`` (or ``key`` and ``value``) is a single node "
"representing the part that will be evaluated for each item."
msgstr ""
"Listas y sets por comprensión, expresiones de generadores, y diccionarios "
"por comprensión. ``elt`` (o ``key`` y ``value``) es un único nodo que "
"representa la parte que va a ser evaluada por cada item."

#: ../Doc/library/ast.rst:725
msgid "``generators`` is a list of :class:`comprehension` nodes."
msgstr "``generators`` es una lista de nodos :class:`comprehension`."

#: ../Doc/library/ast.rst:767
msgid ""
"One ``for`` clause in a comprehension. ``target`` is the reference to use "
"for each element - typically a :class:`Name` or :class:`Tuple` node. "
"``iter`` is the object to iterate over. ``ifs`` is a list of test "
"expressions: each ``for`` clause can have multiple ``ifs``."
msgstr ""
"Una cláusula ``for`` en una comprensión. ``target`` es la referencia a "
"usarse por cada elemento - típicamente un nodo :class:`Name` o :class:"
"`Tuple`. ``iter`` es el objeto por el cual se itera. ``ifs`` es una lista de "
"expresiones de prueba: cada cláusula ``for`` puede tener múltiples ``ifs``."

#: ../Doc/library/ast.rst:772
msgid ""
"``is_async`` indicates a comprehension is asynchronous (using an ``async "
"for`` instead of ``for``). The value is an integer (0 or 1)."
msgstr ""
"``is_async`` indica que una compresión es asíncrona (usando ``async for`` en "
"lugar de ``for``). El valor es un entero (0 o 1)."

#: ../Doc/library/ast.rst:841
msgid "Statements"
msgstr "Declaraciones"

#: ../Doc/library/ast.rst:845
msgid ""
"An assignment. ``targets`` is a list of nodes, and ``value`` is a single "
"node."
msgstr ""
"Una asignación. ``targets`` es una lista de nodos, y ``value`` es un nodo "
"único."

#: ../Doc/library/ast.rst:847
msgid ""
"Multiple nodes in ``targets`` represents assigning the same value to each. "
"Unpacking is represented by putting a :class:`Tuple` or :class:`List` within "
"``targets``."
msgstr ""
"Nodos múltiples en ``targets`` representa asignar el mismo valor a cada uno. "
"El desempaquetado se representa poniendo una :class:`Tuple` o :class:`List` "
"en ``targets``."

#: ../Doc/library/ast.rst:853 ../Doc/library/ast.rst:1161
#: ../Doc/library/ast.rst:1366 ../Doc/library/ast.rst:1891
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment."
msgstr ""
"``type_comment`` es una cadena de caracteres opcional con la anotación de "
"tipos como comentario."

#: ../Doc/library/ast.rst:883
msgid ""
"An assignment with a type annotation. ``target`` is a single node and can be "
"a :class:`Name`, a :class:`Attribute` or a :class:`Subscript`. "
"``annotation`` is the annotation, such as a :class:`Constant` or :class:"
"`Name` node. ``value`` is a single optional node. ``simple`` is a boolean "
"integer set to True for a :class:`Name` node in ``target`` that do not "
"appear in between parenthesis and are hence pure names and not expressions."
msgstr ""
"Una asignación con una anotación de tipos. ``target`` es un nodo único y "
"puede ser un :class:`Name`, a :class:`Attribute` o un :class:`Subscript`. "
"``annotation`` es la anotación, como un nodo :class:`Constant` o :class:"
"`Name`. ``value`` es un único nodo opcional. ``simple`` es un booleano que "
"es True para un nodo :class:`Name` en `target` que no aparece entre "
"paréntesis y por ende son nombres puros y no expresiones."

#: ../Doc/library/ast.rst:938
msgid ""
"Augmented assignment, such as ``a += 1``. In the following example, "
"``target`` is a :class:`Name` node for ``x`` (with the :class:`Store` "
"context), ``op`` is :class:`Add`, and ``value`` is a :class:`Constant` with "
"value for 1."
msgstr ""
"Asignación aumentada, como ``a+=1``. En el siguiente ejemplo, ``target`` es "
"un nodo :class:`Name` para ``x`` (con el contexto :class:`Store`), ``op`` "
"es :class:`Add` y ``value`` es un :class:`Constant` con valor 1."

#: ../Doc/library/ast.rst:943
msgid ""
"The ``target`` attribute cannot be of class :class:`Tuple` or :class:`List`, "
"unlike the targets of :class:`Assign`."
msgstr ""
"El atributo ``target`` no puede ser de clase :class:`Tuple` o :class:`List`, "
"a diferencia de los objetivos de :class:`Assign`."

#: ../Doc/library/ast.rst:960
msgid ""
"A ``raise`` statement. ``exc`` is the exception object to be raised, "
"normally a :class:`Call` or :class:`Name`, or ``None`` for a standalone "
"``raise``. ``cause`` is the optional part for ``y`` in ``raise x from y``."
msgstr ""
"Una declaración ``raise``. ``exc`` es el objeto de excepción a ser lanzado, "
"normalmente un :class:`Call` or :class:`Name`, o ``None`` para un ``raise`` "
"solo. ``cause`` es la parte opcional para ``y`` en ``raise x from y``."

#: ../Doc/library/ast.rst:977
msgid ""
"An assertion. ``test`` holds the condition, such as a :class:`Compare` node. "
"``msg`` holds the failure message."
msgstr ""
"Una aserción. ``test`` contiene la condición, como un nodo :class:`Compare`. "
"``msg`` contiene el mensaje de fallo."

#: ../Doc/library/ast.rst:993
msgid ""
"Represents a ``del`` statement. ``targets`` is a list of nodes, such as :"
"class:`Name`, :class:`Attribute` or :class:`Subscript` nodes."
msgstr ""
"Contiene una declaración ``del``. ``targets`` es una lista de nodos, como "
"nodos :class:`Name`, :class:`Attribute` o :class:`Subscript`."

#: ../Doc/library/ast.rst:1011
msgid "A ``pass`` statement."
msgstr "Una declaración ``pass``."

#: ../Doc/library/ast.rst:1024
msgid ""
"A :ref:`type alias <type-aliases>` created through the :keyword:`type` "
"statement. ``name`` is the name of the alias, ``type_params`` is a list of :"
"ref:`type parameters <ast-type-params>`, and ``value`` is the value of the "
"type alias."
msgstr ""
"Un alias :ref:`type alias <type-aliases>` creado mediante la sentencia :"
"keyword:`type`. ``name`` es el nombre del alias, ``type_params`` es una "
"lista de parámetros :ref:`type <ast-type-params>`, y ``value`` es el valor "
"del alias de tipo."

#: ../Doc/library/ast.rst:1042
msgid ""
"Other statements which are only applicable inside functions or loops are "
"described in other sections."
msgstr ""
"Otras declaraciones que solo son aplicables dentro de funciones o bucles "
"descritos en otras secciones."

#: ../Doc/library/ast.rst:1046
msgid "Imports"
msgstr "Importaciones"

#: ../Doc/library/ast.rst:1050
msgid "An import statement. ``names`` is a list of :class:`alias` nodes."
msgstr ""
"Una declaración de importación. ``names`` es una lista de nodos :class:"
"`alias`."

#: ../Doc/library/ast.rst:1067
msgid ""
"Represents ``from x import y``. ``module`` is a raw string of the 'from' "
"name, without any leading dots, or ``None`` for statements such as ``from . "
"import foo``. ``level`` is an integer holding the level of the relative "
"import (0 means absolute import)."
msgstr ""
"Representa ``form x import y``. ``module`` es una cadena de caracteres sin "
"formato del nombre 'from', sin puntos, o ``None`` para declaraciones como "
"``from . import foo``. ``level`` es un entero que contiene el nivel relativo "
"de la importación (0 significa una importación absoluta)."

#: ../Doc/library/ast.rst:1089
msgid ""
"Both parameters are raw strings of the names. ``asname`` can be ``None`` if "
"the regular name is to be used."
msgstr ""
"Ambos parámetros son cadenas de caracteres sin formato para los nombres. "
"``asname`` puede ser ``None`` si se va a usar el nombre regular."

#: ../Doc/library/ast.rst:1106
msgid "Control flow"
msgstr "Control de flujo"

#: ../Doc/library/ast.rst:1109
msgid ""
"Optional clauses such as ``else`` are stored as an empty list if they're not "
"present."
msgstr ""
"Cláusulas opcionales como ``else`` se guardan como una lista vacía si no "
"están presentes."

#: ../Doc/library/ast.rst:1114
msgid ""
"An ``if`` statement. ``test`` holds a single node, such as a :class:"
"`Compare` node. ``body`` and ``orelse`` each hold a list of nodes."
msgstr ""
"Una declaración ``if``. ``test`` contiene un único nodo, como un nodo :class:"
"`Compare`. ``body`` y ``orelse`` contiene cada uno una lista de nodos."

#: ../Doc/library/ast.rst:1117
msgid ""
"``elif`` clauses don't have a special representation in the AST, but rather "
"appear as extra :class:`If` nodes within the ``orelse`` section of the "
"previous one."
msgstr ""
"Cláusulas ``elif`` no tienen una representación especial en AST, pero pueden "
"aparecer como nodos extra :class:`If` dentro de la sección ``orelse`` del "
"nodo anterior."

#: ../Doc/library/ast.rst:1152
msgid ""
"A ``for`` loop. ``target`` holds the variable(s) the loop assigns to, as a "
"single :class:`Name`, :class:`Tuple`, :class:`List`, :class:`Attribute` or :"
"class:`Subscript` node. ``iter`` holds the item to be looped over, again as "
"a single node. ``body`` and ``orelse`` contain lists of nodes to execute. "
"Those in ``orelse`` are executed if the loop finishes normally, rather than "
"via a ``break`` statement."
msgstr ""
"Un bucle ``for``. ``target`` contiene las variables a las que asigna el "
"bucle, como un único nodo :class:`Name`, :class:`Tuple`, :class:`List`, :"
"class:`Attribute` o :class:`Subscript`. ``iter`` contiene el elemento sobre "
"el que se realizará el bucle, nuevamente como un solo nodo. ``body`` y "
"``orelse`` contienen listas de nodos para ejecutar. Los de ``orelse`` se "
"ejecutan si el ciclo finaliza normalmente, en lugar de mediante una "
"instrucción ``break``."

#: ../Doc/library/ast.rst:1187
msgid ""
"A ``while`` loop. ``test`` holds the condition, such as a :class:`Compare` "
"node."
msgstr ""
"Un bucle ``while``. ``test`` contiene la condición, como un nodo :class:"
"`Compare`."

#: ../Doc/library/ast.rst:1214
msgid "The ``break`` and ``continue`` statements."
msgstr "Las declaraciones ``break`` y ``continue``."

#: ../Doc/library/ast.rst:1249
msgid ""
"``try`` blocks. All attributes are list of nodes to execute, except for "
"``handlers``, which is a list of :class:`ExceptHandler` nodes."
msgstr ""
"Bloques ``try``. Todos los atributos son listas de nodos a ejecutar, excepto "
"para ``handlers``, el cual es una lista de nodos :class:`ExceptHandler`."

#: ../Doc/library/ast.rst:1295
msgid ""
"``try`` blocks which are followed by ``except*`` clauses. The attributes are "
"the same as for :class:`Try` but the :class:`ExceptHandler` nodes in "
"``handlers`` are interpreted as ``except*`` blocks rather then ``except``."
msgstr ""
"Bloques ``try`` que van seguidos de cláusulas ``except*``. Los atributos son "
"los mismos que para :class:`Try` pero los nodos :class:`ExceptHandler` en "
"``handlers`` se interpretan como bloques ``except*`` en lugar de ``except``."

#: ../Doc/library/ast.rst:1327
msgid ""
"A single ``except`` clause. ``type`` is the exception type it will match, "
"typically a :class:`Name` node (or ``None`` for a catch-all ``except:`` "
"clause). ``name`` is a raw string for the name to hold the exception, or "
"``None`` if the clause doesn't have ``as foo``. ``body`` is a list of nodes."
msgstr ""
"Una sola cláusula ``except``. ``type`` es el tipo de excepción con el que "
"coincidirá, normalmente un nodo :class:`Name` (o ``None`` para una cláusula "
"``except:`` generalizada). ``name`` es una cadena sin formato para que el "
"nombre contenga la excepción, o ``None`` si la cláusula no tiene ``as foo``. "
"``body`` es una lista de nodos."

#: ../Doc/library/ast.rst:1361
msgid ""
"A ``with`` block. ``items`` is a list of :class:`withitem` nodes "
"representing the context managers, and ``body`` is the indented block inside "
"the context."
msgstr ""
"Un bloque ``with``. ``items`` es una lista de nodos :class:`withitem` que "
"representan los administradores de contexto, y ``body`` es el bloque con "
"sangría dentro del contexto."

#: ../Doc/library/ast.rst:1371
msgid ""
"A single context manager in a ``with`` block. ``context_expr`` is the "
"context manager, often a :class:`Call` node. ``optional_vars`` is a :class:"
"`Name`, :class:`Tuple` or :class:`List` for the ``as foo`` part, or ``None`` "
"if that isn't used."
msgstr ""
"Un administrador de contexto único en un bloque ``with``. ``context_expr`` "
"es el administrador de contexto, a menudo un nodo :class:`Call`. "
"``optional_vars`` es un :class:`Name`, :class:`Tuple` o :class:`List` para "
"la parte ``as foo``, o ``None`` si no se usa."

#: ../Doc/library/ast.rst:1404
msgid "Pattern matching"
msgstr "La coincidencia de patrones"

#: ../Doc/library/ast.rst:1409
msgid ""
"A ``match`` statement. ``subject`` holds the subject of the match (the "
"object that is being matched against the cases) and ``cases`` contains an "
"iterable of :class:`match_case` nodes with the different cases."
msgstr ""
"Una declaración ``match``. ``subject`` contiene el sujeto de la coincidencia "
"(el objeto que se compara con los casos) y ``cases`` contiene un iterable de "
"nodos :class:`match_case` con los diferentes casos."

#: ../Doc/library/ast.rst:1417
msgid ""
"A single case pattern in a ``match`` statement. ``pattern`` contains the "
"match pattern that the subject will be matched against. Note that the :class:"
"`AST` nodes produced for patterns differ from those produced for "
"expressions, even when they share the same syntax."
msgstr ""
"Un patrón de caso único en una declaración ``match``. ``pattern`` contiene "
"el patrón de coincidencia con el que se comparará el sujeto. Tenga en cuenta "
"que los nodos :class:`AST` producidos para patrones difieren de los "
"producidos para expresiones, incluso cuando comparten la misma sintaxis."

#: ../Doc/library/ast.rst:1422
msgid ""
"The ``guard`` attribute contains an expression that will be evaluated if the "
"pattern matches the subject."
msgstr ""
"El atributo ``guard`` contiene una expresión que se evaluará si el patrón "
"coincide con el sujeto."

#: ../Doc/library/ast.rst:1425
msgid ""
"``body`` contains a list of nodes to execute if the pattern matches and the "
"result of evaluating the guard expression is true."
msgstr ""
"``body`` contiene una lista de nodos para ejecutar si el patrón coincide y "
"el resultado de evaluar la expresión de protección es verdadero."

#: ../Doc/library/ast.rst:1470
msgid ""
"A match literal or value pattern that compares by equality. ``value`` is an "
"expression node. Permitted value nodes are restricted as described in the "
"match statement documentation. This pattern succeeds if the match subject is "
"equal to the evaluated value."
msgstr ""
"Un patrón de valor o literal de coincidencia que se compara por igualdad. "
"``value`` es un nodo de expresión. Los nodos de valores permitidos están "
"restringidos como se describe en la documentación de la declaración de "
"coincidencia. Este patrón tiene éxito si el sujeto de la coincidencia es "
"igual al valor evaluado."

#: ../Doc/library/ast.rst:1499
msgid ""
"A match literal pattern that compares by identity. ``value`` is the "
"singleton to be compared against: ``None``, ``True``, or ``False``. This "
"pattern succeeds if the match subject is the given constant."
msgstr ""
"Un patrón literal de coincidencia que se compara por identidad. ``value`` es "
"el singleton que se va a comparar con: ``None``, ``True`` o ``False``. Este "
"patrón tiene éxito si el sujeto de la coincidencia es la constante dada."

#: ../Doc/library/ast.rst:1526
msgid ""
"A match sequence pattern. ``patterns`` contains the patterns to be matched "
"against the subject elements if the subject is a sequence. Matches a "
"variable length sequence if one of the subpatterns is a ``MatchStar`` node, "
"otherwise matches a fixed length sequence."
msgstr ""
"Un patrón de secuencia de coincidencia. ``patterns`` contiene los patrones "
"que se compararán con los elementos del sujeto si el sujeto es una "
"secuencia. Coincide con una secuencia de longitud variable si uno de los "
"subpatrones es un nodo ``MatchStar``; de lo contrario, coincide con una "
"secuencia de longitud fija."

#: ../Doc/library/ast.rst:1559
msgid ""
"Matches the rest of the sequence in a variable length match sequence "
"pattern. If ``name`` is not ``None``, a list containing the remaining "
"sequence elements is bound to that name if the overall sequence pattern is "
"successful."
msgstr ""
"Coincide con el resto de la secuencia en un patrón de secuencia de "
"coincidencia de longitud variable. Si ``name`` no es ``None``, una lista que "
"contiene los elementos de secuencia restantes está vinculada a ese nombre si "
"el patrón de secuencia general es exitoso."

#: ../Doc/library/ast.rst:1601
msgid ""
"A match mapping pattern. ``keys`` is a sequence of expression nodes. "
"``patterns`` is a corresponding sequence of pattern nodes. ``rest`` is an "
"optional name that can be specified to capture the remaining mapping "
"elements. Permitted key expressions are restricted as described in the match "
"statement documentation."
msgstr ""
"Un patrón de mapeo de coincidencias. ``keys`` es una secuencia de nodos de "
"expresión. ``patterns`` es una secuencia correspondiente de nodos de patrón. "
"``rest`` es un nombre opcional que se puede especificar para capturar los "
"elementos de mapeo restantes. Las expresiones clave permitidas están "
"restringidas como se describe en la documentación de la declaración de "
"coincidencia."

#: ../Doc/library/ast.rst:1607
msgid ""
"This pattern succeeds if the subject is a mapping, all evaluated key "
"expressions are present in the mapping, and the value corresponding to each "
"key matches the corresponding subpattern. If ``rest`` is not ``None``, a "
"dict containing the remaining mapping elements is bound to that name if the "
"overall mapping pattern is successful."
msgstr ""
"Este patrón tiene éxito si el sujeto es un mapeo, todas las expresiones "
"clave evaluadas están presentes en el mapeo y el valor correspondiente a "
"cada clave coincide con el subpatrón correspondiente. Si ``rest`` no es "
"``None``, un dict que contiene los elementos de mapeo restantes se vincula a "
"ese nombre si el patrón de mapeo general es exitoso."

#: ../Doc/library/ast.rst:1649
msgid ""
"A match class pattern. ``cls`` is an expression giving the nominal class to "
"be matched. ``patterns`` is a sequence of pattern nodes to be matched "
"against the class defined sequence of pattern matching attributes. "
"``kwd_attrs`` is a sequence of additional attributes to be matched "
"(specified as keyword arguments in the class pattern), ``kwd_patterns`` are "
"the corresponding patterns (specified as keyword values in the class "
"pattern)."
msgstr ""
"Un patrón de clase coincidente. ``cls`` es una expresión que da la clase "
"nominal que se va a emparejar. ``patterns`` es una secuencia de nodos de "
"patrón que se compararán con la secuencia definida por la clase de atributos "
"de coincidencia de patrones. ``kwd_attrs`` es una secuencia de atributos "
"adicionales que deben coincidir (especificados como argumentos de palabra "
"clave en el patrón de clase), ``kwd_patterns`` son los patrones "
"correspondientes (especificados como valores de palabras clave en el patrón "
"de clase)."

#: ../Doc/library/ast.rst:1656
msgid ""
"This pattern succeeds if the subject is an instance of the nominated class, "
"all positional patterns match the corresponding class-defined attributes, "
"and any specified keyword attributes match their corresponding pattern."
msgstr ""
"Este patrón tiene éxito si el sujeto es una instancia de la clase nominada, "
"todos los patrones posicionales coinciden con los atributos definidos por la "
"clase correspondientes y cualquier atributo de palabra clave especificado "
"coincide con su patrón correspondiente."

#: ../Doc/library/ast.rst:1660
msgid ""
"Note: classes may define a property that returns self in order to match a "
"pattern node against the instance being matched. Several builtin types are "
"also matched that way, as described in the match statement documentation."
msgstr ""
"Nota: las clases pueden definir una propiedad que retorna self para hacer "
"coincidir un nodo de patrón con la instancia que se está comparando. Varios "
"tipos incorporados también se combinan de esa manera, como se describe en la "
"documentación de la declaración de coincidencia."

#: ../Doc/library/ast.rst:1715
msgid ""
"A match \"as-pattern\", capture pattern or wildcard pattern. ``pattern`` "
"contains the match pattern that the subject will be matched against. If the "
"pattern is ``None``, the node represents a capture pattern (i.e a bare name) "
"and will always succeed."
msgstr ""
"Una coincidencia \"como patrón\", patrón de captura o patrón comodín. "
"``pattern`` contiene el patrón de coincidencia con el que se comparará el "
"sujeto. Si el patrón es ``None``, el nodo representa un patrón de captura "
"(es decir, un nombre simple) y siempre tendrá éxito."

#: ../Doc/library/ast.rst:1720
msgid ""
"The ``name`` attribute contains the name that will be bound if the pattern "
"is successful. If ``name`` is ``None``, ``pattern`` must also be ``None`` "
"and the node represents the wildcard pattern."
msgstr ""
"El atributo ``name`` contiene el nombre que se vinculará si el patrón tiene "
"éxito. Si ``name`` es ``None``, ``pattern`` también debe ser ``None`` y el "
"nodo representa el patrón comodín."

#: ../Doc/library/ast.rst:1758
msgid ""
"A match \"or-pattern\". An or-pattern matches each of its subpatterns in "
"turn to the subject, until one succeeds. The or-pattern is then deemed to "
"succeed. If none of the subpatterns succeed the or-pattern fails. The "
"``patterns`` attribute contains a list of match pattern nodes that will be "
"matched against the subject."
msgstr ""
"Una coincidencia \"o patrón\". Un patrón-o hace coincidir cada uno de sus "
"subpatrones con el sujeto, hasta que uno tiene éxito. Entonces se considera "
"que el patrón-o tiene éxito. Si ninguno de los subpatrones tiene éxito, el "
"patrón o falla. El atributo ``patterns`` contiene una lista de nodos de "
"patrones de coincidencia que se compararán con el sujeto."

#: ../Doc/library/ast.rst:1793
msgid "Type parameters"
msgstr "Tipos de parámetro"

#: ../Doc/library/ast.rst:1795
msgid ""
":ref:`Type parameters <type-params>` can exist on classes, functions, and "
"type aliases."
msgstr ""
"\":ref:`Parámetros de tipo <type-params>` pueden existir en clases, "
"funciones y tipos de alias\""

#: ../Doc/library/ast.rst:1800
msgid ""
"A :class:`typing.TypeVar`. ``name`` is the name of the type variable. "
"``bound`` is the bound or constraints, if any. If ``bound`` is a :class:"
"`Tuple`, it represents constraints; otherwise it represents the bound."
msgstr ""
"Una :class:`typing.TypeVar`. ``name`` es el nombre de la variable de tipo. "
"``bound`` es el límite o las restricciones, si las hay. Si ``bound`` es una :"
"class:`Tuple`, representa las restricciones; en caso contrario, representa "
"el límite."

#: ../Doc/library/ast.rst:1825
msgid ""
"A :class:`typing.ParamSpec`. ``name`` is the name of the parameter "
"specification."
msgstr ""
"Una :class:`typing.ParamSpec`. ``name`` es el nombre de la especificación "
"del parámetro."

#: ../Doc/library/ast.rst:1850
msgid ""
"A :class:`typing.TypeVarTuple`. ``name`` is the name of the type variable "
"tuple."
msgstr ""
"Una :class:`typing.TypeVarTuple`. ``name`` es el nombre de la tupla variable "
"de tipo."

#: ../Doc/library/ast.rst:1875
msgid "Function and class definitions"
msgstr "Definiciones de función y clase"

#: ../Doc/library/ast.rst:1879
msgid "A function definition."
msgstr "Una definición de función."

#: ../Doc/library/ast.rst:1881
msgid "``name`` is a raw string of the function name."
msgstr ""
"``name`` es una cadena de caracteres sin formato del nombre de la función."

#: ../Doc/library/ast.rst:1882
msgid "``args`` is an :class:`arguments` node."
msgstr "``args`` es un nodo :class:`arguments`."

#: ../Doc/library/ast.rst:1883
msgid "``body`` is the list of nodes inside the function."
msgstr "``body`` es la lista de nodos dentro de la función."

#: ../Doc/library/ast.rst:1884
msgid ""
"``decorator_list`` is the list of decorators to be applied, stored outermost "
"first (i.e. the first in the list will be applied last)."
msgstr ""
"``decorator_list`` es la lista de decoradores que se aplicarán, almacenados "
"en el exterior primero (es decir, el primero de la lista se aplicará al "
"final)."

#: ../Doc/library/ast.rst:1886
msgid "``returns`` is the return annotation."
msgstr "``returns`` es la anotación de retorno."

#: ../Doc/library/ast.rst:1887 ../Doc/library/ast.rst:2065
msgid "``type_params`` is a list of :ref:`type parameters <ast-type-params>`."
msgstr ""
"``type_params`` es una lista de  :ref:`parametros de tipo <ast-type-params>`."

#: ../Doc/library/ast.rst:1893 ../Doc/library/ast.rst:2094
#: ../Doc/library/ast.rst:2105
msgid "Added ``type_params``."
msgstr "Se ha añadido ``type_params``."

#: ../Doc/library/ast.rst:1899
msgid ""
"``lambda`` is a minimal function definition that can be used inside an "
"expression. Unlike :class:`FunctionDef`, ``body`` holds a single node."
msgstr ""
"``lambda`` es una definición de función mínima que se puede utilizar dentro "
"de una expresión. A diferencia de :class:`FunctionDef`, ``body`` tiene un "
"solo nodo."

#: ../Doc/library/ast.rst:1923
msgid "The arguments for a function."
msgstr "Los argumentos para una función."

#: ../Doc/library/ast.rst:1925
msgid ""
"``posonlyargs``, ``args`` and ``kwonlyargs`` are lists of :class:`arg` nodes."
msgstr ""
"``posonlyargs``, ``args`` y ``kwonlyargs`` son listas de nodos :class:`arg`."

#: ../Doc/library/ast.rst:1926
msgid ""
"``vararg`` and ``kwarg`` are single :class:`arg` nodes, referring to the "
"``*args, **kwargs`` parameters."
msgstr ""
"``vararg`` y ``kwarg`` son nodos :class:`arg` únicos, en referencia a los "
"parámetros ``*args, **kwargs``."

#: ../Doc/library/ast.rst:1928
msgid ""
"``kw_defaults`` is a list of default values for keyword-only arguments. If "
"one is ``None``, the corresponding argument is required."
msgstr ""
"``kw_defaults`` es una lista de valores predeterminados para argumentos de "
"solo palabras clave. Si uno es ``None``, se requiere el argumento "
"correspondiente."

#: ../Doc/library/ast.rst:1930
msgid ""
"``defaults`` is a list of default values for arguments that can be passed "
"positionally. If there are fewer defaults, they correspond to the last n "
"arguments."
msgstr ""
"``defaults`` es una lista de valores predeterminados para argumentos que se "
"pueden pasar posicionalmente. Si hay menos valores predeterminados, "
"corresponden a los últimos n argumentos."

#: ../Doc/library/ast.rst:1937
msgid ""
"A single argument in a list. ``arg`` is a raw string of the argument name, "
"``annotation`` is its annotation, such as a :class:`Str` or :class:`Name` "
"node."
msgstr ""
"Un solo argumento en una lista. ``arg`` es una cadena sin formato del nombre "
"del argumento, ``annotation`` es su anotación, como un nodo :class:`Str` o :"
"class:`Name`."

#: ../Doc/library/ast.rst:1943
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment"
msgstr ""
"``type_comment`` es una cadena opcional con la anotación de tipo como "
"comentario"

#: ../Doc/library/ast.rst:1988
msgid "A ``return`` statement."
msgstr "Una declaración ``return``."

#: ../Doc/library/ast.rst:2003
msgid ""
"A ``yield`` or ``yield from`` expression. Because these are expressions, "
"they must be wrapped in a :class:`Expr` node if the value sent back is not "
"used."
msgstr ""
"Una expresión ``yield`` o ``yield from``. Debido a que se trata de "
"expresiones, deben incluirse en un nodo :class:`Expr` si no se utiliza el "
"valor retornado."

#: ../Doc/library/ast.rst:2028
msgid ""
"``global`` and ``nonlocal`` statements. ``names`` is a list of raw strings."
msgstr ""
"Declaraciones ``global`` y ``nonlocal``. ``names`` es una lista de cadenas "
"sin formato."

#: ../Doc/library/ast.rst:2055
msgid "A class definition."
msgstr "Una definición de clase."

#: ../Doc/library/ast.rst:2057
msgid "``name`` is a raw string for the class name"
msgstr "``name`` es una cadena sin formato para el nombre de la clase"

#: ../Doc/library/ast.rst:2058
msgid "``bases`` is a list of nodes for explicitly specified base classes."
msgstr ""
"``bases`` es una lista de nodos para clases base especificadas "
"explícitamente."

#: ../Doc/library/ast.rst:2059
msgid ""
"``keywords`` is a list of :class:`.keyword` nodes, principally for "
"'metaclass'. Other keywords will be passed to the metaclass, as per "
"`PEP-3115 <https://peps.python.org/pep-3115/>`_."
msgstr ""
"``keywords`` es una lista de nodos :class:`.keyword`, principalmente para "
"'metaclase'. Otras palabras clave se pasarán a la metaclase, según `PEP-3115 "
"<https://peps.python.org/pep-3115/>`_."

#: ../Doc/library/ast.rst:2062
msgid ""
"``body`` is a list of nodes representing the code within the class "
"definition."
msgstr ""
"``body`` es una lista de nodos que representan el código dentro de la "
"definición de clase."

#: ../Doc/library/ast.rst:2064
msgid "``decorator_list`` is a list of nodes, as in :class:`FunctionDef`."
msgstr ""
"``decorator_list`` es una lista de nodos, como en :class:`FunctionDef`."

#: ../Doc/library/ast.rst:2098
msgid "Async and await"
msgstr "Async y await"

#: ../Doc/library/ast.rst:2102
msgid ""
"An ``async def`` function definition. Has the same fields as :class:"
"`FunctionDef`."
msgstr ""
"Una definición de función ``async def``. Tiene los mismos campos que :class:"
"`FunctionDef`."

#: ../Doc/library/ast.rst:2111
msgid ""
"An ``await`` expression. ``value`` is what it waits for. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"Una expresión ``await``. ``value`` es lo que espera. Solo válido en el "
"cuerpo de un :class:`AsyncFunctionDef`."

#: ../Doc/library/ast.rst:2145
msgid ""
"``async for`` loops and ``async with`` context managers. They have the same "
"fields as :class:`For` and :class:`With`, respectively. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"Bucles ``async for`` y administradores de contexto ``async with``. Tienen "
"los mismos campos que :class:`For` y :class:`With`, respectivamente. Solo "
"válido en el cuerpo de un :class:`AsyncFunctionDef`."

#: ../Doc/library/ast.rst:2150
msgid ""
"When a string is parsed by :func:`ast.parse`, operator nodes (subclasses of :"
"class:`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, :class:`ast."
"boolop` and :class:`ast.expr_context`) on the returned tree will be "
"singletons. Changes to one will be reflected in all other occurrences of the "
"same value (e.g. :class:`ast.Add`)."
msgstr ""
"Cuando :func:`ast.parse` analiza una cadena, los nodos de operador "
"(subclases de :class:`ast.operator`, :class:`ast.unaryop`, :class:`ast."
"cmpop`, :class:`ast.boolop` y :class:`ast.expr_context`) en el árbol "
"retornado serán singletons. Los cambios en uno se reflejarán en todas las "
"demás ocurrencias del mismo valor (por ejemplo, :class:`ast.Add`)."

#: ../Doc/library/ast.rst:2158
msgid ":mod:`ast` Helpers"
msgstr "Ayudantes de :mod:`ast`"

#: ../Doc/library/ast.rst:2160
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr ""
"Además de las clases de nodo, el módulo :mod:`ast` define estas funciones y "
"clases de utilidad para atravesar árboles de sintaxis abstracta:"

#: ../Doc/library/ast.rst:2165
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, ast.PyCF_ONLY_AST)``."
msgstr ""
"Analiza la fuente en un nodo AST. Equivalente a ``compile(source, filename, "
"mode, ast.PyCF_ONLY_AST)``."

#: ../Doc/library/ast.rst:2168
msgid ""
"If ``type_comments=True`` is given, the parser is modified to check and "
"return type comments as specified by :pep:`484` and :pep:`526`. This is "
"equivalent to adding :data:`ast.PyCF_TYPE_COMMENTS` to the flags passed to :"
"func:`compile()`.  This will report syntax errors for misplaced type "
"comments.  Without this flag, type comments will be ignored, and the "
"``type_comment`` field on selected AST nodes will always be ``None``.  In "
"addition, the locations of ``# type: ignore`` comments will be returned as "
"the ``type_ignores`` attribute of :class:`Module` (otherwise it is always an "
"empty list)."
msgstr ""
"Si se proporciona ``type_comments=True``, el analizador se modifica para "
"verificar y retornar los comentarios de tipo según lo especificado por :pep:"
"`484` y :pep:`526`. Esto es equivalente a agregar :data:`ast."
"PyCF_TYPE_COMMENTS` a los flags pasados a :func:`compile()`. Esto informará "
"errores de sintaxis para comentarios de tipo fuera de lugar. Sin este flag, "
"los comentarios de tipo se ignorarán y el campo ``type_comment`` en los "
"nodos AST seleccionados siempre será ``None``. Además, las ubicaciones de "
"los comentarios ``# type: ignore`` se retornarán como el atributo "
"``type_ignores`` de :class:`Module` (de lo contrario, siempre es una lista "
"vacía)."

#: ../Doc/library/ast.rst:2178
msgid ""
"In addition, if ``mode`` is ``'func_type'``, the input syntax is modified to "
"correspond to :pep:`484` \"signature type comments\", e.g. ``(str, int) -> "
"List[str]``."
msgstr ""
"Además, si ``modo`` es ``'func_type'``, la sintaxis de entrada se modifica "
"para corresponder a :pep:`484` \"comentarios de tipo de firma\", por ejemplo "
"``(str, int) -> List[str]``."

#: ../Doc/library/ast.rst:2182
msgid ""
"Also, setting ``feature_version`` to a tuple ``(major, minor)`` will attempt "
"to parse using that Python version's grammar. Currently ``major`` must equal "
"to ``3``.  For example, setting ``feature_version=(3, 4)`` will allow the "
"use of ``async`` and ``await`` as variable names.  The lowest supported "
"version is ``(3, 4)``; the highest is ``sys.version_info[0:2]``."
msgstr ""
"Además, establece ``feature_version`` en una tupla ``(major, minor)`` "
"intentará analizar usando la gramática de esa versión de Python. Actualmente "
"``major`` debe ser igual a ``3``. Por ejemplo, establece "
"``feature_version=(3, 4)`` permitirá el uso de ``async`` y ``await`` como "
"nombres de variables. La versión más baja admitida es ``(3, 4)``; la más "
"alto es ``sys.version_info[0:2]``."

#: ../Doc/library/ast.rst:2189
msgid ""
"If source contains a null character ('\\0'), :exc:`ValueError` is raised."
msgstr ""
"Si la fuente contiene un carácter nulo ('\\ 0'), se lanza :exc:`ValueError`."

#: ../Doc/library/ast.rst:2192
msgid ""
"Note that successfully parsing source code into an AST object doesn't "
"guarantee that the source code provided is valid Python code that can be "
"executed as the compilation step can raise further :exc:`SyntaxError` "
"exceptions. For instance, the source ``return 42`` generates a valid AST "
"node for a return statement, but it cannot be compiled alone (it needs to be "
"inside a function node)."
msgstr ""
"Tenga en cuenta que analizar correctamente el código fuente en un objeto AST "
"no garantiza que el código fuente proporcionado sea un código Python válido "
"que se pueda ejecutar, ya que el paso de compilación puede lanzar más "
"excepciones :exc:`SyntaxError`. Por ejemplo, la fuente ``return 42`` genera "
"un nodo AST válido para una declaración de retorno, pero no se puede "
"compilar solo (debe estar dentro de un nodo de función)."

#: ../Doc/library/ast.rst:2199
msgid ""
"In particular, :func:`ast.parse` won't do any scoping checks, which the "
"compilation step does."
msgstr ""
"En particular, :func:`ast.parse` no realizará ninguna verificación de "
"alcance, lo que hace el paso de compilación."

#: ../Doc/library/ast.rst:2203
msgid ""
"It is possible to crash the Python interpreter with a sufficiently large/"
"complex string due to stack depth limitations in Python's AST compiler."
msgstr ""
"Es posible bloquear el intérprete de Python con una cadena de caracteres "
"suficientemente grande/compleja debido a las limitaciones de profundidad de "
"pila en el compilador AST de Python."

#: ../Doc/library/ast.rst:2207
msgid "Added ``type_comments``, ``mode='func_type'`` and ``feature_version``."
msgstr ""
"Se agregaron ``type_comments``, ``mode='func_type'`` y ``feature_version``."

#: ../Doc/library/ast.rst:2213
msgid ""
"Unparse an :class:`ast.AST` object and generate a string with code that "
"would produce an equivalent :class:`ast.AST` object if parsed back with :"
"func:`ast.parse`."
msgstr ""
"Analice un objeto :class:`ast.AST` y genere una cadena con código que "
"produciría un objeto :class:`ast.AST` equivalente si se analiza con :func:"
"`ast.parse`."

#: ../Doc/library/ast.rst:2218
msgid ""
"The produced code string will not necessarily be equal to the original code "
"that generated the :class:`ast.AST` object (without any compiler "
"optimizations, such as constant tuples/frozensets)."
msgstr ""
"La cadena de código producida no será necesariamente igual al código "
"original que generó el objeto :class:`ast.AST` (sin ninguna optimización del "
"compilador, como tuplas constantes / frozensets)."

#: ../Doc/library/ast.rst:2223
msgid ""
"Trying to unparse a highly complex expression would result with :exc:"
"`RecursionError`."
msgstr ""
"Intentar descomprimir una expresión muy compleja daría como resultado :exc:"
"`RecursionError`."

#: ../Doc/library/ast.rst:2231
msgid ""
"Evaluate an expression node or a string containing only a Python literal or "
"container display.  The string or node provided may only consist of the "
"following Python literal structures: strings, bytes, numbers, tuples, lists, "
"dicts, sets, booleans, ``None`` and ``Ellipsis``."
msgstr ""
"Evalúa un nodo de expresión o una cadena de caracteres que contenga "
"únicamente un literal de Python o visualizador de contenedor.  La cadena o "
"nodo proporcionado sólo puede consistir en las siguientes estructuras "
"literales de Python: cadenas de caracteres, bytes, números, tuplas, listas, "
"diccionarios, conjuntos, booleanos, ``None`` y ``Ellipsis``."

#: ../Doc/library/ast.rst:2236
msgid ""
"This can be used for evaluating strings containing Python values without the "
"need to parse the values oneself.  It is not capable of evaluating "
"arbitrarily complex expressions, for example involving operators or indexing."
msgstr ""
"Esto se puede usar para evaluar de forma segura las cadenas de caracteres "
"que contienen valores de Python sin la necesidad de analizar los valores uno "
"mismo.  No es capaz de evaluar expresiones complejas arbitrariamente, por "
"ejemplo, que involucran operadores o indexación."

#: ../Doc/library/ast.rst:2241
msgid ""
"This function had been documented as \"safe\" in the past without defining "
"what that meant. That was misleading. This is specifically designed not to "
"execute Python code, unlike the more general :func:`eval`. There is no "
"namespace, no name lookups, or ability to call out. But it is not free from "
"attack: A relatively small input can lead to memory exhaustion or to C stack "
"exhaustion, crashing the process. There is also the possibility for "
"excessive CPU consumption denial of service on some inputs. Calling it on "
"untrusted data is thus not recommended."
msgstr ""
"Esta función había sido documentada como \"segura\" en el pasado sin definir "
"lo que eso significaba. Eso era engañoso. Está diseñada específicamente no "
"para ejecutar código Python, a diferencia de la más general :func:`eval`. No "
"hay espacio de nombres, ni búsqueda de nombres, ni capacidad de llamada. "
"Pero no está libre de ataques: Una entrada relativamente pequeña puede "
"llevar a un agotamiento de la memoria o de la pila de C, haciendo colapsar "
"el proceso. También existe la posibilidad de denegación de servicio por "
"consumo excesivo de CPU en algunas entradas. Por lo tanto, no se recomienda "
"llamarlo con datos no confiables."

#: ../Doc/library/ast.rst:2251
msgid ""
"It is possible to crash the Python interpreter due to stack depth "
"limitations in Python's AST compiler."
msgstr ""
"Es posible bloquear el intérprete de Python debido a las limitaciones de "
"profundidad de pila en el compilador AST de Python."

#: ../Doc/library/ast.rst:2254
msgid ""
"It can raise :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, :exc:"
"`MemoryError` and :exc:`RecursionError` depending on the malformed input."
msgstr ""
"Puede generar :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, :exc:"
"`MemoryError` y :exc:`RecursionError` dependiendo de la entrada mal formada."

#: ../Doc/library/ast.rst:2258
msgid "Now allows bytes and set literals."
msgstr "Ahora permite bytes y establece literales."

#: ../Doc/library/ast.rst:2261
msgid "Now supports creating empty sets with ``'set()'``."
msgstr "Ahora admite la creación de conjuntos vacíos con ``'set()'``."

#: ../Doc/library/ast.rst:2264
msgid "For string inputs, leading spaces and tabs are now stripped."
msgstr ""
"Para las entradas de cadena, los espacios iniciales y las tabulaciones ahora "
"se eliminan."

#: ../Doc/library/ast.rst:2270
msgid ""
"Return the docstring of the given *node* (which must be a :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or :class:"
"`Module` node), or ``None`` if it has no docstring. If *clean* is true, "
"clean up the docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""
"Retorna la cadena de caracteres de documentación del *node* dado (que debe "
"ser un nodo :class:`FunctionDef`, :class:`AsyncFunctionDef`, :class:"
"`ClassDef`, o :class:`Module`), o ``None`` si no tiene docstring. Si *clean* "
"es verdadero, limpia la sangría del docstring con :func:`inspect.cleandoc`."

#: ../Doc/library/ast.rst:2276
msgid ":class:`AsyncFunctionDef` is now supported."
msgstr ":class:`AsyncFunctionDef` ahora está soportada."

#: ../Doc/library/ast.rst:2282
msgid ""
"Get source code segment of the *source* that generated *node*. If some "
"location information (:attr:`lineno`, :attr:`end_lineno`, :attr:"
"`col_offset`, or :attr:`end_col_offset`) is missing, return ``None``."
msgstr ""
"Obtenga el segmento de código fuente del *source* que generó *node*. Si "
"falta información de ubicación (:attr:`lineno`, :attr:`end_lineno`, :attr:"
"`col_offset`, o :attr:`end_col_offset`), retorna ``None``."

#: ../Doc/library/ast.rst:2286
msgid ""
"If *padded* is ``True``, the first line of a multi-line statement will be "
"padded with spaces to match its original position."
msgstr ""
"Si *padded* es ``True``, la primera línea de una declaración de varias "
"líneas se rellenará con espacios para que coincidan con su posición original."

#: ../Doc/library/ast.rst:2294
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects :"
"attr:`lineno` and :attr:`col_offset` attributes for every node that supports "
"them.  This is rather tedious to fill in for generated nodes, so this helper "
"adds these attributes recursively where not already set, by setting them to "
"the values of the parent node.  It works recursively starting at *node*."
msgstr ""
"Cuando compila un árbol de nodos con :func:`compile`, el compilador espera "
"los atributos :attr:`lineno` y :attr:`col_offset` para cada nodo que los "
"soporta. Es bastante tedioso completar los nodos generados, por lo que este "
"ayudante agrega estos atributos de forma recursiva donde aún no están "
"establecidos, configurándolos en los valores del nodo principal. Funciona de "
"forma recursiva comenzando en *node*."

#: ../Doc/library/ast.rst:2303
msgid ""
"Increment the line number and end line number of each node in the tree "
"starting at *node* by *n*. This is useful to \"move code\" to a different "
"location in a file."
msgstr ""
"Incremente el número de línea y el número de línea final de cada nodo en el "
"árbol comenzando en *node* por *n*. Esto es útil para \"mover código\" a una "
"ubicación diferente en un archivo."

#: ../Doc/library/ast.rst:2310
msgid ""
"Copy source location (:attr:`lineno`, :attr:`col_offset`, :attr:"
"`end_lineno`, and :attr:`end_col_offset`) from *old_node* to *new_node* if "
"possible, and return *new_node*."
msgstr ""
"Copia la ubicación de origen (:attr:`lineno`, :attr:`col_offset`, :attr:"
"`end_lineno`, y :attr:`end_col_offset`) de *old_node* a *new_node* si es "
"posible, y retorna *new_node*."

#: ../Doc/library/ast.rst:2317
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` "
"that is present on *node*."
msgstr ""
"Produce (*yield*) una tupla de ``(fieldname, value)`` para cada campo en "
"``node._fields`` que está presente en *node*."

#: ../Doc/library/ast.rst:2323
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are nodes "
"and all items of fields that are lists of nodes."
msgstr ""
"Cede todos los nodos secundarios directos de *node*, es decir, todos los "
"campos que son nodos y todos los elementos de campos que son listas de nodos."

#: ../Doc/library/ast.rst:2329
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""
"Recursivamente produce todos los nodos descendientes en el árbol comenzando "
"en *node* (incluido *node* en sí mismo), en ningún orden especificado. Esto "
"es útil si solo desea modificar los nodos en su lugar y no le importa el "
"contexto."

#: ../Doc/library/ast.rst:2336
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a "
"visitor function for every node found.  This function may return a value "
"which is forwarded by the :meth:`visit` method."
msgstr ""
"Una clase base de visitante de nodo que recorre el árbol de sintaxis "
"abstracta y llama a una función de visitante para cada nodo encontrado. Esta "
"función puede retornar un valor que se reenvía mediante el método :meth:"
"`visit`."

#: ../Doc/library/ast.rst:2340
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr ""
"Esta clase está destinada a ser subclase, con la subclase agregando métodos "
"de visitante."

#: ../Doc/library/ast.rst:2345
msgid ""
"Visit a node.  The default implementation calls the method called :samp:"
"`self.visit_{classname}` where *classname* is the name of the node class, "
"or :meth:`generic_visit` if that method doesn't exist."
msgstr ""
"Visita un nodo. La implementación predeterminada llama al método llamado :"
"samp:`self.visit_{classname}` donde *classname* es el nombre de la clase de "
"nodo, o :meth:`generic_visit` si ese método no existe."

#: ../Doc/library/ast.rst:2351
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr "Este visitante llama :meth:`visit` en todos los hijos del nodo."

#: ../Doc/library/ast.rst:2353
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be "
"visited unless the visitor calls :meth:`generic_visit` or visits them itself."
msgstr ""
"Tenga en cuenta que los nodos secundarios de los nodos que tienen un método "
"de visitante personalizado no se visitarán a menos que el visitante llame :"
"meth:`generic_visit` o los visite a sí mismo."

#: ../Doc/library/ast.rst:2357
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists (:class:"
"`NodeTransformer`) that allows modifications."
msgstr ""
"No use :class:`NodeVisitor` si desea aplicar cambios a los nodos durante el "
"recorrido. Para esto existe un visitante especial (:class:`NodeTransformer`) "
"que permite modificaciones."

#: ../Doc/library/ast.rst:2363
msgid ""
"Methods :meth:`visit_Num`, :meth:`visit_Str`, :meth:`visit_Bytes`, :meth:"
"`visit_NameConstant` and :meth:`visit_Ellipsis` are deprecated now and will "
"not be called in future Python versions.  Add the :meth:`visit_Constant` "
"method to handle all constant nodes."
msgstr ""
"Los métodos :meth:`visit_Num`, :meth:`visit_Str`, :meth:`visit_Bytes`, :meth:"
"`visit_NameConstant` y :meth:`visit_Ellipsis` están en desuso ahora y no "
"serán llamados en futuras versiones de Python. Agregue el método :meth:"
"`visit_Constant` para manejar todos los nodos constantes."

#: ../Doc/library/ast.rst:2371
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr ""
"Una subclase de :class:`NodeVisitor` que recorre el árbol de sintaxis "
"abstracta y permite la modificación de nodos."

#: ../Doc/library/ast.rst:2374
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value of "
"the visitor methods to replace or remove the old node.  If the return value "
"of the visitor method is ``None``, the node will be removed from its "
"location, otherwise it is replaced with the return value.  The return value "
"may be the original node in which case no replacement takes place."
msgstr ""
"La clase :class:`NodeTransformer` recorrerá el AST y usará el valor de "
"retorno de los métodos del visitante para reemplazar o eliminar el nodo "
"anterior. Si el valor de retorno del método de visitante es ``None``, el "
"nodo se eliminará de su ubicación; de lo contrario, se reemplazará con el "
"valor de retorno. El valor de retorno puede ser el nodo original, en cuyo "
"caso no se realiza ningún reemplazo."

#: ../Doc/library/ast.rst:2380
msgid ""
"Here is an example transformer that rewrites all occurrences of name lookups "
"(``foo``) to ``data['foo']``::"
msgstr ""
"Aquí hay un transformador de ejemplo que reescribe todas las apariciones de "
"búsquedas de nombres (``foo``) en ``data['foo']``::"

#: ../Doc/library/ast.rst:2392
msgid ""
"Keep in mind that if the node you're operating on has child nodes you must "
"either transform the child nodes yourself or call the :meth:`generic_visit` "
"method for the node first."
msgstr ""
"Tenga en cuenta que si el nodo en el que está operando tiene nodos "
"secundarios, debe transformar los nodos secundarios usted mismo o llamar "
"primero al método :meth:`generic_visit` para el nodo."

#: ../Doc/library/ast.rst:2396
msgid ""
"For nodes that were part of a collection of statements (that applies to all "
"statement nodes), the visitor may also return a list of nodes rather than "
"just a single node."
msgstr ""
"Para los nodos que formaban parte de una colección de declaraciones (que se "
"aplica a todos los nodos de declaración), el visitante también puede "
"retornar una lista de nodos en lugar de solo un nodo."

#: ../Doc/library/ast.rst:2400
msgid ""
"If :class:`NodeTransformer` introduces new nodes (that weren't part of "
"original tree) without giving them location information (such as :attr:"
"`lineno`), :func:`fix_missing_locations` should be called with the new sub-"
"tree to recalculate the location information::"
msgstr ""
"Si :class:`NodeTransformer` introduce nuevos nodos (que no eran parte del "
"árbol original) sin darles información de ubicación (como :attr:`lineno`), :"
"func:`fix_missing_locations` debería llamarse con el nuevo sub-árbol para "
"recalcular la información de ubicación ::"

#: ../Doc/library/ast.rst:2408
msgid "Usually you use the transformer like this::"
msgstr "Usualmente usas el transformador así:"

#: ../Doc/library/ast.rst:2415
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for "
"debugging purposes.  If *annotate_fields* is true (by default), the returned "
"string will show the names and the values for fields. If *annotate_fields* "
"is false, the result string will be more compact by omitting unambiguous "
"field names.  Attributes such as line numbers and column offsets are not "
"dumped by default.  If this is wanted, *include_attributes* can be set to "
"true."
msgstr ""
"Retorna un volcado formateado del árbol en *node*. Esto es principalmente "
"útil para propósitos de depuración. Si *annotate_fields* es verdadero (por "
"defecto), la cadena de caracteres retornada mostrará los nombres y los "
"valores de los campos. Si *annotate_fields* es falso, la cadena de "
"resultados será más compacta omitiendo nombres de campo no ambiguos. Los "
"atributos como los números de línea y las compensaciones de columna no se "
"vuelcan de forma predeterminada. Si esto se desea, *include_attributes* se "
"puede establecer en verdadero."

#: ../Doc/library/ast.rst:2423
msgid ""
"If *indent* is a non-negative integer or string, then the tree will be "
"pretty-printed with that indent level.  An indent level of 0, negative, or "
"``\"\"`` will only insert newlines.  ``None`` (the default) selects the "
"single line representation. Using a positive integer indent indents that "
"many spaces per level.  If *indent* is a string (such as ``\"\\t\"``), that "
"string is used to indent each level."
msgstr ""
"Si *indent* es un entero no negativo o una cadena de caracteres, entonces el "
"árbol será impreso de forma linda con ese nivel de sangría.  Un nivel de "
"sangría de 0, negativo, o ``\"\"`` solo insertará nuevas líneas. ``None`` "
"(el valor por defecto) selecciona la representación de línea simple. Al usar "
"un entero positivo se sangrará esa cantidad de espacios como sangría.  Si "
"*indent* es una cadena de caracteres (como ``\"\\t\"``), esa cadena se usa "
"para sangrar cada nivel."

#: ../Doc/library/ast.rst:2430
msgid "Added the *indent* option."
msgstr "Añadida la opción *indent*."

#: ../Doc/library/ast.rst:2437
msgid "Compiler Flags"
msgstr "Banderas del compilador"

#: ../Doc/library/ast.rst:2439
msgid ""
"The following flags may be passed to :func:`compile` in order to change "
"effects on the compilation of a program:"
msgstr ""
"Los siguientes indicadores pueden pasarse a :func:`compile` para cambiar los "
"efectos en la compilación de un programa:"

#: ../Doc/library/ast.rst:2444
msgid ""
"Enables support for top-level ``await``, ``async for``, ``async with`` and "
"async comprehensions."
msgstr ""
"Habilita el soporte para ``await``, ``async for``, ``async with`` y "
"comprensiones asíncronas de nivel superior."

#: ../Doc/library/ast.rst:2451
msgid ""
"Generates and returns an abstract syntax tree instead of returning a "
"compiled code object."
msgstr ""
"Genera y retorna un árbol de sintaxis abstracto en lugar de retornar un "
"objeto de código compilado."

#: ../Doc/library/ast.rst:2456
msgid ""
"Enables support for :pep:`484` and :pep:`526` style type comments (``# type: "
"<type>``, ``# type: ignore <stuff>``)."
msgstr ""
"Habilita el soporte para comentarios de tipo de estilo :pep:`484` y :pep:"
"`526` (``# type: <type>``, ``# type: ignore <stuff>``)."

#: ../Doc/library/ast.rst:2465
msgid "Command-Line Usage"
msgstr "Uso en línea de comandos"

#: ../Doc/library/ast.rst:2469
msgid ""
"The :mod:`ast` module can be executed as a script from the command line. It "
"is as simple as:"
msgstr ""
"El módulo :mod:`ast` puede ser ejecutado como un script desde la línea de "
"comandos. Es tan simple como:"

#: ../Doc/library/ast.rst:2476
msgid "The following options are accepted:"
msgstr "Las siguientes opciones son aceptadas:"

#: ../Doc/library/ast.rst:2482
msgid "Show the help message and exit."
msgstr "Muestra el mensaje de ayuda y sale."

#: ../Doc/library/ast.rst:2487
msgid ""
"Specify what kind of code must be compiled, like the *mode* argument in :"
"func:`parse`."
msgstr ""
"Especifica qué tipo de código debe ser compilado, como el argumento *mode* "
"en :func:`parse`."

#: ../Doc/library/ast.rst:2492
msgid "Don't parse type comments."
msgstr "No analizar los comentarios de tipo."

#: ../Doc/library/ast.rst:2496
msgid "Include attributes such as line numbers and column offsets."
msgstr "Incluye atributos como números de línea y sangrías."

#: ../Doc/library/ast.rst:2501
msgid "Indentation of nodes in AST (number of spaces)."
msgstr "Sangría de nodos en AST (número de espacios)."

#: ../Doc/library/ast.rst:2503
msgid ""
"If :file:`infile` is specified its contents are parsed to AST and dumped to "
"stdout.  Otherwise, the content is read from stdin."
msgstr ""
"Si :file:`infile` es especificado, su contenido es analizado a AST y "
"mostrado en stdout. De otra forma, el contenido es leído desde stdin."

#: ../Doc/library/ast.rst:2509
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, an external "
"documentation resource, has good details on working with Python ASTs."
msgstr ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, un recurso "
"de documentación externo, tiene buenos detalles sobre cómo trabajar con "
"Python AST."

#: ../Doc/library/ast.rst:2512
msgid ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"annotates Python ASTs with the positions of tokens and text in the source "
"code that generated them. This is helpful for tools that make source code "
"transformations."
msgstr ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"anota ASTs de Python con la posición de tokens y texto en el código fuente "
"que los genera. Esto es de ayuda para herramientas que hacen "
"transformaciones de código fuente."

#: ../Doc/library/ast.rst:2517
msgid ""
"`leoAst.py <https://leoeditor.com/appendices.html#leoast-py>`_ unifies the "
"token-based and parse-tree-based views of python programs by inserting two-"
"way links between tokens and ast nodes."
msgstr ""
"`leoAst.py <https://leoeditor.com/appendices.html#leoast-py>`_ unifica las "
"vistas basadas en tokens y en *parse-trees* de los programas de Python "
"insertando vínculos de doble vía entre tokens y nodos AST."

#: ../Doc/library/ast.rst:2521
msgid ""
"`LibCST <https://libcst.readthedocs.io/>`_ parses code as a Concrete Syntax "
"Tree that looks like an ast tree and keeps all formatting details. It's "
"useful for building automated refactoring (codemod) applications and linters."
msgstr ""
"`LibCST <https://libcst.readthedocs.io/>`_ analiza código como Árboles de "
"Sintaxis Concreta que se ven como ASTs y mantienen todos los detalles de "
"formato. Es útil para construir herramientas de refactor automáticas y "
"linters."

#: ../Doc/library/ast.rst:2526
msgid ""
"`Parso <https://parso.readthedocs.io>`_ is a Python parser that supports "
"error recovery and round-trip parsing for different Python versions (in "
"multiple Python versions). Parso is also able to list multiple syntax errors "
"in your python file."
msgstr ""
"`Parso <https://parso.readthedocs.io>`_ es un analizador de Python que "
"soporta recuperación de errores y análisis sintáctico de ida y vuelta para "
"las diferentes versiones de Python (en múltiples versiones de Python). Parso "
"también es capaz de enlistar múltiples errores de sintaxis en tu archivo de "
"Python."

#: ../Doc/library/ast.rst:59
msgid "? (question mark)"
msgstr "? (question mark)"

#: ../Doc/library/ast.rst:59 ../Doc/library/ast.rst:60
msgid "in AST grammar"
msgstr "Gramática abstracta"

#: ../Doc/library/ast.rst:60
msgid "* (asterisk)"
msgstr "* (asterisk)"

#~ msgid ""
#~ "``starargs`` and ``kwargs`` are each a single node, as in a function "
#~ "call. starargs will be expanded to join the list of base classes, and "
#~ "kwargs will be passed to the metaclass."
#~ msgstr ""
#~ "``starargs`` y ``kwargs`` son cada uno un solo nodo, como en una llamada "
#~ "de función. Los starargs se expandirán para unirse a la lista de clases "
#~ "base y los kwargs se pasarán a la metaclase."
