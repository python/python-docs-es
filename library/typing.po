# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-25 19:47+0200\n"
"PO-Revision-Date: 2023-01-07 18:57-0300\n"
"Last-Translator: Héctor Canto <hectorcanto@gmail.com>\n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"
"X-Generator: Poedit 2.4.2\n"

#: ../Doc/library/typing.rst:3
msgid ":mod:`typing` --- Support for type hints"
msgstr ":mod:`typing` --- Soporte para *type hints*"

#: ../Doc/library/typing.rst:10
msgid "**Source code:** :source:`Lib/typing.py`"
msgstr "**Source code:** :source:`Lib/typing.py`"

#: ../Doc/library/typing.rst:14
msgid ""
"The Python runtime does not enforce function and variable type annotations. They can "
"be used by third party tools such as type checkers, IDEs, linters, etc."
msgstr ""
"En tiempo de ejecución, Python no impone las anotaciones de tipado en funciones y "
"variables. Pueden ser utilizadas por herramientas de terceros como validadores de "
"tipado, IDEs, linters, etc."

#: ../Doc/library/typing.rst:20
msgid ""
"This module provides runtime support for type hints. The most fundamental support "
"consists of the types :data:`Any`, :data:`Union`, :data:`Callable`, :class:`TypeVar`, "
"and :class:`Generic`. For a full specification, please see :pep:`484`. For a "
"simplified introduction to type hints, see :pep:`483`."
msgstr ""
"Este módulo entrega soporte en tiempo de ejecución para indicadores de tipo. El "
"soporte fundamental se encuentra en los tipos :data:`Any`, :data:`Union`, :data:"
"`Callable`, :class:`TypeVar`, y :class:`Generic`. Para una especificación completa, "
"por favor ver :pep:`484`. Para una introducción simplificada a los indicadores de "
"tipo, véase :pep:`483`."

#: ../Doc/library/typing.rst:26
msgid "The function below takes and returns a string and is annotated as follows::"
msgstr ""
"La siguiente función toma y retorna una cadena de texto, que se anota de la siguiente "
"manera::"

#: ../Doc/library/typing.rst:31
msgid ""
"In the function ``greeting``, the argument ``name`` is expected to be of type :class:"
"`str` and the return type :class:`str`. Subtypes are accepted as arguments."
msgstr ""
"En la función ``greeting``, se espera que el argumento ``name``  sea de tipo :class:"
"`str` y que el tipo retornado sea :class:`str`. Los subtipos también son aceptados "
"como argumento válido."

#: ../Doc/library/typing.rst:35
msgid ""
"New features are frequently added to the ``typing`` module. The `typing_extensions "
"<https://pypi.org/project/typing-extensions/>`_ package provides backports of these "
"new features to older versions of Python."
msgstr ""
"Frecuentemente se agregan nuevas funcionalidades al módulo ``typing``. El paquete "
"`typing_extensions <https://pypi.org/project/typing-extensions/>`_ provee backports de "
"estas nuevas funcionalidades para versiones más antiguas de Python."

#: ../Doc/library/typing.rst:39
#, fuzzy
msgid ""
"For a summary of deprecated features and a deprecation timeline, please see "
"`Deprecation Timeline of Major Features`_."
msgstr ""
"Para un resumen de las funcionalidades obsoletas y una linea de tiempo de "
"obsolecencia, por favor ver `Deprecation Timeline of Major Features`_."

#: ../Doc/library/typing.rst:44
msgid ""
"The documentation at https://typing.readthedocs.io/ serves as useful reference for "
"type system features, useful typing related tools and typing best practices."
msgstr ""
"La documentación en https://typing.readthedocs.io/ es una referencia útil sobre "
"características de sistemas de tipos, herramientas útiles relativas al tipado, y "
"mejores prácticas de tipado."

#: ../Doc/library/typing.rst:51
msgid "Relevant PEPs"
msgstr "PEPs relevantes"

#: ../Doc/library/typing.rst:53
msgid ""
"Since the initial introduction of type hints in :pep:`484` and :pep:`483`, a number of "
"PEPs have modified and enhanced Python's framework for type annotations. These include:"
msgstr ""
"Desde la introducción inicial de los indicadores de tipo en :pep:`484` y :pep:`483`, "
"un número de PEPs han modificado y mejorado el sistema de anotaciones de tipos de "
"Python. Éstos incluyen:"

#: ../Doc/library/typing.rst:58
msgid ":pep:`526`: Syntax for Variable Annotations"
msgstr ":pep:`526`: Sintaxis para anotaciones de variables"

#: ../Doc/library/typing.rst:58
msgid ""
"*Introducing* syntax for annotating variables outside of function definitions, and :"
"data:`ClassVar`"
msgstr ""
"*Introduce* sintaxis para anotar variables fuera de definiciones de funciones, y :data:"
"`ClassVar`"

#: ../Doc/library/typing.rst:61
msgid ":pep:`544`: Protocols: Structural subtyping (static duck typing)"
msgstr ":pep:`544`: Protocolos: herencia estructural (\"duck typing\" estático)"

#: ../Doc/library/typing.rst:61
msgid ""
"*Introducing* :class:`Protocol` and the :func:`@runtime_checkable<runtime_checkable>` "
"decorator"
msgstr ""
"*Introduce* :class:`Protocol` y el decorador :func:"
"`@runtime_checkable<runtime_checkable>`"

#: ../Doc/library/typing.rst:64
msgid ":pep:`585`: Type Hinting Generics In Standard Collections"
msgstr ":pep:`585`: Indicadores de tipo genéricos en las colecciones estándar"

#: ../Doc/library/typing.rst:64
msgid ""
"*Introducing* :class:`types.GenericAlias` and the ability to use standard library "
"classes as :ref:`generic types<types-genericalias>`"
msgstr ""
"*Introduce* :class:`types.GenericAlias` y la habilidad de utilizar clases de la "
"librería estandar como :ref:`tipos genéricos<types-genericalias>`"

#: ../Doc/library/typing.rst:66
msgid ":pep:`586`: Literal Types"
msgstr ":pep:`586`: Tipos literales"

#: ../Doc/library/typing.rst:67
msgid "*Introducing* :data:`Literal`"
msgstr "*Introduce* :data:`Literal`"

#: ../Doc/library/typing.rst:68
msgid ":pep:`589`: TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys"
msgstr ""
":pep:`589`: TypedDict: Indicadores de tipo para diccionarios con un conjunto de llaves "
"fijo"

#: ../Doc/library/typing.rst:69
msgid "*Introducing* :class:`TypedDict`"
msgstr "*Introduce* :class:`TypedDict`"

#: ../Doc/library/typing.rst:70
msgid ":pep:`591`: Adding a final qualifier to typing"
msgstr ":pep:`591`: Agregar un cualificador final a typing"

#: ../Doc/library/typing.rst:71
msgid "*Introducing* :data:`Final` and the :func:`@final<final>` decorator"
msgstr "*Introduce* :data:`Final` y el decorador :func:`@final<final>`"

#: ../Doc/library/typing.rst:72
msgid ":pep:`593`: Flexible function and variable annotations"
msgstr ":pep:`593`: Anotaciones flexibles para funciones y variables"

#: ../Doc/library/typing.rst:73
msgid "*Introducing* :data:`Annotated`"
msgstr "*Introduce* :data:`Annotated`"

#: ../Doc/library/typing.rst:76
msgid ":pep:`604`: Allow writing union types as ``X | Y``"
msgstr ":pep:`604`: Permitir la escritura de tipos union como ``X | Y``"

#: ../Doc/library/typing.rst:75
msgid ""
"*Introducing* :data:`types.UnionType` and the ability to use the binary-or operator ``|"
"`` to signify a :ref:`union of types<types-union>`"
msgstr ""
"*Introduce* :data:`types.UnionType` y la habilidad de usar el operador binario de "
"disyunción ``|`` para significar una :ref:`union de tipos<types-union>`"

#: ../Doc/library/typing.rst:78
msgid ":pep:`612`: Parameter Specification Variables"
msgstr ":pep:`612`: Variables de especificación de parámetros"

#: ../Doc/library/typing.rst:79
msgid "*Introducing* :class:`ParamSpec` and :data:`Concatenate`"
msgstr "*Introduce* :class:`ParamSpec` y :data:`Concatenate`"

#: ../Doc/library/typing.rst:80
msgid ":pep:`613`: Explicit Type Aliases"
msgstr ":pep:`613`: Alias de tipo explícitos"

#: ../Doc/library/typing.rst:81
msgid "*Introducing* :data:`TypeAlias`"
msgstr "*Introduce* :data:`TypeAlias`"

#: ../Doc/library/typing.rst:82
msgid ":pep:`646`: Variadic Generics"
msgstr ":pep:`646`: Genéricos variádicos"

#: ../Doc/library/typing.rst:83
msgid "*Introducing* :data:`TypeVarTuple`"
msgstr "*Introduce* :data:`TypeVarTuple`"

#: ../Doc/library/typing.rst:84
msgid ":pep:`647`: User-Defined Type Guards"
msgstr ":pep:`647`: Protecciones de tipo definidas por le usuarie"

#: ../Doc/library/typing.rst:85
msgid "*Introducing* :data:`TypeGuard`"
msgstr "*Introduce* :data:`TypeGuard`"

#: ../Doc/library/typing.rst:86
msgid ":pep:`655`: Marking individual TypedDict items as required or potentially missing"
msgstr ""
":pep:`655`: Marcar elementos individuales de un TypedDict como requeridos o "
"potencialmente ausentes"

#: ../Doc/library/typing.rst:87
msgid "*Introducing* :data:`Required` and :data:`NotRequired`"
msgstr "*Introduce* :data:`Required` y :data:`NotRequired`"

#: ../Doc/library/typing.rst:88
msgid ":pep:`673`: Self type"
msgstr ":pep:`673`: Tipo Self"

#: ../Doc/library/typing.rst:89
msgid "*Introducing* :data:`Self`"
msgstr "*Introduce* :data:`Self`"

#: ../Doc/library/typing.rst:90
msgid ":pep:`675`: Arbitrary Literal String Type"
msgstr ":pep:`675`: Tipo para cadenas de caracteres literales arbitratias"

#: ../Doc/library/typing.rst:91
msgid "*Introducing* :data:`LiteralString`"
msgstr "*Introduce* :data:`LiteralString`"

#: ../Doc/library/typing.rst:93
#, fuzzy
msgid ":pep:`681`: Data Class Transforms"
msgstr ":pep:`681`: Transformaciones de Clases de Datos"

#: ../Doc/library/typing.rst:93
msgid "*Introducing* the :func:`@dataclass_transform<dataclass_transform>` decorator"
msgstr "*Introduce* el decorador :func:`@dataclass_transform<dataclass_transform>`"

#: ../Doc/library/typing.rst:98
msgid "Type aliases"
msgstr "Alias de tipo"

#: ../Doc/library/typing.rst:100
msgid ""
"A type alias is defined by assigning the type to the alias. In this example, "
"``Vector`` and ``list[float]`` will be treated as interchangeable synonyms::"
msgstr ""
"Un alias de tipo se define asignando el tipo al alias. En este ejemplo, ``Vector`` y "
"``List[float]`` serán tratados como sinónimos intercambiables::"

#: ../Doc/library/typing.rst:111
msgid "Type aliases are useful for simplifying complex type signatures. For example::"
msgstr ""
"Los alias de tipo son útiles para simplificar firmas de tipo complejas. Por ejemplo::"

#: ../Doc/library/typing.rst:129
msgid ""
"Note that ``None`` as a type hint is a special case and is replaced by ``type(None)``."
msgstr ""
"Nótese que ``None`` como indicador de tipo es un caso especial y es substituido por "
"``type(None)``."

#: ../Doc/library/typing.rst:135
msgid "NewType"
msgstr "NewType"

#: ../Doc/library/typing.rst:137
msgid "Use the :class:`NewType` helper to create distinct types::"
msgstr "Utilícese la clase auxiliar :class:`NewType` para crear tipos distintos::"

#: ../Doc/library/typing.rst:144
msgid ""
"The static type checker will treat the new type as if it were a subclass of the "
"original type. This is useful in helping catch logical errors::"
msgstr ""
"El validador estático de tipos tratará el nuevo tipo como si fuera una subclase del "
"tipo original. Esto es útil para capturar errores lógicos::"

#: ../Doc/library/typing.rst:156
msgid ""
"You may still perform all ``int`` operations on a variable of type ``UserId``, but the "
"result will always be of type ``int``. This lets you pass in a ``UserId`` wherever an "
"``int`` might be expected, but will prevent you from accidentally creating a "
"``UserId`` in an invalid way::"
msgstr ""
"Se pueden realizar todas las operaciones de ``int`` en una variable de tipo "
"``UserId``, pero el resultado siempre será de tipo ``int``. Esto permite pasar un "
"``UserId`` allí donde se espere un ``int``, pero evitará la creación accidental de un "
"``UserId`` de manera incorrecta::"

#: ../Doc/library/typing.rst:164
msgid ""
"Note that these checks are enforced only by the static type checker. At runtime, the "
"statement ``Derived = NewType('Derived', Base)`` will make ``Derived`` a callable that "
"immediately returns whatever parameter you pass it. That means the expression "
"``Derived(some_value)`` does not create a new class or introduce much overhead beyond "
"that of a regular function call."
msgstr ""
"Tenga en cuenta que estas validaciones solo las aplica el verificador de tipo "
"estático. En tiempo de ejecución, la declaración ``Derived = NewType('Derived', "
"Base)`` hará que ``Derived`` sea una clase que retorna inmediatamente cualquier "
"parámetro que le pase. Eso significa que la expresión ``Derived(some_value)`` no crea "
"una nueva clase ni introduce mucha sobrecarga más allá de la de una llamada de función "
"regular."

#: ../Doc/library/typing.rst:170
msgid ""
"More precisely, the expression ``some_value is Derived(some_value)`` is always true at "
"runtime."
msgstr ""
"Más concretamente, la expresión ``some_value is Derived(some_value)`` será siempre "
"verdadera en tiempo de ejecución."

#: ../Doc/library/typing.rst:173
msgid "It is invalid to create a subtype of ``Derived``::"
msgstr "No es válido crear un subtipo de ``Derived``:"

#: ../Doc/library/typing.rst:182
msgid ""
"However, it is possible to create a :class:`NewType` based on a 'derived' ``NewType``::"
msgstr ""
"Sin embargo, es posible crear un :class:`NewType` basado en un ``NewType`` 'derivado':"

#: ../Doc/library/typing.rst:190
msgid "and typechecking for ``ProUserId`` will work as expected."
msgstr "y la comprobación de tipo para ``ProUserId`` funcionará como se espera."

#: ../Doc/library/typing.rst:192
msgid "See :pep:`484` for more details."
msgstr "Véase :pep:`484` para más detalle."

#: ../Doc/library/typing.rst:196
msgid ""
"Recall that the use of a type alias declares two types to be *equivalent* to one "
"another. Doing ``Alias = Original`` will make the static type checker treat ``Alias`` "
"as being *exactly equivalent* to ``Original`` in all cases. This is useful when you "
"want to simplify complex type signatures."
msgstr ""
"Recuérdese que el uso de alias de tipo implica que los dos tipos son *equivalentes* "
"entre sí. Haciendo ``Alias = Original`` provocará que el Validador estático de tipos "
"trate ``Alias`` como algo *exactamente equivalente* a ``Original`` en todos los casos. "
"Esto es útil para cuando se quiera simplificar indicadores de tipo complejos."

#: ../Doc/library/typing.rst:201
msgid ""
"In contrast, ``NewType`` declares one type to be a *subtype* of another. Doing "
"``Derived = NewType('Derived', Original)`` will make the static type checker treat "
"``Derived`` as a *subclass* of ``Original``, which means a value of type ``Original`` "
"cannot be used in places where a value of type ``Derived`` is expected. This is useful "
"when you want to prevent logic errors with minimal runtime cost."
msgstr ""
"En cambio, ``NewType`` declara un tipo que es *subtipo* de otro. Haciendo ``Derived = "
"NewType('Derived', Original)`` hará que el Validador estático de tipos trate "
"``Derived`` como una *subclase* de ``Original``, lo que implica que un valor de tipo "
"``Original`` no puede ser usado allí donde se espere un valor de tipo ``Derived``. "
"Esto es útil para prevenir errores lógicos con un coste de ejecución mínimo."

#: ../Doc/library/typing.rst:210
msgid ""
"``NewType`` is now a class rather than a function.  There is some additional runtime "
"cost when calling ``NewType`` over a regular function.  However, this cost will be "
"reduced in 3.11.0."
msgstr ""
"``NewType`` es ahora una clase en lugar de una función. Existe un costo de tiempo de "
"ejecución adicional cuando se llama a ``NewType`` a través de una función normal. Sin "
"embargo, este costo se reducirá en 3.11.0."

#: ../Doc/library/typing.rst:217
msgid "Callable"
msgstr "Callable"

# Aquí frameworks parace indicar un término abierto referiéndose a elementos
# que interactuarán con las llamadas anotadas. Por ello, se escoge el término
# genérico "entidades"
#: ../Doc/library/typing.rst:219
msgid ""
"Frameworks expecting callback functions of specific signatures might be type hinted "
"using ``Callable[[Arg1Type, Arg2Type], ReturnType]``."
msgstr ""
"Entidades que esperen llamadas a funciones con interfaces específicas puede ser "
"anotadas usando ``Callable[[Arg1Type, Arg2Type], ReturnType]``."

#: ../Doc/library/typing.rst:222 ../Doc/library/typing.rst:1164
#: ../Doc/library/typing.rst:2801
msgid "For example::"
msgstr "Por ejemplo::"

#: ../Doc/library/typing.rst:237
msgid ""
"It is possible to declare the return type of a callable without specifying the call "
"signature by substituting a literal ellipsis for the list of arguments in the type "
"hint: ``Callable[..., ReturnType]``."
msgstr ""
"Es posible declarar el tipo de retorno de un *callable* (invocable) sin especificar "
"tipos en los parámetros substituyendo la lista de argumentos por unos puntos "
"suspensivos (...) en el indicador de tipo: ``Callable[..., ReturnType]``."

#: ../Doc/library/typing.rst:241 ../Doc/library/typing.rst:843
msgid ""
"Callables which take other callables as arguments may indicate that their parameter "
"types are dependent on each other using :class:`ParamSpec`. Additionally, if that "
"callable adds or removes arguments from other callables, the :data:`Concatenate` "
"operator may be used.  They take the form ``Callable[ParamSpecVariable, ReturnType]`` "
"and ``Callable[Concatenate[Arg1Type, Arg2Type, ..., ParamSpecVariable], ReturnType]`` "
"respectively."
msgstr ""
"Los invocables que toman otros invocables como argumentos pueden indicar que sus tipos "
"de parámetros dependen unos de otros utilizando :class:`ParamSpec`. Además, si ese "
"invocable agrega o elimina argumentos de otros invocables, se puede utilizar el "
"operador :data:`Concatenate`. Toman la forma ``Callable[ParamSpecVariable, "
"ReturnType]`` y ``Callable[Concatenate[Arg1Type, Arg2Type, ..., ParamSpecVariable], "
"ReturnType]`` respectivamente."

#: ../Doc/library/typing.rst:249 ../Doc/library/typing.rst:855
msgid ""
"``Callable`` now supports :class:`ParamSpec` and :data:`Concatenate`. See :pep:`612` "
"for more details."
msgstr ""
"``Callable`` ahora es compatible con :class:`ParamSpec` y :data:`Concatenate`. "
"Consulte :pep:`612` para obtener más información."

#: ../Doc/library/typing.rst:254
msgid ""
"The documentation for :class:`ParamSpec` and :class:`Concatenate` provides examples of "
"usage in ``Callable``."
msgstr ""
"La documentación de :class:`ParamSpec` y :class:`Concatenate` proporciona ejemplos de "
"uso en ``Callable``."

#: ../Doc/library/typing.rst:260
msgid "Generics"
msgstr "Genéricos"

#: ../Doc/library/typing.rst:262
msgid ""
"Since type information about objects kept in containers cannot be statically inferred "
"in a generic way, abstract base classes have been extended to support subscription to "
"denote expected types for container elements."
msgstr ""
"Ya que no es posible inferir estáticamente y de una manera genérica la información de "
"tipo de objetos dentro de contenedores, las clases base abstractas han sido mejoradas "
"para permitir sintaxis de subíndice para denotar los tipos esperados en elementos "
"contenedores."

#: ../Doc/library/typing.rst:273
msgid ""
"Generics can be parameterized by using a factory available in typing called :class:"
"`TypeVar`."
msgstr ""
"Los genéricos se pueden parametrizar usando una nueva *factory* disponible en *typing* "
"llamada :class:`TypeVar`."

#: ../Doc/library/typing.rst:289
msgid "User-defined generic types"
msgstr "Tipos genéricos definidos por el usuario"

#: ../Doc/library/typing.rst:291
msgid "A user-defined class can be defined as a generic class."
msgstr "Una clase definida por el usuario puede ser definida como una clase genérica."

#: ../Doc/library/typing.rst:317
msgid ""
"``Generic[T]`` as a base class defines that the class ``LoggedVar`` takes a single "
"type parameter ``T`` . This also makes ``T`` valid as a type within the class body."
msgstr ""
"``Generic[T]`` como clase base define que la clase ``LoggedVar`` toma un solo "
"parámetro ``T``. Esto también implica que ``T`` es un tipo válido dentro del cuerpo de "
"la clase."

# revisar en su contexto
#: ../Doc/library/typing.rst:321
msgid ""
"The :class:`Generic` base class defines :meth:`~object.__class_getitem__` so that "
"``LoggedVar[T]`` is valid as a type::"
msgstr ""
"La clase base :class:`Generic` define :meth:`__class_getitem__` para que "
"``LoggedVar[T]`` sea válido como tipo::"

#: ../Doc/library/typing.rst:330
msgid ""
"A generic type can have any number of type variables. All varieties of :class:"
"`TypeVar` are permissible as parameters for a generic type::"
msgstr ""
"Un tipo genérico puede tener un numero cualquiera de variables de tipo. Se permiten "
"todas las variaciones de :class:`TypeVar` para ser usadas como parámetros de un tipo "
"genérico::"

# revisar la relacion argumento-variable-clase
#: ../Doc/library/typing.rst:342
msgid ""
"Each type variable argument to :class:`Generic` must be distinct. This is thus "
"invalid::"
msgstr ""
"Cada argumento de variable de tipo en una clase :class:`Generic` debe ser distinto. "
"Así, no será válido::"

#: ../Doc/library/typing.rst:353
msgid "You can use multiple inheritance with :class:`Generic`::"
msgstr "Se puede utilizar herencia múltiple con :class:`Generic`::"

#: ../Doc/library/typing.rst:363
msgid "When inheriting from generic classes, some type variables could be fixed::"
msgstr ""
"Cuando se hereda de clases genéricas, se pueden fijar algunas variables de tipo::"

#: ../Doc/library/typing.rst:373
msgid "In this case ``MyDict`` has a single parameter, ``T``."
msgstr "En este caso ``MyDict`` tiene un solo parámetro, ``T``."

#: ../Doc/library/typing.rst:375
msgid ""
"Using a generic class without specifying type parameters assumes :data:`Any` for each "
"position. In the following example, ``MyIterable`` is not generic but implicitly "
"inherits from ``Iterable[Any]``::"
msgstr ""
"Al usar una clase genérica sin especificar parámetros de tipo se asume :data:`Any` "
"para todas las posiciones. En el siguiente ejemplo, ``MyIterable`` no es genérico pero "
"hereda implícitamente de ``Iterable[Any]``::"

#: ../Doc/library/typing.rst:383
msgid "User defined generic type aliases are also supported. Examples::"
msgstr "Son posibles los alias de tipos genéricos definidos por el usuario. Ejemplos::"

#: ../Doc/library/typing.rst:400
msgid ":class:`Generic` no longer has a custom metaclass."
msgstr ":class:`Generic` ya no posee una metaclase personalizable."

#: ../Doc/library/typing.rst:403
msgid ""
"User-defined generics for parameter expressions are also supported via parameter "
"specification variables in the form ``Generic[P]``.  The behavior is consistent with "
"type variables' described above as parameter specification variables are treated by "
"the typing module as a specialized type variable.  The one exception to this is that a "
"list of types can be used to substitute a :class:`ParamSpec`::"
msgstr ""
"Los genéricos definidos por el usuario para expresiones de parámetros también se "
"admiten a través de variables de especificación de parámetros con el formato "
"``Generic[P]``. El comportamiento es coherente con las variables de tipo descritas "
"anteriormente, ya que el módulo typing trata las variables de especificación de "
"parámetros como una variable de tipo especializada. La única excepción a esto es que "
"se puede usar una lista de tipos para sustituir un :class:`ParamSpec`:"

#: ../Doc/library/typing.rst:420
msgid ""
"Furthermore, a generic with only one parameter specification variable will accept "
"parameter lists in the forms ``X[[Type1, Type2, ...]]`` and also ``X[Type1, "
"Type2, ...]`` for aesthetic reasons.  Internally, the latter is converted to the "
"former, so the following are equivalent::"
msgstr ""
"Además, un genérico con una sola variable de especificación de parámetro aceptará "
"listas de parámetros en los formatos ``X[[Type1, Type2, ...]]`` y también ``X[Type1, "
"Type2, ...]`` por razones estéticas. Internamente, este último se convierte en el "
"primero y, por lo tanto, son equivalentes::"

#: ../Doc/library/typing.rst:432
msgid ""
"Do note that generics with :class:`ParamSpec` may not have correct ``__parameters__`` "
"after substitution in some cases because they are intended primarily for static type "
"checking."
msgstr ""
"Téngase presente que los genéricos con :class:`ParamSpec` pueden no tener el "
"``__parameters__`` correcto después de la sustitución en algunos casos porque están "
"destinados principalmente a la verificación de tipos estáticos."

#: ../Doc/library/typing.rst:436
msgid ""
":class:`Generic` can now be parameterized over parameter expressions. See :class:"
"`ParamSpec` and :pep:`612` for more details."
msgstr ""
":class:`Generic` ahora se puede parametrizar sobre expresiones de parámetros. "
"Consulte :class:`ParamSpec` y :pep:`612` para obtener más detalles."

#: ../Doc/library/typing.rst:440
msgid ""
"A user-defined generic class can have ABCs as base classes without a metaclass "
"conflict. Generic metaclasses are not supported. The outcome of parameterizing "
"generics is cached, and most types in the typing module are hashable and comparable "
"for equality."
msgstr ""
"Un clase genérica definida por el usuario puede tener clases ABC como clase base sin "
"conflicto de metaclase. Las metaclases genéricas no están permitidas. El resultado de "
"parametrizar clases genéricas se cachea, y la mayoría de los tipos en el módulo "
"*typing* pueden tener un hash y ser comparables por igualdad (*equality*)."

#: ../Doc/library/typing.rst:447
msgid "The :data:`Any` type"
msgstr "El tipo :data:`Any`"

#: ../Doc/library/typing.rst:449
msgid ""
"A special kind of type is :data:`Any`. A static type checker will treat every type as "
"being compatible with :data:`Any` and :data:`Any` as being compatible with every type."
msgstr ""
"Un caso especial de tipo es :data:`Any`. Un Validador estático de tipos tratará "
"cualquier tipo como compatible con :data:`Any`, y :data:`Any` como compatible con "
"todos los tipos."

#: ../Doc/library/typing.rst:453
msgid ""
"This means that it is possible to perform any operation or method call on a value of "
"type :data:`Any` and assign it to any variable::"
msgstr ""
"Esto significa que es posible realizar cualquier operación o llamada a un método en un "
"valor de tipo :data:`Any` y asignarlo a cualquier variable::"

#: ../Doc/library/typing.rst:471
msgid ""
"Notice that no type checking is performed when assigning a value of type :data:`Any` "
"to a more precise type. For example, the static type checker did not report an error "
"when assigning ``a`` to ``s`` even though ``s`` was declared to be of type :class:"
"`str` and receives an :class:`int` value at runtime!"
msgstr ""
"Nótese que no se realiza comprobación de tipo cuando se asigna un valor de tipo :data:"
"`Any` a un tipo más preciso. Por ejemplo, el Validador estático de tipos no reportó "
"ningún error cuando se asignó ``a`` a ``s``, aún cuando se declaró ``s`` como de tipo :"
"class:`str` y recibió un valor :class:`int` en tiempo de ejecución!"

#: ../Doc/library/typing.rst:477
msgid ""
"Furthermore, all functions without a return type or parameter types will implicitly "
"default to using :data:`Any`::"
msgstr ""
"Además, todas las funciones sin un tipo de retorno o tipos en los parámetros serán "
"asignadas implícitamente a :data:`Any` por defecto::"

#: ../Doc/library/typing.rst:490
msgid ""
"This behavior allows :data:`Any` to be used as an *escape hatch* when you need to mix "
"dynamically and statically typed code."
msgstr ""
"Este comportamiento permite que :data:`Any` sea usado como una *vía de escape* cuando "
"es necesario mezclar código tipado estática y dinámicamente."

#: ../Doc/library/typing.rst:493
msgid ""
"Contrast the behavior of :data:`Any` with the behavior of :class:`object`. Similar to :"
"data:`Any`, every type is a subtype of :class:`object`. However, unlike :data:`Any`, "
"the reverse is not true: :class:`object` is *not* a subtype of every other type."
msgstr ""
"Compárese el comportamiento de :data:`Any` con el de :class:`object`. De manera "
"similar a :data:`Any`, todo tipo es un subtipo de :class:`object`. Sin embargo, en "
"oposición a :data:`Any`, lo contrario no es cierto: :class:`object` *no* es un subtipo "
"de ningún otro tipo."

#: ../Doc/library/typing.rst:498
msgid ""
"That means when the type of a value is :class:`object`, a type checker will reject "
"almost all operations on it, and assigning it to a variable (or using it as a return "
"value) of a more specialized type is a type error. For example::"
msgstr ""
"Esto implica que cuando el tipo de un valor es :class:`object`, un validador de tipos "
"rechazará prácticamente todas las operaciones con él, y al asignarlo a una variable (o "
"usarlo como valor de retorno) de un tipo más preciso será un error de tipo. Por "
"ejemplo::"

#: ../Doc/library/typing.rst:520
msgid ""
"Use :class:`object` to indicate that a value could be any type in a typesafe manner. "
"Use :data:`Any` to indicate that a value is dynamically typed."
msgstr ""
"Úsese :class:`object` para indicar que un valor puede ser de cualquier tipo de manera "
"segura. Úsese :data:`Any` para indicar que un valor es de tipado dinámico."

#: ../Doc/library/typing.rst:525
msgid "Nominal vs structural subtyping"
msgstr "Subtipado nominal vs estructural"

#: ../Doc/library/typing.rst:527
msgid ""
"Initially :pep:`484` defined the Python static type system as using *nominal "
"subtyping*. This means that a class ``A`` is allowed where a class ``B`` is expected "
"if and only if ``A`` is a subclass of ``B``."
msgstr ""
"Inicialmente, el :pep:`484` definió el uso de *subtipado nominal* para el sistema de "
"tipado estático de Python. Esto implica que una clase ``A`` será permitida allí donde "
"se espere una clase ``B`` si y solo si ``A`` es una subclase de ``B``."

# Frase ultracompleja, necesitar una revisión fuerte
#: ../Doc/library/typing.rst:531
msgid ""
"This requirement previously also applied to abstract base classes, such as :class:"
"`~collections.abc.Iterable`. The problem with this approach is that a class had to be "
"explicitly marked to support them, which is unpythonic and unlike what one would "
"normally do in idiomatic dynamically typed Python code. For example, this conforms to :"
"pep:`484`::"
msgstr ""
"Este requisito también se aplicaba anteriormente a clases base abstractas (ABC), tales "
"como :class:`~collections.abc.Iterable`. El problema con esta estrategia es que una "
"clase debía de ser marcada explícitamente para proporcionar tal funcionalidad, lo que "
"resulta poco *pythónico* (idiomático) y poco ajustado a lo que uno normalmente haría "
"en un código Python tipado dinámicamente. Por ejemplo, esto sí se ajusta al :pep:"
"`484`::"

#: ../Doc/library/typing.rst:544
msgid ""
":pep:`544` allows to solve this problem by allowing users to write the above code "
"without explicit base classes in the class definition, allowing ``Bucket`` to be "
"implicitly considered a subtype of both ``Sized`` and ``Iterable[int]`` by static type "
"checkers. This is known as *structural subtyping* (or static duck-typing)::"
msgstr ""
"El :pep:`544` permite resolver este problema al permitir escribir el código anterior "
"sin una clase base explícita en la definición de la clase, permitiendo que el "
"Validador estático de tipo considere implícitamente que ``Bucket`` es un subtipo tanto "
"de ``Sized`` como de ``Iterable[int]``. Esto se conoce como tipado *estructural* (o "
"*duck-typing* estático)::"

#: ../Doc/library/typing.rst:560
msgid ""
"Moreover, by subclassing a special class :class:`Protocol`, a user can define new "
"custom protocols to fully enjoy structural subtyping (see examples below)."
msgstr ""
"Asimismo, creando subclases de la clase especial  :class:`Protocol`, el usuario puede "
"definir nuevos protocolos personalizados y beneficiarse del tipado estructural (véanse "
"los ejemplos de abajo)."

#: ../Doc/library/typing.rst:565
msgid "Module contents"
msgstr "Contenido del módulo"

#: ../Doc/library/typing.rst:567
msgid "The module defines the following classes, functions and decorators."
msgstr "El módulo define las siguientes clases, funciones y decoradores."

#: ../Doc/library/typing.rst:571
msgid ""
"This module defines several types that are subclasses of pre-existing standard library "
"classes which also extend :class:`Generic` to support type variables inside ``[]``. "
"These types became redundant in Python 3.9 when the corresponding pre-existing classes "
"were enhanced to support ``[]``."
msgstr ""
"Este módulo define algunos tipos que son subclases de clases que ya existen en la "
"librería estándar, y que además extienden :class:`Generic` para soportar variables de "
"tipo dentro de ``[]``. Estos tipos se vuelven redundantes en Python 3.9 ya que las "
"clases correspondientes fueron mejoradas para soportar ``[]``."

#: ../Doc/library/typing.rst:577
msgid ""
"The redundant types are deprecated as of Python 3.9 but no deprecation warnings will "
"be issued by the interpreter. It is expected that type checkers will flag the "
"deprecated types when the checked program targets Python 3.9 or newer."
msgstr ""
"Los tipos redundantes están descontinuados con Python 3.9 pero el intérprete no "
"mostrará ninguna advertencia. Se espera que los verificadores de tipo marquen estos "
"tipos como obsoletos cuando el programa a verificar apunte a Python 3.9 o superior."

#: ../Doc/library/typing.rst:582
msgid ""
"The deprecated types will be removed from the :mod:`typing` module in the first Python "
"version released 5 years after the release of Python 3.9.0. See details in :pep:`585`—"
"*Type Hinting Generics In Standard Collections*."
msgstr ""
"Los tipos obsoletos serán removidos del módulo :class:`Generic` en la primera versión "
"de Python que sea lanzada 5 años después del lanzamiento de Python 3.9.0. Véase los "
"detalles en :pep:`585` -- *Sugerencias de tipo genéricas en las Colecciones Estándar*."

#: ../Doc/library/typing.rst:588
msgid "Special typing primitives"
msgstr "Primitivos especiales de tipado"

#: ../Doc/library/typing.rst:591
msgid "Special types"
msgstr "Tipos especiales"

#: ../Doc/library/typing.rst:593
msgid "These can be used as types in annotations and do not support ``[]``."
msgstr "Estos pueden ser usados como tipos en anotaciones y no soportan ``[]``."

#: ../Doc/library/typing.rst:597
msgid "Special type indicating an unconstrained type."
msgstr "Tipo especial que indica un tipo sin restricciones."

#: ../Doc/library/typing.rst:599
msgid "Every type is compatible with :data:`Any`."
msgstr "Todos los tipos son compatibles con :data:`Any`."

#: ../Doc/library/typing.rst:600
msgid ":data:`Any` is compatible with every type."
msgstr ":data:`Any` es compatible con todos los tipos."

# ¿Qué signica el uso de "to duck type" como un verbo en este contexto?
#: ../Doc/library/typing.rst:602
#, fuzzy
msgid ""
":data:`Any` can now be used as a base class. This can be useful for avoiding type "
"checker errors with classes that can duck type anywhere or are highly dynamic."
msgstr ""
"Ahora es posible utilizar :data:`Any` como una clase base. Ésto puede ser útil para "
"evitar errores del Verificador de tipos con clases que pueden hacer uso del *duck "
"typing* en cualquier punto, o que sean áltamente dinámicas."

#: ../Doc/library/typing.rst:609
msgid ""
"Special type that includes only literal strings. A string literal is compatible with "
"``LiteralString``, as is another ``LiteralString``, but an object typed as just "
"``str`` is not. A string created by composing ``LiteralString``-typed objects is also "
"acceptable as a ``LiteralString``."
msgstr ""
"Tipo especial que solo incluye a las cadenas de texto literales. Una cadena de texto "
"literal es compatible con ``LiteralString``, así como otro ``LiteralString`` también "
"lo es, pero un objeto tipado como ``str`` no lo es. Una cadena de texto que ha sido "
"creada componiendo objetos tipados como ``LiteralString` también es válida como "
"``LiteralString``."

#: ../Doc/library/typing.rst:615 ../Doc/library/typing.rst:2443
msgid "Example::"
msgstr "Por ejemplo::"

#: ../Doc/library/typing.rst:629
msgid ""
"This is useful for sensitive APIs where arbitrary user-generated strings could "
"generate problems. For example, the two cases above that generate type checker errors "
"could be vulnerable to an SQL injection attack."
msgstr ""
"Ésto es util para APIs sensibles donde cadenas de texto arbitrarias generadas por "
"usuarios podrían generar problemas. Por ejemplo, los dos casos que aparecen arriba que "
"generar errores en el verificador de tipos podrían ser vulnerables a un ataque de "
"inyección de SQL."

#: ../Doc/library/typing.rst:634
msgid "See :pep:`675` for more details."
msgstr "Véase :pep:`675` para más detalle."

# bottom type?
#: ../Doc/library/typing.rst:640
msgid ""
"The `bottom type <https://en.wikipedia.org/wiki/Bottom_type>`_, a type that has no "
"members."
msgstr ""
"El `bottom type*<https://en.wikipedia.org/wiki/Bottom_type>`_ (tipo vacío), un tipo "
"que no tiene miembros."

#: ../Doc/library/typing.rst:643
msgid ""
"This can be used to define a function that should never be called, or a function that "
"never returns::"
msgstr ""
"Puede ser utilizado para definir una función que nunca debe ser llamada, o una función "
"que nunca retorna::"

#: ../Doc/library/typing.rst:663
msgid ""
"On older Python versions, :data:`NoReturn` may be used to express the same concept. "
"``Never`` was added to make the intended meaning more explicit."
msgstr ""
"En versiones antiguas de Python, es posible utilizar :data:`NoReturn` para expresar el "
"mismo concepto. Se agregó ``Never`` para hacer más explicito el significado "
"intencionado ."

# se añade valor para matizar que la funcion retorna (retorna el control) pero
# no de manera normal. En el ejemplo lanza una excepción.
#: ../Doc/library/typing.rst:668
msgid "Special type indicating that a function never returns. For example::"
msgstr "Tipo especial que indica que una función nunca retorna un valor. Por ejemplo::"

#: ../Doc/library/typing.rst:676
msgid ""
"``NoReturn`` can also be used as a `bottom type <https://en.wikipedia.org/wiki/"
"Bottom_type>`_, a type that has no values. Starting in Python 3.11, the :data:`Never` "
"type should be used for this concept instead. Type checkers should treat the two "
"equivalently."
msgstr ""
"También puede usarse ``NoReturn`` como `bottom type <https://en.wikipedia.org/wiki/"
"Bottom_type>`_, un tipo que no tiene valores. Comenzando con Python 3.11, debe usarse, "
"en cambio, el tipo :data:`Never` para este concepto. Los Validadores de tipo deben "
"tratar a ambos como equivalentes."

# ¿cómo se le llama en español a una variable "capturada" en una clausura?
#: ../Doc/library/typing.rst:687
#, fuzzy
msgid "Special type to represent the current enclosed class. For example::"
msgstr "Tipo especial que representa la clase capturada actual. Por ejemplo::"

#: ../Doc/library/typing.rst:698
msgid ""
"This annotation is semantically equivalent to the following, albeit in a more succinct "
"fashion::"
msgstr ""
"Esta anotacion es semánticamente equivalente a lo siguiente, aunque de una manera más "
"sucinta::"

#: ../Doc/library/typing.rst:710
msgid "In general if something currently follows the pattern of::"
msgstr "En general, si actualmente algo sigue el patron de::"

#: ../Doc/library/typing.rst:717
msgid ""
"You should use :data:`Self` as calls to ``SubclassOfFoo.return_self`` would have "
"``Foo`` as the return type and not ``SubclassOfFoo``."
msgstr ""
"Se debiese usar :data:`Self`, ya que llamadas a ``SubclassOfFoo.return_self`` tendrían "
"``Foo`` como valor de retorno, y no ``SubclassOfFoo``."

#: ../Doc/library/typing.rst:720
msgid "Other common use cases include:"
msgstr "Otros casos de uso comunes incluyen:"

#: ../Doc/library/typing.rst:722
msgid ""
":class:`classmethod`\\s that are used as alternative constructors and return instances "
"of the ``cls`` parameter."
msgstr ""
":class:`classmethod` usados como constructores alternativos y retornan instancias del "
"parámetro ``cls``."

#: ../Doc/library/typing.rst:724
msgid "Annotating an :meth:`~object.__enter__` method which returns self."
msgstr "Anotar un método :meth:`~object.__enter__` que retorna self."

#: ../Doc/library/typing.rst:726
msgid "See :pep:`673` for more details."
msgstr "Véase :pep:`673` para más detalle."

#: ../Doc/library/typing.rst:732
msgid ""
"Special annotation for explicitly declaring a :ref:`type alias <type-aliases>`. For "
"example::"
msgstr ""
"Anotación especial para declarar explícitamente un :ref:`alias de tipo <type-"
"aliases>`. Por ejemplo::"

#: ../Doc/library/typing.rst:739
msgid "See :pep:`613` for more details about explicit type aliases."
msgstr ""
"Consulte :pep:`613` para obtener más detalles sobre los alias de tipos explícitos."

#: ../Doc/library/typing.rst:744
msgid "Special forms"
msgstr "Formas especiales"

#: ../Doc/library/typing.rst:746
msgid ""
"These can be used as types in annotations using ``[]``, each having a unique syntax."
msgstr ""
"Estas se pueden usar como anotaciones de tipo usando ``[]``, cada cual tiene una "
"sintaxis única."

#: ../Doc/library/typing.rst:750
msgid ""
"Tuple type; ``Tuple[X, Y]`` is the type of a tuple of two items with the first item of "
"type X and the second of type Y. The type of the empty tuple can be written as "
"``Tuple[()]``."
msgstr ""
"El tipo Tuple, ``Tuple[X, Y]`` es el tipo de una tupla de dos ítems con el primer ítem "
"de tipo X y el segundo de tipo Y. El tipo de una tupla vacía se puede escribir así: "
"``Tuple[()]``."

#: ../Doc/library/typing.rst:754
msgid ""
"Example: ``Tuple[T1, T2]`` is a tuple of two elements corresponding to type variables "
"T1 and T2.  ``Tuple[int, float, str]`` is a tuple of an int, a float and a string."
msgstr ""
"Ejemplo: ``Tuple[T1, T2]`` es una tupla de dos elementos con sus correspondientes "
"variables de tipo T1 y T2. ``Tuple[int, float, str]`` es un tupla con un número "
"entero, un número de punto flotante y una cadena de texto."

#: ../Doc/library/typing.rst:758
msgid ""
"To specify a variable-length tuple of homogeneous type, use literal ellipsis, e.g. "
"``Tuple[int, ...]``. A plain :data:`Tuple` is equivalent to ``Tuple[Any, ...]``, and "
"in turn to :class:`tuple`."
msgstr ""
"Para especificar una tupla de longitud variable y tipo homogéneo, se usan puntos "
"suspensivos, p. ej. ``Tuple[int, ...]``. Un simple :data:`Tuple` es equivalente a "
"``Tuple[Any, ...]`` y, a su vez, a :class:`tuple`."

#: ../Doc/library/typing.rst:762
msgid ""
":class:`builtins.tuple <tuple>` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`builtins.tuple <tuple>` ahora soporta el uso de subíndices (``[]``). Véase :"
"pep:`585` y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:768
msgid "Union type; ``Union[X, Y]`` is equivalent to ``X | Y`` and means either X or Y."
msgstr "Tipo de unión; ``Union[X, Y]`` es equivalente a ``X | Y`` y significa X o Y."

#: ../Doc/library/typing.rst:770
msgid ""
"To define a union, use e.g. ``Union[int, str]`` or the shorthand ``int | str``. Using "
"that shorthand is recommended. Details:"
msgstr ""
"Para definir una unión, use p. ej. ``Union[int, str]`` o la abreviatura ``int | str``. "
"Se recomienda el uso de la abreviatura. Detalles:"

#: ../Doc/library/typing.rst:772
msgid "The arguments must be types and there must be at least one."
msgstr "Los argumentos deben ser tipos y haber al menos uno."

#: ../Doc/library/typing.rst:774
msgid "Unions of unions are flattened, e.g.::"
msgstr "Las uniones de uniones se simplifican (se aplanan), p. ej.::"

#: ../Doc/library/typing.rst:778
msgid "Unions of a single argument vanish, e.g.::"
msgstr "Las uniones con un solo argumento se eliminan, p. ej.::"

#: ../Doc/library/typing.rst:782
msgid "Redundant arguments are skipped, e.g.::"
msgstr "Argumentos repetidos se omiten, p. ej.::"

#: ../Doc/library/typing.rst:786
msgid "When comparing unions, the argument order is ignored, e.g.::"
msgstr "Cuando se comparan uniones, el orden de los argumentos se ignoran, p. ej.::"

#: ../Doc/library/typing.rst:790
msgid "You cannot subclass or instantiate a ``Union``."
msgstr "No es posible crear una subclase o instanciar un ``Union``."

#: ../Doc/library/typing.rst:792
msgid "You cannot write ``Union[X][Y]``."
msgstr "No es posible escribir ``Union[X][Y]``."

#: ../Doc/library/typing.rst:794
msgid "Don't remove explicit subclasses from unions at runtime."
msgstr "No elimina subclases explícitas de una unión en tiempo de ejecución."

#: ../Doc/library/typing.rst:797
msgid ""
"Unions can now be written as ``X | Y``. See :ref:`union type expressions<types-union>`."
msgstr ""
"Las uniones ahora se pueden escribir como ``X | Y``. Consulte :ref:`union type "
"expressions<types-union>`."

#: ../Doc/library/typing.rst:803
msgid "Optional type."
msgstr "Tipo Optional."

#: ../Doc/library/typing.rst:805
msgid "``Optional[X]`` is equivalent to ``X | None`` (or ``Union[X, None]``)."
msgstr "``Optional[X]`` es equivalente a ``X | None`` (o ``Union[X, None]``)."

#: ../Doc/library/typing.rst:807
msgid ""
"Note that this is not the same concept as an optional argument, which is one that has "
"a default.  An optional argument with a default does not require the ``Optional`` "
"qualifier on its type annotation just because it is optional. For example::"
msgstr ""
"Nótese que no es lo mismo que un argumento opcional, que es aquel que tiene un valor "
"por defecto. Un argumento opcional con un valor por defecto no necesita el indicador "
"``Optional`` en su anotación de tipo simplemente por que sea opcional. Por ejemplo::"

#: ../Doc/library/typing.rst:815
msgid ""
"On the other hand, if an explicit value of ``None`` is allowed, the use of "
"``Optional`` is appropriate, whether the argument is optional or not. For example::"
msgstr ""
"Por otro lado, si se permite un valor ``None``, es apropiado el uso de ``Optional``, "
"independientemente de que sea opcional o no. Por ejemplo::"

#: ../Doc/library/typing.rst:822
msgid ""
"Optional can now be written as ``X | None``. See :ref:`union type expressions<types-"
"union>`."
msgstr ""
"Optional ahora se puede escribir como ``X | None``. Consulte :ref:`union type "
"expressions<types-union>`."

#: ../Doc/library/typing.rst:828
msgid "Callable type; ``Callable[[int], str]`` is a function of (int) -> str."
msgstr ""
"Tipo Callable (invocable); ``Callable[[int], str]`` es una función de (int) -> str."

#: ../Doc/library/typing.rst:830
msgid ""
"The subscription syntax must always be used with exactly two values: the argument list "
"and the return type.  The argument list must be a list of types or an ellipsis; the "
"return type must be a single type."
msgstr ""
"La sintaxis de subíndice (con corchetes *[]*) debe usarse siempre con dos valores: la "
"lista de argumentos y el tipo de retorno. La lista de argumentos debe ser una lista de "
"tipos o unos puntos suspensivos; el tipo de retorno debe ser un único tipo."

#: ../Doc/library/typing.rst:835
msgid ""
"There is no syntax to indicate optional or keyword arguments; such function types are "
"rarely used as callback types. ``Callable[..., ReturnType]`` (literal ellipsis) can be "
"used to type hint a callable taking any number of arguments and returning "
"``ReturnType``.  A plain :data:`Callable` is equivalent to ``Callable[..., Any]``, and "
"in turn to :class:`collections.abc.Callable`."
msgstr ""
"No existe una sintaxis para indicar argumentos opcionales o con clave (*keyword*); "
"tales funciones rara vez se utilizan como tipos para llamadas. ``Callable[..., "
"ReturnType]`` (puntos suspensivos) se puede usar para indicar que un *callable* admite "
"un número indeterminado de argumentos y retorna ``ReturnType``. Un simple :data:"
"`Callable` es equivalente a ``Callable[..., Any]`` y, a su vez, a :class:`collections."
"abc.Callable`."

#: ../Doc/library/typing.rst:851
msgid ""
":class:`collections.abc.Callable` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Callable` ahora soporta subíndices (``[]``). Véase :pep:`585` "
"y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:860
msgid ""
"The documentation for :class:`ParamSpec` and :class:`Concatenate` provide examples of "
"usage with ``Callable``."
msgstr ""
"La documentación de :class:`ParamSpec` y :class:`Concatenate` proporciona ejemplos de "
"uso con ``Callable``."

#: ../Doc/library/typing.rst:865
msgid ""
"Used with :data:`Callable` and :class:`ParamSpec` to type annotate a higher order "
"callable which adds, removes, or transforms parameters of another callable.  Usage is "
"in the form ``Concatenate[Arg1Type, Arg2Type, ..., ParamSpecVariable]``. "
"``Concatenate`` is currently only valid when used as the first argument to a :data:"
"`Callable`. The last parameter to ``Concatenate`` must be a :class:`ParamSpec` or "
"ellipsis (``...``)."
msgstr ""
"Se utiliza con :data:`Callable` y :class:`ParamSpec` para escribir anotar un invocable "
"de orden superior que agrega, elimina o transforma parámetros de otro invocable. El "
"uso tiene el formato ``Concatenate[Arg1Type, Arg2Type, ..., ParamSpecVariable]``. "
"Actualmente, ``Concatenate`` solo es válido cuando se utiliza como primer argumento de "
"un :data:`Callable`. El último parámetro de ``Concatenate`` debe ser un :class:"
"`ParamSpec` o unos puntos suspensivos (``...``)."

#: ../Doc/library/typing.rst:873
msgid ""
"For example, to annotate a decorator ``with_lock`` which provides a :class:`threading."
"Lock` to the decorated function,  ``Concatenate`` can be used to indicate that "
"``with_lock`` expects a callable which takes in a ``Lock`` as the first argument, and "
"returns a callable with a different type signature.  In this case, the :class:"
"`ParamSpec` indicates that the returned callable's parameter types are dependent on "
"the parameter types of the callable being passed in::"
msgstr ""
"Por ejemplo, para anotar un decorador ``with_lock`` que proporciona un :class:"
"`threading.Lock` a la función decorada, ``Concatenate`` puede usarse para indicar que "
"``with_lock`` espera un invocable que toma un ``Lock`` como primer argumento y retorna "
"un invocable con un tipo de firma diferente. En este caso, el :class:`ParamSpec` "
"indica que los tipos de parámetros de los invocables retornados dependen de los tipos "
"de parámetros de los invocables que se pasan en ::"

#: ../Doc/library/typing.rst:912 ../Doc/library/typing.rst:1500
msgid ""
":pep:`612` -- Parameter Specification Variables (the PEP which introduced "
"``ParamSpec`` and ``Concatenate``)."
msgstr ""
":pep:`612` - Variables de especificación de parámetros (el PEP que introdujo "
"``ParamSpec`` y ``Concatenate``)."

#: ../Doc/library/typing.rst:914
msgid ":class:`ParamSpec` and :class:`Callable`."
msgstr ":class:`ParamSpec` y :class:`Callable`."

#: ../Doc/library/typing.rst:919
msgid ""
"A variable annotated with ``C`` may accept a value of type ``C``. In contrast, a "
"variable annotated with ``Type[C]`` may accept values that are classes themselves -- "
"specifically, it will accept the *class object* of ``C``. For example::"
msgstr ""
"Una variable indicada como ``C`` puede aceptar valores de tipo ``C``. Sin embargo, un "
"variable indicada como ``Type[C]`` puede aceptar valores que son clases en sí mismas "
"-- específicamente, aceptará el *objeto clase* de ``C``. Por ejemplo.::"

#: ../Doc/library/typing.rst:928
msgid "Note that ``Type[C]`` is covariant::"
msgstr "Nótese que ``Type[C]`` es covariante::"

#: ../Doc/library/typing.rst:940
msgid ""
"The fact that ``Type[C]`` is covariant implies that all subclasses of ``C`` should "
"implement the same constructor signature and class method signatures as ``C``. The "
"type checker should flag violations of this, but should also allow constructor calls "
"in subclasses that match the constructor calls in the indicated base class. How the "
"type checker is required to handle this particular case may change in future revisions "
"of :pep:`484`."
msgstr ""
"El hecho de que ``Type[C]`` sea covariante implica que todas las subclases de ``C`` "
"deben implementar la misma interfaz del constructor y las mismas interfaces de los "
"métodos de clase que ``C``. El validador de tipos marcará cualquier incumplimiento de "
"esto, pero permitirá llamadas al constructor que coincida con la llamada al "
"constructor de la clase base indicada. El modo en que el validador de tipos debe "
"gestionar este caso particular podría cambiar en futuras revisiones de :pep:`484`."

#: ../Doc/library/typing.rst:948
msgid ""
"The only legal parameters for :class:`Type` are classes, :data:`Any`, :ref:`type "
"variables <generics>`, and unions of any of these types. For example::"
msgstr ""
"Lo únicos parámetros válidos de :class:`Type` son clases, :data:`Any`, :ref:`type "
"variables <generics>`, y uniones de cualquiera de los tipos anteriores. Por ejemplo::"

#: ../Doc/library/typing.rst:954
msgid ""
"``Type[Any]`` is equivalent to ``Type`` which in turn is equivalent to ``type``, which "
"is the root of Python's metaclass hierarchy."
msgstr ""
"``Type[Any]`` es equivalente a ``Type``, que a su vez es equivalente a ``type``, que "
"es la raíz de la jerarquía de metaclases de Python."

#: ../Doc/library/typing.rst:959
msgid ""
":class:`builtins.type <type>` now supports subscripting (``[]``). See :pep:`585` and :"
"ref:`types-genericalias`."
msgstr ""
":class:`builtins.type <type>` ahora soporta el uso de subíndices (``[]``). Véase :pep:"
"`585` y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:965
msgid ""
"A type that can be used to indicate to type checkers that the corresponding variable "
"or function parameter has a value equivalent to the provided literal (or one of "
"several literals). For example::"
msgstr ""
"Un tipo que puede ser utilizado para indicar a los validadores de tipos que una "
"variable o un parámetro de una función tiene un valor equivalente al valor literal "
"proveído (o uno de los proveídos). Por ejemplo::"

#: ../Doc/library/typing.rst:979
msgid ""
"``Literal[...]`` cannot be subclassed. At runtime, an arbitrary value is allowed as "
"type argument to ``Literal[...]``, but type checkers may impose restrictions. See :pep:"
"`586` for more details about literal types."
msgstr ""
"``Literal[...]`` no puede ser derivado. En tiempo de ejecución, se permite un valor "
"arbitrario como argumento de tipo de ``Literal[...]``, pero los validadores de tipos "
"pueden imponer sus restricciones. Véase :pep:`585` para más detalles sobre tipos "
"literales."

#: ../Doc/library/typing.rst:985
msgid ""
"``Literal`` now de-duplicates parameters.  Equality comparisons of ``Literal`` objects "
"are no longer order dependent. ``Literal`` objects will now raise a :exc:`TypeError` "
"exception during equality comparisons if one of their parameters are not :term:"
"`hashable`."
msgstr ""
"``Literal`` ahora elimina los parámetros duplicados. Las comparaciones de igualdad de "
"los objetos ``Literal`` ya no dependen del orden. Los objetos ``Literal`` ahora "
"lanzarán una excepción :exc:`TypeError` durante las comparaciones de igualdad si uno "
"de sus parámetros no es :term:`hashable`."

#: ../Doc/library/typing.rst:993
msgid "Special type construct to mark class variables."
msgstr "Construcción especial para tipado para marcar variables de clase."

# Puede haber una entrada mejor para "As introduced"
#: ../Doc/library/typing.rst:995
msgid ""
"As introduced in :pep:`526`, a variable annotation wrapped in ClassVar indicates that "
"a given attribute is intended to be used as a class variable and should not be set on "
"instances of that class. Usage::"
msgstr ""
"Tal y como introduce :pep:`526`, una anotación de variable rodeada por ClassVar indica "
"que la intención de un atributo dado es ser usado como variable de clase y que no "
"debería ser modificado en las instancias de esa misma clase. Uso::"

# subscribed se substituye por niveles de subindice
#: ../Doc/library/typing.rst:1003
msgid ":data:`ClassVar` accepts only types and cannot be further subscribed."
msgstr ":data:`ClassVar` solo acepta tipos y no admite más niveles de subíndices."

#: ../Doc/library/typing.rst:1005
msgid ""
":data:`ClassVar` is not a class itself, and should not be used with :func:`isinstance` "
"or :func:`issubclass`. :data:`ClassVar` does not change Python runtime behavior, but "
"it can be used by third-party type checkers. For example, a type checker might flag "
"the following code as an error::"
msgstr ""
":data:`ClassVar` no es un clase en sí misma, y no debe ser usado con :func:"
"`isinstance` o :func:`issubclass`. :data:`ClassVar` no modifica el comportamiento de "
"Python en tiempo de ejecución pero puede ser utilizado por validadores de terceros. "
"Por ejemplo, un validador de tipos puede marcar el siguiente código como erróneo::"

#: ../Doc/library/typing.rst:1019
msgid ""
"A special typing construct to indicate to type checkers that a name cannot be re-"
"assigned or overridden in a subclass. For example::"
msgstr ""
"Un construcción especial para tipado que indica a los validadores de tipo que un "
"nombre no puede ser reasignado o sobrescrito en una subclase. Por ejemplo::"

#: ../Doc/library/typing.rst:1031 ../Doc/library/typing.rst:2684
msgid ""
"There is no runtime checking of these properties. See :pep:`591` for more details."
msgstr ""
"No hay comprobación en tiempo de ejecución para estas propiedades. Véase :pep:`591` "
"para más detalles."

#: ../Doc/library/typing.rst:1040
msgid ""
"Special typing constructs that mark individual keys of a :class:`TypedDict` as either "
"required or non-required respectively."
msgstr ""
"Constructos de tipado especiales que marcan llaves individuales de un :class:"
"`TypedDict` como requeridas o no requeridas respectivamente."

#: ../Doc/library/typing.rst:1043
msgid "See :class:`TypedDict` and :pep:`655` for more details."
msgstr "Véase :class:`TypedDict` y :pep:`655` para más detalle."

#: ../Doc/library/typing.rst:1049
msgid ""
"A type, introduced in :pep:`593` (``Flexible function and variable annotations``), to "
"decorate existing types with context-specific metadata (possibly multiple pieces of "
"it, as ``Annotated`` is variadic). Specifically, a type ``T`` can be annotated with "
"metadata ``x`` via the typehint ``Annotated[T, x]``. This metadata can be used for "
"either static analysis or at runtime. If a library (or tool) encounters a typehint "
"``Annotated[T, x]`` and has no special logic for metadata ``x``, it should ignore it "
"and simply treat the type as ``T``. Unlike the ``no_type_check`` functionality that "
"currently exists in the ``typing`` module which completely disables typechecking "
"annotations on a function or a class, the ``Annotated`` type allows for both static "
"typechecking of ``T`` (which can safely ignore ``x``) together with runtime access to "
"``x`` within a specific application."
msgstr ""
"Un tipo introducido en :pep:`593` (``Anotaciones flexibles de función y variable``), "
"para decorar tipos existentes con metadatos específicos del contexto (posiblemente "
"múltiples partes del mismo, ya que ``Annotated`` es variádico). En concreto, un tipo "
"``T`` puede ser anotado con el metadato ``x`` a través del *typehint* ``Annotated[T,"
"x]``. Estos metadatos se pueden utilizar para el análisis estático o en tiempo de "
"ejecución. Si una librería (o herramienta) encuentra un *typehint* ``Annotated[T,x]`` "
"y no encuentra una lógica especial para el metadato ``x``, este debería ignorarlo o "
"simplemente tratar el tipo como ``T``. A diferencia de la funcionalidad "
"``no_type_check``, que actualmente existe en el módulo ``typing``, que deshabilita "
"completamente la comprobación de anotaciones de tipo en una función o clase, el tipo "
"``Annotated`` permite tanto la comprobación de tipos estático de ``T`` (la cuál "
"ignoraría ``x`` de forma segura) en conjunto con el acceso a ``x`` en tiempo de "
"ejecución dentro de una aplicación específica."

#: ../Doc/library/typing.rst:1063
msgid ""
"Ultimately, the responsibility of how to interpret the annotations (if at all) is the "
"responsibility of the tool or library encountering the ``Annotated`` type. A tool or "
"library encountering an ``Annotated`` type can scan through the annotations to "
"determine if they are of interest (e.g., using ``isinstance()``)."
msgstr ""
"En última instancia, la responsabilidad de cómo interpretar las anotaciones (si es que "
"la hay) es de la herramienta o librería que encuentra el tipo ``Annotated``. Una "
"herramienta o librería que encuentra un tipo ``Annotated`` puede escanear las "
"anotaciones para determinar si son de interés. (por ejemplo, usando ``isinstance()``)."

#: ../Doc/library/typing.rst:1069
msgid ""
"When a tool or a library does not support annotations or encounters an unknown "
"annotation it should just ignore it and treat annotated type as the underlying type."
msgstr ""
"Cuando una herramienta o librería no soporta anotaciones o encuentra una anotación "
"desconocida, simplemente debe ignorarla o tratar la anotación como el tipo subyacente."

#: ../Doc/library/typing.rst:1073
msgid ""
"It's up to the tool consuming the annotations to decide whether the client is allowed "
"to have several annotations on one type and how to merge those annotations."
msgstr ""
"Depende de la herramienta que consume las anotaciones decidir si el cliente puede "
"tener varias anotaciones en un tipo y cómo combinar esas anotaciones."

#: ../Doc/library/typing.rst:1077
msgid ""
"Since the ``Annotated`` type allows you to put several annotations of the same (or "
"different) type(s) on any node, the tools or libraries consuming those annotations are "
"in charge of dealing with potential duplicates. For example, if you are doing value "
"range analysis you might allow this::"
msgstr ""
"Dado que el tipo ``Annotated`` permite colocar varias anotaciones del mismo (o "
"diferente) tipo(s) en cualquier nodo, las herramientas o librerías que consumen dichas "
"anotaciones están a cargo de ocuparse de potenciales duplicados. Por ejemplo, si se "
"está realizando un análisis de rango, esto se debería permitir::"

#: ../Doc/library/typing.rst:1086
msgid ""
"Passing ``include_extras=True`` to :func:`get_type_hints` lets one access the extra "
"annotations at runtime."
msgstr ""
"Pasar ``include_extras=True`` a :func:`get_type_hints` permite acceder a las "
"anotaciones extra en tiempo de ejecución."

#: ../Doc/library/typing.rst:1089
msgid "The details of the syntax:"
msgstr "Los detalles de la sintaxis:"

#: ../Doc/library/typing.rst:1091
msgid "The first argument to ``Annotated`` must be a valid type"
msgstr "El primer argumento en ``Annotated`` debe ser un tipo válido"

#: ../Doc/library/typing.rst:1093
msgid ""
"Multiple type annotations are supported (``Annotated`` supports variadic arguments)::"
msgstr ""
"Se permiten varias anotaciones de tipo (``Annotated`` admite argumentos variádicos)::"

#: ../Doc/library/typing.rst:1098
msgid ""
"``Annotated`` must be called with at least two arguments ( ``Annotated[int]`` is not "
"valid)"
msgstr ""
"``Annotated`` debe ser llamado con al menos dos argumentos (``Annotated[int]`` no es "
"válido)"

#: ../Doc/library/typing.rst:1101
msgid "The order of the annotations is preserved and matters for equality checks::"
msgstr ""
"Se mantiene el orden de las anotaciones y se toma en cuenta para chequeos de igualdad::"

#: ../Doc/library/typing.rst:1108
msgid ""
"Nested ``Annotated`` types are flattened, with metadata ordered starting with the "
"innermost annotation::"
msgstr ""
"Los tipos ``Annotated`` anidados son aplanados con los metadatos ordenados empezando "
"por la anotación más interna::"

#: ../Doc/library/typing.rst:1115
msgid "Duplicated annotations are not removed::"
msgstr "Anotaciones duplicadas no son removidas::"

#: ../Doc/library/typing.rst:1121
msgid "``Annotated`` can be used with nested and generic aliases::"
msgstr "``Anotated`` puede ser usado con alias anidados y genéricos::"

#: ../Doc/library/typing.rst:1134
msgid ""
"Special typing form used to annotate the return type of a user-defined type guard "
"function.  ``TypeGuard`` only accepts a single type argument. At runtime, functions "
"marked this way should return a boolean."
msgstr ""
"Formulario de mecanografía especial utilizado para anotar el tipo de retorno de una "
"función de protección de tipo definida por el usuario. ``TypeGuard`` solo acepta un "
"argumento de tipo único. En tiempo de ejecución, las funciones marcadas de esta manera "
"deberían retornar un booleano."

#: ../Doc/library/typing.rst:1138
msgid ""
"``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static type "
"checkers to determine a more precise type of an expression within a program's code "
"flow.  Usually type narrowing is done by analyzing conditional code flow and applying "
"the narrowing to a block of code.  The conditional expression here is sometimes "
"referred to as a \"type guard\"::"
msgstr ""
"``TypeGuard`` tiene como objetivo beneficiar a *type narrowing*, una técnica utilizada "
"por los verificadores de tipo estático para determinar un tipo más preciso de una "
"expresión dentro del flujo de código de un programa. Por lo general, el estrechamiento "
"de tipos se realiza analizando el flujo de código condicional y aplicando el "
"estrechamiento a un bloque de código. La expresión condicional aquí a veces se "
"denomina \"protección de tipo\":"

#: ../Doc/library/typing.rst:1153
msgid ""
"Sometimes it would be convenient to use a user-defined boolean function as a type "
"guard.  Such a function should use ``TypeGuard[...]`` as its return type to alert "
"static type checkers to this intention."
msgstr ""
"A veces sería conveniente utilizar una función booleana definida por el usuario como "
"protección de tipos. Dicha función debería usar ``TypeGuard[...]`` como su tipo de "
"retorno para alertar a los verificadores de tipo estático sobre esta intención."

#: ../Doc/library/typing.rst:1157
msgid "Using  ``-> TypeGuard`` tells the static type checker that for a given function:"
msgstr ""
"El uso de ``-> TypeGuard`` le dice al verificador de tipo estático que para una "
"función determinada:"

#: ../Doc/library/typing.rst:1160
msgid "The return value is a boolean."
msgstr "El valor de retorno es un booleano."

#: ../Doc/library/typing.rst:1161
msgid ""
"If the return value is ``True``, the type of its argument is the type inside "
"``TypeGuard``."
msgstr ""
"Si el valor de retorno es ``True``, el tipo de su argumento es el tipo dentro de "
"``TypeGuard``."

#: ../Doc/library/typing.rst:1178
msgid ""
"If ``is_str_list`` is a class or instance method, then the type in ``TypeGuard`` maps "
"to the type of the second parameter after ``cls`` or ``self``."
msgstr ""
"Si ``is_str_list`` es un método de clase o instancia, entonces el tipo en "
"``TypeGuard`` se asigna al tipo del segundo parámetro después de ``cls`` o ``self``."

#: ../Doc/library/typing.rst:1182
msgid ""
"In short, the form ``def foo(arg: TypeA) -> TypeGuard[TypeB]: ...``, means that if "
"``foo(arg)`` returns ``True``, then ``arg`` narrows from ``TypeA`` to ``TypeB``."
msgstr ""
"En resumen, la forma ``def foo(arg: TypeA) -> TypeGuard[TypeB]: ...`` significa que si "
"``foo(arg)`` retorna ``True``, entonces ``arg`` se estrecha de ``TypeA`` a ``TypeB``."

#: ../Doc/library/typing.rst:1188
msgid ""
"``TypeB`` need not be a narrower form of ``TypeA`` -- it can even be a wider form. The "
"main reason is to allow for things like narrowing ``list[object]`` to ``list[str]`` "
"even though the latter is not a subtype of the former, since ``list`` is invariant. "
"The responsibility of writing type-safe type guards is left to the user."
msgstr ""
"No es necesario que ``TypeB`` sea una forma más estrecha de ``TypeA``; incluso puede "
"ser una forma más amplia. La razón principal es permitir cosas como reducir "
"``List[object]`` a ``List[str]`` aunque este último no sea un subtipo del primero, ya "
"que ``List`` es invariante. La responsabilidad de escribir protecciones de tipo "
"seguras se deja al usuario."

#: ../Doc/library/typing.rst:1194
msgid "``TypeGuard`` also works with type variables.  See :pep:`647` for more details."
msgstr ""
"``TypeGuard`` también funciona con variables de tipo. Véase :pep:`647` para más "
"detalles."

#: ../Doc/library/typing.rst:1200
msgid "Building generic types"
msgstr "Contruir tipos genéricos"

#: ../Doc/library/typing.rst:1202
msgid ""
"These are not used in annotations. They are building blocks for creating generic types."
msgstr ""
"Estos no son utilizados en anotaciones. Son utilizados como bloques para crear tipos "
"genéricos."

#: ../Doc/library/typing.rst:1206
msgid "Abstract base class for generic types."
msgstr "Clase base abstracta para tipos genéricos."

#: ../Doc/library/typing.rst:1208
msgid ""
"A generic type is typically declared by inheriting from an instantiation of this class "
"with one or more type variables. For example, a generic mapping type might be defined "
"as::"
msgstr ""
"Un tipo genérico se declara habitualmente heredando de una instancia de esta clase con "
"una o más variables de tipo. Por ejemplo, un tipo de mapeo genérico se podría definir "
"como::"

#: ../Doc/library/typing.rst:1217
msgid "This class can then be used as follows::"
msgstr "Entonces, esta clase se puede usar como sigue::"

#: ../Doc/library/typing.rst:1230
msgid "Type variable."
msgstr "Variable de tipo."

#: ../Doc/library/typing.rst:1232 ../Doc/library/typing.rst:1429
#: ../Doc/library/typing.rst:1606
msgid "Usage::"
msgstr "Uso::"

#: ../Doc/library/typing.rst:1238
msgid ""
"Type variables exist primarily for the benefit of static type checkers.  They serve as "
"the parameters for generic types as well as for generic function definitions.  See :"
"class:`Generic` for more information on generic types.  Generic functions work as "
"follows::"
msgstr ""
"Las variables de tipo son principalmente para ayudar a los validadores estáticos de "
"tipos. Sirven tanto como de parámetros para tipos genéricos como para definición de "
"funciones genéricas. Véase :class:`Generic` para más información sobre tipos "
"genéricos. Las funciones genéricas funcionan de la siguiente manera::"

#: ../Doc/library/typing.rst:1258
msgid ""
"Note that type variables can be *bound*, *constrained*, or neither, but cannot be both "
"bound *and* constrained."
msgstr ""
"Nótese que las variables de tipo pueden ser *bound* (delimitadas), *constrained* "
"(restringidas), o ninguna, pero no pueden ser al mismo tiempo delimitadas *y* "
"restringidas."

#: ../Doc/library/typing.rst:1261
msgid ""
"Bound type variables and constrained type variables have different semantics in "
"several important ways. Using a *bound* type variable means that the ``TypeVar`` will "
"be solved using the most specific type possible::"
msgstr ""
"Las variables de tipo delimitadas y las variables de tipo restringidas tienen "
"semánticas distintas en varios aspectos importantes. Usar una variable de tipo *bound* "
"(delimitada) significa que la ``TypeVar`` será resuelta utilizando el tipo más "
"específico posible::"

#: ../Doc/library/typing.rst:1276
msgid ""
"Type variables can be bound to concrete types, abstract types (ABCs or protocols), and "
"even unions of types::"
msgstr ""
"Las variablas de tipo pueden estar delimitadas por tipos concretos, tipos abstractos "
"(ABCs o *protocols*) e incluso uniones de tipos::"

#: ../Doc/library/typing.rst:1282
msgid ""
"Using a *constrained* type variable, however, means that the ``TypeVar`` can only ever "
"be solved as being exactly one of the constraints given::"
msgstr ""
"Sin embargo, usar una variable de tipo *constrained* significa que la ``TypeVar`` sólo "
"podrá ser determinada como exactamente una de las restricciones dadas::"

#: ../Doc/library/typing.rst:1293
msgid ""
"At runtime, ``isinstance(x, T)`` will raise :exc:`TypeError`.  In general, :func:"
"`isinstance` and :func:`issubclass` should not be used with types."
msgstr ""
"En tiempo de ejecución, ``isinstance(x, T)`` lanzará una excepción  :exc:`TypeError`.  "
"En general, :func:`isinstance` y :func:`issubclass` no se deben usar con variables de "
"tipo."

#: ../Doc/library/typing.rst:1296
msgid ""
"Type variables may be marked covariant or contravariant by passing ``covariant=True`` "
"or ``contravariant=True``.  See :pep:`484` for more details.  By default, type "
"variables are invariant."
msgstr ""
"Las variables de tipo pueden ser marcadas como covariantes o contravariantes pasando "
"``covariant=True`` o ``contravariant=True``, respectivamente. Véase :pep:`484` para "
"más detalles. Por defecto, las variables de tipo son invariantes."

#: ../Doc/library/typing.rst:1302
msgid ""
"Type variable tuple. A specialized form of :class:`type variable <TypeVar>` that "
"enables *variadic* generics."
msgstr ""
"Tupla de variables de tipo. Una versión especializada de :class:`type variables "
"<TypeVar>` que permite genéricos *variádicos*."

#: ../Doc/library/typing.rst:1305
msgid ""
"A normal type variable enables parameterization with a single type. A type variable "
"tuple, in contrast, allows parameterization with an *arbitrary* number of types by "
"acting like an *arbitrary* number of type variables wrapped in a tuple. For example::"
msgstr ""
"Una variable de tipo normal permite parametrizar con un solo tipo. Una tupla de "
"variables de tipo, en contraste, permite la parametrizaci+on con un número "
"*arbitrario* de tipos, al actuar como un número *arbitrario* de variables de tipo "
"envueltas en una tupla. Por ejemplo::"

#: ../Doc/library/typing.rst:1333
msgid ""
"Note the use of the unpacking operator ``*`` in ``tuple[T, *Ts]``. Conceptually, you "
"can think of ``Ts`` as a tuple of type variables ``(T1, T2, ...)``. ``tuple[T, *Ts]`` "
"would then become ``tuple[T, *(T1, T2, ...)]``, which is equivalent to ``tuple[T, T1, "
"T2, ...]``. (Note that in older versions of Python, you might see this written using :"
"data:`Unpack <Unpack>` instead, as ``Unpack[Ts]``.)"
msgstr ""
"Nótese el uso del operador de desempaquetado ``*`` en ``tuple[T, *Ts]``. "
"Conceptualmente, puede pensarse en ``Ts`` como una tupla de variables de tipo ``(T1, "
"T2, ...)``. ``tuple[T, *Ts]`` se convertiría en ``tuple[T, *(T1, T2, ...)]``, lo que "
"es equivalente a ``tuple[T, T1, T2, ...]``. (Nótese que en versiones más antiguas de "
"Python, ésto puede verse escrito usando en cambio :data:`Unpack <Unpack>`, en la forma "
"``Unpack[Ts]``.)"

# Esta coma es válida en español? en mi mente hace sentido porque me permite separar los dos sustantivos, en el mar de "de" que hay
#: ../Doc/library/typing.rst:1341
msgid ""
"Type variable tuples must *always* be unpacked. This helps distinguish type variable "
"types from normal type variables::"
msgstr ""
"Las tuplas de variables de tipo *siempre* deben ser desempaquetadas. Esto ayuda a "
"distinguir tuplas de variables de tipos, de variables de tipo normales::"

#: ../Doc/library/typing.rst:1348
msgid ""
"Type variable tuples can be used in the same contexts as normal type variables. For "
"example, in class definitions, arguments, and return types::"
msgstr ""
"Las tuplas de varialbes de tipo pueden ser utilizadas en los mismos contextos que las "
"variables de tipo normales. Por ejemplo en definiciones de clases, argumentos y tipos "
"de retorno::"

#: ../Doc/library/typing.rst:1357
msgid "Type variable tuples can be happily combined with normal type variables::"
msgstr ""
"Las tuplas de variables de tipo pueden ser combinadas sin problema con variables de "
"tipo normales::"

#: ../Doc/library/typing.rst:1370
msgid ""
"However, note that at most one type variable tuple may appear in a single list of type "
"arguments or type parameters::"
msgstr ""
"Sin embargo, nótese que en una determinada lista de argumentos de tipo o de parámetros "
"de tipo puede haber como máximo una tupla de variables de tipo::"

#: ../Doc/library/typing.rst:1377
msgid ""
"Finally, an unpacked type variable tuple can be used as the type annotation of "
"``*args``::"
msgstr ""
"Finalmente, una tupla de variables de tipo desempaquetada puede ser utilizada como la "
"anotación de tipo de ``*args``::"

#: ../Doc/library/typing.rst:1387
msgid ""
"In contrast to non-unpacked annotations of ``*args`` - e.g. ``*args: int``, which "
"would specify that *all* arguments are ``int`` - ``*args: *Ts`` enables reference to "
"the types of the *individual* arguments in ``*args``. Here, this allows us to ensure "
"the types of the ``*args`` passed to ``call_soon`` match the types of the (positional) "
"arguments of ``callback``."
msgstr ""
"En contraste con las anotaciones no-desempaquetadas de ``*args``, por ej. ``*args: "
"int``, que especificaría que *todos* los argumentos son ``int`` - ``*args: *Ts`` "
"permite referenciar los tipos de los argumentos *individuales* en ``*args``. Aquí, "
"ésto permite asegurarse de que los tipos de los ``*args`` que son pasados a "
"``call_soon`` calcen con los tipos de los argumentos (posicionales) de ``callback``."

#: ../Doc/library/typing.rst:1394
msgid "See :pep:`646` for more details on type variable tuples."
msgstr ""
"Véase :pep:`646` para obtener más detalles sobre las tuplas de variables de tipo."

#: ../Doc/library/typing.rst:1400
msgid ""
"A typing operator that conceptually marks an object as having been unpacked. For "
"example, using the unpack operator ``*`` on a :class:`type variable tuple "
"<TypeVarTuple>` is equivalent to using ``Unpack`` to mark the type variable tuple as "
"having been unpacked::"
msgstr ""
"Un operador de tipado que conceptualmente marca en un objeto el hecho de haber sido "
"desempaquetado. Por ejemplo, el uso del operador de desepaquetado ``*`` en una :class:"
"`type variable tuple <TypeVarTuple>` es equivalente al uso de ``Unpack`` para marcar "
"en una tupla de variables de tipo el haber sido desepaquetada::"

#: ../Doc/library/typing.rst:1410
msgid ""
"In fact, ``Unpack`` can be used interchangeably with ``*`` in the context of types. "
"You might see ``Unpack`` being used explicitly in older versions of Python, where "
"``*`` couldn't be used in certain places::"
msgstr ""
"De hecho, es posible utilizar ``Unpack`` indistintamente de ``*`` en el contexto de "
"tipos. ``Unpack`` puede ser visto siendo usado explícitamente en versiones más "
"antiguas de Python, donde ``*`` no podía ser usado en ciertos lugares::"

#: ../Doc/library/typing.rst:1426
msgid ""
"Parameter specification variable.  A specialized version of :class:`type variables "
"<TypeVar>`."
msgstr ""
"Variable de especificación de parámetros. Una versión especializada de :class:`type "
"variables <TypeVar>`."

#: ../Doc/library/typing.rst:1433
msgid ""
"Parameter specification variables exist primarily for the benefit of static type "
"checkers.  They are used to forward the parameter types of one callable to another "
"callable -- a pattern commonly found in higher order functions and decorators.  They "
"are only valid when used in ``Concatenate``, or as the first argument to ``Callable``, "
"or as parameters for user-defined Generics.  See :class:`Generic` for more information "
"on generic types."
msgstr ""
"Las variables de especificación de parámetros existen principalmente para el beneficio "
"de los verificadores de tipo estático. Se utilizan para reenviar los tipos de "
"parámetros de un invocable a otro invocable, un patrón que se encuentra comúnmente en "
"funciones y decoradores de orden superior. Solo son válidos cuando se utilizan en "
"``Concatenate``, o como primer argumento de ``Callable``, o como parámetros para "
"genéricos definidos por el usuario. Consulte :class:`Generic` para obtener más "
"información sobre tipos genéricos."

#: ../Doc/library/typing.rst:1440
msgid ""
"For example, to add basic logging to a function, one can create a decorator "
"``add_logging`` to log function calls.  The parameter specification variable tells the "
"type checker that the callable passed into the decorator and the new callable returned "
"by it have inter-dependent type parameters::"
msgstr ""
"Por ejemplo, para agregar un registro básico a una función, se puede crear un "
"decorador ``add_logging`` para registrar llamadas a funciones. La variable de "
"especificación de parámetros le dice al verificador de tipo que el invocable pasado al "
"decorador y el nuevo invocable retornado por él tienen parámetros de tipo "
"interdependientes:"

#: ../Doc/library/typing.rst:1464
msgid ""
"Without ``ParamSpec``, the simplest way to annotate this previously was to use a :"
"class:`TypeVar` with bound ``Callable[..., Any]``.  However this causes two problems:"
msgstr ""
"Sin ``ParamSpec``, la forma más sencilla de anotar esto anteriormente era usar un :"
"class:`TypeVar` con ``Callable[..., Any]`` enlazado. Sin embargo, esto causa dos "
"problemas:"

#: ../Doc/library/typing.rst:1468
msgid ""
"The type checker can't type check the ``inner`` function because ``*args`` and "
"``**kwargs`` have to be typed :data:`Any`."
msgstr ""
"El verificador de tipo no puede verificar la función ``inner`` porque ``*args`` y "
"``**kwargs`` deben escribirse :data:`Any`."

#: ../Doc/library/typing.rst:1470
msgid ""
":func:`~cast` may be required in the body of the ``add_logging`` decorator when "
"returning the ``inner`` function, or the static type checker must be told to ignore "
"the ``return inner``."
msgstr ""
"Es posible que se requiera :func:`~cast` en el cuerpo del decorador ``add_logging`` al "
"retornar la función ``inner``, o se debe indicar al verificador de tipo estático que "
"ignore el ``return inner``."

#: ../Doc/library/typing.rst:1477
msgid ""
"Since ``ParamSpec`` captures both positional and keyword parameters, ``P.args`` and "
"``P.kwargs`` can be used to split a ``ParamSpec`` into its components.  ``P.args`` "
"represents the tuple of positional parameters in a given call and should only be used "
"to annotate ``*args``.  ``P.kwargs`` represents the mapping of keyword parameters to "
"their values in a given call, and should be only be used to annotate ``**kwargs``.  "
"Both attributes require the annotated parameter to be in scope. At runtime, ``P.args`` "
"and ``P.kwargs`` are instances respectively of :class:`ParamSpecArgs` and :class:"
"`ParamSpecKwargs`."
msgstr ""
"Dado que ``ParamSpec`` captura tanto parámetros posicionales como de palabras clave, "
"``P.args`` y ``P.kwargs`` se pueden utilizar para dividir un ``ParamSpec`` en sus "
"componentes. ``P.args`` representa la tupla de parámetros posicionales en una llamada "
"determinada y solo debe usarse para anotar ``*args``. ``P.kwargs`` representa la "
"asignación de parámetros de palabras clave a sus valores en una llamada determinada y "
"solo debe usarse para anotar ``**kwargs``. Ambos atributos requieren que el parámetro "
"anotado esté dentro del alcance. En tiempo de ejecución, ``P.args`` y ``P.kwargs`` son "
"instancias respectivamente de :class:`ParamSpecArgs` y :class:`ParamSpecKwargs`."

#: ../Doc/library/typing.rst:1487
msgid ""
"Parameter specification variables created with ``covariant=True`` or "
"``contravariant=True`` can be used to declare covariant or contravariant generic "
"types.  The ``bound`` argument is also accepted, similar to :class:`TypeVar`.  However "
"the actual semantics of these keywords are yet to be decided."
msgstr ""
"Las variables de especificación de parámetros creadas con ``covariant=True`` o "
"``contravariant=True`` se pueden utilizar para declarar tipos genéricos covariantes o "
"contravariantes. También se acepta el argumento ``bound``, similar a :class:`TypeVar`. "
"Sin embargo, la semántica real de estas palabras clave aún no se ha decidido."

#: ../Doc/library/typing.rst:1496
msgid "Only parameter specification variables defined in global scope can be pickled."
msgstr ""
"Solo las variables de especificación de parámetros definidas en el ámbito global "
"pueden ser serializadas."

#: ../Doc/library/typing.rst:1502
msgid ":class:`Callable` and :class:`Concatenate`."
msgstr ":class:`Callable` y :class:`Concatenate`."

#: ../Doc/library/typing.rst:1507
msgid ""
"Arguments and keyword arguments attributes of a :class:`ParamSpec`. The ``P.args`` "
"attribute of a ``ParamSpec`` is an instance of ``ParamSpecArgs``, and ``P.kwargs`` is "
"an instance of ``ParamSpecKwargs``. They are intended for runtime introspection and "
"have no special meaning to static type checkers."
msgstr ""
"Argumentos y atributos de argumentos de palabras clave de un :class:`ParamSpec`. El "
"atributo ``P.args`` de un ``ParamSpec`` es una instancia de ``ParamSpecArgs`` y ``P."
"kwargs`` es una instancia de ``ParamSpecKwargs``. Están pensados para la introspección "
"en tiempo de ejecución y no tienen un significado especial para los verificadores de "
"tipo estático."

#: ../Doc/library/typing.rst:1512
msgid ""
"Calling :func:`get_origin` on either of these objects will return the original "
"``ParamSpec``::"
msgstr ""
"Llamar a :func:`get_origin` en cualquiera de estos objetos retornará el ``ParamSpec`` "
"original:"

#: ../Doc/library/typing.rst:1524
msgid ""
"``AnyStr`` is a :class:`constrained type variable <TypeVar>` defined as ``AnyStr = "
"TypeVar('AnyStr', str, bytes)``."
msgstr ""
"``AnyStr`` es una :class:`constrained type variable <TypeVar>` definida como ``AnyStr "
"= TypeVar('AnyStr', str, bytes)``."

#: ../Doc/library/typing.rst:1527
msgid ""
"It is meant to be used for functions that may accept any kind of string without "
"allowing different kinds of strings to mix. For example::"
msgstr ""
"Su objetivo es ser usada por funciones que pueden aceptar cualquier tipo de cadena de "
"texto sin permitir mezclar diferentes tipos al mismo tiempo. Por ejemplo::"

#: ../Doc/library/typing.rst:1539
msgid "Base class for protocol classes. Protocol classes are defined like this::"
msgstr "Clase base para clases protocolo. Las clases protocolo se definen así::"

#: ../Doc/library/typing.rst:1545
msgid ""
"Such classes are primarily used with static type checkers that recognize structural "
"subtyping (static duck-typing), for example::"
msgstr ""
"Tales clases son usadas principalmente con validadores estáticos de tipos que detectan "
"subtipado estructural (*duck-typing* estático), por ejemplo::"

#: ../Doc/library/typing.rst:1557
msgid ""
"See :pep:`544` for more details. Protocol classes decorated with :func:"
"`runtime_checkable` (described later) act as simple-minded runtime protocols that "
"check only the presence of given attributes, ignoring their type signatures."
msgstr ""
"Véase :pep:`544` para más detalles. Las clases protocolo decoradas con :func:"
"`runtime_checkable` (descrito más adelante) se comportan como protocolos simplistas en "
"tiempo de ejecución que solo comprueban la presencia de atributos dados, ignorando su "
"firma de tipo."

#: ../Doc/library/typing.rst:1562
msgid "Protocol classes can be generic, for example::"
msgstr "Las clases protocolo pueden ser genéricas, por ejemplo::"

#: ../Doc/library/typing.rst:1572
msgid "Mark a protocol class as a runtime protocol."
msgstr ""
"Marca una clase protocolo como aplicable en tiempo de ejecución (lo convierte en un "
"*runtime protocol*)."

#: ../Doc/library/typing.rst:1574
msgid ""
"Such a protocol can be used with :func:`isinstance` and :func:`issubclass`. This "
"raises :exc:`TypeError` when applied to a non-protocol class.  This allows a simple-"
"minded structural check, very similar to \"one trick ponies\" in :mod:`collections."
"abc` such as :class:`~collections.abc.Iterable`.  For example::"
msgstr ""
"Tal protocolo se puede usar con :func:`isinstance` y :func:`issubclass`. Esto lanzará "
"una excepción :exc:`TypeError` cuando se aplique a una clase que no es un protocolo. "
"Esto permite una comprobación estructural simple, muy semejante a \"one trick ponies\" "
"en :mod:`collections.abc` con :class:`Iterable`. Por ejemplo::"

#: ../Doc/library/typing.rst:1587
msgid ""
":func:`runtime_checkable` will check only the presence of the required methods, not "
"their type signatures. For example, :class:`ssl.SSLObject` is a class, therefore it "
"passes an :func:`issubclass` check against :data:`Callable`.  However, the :meth:`ssl."
"SSLObject.__init__` method exists only to raise a :exc:`TypeError` with a more "
"informative message, therefore making it impossible to call (instantiate) :class:`ssl."
"SSLObject`."
msgstr ""
":func:`runtime_checkable` verificará solo la presencia de los métodos requeridos, no "
"sus firmas de tipo. Por ejemplo, :class:`ssl.SSLObject` es una clase, por lo que pasa "
"una verificación :func:`issubclass` contra :data:`Callable`. Sin embargo, el método :"
"meth:`ssl.SSLObject.__init__` existe solo para lanzar un :exc:`TypeError` con un "
"mensaje más informativo, por lo que es imposible llamar (instanciar) :class:`ssl."
"SSLObject`."

#: ../Doc/library/typing.rst:1598
msgid "Other special directives"
msgstr "Otras directivas especiales"

#: ../Doc/library/typing.rst:1600
msgid "These are not used in annotations. They are building blocks for declaring types."
msgstr ""
"Estos no son utilizados en anotaciones. Son utilizados como bloques para crear tipos "
"genéricos."

#: ../Doc/library/typing.rst:1604
msgid "Typed version of :func:`collections.namedtuple`."
msgstr "Versión para anotación de tipos de :func:`collections.namedtuple`."

#: ../Doc/library/typing.rst:1612
msgid "This is equivalent to::"
msgstr "Esto es equivalente a::"

#: ../Doc/library/typing.rst:1616
msgid "To give a field a default value, you can assign to it in the class body::"
msgstr ""
"Para proporcionar a un campo un valor por defecto se puede asignar en el cuerpo de la "
"clase::"

#: ../Doc/library/typing.rst:1625
msgid "Fields with a default value must come after any fields without a default."
msgstr ""
"Los campos con un valor por defecto deben ir después de los campos sin valor por "
"defecto."

#: ../Doc/library/typing.rst:1627
msgid ""
"The resulting class has an extra attribute ``__annotations__`` giving a dict that maps "
"the field names to the field types.  (The field names are in the ``_fields`` attribute "
"and the default values are in the ``_field_defaults`` attribute, both of which are "
"part of the :func:`~collections.namedtuple` API.)"
msgstr ""
"La clase resultante tiene un atributo extra ``__annotations__`` que proporciona un "
"diccionario que mapea el nombre de los campos con sus respectivos tipos. (Los nombres "
"de los campos están en el atributo ``_fields`` y sus valores por defecto en el "
"atributo ``_field_defaults``, ambos parte de la API :func:`~collections.namedtuple`.)"

#: ../Doc/library/typing.rst:1633
msgid "``NamedTuple`` subclasses can also have docstrings and methods::"
msgstr "Las subclases de ``NamedTuple`` también pueden tener *docstrings* y métodos::"

#: ../Doc/library/typing.rst:1643
msgid "``NamedTuple`` subclasses can be generic::"
msgstr "Las subclases de ``NamedTuple`` pueden ser genéricas::"

#: ../Doc/library/typing.rst:1649
msgid "Backward-compatible usage::"
msgstr "Uso retrocompatible::"

#: ../Doc/library/typing.rst:1653
msgid "Added support for :pep:`526` variable annotation syntax."
msgstr ""
"Soporte añadido para la sintaxis de anotación de variables propuesto en :pep:`526`."

#: ../Doc/library/typing.rst:1656
msgid "Added support for default values, methods, and docstrings."
msgstr "Soporte añadido para valores por defecto, métodos y *docstrings*."

#: ../Doc/library/typing.rst:1659
msgid ""
"The ``_field_types`` and ``__annotations__`` attributes are now regular dictionaries "
"instead of instances of ``OrderedDict``."
msgstr ""
"Los atributos ``_field_types`` y ``__annotations__`` son simples diccionarios en vez "
"de instancias de ``OrderedDict``."

#: ../Doc/library/typing.rst:1663
msgid ""
"Removed the ``_field_types`` attribute in favor of the more standard "
"``__annotations__`` attribute which has the same information."
msgstr ""
"Se remueve el atributo ``_field_types`` en favor del atributo más estándar "
"``__annotations__`` que tiene la misma información."

#: ../Doc/library/typing.rst:1667
msgid "Added support for generic namedtuples."
msgstr "Se agrega soporte para *namedtuples* genéricas."

#: ../Doc/library/typing.rst:1672
msgid ""
"A helper class to indicate a distinct type to a typechecker, see :ref:`distinct`. At "
"runtime it returns an object that returns its argument when called. Usage::"
msgstr ""
"Una clase auxiliar para indicar un tipo diferenciado a un comprobador de tipos, "
"consulte :ref:`distinct`. En tiempo de ejecución, retorna un objeto que retorna su "
"argumento cuando se llama. Uso::"

#: ../Doc/library/typing.rst:1682
msgid "``NewType`` is now a class rather than a function."
msgstr "``NewType`` es ahora una clase en lugar de una función."

#: ../Doc/library/typing.rst:1687
msgid ""
"Special construct to add type hints to a dictionary. At runtime it is a plain :class:"
"`dict`."
msgstr ""
"Es una construcción especial para añadir indicadores de tipo a un diccionario. En "
"tiempo de ejecución es un :class:`dict` simple."

# sinonimo para imposicion/imponer
#: ../Doc/library/typing.rst:1690
msgid ""
"``TypedDict`` declares a dictionary type that expects all of its instances to have a "
"certain set of keys, where each key is associated with a value of a consistent type. "
"This expectation is not checked at runtime but is only enforced by type checkers. "
"Usage::"
msgstr ""
"``TypedDict`` crea un tipo de diccionario que espera que todas sus instancias tenga un "
"cierto conjunto de claves, donde cada clave está asociada con un valor de un tipo "
"determinado. Esta exigencia no se comprueba en tiempo de ejecución y solo es aplicada "
"por validadores de tipo. Uso::"

#: ../Doc/library/typing.rst:1706
msgid ""
"To allow using this feature with older versions of Python that do not support :pep:"
"`526`, ``TypedDict`` supports two additional equivalent syntactic forms:"
msgstr ""
"Para permitir el uso de esta caracterísitca con versiones más antiguas de Python que "
"no tienen soporte para :pep:`526`, ``TypedDict`` soporta adicionalmente dos formas "
"sintácticas equivalentes:"

#: ../Doc/library/typing.rst:1710
msgid "Using a literal :class:`dict` as the second argument::"
msgstr "El uso de un :class:`dict` literal como segundo argumento::"

#: ../Doc/library/typing.rst:1714
msgid "Using keyword arguments::"
msgstr "El uso de argumentos nombrados::"

#: ../Doc/library/typing.rst:1721
msgid ""
"The keyword-argument syntax is deprecated in 3.11 and will be removed in 3.13. It may "
"also be unsupported by static type checkers."
msgstr ""
"La sintaxis de argumentos nombrados está obsoleta desde la versión 3.11 y será "
"removida en la versión 3.13. Además, podría no estár soportada por los validadores "
"estáticos de tipo."

#: ../Doc/library/typing.rst:1722
msgid ""
"The functional syntax should also be used when any of the keys are not valid :ref:"
"`identifiers <identifiers>`, for example because they are keywords or contain hyphens. "
"Example::"
msgstr ""
"También es preferible el uso de la sintaxis funcional cuando cualquiera de las llaves "
"no sean :ref:`identifiers<identifiers>` válidos, por ejemplo porque son palabras clave "
"o contienen guiones. Ejemplo::"

#: ../Doc/library/typing.rst:1734
msgid ""
"By default, all keys must be present in a ``TypedDict``. It is possible to mark "
"individual keys as non-required using :data:`NotRequired`::"
msgstr ""
"De forma predeterminada, todas las llaves deben estar presentes en un ``TypedDict``. "
"Es posible marcar llaves individuales como *no requeridas* utilizando :data:"
"`NotRequired`::"

#: ../Doc/library/typing.rst:1745
msgid "This means that a ``Point2D`` ``TypedDict`` can have the ``label`` key omitted."
msgstr ""
"Esto significa que en un ``TypedDict`` que sea una instancia de ``Point2D``, será "
"posible omitir la llave ``label``."

#: ../Doc/library/typing.rst:1748
msgid ""
"It is also possible to mark all keys as non-required by default by specifying a "
"totality of ``False``::"
msgstr ""
"Además, es posible marcar todas las llaves como no-requeridas por defecto, al "
"especificar un valor de ``False`` en el argumento *total*::"

#: ../Doc/library/typing.rst:1758
msgid ""
"This means that a ``Point2D`` ``TypedDict`` can have any of the keys omitted. A type "
"checker is only expected to support a literal ``False`` or ``True`` as the value of "
"the ``total`` argument. ``True`` is the default, and makes all items defined in the "
"class body required."
msgstr ""
"Esto significa que un ``TypedDict`` ``Point2D`` puede tener cualquiera de las llaves "
"omitidas. Solo se espera que un verificador de tipo admita un ``False`` literal o "
"``True`` como valor del argumento ``total``. ``True`` es el predeterminado y hace que "
"todos los elementos definidos en el cuerpo de la clase sean obligatorios."

#: ../Doc/library/typing.rst:1763
msgid ""
"Individual keys of a ``total=False`` ``TypedDict`` can be marked as required using :"
"data:`Required`::"
msgstr ""
"Las llaves individuales de un ``TypedDict`` ``total=False`` pueden ser marcadas como "
"requeridas utilizando :data:`Required`::"

#: ../Doc/library/typing.rst:1778
msgid ""
"It is possible for a ``TypedDict`` type to inherit from one or more other "
"``TypedDict`` types using the class-based syntax. Usage::"
msgstr ""
"Es posible que un tipo ``TypedDict`` herede de uno o más tipos ``TypedDict`` usando la "
"sintaxis de clase. Uso::"

#: ../Doc/library/typing.rst:1785
msgid ""
"``Point3D`` has three items: ``x``, ``y`` and ``z``. It is equivalent to this "
"definition::"
msgstr ""
"``Point3D`` tiene tres elementos: ``x``, ``y`` y ``z``. Lo que es equivalente a la "
"siguiente definición::"

#: ../Doc/library/typing.rst:1793
msgid ""
"A ``TypedDict`` cannot inherit from a non-\\ ``TypedDict`` class, except for :class:"
"`Generic`. For example::"
msgstr ""
"Un ``TypedDict`` no puede heredar de una clase que no sea una subclase de "
"``TypedDict``, exceptuando :class:`Generic`. Por ejemplo::"

#: ../Doc/library/typing.rst:1811
msgid "A ``TypedDict`` can be generic::"
msgstr "Un ``TypedDict`` puede ser genérico::"

#: ../Doc/library/typing.rst:1817
msgid ""
"A ``TypedDict`` can be introspected via annotations dicts (see :ref:`annotations-"
"howto` for more information on annotations best practices), :attr:`__total__`, :attr:"
"`__required_keys__`, and :attr:`__optional_keys__`."
msgstr ""
"Es posible introspectar un ``TypedDict`` a través de diccionarios de anotaciones "
"(véase\n"
" :ref:`annotations-howto` para más información acerca de mejores prácticas de "
"anotaciones), :attr:`__total__`, :attr:`__required_keys__`, y :attr:"
"`__optional_keys__`."

#: ../Doc/library/typing.rst:1823
msgid "``Point2D.__total__`` gives the value of the ``total`` argument. Example::"
msgstr "``Point2D.__total__`` entrega el valor del argumento ``total``. Ejemplo::"

#: ../Doc/library/typing.rst:1843
msgid ""
"``Point2D.__required_keys__`` and ``Point2D.__optional_keys__`` return :class:"
"`frozenset` objects containing required and non-required keys, respectively."
msgstr ""
"``Point2D.__required_keys__`` y ``Point2D.__optional_keys__`` retornan objetos de la "
"clase :class:`frozenset`, que contienen las llaves requeridas y no requeridas, "
"respectivamente."

#: ../Doc/library/typing.rst:1846
msgid ""
"Keys marked with :data:`Required` will always appear in ``__required_keys__`` and keys "
"marked with :data:`NotRequired` will always appear in ``__optional_keys__``."
msgstr ""
"Las llaves marcadas con :data:`Required` siempre aparecerán en ``__required_keys__`` y "
"las llaves marcadas con :data:`NotRequired` siempre aparecerán en "
"``__optional_keys__``."

#: ../Doc/library/typing.rst:1849
msgid ""
"For backwards compatibility with Python 3.10 and below, it is also possible to use "
"inheritance to declare both required and non-required keys in the same ``TypedDict`` . "
"This is done by declaring a ``TypedDict`` with one value for the ``total`` argument "
"and then inheriting from it in another ``TypedDict`` with a different value for "
"``total``::"
msgstr ""
"Para retrocompatibilidad con Python 3.10 y versiones más antiguas, es posible utilizar "
"herencia para declarar tanto las llaves requeridas como las no requeridas en el mismo "
"``TypedDict``. Ésto se logra declarando un ``TypedDict`` con un valor para el "
"argumento ``total`` y luego heredando de él en otro ``TypedDict`` con un valor "
"distinto para ``total``::"

#: ../Doc/library/typing.rst:1870
msgid "See :pep:`589` for more examples and detailed rules of using ``TypedDict``."
msgstr "Véase :pep:`589` para más ejemplos y reglas detalladas del uso de ``TypedDict``."

#: ../Doc/library/typing.rst:1874
msgid ""
"Added support for marking individual keys as :data:`Required` or :data:`NotRequired`. "
"See :pep:`655`."
msgstr ""
"Se agrega soporte para marcar llaves individuales como :data:`Required` o :data:"
"`NotRequired`. Véase :pep:`655`."

#: ../Doc/library/typing.rst:1878
msgid "Added support for generic ``TypedDict``\\ s."
msgstr "Se agrega soporte para ``TypedDict``s genéricos."

#: ../Doc/library/typing.rst:1882
msgid "Generic concrete collections"
msgstr "Colecciones genéricas concretas"

#: ../Doc/library/typing.rst:1885
msgid "Corresponding to built-in types"
msgstr "Correspondientes a tipos integrados"

#: ../Doc/library/typing.rst:1889
msgid ""
"A generic version of :class:`dict`. Useful for annotating return types. To annotate "
"arguments it is preferred to use an abstract collection type such as :class:`Mapping`."
msgstr ""
"Una versión genérica de :class:`dict`. Útil para anotar tipos de retorno. Para anotar "
"argumentos es preferible usar un tipo abstracto de colección como :class:`Mapping`."

#: ../Doc/library/typing.rst:1893
msgid "This type can be used as follows::"
msgstr "Este tipo se puede usar de la siguiente manera::"

#: ../Doc/library/typing.rst:1898
msgid ""
":class:`builtins.dict <dict>` now supports subscripting (``[]``). See :pep:`585` and :"
"ref:`types-genericalias`."
msgstr ""
":class:`builtins.dict <dict>` ahora soporta subíndices (``[]``). Véase :pep:`585` y :"
"ref:`types-genericalias`."

#: ../Doc/library/typing.rst:1904
msgid ""
"Generic version of :class:`list`. Useful for annotating return types. To annotate "
"arguments it is preferred to use an abstract collection type such as :class:`Sequence` "
"or :class:`Iterable`."
msgstr ""
"Versión genérica de :class:`list`. Útil para anotar tipos de retorno. Para anotar "
"argumentos es preferible usar un tipo abstracto de colección como  :class:`Sequence` "
"o :class:`Iterable`."

#: ../Doc/library/typing.rst:1909
msgid "This type may be used as follows::"
msgstr "Este tipo se puede usar del siguiente modo::"

#: ../Doc/library/typing.rst:1919
msgid ""
":class:`builtins.list <list>` now supports subscripting (``[]``). See :pep:`585` and :"
"ref:`types-genericalias`."
msgstr ""
":class:`builtins.list <list>` ahora soporta subíndices (``[]``). Véase :pep:`585` y :"
"ref:`types-genericalias`."

#: ../Doc/library/typing.rst:1925
msgid ""
"A generic version of :class:`builtins.set <set>`. Useful for annotating return types. "
"To annotate arguments it is preferred to use an abstract collection type such as :"
"class:`AbstractSet`."
msgstr ""
"Una versión genérica de :class:`builtins.set <set>`. Útil para anotar tipos de "
"retornos. Para anotar argumentos es preferible usar un tipo abstracto de colección "
"como :class:`AbstractSet`."

#: ../Doc/library/typing.rst:1929
msgid ""
":class:`builtins.set <set>` now supports subscripting (``[]``). See :pep:`585` and :"
"ref:`types-genericalias`."
msgstr ""
":class:`builtins.set <set>` ahora soporta subíndices (``[]``). Véase :pep:`585` y :ref:"
"`types-genericalias`."

#: ../Doc/library/typing.rst:1935
msgid "A generic version of :class:`builtins.frozenset <frozenset>`."
msgstr "Una versión genérica de :class:`builtins.frozenset <frozenset>`."

#: ../Doc/library/typing.rst:1937
msgid ""
":class:`builtins.frozenset <frozenset>` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""
":class:`builtins.frozenset <frozenset>` ahora soporta subíndices (``[]``). Véase :pep:"
"`585` y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:1942
msgid ":data:`Tuple` is a special form."
msgstr ":data:`Tuple` es una forma especial."

#: ../Doc/library/typing.rst:1945
msgid "Corresponding to types in :mod:`collections`"
msgstr "Correspondiente a tipos en :mod:`collections`"

#: ../Doc/library/typing.rst:1949
msgid "A generic version of :class:`collections.defaultdict`."
msgstr "Una versión genérica de :class:`collections.defaultdict`."

#: ../Doc/library/typing.rst:1953
msgid ""
":class:`collections.defaultdict` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.defaultdict` ahora soporta subíndices (``[]``). Véase :pep:`585` "
"y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:1959
msgid "A generic version of :class:`collections.OrderedDict`."
msgstr "Una versión genérica de :class:`collections.OrderedDict`."

#: ../Doc/library/typing.rst:1963
msgid ""
":class:`collections.OrderedDict` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.OrderedDict` ahora soporta subíndices (``[]``). Véase :pep:`585` "
"y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:1969
msgid "A generic version of :class:`collections.ChainMap`."
msgstr "Una versión genérica de :class:`collections.ChainMap`."

#: ../Doc/library/typing.rst:1974
msgid ""
":class:`collections.ChainMap` now supports subscripting (``[]``). See :pep:`585` and :"
"ref:`types-genericalias`."
msgstr ""
":class:`collections.ChainMap` ahora soporta subíndices (``[]``). Véase :pep:`585` y :"
"ref:`types-genericalias`."

#: ../Doc/library/typing.rst:1980
msgid "A generic version of :class:`collections.Counter`."
msgstr "Una versión genérica de :class:`collections.Counter`."

#: ../Doc/library/typing.rst:1985
msgid ""
":class:`collections.Counter` now supports subscripting (``[]``). See :pep:`585` and :"
"ref:`types-genericalias`."
msgstr ""
":class:`collections.Counter` ahora soporta subíndices (``[]``)`. Véase :pep:`585` y :"
"ref:`types-genericalias`."

#: ../Doc/library/typing.rst:1991
msgid "A generic version of :class:`collections.deque`."
msgstr "Una versión genérica de :class:`collections.deque`."

#: ../Doc/library/typing.rst:1996
msgid ""
":class:`collections.deque` now supports subscripting (``[]``). See :pep:`585` and :ref:"
"`types-genericalias`."
msgstr ""
":class:`collections.deque` ahora soporta subíndices (``[]``). Véase :pep:`585` y :ref:"
"`types-genericalias`."

#: ../Doc/library/typing.rst:2001
msgid "Other concrete types"
msgstr "Otros tipos concretos"

#: ../Doc/library/typing.rst:2007
msgid ""
"Generic type ``IO[AnyStr]`` and its subclasses ``TextIO(IO[str])`` and "
"``BinaryIO(IO[bytes])`` represent the types of I/O streams such as returned by :func:"
"`open`."
msgstr ""
"El tipo genérico ``IO[AnyStr]`` y sus subclases ``TextIO(IO[str])`` y "
"``BinaryIO(IO[bytes])`` representan los tipos de flujos de E/S como los retornados "
"por :func:`open`."

#: ../Doc/library/typing.rst:2014
msgid ""
"The ``typing.io`` namespace is deprecated and will be removed. These types should be "
"directly imported from ``typing`` instead."
msgstr ""
"El espacio de nombres ``typing.io`` está obsoleto y se eliminará. En su lugar, estos "
"tipos deben importarse directamente desde ``typing``."

#: ../Doc/library/typing.rst:2019
msgid ""
"These type aliases correspond to the return types from :func:`re.compile` and :func:"
"`re.match`.  These types (and the corresponding functions) are generic in ``AnyStr`` "
"and can be made specific by writing ``Pattern[str]``, ``Pattern[bytes]``, "
"``Match[str]``, or ``Match[bytes]``."
msgstr ""
"Estos alias de tipo corresponden a los tipos retornados de :func:`re.compile` y :func:"
"`re.match`. Estos tipos (y las funciones correspondientes) son genéricos en ``AnyStr`` "
"y se pueden hacer específicos escribiendo ``Pattern[str]``, ``Pattern[bytes]``, "
"``Match[str]`` o ``Match[bytes]``."

#: ../Doc/library/typing.rst:2029
msgid ""
"The ``typing.re`` namespace is deprecated and will be removed. These types should be "
"directly imported from ``typing`` instead."
msgstr ""
"El espacio de nombres ``typing.re`` está obsoleto y se eliminará. En su lugar, estos "
"tipos deben importarse directamente desde ``typing``."

#: ../Doc/library/typing.rst:2030
msgid ""
"Classes ``Pattern`` and ``Match`` from :mod:`re` now support ``[]``. See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
"Las clases ``Pattern`` y ``Match`` de :mod:`re` ahora soportan ``[]``. Véase :pep:"
"`585` y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2036
msgid ""
"``Text`` is an alias for ``str``. It is provided to supply a forward compatible path "
"for Python 2 code: in Python 2, ``Text`` is an alias for ``unicode``."
msgstr ""
"``Text`` es un alias para ``str``. Ésta disponible para proporcionar un mecanismo "
"compatible hacia delante para código en Python 2: en Python 2, ``Text`` es un alias de "
"``unicode``."

#: ../Doc/library/typing.rst:2040
msgid ""
"Use ``Text`` to indicate that a value must contain a unicode string in a manner that "
"is compatible with both Python 2 and Python 3::"
msgstr ""
"Úsese ``Text`` para indicar que un valor debe contener una cadena de texto Unicode de "
"manera que sea compatible con Python 2 y Python 3::"

#: ../Doc/library/typing.rst:2048
msgid ""
"Python 2 is no longer supported, and most type checkers also no longer support type "
"checking Python 2 code. Removal of the alias is not currently planned, but users are "
"encouraged to use :class:`str` instead of ``Text`` wherever possible."
msgstr ""
"Ya no se soporta Python 2, y la mayoría de los validadores de tipo tampoco dan soporte "
"a la validación de tipos en código escrito en Python 2. Actualmente no está "
"planificado remover el alias, pero se alenta a los usuarios a utilizar :class:`str` en "
"vez de ``Text`` allí donde sea posible."

#: ../Doc/library/typing.rst:2055
msgid "Abstract Base Classes"
msgstr "Clase base abstracta para tipos genéricos"

#: ../Doc/library/typing.rst:2058
msgid "Corresponding to collections in :mod:`collections.abc`"
msgstr "Correspondientes a las colecciones en :mod:`collections.abc`"

#: ../Doc/library/typing.rst:2062
msgid "A generic version of :class:`collections.abc.Set`."
msgstr "Una versión genérica de :class:`collections.abc.Set`."

#: ../Doc/library/typing.rst:2064
msgid ""
":class:`collections.abc.Set` now supports subscripting (``[]``). See :pep:`585` and :"
"ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Set` ahora soporta subíndices (``[]``). Véase :pep:`585` y :"
"ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2070
msgid "A generic version of :class:`collections.abc.ByteString`."
msgstr "Una versión genérica de :class:`collections.abc.ByteString`."

#: ../Doc/library/typing.rst:2072
msgid ""
"This type represents the types :class:`bytes`, :class:`bytearray`, and :class:"
"`memoryview` of byte sequences."
msgstr ""
"Este tipo representa a los tipos :class:`bytes`, :class:`bytearray`, y :class:"
"`memoryview` de secuencias de bytes."

#: ../Doc/library/typing.rst:2075
msgid ""
"As a shorthand for this type, :class:`bytes` can be used to annotate arguments of any "
"of the types mentioned above."
msgstr ""
"Como abreviación para este tipo, :class:`bytes` se puede usar para anotar argumentos "
"de cualquiera de los tipos mencionados arriba."

#: ../Doc/library/typing.rst:2078
msgid ""
":class:`collections.abc.ByteString` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.ByteString` ahora soporta la sintaxis de subíndice (``[]``). "
"Véase :pep:`585` y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2084
msgid "A generic version of :class:`collections.abc.Collection`"
msgstr "Una versión genérica de :class:`collections.abc.Collection`"

#: ../Doc/library/typing.rst:2088
msgid ""
":class:`collections.abc.Collection` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Collection` ahora soporta la sintaxis de subíndice (``[]``). "
"Véase :pep:`585` y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2094
msgid "A generic version of :class:`collections.abc.Container`."
msgstr "Una versión genérica de :class:`collections.abc.Container`."

#: ../Doc/library/typing.rst:2096
msgid ""
":class:`collections.abc.Container` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Container` ahora soporta subíndices (``[]``). Véase :pep:`585` "
"y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2102
msgid "A generic version of :class:`collections.abc.ItemsView`."
msgstr "Una versión genérica de :class:`collections.abc.ItemsView`."

#: ../Doc/library/typing.rst:2104
msgid ""
":class:`collections.abc.ItemsView` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.ItemsView` ahora soporta subíndices (``[]``). Véase :pep:`585` "
"y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2110
msgid "A generic version of :class:`collections.abc.KeysView`."
msgstr "Una versión genérica de :class:`collections.abc.KeysView`."

#: ../Doc/library/typing.rst:2112
msgid ""
":class:`collections.abc.KeysView` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.KeysView` ahora soporta subíndices (``[]``). Véase :pep:`585` "
"y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2118
msgid ""
"A generic version of :class:`collections.abc.Mapping`. This type can be used as "
"follows::"
msgstr ""
"Una versión genérica de :class:`collections.abc.Mapping`. Este tipo se puede usar de "
"la siguiente manera::"

#: ../Doc/library/typing.rst:2124
msgid ""
":class:`collections.abc.Mapping` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Mapping` ahora soporta subíndices (``[]``). Véase :pep:`585` "
"y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2130
msgid "A generic version of :class:`collections.abc.MappingView`."
msgstr "Una versión genérica de :class:`collections.abc.MappingView`."

#: ../Doc/library/typing.rst:2132
msgid ""
":class:`collections.abc.MappingView` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.MappingView` ahora soporta subíndices (``[]``). Véase :pep:"
"`585` y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2138
msgid "A generic version of :class:`collections.abc.MutableMapping`."
msgstr "Una versión genérica de :class:`collections.abc.MutableMapping`."

#: ../Doc/library/typing.rst:2140
msgid ""
":class:`collections.abc.MutableMapping` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.MutableMapping` ahora soporta subíndices (``[]``). Véase :pep:"
"`585` y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2147
msgid "A generic version of :class:`collections.abc.MutableSequence`."
msgstr "Una versión genérica de :class:`collections.abc.MutableSequence`."

#: ../Doc/library/typing.rst:2149
msgid ""
":class:`collections.abc.MutableSequence` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.MutableSequence` ahora soporta subíndices (``[]``). Véase :pep:"
"`585` y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2156
msgid "A generic version of :class:`collections.abc.MutableSet`."
msgstr "Una versión genérica de :class:`collections.abc.MutableSet`."

#: ../Doc/library/typing.rst:2158
msgid ""
":class:`collections.abc.MutableSet` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.MutableSet` ahora soporta subíndices (``[]``). Véase :pep:"
"`585` y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2164
msgid "A generic version of :class:`collections.abc.Sequence`."
msgstr "Una versión genérica de :class:`collections.abc.Sequence`."

#: ../Doc/library/typing.rst:2166
msgid ""
":class:`collections.abc.Sequence` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Sequence` ahora soporta subíndices (``[]``). Véase :pep:`585` "
"y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2172
msgid "A generic version of :class:`collections.abc.ValuesView`."
msgstr "Una versión genérica de :class:`collections.abc.ValuesView`."

#: ../Doc/library/typing.rst:2174
msgid ""
":class:`collections.abc.ValuesView` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.ValuesView` ahora soporta subíndices (``[]``). Véase :pep:"
"`585` y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2179
msgid "Corresponding to other types in :mod:`collections.abc`"
msgstr "Correspondiente a otros tipos en :mod:`collections.abc`"

#: ../Doc/library/typing.rst:2183
msgid "A generic version of :class:`collections.abc.Iterable`."
msgstr "Una versión genérica de :class:`collections.abc.Iterable`."

#: ../Doc/library/typing.rst:2185
msgid ""
":class:`collections.abc.Iterable` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Iterable` ahora soporta subíndices (``[]``). Véase :pep:`585` "
"y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2191
msgid "A generic version of :class:`collections.abc.Iterator`."
msgstr "Una versión genérica de :class:`collections.abc.Iterator`."

#: ../Doc/library/typing.rst:2193
msgid ""
":class:`collections.abc.Iterator` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Iterator` ahora soporta subíndices (``[]``). Véase :pep:`585` "
"y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2199
msgid ""
"A generator can be annotated by the generic type ``Generator[YieldType, SendType, "
"ReturnType]``. For example::"
msgstr ""
"Un generador puede ser anotado con el tipo genérico ``Generator[YieldType, SendType, "
"ReturnType]``. Por ejemplo::"

#: ../Doc/library/typing.rst:2208
msgid ""
"Note that unlike many other generics in the typing module, the ``SendType`` of :class:"
"`Generator` behaves contravariantly, not covariantly or invariantly."
msgstr ""
"Nótese que en contraste con muchos otros genéricos en el módulo *typing*, el "
"``SendType`` de :class:`Generator` se comporta como contravariante, no covariante ni "
"invariante."

#: ../Doc/library/typing.rst:2212
msgid ""
"If your generator will only yield values, set the ``SendType`` and ``ReturnType`` to "
"``None``::"
msgstr ""
"Si tu generador solo retornará valores con *yield*, establece ``SendType`` y "
"``ReturnType`` como ``None``::"

#: ../Doc/library/typing.rst:2220
msgid ""
"Alternatively, annotate your generator as having a return type of either "
"``Iterable[YieldType]`` or ``Iterator[YieldType]``::"
msgstr ""
"Opcionalmente, anota tu generador con un tipo de retorno de ``Iterable[YieldType]`` o "
"``Iterator[YieldType]``::"

#: ../Doc/library/typing.rst:2228
msgid ""
":class:`collections.abc.Generator` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Generator` ahora soporta subíndices (``[]``). Véase :pep:`585` "
"y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2234
msgid "An alias to :class:`collections.abc.Hashable`."
msgstr "Un alias de :class:`collections.abc.Hashable`."

#: ../Doc/library/typing.rst:2238
msgid "A generic version of :class:`collections.abc.Reversible`."
msgstr "Una versión genérica de :class:`collections.abc.Reversible`."

#: ../Doc/library/typing.rst:2240
msgid ""
":class:`collections.abc.Reversible` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Reversible` ahora soporta subíndices (``[]``). Véase :pep:"
"`585` y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2246
msgid "An alias to :class:`collections.abc.Sized`."
msgstr "Un alias de :class:`collections.abc.Sized`."

#: ../Doc/library/typing.rst:2249
msgid "Asynchronous programming"
msgstr "Programación asíncrona"

#: ../Doc/library/typing.rst:2253
msgid ""
"A generic version of :class:`collections.abc.Coroutine`. The variance and order of "
"type variables correspond to those of :class:`Generator`, for example::"
msgstr ""
"Una versión genérica de :class:`collections.abc.Coroutine`.y orden de las variables de "
"tipo se corresponde con aquellas de :class:`Generator`, por ejemplo::"

#: ../Doc/library/typing.rst:2265
msgid ""
":class:`collections.abc.Coroutine` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Coroutine` ahora soporta subíndices (``[]``). Véase :pep:`585` "
"y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2271
msgid ""
"An async generator can be annotated by the generic type ``AsyncGenerator[YieldType, "
"SendType]``. For example::"
msgstr ""
"Un generador asíncrono se puede anotar con el tipo genérico "
"``AsyncGenerator[YieldType, SendType]``. Por ejemplo::"

#: ../Doc/library/typing.rst:2280
msgid ""
"Unlike normal generators, async generators cannot return a value, so there is no "
"``ReturnType`` type parameter. As with :class:`Generator`, the ``SendType`` behaves "
"contravariantly."
msgstr ""
"A diferencia de los generadores normales, los generadores asíncronos no pueden "
"retornar un valor, por lo que no hay un parámetro de tipo ``ReturnType``. Igual que :"
"class:`Generator`, ``SendType`` se comporta como contravariante."

#: ../Doc/library/typing.rst:2284
msgid "If your generator will only yield values, set the ``SendType`` to ``None``::"
msgstr ""
"Si tu generador solo retornará valores con *yield*,  establece el ``SendType`` como "
"``None``::"

#: ../Doc/library/typing.rst:2292
msgid ""
"Alternatively, annotate your generator as having a return type of either "
"``AsyncIterable[YieldType]`` or ``AsyncIterator[YieldType]``::"
msgstr ""
"Opcionalmente, anota el generador con un tipo de retorno ``AsyncIterable[YieldType]`` "
"o ``AsyncIterator[YieldType]``::"

#: ../Doc/library/typing.rst:2302
msgid ""
":class:`collections.abc.AsyncGenerator` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.AsycGenerator` ahora soporta subíndices (``[]``). Véase :pep:"
"`585` y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2309
msgid "A generic version of :class:`collections.abc.AsyncIterable`."
msgstr "Una versión genérica de :class:`collections.abc.AsyncIterable`."

#: ../Doc/library/typing.rst:2313
msgid ""
":class:`collections.abc.AsyncIterable` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.AsyncIterable` ahora soporta subíndices (``[]``). Véase :pep:"
"`585` y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2319
msgid "A generic version of :class:`collections.abc.AsyncIterator`."
msgstr "Una versión genérica de :class:`collections.abc.AsyncIterator`."

#: ../Doc/library/typing.rst:2323
msgid ""
":class:`collections.abc.AsyncIterator` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.AsyncIterator` ahora soporta subíndices (``[]``). Véase :pep:"
"`585` y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2329
msgid "A generic version of :class:`collections.abc.Awaitable`."
msgstr "Una versión genérica de :class:`collections.abc.Awaitable`."

#: ../Doc/library/typing.rst:2333
msgid ""
":class:`collections.abc.Awaitable` now supports subscripting (``[]``). See :pep:`585` "
"and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Awaitable` ahora soporta subíndices (``[]``). Véase :pep:`585` "
"y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2339
msgid "Context manager types"
msgstr "Tipos del administrador de contextos"

#: ../Doc/library/typing.rst:2343
msgid "A generic version of :class:`contextlib.AbstractContextManager`."
msgstr "Una versión genérica de :class:`contextlib.AbstractContextManager`."

#: ../Doc/library/typing.rst:2348
msgid ""
":class:`contextlib.AbstractContextManager` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`contextlib.AbstractContextManager` ahora soporta subíndices (``[]``). Véase :"
"pep:`585` y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2355
msgid "A generic version of :class:`contextlib.AbstractAsyncContextManager`."
msgstr "Una versión genérica de :class:`contextlib.AbstractAsyncContextManager`."

#: ../Doc/library/typing.rst:2360
msgid ""
":class:`contextlib.AbstractAsyncContextManager` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`contextlib.AbstractAsyncContextManager` ahora soporta subíndices (``[]``). "
"Véase :pep:`585` y :ref:`types-genericalias`."

#: ../Doc/library/typing.rst:2366
msgid "Protocols"
msgstr "Protocolos"

#: ../Doc/library/typing.rst:2368
msgid "These protocols are decorated with :func:`runtime_checkable`."
msgstr "Estos protocolos se decoran con :func:`runtime_checkable`."

#: ../Doc/library/typing.rst:2372
msgid "An ABC with one abstract method ``__abs__`` that is covariant in its return type."
msgstr ""
"Una ABC con un método abstracto ``__abs__`` que es covariante en su tipo retornado."

#: ../Doc/library/typing.rst:2377
msgid "An ABC with one abstract method ``__bytes__``."
msgstr "Una ABC con un método abstracto ``__bytes__``."

#: ../Doc/library/typing.rst:2381
msgid "An ABC with one abstract method ``__complex__``."
msgstr "Una ABC con un método abstracto ``__complex__``."

#: ../Doc/library/typing.rst:2385
msgid "An ABC with one abstract method ``__float__``."
msgstr "Una ABC con un método abstracto ``__float__``."

#: ../Doc/library/typing.rst:2389
msgid "An ABC with one abstract method ``__index__``."
msgstr "Una ABC con un método abstracto ``__index__``."

#: ../Doc/library/typing.rst:2395
msgid "An ABC with one abstract method ``__int__``."
msgstr "Una ABC con un método abstracto ``__int__``."

#: ../Doc/library/typing.rst:2399
msgid ""
"An ABC with one abstract method ``__round__`` that is covariant in its return type."
msgstr ""
"Una ABC con un método abstracto ``__round__`` que es covariantes en su tipo retornado."

#: ../Doc/library/typing.rst:2403
msgid "Functions and decorators"
msgstr "Funciones y decoradores"

#: ../Doc/library/typing.rst:2407
msgid "Cast a value to a type."
msgstr "Convertir un valor a un tipo."

# el "esto" del final queda muy colgado
#: ../Doc/library/typing.rst:2409
msgid ""
"This returns the value unchanged.  To the type checker this signals that the return "
"value has the designated type, but at runtime we intentionally don't check anything "
"(we want this to be as fast as possible)."
msgstr ""
"Esto retorna el valor sin modificar. Para el validador de tipos esto indica que el "
"valor de retorno tiene el tipo señalado pero, de manera intencionada, no se comprobará "
"en tiempo de ejecución (para maximizar la velocidad)."

#: ../Doc/library/typing.rst:2416
msgid "Ask a static type checker to confirm that *val* has an inferred type of *typ*."
msgstr ""
"Solicitar a un validador de tipos que confirme que *val* tiene *typ* por tipo inferido."

#: ../Doc/library/typing.rst:2418
msgid ""
"When the type checker encounters a call to ``assert_type()``, it emits an error if the "
"value is not of the specified type::"
msgstr ""
"Cuando el validador de tipos se encuentra con una llamada a ``assert_type()``, emite "
"un error si el valor no es del tipo especificado::"

#: ../Doc/library/typing.rst:2425
msgid "At runtime this returns the first argument unchanged with no side effects."
msgstr ""
"En tiempo de ejecución, ésto retorna el primer argumento sin modificar y sin efectos "
"secudarios."

#: ../Doc/library/typing.rst:2427
msgid ""
"This function is useful for ensuring the type checker's understanding of a script is "
"in line with the developer's intentions::"
msgstr ""
"Esta función es útil para asegurarse de que la comprensión que el validador de tipos "
"tiene sobre un *script* está alineada con las intenciones de le desarrolladore::"

#: ../Doc/library/typing.rst:2441
msgid "Ask a static type checker to confirm that a line of code is unreachable."
msgstr ""
"Solicitar a un validador estático de tipos confirmar que una línea de código no es "
"alcanzable."

#: ../Doc/library/typing.rst:2454
msgid ""
"Here, the annotations allow the type checker to infer that the last case can never "
"execute, because ``arg`` is either an :class:`int` or a :class:`str`, and both options "
"are covered by earlier cases. If a type checker finds that a call to "
"``assert_never()`` is reachable, it will emit an error. For example, if the type "
"annotation for ``arg`` was instead ``int | str | float``, the type checker would emit "
"an error pointing out that ``unreachable`` is of type :class:`float`. For a call to "
"``assert_never`` to pass type checking, the inferred type of the argument passed in "
"must be the bottom type, :data:`Never`, and nothing else."
msgstr ""
"Aquí, las anotaciones permiten al validador de tipos inferir que el último caso nunca "
"será ejecutado, porque ``arg`` es un :class:`int` o un :class:`str`, y ambas opciones "
"son cubiertas por los casos anteriores. Si un validador de tipos encuentra que una "
"llamada a ``assert_never()`` es alcanzable, emitirá un error. Por ejemplo, si la "
"anotacion de tipos para ``arg`` fuera en cambio ``int | str | float``, el validador de "
"tipos emitiría un error señalando que ``unreachable`` es de tipo :class:`float`. Para "
"que una llamada a ``assert_never`` pase la validación de tipos, el tipo inferido del "
"argumento dado debe ser el tipo vacío, :data:`Never`, y nada más."

#: ../Doc/library/typing.rst:2466
msgid "At runtime, this throws an exception when called."
msgstr "En tiempo de ejecución, ésto lanza una excepción cuando es llamado."

#: ../Doc/library/typing.rst:2469
msgid ""
"`Unreachable Code and Exhaustiveness Checking <https://typing.readthedocs.io/en/latest/"
"source/unreachable.html>`__ has more information about exhaustiveness checking with "
"static typing."
msgstr ""
"`Unreachable Code and Exhaustiveness Checking <https://typing.readthedocs.io/en/latest/"
"source/unreachable.html>`__ contiene más información acerca de la verificación de "
"exhaustividad con tipado estático."

#: ../Doc/library/typing.rst:2477
msgid "Reveal the inferred static type of an expression."
msgstr "Revela el tipo estático inferido de una expresión."

#: ../Doc/library/typing.rst:2479
msgid ""
"When a static type checker encounters a call to this function, it emits a diagnostic "
"with the type of the argument. For example::"
msgstr ""
"Cuando un validador estático de tipos se encuentra con una invocación a esta función, "
"emite un diagnostico con el tipo del argumento. Por ejemplo::"

#: ../Doc/library/typing.rst:2485
msgid ""
"This can be useful when you want to debug how your type checker handles a particular "
"piece of code."
msgstr ""
"Ésto puede ser de utilidad cuando se desea *debuguear* cómo tu validador de tipos "
"maneja una pieza particular de código."

#: ../Doc/library/typing.rst:2488
msgid ""
"The function returns its argument unchanged, which allows using it within an "
"expression::"
msgstr ""
"Esta función retorna su argumento sin cambios, lo que permite su uso dentro de una "
"expresión::"

#: ../Doc/library/typing.rst:2493
msgid ""
"Most type checkers support ``reveal_type()`` anywhere, even if the name is not "
"imported from ``typing``. Importing the name from ``typing`` allows your code to run "
"without runtime errors and communicates intent more clearly."
msgstr ""
"La mayoría de los validadores de tipos soportan ``reveal_type()`` en cualquier lugar, "
"incluso si el nombre no ha sido importado desde ``typing``. Importar el nombre desde "
"``typing`` permite que el código corra sin errores en tiempo de ejecución y comunica "
"la intención de forma más clara."

#: ../Doc/library/typing.rst:2498
msgid ""
"At runtime, this function prints the runtime type of its argument to stderr and "
"returns it unchanged::"
msgstr ""
"En tiempo de ejecución, esta función imprime al *stderr* el tipo en tiempo de "
"ejecución de su argumento y lu retorna in cambios::"

#: ../Doc/library/typing.rst:2508
msgid ""
":data:`~typing.dataclass_transform` may be used to decorate a class, metaclass, or a "
"function that is itself a decorator. The presence of ``@dataclass_transform()`` tells "
"a static type checker that the decorated object performs runtime \"magic\" that "
"transforms a class, giving it :func:`dataclasses.dataclass`-like behaviors."
msgstr ""
"Es posible utilizar :data:`~typing.dataclass_transform` para decorar una clase, "
"metaclase, o una función que es ella misma un decorador. La presencia de "
"``@dataclass_transform()`` indica a un validador estático de tipos que el objeto "
"decorado ejecuta, en tiempo de ejecución, \"magia\" que transforma una clase, dándole "
"comportamientos similares a los que tiene :func:`dataclasses.dataclass`."

#: ../Doc/library/typing.rst:2514
msgid "Example usage with a decorator function::"
msgstr "Ejemplo de uso con una función-decorador::"

#: ../Doc/library/typing.rst:2528
msgid "On a base class::"
msgstr "En una clase base::"

#: ../Doc/library/typing.rst:2537
msgid "On a metaclass::"
msgstr "En una metaclase::"

#: ../Doc/library/typing.rst:2548
msgid ""
"The ``CustomerModel`` classes defined above will be treated by type checkers similarly "
"to classes created with :func:`@dataclasses.dataclass <dataclasses.dataclass>`. For "
"example, type checkers will assume these classes have ``__init__`` methods that accept "
"``id`` and ``name``."
msgstr ""
"Las clases ``CustomerModel`` definidas arribe serán tratadas por los validadores de "
"tipo de forma similar a las clases que sean creadas con  :func:`@dataclasses.dataclass "
"<dataclasses.dataclass>`. Por ejemplo, los validadores de tipo asumirán que estas "
"clases tienen métodos ``__init__`` que aceptan ``id`` y ``name``."

#: ../Doc/library/typing.rst:2554
msgid ""
"The decorated class, metaclass, or function may accept the following bool arguments "
"which type checkers will assume have the same effect as they would have on the :func:"
"`@dataclasses.dataclass<dataclasses.dataclass>` decorator: ``init``, ``eq``, "
"``order``, ``unsafe_hash``, ``frozen``, ``match_args``, ``kw_only``, and ``slots``. It "
"must be possible for the value of these arguments (``True`` or ``False``) to be "
"statically evaluated."
msgstr ""
"La clase, metaclase o función decorada puede aceptar los siguientes argumentos "
"booleanos, de los cuales los validadores de tipos asumirán que tienen el mismo efecto "
"que tendrían en el decorador :func:`@dataclasses.dataclass<dataclasses.dataclass>`: "
"``init``, ``eq``, ``order``, ``unsafe_hash``, ``frozen``, ``match_args``, ``kw_only``, "
"y ``slots``. Debe ser posible evaluar estáticamente el valor de estos argumentos "
"(``True`` o ``False``)."

#: ../Doc/library/typing.rst:2562
msgid ""
"The arguments to the ``dataclass_transform`` decorator can be used to customize the "
"default behaviors of the decorated class, metaclass, or function:"
msgstr ""
"Es posible utilizar los argumentos del decorador ``dataclass_transform`` para "
"personalizar los compartamientos por defecto de la clase, metaclase o función decorada:"

#: ../Doc/library/typing.rst:2566
msgid ""
"``eq_default`` indicates whether the ``eq`` parameter is assumed to be ``True`` or "
"``False`` if it is omitted by the caller."
msgstr ""
"``eq_default`` indica si, cuando el invocador haya omitido el parámetro ``eq``, el "
"valor de éste debe tomarse por ``True`` o ``False``."

#: ../Doc/library/typing.rst:2568
msgid ""
"``order_default`` indicates whether the ``order`` parameter is assumed to be True or "
"False if it is omitted by the caller."
msgstr ""
"``order_default`` indica si, cuando el invocador haya omitido el parámetro ``order``, "
"el valor de éste debe tomarse por ``True`` o ``False``."

#: ../Doc/library/typing.rst:2570
msgid ""
"``kw_only_default`` indicates whether the ``kw_only`` parameter is assumed to be True "
"or False if it is omitted by the caller."
msgstr ""
"``kw_only_default`` indica si, cuando el invocador haya omitido el parámetro "
"``kw_only``, el valor de éste debe tomarse por ``True`` o ``False``."

#: ../Doc/library/typing.rst:2572
msgid ""
"``field_specifiers`` specifies a static list of supported classes or functions that "
"describe fields, similar to ``dataclasses.field()``."
msgstr ""
"``field_specifiers`` (especificadores de campos) especifica una lista estática de "
"clases o funciones soportadas que describen campos, de manera similar a ``dataclasses."
"field()``."

#: ../Doc/library/typing.rst:2574
msgid ""
"Arbitrary other keyword arguments are accepted in order to allow for possible future "
"extensions."
msgstr ""
"Es posible pasar arbitrariamente otros argumentos nombrados para permitir posibles "
"extensiones futuras."

#: ../Doc/library/typing.rst:2577
msgid "Type checkers recognize the following optional arguments on field specifiers:"
msgstr ""
"Los validadores de tipos reconocen los siguientes argumentos opcionales en "
"especificadores de campos:"

#: ../Doc/library/typing.rst:2580
msgid ""
"``init`` indicates whether the field should be included in the synthesized "
"``__init__`` method. If unspecified, ``init`` defaults to ``True``."
msgstr ""
"``init`` indica si el campo debe ser incluido en el método ``__init__`` sintetizado. "
"Si no es especificado, ``init`` será ``True`` por defecto."

#: ../Doc/library/typing.rst:2583
msgid "``default`` provides the default value for the field."
msgstr "``default`` provee el valor por defecto para el campo."

#: ../Doc/library/typing.rst:2584
msgid ""
"``default_factory`` provides a runtime callback that returns the default value for the "
"field. If neither ``default`` nor ``default_factory`` are specified, the field is "
"assumed to have no default value and must be provided a value when the class is "
"instantiated."
msgstr ""
"``default_factory`` provee un *callback* en tiempo de ejecución que retorna el valor "
"por defecto para el campo. Si no se especifican ``default`` ni ``default_factory``, se "
"asumirá que el campo no tiene un valor por defecto y que un valor debe ser provisto "
"cuando la clase sea instanciada."

#: ../Doc/library/typing.rst:2589
msgid "``factory`` is an alias for ``default_factory``."
msgstr "``factory`` es un alias para ``default_factory``."

#: ../Doc/library/typing.rst:2590
msgid ""
"``kw_only`` indicates whether the field should be marked as keyword-only. If ``True``, "
"the field will be keyword-only. If ``False``, it will not be keyword-only. If "
"unspecified, the value of the ``kw_only`` parameter on the object decorated with "
"``dataclass_transform`` will be used, or if that is unspecified, the value of "
"``kw_only_default`` on ``dataclass_transform`` will be used."
msgstr ""
"``kw_only`` indica si el campo debe ser marcado como exclusivamente de palabra clave. "
"Si es ``True``, el campo será exclusivamente de palabra clave. Si es ``False`` no lo "
"será. Si no se especifica, se utilizará el valor para el parámetro ``kw_only`` "
"especificado en el objeto decorado con ``dataclass_transform``, o si éste tampoco está "
"especificado, se utilizará el valor de ``kw_only_default`` en ``dataclass_transform``."

# La idea de "synthesized __init__ method" puede verse en el pep 681 donde refiere a los métodos init que pueden auto-generar librerías con características similares a dataclass
#: ../Doc/library/typing.rst:2596
msgid ""
"``alias`` provides an alternative name for the field. This alternative name is used in "
"the synthesized ``__init__`` method."
msgstr ""
"``alias`` provee un nombre alternativo para el campo. Este nombre alternativo será "
"utilizado en el método ``__init__`` sintetizado."

#: ../Doc/library/typing.rst:2599
msgid ""
"At runtime, this decorator records its arguments in the ``__dataclass_transform__`` "
"attribute on the decorated object. It has no other runtime effect."
msgstr ""
"En tiempo de ejecución, este decorador registra sus argumentos en el atributo "
"``__dataclass_transform__`` del objeto decorado. No tiene otro efecto en tiempo de "
"ejecución."

#: ../Doc/library/typing.rst:2603
msgid "See :pep:`681` for more details."
msgstr "Véase :pep:`681` para más detalle."

#: ../Doc/library/typing.rst:2609
msgid ""
"The ``@overload`` decorator allows describing functions and methods that support "
"multiple different combinations of argument types. A series of ``@overload``-decorated "
"definitions must be followed by exactly one non-``@overload``-decorated definition "
"(for the same function/method). The ``@overload``-decorated definitions are for the "
"benefit of the type checker only, since they will be overwritten by the non-"
"``@overload``-decorated definition, while the latter is used at runtime but should be "
"ignored by a type checker.  At runtime, calling a ``@overload``-decorated function "
"directly will raise :exc:`NotImplementedError`. An example of overload that gives a "
"more precise type than can be expressed using a union or a type variable::"
msgstr ""
"El decorador ``@overload`` permite describir funciones y métodos que soportan "
"diferentes combinaciones de tipos de argumento. A una serie de definiciones decoradas "
"con ``@overload`` debe seguir exactamente una definición no decorada con ``@overload`` "
"(para la misma función o método). Las definiciones decoradas con ``@overload`` son "
"solo para beneficio del validador de tipos, ya que serán sobrescritas por la "
"definición no decorada con ``@overload``. Esta última se usa en tiempo de ejecución y "
"debería ser ignorada por el validador de tipos. En tiempo de ejecución, llamar a una "
"función decorada con ``@overload`` lanzará directamente :exc:`NotImplementedError`. Un "
"ejemplo de sobrecarga que proporciona un tipo más preciso se puede expresar con una "
"unión o una variable de tipo::"

#: ../Doc/library/typing.rst:2633
msgid "See :pep:`484` for more details and comparison with other typing semantics."
msgstr "Véase :pep:`484` para más detalle y comparación con otras semánticas de tipado."

#: ../Doc/library/typing.rst:2635
msgid ""
"Overloaded functions can now be introspected at runtime using :func:`get_overloads`."
msgstr ""
"Ahora es posible introspectar en tiempo de ejecución las funciones sobrecargadas "
"utilizando :func:`get_overloads`."

#: ../Doc/library/typing.rst:2642
msgid ""
"Return a sequence of :func:`@overload <overload>`-decorated definitions for *func*. "
"*func* is the function object for the implementation of the overloaded function. For "
"example, given the definition of ``process`` in the documentation for :func:`@overload "
"<overload>`, ``get_overloads(process)`` will return a sequence of three function "
"objects for the three defined overloads. If called on a function with no overloads, "
"``get_overloads()`` returns an empty sequence."
msgstr ""
"Retorna una secuencia de definiciones para *func* decoradas con :func:`@overload "
"<overload>`. *func* es el objeto función correspondiente a la implementación de la "
"función sobrecargada. Por ejemplo, dada la definición de ``process`` en la "
"documentación de :func:`@overload <overload>`, ``get_overloads(process)`` retornará "
"una secuencia de tres objetos función para las tres sobrecargas definidas. Si es "
"llamada con una función que no tenga sobrecargas, ``get_overloads()`` retorna una "
"secuencia vacía."

#: ../Doc/library/typing.rst:2650
msgid ""
"``get_overloads()`` can be used for introspecting an overloaded function at runtime."
msgstr ""
"``get_overloads()`` puede ser utilizada para introspectar en tiempo de ejecución una "
"función sobrecargada."

#: ../Doc/library/typing.rst:2658
msgid ""
"Clear all registered overloads in the internal registry. This can be used to reclaim "
"the memory used by the registry."
msgstr ""
"Limpia todas las sobrecargas registradas del registro interno. Ésto puede ser usado "
"para recuperar memoria usada por el registro."

#: ../Doc/library/typing.rst:2666
msgid ""
"A decorator to indicate to type checkers that the decorated method cannot be "
"overridden, and the decorated class cannot be subclassed. For example::"
msgstr ""
"Un decorador que indica a los validadores de tipos que el método decorado no se puede "
"sobreescribir, o que la clase decorada no se puede derivar (*subclassed*). Por "
"ejemplo::"

#: ../Doc/library/typing.rst:2689
msgid ""
"The decorator will now set the ``__final__`` attribute to ``True`` on the decorated "
"object. Thus, a check like ``if getattr(obj, \"__final__\", False)`` can be used at "
"runtime to determine whether an object ``obj`` has been marked as final. If the "
"decorated object does not support setting attributes, the decorator returns the object "
"unchanged without raising an exception."
msgstr ""
"El decorador establecerá a ``True`` el atributo ``__final__`` en el objeto decorado. "
"De este modo, es posible utilizar en tiempo de ejecución una verificación como ``if "
"getattr(obj, \"__final__\", False)`` para determinar si un objeto ``obj`` has sido "
"marcado como final. Si el objeto decorado no soporta el establecimiento de atributos, "
"el decorador retorna el objeto sin cambios y sin levantar una excepción."

# se extrae del contexto que el decorador elimina la comprobacion de tipo en
# el validador, por lo tanto solo anota/comenta (annotation), no
# indica/sugiere tipo (type hint)
#: ../Doc/library/typing.rst:2700
msgid "Decorator to indicate that annotations are not type hints."
msgstr ""
"Un decorador para indicar que las anotaciones no deben ser comprobadas como "
"indicadores de tipo."

#: ../Doc/library/typing.rst:2702
msgid ""
"This works as class or function :term:`decorator`.  With a class, it applies "
"recursively to all methods and classes defined in that class (but not to methods "
"defined in its superclasses or subclasses)."
msgstr ""
"Esto funciona como un :term:`decorator` (decorador) de clase o función. Con una clase, "
"se aplica recursivamente a todos los métodos y clases definidos en dicha clase (pero "
"no a lo métodos definidos en sus superclases y subclases)."

# ver en contexto
#: ../Doc/library/typing.rst:2706
msgid "This mutates the function(s) in place."
msgstr "Esto modifica la función o funciones *in situ*."

#: ../Doc/library/typing.rst:2710
msgid "Decorator to give another decorator the :func:`no_type_check` effect."
msgstr ""
"Un decorador que asigna a otro decorador el efecto de :func:`no_type_check` (no "
"comprobar tipo)."

#: ../Doc/library/typing.rst:2712
msgid ""
"This wraps the decorator with something that wraps the decorated function in :func:"
"`no_type_check`."
msgstr ""
"Esto hace que el decorador decorado añada el efecto de :func:`no_type_check` a la "
"función decorada."

#: ../Doc/library/typing.rst:2717
msgid "Decorator to mark a class or function to be unavailable at runtime."
msgstr ""
"Un decorador que marca una clase o función como no disponible en tiempo de ejecución."

#: ../Doc/library/typing.rst:2719
msgid ""
"This decorator is itself not available at runtime. It is mainly intended to mark "
"classes that are defined in type stub files if an implementation returns an instance "
"of a private class::"
msgstr ""
"Este decorador no está disponible en tiempo de ejecución. Existe principalmente para "
"marcar clases que se definen en archivos *stub* para cuando una implementación retorna "
"una instancia de una clase privada::"

#: ../Doc/library/typing.rst:2730
msgid ""
"Note that returning instances of private classes is not recommended. It is usually "
"preferable to make such classes public."
msgstr ""
"Nótese que no se recomienda retornar instancias de clases privadas. Normalmente es "
"preferible convertirlas en clases públicas."

#: ../Doc/library/typing.rst:2734
msgid "Introspection helpers"
msgstr "Ayudas de introspección"

#: ../Doc/library/typing.rst:2738
msgid ""
"Return a dictionary containing type hints for a function, method, module or class "
"object."
msgstr ""
"Retorna un diccionario que contiene indicaciones de tipo para una función, método, "
"módulo o objeto clase."

#: ../Doc/library/typing.rst:2741
msgid ""
"This is often the same as ``obj.__annotations__``. In addition, forward references "
"encoded as string literals are handled by evaluating them in ``globals`` and "
"``locals`` namespaces. For a class ``C``, return a dictionary constructed by merging "
"all the ``__annotations__`` along ``C.__mro__`` in reverse order."
msgstr ""
"Habitualmente, esto es lo mismo que ``obj.__annotations__``. Además, las referencias "
"indicadas como cadenas de texto se gestionan evaluándolas en los espacios de "
"nombres``globals`` y ``locals``. Para una clase ``C``, se retorna un diccionario "
"construido por la combinación de ``__annotations__`` y ``C.__mro`` en orden inverso."

#: ../Doc/library/typing.rst:2747
msgid ""
"The function recursively replaces all ``Annotated[T, ...]`` with ``T``, unless "
"``include_extras`` is set to ``True`` (see :class:`Annotated` for more information). "
"For example::"
msgstr ""
"La función reemplaza todos los ``Annotated[T, ...]`` con ``T`` de manera recursiva, a "
"menos que ``include_extras`` se defina como ``True`` ( véase :class:`Annotated` para "
"más información). Por ejemplo::"

#: ../Doc/library/typing.rst:2762
msgid ""
":func:`get_type_hints` does not work with imported :ref:`type aliases <type-aliases>` "
"that include forward references. Enabling postponed evaluation of annotations (:pep:"
"`563`) may remove the need for most forward references."
msgstr ""
":func:`get_type_hints` no funciona con :ref:`alias de tipo <type-aliases>` importados "
"que incluyen referencias hacia adelante. Habilitar la evaluación pospuesta de "
"anotaciones (:pep:`563`) puede eliminar la necesidad de la mayoría de las referencias "
"futuras."

#: ../Doc/library/typing.rst:2767
msgid "Added ``include_extras`` parameter as part of :pep:`593`."
msgstr "Se agregan los parámetros ``include_extras`` como parte de :pep:`593`."

#: ../Doc/library/typing.rst:2770
msgid ""
"Previously, ``Optional[t]`` was added for function and method annotations if a default "
"value equal to ``None`` was set. Now the annotation is returned unchanged."
msgstr ""
"Anteriormente, se agregaba ``Optional[t]`` en las anotaciones de funciones o métodos "
"si se establecia un valor por defecto igual a ``None``. Ahora la anotación es "
"retornada sin cambios."

# special forms se refiere a tipado exclusivo de typing (no el nativo como str
# o int): Union, Optional ...
#: ../Doc/library/typing.rst:2778
msgid "Provide basic introspection for generic types and special typing forms."
msgstr ""
"Provee introspección básica para tipos genéricos y construcciones especiales de tipado."

#: ../Doc/library/typing.rst:2780
msgid ""
"For a typing object of the form ``X[Y, Z, ...]`` these functions return ``X`` and "
"``(Y, Z, ...)``. If ``X`` is a generic alias for a builtin or :mod:`collections` "
"class, it gets normalized to the original class. If ``X`` is a union or :class:"
"`Literal` contained in another generic type, the order of ``(Y, Z, ...)`` may be "
"different from the order of the original arguments ``[Y, Z, ...]`` due to type "
"caching. For unsupported objects return ``None`` and ``()`` correspondingly. Examples::"
msgstr ""
"Para un objeto de escritura de la forma ``X[Y, Z, ...]``, estas funciones retornan "
"``X`` y ``(Y, Z, ...)``. Si ``X`` es un alias genérico para una clase incorporada o :"
"mod:`collections`, se normaliza a la clase original. Si ``X`` es una unión o :class:"
"`Literal` contenido en otro tipo genérico, el orden de ``(Y, Z, ...)`` puede ser "
"diferente del orden de los argumentos originales ``[Y, Z, ...]`` debido al tipo de "
"almacenamiento en caché. Para objetos no admitidos, retorna ``None`` y ``()`` "
"correspondientemente. Ejemplos:"

#: ../Doc/library/typing.rst:2799
msgid "Check if a type is a :class:`TypedDict`."
msgstr "Compruebe si un tipo es :class:`TypedDict`."

#: ../Doc/library/typing.rst:2814
msgid ""
"A class used for internal typing representation of string forward references. For "
"example, ``List[\"SomeClass\"]`` is implicitly transformed into "
"``List[ForwardRef(\"SomeClass\")]``.  This class should not be instantiated by a user, "
"but may be used by introspection tools."
msgstr ""
"Una clase utilizada para la representación de escritura interna de referencias de "
"cadena hacia adelante. Por ejemplo, ``List[\"SomeClass\"]`` se transforma "
"implícitamente en ``List[ForwardRef(\"SomeClass\")]``. Esta clase no debe ser "
"instanciada por un usuario, pero puede ser utilizada por herramientas de introspección."

#: ../Doc/library/typing.rst:2820
msgid ""
":pep:`585` generic types such as ``list[\"SomeClass\"]`` will not be implicitly "
"transformed into ``list[ForwardRef(\"SomeClass\")]`` and thus will not automatically "
"resolve to ``list[SomeClass]``."
msgstr ""
"Los tipos genéricos de :pep:`585`, como ``list[\"SomeClass\"]``, no se transformarán "
"implícitamente en ``list[ForwardRef(\"SomeClass\")]`` y, por lo tanto, no se "
"resolverán automáticamente en ``list[SomeClass]``."

#: ../Doc/library/typing.rst:2827
msgid "Constant"
msgstr "Constantes"

#: ../Doc/library/typing.rst:2831
msgid ""
"A special constant that is assumed to be ``True`` by 3rd party static type checkers. "
"It is ``False`` at runtime. Usage::"
msgstr ""
"Una constante especial que se asume como cierta (``True``) por validadores estáticos "
"de tipos de terceros. Es falsa (``False``) en tiempo de ejecución. Uso::"

#: ../Doc/library/typing.rst:2840
msgid ""
"The first type annotation must be enclosed in quotes, making it a \"forward reference"
"\", to hide the ``expensive_mod`` reference from the interpreter runtime.  Type "
"annotations for local variables are not evaluated, so the second annotation does not "
"need to be enclosed in quotes."
msgstr ""
"Nótese que la primera anotación de tipo debe estar rodeada por comillas, "
"convirtiéndola en una \"referencia directa\", para ocultar al intérprete la referencia "
"``expensive_mod`` en tiempo de ejecución. Las anotaciones de tipo para variables "
"locales no se evalúan, así que la segunda anotación no necesita comillas."

#: ../Doc/library/typing.rst:2847
msgid ""
"If ``from __future__ import annotations`` is used, annotations are not evaluated at "
"function definition time. Instead, they are stored as strings in ``__annotations__``. "
"This makes it unnecessary to use quotes around the annotation (see :pep:`563`)."
msgstr ""
"Si se utiliza ``from __future__ import annotations``, las anotaciones no son evaluadas "
"al momento de la definición de funciones. En cambio, serán almacenadas como cadenas de "
"texto en ``__annotations__``. Ésto vuelve innecesario el uso de comillas alrededor de "
"la anotación (véase :pep:`563`)."

#: ../Doc/library/typing.rst:2856
msgid "Deprecation Timeline of Major Features"
msgstr "Línea de tiempo de obsolecencia de características principales"

#: ../Doc/library/typing.rst:2858
msgid ""
"Certain features in ``typing`` are deprecated and may be removed in a future version "
"of Python. The following table summarizes major deprecations for your convenience. "
"This is subject to change, and not all deprecations are listed."
msgstr ""
"Algunas características de ``typing`` están obsoletas y podrán ser removidas en "
"versiones futuras de Python. Lo que sigue es una tabla que resume las principales "
"obsolecencias para su conveniencia. Ésto está sujeto a cambio y no todas las "
"obsolecencias están representadas."

#: ../Doc/library/typing.rst:2863
msgid "Feature"
msgstr "Característica"

#: ../Doc/library/typing.rst:2863
msgid "Deprecated in"
msgstr "En desuso desde"

#: ../Doc/library/typing.rst:2863
msgid "Projected removal"
msgstr "Eliminación proyectada"

#: ../Doc/library/typing.rst:2863
msgid "PEP/issue"
msgstr "PEP/issue"

#: ../Doc/library/typing.rst:2865
msgid "``typing.io`` and ``typing.re`` submodules"
msgstr "``typing.io`` and ``typing.re`` submodules"

#: ../Doc/library/typing.rst:2865
msgid "3.8"
msgstr "3.8"

#: ../Doc/library/typing.rst:2865
msgid "3.12"
msgstr "3.12"

#: ../Doc/library/typing.rst:2865
msgid ":issue:`38291`"
msgstr ":issue:`38291`"

#: ../Doc/library/typing.rst:2868
msgid "``typing`` versions of standard collections"
msgstr "Versiones ``typing`` de colecciones estándares"

#: ../Doc/library/typing.rst:2868
msgid "3.9"
msgstr "3.9"

#: ../Doc/library/typing.rst:2868 ../Doc/library/typing.rst:2871
msgid "Undecided"
msgstr "No decidido"

#: ../Doc/library/typing.rst:2868
msgid ":pep:`585`"
msgstr ":pep:`585`"

#: ../Doc/library/typing.rst:2871
msgid "``typing.Text``"
msgstr "``typing.Text``"

#: ../Doc/library/typing.rst:2871
msgid "3.11"
msgstr "3.11"

#: ../Doc/library/typing.rst:2871
msgid ":gh:`92332`"
msgstr ":gh:`92332`"

#~ msgid ""
#~ "This module provides runtime support for type hints as specified by :pep:`484`, :"
#~ "pep:`526`, :pep:`544`, :pep:`586`, :pep:`589`, :pep:`591`, :pep:`612` and :pep:"
#~ "`613`. The most fundamental support consists of the types :data:`Any`, :data:"
#~ "`Union`, :data:`Tuple`, :data:`Callable`, :class:`TypeVar`, and :class:`Generic`.  "
#~ "For full specification please see :pep:`484`.  For a simplified introduction to "
#~ "type hints see :pep:`483`."
#~ msgstr ""
#~ "Este módulo proporciona soporte en tiempo de ejecución para sugerencias de tipo "
#~ "según lo especificado por :pep:`484`, :pep:`526`, :pep:`544`, :pep:`586`, :pep:"
#~ "`589`, :pep:`591`, :pep:`612` y :pep:`613`. El soporte más fundamental consiste en "
#~ "los tipos :data:`Any`, :data:`Union`, :data:`Tuple`, :data:`Callable`, :class:"
#~ "`TypeVar` y :class:`Generic`. Para obtener especificaciones completas, consulte :"
#~ "pep:`484`. Para obtener una introducción simplificada a las sugerencias de tipo, "
#~ "consulte :pep:`483`."

# revisar constrained y que es una type variable en su contexto
#~ msgid ""
#~ "A generic type can have any number of type variables, and type variables may be "
#~ "constrained::"
#~ msgstr ""
#~ "Un tipo genérico puede tener un número indefinido de variables de tipo, y pueden "
#~ "limitarse a tipos concretos::"

#~ msgid ""
#~ "The latter example's signature is essentially the overloading of ``(str, str) -> "
#~ "str`` and ``(bytes, bytes) -> bytes``.  Also note that if the arguments are "
#~ "instances of some subclass of :class:`str`, the return type is still plain :class:"
#~ "`str`."
#~ msgstr ""
#~ "La signatura de los ejemplos anteriores es esencialmente la superposición de "
#~ "``(str, str) -> str`` y ``(bytes, bytes) -> bytes``. Nótese también que aunque los "
#~ "argumentos sean instancias de alguna subclase de :class:`str`, el tipo retornado "
#~ "aún será una simple :class:`str`."

#~ msgid ""
#~ "If ``from __future__ import annotations`` is used in Python 3.7 or later, "
#~ "annotations are not evaluated at function definition time. Instead, they are stored "
#~ "as strings in ``__annotations__``, This makes it unnecessary to use quotes around "
#~ "the annotation. (see :pep:`563`)."
#~ msgstr ""
#~ "Si ``from __future__ import annotations`` es usado en Python 3.7 o posterior, las "
#~ "anotaciones no son evaluadas en tiempo de definición de funciones. En cambio, son "
#~ "guardadas como cadenas de caracteres en ``__annotations__``, esto hace innecesario "
#~ "usar comillas alrededor de la anotación. (véase :pep:`563`)."
