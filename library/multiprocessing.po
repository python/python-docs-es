# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2021-12-12 13:14-0500\n"
"Last-Translator: Adolfo Hristo David Roque Gámez <aroquega@gmail.com>\n"
"Language: es_ES\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.0\n"

#: ../Doc/library/multiprocessing.rst:2
msgid ":mod:`multiprocessing` --- Process-based parallelism"
msgstr ":mod:`multiprocessing` --- Paralelismo basado en procesos"

#: ../Doc/library/multiprocessing.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/`"
msgstr "**Código fuente:** :source:`Lib/multiprocessing/`"

#: ../Doc/includes/wasm-notavail.rst:3
#, fuzzy
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ":ref:`Availability <availability>`: no Emscripten, no WASI."

#: ../Doc/includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"Este módulo no funciona o no está disponible en las plataformas WebAssembly "
"``wasm32-emscripten`` y ``wasm32-wasi``. Consulte :ref:`wasm-availability` "
"para obtener más información."

#: ../Doc/library/multiprocessing.rst:14
msgid "Introduction"
msgstr "Introducción"

#: ../Doc/library/multiprocessing.rst:16
#, fuzzy
msgid ""
":mod:`multiprocessing` is a package that supports spawning processes using "
"an API similar to the :mod:`threading` module.  The :mod:`multiprocessing` "
"package offers both local and remote concurrency, effectively side-stepping "
"the :term:`Global Interpreter Lock <global interpreter lock>` by using "
"subprocesses instead of threads.  Due to this, the :mod:`multiprocessing` "
"module allows the programmer to fully leverage multiple processors on a "
"given machine.  It runs on both POSIX and Windows."
msgstr ""
":mod:`multiprocessing` es un paquete que permite crear procesos (*spawning*) "
"utilizando una API similar al módulo :mod:`threading`. El paquete :mod:"
"`multiprocessing` ofrece concurrencia tanto local como remota, esquivando "
"el :term:`Global Interpreter Lock <global interpreter lock>` mediante el uso "
"de subprocesos en lugar de hilos (*threads*). Debido a esto, el módulo :mod:"
"`multiprocessing` le permite al programador aprovechar al máximo múltiples "
"procesadores en una máquina determinada. Se ejecuta tanto en Unix como en "
"Windows."

#: ../Doc/library/multiprocessing.rst:25
msgid ""
"The :mod:`multiprocessing` module also introduces APIs which do not have "
"analogs in the :mod:`threading` module.  A prime example of this is the :"
"class:`~multiprocessing.pool.Pool` object which offers a convenient means of "
"parallelizing the execution of a function across multiple input values, "
"distributing the input data across processes (data parallelism).  The "
"following example demonstrates the common practice of defining such "
"functions in a module so that child processes can successfully import that "
"module.  This basic example of data parallelism using :class:"
"`~multiprocessing.pool.Pool`, ::"
msgstr ""
"El módulo :mod:`multiprocessing` también introduce API que no tienen "
"análogos en el módulo :mod:`threading`. Un buen ejemplo de esto es el "
"objeto :class:`~multiprocessing.pool.Pool` que ofrece un medio conveniente "
"de paralelizar la ejecución de una función a través de múltiples valores de "
"entrada, distribuyendo los datos de entrada a través de procesos "
"(paralelismo de datos). El siguiente ejemplo demuestra la práctica común de "
"definir tales funciones en un módulo para que los procesos secundarios "
"puedan importar con éxito ese módulo. Este ejemplo básico de paralelismo de "
"datos usando :class:`~multiprocessing.pool.Pool`, ::"

#: ../Doc/library/multiprocessing.rst:43
msgid "will print to standard output ::"
msgstr "imprimirá la salida estándar ::"

#: ../Doc/library/multiprocessing.rst:50
msgid ""
":class:`concurrent.futures.ProcessPoolExecutor` offers a higher level "
"interface to push tasks to a background process without blocking execution "
"of the calling process. Compared to using the :class:`~multiprocessing.pool."
"Pool` interface directly, the :mod:`concurrent.futures` API more readily "
"allows the submission of work to the underlying process pool to be separated "
"from waiting for the results."
msgstr ""
":class:`concurrent.futures.ProcessPoolExecutor` ofrece una interfaz de nivel "
"superior para enviar tareas a un proceso en segundo plano sin bloquear la "
"ejecución del proceso de llamada. En comparación con el uso directo de la "
"interfaz :class:`~multiprocessing.pool.Pool`, la API :mod:`concurrent."
"futures` permite separar el envío de trabajo al grupo de procesos subyacente "
"de la espera de los resultados."

#: ../Doc/library/multiprocessing.rst:59
msgid "The :class:`Process` class"
msgstr "La clase :class:`Process`"

#: ../Doc/library/multiprocessing.rst:61
msgid ""
"In :mod:`multiprocessing`, processes are spawned by creating a :class:"
"`Process` object and then calling its :meth:`~Process.start` method.  :class:"
"`Process` follows the API of :class:`threading.Thread`.  A trivial example "
"of a multiprocess program is ::"
msgstr ""
"En :mod:`multiprocessing`, los procesos se generan creando un objeto :class:"
"`Process` y luego llamando a su método :meth:`~Process.start` .  :class:"
"`Process` sigue la API de :class:`threading.Thread`. Un ejemplo trivial de "
"un programa multiproceso es ::"

#: ../Doc/library/multiprocessing.rst:76
msgid ""
"To show the individual process IDs involved, here is an expanded example::"
msgstr ""
"Para mostrar las IDs individuales involucradas en el proceso, aquí hay un "
"ejemplo ampliado::"

#: ../Doc/library/multiprocessing.rst:97
msgid ""
"For an explanation of why the ``if __name__ == '__main__'`` part is "
"necessary, see :ref:`multiprocessing-programming`."
msgstr ""
"Para obtener una explicación de por qué es necesaria la parte ``if __name__ "
"== '__main__'`` , consulte :ref:`multiprocessing-programming`."

#: ../Doc/library/multiprocessing.rst:105
msgid "Contexts and start methods"
msgstr "Contextos y métodos de inicio"

#: ../Doc/library/multiprocessing.rst:107
msgid ""
"Depending on the platform, :mod:`multiprocessing` supports three ways to "
"start a process.  These *start methods* are"
msgstr ""
"Dependiendo de la plataforma, :mod:`multiprocessing` admite tres formas de "
"iniciar un proceso. Estos métodos de inicio *start methods* son"

#: ../Doc/library/multiprocessing.rst:118
msgid "*spawn*"
msgstr "Generación (*spawn*)"

#: ../Doc/library/multiprocessing.rst:111
msgid ""
"The parent process starts a fresh Python interpreter process.  The child "
"process will only inherit those resources necessary to run the process "
"object's :meth:`~Process.run` method.  In particular, unnecessary file "
"descriptors and handles from the parent process will not be inherited.  "
"Starting a process using this method is rather slow compared to using *fork* "
"or *forkserver*."
msgstr ""
"El proceso principal inicia un nuevo proceso de interpretación de Python. El "
"proceso secundario solo heredará los recursos necesarios para ejecutar el "
"método :meth:`~Process.run` del objeto de proceso. En particular, los "
"identificadores y descriptores de archivo innecesarios del proceso principal "
"no se heredarán. Iniciar un proceso con este método es bastante lento en "
"comparación con *fork* o *forkserver*."

#: ../Doc/library/multiprocessing.rst:118
#, fuzzy
msgid ""
"Available on POSIX and Windows platforms.  The default on Windows and macOS."
msgstr "Disponible en Unix y Windows. Por defecto en Windows y macOS."

#: ../Doc/library/multiprocessing.rst:138
msgid "*fork*"
msgstr "*fork*"

#: ../Doc/library/multiprocessing.rst:121
msgid ""
"The parent process uses :func:`os.fork` to fork the Python interpreter.  The "
"child process, when it begins, is effectively identical to the parent "
"process.  All resources of the parent are inherited by the child process.  "
"Note that safely forking a multithreaded process is problematic."
msgstr ""
"El proceso parental usa :func:`os.fork` para bifurcar el intérprete de "
"Python. El proceso hijo, cuando comienza, es efectivamente idéntico al "
"proceso parental. Todos los recursos del proceso parental son heredados por "
"el proceso hijo. Tenga en cuenta que bifurcar (*forking*) de forma segura un "
"proceso multihilo es problemático."

#: ../Doc/library/multiprocessing.rst:127
#, fuzzy
msgid ""
"Available on POSIX systems.  Currently the default on POSIX except macOS."
msgstr "Disponible solo en Unix. Por defecto en Unix."

#: ../Doc/library/multiprocessing.rst:130
msgid ""
"The default start method will change away from *fork* in Python 3.14. Code "
"that requires *fork* should explicitly specify that via :func:`get_context` "
"or :func:`set_start_method`."
msgstr ""

#: ../Doc/library/multiprocessing.rst:134
msgid ""
"If Python is able to detect that your process has multiple threads, the :"
"func:`os.fork` function that this start method calls internally will raise "
"a :exc:`DeprecationWarning`. Use a different start method. See the :func:`os."
"fork` documentation for further explanation."
msgstr ""

#: ../Doc/library/multiprocessing.rst:151
msgid "*forkserver*"
msgstr "*forkserver*"

#: ../Doc/library/multiprocessing.rst:141
#, fuzzy
msgid ""
"When the program starts and selects the *forkserver* start method, a server "
"process is spawned.  From then on, whenever a new process is needed, the "
"parent process connects to the server and requests that it fork a new "
"process.  The fork server process is single threaded unless system libraries "
"or preloaded imports spawn threads as a side-effect so it is generally safe "
"for it to use :func:`os.fork`. No unnecessary resources are inherited."
msgstr ""
"Cuando el programa se inicia y selecciona el método de inicio *forkserver*, "
"se inicia un proceso de servidor. A partir de ese momento, cada vez que se "
"necesite un nuevo proceso, el proceso parental se conecta al servidor y "
"solicita que bifurque un nuevo proceso. El proceso del servidor *fork* es de "
"un solo hilo, por lo que es seguro usarlo :func:`os.fork`. No se heredan "
"recursos innecesarios."

#: ../Doc/library/multiprocessing.rst:149
#, fuzzy
msgid ""
"Available on POSIX platforms which support passing file descriptors over "
"Unix pipes such as Linux."
msgstr ""
"Disponible en plataformas Unix que admiten pasar descriptores de archivo a "
"través de tuberías (*pipes*) Unix."

#: ../Doc/library/multiprocessing.rst:155
#, fuzzy
msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess as macOS system libraries may start threads. See :issue:`33725`."
msgstr ""
"En macOS, el método de inicio *spawn* ahora es el predeterminado. El método "
"de inicio *fork* debe considerarse inseguro ya que puede provocar bloqueos "
"del subproceso. Consulte :issue:`33725`."

#: ../Doc/library/multiprocessing.rst:159
#, fuzzy
msgid ""
"*spawn* added on all POSIX platforms, and *forkserver* added for some POSIX "
"platforms. Child processes no longer inherit all of the parents inheritable "
"handles on Windows."
msgstr ""
"Se agregó *spawn* en todas las plataformas Unix y se agregó *forkserver* "
"para algunas plataformas Unix. Los procesos secundarios ya no heredan todos "
"los identificadores heredables principales en Windows."

#: ../Doc/library/multiprocessing.rst:165
#, fuzzy
msgid ""
"On POSIX using the *spawn* or *forkserver* start methods will also start a "
"*resource tracker* process which tracks the unlinked named system resources "
"(such as named semaphores or :class:`~multiprocessing.shared_memory."
"SharedMemory` objects) created by processes of the program.  When all "
"processes have exited the resource tracker unlinks any remaining tracked "
"object. Usually there should be none, but if a process was killed by a "
"signal there may be some \"leaked\" resources.  (Neither leaked semaphores "
"nor shared memory segments will be automatically unlinked until the next "
"reboot. This is problematic for both objects because the system allows only "
"a limited number of named semaphores, and shared memory segments occupy some "
"space in the main memory.)"
msgstr ""
"En Unix, los métodos de inicio *spawn* o *forkserver* también iniciarán un "
"proceso *resource tracker* que rastrea los recursos del sistema con nombre "
"no vinculados (como los nombrados semáforos o objetos :class:"
"`~multiprocessing.shared_memory.SharedMemory`) creado por procesos del "
"programa. Cuando todos los procesos han salido, el rastreador de recursos "
"desvincula cualquier objeto rastreado restante. Por lo general, no debería "
"haber ninguno, pero si un proceso fue eliminado por una señal, puede haber "
"algunos recursos \"filtrados\". (Ni los semáforos filtrados ni los segmentos "
"de memoria compartida se desvincularán automáticamente hasta el próximo "
"reinicio. Esto es problemático para ambos objetos porque el sistema solo "
"permite un número limitado de semáforos con nombre, y los segmentos de "
"memoria compartida ocupan algo de espacio en la memoria principal)."

#: ../Doc/library/multiprocessing.rst:178
msgid ""
"To select a start method you use the :func:`set_start_method` in the ``if "
"__name__ == '__main__'`` clause of the main module.  For example::"
msgstr ""
"Para seleccionar un método de inicio, utilice la función :func:"
"`set_start_method` en la cláusula ``if __name__ == '__main__'`` del módulo "
"principal. Por ejemplo::"

#: ../Doc/library/multiprocessing.rst:195
msgid ""
":func:`set_start_method` should not be used more than once in the program."
msgstr ""
":func:`set_start_method` no debería ser usada más de una vez en el programa."

#: ../Doc/library/multiprocessing.rst:198
msgid ""
"Alternatively, you can use :func:`get_context` to obtain a context object.  "
"Context objects have the same API as the multiprocessing module, and allow "
"one to use multiple start methods in the same program. ::"
msgstr ""
"Alternativamente, se puede usar :func:`get_context` para obtener un objeto "
"de contexto. Los objetos de contexto tienen la misma API que el módulo de "
"multiprocesamiento, y permiten utilizar múltiples métodos de inicio en el "
"mismo programa. ::"

#: ../Doc/library/multiprocessing.rst:216
msgid ""
"Note that objects related to one context may not be compatible with "
"processes for a different context.  In particular, locks created using the "
"*fork* context cannot be passed to processes started using the *spawn* or "
"*forkserver* start methods."
msgstr ""
"Tenga en cuenta que los objetos relacionados con un contexto pueden no ser "
"compatibles con procesos para un contexto diferente. En particular, los "
"*locks* creados con el contexto *fork* no se pueden pasar a los procesos "
"iniciados con los métodos de inicio *spawn* o *forkserver* ."

#: ../Doc/library/multiprocessing.rst:221
msgid ""
"A library which wants to use a particular start method should probably use :"
"func:`get_context` to avoid interfering with the choice of the library user."
msgstr ""
"Una biblioteca que quiera usar un método de inicio particular probablemente "
"debería usar :func:`get_context` para evitar interferir con la elección del "
"usuario de la biblioteca."

#: ../Doc/library/multiprocessing.rst:227
#, fuzzy
msgid ""
"The ``'spawn'`` and ``'forkserver'`` start methods generally cannot be used "
"with \"frozen\" executables (i.e., binaries produced by packages like "
"**PyInstaller** and **cx_Freeze**) on POSIX systems. The ``'fork'`` start "
"method may work if code does not use threads."
msgstr ""
"Los métodos de inicio ``'spawn'`` y ``'forkserver'`` actualmente no pueden "
"ser usados con ejecutables \"congelados\" (*frozen*)(es decir, binarios "
"producidos por paquetes como **PyInstaller** y **cx_Freeze**) en Unix. El "
"método de inicio ``'fork'`` funciona."

#: ../Doc/library/multiprocessing.rst:234
msgid "Exchanging objects between processes"
msgstr "Intercambiando objetos entre procesos"

#: ../Doc/library/multiprocessing.rst:236
msgid ""
":mod:`multiprocessing` supports two types of communication channel between "
"processes:"
msgstr ""
":mod:`multiprocessing` admite dos tipos de canales de comunicación entre "
"procesos:"

#: ../Doc/library/multiprocessing.rst:239
msgid "**Queues**"
msgstr "**Colas (*queues*)**"

#: ../Doc/library/multiprocessing.rst:241
msgid ""
"The :class:`Queue` class is a near clone of :class:`queue.Queue`.  For "
"example::"
msgstr ""
"La clase :class:`Queue` es prácticamente un clon de :class:`queue.Queue`. "
"Por ejemplo::"

#: ../Doc/library/multiprocessing.rst:256
msgid "Queues are thread and process safe."
msgstr "Las colas (*queues*) son hilos y procesos seguro."

#: ../Doc/library/multiprocessing.rst:258
msgid "**Pipes**"
msgstr "**Tuberías (*Pipes*)**"

#: ../Doc/library/multiprocessing.rst:260
msgid ""
"The :func:`Pipe` function returns a pair of connection objects connected by "
"a pipe which by default is duplex (two-way).  For example::"
msgstr ""
"La función :func:`Pipe` retorna un par de objetos de conexión conectados por "
"una tubería (*pipe*) que, por defecto, es un dúplex (bidireccional). Por "
"ejemplo::"

#: ../Doc/library/multiprocessing.rst:276
msgid ""
"The two connection objects returned by :func:`Pipe` represent the two ends "
"of the pipe.  Each connection object has :meth:`~Connection.send` and :meth:"
"`~Connection.recv` methods (among others).  Note that data in a pipe may "
"become corrupted if two processes (or threads) try to read from or write to "
"the *same* end of the pipe at the same time.  Of course there is no risk of "
"corruption from processes using different ends of the pipe at the same time."
msgstr ""
"Los dos objetos de conexión retornados por :func:`Pipe` representan los dos "
"extremos de la tubería (*pipe*). Cada objeto de conexión tiene los métodos :"
"meth:`~Connection.send` y :meth:`~Connection.recv` (entre otros). Tenga en "
"cuenta que los datos en una tubería pueden corromperse si dos procesos (o "
"hilos) intentan leer o escribir en el *mismo* (*same*) extremo de la tubería "
"al mismo tiempo. Por supuesto, no hay riesgo de corrupción por procesos que "
"utilizan diferentes extremos de la tubería (*pipe*) al mismo tiempo."

#: ../Doc/library/multiprocessing.rst:286
msgid "Synchronization between processes"
msgstr "Sincronización entre procesos"

#: ../Doc/library/multiprocessing.rst:288
msgid ""
":mod:`multiprocessing` contains equivalents of all the synchronization "
"primitives from :mod:`threading`.  For instance one can use a lock to ensure "
"that only one process prints to standard output at a time::"
msgstr ""
":mod:`multiprocessing` contiene equivalentes de todas las sincronizaciones "
"primitivas de :mod:`threading`.  Por ejemplo, se puede usar un candado "
"(*lock*) para garantizar que solo un proceso se imprima a la salida estándar "
"a la vez::"

#: ../Doc/library/multiprocessing.rst:307
msgid ""
"Without using the lock output from the different processes is liable to get "
"all mixed up."
msgstr ""
"Sin usar el candado (*lock*) de salida de los diferentes procesos, es "
"probable que todo se mezcle."

#: ../Doc/library/multiprocessing.rst:312
msgid "Sharing state between processes"
msgstr "Compartiendo estado entre procesos"

#: ../Doc/library/multiprocessing.rst:314
msgid ""
"As mentioned above, when doing concurrent programming it is usually best to "
"avoid using shared state as far as possible.  This is particularly true when "
"using multiple processes."
msgstr ""
"Como se mencionó anteriormente, cuando se realiza una programación "
"concurrente, generalmente es mejor evitar el uso del estado compartido en la "
"medida de lo posible. Esto es particularmente cierto cuando se utilizan "
"múltiples procesos."

#: ../Doc/library/multiprocessing.rst:318
msgid ""
"However, if you really do need to use some shared data then :mod:"
"`multiprocessing` provides a couple of ways of doing so."
msgstr ""
"Sin embargo, si usted realmente necesita usar algunos datos compartidos el :"
"mod:`multiprocessing` proporciona un par de maneras de hacerlo."

#: ../Doc/library/multiprocessing.rst:321
msgid "**Shared memory**"
msgstr "**Memoria compartida**"

#: ../Doc/library/multiprocessing.rst:323
msgid ""
"Data can be stored in a shared memory map using :class:`Value` or :class:"
"`Array`.  For example, the following code ::"
msgstr ""
"Los datos se pueden almacenar en un mapa de memoria compartida usando :class:"
"`Value` o :class:`Array`. Por ejemplo, el siguiente código ::"

#: ../Doc/library/multiprocessing.rst:344
#: ../Doc/library/multiprocessing.rst:390
msgid "will print ::"
msgstr "imprimirá ::"

#: ../Doc/library/multiprocessing.rst:349
msgid ""
"The ``'d'`` and ``'i'`` arguments used when creating ``num`` and ``arr`` are "
"typecodes of the kind used by the :mod:`array` module: ``'d'`` indicates a "
"double precision float and ``'i'`` indicates a signed integer.  These shared "
"objects will be process and thread-safe."
msgstr ""
"Los argumentos ``'d'`` y ``'i'`` utilizados al crear ``num`` y ``arr`` son "
"códigos de tipo del tipo utilizado por :mod:`array` module: ``'d'`` indica "
"un flotador de doble precisión y ``'i'`` indica un entero con signo. Estos "
"objetos compartidos serán seguros para procesos y subprocesos."

#: ../Doc/library/multiprocessing.rst:354
msgid ""
"For more flexibility in using shared memory one can use the :mod:"
"`multiprocessing.sharedctypes` module which supports the creation of "
"arbitrary ctypes objects allocated from shared memory."
msgstr ""
"Para una mayor flexibilidad en el uso de la memoria compartida, se puede "
"usar el módulo :mod:`multiprocessing.sharedctypes` que admite la creación "
"arbitraria de objetos *ctypes* asignados desde la memoria compartida."

#: ../Doc/library/multiprocessing.rst:358
msgid "**Server process**"
msgstr "**Proceso servidor (*Server process*)**"

#: ../Doc/library/multiprocessing.rst:360
msgid ""
"A manager object returned by :func:`Manager` controls a server process which "
"holds Python objects and allows other processes to manipulate them using "
"proxies."
msgstr ""
"Un objeto de administrador retornado por :func:`Manager` controla un proceso "
"de servidor que contiene objetos de Python y permite que otros procesos los "
"manipulen usando proxies."

#: ../Doc/library/multiprocessing.rst:364
msgid ""
"A manager returned by :func:`Manager` will support types :class:`list`, :"
"class:`dict`, :class:`~managers.Namespace`, :class:`Lock`, :class:`RLock`, :"
"class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, :class:"
"`Event`, :class:`Barrier`, :class:`Queue`, :class:`Value` and :class:"
"`Array`.  For example, ::"
msgstr ""
"Un administrador retornado por :func:`Manager` soportará tipos de clases  "
"como :class:`list`, :class:`dict`, :class:`~managers.Namespace`, :class:"
"`Lock`, :class:`RLock`, :class:`Semaphore`, :class:`BoundedSemaphore`, :"
"class:`Condition`, :class:`Event`, :class:`Barrier`, :class:`Queue`, :class:"
"`Value` y :class:`Array`.  Por ejemplo, ::"

#: ../Doc/library/multiprocessing.rst:395
msgid ""
"Server process managers are more flexible than using shared memory objects "
"because they can be made to support arbitrary object types.  Also, a single "
"manager can be shared by processes on different computers over a network. "
"They are, however, slower than using shared memory."
msgstr ""
"Los administradores de procesos del servidor son más flexibles que el uso de "
"objetos de memoria compartida porque pueden hacerse para admitir tipos de "
"objetos arbitrarios. Por lo tanto, un solo administrador puede ser "
"compartido por procesos en diferentes ordenadores a través de una red. Sin "
"embargo, son más lentos que usar memoria compartida."

#: ../Doc/library/multiprocessing.rst:402
msgid "Using a pool of workers"
msgstr "Usando una piscina de trabajadores (*pool of workers*)"

#: ../Doc/library/multiprocessing.rst:404
msgid ""
"The :class:`~multiprocessing.pool.Pool` class represents a pool of worker "
"processes.  It has methods which allows tasks to be offloaded to the worker "
"processes in a few different ways."
msgstr ""
"La clase :class:`~multiprocessing.pool.Pool` representa procesos de piscina "
"de trabajadores (*pool of workers*). Tiene métodos que permiten que las "
"tareas se descarguen a los procesos de trabajo de diferentes maneras."

#: ../Doc/library/multiprocessing.rst:408
msgid "For example::"
msgstr "Por ejemplo::"

#: ../Doc/library/multiprocessing.rst:452
msgid ""
"Note that the methods of a pool should only ever be used by the process "
"which created it."
msgstr ""
"Tenga en cuenta que los métodos de una piscina (*pool*) solo deben ser "
"utilizados por el proceso que lo creó."

#: ../Doc/library/multiprocessing.rst:457
msgid ""
"Functionality within this package requires that the ``__main__`` module be "
"importable by the children. This is covered in :ref:`multiprocessing-"
"programming` however it is worth pointing out here. This means that some "
"examples, such as the :class:`multiprocessing.pool.Pool` examples will not "
"work in the interactive interpreter. For example::"
msgstr ""
"La funcionalidad en este paquete requiere que los procesos hijos "
"(*children*) puedan importar el módulo ``__main__``. Esto está cubierto en :"
"ref:`multiprocessing-programming` sin embargo, vale la pena señalarlo aquí. "
"Esto significa que algunos ejemplos, como :class:`multiprocessing.pool.Pool` "
"no funcionarán en el intérprete interactivo. Por ejemplo::"

#: ../Doc/library/multiprocessing.rst:480
msgid ""
"(If you try this it will actually output three full tracebacks interleaved "
"in a semi-random fashion, and then you may have to stop the parent process "
"somehow.)"
msgstr ""
"(Si intenta esto, en realidad generará tres trazas completas intercaladas de "
"forma semialeatoria, y luego tendrá que detener el proceso principal de "
"alguna manera)"

#: ../Doc/library/multiprocessing.rst:486
msgid "Reference"
msgstr "Referencia"

#: ../Doc/library/multiprocessing.rst:488
msgid ""
"The :mod:`multiprocessing` package mostly replicates the API of the :mod:"
"`threading` module."
msgstr ""
"El paquete :mod:`multiprocessing` mayoritariamente replica la API del "
"módulo :mod:`threading`."

#: ../Doc/library/multiprocessing.rst:493
msgid ":class:`Process` and exceptions"
msgstr ":class:`Process` y excepciones"

#: ../Doc/library/multiprocessing.rst:498
msgid ""
"Process objects represent activity that is run in a separate process. The :"
"class:`Process` class has equivalents of all the methods of :class:"
"`threading.Thread`."
msgstr ""
"Los objetos de proceso representan la actividad que se ejecuta en un proceso "
"separado. La clase :class:`Process` tiene equivalentes para todos los "
"métodos :class:`threading.Thread`."

#: ../Doc/library/multiprocessing.rst:502
msgid ""
"The constructor should always be called with keyword arguments. *group* "
"should always be ``None``; it exists solely for compatibility with :class:"
"`threading.Thread`.  *target* is the callable object to be invoked by the :"
"meth:`run()` method.  It defaults to ``None``, meaning nothing is called. "
"*name* is the process name (see :attr:`name` for more details). *args* is "
"the argument tuple for the target invocation.  *kwargs* is a dictionary of "
"keyword arguments for the target invocation.  If provided, the keyword-only "
"*daemon* argument sets the process :attr:`daemon` flag to ``True`` or "
"``False``.  If ``None`` (the default), this flag will be inherited from the "
"creating process."
msgstr ""
"El constructor siempre debe llamarse con argumentos de palabras clave. "
"*group* siempre debe ser ``None``; existe únicamente por compatibilidad con :"
"class:`threading.Thread`. *target* es el objeto invocable a ser llamado por "
"el método :meth:`run()` . El valor predeterminado es ``None``, lo que "
"significa que nada es llamado. *name* es el nombre del proceso (consulte :"
"attr:`name` para más detalles). *args* es la tupla de argumento para la "
"invocación de destino. *kwargs* es un diccionario de argumentos de palabras "
"clave para la invocación de destino. Si se proporciona, el argumento "
"*daemon* solo de palabra clave establece el proceso :attr:`daemon` en "
"``True`` o ``False``.  Si ``None`` (el valor predeterminado), este indicador "
"se heredará del proceso de creación."

#: ../Doc/library/multiprocessing.rst:513
msgid ""
"By default, no arguments are passed to *target*. The *args* argument, which "
"defaults to ``()``, can be used to specify a list or tuple of the arguments "
"to pass to *target*."
msgstr ""
"De forma predeterminada, no se pasan argumentos a *target*. El argumento "
"*args*, que por defecto es ``()``, se puede usar para especificar una lista "
"o tupla de los argumentos para pasar a *target*."

#: ../Doc/library/multiprocessing.rst:517
msgid ""
"If a subclass overrides the constructor, it must make sure it invokes the "
"base class constructor (:meth:`Process.__init__`) before doing anything else "
"to the process."
msgstr ""
"Si una subclase anula al constructor, debe asegurarse de que invoca al "
"constructor de la clase base (:meth:`Process.__init__`) antes de hacer "
"cualquier otra cosa al proceso."

#: ../Doc/library/multiprocessing.rst:521
msgid "Added the *daemon* argument."
msgstr "Añadido el argumento *daemon*."

#: ../Doc/library/multiprocessing.rst:526
msgid "Method representing the process's activity."
msgstr "Método que representa la actividad del proceso."

#: ../Doc/library/multiprocessing.rst:528
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the target "
"argument, if any, with sequential and keyword arguments taken from the "
"*args* and *kwargs* arguments, respectively."
msgstr ""
"Puede anular este método en una subclase. El método estándar :meth:`run` "
"invoca el objeto invocable pasado al constructor del objeto como argumento "
"objetivo, si lo hay, con argumentos posicionares y de palabras clave tomados "
"de los argumentos *args* y *kwargs*, respectivamente."

#: ../Doc/library/multiprocessing.rst:533
msgid ""
"Using a list or tuple as the *args* argument passed to :class:`Process` "
"achieves the same effect."
msgstr ""
"El uso de una lista o tupla como argumento *args* pasado a :class:`Process` "
"logra el mismo efecto."

#: ../Doc/library/multiprocessing.rst:536
msgid "Example::"
msgstr "Ejemplo::"

#: ../Doc/library/multiprocessing.rst:548
msgid "Start the process's activity."
msgstr "Comienza la actividad del proceso."

#: ../Doc/library/multiprocessing.rst:550
msgid ""
"This must be called at most once per process object.  It arranges for the "
"object's :meth:`run` method to be invoked in a separate process."
msgstr ""
"Esto debe llamarse como máximo una vez por objeto de proceso. Organiza la "
"invocación del método :meth:`run` del objeto en un proceso separado."

#: ../Doc/library/multiprocessing.rst:555
msgid ""
"If the optional argument *timeout* is ``None`` (the default), the method "
"blocks until the process whose :meth:`join` method is called terminates. If "
"*timeout* is a positive number, it blocks at most *timeout* seconds. Note "
"that the method returns ``None`` if its process terminates or if the method "
"times out.  Check the process's :attr:`exitcode` to determine if it "
"terminated."
msgstr ""
"Si el argumento opcional *timeout* es ``None`` (el valor predeterminado), el "
"método se bloquea hasta que el proceso cuyo método :meth:`join` se llama "
"termina. Si *timeout* es un número positivo, bloquea como máximo *timeout* "
"segundos. Tenga en cuenta que el método retorna ``None`` si su proceso "
"finaliza o si el método agota el tiempo de espera. Verifique el proceso :"
"attr:`exitcode` para determinar si terminó."

#: ../Doc/library/multiprocessing.rst:562
msgid "A process can be joined many times."
msgstr "Un proceso puede unirse muchas veces."

#: ../Doc/library/multiprocessing.rst:564
msgid ""
"A process cannot join itself because this would cause a deadlock.  It is an "
"error to attempt to join a process before it has been started."
msgstr ""
"Un proceso no puede unirse a sí mismo porque esto provocaría un punto "
"muerto. Es un error intentar unirse a un proceso antes de que se haya "
"iniciado."

#: ../Doc/library/multiprocessing.rst:569
msgid ""
"The process's name.  The name is a string used for identification purposes "
"only.  It has no semantics.  Multiple processes may be given the same name."
msgstr ""
"El nombre del proceso. El nombre es una cadena utilizada solo con fines de "
"identificación. No tiene semántica. Múltiples procesos pueden tener el mismo "
"nombre."

#: ../Doc/library/multiprocessing.rst:573
msgid ""
"The initial name is set by the constructor.  If no explicit name is provided "
"to the constructor, a name of the form 'Process-N\\ :sub:`1`:N\\ :sub:"
"`2`:...:N\\ :sub:`k`' is constructed, where each N\\ :sub:`k` is the N-th "
"child of its parent."
msgstr ""
"El nombre inicial es establecido por el constructor. Si no se proporciona un "
"nombre explícito al constructor, se forma un nombre usando *'Process-N\\ :"
"sub:`1`:N\\ :sub:`2`:...:N\\ :sub:`k`'* se construye, donde cada *N\\ :sub:"
"`k`* es el *N-enésimo* hijo del parental."

#: ../Doc/library/multiprocessing.rst:580
msgid "Return whether the process is alive."
msgstr "Retorna si el proceso está vivo."

#: ../Doc/library/multiprocessing.rst:582
msgid ""
"Roughly, a process object is alive from the moment the :meth:`start` method "
"returns until the child process terminates."
msgstr ""
"Aproximadamente, un objeto de proceso está vivo desde el momento en que el "
"método :meth:`start` retorna hasta que finaliza el proceso hijo."

#: ../Doc/library/multiprocessing.rst:587
msgid ""
"The process's daemon flag, a Boolean value.  This must be set before :meth:"
"`start` is called."
msgstr ""
"La bandera del proceso *daemon* , es un valor booleano. Esto debe "
"establecerse antes de que :meth:`start` sea llamado."

#: ../Doc/library/multiprocessing.rst:590
msgid "The initial value is inherited from the creating process."
msgstr "El valor inicial se hereda del proceso de creación."

#: ../Doc/library/multiprocessing.rst:592
msgid ""
"When a process exits, it attempts to terminate all of its daemonic child "
"processes."
msgstr ""
"Cuando un proceso sale, intenta terminar todos sus procesos demoníacos "
"(*daemonic*) hijos."

#: ../Doc/library/multiprocessing.rst:595
msgid ""
"Note that a daemonic process is not allowed to create child processes. "
"Otherwise a daemonic process would leave its children orphaned if it gets "
"terminated when its parent process exits. Additionally, these are **not** "
"Unix daemons or services, they are normal processes that will be terminated "
"(and not joined) if non-daemonic processes have exited."
msgstr ""
"Tenga en cuenta que un proceso demoníaco (*daemonic*) no puede crear "
"procesos hijos. De lo contrario, un proceso demoníaco (*daemonic*) dejaría a "
"sus hijos huérfanos si se termina cuando finaliza su proceso parental. "
"Además, estos **no** son *daemons* o servicios de Unix, son procesos "
"normales qué finalizarán (y no se unirán) si los procesos no demoníacos han "
"salido."

#: ../Doc/library/multiprocessing.rst:601
msgid ""
"In addition to the  :class:`threading.Thread` API, :class:`Process` objects "
"also support the following attributes and methods:"
msgstr ""
"Además de API :class:`threading.Thread`, los objetos :class:`Process` "
"también admiten los siguientes atributos y métodos:"

#: ../Doc/library/multiprocessing.rst:606
msgid ""
"Return the process ID.  Before the process is spawned, this will be ``None``."
msgstr ""
"Retorna el ID del proceso. Antes de que se genere el proceso, esto será "
"``None``."

#: ../Doc/library/multiprocessing.rst:611
msgid ""
"The child's exit code.  This will be ``None`` if the process has not yet "
"terminated."
msgstr ""
"El código de salida del proceso secundario. Será ``None`` si el proceso aún "
"no ha finalizado."

#: ../Doc/library/multiprocessing.rst:614
msgid ""
"If the child's :meth:`run` method returned normally, the exit code will be "
"0.  If it terminated via :func:`sys.exit` with an integer argument *N*, the "
"exit code will be *N*."
msgstr ""
"Si el método :meth:`run` del proceso secundario se retornó normalmente, el "
"código de salida será 0. Si terminó a través de :func:`sys.exit` con un "
"argumento entero *N*, el código de salida será *N*."

#: ../Doc/library/multiprocessing.rst:618
msgid ""
"If the child terminated due to an exception not caught within :meth:`run`, "
"the exit code will be 1.  If it was terminated by signal *N*, the exit code "
"will be the negative value *-N*."
msgstr ""
"Si el proceso secundario finalizó debido a una excepción no capturada dentro "
"de :meth:`run`, el código de salida será 1. Si fue terminado por la señal "
"*N*, el código de salida será el valor negativo *-N*."

#: ../Doc/library/multiprocessing.rst:624
msgid "The process's authentication key (a byte string)."
msgstr "La clave de autenticación del proceso (una cadena de bytes)."

#: ../Doc/library/multiprocessing.rst:626
msgid ""
"When :mod:`multiprocessing` is initialized the main process is assigned a "
"random string using :func:`os.urandom`."
msgstr ""
"Cuando el :mod:`multiprocessing` se inicializa el proceso principal se le "
"asigna una cadena aleatoria usando :func:`os.urandom`."

#: ../Doc/library/multiprocessing.rst:629
msgid ""
"When a :class:`Process` object is created, it will inherit the "
"authentication key of its parent process, although this may be changed by "
"setting :attr:`authkey` to another byte string."
msgstr ""
"Cuando se crea un objeto :class:`Process`, este heredará la clave de "
"autenticación de su proceso parental, aunque esto puede cambiarse "
"configurando :attr:`authkey` a otra cadena de bytes."

#: ../Doc/library/multiprocessing.rst:633
msgid "See :ref:`multiprocessing-auth-keys`."
msgstr "Consulte :ref:`multiprocessing-auth-keys`."

#: ../Doc/library/multiprocessing.rst:637
msgid ""
"A numeric handle of a system object which will become \"ready\" when the "
"process ends."
msgstr ""
"Un identificador numérico de un objeto del sistema que estará \"listo\" "
"cuando finalice el proceso."

#: ../Doc/library/multiprocessing.rst:640
msgid ""
"You can use this value if you want to wait on several events at once using :"
"func:`multiprocessing.connection.wait`.  Otherwise calling :meth:`join()` is "
"simpler."
msgstr ""
"Se puede usar este valor si desea esperar varios eventos a la vez usando :"
"func:`multiprocessing.connection.wait`. De lo contrario, llamar a :meth:"
"`join()` es más simple."

#: ../Doc/library/multiprocessing.rst:644
#, fuzzy
msgid ""
"On Windows, this is an OS handle usable with the ``WaitForSingleObject`` and "
"``WaitForMultipleObjects`` family of API calls.  On POSIX, this is a file "
"descriptor usable with primitives from the :mod:`select` module."
msgstr ""
"En Windows, este es un sistema operativo manejable con la familia de "
"llamadas API ``WaitForSingleObject`` y ``WaitForMultipleObjects``. En Unix, "
"este es un descriptor de archivo utilizable con primitivas del módulo :mod:"
"`select`."

#: ../Doc/library/multiprocessing.rst:652
#, fuzzy
msgid ""
"Terminate the process.  On POSIX this is done using the ``SIGTERM`` signal; "
"on Windows :c:func:`TerminateProcess` is used.  Note that exit handlers and "
"finally clauses, etc., will not be executed."
msgstr ""
"Terminar el proceso. En Unix, esto se hace usando la señal ``SIGTERM``; en "
"Windows se utiliza :c:func:`TerminateProcess` . Tenga en cuenta que los "
"manejadores de salida y finalmente las cláusulas, etc., no se ejecutarán."

#: ../Doc/library/multiprocessing.rst:656
msgid ""
"Note that descendant processes of the process will *not* be terminated -- "
"they will simply become orphaned."
msgstr ""
"Tenga en cuenta que los procesos descendientes del proceso *no* finalizarán "
"-- simplemente quedarán huérfanos."

#: ../Doc/library/multiprocessing.rst:661
msgid ""
"If this method is used when the associated process is using a pipe or queue "
"then the pipe or queue is liable to become corrupted and may become unusable "
"by other process.  Similarly, if the process has acquired a lock or "
"semaphore etc. then terminating it is liable to cause other processes to "
"deadlock."
msgstr ""
"Si este método se usa cuando el proceso asociado está usando una tubería "
"(*pipe*) o una cola(*queue*), entonces la tubería o la cola pueden "
"corromperse y pueden quedar inutilizables por otro proceso. Del mismo modo, "
"si el proceso ha adquirido un *lock* o un semáforo, etc., su finalización "
"puede provocar el bloqueo de otros procesos."

#: ../Doc/library/multiprocessing.rst:669
#, fuzzy
msgid "Same as :meth:`terminate()` but using the ``SIGKILL`` signal on POSIX."
msgstr ""
"Siempre como :meth:`terminate()` pero utilizando la señal ``SIGKILL`` en "
"Unix."

#: ../Doc/library/multiprocessing.rst:675
msgid ""
"Close the :class:`Process` object, releasing all resources associated with "
"it.  :exc:`ValueError` is raised if the underlying process is still "
"running.  Once :meth:`close` returns successfully, most other methods and "
"attributes of the :class:`Process` object will raise :exc:`ValueError`."
msgstr ""
"El cierre del objeto :class:`Process`, libera todos los recursos asociados a "
"él.  :exc:`ValueError` se lanza si el proceso subyacente aún se está "
"ejecutando. Una vez :meth:`close` se retorna con éxito, la mayoría de los "
"otros métodos y atributos del objeto :class:`Process` lanzará :exc:"
"`ValueError`."

#: ../Doc/library/multiprocessing.rst:683
msgid ""
"Note that the :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:"
"`terminate` and :attr:`exitcode` methods should only be called by the "
"process that created the process object."
msgstr ""
"Tenga en cuenta que los métodos :meth:`start`, :meth:`join`, :meth:"
"`is_alive`, :meth:`terminate` y :attr:`exitcode` deberían solo ser llamados "
"por el proceso que creó el objeto del proceso."

#: ../Doc/library/multiprocessing.rst:687
msgid "Example usage of some of the methods of :class:`Process`:"
msgstr "Ejemplo de uso de algunos métodos de la :class:`Process`:"

#: ../Doc/library/multiprocessing.rst:708
msgid "The base class of all :mod:`multiprocessing` exceptions."
msgstr "La clase base de todas las excepciones :mod:`multiprocessing`."

#: ../Doc/library/multiprocessing.rst:712
msgid ""
"Exception raised by :meth:`Connection.recv_bytes_into()` when the supplied "
"buffer object is too small for the message read."
msgstr ""
"La excepción :meth:`Connection.recv_bytes_into()` es lanzada cuando el "
"objeto de búfer suministrado es demasiado pequeño para el mensaje leído."

#: ../Doc/library/multiprocessing.rst:715
msgid ""
"If ``e`` is an instance of :exc:`BufferTooShort` then ``e.args[0]`` will "
"give the message as a byte string."
msgstr ""
"Si ``e`` es una instancia de :exc:`BufferTooShort` entonces ``e.args[0]`` "
"dará el mensaje como una cadena de *bytes*."

#: ../Doc/library/multiprocessing.rst:720
msgid "Raised when there is an authentication error."
msgstr "Lanzada cuando hay un error de autenticación."

#: ../Doc/library/multiprocessing.rst:724
msgid "Raised by methods with a timeout when the timeout expires."
msgstr ""
"Lanzada por métodos con un tiempo de espera (*timeout*) cuando este expira."

#: ../Doc/library/multiprocessing.rst:727
msgid "Pipes and Queues"
msgstr "Tuberías (*Pipes*) y Colas (*Queues*)"

#: ../Doc/library/multiprocessing.rst:729
msgid ""
"When using multiple processes, one generally uses message passing for "
"communication between processes and avoids having to use any synchronization "
"primitives like locks."
msgstr ""
"Cuando se usan múltiples procesos, uno generalmente usa el paso de mensajes "
"para la comunicación entre procesos y evita tener que usar primitivas de "
"sincronización como *locks*."

#: ../Doc/library/multiprocessing.rst:733
msgid ""
"For passing messages one can use :func:`Pipe` (for a connection between two "
"processes) or a queue (which allows multiple producers and consumers)."
msgstr ""
"Para pasar mensajes se puede usar :func:`Pipe` (para una conexión entre dos "
"procesos) o una cola (*queue*)(que permite múltiples productores y "
"consumidores)."

#: ../Doc/library/multiprocessing.rst:736
msgid ""
"The :class:`Queue`, :class:`SimpleQueue` and :class:`JoinableQueue` types "
"are multi-producer, multi-consumer :abbr:`FIFO (first-in, first-out)` queues "
"modelled on the :class:`queue.Queue` class in the standard library.  They "
"differ in that :class:`Queue` lacks the :meth:`~queue.Queue.task_done` and :"
"meth:`~queue.Queue.join` methods introduced into Python 2.5's :class:`queue."
"Queue` class."
msgstr ""
"Los tipos :class:`Queue`, :class:`SimpleQueue` y :class:`JoinableQueue` son "
"colas multi-productor, multi-consumidor :abbr:`FIFO (first-in, first-out)` "
"(primero en entrar, primero en salir) modeladas en :class:`queue.Queue` en "
"la biblioteca estándar. Se diferencian en que :class:`Queue` carece de :meth:"
"`~queue.Queue.task_done` y :meth:`~queue.Queue.join` métodos introducidos en "
"Python 2.5 :class:`queue.Queue` class."

#: ../Doc/library/multiprocessing.rst:743
msgid ""
"If you use :class:`JoinableQueue` then you **must** call :meth:"
"`JoinableQueue.task_done` for each task removed from the queue or else the "
"semaphore used to count the number of unfinished tasks may eventually "
"overflow, raising an exception."
msgstr ""
"Si usa :class:`JoinableQueue`, entonces **debe** llamar a :meth:"
"`JoinableQueue.task_done` para cada tarea eliminada de la cola (*queue*) o "
"de lo contrario el semáforo utilizado para contar el número de tareas sin "
"terminar puede eventualmente desbordarse, lanzando un excepción."

#: ../Doc/library/multiprocessing.rst:748
msgid ""
"Note that one can also create a shared queue by using a manager object -- "
"see :ref:`multiprocessing-managers`."
msgstr ""
"Tenga en cuenta que también se puede crear una cola compartida mediante el "
"uso de un objeto de administrador -- consulte :ref:`multiprocessing-"
"managers`."

#: ../Doc/library/multiprocessing.rst:753
msgid ""
":mod:`multiprocessing` uses the usual :exc:`queue.Empty` and :exc:`queue."
"Full` exceptions to signal a timeout.  They are not available in the :mod:"
"`multiprocessing` namespace so you need to import them from :mod:`queue`."
msgstr ""
":mod:`multiprocessing` utiliza las excepciones habituales :exc:`queue.Empty` "
"y :exc:`queue.Full` para indicar un tiempo de espera. No están disponibles "
"en el espacio de nombres :mod:`multiprocessing`, por lo que debe importarlos "
"desde :mod:`queue`."

#: ../Doc/library/multiprocessing.rst:760
msgid ""
"When an object is put on a queue, the object is pickled and a background "
"thread later flushes the pickled data to an underlying pipe.  This has some "
"consequences which are a little surprising, but should not cause any "
"practical difficulties -- if they really bother you then you can instead use "
"a queue created with a :ref:`manager <multiprocessing-managers>`."
msgstr ""
"Cuando un objeto se coloca en una cola (*queue*), el objeto se serializa "
"(*pickled*) y luego un subproceso de fondo vacía los datos serializados a "
"una tubería (*pipe*) subyacente. Esto tiene algunas consecuencias que son un "
"poco sorprendentes, pero no deberían causar dificultades prácticas: si "
"realmente causan molestias, se puede usar una cola creada con un :ref:"
"`manager <multiprocessing-managers>`."

#: ../Doc/library/multiprocessing.rst:767
msgid ""
"After putting an object on an empty queue there may be an infinitesimal "
"delay before the queue's :meth:`~Queue.empty` method returns :const:`False` "
"and :meth:`~Queue.get_nowait` can return without raising :exc:`queue.Empty`."
msgstr ""
"Después de poner un objeto en una cola vacía, puede haber un retraso "
"infinitesimal antes de que el método de la cola :meth:`~Queue.empty` "
"retorne :const:`False` y :meth:`~Queue.get_nowait` puede retornar sin "
"lanzar :exc:`queue.Empty`."

#: ../Doc/library/multiprocessing.rst:772
msgid ""
"If multiple processes are enqueuing objects, it is possible for the objects "
"to be received at the other end out-of-order. However, objects enqueued by "
"the same process will always be in the expected order with respect to each "
"other."
msgstr ""
"Si varios procesos están poniendo en cola objetos, es posible que los "
"objetos se reciban en el otro extremo fuera de orden. Sin embargo, los "
"objetos en cola por el mismo proceso siempre estarán en el orden esperado "
"entre sí."

#: ../Doc/library/multiprocessing.rst:779
msgid ""
"If a process is killed using :meth:`Process.terminate` or :func:`os.kill` "
"while it is trying to use a :class:`Queue`, then the data in the queue is "
"likely to become corrupted.  This may cause any other process to get an "
"exception when it tries to use the queue later on."
msgstr ""
"Si se termina un proceso usando :meth:`Process.terminate` o :func:`os.kill` "
"mientras intenta usar una clase :class:`Queue`, es probable que los datos de "
"la cola(*queue*) se corrompan. Esto puede hacer que cualquier otro proceso "
"obtenga una excepción cuando intente usar la cola más adelante."

#: ../Doc/library/multiprocessing.rst:786
msgid ""
"As mentioned above, if a child process has put items on a queue (and it has "
"not used :meth:`JoinableQueue.cancel_join_thread <multiprocessing.Queue."
"cancel_join_thread>`), then that process will not terminate until all "
"buffered items have been flushed to the pipe."
msgstr ""
"Como se mencionó anteriormente, si un proceso hijo ha puesto elementos en "
"una cola (*queue*) (y no ha utilizado :meth:`JoinableQueue."
"cancel_join_thread <multiprocessing.Queue.cancel_join_thread>`), entonces "
"ese proceso no terminará hasta que todos los elementos almacenados en búfer "
"hayan sido vaciados a la tubería (*pipe*)."

#: ../Doc/library/multiprocessing.rst:791
msgid ""
"This means that if you try joining that process you may get a deadlock "
"unless you are sure that all items which have been put on the queue have "
"been consumed.  Similarly, if the child process is non-daemonic then the "
"parent process may hang on exit when it tries to join all its non-daemonic "
"children."
msgstr ""
"Esto significa que si intenta unirse a ese proceso, puede obtener un punto "
"muerto a menos que esté seguro de que todos los elementos que se han puesto "
"en la cola (*queue*) se han consumido. Del mismo modo, si el proceso hijo no "
"es *daemonic*, el proceso parental puede bloquearse en la salida cuando "
"intenta unir todos sus elementos hijos no *daemonic*."

#: ../Doc/library/multiprocessing.rst:796
msgid ""
"Note that a queue created using a manager does not have this issue.  See :"
"ref:`multiprocessing-programming`."
msgstr ""
"Tenga en cuenta que una cola (*queue*) creada con un administrador no tiene "
"este problema. Consulte :ref:`multiprocessing-programming`."

#: ../Doc/library/multiprocessing.rst:799
msgid ""
"For an example of the usage of queues for interprocess communication see :"
"ref:`multiprocessing-examples`."
msgstr ""
"Para ver un ejemplo del uso de colas para la comunicación entre procesos, "
"consulte :ref:`multiprocessing-examples`."

#: ../Doc/library/multiprocessing.rst:805
msgid ""
"Returns a pair ``(conn1, conn2)`` of :class:`~multiprocessing.connection."
"Connection` objects representing the ends of a pipe."
msgstr ""
"Retorna un par de objetos *``(conn1, conn2)``* de la :class:"
"`~multiprocessing.connection.Connection` que representan los extremos de una "
"tubería (*pipe*)."

#: ../Doc/library/multiprocessing.rst:809
msgid ""
"If *duplex* is ``True`` (the default) then the pipe is bidirectional.  If "
"*duplex* is ``False`` then the pipe is unidirectional: ``conn1`` can only be "
"used for receiving messages and ``conn2`` can only be used for sending "
"messages."
msgstr ""
"Si *duplex* es ``True`` (el valor predeterminado), entonces la tubería "
"(*pipe*) es bidireccional. Si *duplex* es ``False``, entonces la tubería es "
"unidireccional: ``conn1`` solo se puede usar para recibir mensajes y "
"``conn2`` solo se puede usar para enviar mensajes."

#: ../Doc/library/multiprocessing.rst:817
msgid ""
"Returns a process shared queue implemented using a pipe and a few locks/"
"semaphores.  When a process first puts an item on the queue a feeder thread "
"is started which transfers objects from a buffer into the pipe."
msgstr ""
"Retorna un proceso de cola (*queue*) compartida implementado utilizando una "
"tubería (*pipe*) y algunos candados/semáforos (*locks/semaphores*). Cuando "
"un proceso pone por primera vez un elemento en la cola, se inicia un hilo "
"alimentador que transfiere objetos desde un búfer a la tubería."

#: ../Doc/library/multiprocessing.rst:821
msgid ""
"The usual :exc:`queue.Empty` and :exc:`queue.Full` exceptions from the "
"standard library's :mod:`queue` module are raised to signal timeouts."
msgstr ""
"Las excepciones habituales :exc:`queue.Empty` y :exc:`queue.Full` del módulo "
"de la biblioteca estándar :mod:`queue` se generan para indicar tiempos de "
"espera."

#: ../Doc/library/multiprocessing.rst:824
msgid ""
":class:`Queue` implements all the methods of :class:`queue.Queue` except "
"for :meth:`~queue.Queue.task_done` and :meth:`~queue.Queue.join`."
msgstr ""
"La :class:`Queue` implementa todos los métodos de la :class:`queue.Queue` "
"excepto por :meth:`~queue.Queue.task_done` y :meth:`~queue.Queue.join`."

#: ../Doc/library/multiprocessing.rst:829
msgid ""
"Return the approximate size of the queue.  Because of multithreading/"
"multiprocessing semantics, this number is not reliable."
msgstr ""
"Retorna el tamaño aproximado de la cola (*queue*). Debido a la semántica "
"multiproceso/multiprocesamiento, este número no es confiable."

#: ../Doc/library/multiprocessing.rst:832
#, fuzzy
msgid ""
"Note that this may raise :exc:`NotImplementedError` on platforms like macOS "
"where ``sem_getvalue()`` is not implemented."
msgstr ""
"Tenga en cuenta que esto puede lanzar :exc:`NotImplementedError` en "
"plataformas Unix como macOS donde ``sem_getvalue()`` no está implementado."

#: ../Doc/library/multiprocessing.rst:837
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"Retorna ``True`` si la cola (*queue*) está vacía, de lo contrario retorna "
"``False`` . Debido a la semántica multiproceso/multiprocesamiento, esto no "
"es confiable."

#: ../Doc/library/multiprocessing.rst:842
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"Retorna ``True`` si la cola (*queue*) está llena, de lo contrario retorna "
"``False`` . Debido a la semántica multiproceso/multiprocesamiento, esto no "
"es confiable."

#: ../Doc/library/multiprocessing.rst:847
msgid ""
"Put obj into the queue.  If the optional argument *block* is ``True`` (the "
"default) and *timeout* is ``None`` (the default), block if necessary until a "
"free slot is available.  If *timeout* is a positive number, it blocks at "
"most *timeout* seconds and raises the :exc:`queue.Full` exception if no free "
"slot was available within that time.  Otherwise (*block* is ``False``), put "
"an item on the queue if a free slot is immediately available, else raise "
"the :exc:`queue.Full` exception (*timeout* is ignored in that case)."
msgstr ""
"Pone *obj* en la cola. Si el argumento opcional *block* es ``True`` (el "
"valor predeterminado) y *timeout* es ``None`` (el valor predeterminado), se "
"bloquea si es necesario hasta que haya un espacio disponible. Si *timeout* "
"es un número positivo, bloquea a lo sumo *timeout* segundos y genera la "
"excepción :exc:`queue.Full` si no hay espacio libre disponible en ese "
"tiempo. De lo contrario (*block* es ``False``), y coloca un elemento en la "
"cola si hay un espacio libre disponible de inmediato, de lo contrario, "
"genera la excepción :exc:`queue.Full` (*timeout* se ignora en ese caso)."

#: ../Doc/library/multiprocessing.rst:856
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr ""
"Si la cola (*queue*) está cerrada, :exc:`ValueError` se lanza en lugar de :"
"exc:`AssertionError`."

#: ../Doc/library/multiprocessing.rst:862
msgid "Equivalent to ``put(obj, False)``."
msgstr "Equivalente a ``put(obj, False)``."

#: ../Doc/library/multiprocessing.rst:866
msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"``True`` (the default) and *timeout* is ``None`` (the default), block if "
"necessary until an item is available.  If *timeout* is a positive number, it "
"blocks at most *timeout* seconds and raises the :exc:`queue.Empty` exception "
"if no item was available within that time.  Otherwise (block is ``False``), "
"return an item if one is immediately available, else raise the :exc:`queue."
"Empty` exception (*timeout* is ignored in that case)."
msgstr ""
"Elimina y retorna un artículo de la cola (*queue*). Si un argumento opcional "
"*block* es ``True`` (el valor predeterminado) y el *timeout* es ``None`` (el "
"valor predeterminado), es bloqueado si es necesario hasta que un elemento "
"esté disponible. Si el *timeout* es un número positivo, bloquea a lo sumo "
"segundos y genera la excepción :exc:`queue.Empty` si no había ningún "
"elemento disponible dentro de ese tiempo. De lo contrario (el bloque es "
"``False``), retorna un elemento si hay uno disponible de inmediato, de lo "
"contrario, levante la excepción :exc:`queue.Empty` (*timeout* se ignora en "
"ese caso)."

#: ../Doc/library/multiprocessing.rst:874
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`OSError`."
msgstr ""
"Si la cola está cerrada, se lanza :exc:`ValueError` en lugar de :exc:"
"`OSError`."

#: ../Doc/library/multiprocessing.rst:880
msgid "Equivalent to ``get(False)``."
msgstr "Equivalente a ``get(False)``."

#: ../Doc/library/multiprocessing.rst:882
msgid ""
":class:`multiprocessing.Queue` has a few additional methods not found in :"
"class:`queue.Queue`.  These methods are usually unnecessary for most code:"
msgstr ""
"La :class:`multiprocessing.Queue` tiene algunos métodos adicionales que no "
"se encuentran en :class:`queue.Queue`. Estos métodos suelen ser innecesarios "
"para la mayoría de los códigos:"

#: ../Doc/library/multiprocessing.rst:888
msgid ""
"Indicate that no more data will be put on this queue by the current "
"process.  The background thread will quit once it has flushed all buffered "
"data to the pipe.  This is called automatically when the queue is garbage "
"collected."
msgstr ""
"Indica que el proceso actual no colocará más datos en esta cola (*queue*). "
"El subproceso en segundo plano se cerrará una vez que haya vaciado todos los "
"datos almacenados en la tubería (*pipe*). Esto se llama automáticamente "
"cuando la cola es recolectada por el recolector de basura."

#: ../Doc/library/multiprocessing.rst:895
msgid ""
"Join the background thread.  This can only be used after :meth:`close` has "
"been called.  It blocks until the background thread exits, ensuring that all "
"data in the buffer has been flushed to the pipe."
msgstr ""
"Unifica al hilo de fondo. Esto solo se puede usar después de que se ha "
"llamado a :meth:`close`. Esto se bloquea hasta que salga el hilo de fondo, "
"asegurando que todos los datos en el búfer se hayan vaciado a la tubería "
"(*pipe*)."

#: ../Doc/library/multiprocessing.rst:899
msgid ""
"By default if a process is not the creator of the queue then on exit it will "
"attempt to join the queue's background thread.  The process can call :meth:"
"`cancel_join_thread` to make :meth:`join_thread` do nothing."
msgstr ""
"Por defecto, si un proceso no es el creador de la cola (*queue*), al salir "
"intentará unirse al hilo de fondo de la cola. El proceso puede llamar a :"
"meth:`cancel_join_thread` para hacer que el :meth:`join_thread` no haga nada."

#: ../Doc/library/multiprocessing.rst:905
msgid ""
"Prevent :meth:`join_thread` from blocking.  In particular, this prevents the "
"background thread from being joined automatically when the process exits -- "
"see :meth:`join_thread`."
msgstr ""
"Evita que :meth:`join_thread` bloquee. En particular, esto evita que el "
"subproceso en segundo plano se una automáticamente cuando finaliza el "
"proceso; consulte :meth:`join_thread`."

#: ../Doc/library/multiprocessing.rst:909
msgid ""
"A better name for this method might be ``allow_exit_without_flush()``.  It "
"is likely to cause enqueued data to be lost, and you almost certainly will "
"not need to use it. It is really only there if you need the current process "
"to exit immediately without waiting to flush enqueued data to the underlying "
"pipe, and you don't care about lost data."
msgstr ""
"Un mejor nombre para este método podría ser ``allow_exit_without_flush()``.  "
"Es probable que provoque la pérdida de datos encolados, y es casi seguro que "
"no necesitará usarlo. Realmente solo está allí si necesita que el proceso "
"actual salga inmediatamente sin esperar a vaciar los datos en en la tubería "
"(*pipe*) subyacente, y no le importan los datos perdidos."

#: ../Doc/library/multiprocessing.rst:918
msgid ""
"This class's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the functionality "
"in this class will be disabled, and attempts to instantiate a :class:`Queue` "
"will result in an :exc:`ImportError`. See :issue:`3770` for additional "
"information.  The same holds true for any of the specialized queue types "
"listed below."
msgstr ""
"La funcionalidad de esta clase requiere una implementación de semáforo "
"compartido en funcionamiento en el sistema operativo que es huésped "
"(*host*). Sin uno, la funcionalidad en esta clase se deshabilitará, y los "
"intentos de instanciar a :class:`Queue` resultarán en :exc:`ImportError`. "
"Consulte :issue:`3770` para información adicional. Lo mismo es válido para "
"cualquiera de los tipos de cola especializados que se enumeran a "
"continuación."

#: ../Doc/library/multiprocessing.rst:927
msgid ""
"It is a simplified :class:`Queue` type, very close to a locked :class:`Pipe`."
msgstr ""
"Es un tipo simplificado :class:`Queue`, muy similar a un *lock* de :class:"
"`Pipe`."

#: ../Doc/library/multiprocessing.rst:931
msgid "Close the queue: release internal resources."
msgstr "Cierra la cola: libera recursos internos."

#: ../Doc/library/multiprocessing.rst:933
msgid ""
"A queue must not be used anymore after it is closed. For example, :meth:"
"`get`, :meth:`put` and :meth:`empty` methods must no longer be called."
msgstr ""
"Una cola no se debe usar más después de ser cerrada. Por ejemplo los "
"métodos :meth:`get`, :meth:`put` y :meth:`empty` no deben ser llamados."

#: ../Doc/library/multiprocessing.rst:941
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr ""
"Retorna ``True`` si la cola (*queue*) está vacía, de otra manera retorna "
"``False``."

#: ../Doc/library/multiprocessing.rst:945
msgid "Remove and return an item from the queue."
msgstr "Eliminar y retornar un artículo de la cola (*queue*)."

#: ../Doc/library/multiprocessing.rst:949
msgid "Put *item* into the queue."
msgstr "Pone *item* en la cola."

#: ../Doc/library/multiprocessing.rst:954
msgid ""
":class:`JoinableQueue`, a :class:`Queue` subclass, is a queue which "
"additionally has :meth:`task_done` and :meth:`join` methods."
msgstr ""
":class:`JoinableQueue`, una subclase :class:`Queue` , es una cola (*queue*) "
"que además tiene los métodos :meth:`task_done` y :meth:`join`."

#: ../Doc/library/multiprocessing.rst:959
msgid ""
"Indicate that a formerly enqueued task is complete. Used by queue "
"consumers.  For each :meth:`~Queue.get` used to fetch a task, a subsequent "
"call to :meth:`task_done` tells the queue that the processing on the task is "
"complete."
msgstr ""
"Indica que una tarea anteriormente en cola (*queue*) está completa. Usado "
"por los consumidores de la cola. Por cada :meth:`~Queue.get` utilizado para "
"recuperar una tarea, una llamada posterior a :meth:`task_done` le dice a la "
"cola que el procesamiento de la tarea se ha completado."

#: ../Doc/library/multiprocessing.rst:964
msgid ""
"If a :meth:`~queue.Queue.join` is currently blocking, it will resume when "
"all items have been processed (meaning that a :meth:`task_done` call was "
"received for every item that had been :meth:`~Queue.put` into the queue)."
msgstr ""
"Si un :meth:`~queue.Queue.join` se está bloqueando actualmente, se reanudará "
"cuando se hayan procesado todos los elementos (lo que significa que :meth:"
"`task_done` es llamado para cada elemento que había sido puesto en cola "
"(*queue*) por :meth:`~Queue.put`)."

#: ../Doc/library/multiprocessing.rst:968
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Lanza un :exc:`ValueError` si es llamado más veces que elementos hay en una "
"cola."

#: ../Doc/library/multiprocessing.rst:974
msgid "Block until all items in the queue have been gotten and processed."
msgstr ""
"Se bloquea hasta que todos los elementos en una cola han sido recibidos y "
"procesados."

#: ../Doc/library/multiprocessing.rst:976
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue.  The count goes down whenever a consumer calls :meth:`task_done` to "
"indicate that the item was retrieved and all work on it is complete.  When "
"the count of unfinished tasks drops to zero, :meth:`~queue.Queue.join` "
"unblocks."
msgstr ""
"El recuento de tareas no finalizadas aumenta cada vez que se agrega un "
"elemento a la cola. El recuento disminuye cada vez que un consumidor llama "
"a :meth:`task_done` para indicar que el artículo se recuperó y todo el "
"trabajo en él está completo. Cuando el recuento de tareas inacabadas cae a "
"cero, :meth:`~queue.Queue.join` se desbloquea."

#: ../Doc/library/multiprocessing.rst:984
msgid "Miscellaneous"
msgstr "Miscelánea"

#: ../Doc/library/multiprocessing.rst:988
msgid "Return list of all live children of the current process."
msgstr "Retorna una lista con todos los hijos del proceso actual."

#: ../Doc/library/multiprocessing.rst:990
msgid ""
"Calling this has the side effect of \"joining\" any processes which have "
"already finished."
msgstr ""
"Llamar a esto tiene el efecto secundario de \"unir\" (*joining*) cualquier "
"proceso que ya haya finalizado."

#: ../Doc/library/multiprocessing.rst:995
msgid "Return the number of CPUs in the system."
msgstr "Retorna el número de CPU en el sistema."

#: ../Doc/library/multiprocessing.rst:997
msgid ""
"This number is not equivalent to the number of CPUs the current process can "
"use.  The number of usable CPUs can be obtained with ``len(os."
"sched_getaffinity(0))``"
msgstr ""
"Este número no es equivalente al número de CPU que puede utilizar el proceso "
"actual. El número de CPU utilizables se puede obtener con ``len(os."
"sched_getaffinity(0))``"

#: ../Doc/library/multiprocessing.rst:1001
msgid ""
"When the number of CPUs cannot be determined a :exc:`NotImplementedError` is "
"raised."
msgstr ""
"Cuando no se puede determinar el número de CPUs, se lanza un :exc:"
"`NotImplementedError`."

#: ../Doc/library/multiprocessing.rst:1005
msgid ":func:`os.cpu_count`"
msgstr ":func:`os.cpu_count`"

#: ../Doc/library/multiprocessing.rst:1009
msgid ""
"Return the :class:`Process` object corresponding to the current process."
msgstr ""
"Retorna el objeto de la :class:`Process` correspondiente al proceso actual."

#: ../Doc/library/multiprocessing.rst:1011
msgid "An analogue of :func:`threading.current_thread`."
msgstr "Un análogo de la :func:`threading.current_thread`."

#: ../Doc/library/multiprocessing.rst:1015
msgid ""
"Return the :class:`Process` object corresponding to the parent process of "
"the :func:`current_process`. For the main process, ``parent_process`` will "
"be ``None``."
msgstr ""
"Retorna el objeto de la :class:`Process` correspondiente al proceso parental "
"de :func:`current_process`. Para el proceso principal, ``parent_process`` "
"será ``None``."

#: ../Doc/library/multiprocessing.rst:1023
msgid ""
"Add support for when a program which uses :mod:`multiprocessing` has been "
"frozen to produce a Windows executable.  (Has been tested with **py2exe**, "
"**PyInstaller** and **cx_Freeze**.)"
msgstr ""
"Agrega soporte para cuando un programa que utiliza :mod:`multiprocessing` se "
"haya congelado para producir un ejecutable de Windows. (Ha sido probado con "
"**py2exe**, **PyInstaller** y **cx_Freeze**.)"

#: ../Doc/library/multiprocessing.rst:1027
msgid ""
"One needs to call this function straight after the ``if __name__ == "
"'__main__'`` line of the main module.  For example::"
msgstr ""
"Es necesario llamar a esta función inmediatamente después de la línea "
"principal del módulo ``if __name__ == '__main__'`` . Por ejemplo::"

#: ../Doc/library/multiprocessing.rst:1039
msgid ""
"If the ``freeze_support()`` line is omitted then trying to run the frozen "
"executable will raise :exc:`RuntimeError`."
msgstr ""
"Si se omite la línea ``freeze_support()`` entonces se intenta comenzar el "
"ejecutable congelado que lanzará :exc:`RuntimeError`."

#: ../Doc/library/multiprocessing.rst:1042
msgid ""
"Calling ``freeze_support()`` has no effect when invoked on any operating "
"system other than Windows.  In addition, if the module is being run normally "
"by the Python interpreter on Windows (the program has not been frozen), then "
"``freeze_support()`` has no effect."
msgstr ""
"La llamada de ``freeze_support()`` no tiene efecto cuando es invocada por "
"cualquier sistema operativo que no sea Windows. Además, si el módulo ha sido "
"ejecutado en un intérprete de Python en Windows (y el programa no se ha "
"congelado) entonces ``freeze_support()`` no tiene efecto."

#: ../Doc/library/multiprocessing.rst:1049
#, fuzzy
msgid ""
"Returns a list of the supported start methods, the first of which is the "
"default.  The possible start methods are ``'fork'``, ``'spawn'`` and "
"``'forkserver'``.  Not all platforms support all methods.  See :ref:"
"`multiprocessing-start-methods`."
msgstr ""
"Retorna una lista de los métodos de inicio admitidos, el primero de los "
"cuales es el predeterminado. Los posibles métodos de inicio son ``'fork'``, "
"``'spawn'`` y ``'forkserver'``. En Windows solo está disponible ``'spawn'``. "
"En Unix, ``'fork'`` y ``'spawn'`` siempre son compatibles, siendo ``'fork'`` "
"el valor predeterminado."

#: ../Doc/library/multiprocessing.rst:1058
msgid ""
"Return a context object which has the same attributes as the :mod:"
"`multiprocessing` module."
msgstr ""
"Retorna un objeto de contexto que tiene los mismos atributos que el módulo :"
"mod:`multiprocessing`."

#: ../Doc/library/multiprocessing.rst:1061
#, fuzzy
msgid ""
"If *method* is ``None`` then the default context is returned. Otherwise "
"*method* should be ``'fork'``, ``'spawn'``, ``'forkserver'``.  :exc:"
"`ValueError` is raised if the specified start method is not available.  See :"
"ref:`multiprocessing-start-methods`."
msgstr ""
"Si el método *method* es ``None`` entonces el contexto predeterminado es "
"retornado. Por lo contrario, *method* debería ser ``'fork'``, ``'spawn'``, "
"``'forkserver'``. Se lanza :exc:`ValueError` if el método de inicio no esta "
"disponible."

#: ../Doc/library/multiprocessing.rst:1070
msgid "Return the name of start method used for starting processes."
msgstr ""
"Retorna el nombre del método de inicio que es utilizado para iniciar "
"procesos."

#: ../Doc/library/multiprocessing.rst:1072
msgid ""
"If the start method has not been fixed and *allow_none* is false, then the "
"start method is fixed to the default and the name is returned.  If the start "
"method has not been fixed and *allow_none* is true then ``None`` is returned."
msgstr ""
"Si el método de inicio no se ha solucionado y *allow_none* es falso, "
"entonces el método de inicio se fija al predeterminado y se retorna el "
"nombre. Si el método de inicio no se ha solucionado y *allow_none* es "
"verdadero, se retorna ``None``."

#: ../Doc/library/multiprocessing.rst:1077
#, fuzzy
msgid ""
"The return value can be ``'fork'``, ``'spawn'``, ``'forkserver'`` or "
"``None``.  See :ref:`multiprocessing-start-methods`."
msgstr ""
"El valor retornado puede ser ``'fork'``, ``'spawn'``, ``'forkserver'`` o "
"``None``. En Unix ``'fork'`` es el valor predeterminado mientras que "
"``'spawn'`` lo es en Windows y macOS."

#: ../Doc/library/multiprocessing.rst:1082
msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess. See :issue:`33725`."
msgstr ""
"En macOS, el método de inicio *spawn* ahora es el predeterminado. El método "
"de inicio *fork* debe considerarse inseguro ya que puede provocar bloqueos "
"del subproceso. Consulte :issue:`33725`."

#: ../Doc/library/multiprocessing.rst:1090
msgid ""
"Set the path of the Python interpreter to use when starting a child process. "
"(By default :data:`sys.executable` is used).  Embedders will probably need "
"to do some thing like ::"
msgstr ""
"Establezca la ruta del intérprete de Python para usar al iniciar un proceso "
"secundario. (Por defecto se usa :data:`sys.executable`). Los integradores "
"probablemente necesitarán hacer algo como ::"

#: ../Doc/library/multiprocessing.rst:1096
msgid "before they can create child processes."
msgstr "antes ellos pueden crear procesos hijos."

#: ../Doc/library/multiprocessing.rst:1098
#, fuzzy
msgid "Now supported on POSIX when the ``'spawn'`` start method is used."
msgstr ""
"Ahora es compatible con Unix cuando se usa el método de inicio ``'spawn'``."

#: ../Doc/library/multiprocessing.rst:1101
msgid "Accepts a :term:`path-like object`."
msgstr "Acepta un :term:`path-like object`."

#: ../Doc/library/multiprocessing.rst:1106
msgid ""
"Set a list of module names for the forkserver main process to attempt to "
"import so that their already imported state is inherited by forked "
"processes. Any :exc:`ImportError` when doing so is silently ignored. This "
"can be used as a performance enhancement to avoid repeated work in every "
"process."
msgstr ""

#: ../Doc/library/multiprocessing.rst:1112
msgid ""
"For this to work, it must be called before the forkserver process has been "
"launched (before creating a :class:`Pool` or starting a :class:`Process`)."
msgstr ""

#: ../Doc/library/multiprocessing.rst:1115
msgid ""
"Only meaningful when using the ``'forkserver'`` start method. See :ref:"
"`multiprocessing-start-methods`."
msgstr ""

#: ../Doc/library/multiprocessing.rst:1122
msgid ""
"Set the method which should be used to start child processes. The *method* "
"argument can be ``'fork'``, ``'spawn'`` or ``'forkserver'``. Raises :exc:"
"`RuntimeError` if the start method has already been set and *force* is not "
"``True``.  If *method* is ``None`` and *force* is ``True`` then the start "
"method is set to ``None``.  If *method* is ``None`` and *force* is ``False`` "
"then the context is set to the default context."
msgstr ""

#: ../Doc/library/multiprocessing.rst:1129
msgid ""
"Note that this should be called at most once, and it should be protected "
"inside the ``if __name__ == '__main__'`` clause of the main module."
msgstr ""
"Tenga en cuenta que esto debería llamarse como máximo una vez, y debería "
"protegerse dentro de la cláusula ``if __name__ == '__main__'`` del módulo "
"principal."

#: ../Doc/library/multiprocessing.rst:1133
#, fuzzy
msgid "See :ref:`multiprocessing-start-methods`."
msgstr "Consulte :ref:`multiprocessing-auth-keys`."

#: ../Doc/library/multiprocessing.rst:1139
msgid ""
":mod:`multiprocessing` contains no analogues of :func:`threading."
"active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :"
"func:`threading.setprofile`, :class:`threading.Timer`, or :class:`threading."
"local`."
msgstr ""
":mod:`multiprocessing` no contiene análogos de :func:`threading."
"active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :"
"func:`threading.setprofile`, :class:`threading.Timer`, o :class:`threading."
"local`."

#: ../Doc/library/multiprocessing.rst:1146
msgid "Connection Objects"
msgstr "Objetos de conexión *Connection Objects*"

#: ../Doc/library/multiprocessing.rst:1150
msgid ""
"Connection objects allow the sending and receiving of picklable objects or "
"strings.  They can be thought of as message oriented connected sockets."
msgstr ""
"Los objetos de conexión permiten el envío y la recepción de objetos "
"serializables (*pickable*) o cadenas de caracteres seleccionables. Pueden "
"considerarse como sockets conectados orientados a mensajes."

#: ../Doc/library/multiprocessing.rst:1153
msgid ""
"Connection objects are usually created using :func:`Pipe <multiprocessing."
"Pipe>` -- see also :ref:`multiprocessing-listeners-clients`."
msgstr ""
"Los objetos de conexión usualmente son creados usando :func:`Pipe "
"<multiprocessing.Pipe>` -- ver también :ref:`multiprocessing-listeners-"
"clients`."

#: ../Doc/library/multiprocessing.rst:1161
msgid ""
"Send an object to the other end of the connection which should be read "
"using :meth:`recv`."
msgstr ""
"Envía un objeto al otro extremo de la conexión que debe leerse usando :meth:"
"`recv`."

#: ../Doc/library/multiprocessing.rst:1164
msgid ""
"The object must be picklable.  Very large pickles (approximately 32 MiB+, "
"though it depends on the OS) may raise a :exc:`ValueError` exception."
msgstr ""
"El objeto debe ser serializable (*pickable*). Los serializados (*pickable*) "
"muy grandes (aproximadamente 32 *MiB+* , aunque depende del sistema "
"operativo) pueden generar una excepción :exc:`ValueError`."

#: ../Doc/library/multiprocessing.rst:1169
msgid ""
"Return an object sent from the other end of the connection using :meth:"
"`send`.  Blocks until there is something to receive.  Raises :exc:`EOFError` "
"if there is nothing left to receive and the other end was closed."
msgstr ""
"Retorna un objeto enviado desde el otro extremo de la conexión usando :meth:"
"`send`. Se bloquea hasta que haya algo para recibir. Se lanza :exc:"
"`EOFError` si no queda nada por recibir y el otro extremo está cerrado."

#: ../Doc/library/multiprocessing.rst:1176
msgid "Return the file descriptor or handle used by the connection."
msgstr ""
"Retorna el descriptor de archivo o identificador utilizado por la conexión."

#: ../Doc/library/multiprocessing.rst:1180
msgid "Close the connection."
msgstr "Cierra la conexión."

#: ../Doc/library/multiprocessing.rst:1182
msgid "This is called automatically when the connection is garbage collected."
msgstr ""
"Esto se llama automáticamente cuando la conexión es basura recolectada."

#: ../Doc/library/multiprocessing.rst:1186
msgid "Return whether there is any data available to be read."
msgstr "Retorna si hay datos disponibles para leer."

#: ../Doc/library/multiprocessing.rst:1188
msgid ""
"If *timeout* is not specified then it will return immediately.  If *timeout* "
"is a number then this specifies the maximum time in seconds to block.  If "
"*timeout* is ``None`` then an infinite timeout is used."
msgstr ""
"Si no se especifica *timeout*, se retornará de inmediato. Si *timeout* es un "
"número, esto especifica el tiempo máximo en segundos para bloquear. Si "
"*timeout* es ``None``, se usa un tiempo de espera infinito."

#: ../Doc/library/multiprocessing.rst:1192
msgid ""
"Note that multiple connection objects may be polled at once by using :func:"
"`multiprocessing.connection.wait`."
msgstr ""
"Tenga en cuenta que se pueden sondear varios objetos de conexión a la vez "
"utilizando :func:`multiprocessing.connection.wait`."

#: ../Doc/library/multiprocessing.rst:1197
msgid "Send byte data from a :term:`bytes-like object` as a complete message."
msgstr ""
"Envía datos de *bytes* desde a :term:`bytes-like object` como un mensaje "
"completo."

#: ../Doc/library/multiprocessing.rst:1199
msgid ""
"If *offset* is given then data is read from that position in *buffer*.  If "
"*size* is given then that many bytes will be read from buffer.  Very large "
"buffers (approximately 32 MiB+, though it depends on the OS) may raise a :"
"exc:`ValueError` exception"
msgstr ""
"Si se da *offset*, los datos se leen desde esa posición en *buffer*. Si se "
"da *size* entonces se leerán muchos *bytes* del búfer. Los *buffers* muy "
"grandes (aproximadamente *32 MiB+*, aunque depende del sistema operativo) "
"pueden generar una excepción :exc:`ValueError`"

#: ../Doc/library/multiprocessing.rst:1206
msgid ""
"Return a complete message of byte data sent from the other end of the "
"connection as a string.  Blocks until there is something to receive. Raises :"
"exc:`EOFError` if there is nothing left to receive and the other end has "
"closed."
msgstr ""
"Retorna un mensaje completo de datos de *bytes* enviados desde el otro "
"extremo de la conexión como una cadena de caracteres. Se bloquea hasta que "
"haya algo para recibir. Aumenta :exc:`EOFError` si no queda nada por recibir "
"y el otro extremo se ha cerrado."

#: ../Doc/library/multiprocessing.rst:1211
msgid ""
"If *maxlength* is specified and the message is longer than *maxlength* then :"
"exc:`OSError` is raised and the connection will no longer be readable."
msgstr ""
"Si se especifica *maxlength* y el mensaje es más largo que *maxlength*, "
"entonces se lanza un :exc:`OSError` y la conexión ya no será legible."

#: ../Doc/library/multiprocessing.rst:1215
msgid ""
"This function used to raise :exc:`IOError`, which is now an alias of :exc:"
"`OSError`."
msgstr ""
"Esta función solía lanzar un :exc:`IOError`, que ahora es un alias de :exc:"
"`OSError`."

#: ../Doc/library/multiprocessing.rst:1222
msgid ""
"Read into *buffer* a complete message of byte data sent from the other end "
"of the connection and return the number of bytes in the message.  Blocks "
"until there is something to receive.  Raises :exc:`EOFError` if there is "
"nothing left to receive and the other end was closed."
msgstr ""
"Lee en *buffer* un mensaje completo de datos de *bytes* enviados desde el "
"otro extremo de la conexión y retorne el número de *bytes* en el mensaje. Se "
"bloquea hasta que haya algo para recibir. Si no queda nada por recibir y el "
"otro extremo está cerrándose se lanza :exc:`EOFError`."

#: ../Doc/library/multiprocessing.rst:1228
msgid ""
"*buffer* must be a writable :term:`bytes-like object`.  If *offset* is given "
"then the message will be written into the buffer from that position.  Offset "
"must be a non-negative integer less than the length of *buffer* (in bytes)."
msgstr ""
"*buffer* debe ser un escribible :term:`bytes-like object`. Si se proporciona "
"*offset* el mensaje se escribirá en el búfer desde esa posición. La "
"compensación debe ser un número entero no negativo menor que la longitud de "
"*buffer* (en *bytes*)."

#: ../Doc/library/multiprocessing.rst:1233
msgid ""
"If the buffer is too short then a :exc:`BufferTooShort` exception is raised "
"and the complete message is available as ``e.args[0]`` where ``e`` is the "
"exception instance."
msgstr ""
"Si el búfer es demasiado corto, se genera una excepción :exc:"
"`BufferTooShort` y el mensaje completo está disponible como ``e.args[0]`` "
"donde ``e`` es la instancia de excepción."

#: ../Doc/library/multiprocessing.rst:1237
msgid ""
"Connection objects themselves can now be transferred between processes "
"using :meth:`Connection.send` and :meth:`Connection.recv`."
msgstr ""
"Los objetos de conexión ahora pueden transferirse entre procesos usando :"
"meth:`Connection.send` y :meth:`Connection.recv`."

#: ../Doc/library/multiprocessing.rst:1241
msgid ""
"Connection objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"connection object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"Los objetos de conexión ahora admiten el protocolo de administración de "
"contexto -- consulte :ref:`typecontextmanager`.  :meth:`~contextmanager."
"__enter__` retorna el objeto de conexión, y :meth:`~contextmanager.__exit__` "
"llama a :meth:`close`."

#: ../Doc/library/multiprocessing.rst:1246
msgid "For example:"
msgstr "Por ejemplo:"

#: ../Doc/library/multiprocessing.rst:1271
msgid ""
"The :meth:`Connection.recv` method automatically unpickles the data it "
"receives, which can be a security risk unless you can trust the process "
"which sent the message."
msgstr ""
"El método :meth:`Connection.recv` desempaqueta automáticamente los datos que "
"recibe, lo que puede ser un riesgo de seguridad a menos que pueda confiar en "
"el proceso que envió el mensaje."

#: ../Doc/library/multiprocessing.rst:1275
msgid ""
"Therefore, unless the connection object was produced using :func:`Pipe` you "
"should only use the :meth:`~Connection.recv` and :meth:`~Connection.send` "
"methods after performing some sort of authentication.  See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""
"Por lo tanto, a menos que el objeto de conexión se haya producido usando :"
"func:`Pipe` solo debe usar los métodos :meth:`~Connection.recv` y :meth:"
"`~Connection.send` después de realizar algún tipo de autenticación. "
"Consulte :ref:`multiprocessing-auth-keys`."

#: ../Doc/library/multiprocessing.rst:1282
msgid ""
"If a process is killed while it is trying to read or write to a pipe then "
"the data in the pipe is likely to become corrupted, because it may become "
"impossible to be sure where the message boundaries lie."
msgstr ""
"Si se mata un proceso mientras intenta leer o escribir en una tubería "
"(*pipe*), entonces es probable que los datos en la tubería se corrompan, "
"porque puede ser imposible estar seguro de dónde se encuentran los límites "
"del mensaje."

#: ../Doc/library/multiprocessing.rst:1288
msgid "Synchronization primitives"
msgstr "Primitivas de sincronización (*Synchronization primitives*)"

#: ../Doc/library/multiprocessing.rst:1292
msgid ""
"Generally synchronization primitives are not as necessary in a multiprocess "
"program as they are in a multithreaded program.  See the documentation for :"
"mod:`threading` module."
msgstr ""
"En general, las primitivas de sincronización no son tan necesarias en un "
"programa multiproceso como en un programa *multihilos* (*multithreaded*). "
"Consulte la documentación para :mod:`threading` ."

#: ../Doc/library/multiprocessing.rst:1296
msgid ""
"Note that one can also create synchronization primitives by using a manager "
"object -- see :ref:`multiprocessing-managers`."
msgstr ""
"Tenga en cuenta que también se pueden crear primitivas de sincronización "
"utilizando un objeto administrador -- consulte :ref:`multiprocessing-"
"managers`."

#: ../Doc/library/multiprocessing.rst:1301
msgid "A barrier object: a clone of :class:`threading.Barrier`."
msgstr "Un objeto de barrera: un clon de :class:`threading.Barrier`."

#: ../Doc/library/multiprocessing.rst:1307
msgid ""
"A bounded semaphore object: a close analog of :class:`threading."
"BoundedSemaphore`."
msgstr ""
"Un objeto semáforo (*semaphore object*) acotado: un análogo cercano de la :"
"class:`threading.BoundedSemaphore`."

#: ../Doc/library/multiprocessing.rst:1310
#: ../Doc/library/multiprocessing.rst:1448
msgid ""
"A solitary difference from its close analog exists: its ``acquire`` method's "
"first argument is named *block*, as is consistent with :meth:`Lock.acquire`."
msgstr ""
"Existe una diferencia solitaria de su análogo cercano: el primer argumento "
"de su método ``acquire`` es nombrado *block*, es consistente con :meth:`Lock."
"acquire`."

#: ../Doc/library/multiprocessing.rst:1314
msgid ""
"On macOS, this is indistinguishable from :class:`Semaphore` because "
"``sem_getvalue()`` is not implemented on that platform."
msgstr ""
"En macOS, esto no se puede distinguir de :class:`Semaphore` porque "
"``sem_getvalue()`` no está implementado en esa plataforma."

#: ../Doc/library/multiprocessing.rst:1319
msgid "A condition variable: an alias for :class:`threading.Condition`."
msgstr ""
"Una variable de condición: un alias para la :class:`threading.Condition`."

#: ../Doc/library/multiprocessing.rst:1321
msgid ""
"If *lock* is specified then it should be a :class:`Lock` or :class:`RLock` "
"object from :mod:`multiprocessing`."
msgstr ""
"Si se especifica *lock*, entonces debería ser una :class:`Lock` o :class:"
"`RLock` objeto de :mod:`multiprocessing`."

#: ../Doc/library/multiprocessing.rst:1324
#: ../Doc/library/multiprocessing.rst:1873
msgid "The :meth:`~threading.Condition.wait_for` method was added."
msgstr "El método :meth:`~threading.Condition.wait_for` fue a añadido."

#: ../Doc/library/multiprocessing.rst:1329
msgid "A clone of :class:`threading.Event`."
msgstr "Un clon de :class:`threading.Event`."

#: ../Doc/library/multiprocessing.rst:1334
msgid ""
"A non-recursive lock object: a close analog of :class:`threading.Lock`. Once "
"a process or thread has acquired a lock, subsequent attempts to acquire it "
"from any process or thread will block until it is released; any process or "
"thread may release it.  The concepts and behaviors of :class:`threading."
"Lock` as it applies to threads are replicated here in :class:"
"`multiprocessing.Lock` as it applies to either processes or threads, except "
"as noted."
msgstr ""
"Un objeto candado no recursivo: un análogo cercano de :class:`threading."
"Lock` . Una vez que un proceso o subproceso ha adquirido un bloqueo, los "
"intentos posteriores de adquirirlo de cualquier proceso o subproceso se "
"bloquearán hasta que se libere; cualquier proceso o hilo puede liberarlo. "
"Los conceptos y comportamientos de :class:`threading.Lock` como se aplica a "
"los subprocesos se replican aquí en :class:`multiprocessing.Lock` como se "
"aplica a los procesos o subprocesos, excepto como se indica."

#: ../Doc/library/multiprocessing.rst:1342
msgid ""
"Note that :class:`Lock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.Lock`` initialized with a default "
"context."
msgstr ""
"Tenga en cuenta que :class:`Lock` es en realidad una función de fábrica que "
"retorna una instancia de ``multiprocessing.synchronize.Lock`` inicializada "
"con un contexto predeterminado."

#: ../Doc/library/multiprocessing.rst:1346
msgid ""
":class:`Lock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
"La :class:`Lock` soporta el protocolo :term:`context manager` y, por lo "
"tanto, se puede usar en la declaración :keyword:`with`."

#: ../Doc/library/multiprocessing.rst:1351
#: ../Doc/library/multiprocessing.rst:1402
msgid "Acquire a lock, blocking or non-blocking."
msgstr "Adquiriendo un candado (*lock*), bloqueante o no bloqueante."

#: ../Doc/library/multiprocessing.rst:1353
msgid ""
"With the *block* argument set to ``True`` (the default), the method call "
"will block until the lock is in an unlocked state, then set it to locked and "
"return ``True``.  Note that the name of this first argument differs from "
"that in :meth:`threading.Lock.acquire`."
msgstr ""
"Con el argumento *block* establecido en ``True`` (el valor predeterminado), "
"la llamada al método se bloqueará hasta que el bloqueo esté en un estado "
"desbloqueado, luego configúrelo como bloqueado y retorne ``True``. Tenga en "
"cuenta que el nombre de este primer argumento difiere del que aparece en :"
"meth:`threading.Lock.acquire`."

#: ../Doc/library/multiprocessing.rst:1358
msgid ""
"With the *block* argument set to ``False``, the method call does not block.  "
"If the lock is currently in a locked state, return ``False``; otherwise set "
"the lock to a locked state and return ``True``."
msgstr ""
"Con el argumento *block* establecido en ``False``, la llamada al método no "
"se bloquea. Si el bloqueo está actualmente en un estado bloqueado, retorna "
"``False``; de lo contrario, configure el bloqueo en un estado bloqueado y "
"retorne ``True``."

#: ../Doc/library/multiprocessing.rst:1362
msgid ""
"When invoked with a positive, floating-point value for *timeout*, block for "
"at most the number of seconds specified by *timeout* as long as the lock can "
"not be acquired.  Invocations with a negative value for *timeout* are "
"equivalent to a *timeout* of zero.  Invocations with a *timeout* value of "
"``None`` (the default) set the timeout period to infinite.  Note that the "
"treatment of negative or ``None`` values for *timeout* differs from the "
"implemented behavior in :meth:`threading.Lock.acquire`.  The *timeout* "
"argument has no practical implications if the *block* argument is set to "
"``False`` and is thus ignored.  Returns ``True`` if the lock has been "
"acquired or ``False`` if the timeout period has elapsed."
msgstr ""
"Cuando se invoca con un valor positivo de punto flotante para *timeout*, "
"bloquea como máximo el número de segundos especificado por *timeout* siempre "
"que no se pueda obtener el bloqueo. Las invocaciones con un valor negativo "
"para *timeout* de cero. Las invocaciones con un valor *timeout* de ``None`` "
"(el valor predeterminado) establecen el período de tiempo de espera en "
"infinito. Tenga en cuenta que el tratamiento de valores negativos o ``None`` "
"para *timeout* difiere del comportamiento implementado en :meth:`threading."
"Lock.acquire`. El argumento *timeout* no tiene implicaciones prácticas si el "
"argumento *block* se establece en ``False`` y, por lo tanto, se ignora. "
"Retorna ``True`` si se ha adquirido el candado o ``False`` si ha "
"transcurrido el tiempo de espera."

#: ../Doc/library/multiprocessing.rst:1377
msgid ""
"Release a lock.  This can be called from any process or thread, not only the "
"process or thread which originally acquired the lock."
msgstr ""
"Suelta un candado. Esto se puede llamar desde cualquier proceso o "
"subproceso, no solo desde el proceso o subproceso que originalmente adquirió "
"el candado."

#: ../Doc/library/multiprocessing.rst:1380
msgid ""
"Behavior is the same as in :meth:`threading.Lock.release` except that when "
"invoked on an unlocked lock, a :exc:`ValueError` is raised."
msgstr ""
"El comportamiento es el mismo que en :meth:`threading.Lock.release` excepto "
"que cuando se invoca en un bloqueo desbloqueado, se genera a :exc:"
"`ValueError`."

#: ../Doc/library/multiprocessing.rst:1386
msgid ""
"A recursive lock object: a close analog of :class:`threading.RLock`.  A "
"recursive lock must be released by the process or thread that acquired it. "
"Once a process or thread has acquired a recursive lock, the same process or "
"thread may acquire it again without blocking; that process or thread must "
"release it once for each time it has been acquired."
msgstr ""
"Un objeto de candado recursivo: un análogo cercano a :class:`threading."
"RLock`. El proceso o el hilo que lo adquirió debe liberar un candado "
"recursivo. Una vez que un proceso o subproceso ha adquirido un candado "
"recursivo, el mismo proceso o subproceso puede volver a adquirirlo sin "
"bloquearlo; ese proceso o hilo debe liberarlo una vez por cada vez que se "
"haya adquirido."

#: ../Doc/library/multiprocessing.rst:1392
msgid ""
"Note that :class:`RLock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.RLock`` initialized with a default "
"context."
msgstr ""
"Tenga en cuenta que :class:`RLock` es en realidad una función de fábrica que "
"retorna una instancia de ``multiprocessing.synchronize.RLock`` inicializada "
"con un contexto predeterminado."

#: ../Doc/library/multiprocessing.rst:1396
msgid ""
":class:`RLock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
"La :class:`RLock` admite el protocolo :term:`context manager` y, por lo "
"tanto, puede usarse en :keyword:`with`."

#: ../Doc/library/multiprocessing.rst:1404
msgid ""
"When invoked with the *block* argument set to ``True``, block until the lock "
"is in an unlocked state (not owned by any process or thread) unless the lock "
"is already owned by the current process or thread.  The current process or "
"thread then takes ownership of the lock (if it does not already have "
"ownership) and the recursion level inside the lock increments by one, "
"resulting in a return value of ``True``.  Note that there are several "
"differences in this first argument's behavior compared to the implementation "
"of :meth:`threading.RLock.acquire`, starting with the name of the argument "
"itself."
msgstr ""
"Cuando se invoca con el argumento *block* establecido en ``True`` , bloquea "
"hasta que el candado esté en un estado desbloqueado (que no sea propiedad de "
"ningún proceso o subproceso) a menos que el candado o el subproceso actual "
"ya sea de su propiedad. El proceso o subproceso actual se apropia del "
"candado (si aún no lo tiene) y el nivel de recursión dentro de este  aumenta "
"en uno, lo que da como resultado un valor de retorno de ``True``. Tenga en "
"cuenta que hay varias diferencias en el comportamiento de este primer "
"argumento en comparación con la implementación de :meth:`threading.RLock."
"acquire`, comenzando con el nombre del argumento en sí."

#: ../Doc/library/multiprocessing.rst:1414
msgid ""
"When invoked with the *block* argument set to ``False``, do not block. If "
"the lock has already been acquired (and thus is owned) by another process or "
"thread, the current process or thread does not take ownership and the "
"recursion level within the lock is not changed, resulting in a return value "
"of ``False``.  If the lock is in an unlocked state, the current process or "
"thread takes ownership and the recursion level is incremented, resulting in "
"a return value of ``True``."
msgstr ""
"Cuando se invoca con el argumento *block* establecido en ``False``, no "
"bloquea. Si el candado ya ha sido adquirido (y por lo tanto es propiedad) de "
"otro proceso o subproceso, el proceso o subproceso actual no se apropia y el "
"nivel de recursión dentro del candado no cambia, lo que resulta en un valor "
"de retorno de ``False``. Si el candado está en un estado desbloqueado, el "
"proceso o subproceso actual toma posesión y el nivel de recurrencia se "
"incrementa, lo que resulta en un valor de retorno de ``True``."

#: ../Doc/library/multiprocessing.rst:1422
msgid ""
"Use and behaviors of the *timeout* argument are the same as in :meth:`Lock."
"acquire`.  Note that some of these behaviors of *timeout* differ from the "
"implemented behaviors in :meth:`threading.RLock.acquire`."
msgstr ""
"El uso y los comportamientos del argumento *timeout* son los mismos que en :"
"meth:`Lock.acquire`. Tenga en cuenta que algunos de estos comportamientos de "
"*timeout* difieren de los comportamientos implementados en :meth:`threading."
"RLock.acquire`."

#: ../Doc/library/multiprocessing.rst:1429
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement "
"the recursion level is zero, reset the lock to unlocked (not owned by any "
"process or thread) and if any other processes or threads are blocked waiting "
"for the lock to become unlocked, allow exactly one of them to proceed.  If "
"after the decrement the recursion level is still nonzero, the lock remains "
"locked and owned by the calling process or thread."
msgstr ""
"Libera un candado, disminuyendo el nivel de recursión. Si después del "
"decremento el nivel de recursión es cero, restablece el candado a "
"desbloqueado (que no sea propiedad de ningún proceso o subproceso) y si se "
"bloquean otros procesos o subprocesos esperando que el candado se "
"desbloquee, permite que continúe exactamente uno de ellos. Si después del "
"decremento el nivel de recursión sigue siendo distinto de cero, el candado "
"permanece bloqueado y pertenece al proceso de llamada o subproceso."

#: ../Doc/library/multiprocessing.rst:1437
msgid ""
"Only call this method when the calling process or thread owns the lock. An :"
"exc:`AssertionError` is raised if this method is called by a process or "
"thread other than the owner or if the lock is in an unlocked (unowned) "
"state.  Note that the type of exception raised in this situation differs "
"from the implemented behavior in :meth:`threading.RLock.release`."
msgstr ""
"Solo llame a este método cuando el proceso o subproceso de llamada sea el "
"propietario del candado. Se lanza un :exc:`AssertionError` si se llama a "
"este método mediante un proceso o subproceso que no sea el propietario o si "
"el candado está en un estado desbloqueado (sin propietario). Tenga en cuenta "
"que el tipo de excepción planteada en esta situación difiere del "
"comportamiento implementado en :meth:`threading.RLock.release`."

#: ../Doc/library/multiprocessing.rst:1446
msgid "A semaphore object: a close analog of :class:`threading.Semaphore`."
msgstr ""
"Un objeto semáforo: un análogo cercano de :class:`threading.Semaphore`."

#: ../Doc/library/multiprocessing.rst:1453
msgid ""
"On macOS, ``sem_timedwait`` is unsupported, so calling ``acquire()`` with a "
"timeout will emulate that function's behavior using a sleeping loop."
msgstr ""
"En macOS, ``sem_timedwait`` no es compatible, por lo que llamar a "
"``acquire()`` con un tiempo de espera emulará el comportamiento de esa "
"función utilizando un bucle inactivo."

#: ../Doc/library/multiprocessing.rst:1458
msgid ""
"If the SIGINT signal generated by :kbd:`Ctrl-C` arrives while the main "
"thread is blocked by a call to :meth:`BoundedSemaphore.acquire`, :meth:`Lock."
"acquire`, :meth:`RLock.acquire`, :meth:`Semaphore.acquire`, :meth:`Condition."
"acquire` or :meth:`Condition.wait` then the call will be immediately "
"interrupted and :exc:`KeyboardInterrupt` will be raised."
msgstr ""
"Si la señal SIGINT generada por :kbd:`Ctrl-C` llega mientras el hilo "
"principal está bloqueado por una llamada a :meth:`BoundedSemaphore."
"acquire`, :meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Semaphore."
"acquire`, :meth:`Condition.acquire` o :meth:`Condition.wait`, la llamada se "
"interrumpirá inmediatamente y :exc:`KeyboardInterrupt` se lanzará."

#: ../Doc/library/multiprocessing.rst:1464
msgid ""
"This differs from the behaviour of :mod:`threading` where SIGINT will be "
"ignored while the equivalent blocking calls are in progress."
msgstr ""
"Esto difiere del comportamiento de :mod:`threading` donde SIGINT será "
"ignorado mientras las llamadas de candado equivalentes están en progreso."

#: ../Doc/library/multiprocessing.rst:1469
msgid ""
"Some of this package's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the :mod:"
"`multiprocessing.synchronize` module will be disabled, and attempts to "
"import it will result in an :exc:`ImportError`. See :issue:`3770` for "
"additional information."
msgstr ""
"Parte de la funcionalidad de este paquete requiere una implementación de "
"semáforo compartido que funcione en el sistema operativo. Sin uno, el "
"módulo :mod:`multiprocessing.synchronize` se desactivará, y los intentos de "
"importarlo darán como resultado :exc:`ImportError`. Consulte :issue:`3770` "
"para información adicional."

#: ../Doc/library/multiprocessing.rst:1477
msgid "Shared :mod:`ctypes` Objects"
msgstr "Objetos compartidos :mod:`ctypes`"

#: ../Doc/library/multiprocessing.rst:1479
msgid ""
"It is possible to create shared objects using shared memory which can be "
"inherited by child processes."
msgstr ""
"Es posible crear objetos compartidos utilizando memoria compartida que puede "
"ser heredada por procesos secundarios."

#: ../Doc/library/multiprocessing.rst:1484
msgid ""
"Return a :mod:`ctypes` object allocated from shared memory.  By default the "
"return value is actually a synchronized wrapper for the object.  The object "
"itself can be accessed via the *value* attribute of a :class:`Value`."
msgstr ""
"Retorna un objeto :mod:`ctypes` asignado desde la memoria compartida. Por "
"defecto, el valor de retorno es en realidad un contenedor sincronizado para "
"el objeto. Se puede acceder al objeto en sí a través del atributo *value* de "
"la :class:`Value`."

#: ../Doc/library/multiprocessing.rst:1488
#: ../Doc/library/multiprocessing.rst:1575
msgid ""
"*typecode_or_type* determines the type of the returned object: it is either "
"a ctypes type or a one character typecode of the kind used by the :mod:"
"`array` module.  *\\*args* is passed on to the constructor for the type."
msgstr ""
"*typecode_or_type* determina el tipo del objeto retornado: es un tipo "
"*ctypes* o un código de tipo de un carácter del tipo utilizado por el "
"módulo :mod:`array`. *\\*args* se pasa al constructor para el tipo."

#: ../Doc/library/multiprocessing.rst:1492
msgid ""
"If *lock* is ``True`` (the default) then a new recursive lock object is "
"created to synchronize access to the value.  If *lock* is a :class:`Lock` "
"or :class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr ""
"Si *lock* es ``True`` (el valor predeterminado), se crea un nuevo objeto de "
"candado recursivo para sincronizar el acceso al valor. Si *lock* es un "
"objeto :class:`Lock` o :class:`RLock`, se usará para sincronizar el acceso "
"al valor. Si *lock* es ``False``, entonces el acceso al objeto retornado no "
"estará protegido automáticamente por un candado, por lo que no será "
"necesariamente \"proceso-seguro\"."

#: ../Doc/library/multiprocessing.rst:1499
msgid ""
"Operations like ``+=`` which involve a read and write are not atomic.  So "
"if, for instance, you want to atomically increment a shared value it is "
"insufficient to just do ::"
msgstr ""
"Operaciones como ``+=`` que implican una lectura y escritura no son "
"atómicas. Entonces, si, por ejemplo, desea incrementar atómicamente un valor "
"compartido, es insuficiente simplemente hacer::"

#: ../Doc/library/multiprocessing.rst:1505
msgid ""
"Assuming the associated lock is recursive (which it is by default) you can "
"instead do ::"
msgstr ""
"Suponiendo que el candado asociado es recursivo (que es por defecto), puede "
"hacer ::"

#: ../Doc/library/multiprocessing.rst:1511
#: ../Doc/library/multiprocessing.rst:1601
#: ../Doc/library/multiprocessing.rst:1616
msgid "Note that *lock* is a keyword-only argument."
msgstr "Véase que *lock* es un argumento de solo una palabra clave."

#: ../Doc/library/multiprocessing.rst:1515
msgid ""
"Return a ctypes array allocated from shared memory.  By default the return "
"value is actually a synchronized wrapper for the array."
msgstr ""
"Retorna una matriz *ctypes* asignada desde la memoria compartida. Por "
"defecto, el valor de retorno es en realidad un contenedor sincronizado para "
"el arreglo."

#: ../Doc/library/multiprocessing.rst:1518
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer, "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise, *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* determina el tipo de los elementos de la matriz "
"retornada: es un tipo de tipo *ctypes* o un código de tipo de un carácter "
"del tipo utilizado por el módulo :mod:`array`. Si *size_or_initializer* es "
"un número entero, entonces determina la longitud de la matriz, y la matriz "
"se pondrá a cero inicialmente. De lo contrario, *size_or_initializer* es una "
"secuencia que se utiliza para inicializar la matriz y cuya longitud "
"determina la longitud de la matriz."

#: ../Doc/library/multiprocessing.rst:1525
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`Lock` or :class:"
"`RLock` object then that will be used to synchronize access to the value.  "
"If *lock* is ``False`` then access to the returned object will not be "
"automatically protected by a lock, so it will not necessarily be \"process-"
"safe\"."
msgstr ""
"Si *lock* es ``True`` (el valor predeterminado), se crea un nuevo objeto de "
"bloqueo para sincronizar el acceso al valor. Si *lock* es un objeto :class:"
"`Lock` o :class:`RLock`, se usará para sincronizar el acceso al valor. Si "
"*lock* es ``False``, entonces el acceso al objeto retornado no estará "
"protegido automáticamente por un candado, por lo que no será necesariamente "
"\"proceso seguro\"."

#: ../Doc/library/multiprocessing.rst:1532
msgid "Note that *lock* is a keyword only argument."
msgstr "Véase que *lock* es un argumento de solo una palabra clave."

#: ../Doc/library/multiprocessing.rst:1534
msgid ""
"Note that an array of :data:`ctypes.c_char` has *value* and *raw* attributes "
"which allow one to use it to store and retrieve strings."
msgstr ""
"Tenga en cuenta que una matriz de :data:`ctypes.c_char` tiene atributos "
"*value* y *raw* que le permiten a uno usarlo para almacenar y recuperar "
"cadenas de caracteres."

#: ../Doc/library/multiprocessing.rst:1539
msgid "The :mod:`multiprocessing.sharedctypes` module"
msgstr "El módulo :mod:`multiprocessing.sharedctypes`"

#: ../Doc/library/multiprocessing.rst:1544
msgid ""
"The :mod:`multiprocessing.sharedctypes` module provides functions for "
"allocating :mod:`ctypes` objects from shared memory which can be inherited "
"by child processes."
msgstr ""
"El módulo :mod:`multiprocessing.sharedctypes` proporciona funciones para "
"asignar objetos :mod:`ctypes` de la memoria compartida que pueden ser "
"heredados por procesos secundarios."

#: ../Doc/library/multiprocessing.rst:1550
msgid ""
"Although it is possible to store a pointer in shared memory remember that "
"this will refer to a location in the address space of a specific process. "
"However, the pointer is quite likely to be invalid in the context of a "
"second process and trying to dereference the pointer from the second process "
"may cause a crash."
msgstr ""
"Aunque es posible almacenar un puntero en la memoria compartida, recuerde "
"que esto se referirá a una ubicación en el espacio de direcciones de un "
"proceso específico. Sin embargo, es muy probable que el puntero sea inválido "
"en el contexto de un segundo proceso y tratar de desreferenciar el puntero "
"del segundo proceso puede causar un bloqueo."

#: ../Doc/library/multiprocessing.rst:1558
msgid "Return a ctypes array allocated from shared memory."
msgstr "Retorna una matriz *ctypes* asignada desde la memoria compartida."

#: ../Doc/library/multiprocessing.rst:1560
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* determina el tipo de los elementos de la matriz "
"retornada: es un tipo de tipo *ctypes* o un código de tipo de un carácter "
"del tipo utilizado por el módulo :mod:`array`. Si *size_or_initializer* es "
"un entero, entonces determina la longitud de la matriz, y la matriz se "
"pondrá a cero inicialmente. De lo contrario, *size_or_initializer* es una "
"secuencia que se usa para inicializar la matriz y cuya longitud determina la "
"longitud del arreglo."

#: ../Doc/library/multiprocessing.rst:1567
msgid ""
"Note that setting and getting an element is potentially non-atomic -- use :"
"func:`Array` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"Tenga en cuenta que configurar y obtener un elemento es potencialmente no "
"atómico -- utiliza :func:`Array` en su lugar para asegurarse de que el "
"acceso se sincronice automáticamente mediante un candado."

#: ../Doc/library/multiprocessing.rst:1573
msgid "Return a ctypes object allocated from shared memory."
msgstr "Retorna un objeto *ctypes* asignado desde la memoria compartida."

#: ../Doc/library/multiprocessing.rst:1579
msgid ""
"Note that setting and getting the value is potentially non-atomic -- use :"
"func:`Value` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"Tenga en cuenta que configurar y obtener el valor es potencialmente no "
"atómico -- use :func:`Value` en su lugar para asegurarse de que el acceso se "
"sincronice automáticamente mediante un candado."

#: ../Doc/library/multiprocessing.rst:1583
msgid ""
"Note that an array of :data:`ctypes.c_char` has ``value`` and ``raw`` "
"attributes which allow one to use it to store and retrieve strings -- see "
"documentation for :mod:`ctypes`."
msgstr ""
"Tenga en cuenta que una matriz de :data:`ctypes.c_char` tiene atributos "
"``value`` y ``raw`` que le permiten a uno usarlo para almacenar y recuperar "
"cadenas de caracteres -- consulte la documentación para :mod:`ctypes`."

#: ../Doc/library/multiprocessing.rst:1589
msgid ""
"The same as :func:`RawArray` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"array."
msgstr ""
"Lo mismo que :func:`RawArray`, excepto que, dependiendo del valor de *lock*, "
"se puede retornar un contenedor de sincronización seguro para el proceso en "
"lugar de un arreglo de tipos crudos."

#: ../Doc/library/multiprocessing.rst:1593
#: ../Doc/library/multiprocessing.rst:1609
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`~multiprocessing."
"Lock` or :class:`~multiprocessing.RLock` object then that will be used to "
"synchronize access to the value.  If *lock* is ``False`` then access to the "
"returned object will not be automatically protected by a lock, so it will "
"not necessarily be \"process-safe\"."
msgstr ""
"Si *lock* es ``True`` (el valor predeterminado), se crea un nuevo objeto "
"candado para sincronizar el acceso al valor. Si *lock* es un objeto :class:"
"`~multiprocessing.Lock` o :class:`~multiprocessing.RLock`, se utilizará para "
"sincronizar el acceso al valor. Si *lock* es ``False``, entonces el acceso "
"al objeto retornado no estará protegido automáticamente por un candado, por "
"lo que no será necesariamente \"seguro para el proceso\"."

#: ../Doc/library/multiprocessing.rst:1605
msgid ""
"The same as :func:`RawValue` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"object."
msgstr ""
"Lo mismo que :func:`RawValue` excepto que, dependiendo del valor de *lock*, "
"se puede retornar una envoltura de sincronización segura para el proceso en "
"lugar de un objeto *ctypes* sin procesar."

#: ../Doc/library/multiprocessing.rst:1620
msgid ""
"Return a ctypes object allocated from shared memory which is a copy of the "
"ctypes object *obj*."
msgstr ""
"Retorna un objeto *ctypes* asignado de la memoria compartida, que es una "
"copia del objeto *ctypes* *obj*."

#: ../Doc/library/multiprocessing.rst:1625
msgid ""
"Return a process-safe wrapper object for a ctypes object which uses *lock* "
"to synchronize access.  If *lock* is ``None`` (the default) then a :class:"
"`multiprocessing.RLock` object is created automatically."
msgstr ""
"Retorna un objeto contenedor seguro para un objeto *ctypes* que usa *lock* "
"para sincronizar el acceso. Si *lock* es ``None`` (el valor predeterminado), "
"se crea automáticamente un objeto :class:`multiprocessing.RLock`."

#: ../Doc/library/multiprocessing.rst:1629
msgid ""
"A synchronized wrapper will have two methods in addition to those of the "
"object it wraps: :meth:`get_obj` returns the wrapped object and :meth:"
"`get_lock` returns the lock object used for synchronization."
msgstr ""
"Un contenedor sincronizado tendrá dos métodos además de los del objeto que "
"envuelve: :meth:`get_obj` retorna el objeto envuelto y :meth:`get_lock` "
"retorna el objeto de bloqueo utilizado para la sincronización."

#: ../Doc/library/multiprocessing.rst:1633
msgid ""
"Note that accessing the ctypes object through the wrapper can be a lot "
"slower than accessing the raw ctypes object."
msgstr ""
"Tenga en cuenta que acceder al objeto *ctypes* a través del contenedor puede "
"ser mucho más lento que acceder al objeto *ctypes* sin formato."

#: ../Doc/library/multiprocessing.rst:1636
msgid "Synchronized objects support the :term:`context manager` protocol."
msgstr ""
"Los objetos sincronizados admiten el protocolo: :term:`context manager`."

#: ../Doc/library/multiprocessing.rst:1640
msgid ""
"The table below compares the syntax for creating shared ctypes objects from "
"shared memory with the normal ctypes syntax.  (In the table ``MyStruct`` is "
"some subclass of :class:`ctypes.Structure`.)"
msgstr ""
"La siguiente tabla compara la sintaxis para crear objetos *ctypes* "
"compartidos desde la memoria compartida con la sintaxis *ctypes* normal. (En "
"la tabla ``MyStruct`` hay alguna subclase de :class:`ctypes.Structure`.)"

#: ../Doc/library/multiprocessing.rst:1645
msgid "ctypes"
msgstr "*ctypes*"

#: ../Doc/library/multiprocessing.rst:1645
msgid "sharedctypes using type"
msgstr "*sharedctypes* usando *type*"

#: ../Doc/library/multiprocessing.rst:1645
msgid "sharedctypes using typecode"
msgstr "*sharedctypes* usando *typecode*"

#: ../Doc/library/multiprocessing.rst:1647
msgid "c_double(2.4)"
msgstr "*c_double(2.4)*"

#: ../Doc/library/multiprocessing.rst:1647
msgid "RawValue(c_double, 2.4)"
msgstr "*RawValue(c_double, 2.4)*"

#: ../Doc/library/multiprocessing.rst:1647
msgid "RawValue('d', 2.4)"
msgstr "*RawValue('d', 2.4)*"

#: ../Doc/library/multiprocessing.rst:1648
msgid "MyStruct(4, 6)"
msgstr "*MyStruct(4, 6)*"

#: ../Doc/library/multiprocessing.rst:1648
msgid "RawValue(MyStruct, 4, 6)"
msgstr "*RawValue(MyStruct, 4, 6)*"

#: ../Doc/library/multiprocessing.rst:1649
msgid "(c_short * 7)()"
msgstr "*(c_short * 7)()*"

#: ../Doc/library/multiprocessing.rst:1649
msgid "RawArray(c_short, 7)"
msgstr "*RawArray(c_short, 7)*"

#: ../Doc/library/multiprocessing.rst:1649
msgid "RawArray('h', 7)"
msgstr "*RawArray(‘h’, 7)*"

#: ../Doc/library/multiprocessing.rst:1650
msgid "(c_int * 3)(9, 2, 8)"
msgstr "*(c_int * 3)(9, 2, 8)*"

#: ../Doc/library/multiprocessing.rst:1650
msgid "RawArray(c_int, (9, 2, 8))"
msgstr "*RawArray(c_int, (9, 2, 8))*"

#: ../Doc/library/multiprocessing.rst:1650
msgid "RawArray('i', (9, 2, 8))"
msgstr "*RawArray('i', (9, 2, 8))*"

#: ../Doc/library/multiprocessing.rst:1654
msgid ""
"Below is an example where a number of ctypes objects are modified by a child "
"process::"
msgstr ""
"A continuación se muestra un ejemplo donde un número de objetos *ctypes* son "
"modificados por un proceso hijo::"

#: ../Doc/library/multiprocessing.rst:1692
msgid "The results printed are ::"
msgstr "Los resultados impresos son ::"

#: ../Doc/library/multiprocessing.rst:1705
msgid "Managers"
msgstr "Administradores (*Managers*)"

#: ../Doc/library/multiprocessing.rst:1707
msgid ""
"Managers provide a way to create data which can be shared between different "
"processes, including sharing over a network between processes running on "
"different machines. A manager object controls a server process which manages "
"*shared objects*.  Other processes can access the shared objects by using "
"proxies."
msgstr ""
"Los administradores (*managers*) proporcionan una forma de crear datos que "
"se pueden compartir entre diferentes procesos, incluido el intercambio en "
"una red entre procesos que se ejecutan en diferentes máquinas. Un objeto "
"administrador controla un proceso de servidor que gestiona *shared objects* "
"(*objetos compartidos*). Otros procesos pueden acceder a los objetos "
"compartidos mediante el uso de servidores proxy."

#: ../Doc/library/multiprocessing.rst:1716
msgid ""
"Returns a started :class:`~multiprocessing.managers.SyncManager` object "
"which can be used for sharing objects between processes.  The returned "
"manager object corresponds to a spawned child process and has methods which "
"will create shared objects and return corresponding proxies."
msgstr ""
"Retorna un objeto iniciado :class:`~multiprocessing.managers.SyncManager` "
"que se puede usar para compartir objetos entre procesos. El objeto "
"administrador retornado corresponde a un proceso hijo generado y tiene "
"métodos que crearán objetos compartidos y retornarán los proxies "
"correspondientes."

#: ../Doc/library/multiprocessing.rst:1724
msgid ""
"Manager processes will be shutdown as soon as they are garbage collected or "
"their parent process exits.  The manager classes are defined in the :mod:"
"`multiprocessing.managers` module:"
msgstr ""
"Los procesos del administrador se cerrarán tan pronto como se recolecte la "
"basura o salga su proceso padre. Las clases de administrador se definen en "
"el módulo :mod:`multiprocessing.managers`:"

#: ../Doc/library/multiprocessing.rst:1730
msgid "Create a BaseManager object."
msgstr "Crear un objeto *BaseManager*."

#: ../Doc/library/multiprocessing.rst:1732
msgid ""
"Once created one should call :meth:`start` or ``get_server()."
"serve_forever()`` to ensure that the manager object refers to a started "
"manager process."
msgstr ""
"Una vez creado, debe llamar a :meth:`start` o ``get_server()."
"serve_forever()`` para asegurarse de que el objeto de administrador se "
"refiera a un proceso de administrador iniciado."

#: ../Doc/library/multiprocessing.rst:1735
msgid ""
"*address* is the address on which the manager process listens for new "
"connections.  If *address* is ``None`` then an arbitrary one is chosen."
msgstr ""
"*address* es la dirección en la que el proceso del administrador escucha las "
"nuevas conexiones. Si *address* es ``None``, se elige una arbitrariamente."

#: ../Doc/library/multiprocessing.rst:1738
msgid ""
"*authkey* is the authentication key which will be used to check the validity "
"of incoming connections to the server process.  If *authkey* is ``None`` "
"then ``current_process().authkey`` is used. Otherwise *authkey* is used and "
"it must be a byte string."
msgstr ""
"*authkey* es la clave de autenticación que se utilizará para verificar la "
"validez de las conexiones entrantes al proceso del servidor. Si *authkey* es "
"``None``, entonces se usa ``current_process().authkey``. De lo contrario, se "
"usa *authkey* y debe ser una cadena de *bytes*."

#: ../Doc/library/multiprocessing.rst:1743
msgid ""
"*serializer* must be ``'pickle'`` (use :mod:`pickle` serialization) or "
"``'xmlrpclib'`` (use :mod:`xmlrpc.client` serialization)."
msgstr ""
"*serializer* debe ser ``'pickle'`` (usar serialización :mod:`pickle`) o "
"``'xmlrpclib'`` (usar serialización :mod:`xmlrpc.client`)."

#: ../Doc/library/multiprocessing.rst:1746
msgid ""
"*ctx* is a context object, or ``None`` (use the current context). See the :"
"func:`get_context` function."
msgstr ""
"*ctx* es un objeto de contexto, o ``None`` (utilice el contexto actual). "
"Consulte la función :func:`get_context`."

#: ../Doc/library/multiprocessing.rst:1749
msgid ""
"*shutdown_timeout* is a timeout in seconds used to wait until the process "
"used by the manager completes in the :meth:`shutdown` method. If the "
"shutdown times out, the process is terminated. If terminating the process "
"also times out, the process is killed."
msgstr ""
"*shutdown_timeout* es un tiempo de espera en segundos que se utiliza para "
"esperar hasta que el proceso utilizado por el administrador se complete en "
"el método :meth:`shutdown`. Si se agota el tiempo de apagado, el proceso "
"finaliza. Si la finalización del proceso también supera el tiempo de espera, "
"el proceso se cancela."

#: ../Doc/library/multiprocessing.rst:1754
msgid "Added the *shutdown_timeout* parameter."
msgstr "Se agregó el parámetro *shutdown_timeout*."

#: ../Doc/library/multiprocessing.rst:1759
msgid ""
"Start a subprocess to start the manager.  If *initializer* is not ``None`` "
"then the subprocess will call ``initializer(*initargs)`` when it starts."
msgstr ""
"Se inicia un subproceso para iniciar el administrador. Si *initializer* no "
"es ``None``, entonces el subproceso llamará ``initializer(*initargs)`` "
"cuando se inicie."

#: ../Doc/library/multiprocessing.rst:1764
msgid ""
"Returns a :class:`Server` object which represents the actual server under "
"the control of the Manager. The :class:`Server` object supports the :meth:"
"`serve_forever` method::"
msgstr ""
"Retorna un objeto :class:`Server` que representa el servidor real bajo el "
"control del Administrador. El objeto :class:`Server` admite el método :meth:"
"`serve_forever`::"

#: ../Doc/library/multiprocessing.rst:1773
msgid ":class:`Server` additionally has an :attr:`address` attribute."
msgstr ":class:`Server` tiene un atributo adicional :attr:`address`."

#: ../Doc/library/multiprocessing.rst:1777
msgid "Connect a local manager object to a remote manager process::"
msgstr ""
"Conecta un objeto de administrador (*manager*) local a un proceso de "
"administrador remoto::"

#: ../Doc/library/multiprocessing.rst:1785
msgid ""
"Stop the process used by the manager.  This is only available if :meth:"
"`start` has been used to start the server process."
msgstr ""
"Detiene el proceso utilizado por el gerente (*manager*). Esto solo está "
"disponible si :meth:`start` se ha utilizado para iniciar el proceso del "
"servidor."

#: ../Doc/library/multiprocessing.rst:1788
msgid "This can be called multiple times."
msgstr "Esto se puede llamar múltiples veces."

#: ../Doc/library/multiprocessing.rst:1792
msgid ""
"A classmethod which can be used for registering a type or callable with the "
"manager class."
msgstr ""
"Un método de clase que puede usarse para registrar un tipo o invocarse con "
"la clase de administrador (*manager*)."

#: ../Doc/library/multiprocessing.rst:1795
msgid ""
"*typeid* is a \"type identifier\" which is used to identify a particular "
"type of shared object.  This must be a string."
msgstr ""
"*typeid* es un \"identificador de tipo\" que se utiliza para identificar un "
"tipo particular de objeto compartido. Esto debe ser una cadena de caracteres."

#: ../Doc/library/multiprocessing.rst:1798
msgid ""
"*callable* is a callable used for creating objects for this type "
"identifier.  If a manager instance will be connected to the server using "
"the :meth:`connect` method, or if the *create_method* argument is ``False`` "
"then this can be left as ``None``."
msgstr ""
"*callable* es un invocable utilizado para crear objetos para este "
"identificador de tipo. Si una instancia de administrador se conectará al "
"servidor utilizando el método :meth:`connect`, o si el argumento "
"*create_method* es ``False``, esto se puede dejar como ``None``."

#: ../Doc/library/multiprocessing.rst:1804
msgid ""
"*proxytype* is a subclass of :class:`BaseProxy` which is used to create "
"proxies for shared objects with this *typeid*.  If ``None`` then a proxy "
"class is created automatically."
msgstr ""
"*proxytype* es una subclase de :class:`BaseProxy` que se usa para crear "
"*proxies* para objetos compartidos con este *typeid*. Si ``None``, se crea "
"automáticamente una clase proxy."

#: ../Doc/library/multiprocessing.rst:1808
msgid ""
"*exposed* is used to specify a sequence of method names which proxies for "
"this typeid should be allowed to access using :meth:`BaseProxy."
"_callmethod`.  (If *exposed* is ``None`` then :attr:`proxytype._exposed_` is "
"used instead if it exists.)  In the case where no exposed list is specified, "
"all \"public methods\" of the shared object will be accessible.  (Here a "
"\"public method\" means any attribute which has a :meth:`~object.__call__` "
"method and whose name does not begin with ``'_'``.)"
msgstr ""
"Se utiliza *exposed* para especificar una secuencia de nombres de métodos a "
"los que se debe permitir el acceso de los servidores proxy para este tipo de "
"identificación utilizando :meth:`BaseProxy._callmethod`. (Si *exposed* es "
"``None``, entonces :attr:`proxytype._exposed_` se usa en su lugar si "
"existe). En el caso de que no se especifique una lista expuesta, todos los "
"\"métodos públicos\" del objeto compartido serán accesibles . (Aquí un "
"\"método público\" significa cualquier atributo que tenga un método :meth:"
"`~object.__call__` y cuyo nombre no comience con ``'_'``.)"

#: ../Doc/library/multiprocessing.rst:1817
msgid ""
"*method_to_typeid* is a mapping used to specify the return type of those "
"exposed methods which should return a proxy.  It maps method names to typeid "
"strings.  (If *method_to_typeid* is ``None`` then :attr:`proxytype."
"_method_to_typeid_` is used instead if it exists.)  If a method's name is "
"not a key of this mapping or if the mapping is ``None`` then the object "
"returned by the method will be copied by value."
msgstr ""
"El *method_to_typeid* es una asignación utilizada para especificar el tipo "
"de retorno de los métodos expuestos que deberían retornar un proxy. Asigna "
"nombres de métodos a cadenas *typeid*. (Si *method_to_typeid* es ``None`` "
"entonces :attr:`proxytype._method_to_typeid` se usa en su lugar si existe). "
"Si el nombre de un método no es una clave de esta asignación o si la "
"asignación es ``None`` entonces el objeto retornado por el método se copiará "
"por valor."

#: ../Doc/library/multiprocessing.rst:1824
msgid ""
"*create_method* determines whether a method should be created with name "
"*typeid* which can be used to tell the server process to create a new shared "
"object and return a proxy for it.  By default it is ``True``."
msgstr ""
"*create_method* determina si un método debe crearse con el nombre *typeid* "
"que se puede usar para indicarle al proceso del servidor que cree un nuevo "
"objeto compartido y retornando un proxy para él. Por defecto es ``True``."

#: ../Doc/library/multiprocessing.rst:1828
msgid ":class:`BaseManager` instances also have one read-only property:"
msgstr ""
":class:`BaseManager` las instancias también tienen una propiedad de solo "
"lectura:"

#: ../Doc/library/multiprocessing.rst:1832
msgid "The address used by the manager."
msgstr "La dirección utilizada por el administrador."

#: ../Doc/library/multiprocessing.rst:1834
msgid ""
"Manager objects support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` starts the server "
"process (if it has not already started) and then returns the manager "
"object.  :meth:`~contextmanager.__exit__` calls :meth:`shutdown`."
msgstr ""
"Los objetos de administrador admiten el protocolo de gestión de contexto; "
"consulte :ref:`typecontextmanager`. :meth:`~contextmanager.__enter__` inicia "
"el proceso del servidor (si aún no se ha iniciado) y luego retorna el objeto "
"de administrador. :meth:`~contextmanager .__exit__` llama :meth:`shutdown`."

#: ../Doc/library/multiprocessing.rst:1840
msgid ""
"In previous versions :meth:`~contextmanager.__enter__` did not start the "
"manager's server process if it was not already started."
msgstr ""
"En versiones anteriores :meth:`~contextmanager.__enter__` no iniciaba el "
"proceso del servidor del administrador si aún no se había iniciado."

#: ../Doc/library/multiprocessing.rst:1845
msgid ""
"A subclass of :class:`BaseManager` which can be used for the synchronization "
"of processes.  Objects of this type are returned by :func:`multiprocessing."
"Manager`."
msgstr ""
"Una subclase de :class:`BaseManager` que se puede utilizar para la "
"sincronización de procesos. Los objetos de este tipo son retornados por :"
"func:`multiprocessing.Manager`."

#: ../Doc/library/multiprocessing.rst:1849
msgid ""
"Its methods create and return :ref:`multiprocessing-proxy_objects` for a "
"number of commonly used data types to be synchronized across processes. This "
"notably includes shared lists and dictionaries."
msgstr ""
"Sus métodos crean y retornan :ref:`multiprocessing-proxy_objects` para "
"varios tipos de datos de uso común que se sincronizarán entre procesos. Esto "
"incluye notablemente listas compartidas y diccionarios."

#: ../Doc/library/multiprocessing.rst:1855
msgid ""
"Create a shared :class:`threading.Barrier` object and return a proxy for it."
msgstr ""
":class:`threading.Barrier` crea un objeto compartido y retorna un proxy para "
"él."

#: ../Doc/library/multiprocessing.rst:1862
msgid ""
"Create a shared :class:`threading.BoundedSemaphore` object and return a "
"proxy for it."
msgstr ""
"Crea un objeto compartido :class:`threading.BoundedSemaphore` y retorna un "
"proxy para él."

#: ../Doc/library/multiprocessing.rst:1867
msgid ""
"Create a shared :class:`threading.Condition` object and return a proxy for "
"it."
msgstr ""
"Crea un objeto compartido :class:`threading.Condition` y retorna un proxy "
"para él."

#: ../Doc/library/multiprocessing.rst:1870
msgid ""
"If *lock* is supplied then it should be a proxy for a :class:`threading."
"Lock` or :class:`threading.RLock` object."
msgstr ""
"Si se proporciona *lock*, debería ser un proxy para un objeto :class:"
"`threading.Lock` o :class:`threading.RLock`."

#: ../Doc/library/multiprocessing.rst:1878
msgid ""
"Create a shared :class:`threading.Event` object and return a proxy for it."
msgstr ""
"Crea un objeto compartido :class:`threading.Event` y retorna un proxy para "
"él."

#: ../Doc/library/multiprocessing.rst:1882
msgid ""
"Create a shared :class:`threading.Lock` object and return a proxy for it."
msgstr ""
"Crea un objeto compartido :class:`threading.Lock` y retorna un proxy para él."

#: ../Doc/library/multiprocessing.rst:1886
msgid "Create a shared :class:`Namespace` object and return a proxy for it."
msgstr ""
"Crea un objeto compartido :class:`Namespace` y retorna un proxy para él."

#: ../Doc/library/multiprocessing.rst:1890
msgid "Create a shared :class:`queue.Queue` object and return a proxy for it."
msgstr ""
"Crea un objeto compartido :class:`queue.Queue` y retorna un proxy para él."

#: ../Doc/library/multiprocessing.rst:1894
msgid ""
"Create a shared :class:`threading.RLock` object and return a proxy for it."
msgstr ""
"Crea un objeto compartido :class:`threading.RLock` y retorna un proxy para "
"él."

#: ../Doc/library/multiprocessing.rst:1898
msgid ""
"Create a shared :class:`threading.Semaphore` object and return a proxy for "
"it."
msgstr ""
"Crea un objeto compartido :class:`threading.Semaphore` y retorna un proxy "
"para él."

#: ../Doc/library/multiprocessing.rst:1903
msgid "Create an array and return a proxy for it."
msgstr "Crea un arreglo y retorna un proxy para ello."

#: ../Doc/library/multiprocessing.rst:1907
msgid ""
"Create an object with a writable ``value`` attribute and return a proxy for "
"it."
msgstr ""
"Crea un objeto con un atributo de escritura ``value`` y retorna un proxy "
"para él."

#: ../Doc/library/multiprocessing.rst:1914
msgid "Create a shared :class:`dict` object and return a proxy for it."
msgstr "Crea un objeto compartido :class:`dict` y retorna un proxy para él."

#: ../Doc/library/multiprocessing.rst:1919
msgid "Create a shared :class:`list` object and return a proxy for it."
msgstr "Crea un objeto compartido :class:`list` y retorna un proxy para él."

#: ../Doc/library/multiprocessing.rst:1921
msgid ""
"Shared objects are capable of being nested.  For example, a shared container "
"object such as a shared list can contain other shared objects which will all "
"be managed and synchronized by the :class:`SyncManager`."
msgstr ""
"Los objetos compartidos pueden anidarse. Por ejemplo, un objeto contenedor "
"compartido, como una lista compartida, puede contener otros objetos "
"compartidos que serán administrados y sincronizados por :class:`SyncManager`."

#: ../Doc/library/multiprocessing.rst:1928
msgid "A type that can register with :class:`SyncManager`."
msgstr "Un tipo que puede registrarse con :class:`SyncManager`."

#: ../Doc/library/multiprocessing.rst:1930
msgid ""
"A namespace object has no public methods, but does have writable attributes. "
"Its representation shows the values of its attributes."
msgstr ""
"Un objeto de espacio de nombres no tiene métodos públicos, pero tiene "
"atributos de escritura. Su representación muestra los valores de sus "
"atributos."

#: ../Doc/library/multiprocessing.rst:1933
msgid ""
"However, when using a proxy for a namespace object, an attribute beginning "
"with ``'_'`` will be an attribute of the proxy and not an attribute of the "
"referent:"
msgstr ""
"Sin embargo, cuando se usa un proxy para un objeto de espacio de nombres, un "
"atributo que comience con ``'_'`` será un atributo del proxy y no un "
"atributo del referente:"

#: ../Doc/library/multiprocessing.rst:1950
msgid "Customized managers"
msgstr "Administradores customizables (*Customized managers*)"

#: ../Doc/library/multiprocessing.rst:1952
msgid ""
"To create one's own manager, one creates a subclass of :class:`BaseManager` "
"and uses the :meth:`~BaseManager.register` classmethod to register new types "
"or callables with the manager class.  For example::"
msgstr ""
"Para crear su propio administrador, uno crea una subclase de :class:"
"`BaseManager` y utiliza el método de clase :meth:`~BaseManager.register` "
"para registrar nuevos tipos o llamadas con la clase de administrador. Por "
"ejemplo::"

#: ../Doc/library/multiprocessing.rst:1977
msgid "Using a remote manager"
msgstr "Utilizando un administrador remoto"

#: ../Doc/library/multiprocessing.rst:1979
msgid ""
"It is possible to run a manager server on one machine and have clients use "
"it from other machines (assuming that the firewalls involved allow it)."
msgstr ""
"Es posible ejecutar un servidor administrador en una máquina y hacer que los "
"clientes lo usen desde otras máquinas (suponiendo que los cortafuegos "
"involucrados lo permitan)."

#: ../Doc/library/multiprocessing.rst:1982
msgid ""
"Running the following commands creates a server for a single shared queue "
"which remote clients can access::"
msgstr ""
"La ejecución de los siguientes comandos crea un servidor para una única cola "
"compartida a la que los clientes remotos pueden acceder::"

#: ../Doc/library/multiprocessing.rst:1994
msgid "One client can access the server as follows::"
msgstr "Un cliente puede tener accesos al servidor de la siguiente manera::"

#: ../Doc/library/multiprocessing.rst:2004
msgid "Another client can also use it::"
msgstr "Otro cliente puede también usarlo::"

#: ../Doc/library/multiprocessing.rst:2015
msgid ""
"Local processes can also access that queue, using the code from above on the "
"client to access it remotely::"
msgstr ""
"Los procesos locales también pueden acceder a esa cola (*queue*), utilizando "
"el código de arriba en el cliente para acceder de forma remota::"

#: ../Doc/library/multiprocessing.rst:2040
msgid "Proxy Objects"
msgstr "Objetos Proxy (*Proxy Objects*)"

#: ../Doc/library/multiprocessing.rst:2042
msgid ""
"A proxy is an object which *refers* to a shared object which lives "
"(presumably) in a different process.  The shared object is said to be the "
"*referent* of the proxy.  Multiple proxy objects may have the same referent."
msgstr ""
"Un proxy es un objeto que *se refiere* a un objeto compartido que vive "
"(presumiblemente) en un proceso diferente. Se dice que el objeto compartido "
"es el *referente* del proxy. Varios objetos proxy pueden tener el mismo "
"referente."

#: ../Doc/library/multiprocessing.rst:2046
msgid ""
"A proxy object has methods which invoke corresponding methods of its "
"referent (although not every method of the referent will necessarily be "
"available through the proxy).  In this way, a proxy can be used just like "
"its referent can:"
msgstr ""
"Un objeto proxy tiene métodos que invocan los métodos correspondientes de su "
"referente (aunque no todos los métodos del referente estarán necesariamente "
"disponibles a través del proxy). De esta manera, un proxy se puede usar al "
"igual que su referente:"

#: ../Doc/library/multiprocessing.rst:2064
msgid ""
"Notice that applying :func:`str` to a proxy will return the representation "
"of the referent, whereas applying :func:`repr` will return the "
"representation of the proxy."
msgstr ""
"Tenga en cuenta que la aplicación :func:`str` a un proxy retornará la "
"representación del referente, mientras que la aplicación :func:`repr` "
"retornará la representación del proxy."

#: ../Doc/library/multiprocessing.rst:2068
msgid ""
"An important feature of proxy objects is that they are picklable so they can "
"be passed between processes.  As such, a referent can contain :ref:"
"`multiprocessing-proxy_objects`.  This permits nesting of these managed "
"lists, dicts, and other :ref:`multiprocessing-proxy_objects`:"
msgstr ""
"Una característica importante de los objetos proxy es que son seleccionables "
"para que puedan pasarse entre procesos. Como tal, un referente puede "
"contener :ref:`multiprocessing-proxy_objects`. Esto permite anidar estas "
"listas administradas, dictados y otros :ref:`multiprocessing-proxy_objects`:"

#: ../Doc/library/multiprocessing.rst:2084
msgid "Similarly, dict and list proxies may be nested inside one another::"
msgstr ""
"Del mismo modo, los proxies *dict* y *list* pueden estar anidados uno dentro "
"del otro::"

#: ../Doc/library/multiprocessing.rst:2097
msgid ""
"If standard (non-proxy) :class:`list` or :class:`dict` objects are contained "
"in a referent, modifications to those mutable values will not be propagated "
"through the manager because the proxy has no way of knowing when the values "
"contained within are modified.  However, storing a value in a container "
"proxy (which triggers a ``__setitem__`` on the proxy object) does propagate "
"through the manager and so to effectively modify such an item, one could re-"
"assign the modified value to the container proxy::"
msgstr ""
"Si los objetos estándar (no proxy) :class:`list` or :class:`dict` están "
"contenidos en un referente, las modificaciones a esos valores mutables no se "
"propagarán a través del administrador porque el proxy no tiene forma de "
"saber cuándo los valores contenidos dentro son modificados. Sin embargo, "
"almacenar un valor en un proxy de contenedor (que desencadena un "
"``__setitem__`` en el objeto proxy) se propaga a través del administrador y, "
"por lo tanto, para modificar efectivamente dicho elemento, uno podría "
"reasignar el valor modificado al proxy de contenedor::"

#: ../Doc/library/multiprocessing.rst:2116
msgid ""
"This approach is perhaps less convenient than employing nested :ref:"
"`multiprocessing-proxy_objects` for most use cases but also demonstrates a "
"level of control over the synchronization."
msgstr ""
"Este enfoque es quizás menos conveniente que emplear anidado :ref:"
"`multiprocessing-proxy_objects` para la mayoría de los casos de uso, pero "
"también demuestra un nivel de control sobre la sincronización."

#: ../Doc/library/multiprocessing.rst:2122
msgid ""
"The proxy types in :mod:`multiprocessing` do nothing to support comparisons "
"by value.  So, for instance, we have:"
msgstr ""
"Los tipos de proxy en :mod:`multiprocessing` no hacen nada para admitir "
"comparaciones por valor. Entonces, por ejemplo, tenemos:"

#: ../Doc/library/multiprocessing.rst:2130
msgid ""
"One should just use a copy of the referent instead when making comparisons."
msgstr ""
"En su lugar, se debe usar una copia del referente al hacer comparaciones."

#: ../Doc/library/multiprocessing.rst:2134
msgid "Proxy objects are instances of subclasses of :class:`BaseProxy`."
msgstr "Los objetos proxy son instancias de subclases de :class:`BaseProxy`."

#: ../Doc/library/multiprocessing.rst:2138
msgid "Call and return the result of a method of the proxy's referent."
msgstr "Llama y retorna el resultado de un método del referente del proxy."

#: ../Doc/library/multiprocessing.rst:2140
msgid ""
"If ``proxy`` is a proxy whose referent is ``obj`` then the expression ::"
msgstr ""
"Si ``proxy`` es un proxy cuyo referente es ``obj`` entonces la expresión ::"

#: ../Doc/library/multiprocessing.rst:2144
msgid "will evaluate the expression ::"
msgstr "evaluará la expresión ::"

#: ../Doc/library/multiprocessing.rst:2148
msgid "in the manager's process."
msgstr "en el proceso del administrador."

#: ../Doc/library/multiprocessing.rst:2150
msgid ""
"The returned value will be a copy of the result of the call or a proxy to a "
"new shared object -- see documentation for the *method_to_typeid* argument "
"of :meth:`BaseManager.register`."
msgstr ""
"El valor retornado será una copia del resultado de la llamada o un proxy a "
"un nuevo objeto compartido; consulte la documentación del argumento "
"*method_to_typeid* de :meth:`BaseManager.register`."

#: ../Doc/library/multiprocessing.rst:2154
msgid ""
"If an exception is raised by the call, then is re-raised by :meth:"
"`_callmethod`.  If some other exception is raised in the manager's process "
"then this is converted into a :exc:`RemoteError` exception and is raised by :"
"meth:`_callmethod`."
msgstr ""
"Si la llamada genera una excepción, entonces se vuelve a generar :meth:"
"`_callmethod`. Si se genera alguna otra excepción en el proceso del "
"administrador, esto se convierte en una excepción :exc:`RemoteError` y se "
"genera mediante  :meth:`_callmethod`."

#: ../Doc/library/multiprocessing.rst:2159
msgid ""
"Note in particular that an exception will be raised if *methodname* has not "
"been *exposed*."
msgstr ""
"Tenga en cuenta en particular que se lanzará una excepción si *methodname* "
"no ha sido *exposed*."

#: ../Doc/library/multiprocessing.rst:2162
msgid "An example of the usage of :meth:`_callmethod`:"
msgstr "Un ejemplo de uso de :meth:`_callmethod`:"

#: ../Doc/library/multiprocessing.rst:2178
msgid "Return a copy of the referent."
msgstr "Retorna una copia del referente."

#: ../Doc/library/multiprocessing.rst:2180
msgid "If the referent is unpicklable then this will raise an exception."
msgstr ""
"Si el referente no se puede deserializar (*unpicklable*), esto lanzará una "
"excepción."

#: ../Doc/library/multiprocessing.rst:2184
msgid "Return a representation of the proxy object."
msgstr "Retorna una representación de un objeto proxy."

#: ../Doc/library/multiprocessing.rst:2188
msgid "Return the representation of the referent."
msgstr "Retorna una representación del referente."

#: ../Doc/library/multiprocessing.rst:2192
msgid "Cleanup"
msgstr "Limpieza (*Cleanup*)"

#: ../Doc/library/multiprocessing.rst:2194
msgid ""
"A proxy object uses a weakref callback so that when it gets garbage "
"collected it deregisters itself from the manager which owns its referent."
msgstr ""
"Un objeto proxy utiliza una devolución de llamada (*callback*) de referencia "
"débil (*weakref*) para que cuando sea recolectado por el recolector de "
"basura se da de baja del administrador que posee su referente."

#: ../Doc/library/multiprocessing.rst:2197
msgid ""
"A shared object gets deleted from the manager process when there are no "
"longer any proxies referring to it."
msgstr ""
"Un objeto compartido se elimina del proceso del administrador cuando ya no "
"hay ningún proxy que se refiera a él."

#: ../Doc/library/multiprocessing.rst:2202
msgid "Process Pools"
msgstr "Piscinas de procesos (*Process Pools*)"

#: ../Doc/library/multiprocessing.rst:2207
msgid ""
"One can create a pool of processes which will carry out tasks submitted to "
"it with the :class:`Pool` class."
msgstr ""
"Se puede crear un grupo de procesos que llevarán a cabo las tareas que se le "
"presenten con la  :class:`Pool` class."

#: ../Doc/library/multiprocessing.rst:2212
msgid ""
"A process pool object which controls a pool of worker processes to which "
"jobs can be submitted.  It supports asynchronous results with timeouts and "
"callbacks and has a parallel map implementation."
msgstr ""
"Un objeto de grupo de procesos que controla un grupo de procesos de trabajo "
"a los que se pueden enviar trabajos. Admite resultados asincrónicos con "
"tiempos de espera y devoluciones de llamada y tiene una implementación de "
"mapa paralelo."

#: ../Doc/library/multiprocessing.rst:2216
msgid ""
"*processes* is the number of worker processes to use.  If *processes* is "
"``None`` then the number returned by :func:`os.cpu_count` is used."
msgstr ""
"*processes* es el número de procesos de trabajo a utilizar. Si *processes* "
"es ``None`` , se utiliza el número retornado por :func:`os.cpu_count`."

#: ../Doc/library/multiprocessing.rst:2219
#: ../Doc/library/multiprocessing.rst:2780
msgid ""
"If *initializer* is not ``None`` then each worker process will call "
"``initializer(*initargs)`` when it starts."
msgstr ""
"Si *initializer* no es ``None``, cada proceso de trabajo llamará "
"``initializer(*initargs)`` cuando se inicie."

#: ../Doc/library/multiprocessing.rst:2222
msgid ""
"*maxtasksperchild* is the number of tasks a worker process can complete "
"before it will exit and be replaced with a fresh worker process, to enable "
"unused resources to be freed. The default *maxtasksperchild* is ``None``, "
"which means worker processes will live as long as the pool."
msgstr ""
"*maxtasksperchild* es el número de tareas que un proceso de trabajo puede "
"completar antes de salir y ser reemplazado por un proceso de trabajo nuevo, "
"para permitir que se liberen los recursos no utilizados. El valor "
"predeterminado *maxtasksperchild* es ``None``, lo que significa que los "
"procesos de trabajo vivirán tanto tiempo como el grupo."

#: ../Doc/library/multiprocessing.rst:2227
msgid ""
"*context* can be used to specify the context used for starting the worker "
"processes.  Usually a pool is created using the function :func:"
"`multiprocessing.Pool` or the :meth:`Pool` method of a context object.  In "
"both cases *context* is set appropriately."
msgstr ""
"*context* se puede utilizar para especificar el contexto utilizado para "
"iniciar los procesos de trabajo. Por lo general, un grupo se crea utilizando "
"la función :func:`multiprocessing.Pool` o el método de un objeto de "
"contexto :meth:`Pool`. En ambos casos, *context* se establece de manera "
"adecuada."

#: ../Doc/library/multiprocessing.rst:2233
msgid ""
"Note that the methods of the pool object should only be called by the "
"process which created the pool."
msgstr ""
"Tenga en cuenta que los métodos del objeto de grupo solo deben ser invocados "
"por el proceso que creó el grupo."

#: ../Doc/library/multiprocessing.rst:2237
msgid ""
":class:`multiprocessing.pool` objects have internal resources that need to "
"be properly managed (like any other resource) by using the pool as a context "
"manager or by calling :meth:`close` and :meth:`terminate` manually. Failure "
"to do this can lead to the process hanging on finalization."
msgstr ""
"Los objetos :class:`multiprocessing.pool` tienen recursos internos que "
"necesitan ser administrados adecuadamente (como cualquier otro recurso) "
"utilizando el grupo como administrador de contexto o llamando a :meth:"
"`close` y :meth:`terminate` manualmente. De lo contrario, el proceso puede "
"demorarse en la finalización."

#: ../Doc/library/multiprocessing.rst:2242
msgid ""
"Note that it is **not correct** to rely on the garbage collector to destroy "
"the pool as CPython does not assure that the finalizer of the pool will be "
"called (see :meth:`object.__del__` for more information)."
msgstr ""
"Tenga en cuenta que **no es correcto** confiar en el recolector de basura "
"para destruir el grupo ya que *CPython* no asegura que se llamará al "
"finalizador del grupo (consulte :meth:`object.__del__` para obtener más "
"información)."

#: ../Doc/library/multiprocessing.rst:2246
msgid "*maxtasksperchild*"
msgstr "*maxtasksperchild*"

#: ../Doc/library/multiprocessing.rst:2249
msgid "*context*"
msgstr "*context*"

#: ../Doc/library/multiprocessing.rst:2254
msgid ""
"Worker processes within a :class:`Pool` typically live for the complete "
"duration of the Pool's work queue. A frequent pattern found in other systems "
"(such as Apache, mod_wsgi, etc) to free resources held by workers is to "
"allow a worker within a pool to complete only a set amount of work before "
"being exiting, being cleaned up and a new process spawned to replace the old "
"one. The *maxtasksperchild* argument to the :class:`Pool` exposes this "
"ability to the end user."
msgstr ""
"Los procesos de los trabajadores dentro de una :class:`Pool` normalmente "
"viven durante la duración completa de la cola de trabajo de la piscina. Un "
"patrón frecuente que se encuentra en otros sistemas (como *Apache, mod_wsgi,"
"* etc.) para liberar recursos en poder de los trabajadores es permitir que "
"un trabajador dentro de un grupo complete solo una cantidad determinada de "
"trabajo antes de salir, limpiarse y generar un nuevo proceso para reemplazar "
"el viejo. El argumento *maxtasksperchild* para :class:`Pool` expone esta "
"capacidad al usuario final."

#: ../Doc/library/multiprocessing.rst:2264
msgid ""
"Call *func* with arguments *args* and keyword arguments *kwds*.  It blocks "
"until the result is ready. Given this blocks, :meth:`apply_async` is better "
"suited for performing work in parallel. Additionally, *func* is only "
"executed in one of the workers of the pool."
msgstr ""
"Llama a *func* con argumentos *args* y argumentos de palabras clave *kwds*. "
"Se bloquea hasta que el resultado esté listo. Dados estos bloques, :meth:"
"`apply_async` es más adecuado para realizar trabajos en paralelo. Además, "
"*func* solo se ejecuta en uno de los trabajadores de piscina."

#: ../Doc/library/multiprocessing.rst:2271
msgid ""
"A variant of the :meth:`apply` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ""
"Una variante del método :meth:`apply` que retorna un objeto :class:"
"`~multiprocessing.pool.AsyncResult`."

#: ../Doc/library/multiprocessing.rst:2274
#: ../Doc/library/multiprocessing.rst:2305
msgid ""
"If *callback* is specified then it should be a callable which accepts a "
"single argument.  When the result becomes ready *callback* is applied to it, "
"that is unless the call failed, in which case the *error_callback* is "
"applied instead."
msgstr ""
"Si se especifica *callback*, debería ser un invocable que acepte un único "
"argumento. Cuando el resultado está listo, se le aplica *callback*, a menos "
"que la llamada falle, en cuyo caso se aplica *error_callback*."

#: ../Doc/library/multiprocessing.rst:2279
#: ../Doc/library/multiprocessing.rst:2310
msgid ""
"If *error_callback* is specified then it should be a callable which accepts "
"a single argument.  If the target function fails, then the *error_callback* "
"is called with the exception instance."
msgstr ""
"Si se especifica *error_callback*, debería ser un invocable que acepte un "
"único argumento. Si la función de destino falla, se llama a *error_callback* "
"con la instancia de excepción."

#: ../Doc/library/multiprocessing.rst:2283
#: ../Doc/library/multiprocessing.rst:2314
msgid ""
"Callbacks should complete immediately since otherwise the thread which "
"handles the results will get blocked."
msgstr ""
"Las devoluciones de llamada deben completarse inmediatamente ya que de lo "
"contrario el hilo que maneja los resultados se bloqueará."

#: ../Doc/library/multiprocessing.rst:2288
msgid ""
"A parallel equivalent of the :func:`map` built-in function (it supports only "
"one *iterable* argument though, for multiple iterables see :meth:`starmap`). "
"It blocks until the result is ready."
msgstr ""
"Un equivalente paralelo de la función incorporada :func:`map` (aunque solo "
"admite un argumento *iterable*, para varios iterables consulte :meth:"
"`starmap`). Bloquea hasta que el resultado esté listo."

#: ../Doc/library/multiprocessing.rst:2292
msgid ""
"This method chops the iterable into a number of chunks which it submits to "
"the process pool as separate tasks.  The (approximate) size of these chunks "
"can be specified by setting *chunksize* to a positive integer."
msgstr ""
"Este método corta el iterable en varios trozos que envía al grupo de "
"procesos como tareas separadas. El tamaño (aproximado) de estos fragmentos "
"se puede especificar estableciendo *chunksize* en un entero positivo."

#: ../Doc/library/multiprocessing.rst:2296
msgid ""
"Note that it may cause high memory usage for very long iterables. Consider "
"using :meth:`imap` or :meth:`imap_unordered` with explicit *chunksize* "
"option for better efficiency."
msgstr ""
"Tenga en cuenta que puede causar un alto uso de memoria para iterables muy "
"largos. Considere usar :meth:`imap` o :meth:`imap_unordered` con la opción "
"explícita *chunksize* para una mejor eficiencia."

#: ../Doc/library/multiprocessing.rst:2302
msgid ""
"A variant of the :meth:`.map` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ""
"Una variante del método :meth:`.map` que retorna un objeto :class:"
"`~multiprocessing.pool.AsyncResult`."

#: ../Doc/library/multiprocessing.rst:2319
msgid "A lazier version of :meth:`.map`."
msgstr "Una versión más perezosa (*lazier*) de :meth:`.map`."

#: ../Doc/library/multiprocessing.rst:2321
msgid ""
"The *chunksize* argument is the same as the one used by the :meth:`.map` "
"method.  For very long iterables using a large value for *chunksize* can "
"make the job complete **much** faster than using the default value of ``1``."
msgstr ""
"El argumento *chunksize* es el mismo que el utilizado por el método :meth:`."
"map`. Para iterables muy largos, usar un valor grande para *chunksize* puede "
"hacer que el trabajo se complete **much** (**mucho**) más rápido que usar el "
"valor predeterminado de ``1``."

#: ../Doc/library/multiprocessing.rst:2326
msgid ""
"Also if *chunksize* is ``1`` then the :meth:`!next` method of the iterator "
"returned by the :meth:`imap` method has an optional *timeout* parameter: "
"``next(timeout)`` will raise :exc:`multiprocessing.TimeoutError` if the "
"result cannot be returned within *timeout* seconds."
msgstr ""
"Además, si *chunksize* es ``1``, el método :meth:`!next` del iterador "
"retornado por el método :meth:`imap` tiene un parámetro opcional *timeout* :"
"``next (timeout)`` lanzará  :exc:`multiprocessing.TimeoutError` si el "
"resultado no puede retornarse dentro de *timeout* segundos."

#: ../Doc/library/multiprocessing.rst:2333
msgid ""
"The same as :meth:`imap` except that the ordering of the results from the "
"returned iterator should be considered arbitrary.  (Only when there is only "
"one worker process is the order guaranteed to be \"correct\".)"
msgstr ""
"Lo mismo que :meth:`imap`, excepto que el orden de los resultados del "
"iterador retornado debe considerarse arbitrario. (Solo cuando hay un solo "
"proceso de trabajo se garantiza que el orden sea \"correcto\")."

#: ../Doc/library/multiprocessing.rst:2339
msgid ""
"Like :meth:`~multiprocessing.pool.Pool.map` except that the elements of the "
"*iterable* are expected to be iterables that are unpacked as arguments."
msgstr ""
"Como :meth:`~multiprocessing.pool.Pool.map`, excepto que se espera que los "
"elementos de *iterable* sean iterables que se desempaquetan como argumentos."

#: ../Doc/library/multiprocessing.rst:2343
msgid ""
"Hence an *iterable* of ``[(1,2), (3, 4)]`` results in ``[func(1,2), "
"func(3,4)]``."
msgstr ""
"Por lo tanto, un *iterable* de ``[(1,2), (3, 4)]`` da como resultado "
"``[func(1,2), func(3,4)]``."

#: ../Doc/library/multiprocessing.rst:2350
msgid ""
"A combination of :meth:`starmap` and :meth:`map_async` that iterates over "
"*iterable* of iterables and calls *func* with the iterables unpacked. "
"Returns a result object."
msgstr ""
"Una combinación de :meth:`starmap` y :meth:`map_async` que itera sobre "
"*iterable* de iterables y llama a *func* con los iterables desempaquetados. "
"Como resultado se retorna un objeto."

#: ../Doc/library/multiprocessing.rst:2358
msgid ""
"Prevents any more tasks from being submitted to the pool.  Once all the "
"tasks have been completed the worker processes will exit."
msgstr ""
"Impide que se envíen más tareas a la piscina (*pool*). Una vez que se hayan "
"completado todas las tareas, se cerrarán los procesos de trabajo."

#: ../Doc/library/multiprocessing.rst:2363
msgid ""
"Stops the worker processes immediately without completing outstanding work.  "
"When the pool object is garbage collected :meth:`terminate` will be called "
"immediately."
msgstr ""
"Detiene los procesos de trabajo inmediatamente sin completar el trabajo "
"pendiente. Cuando el objeto del grupo es basura recolectada :meth:"
"`terminate` se llamará inmediatamente."

#: ../Doc/library/multiprocessing.rst:2369
msgid ""
"Wait for the worker processes to exit.  One must call :meth:`close` or :meth:"
"`terminate` before using :meth:`join`."
msgstr ""
"Espera a que salgan los procesos de trabajo. Se debe llamar :meth:`close` o :"
"meth:`terminate` antes de usar :meth:`join`."

#: ../Doc/library/multiprocessing.rst:2372
msgid ""
"Pool objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the pool "
"object, and :meth:`~contextmanager.__exit__` calls :meth:`terminate`."
msgstr ""
"Los objetos de piscina (*pool*) ahora admiten el protocolo de administración "
"de contexto; consulte :ref:`typecontextmanager`. :meth:`~contextmanager.__ "
"enter__` retorna el objeto de grupo, y :meth:`~ contextmanager.__ exit__` "
"llama :meth:`terminate`."

#: ../Doc/library/multiprocessing.rst:2380
msgid ""
"The class of the result returned by :meth:`Pool.apply_async` and :meth:`Pool."
"map_async`."
msgstr ""
"La clase del resultado retornado por :meth:`Pool.apply_async` y :meth:`Pool."
"map_async`."

#: ../Doc/library/multiprocessing.rst:2385
msgid ""
"Return the result when it arrives.  If *timeout* is not ``None`` and the "
"result does not arrive within *timeout* seconds then :exc:`multiprocessing."
"TimeoutError` is raised.  If the remote call raised an exception then that "
"exception will be reraised by :meth:`get`."
msgstr ""
"Retorna el resultado cuando llegue. Si *timeout* no es ``None`` y el "
"resultado no llega dentro de *timeout* segundos, entonces se lanza :exc:"
"`multiprocessing.TimeoutError`. Si la llamada remota generó una excepción, "
"esa excepción se volverá a plantear mediante :meth:`get`."

#: ../Doc/library/multiprocessing.rst:2392
msgid "Wait until the result is available or until *timeout* seconds pass."
msgstr ""
"Espera hasta que el resultado esté disponible o hasta que pase *timeout* "
"segundos."

#: ../Doc/library/multiprocessing.rst:2396
msgid "Return whether the call has completed."
msgstr "Retorna si la llamada se ha completado."

#: ../Doc/library/multiprocessing.rst:2400
msgid ""
"Return whether the call completed without raising an exception.  Will raise :"
"exc:`ValueError` if the result is not ready."
msgstr ""
"Retorna si la llamada se completó sin generar una excepción. Lanzará :exc:"
"`ValueError` si el resultado no está listo."

#: ../Doc/library/multiprocessing.rst:2403
msgid ""
"If the result is not ready, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr ""
"Si el resultado no está listo :exc:`ValueError` aparece en lugar de :exc:"
"`AssertionError`."

#: ../Doc/library/multiprocessing.rst:2407
msgid "The following example demonstrates the use of a pool::"
msgstr "El siguiente ejemplo demuestra el uso de una piscina(*pool*)::"

#: ../Doc/library/multiprocessing.rst:2434
msgid "Listeners and Clients"
msgstr "Oyentes y clientes (*Listeners and Clients*)"

#: ../Doc/library/multiprocessing.rst:2439
msgid ""
"Usually message passing between processes is done using queues or by using :"
"class:`~Connection` objects returned by :func:`~multiprocessing.Pipe`."
msgstr ""
"Por lo general, el paso de mensajes entre procesos se realiza mediante colas "
"o mediante objetos :class:`~Connection` retornados por :func:"
"`~multiprocessing.Pipe`."

#: ../Doc/library/multiprocessing.rst:2443
msgid ""
"However, the :mod:`multiprocessing.connection` module allows some extra "
"flexibility.  It basically gives a high level message oriented API for "
"dealing with sockets or Windows named pipes.  It also has support for "
"*digest authentication* using the :mod:`hmac` module, and for polling "
"multiple connections at the same time."
msgstr ""
"Sin embargo, el módulo :mod:`multiprocessing.connection` permite cierta "
"flexibilidad adicional. Básicamente proporciona una API orientada a mensajes "
"de alto nivel para tratar con sockets o canalizaciones con nombre de "
"Windows. También tiene soporte para *digest authentication* usando el "
"módulo :mod:`hmac`, y para sondear múltiples conexiones al mismo tiempo."

#: ../Doc/library/multiprocessing.rst:2452
msgid ""
"Send a randomly generated message to the other end of the connection and "
"wait for a reply."
msgstr ""
"Envía un mensaje generado aleatoriamente al otro extremo de la conexión y "
"espera una respuesta."

#: ../Doc/library/multiprocessing.rst:2455
msgid ""
"If the reply matches the digest of the message using *authkey* as the key "
"then a welcome message is sent to the other end of the connection.  "
"Otherwise :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"Si la respuesta coincide con el resumen del mensaje utilizando *authkey* "
"como clave, se envía un mensaje de bienvenida al otro extremo de la "
"conexión. De lo contrario se lanza :exc:`~multiprocessing."
"AuthenticationError`."

#: ../Doc/library/multiprocessing.rst:2461
msgid ""
"Receive a message, calculate the digest of the message using *authkey* as "
"the key, and then send the digest back."
msgstr ""
"Recibe un mensaje, calcula el resumen del mensaje usando *authkey* como la "
"clave y luego envía el resumen de vuelta."

#: ../Doc/library/multiprocessing.rst:2464
msgid ""
"If a welcome message is not received, then :exc:`~multiprocessing."
"AuthenticationError` is raised."
msgstr ""
"Si no se recibe un mensaje de bienvenida, se lanza :exc:`~multiprocessing."
"AuthenticationError`."

#: ../Doc/library/multiprocessing.rst:2469
msgid ""
"Attempt to set up a connection to the listener which is using address "
"*address*, returning a :class:`~Connection`."
msgstr ""
"Se intenta configurar una conexión con el oyente que utiliza la dirección "
"*address*, retornando :class:`~Connection`."

#: ../Doc/library/multiprocessing.rst:2472
msgid ""
"The type of the connection is determined by *family* argument, but this can "
"generally be omitted since it can usually be inferred from the format of "
"*address*. (See :ref:`multiprocessing-address-formats`)"
msgstr ""
"El tipo de conexión está determinado por el argumento *family*, pero esto "
"generalmente se puede omitir ya que generalmente se puede inferir del "
"formato de *address*. (Consulte :ref:`multiprocessing-address-formats`)"

#: ../Doc/library/multiprocessing.rst:2476
#: ../Doc/library/multiprocessing.rst:2511
msgid ""
"If *authkey* is given and not None, it should be a byte string and will be "
"used as the secret key for an HMAC-based authentication challenge. No "
"authentication is done if *authkey* is None. :exc:`~multiprocessing."
"AuthenticationError` is raised if authentication fails. See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""
"Si se proporciona *authkey* y no *None*, debe ser una cadena de *bytes* y se "
"utilizará como clave secreta para un desafío de autenticación basado en "
"HMAC. No se realiza la autenticación si *authkey* es *None*. Si falla la "
"autenticación se lanza :exc:`~multiprocessing.AuthenticationError`. "
"Consulte :ref:`multiprocessing-auth-keys`."

#: ../Doc/library/multiprocessing.rst:2484
msgid ""
"A wrapper for a bound socket or Windows named pipe which is 'listening' for "
"connections."
msgstr ""
"Un contenedor para un *socket* vinculado o una tubería (*pipe*) con nombre "
"de Windows que está 'escuchando' las conexiones."

#: ../Doc/library/multiprocessing.rst:2487
msgid ""
"*address* is the address to be used by the bound socket or named pipe of the "
"listener object."
msgstr ""
"*address* es la dirección que utilizará el *socket* vinculado o la conocida "
"tubería (*pipe*) con nombre del objeto de escucha."

#: ../Doc/library/multiprocessing.rst:2492
msgid ""
"If an address of '0.0.0.0' is used, the address will not be a connectable "
"end point on Windows. If you require a connectable end-point, you should use "
"'127.0.0.1'."
msgstr ""
"Si se usa una dirección de '0.0.0.0' , la dirección no será un punto final "
"conectable en Windows. Si necesita un punto final conectable, debe usar "
"'127.0.0.1'."

#: ../Doc/library/multiprocessing.rst:2496
msgid ""
"*family* is the type of socket (or named pipe) to use.  This can be one of "
"the strings ``'AF_INET'`` (for a TCP socket), ``'AF_UNIX'`` (for a Unix "
"domain socket) or ``'AF_PIPE'`` (for a Windows named pipe).  Of these only "
"the first is guaranteed to be available.  If *family* is ``None`` then the "
"family is inferred from the format of *address*.  If *address* is also "
"``None`` then a default is chosen.  This default is the family which is "
"assumed to be the fastest available.  See :ref:`multiprocessing-address-"
"formats`.  Note that if *family* is ``'AF_UNIX'`` and address is ``None`` "
"then the socket will be created in a private temporary directory created "
"using :func:`tempfile.mkstemp`."
msgstr ""
"*family* es el tipo de socket (o tubería con nombre) a utilizar. Esta puede "
"ser una de las cadenas de caracteres ``'AF_INET'`` (para un socket TCP), ``' "
"AF_UNIX'`` (para un socket de dominio Unix) o ``'AF_PIPE'`` (para una "
"tubería con nombre de Windows) . De estos, solo el primero está garantizado "
"para estar disponible. Si *family* es ``None`` , *family* se deduce del "
"formato de *address*. Si *address* también es ``None`` , se elige un valor "
"predeterminado. Este valor predeterminado es *family* con la opción más "
"rápida disponible. Consulte :ref:`multiprocessing-address-formats`. Tenga en "
"cuenta que si *family* es ``'AF_UNIX'`` y la dirección es ``None``, el "
"*socket* se creará en un directorio temporal privado usando :func:`tempfile."
"mkstemp`."

#: ../Doc/library/multiprocessing.rst:2507
msgid ""
"If the listener object uses a socket then *backlog* (1 by default) is passed "
"to the :meth:`~socket.socket.listen` method of the socket once it has been "
"bound."
msgstr ""
"Si el objeto de escucha utiliza un *socket*, entonces *backlog* (1 por "
"defecto) se pasa al método :meth:`~socket.socket.listen` del *socket* una "
"vez que se ha vinculado."

#: ../Doc/library/multiprocessing.rst:2519
msgid ""
"Accept a connection on the bound socket or named pipe of the listener object "
"and return a :class:`~Connection` object. If authentication is attempted and "
"fails, then :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"Acepta una conexión en el *socket* vinculado o canalización con nombre del "
"objeto de escucha y retorne un objeto :class:`~Connection`. Si se intenta la "
"autenticación y falla, entonces se lanza una :exc:`~multiprocessing."
"AuthenticationError`."

#: ../Doc/library/multiprocessing.rst:2526
msgid ""
"Close the bound socket or named pipe of the listener object.  This is called "
"automatically when the listener is garbage collected.  However it is "
"advisable to call it explicitly."
msgstr ""
"Cierra el socket vinculado o la tubería con nombre del objeto de escucha. "
"Esto se llama automáticamente cuando el oyente es recolectado por el "
"recolector de basura. Sin embargo, es aconsejable llamarlo explícitamente."

#: ../Doc/library/multiprocessing.rst:2530
msgid "Listener objects have the following read-only properties:"
msgstr ""
"Los objetos de escucha tienen las siguientes propiedades de solo lectura:"

#: ../Doc/library/multiprocessing.rst:2534
msgid "The address which is being used by the Listener object."
msgstr "La dirección que está utilizando el objeto *Listener*."

#: ../Doc/library/multiprocessing.rst:2538
msgid ""
"The address from which the last accepted connection came.  If this is "
"unavailable then it is ``None``."
msgstr ""
"La dirección de donde vino la última conexión aceptada. Si esto no está "
"disponible, entonces es ``None``."

#: ../Doc/library/multiprocessing.rst:2541
msgid ""
"Listener objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"listener object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"Los objetos de escucha ahora admiten el protocolo de gestión de contexto -- "
"consulte :ref:`typecontextmanager`. El objeto *lISTENER* retorna :meth:"
"`~contextmanager.__enter__`, y :meth:`~contextmanager.__exit__` llama a :"
"meth:`close`."

#: ../Doc/library/multiprocessing.rst:2548
msgid ""
"Wait till an object in *object_list* is ready.  Returns the list of those "
"objects in *object_list* which are ready.  If *timeout* is a float then the "
"call blocks for at most that many seconds.  If *timeout* is ``None`` then it "
"will block for an unlimited period. A negative timeout is equivalent to a "
"zero timeout."
msgstr ""
"Espera hasta que un objeto en *object_list* esté listo. Retorna la lista de "
"esos objetos en *object_list* que están listos. Si *timeout* es flotante, la "
"llamada se bloquea durante como máximo tantos segundos. Si *timeout* es "
"```None``, se bloqueará por un período ilimitado. Un tiempo de espera "
"negativo es equivalente a un tiempo de espera cero."

#: ../Doc/library/multiprocessing.rst:2554
#, fuzzy
msgid ""
"For both POSIX and Windows, an object can appear in *object_list* if it is"
msgstr ""
"Tanto para Unix como para Windows, un objeto puede aparecer en *object_list* "
"si este es"

#: ../Doc/library/multiprocessing.rst:2557
msgid "a readable :class:`~multiprocessing.connection.Connection` object;"
msgstr "un objeto legible de :class:`~multiprocessing.connection.Connection`;"

#: ../Doc/library/multiprocessing.rst:2558
msgid "a connected and readable :class:`socket.socket` object; or"
msgstr "un objeto conectado y legible de :class:`socket.socket`; o"

#: ../Doc/library/multiprocessing.rst:2559
msgid ""
"the :attr:`~multiprocessing.Process.sentinel` attribute of a :class:"
"`~multiprocessing.Process` object."
msgstr ""
"el atributo :attr:`~multiprocessing.Process.sentinel` de un objeto :class:"
"`~multiprocessing.Process`."

#: ../Doc/library/multiprocessing.rst:2562
msgid ""
"A connection or socket object is ready when there is data available to be "
"read from it, or the other end has been closed."
msgstr ""
"Un objeto de conexión o *socket* está listo cuando hay datos disponibles "
"para leer, o el otro extremo se ha cerrado."

#: ../Doc/library/multiprocessing.rst:2565
#, fuzzy
msgid ""
"**POSIX**: ``wait(object_list, timeout)`` almost equivalent ``select."
"select(object_list, [], [], timeout)``.  The difference is that, if :func:"
"`select.select` is interrupted by a signal, it can raise :exc:`OSError` with "
"an error number of ``EINTR``, whereas :func:`wait` will not."
msgstr ""
"**Unix**: ``wait(object_list, timeout)`` es casi equivalente a ``select."
"select(object_list, [], [], timeout)``. La diferencia es que si se "
"interrumpe :func:`select.select` por una señal, este lanza :exc:`OSError` "
"con un número de error ``EINTR``, a diferencia de :func:`wait`."

#: ../Doc/library/multiprocessing.rst:2571
msgid ""
"**Windows**: An item in *object_list* must either be an integer handle which "
"is waitable (according to the definition used by the documentation of the "
"Win32 function ``WaitForMultipleObjects()``) or it can be an object with a :"
"meth:`fileno` method which returns a socket handle or pipe handle.  (Note "
"that pipe handles and socket handles are **not** waitable handles.)"
msgstr ""
"**Windows**: Un elemento en *object_list* debe ser un identificador de "
"número entero que se pueda esperar (de acuerdo con la definición utilizada "
"por la documentación de la función *Win32* ``WaitForMultipleObjects()``) o "
"puede ser un objeto con un :meth:`fileno` Método que retorna un manejador de "
"tubo o manejador de tubería. (Tenga en cuenta que las manijas de las "
"tuberías y las manijas de los zócalos son **no** manijas aptas)"

#: ../Doc/library/multiprocessing.rst:2581
msgid "**Examples**"
msgstr "**Ejemplos**"

#: ../Doc/library/multiprocessing.rst:2583
msgid ""
"The following server code creates a listener which uses ``'secret "
"password'`` as an authentication key.  It then waits for a connection and "
"sends some data to the client::"
msgstr ""
"El siguiente código de servidor crea un escucha que utiliza ``'secret "
"password'`` como clave de autenticación. Luego espera una conexión y envía "
"algunos datos al cliente::"

#: ../Doc/library/multiprocessing.rst:2602
msgid ""
"The following code connects to the server and receives some data from the "
"server::"
msgstr ""
"El siguiente código se conecta al servidor y recibe algunos datos del "
"servidor::"

#: ../Doc/library/multiprocessing.rst:2619
msgid ""
"The following code uses :func:`~multiprocessing.connection.wait` to wait for "
"messages from multiple processes at once::"
msgstr ""
"El siguiente código utiliza :func:`~multiprocessing.connection.wait` para "
"esperar mensajes de múltiples procesos a la vez::"

#: ../Doc/library/multiprocessing.rst:2658
msgid "Address Formats"
msgstr "Formatos de dirección (*Address formats*)"

#: ../Doc/library/multiprocessing.rst:2660
msgid ""
"An ``'AF_INET'`` address is a tuple of the form ``(hostname, port)`` where "
"*hostname* is a string and *port* is an integer."
msgstr ""
"Una dirección ``'AF_INET'`` es una tupla de la forma ``(hostname, port)`` "
"donde *hostname* es una cadena de caracteres y *port* es un número entero."

#: ../Doc/library/multiprocessing.rst:2663
msgid ""
"An ``'AF_UNIX'`` address is a string representing a filename on the "
"filesystem."
msgstr ""
"Una dirección ``'AF_UNIX'`` es una cadena que representa un nombre de "
"archivo en el sistema de archivos."

#: ../Doc/library/multiprocessing.rst:2666
msgid ""
"An ``'AF_PIPE'`` address is a string of the form :samp:`r'\\\\\\\\\\\\.\\"
"\\pipe\\\\\\\\{PipeName}'`.  To use :func:`Client` to connect to a named "
"pipe on a remote computer called *ServerName* one should use an address of "
"the form :samp:`r'\\\\\\\\\\\\\\\\{ServerName}\\\\pipe\\\\\\\\{PipeName}'` "
"instead."
msgstr ""
"Una dirección ``'AF_PIPE'`` es una cadena con el formato :samp:`r'\\\\\\\\\\"
"\\.\\\\pipe\\\\\\\\{PipeName}'`. Para usar :func:`Client` para conectarse a "
"una tubería con nombre en una computadora remota llamada *ServerName*, se "
"debe usar una dirección de la forma :samp:`r'\\\\\\\\\\\\\\\\{ServerName}\\"
"\\pipe\\\\\\\\{PipeName}'` en cambio."

#: ../Doc/library/multiprocessing.rst:2671
msgid ""
"Note that any string beginning with two backslashes is assumed by default to "
"be an ``'AF_PIPE'`` address rather than an ``'AF_UNIX'`` address."
msgstr ""
"Tenga en cuenta que cualquier cadena que comience con dos barras inclinadas "
"invertidas se asume por defecto como una dirección ``'AF_PIPE'`` en lugar de "
"una dirección ``'AF_UNIX'``."

#: ../Doc/library/multiprocessing.rst:2678
msgid "Authentication keys"
msgstr "Llaves de autentificación"

#: ../Doc/library/multiprocessing.rst:2680
msgid ""
"When one uses :meth:`Connection.recv <Connection.recv>`, the data received "
"is automatically unpickled. Unfortunately unpickling data from an untrusted "
"source is a security risk. Therefore :class:`Listener` and :func:`Client` "
"use the :mod:`hmac` module to provide digest authentication."
msgstr ""
"Cuando uno usa :meth:`Connection.recv <Connection.recv>`, los datos "
"recibidos se desbloquean automáticamente. Desafortunadamente, la eliminación "
"de datos de una fuente no confiable es un riesgo de seguridad. Por lo tanto :"
"class:`Listener` y :func:`Client` usan el módulo :mod:`hmac` para "
"proporcionar autenticación de resumen."

#: ../Doc/library/multiprocessing.rst:2686
msgid ""
"An authentication key is a byte string which can be thought of as a "
"password: once a connection is established both ends will demand proof that "
"the other knows the authentication key.  (Demonstrating that both ends are "
"using the same key does **not** involve sending the key over the connection.)"
msgstr ""
"Una clave de autenticación es una cadena de bytes que se puede considerar "
"como una contraseña: una vez que se establece una conexión, ambos extremos "
"exigirán pruebas de que el otro conoce la clave de autenticación. (Demostrar "
"que ambos extremos están usando la misma clave **no** implica enviar la "
"clave a través de la conexión)."

#: ../Doc/library/multiprocessing.rst:2692
msgid ""
"If authentication is requested but no authentication key is specified then "
"the return value of ``current_process().authkey`` is used (see :class:"
"`~multiprocessing.Process`).  This value will be automatically inherited by "
"any :class:`~multiprocessing.Process` object that the current process "
"creates. This means that (by default) all processes of a multi-process "
"program will share a single authentication key which can be used when "
"setting up connections between themselves."
msgstr ""
"Si se solicita la autenticación pero no se especifica una clave de "
"autenticación, se utiliza el valor de retorno de ``current_process()."
"authkey`` (consulte :class:`~multiprocessing.Process` ). Este valor será "
"heredado automáticamente por cualquier objeto :class:`~ multiprocessing."
"Process` que crea el proceso actual. Esto significa que (por defecto) todos "
"los procesos de un programa multiproceso compartirán una única clave de "
"autenticación que se puede usar al configurar conexiones entre ellos."

#: ../Doc/library/multiprocessing.rst:2700
msgid ""
"Suitable authentication keys can also be generated by using :func:`os."
"urandom`."
msgstr ""
"Las claves de autenticación adecuadas también se pueden generar utilizando :"
"func:`os.urandom`."

#: ../Doc/library/multiprocessing.rst:2704
msgid "Logging"
msgstr "*Logging*"

#: ../Doc/library/multiprocessing.rst:2706
msgid ""
"Some support for logging is available.  Note, however, that the :mod:"
"`logging` package does not use process shared locks so it is possible "
"(depending on the handler type) for messages from different processes to get "
"mixed up."
msgstr ""
"Existe cierto soporte para el registro. Sin embargo, tenga en cuenta que el "
"paquete :mod:`logging` no utiliza candados compartidos de proceso, por lo "
"que es posible (dependiendo del tipo de controlador) que los mensajes de "
"diferentes procesos se mezclen."

#: ../Doc/library/multiprocessing.rst:2713
msgid ""
"Returns the logger used by :mod:`multiprocessing`.  If necessary, a new one "
"will be created."
msgstr ""
"Retorna el registrador utilizado por :mod:`multiprocessing`. Si es "
"necesario, se creará uno nuevo."

#: ../Doc/library/multiprocessing.rst:2716
#, fuzzy
msgid ""
"When first created the logger has level :const:`logging.NOTSET` and no "
"default handler. Messages sent to this logger will not by default propagate "
"to the root logger."
msgstr ""
"Cuando se creó por primera vez, el registrador tiene nivel :data:`logging."
"NOTSET` y no tiene un controlador predeterminado. Los mensajes enviados a "
"este registrador no se propagarán por defecto al registrador raíz."

#: ../Doc/library/multiprocessing.rst:2720
msgid ""
"Note that on Windows child processes will only inherit the level of the "
"parent process's logger -- any other customization of the logger will not be "
"inherited."
msgstr ""
"Tenga en cuenta que en Windows los procesos hijos solo heredarán el nivel "
"del registrador del proceso parental -- no se heredará ninguna otra "
"personalización del registrador."

#: ../Doc/library/multiprocessing.rst:2727
#, python-format
msgid ""
"This function performs a call to :func:`get_logger` but in addition to "
"returning the logger created by get_logger, it adds a handler which sends "
"output to :data:`sys.stderr` using format ``'[%(levelname)s/%(processName)s] "
"%(message)s'``. You can modify ``levelname`` of the logger by passing a "
"``level`` argument."
msgstr ""
"Esta función realiza una llamada a :func:`get_logger` pero además de "
"retornar el registrador creado por get_logger, agrega un controlador que "
"envía la salida a :data:`sys.stderr` usando el formato ``'[%(levelname)s/"
"%(processName)s] %(message)s'``. Puede modificar ``levelname`` del "
"registrador pasando un argumento ``level``."

#: ../Doc/library/multiprocessing.rst:2733
msgid "Below is an example session with logging turned on::"
msgstr ""
"A continuación se muestra una sesión de ejemplo con el registro activado::"

#: ../Doc/library/multiprocessing.rst:2748
msgid "For a full table of logging levels, see the :mod:`logging` module."
msgstr ""
"Para obtener una tabla completa de niveles de registro, consulte el módulo :"
"mod:`logging`."

#: ../Doc/library/multiprocessing.rst:2752
msgid "The :mod:`multiprocessing.dummy` module"
msgstr "El módulo :mod:`multiprocessing.dummy`"

#: ../Doc/library/multiprocessing.rst:2757
msgid ""
":mod:`multiprocessing.dummy` replicates the API of :mod:`multiprocessing` "
"but is no more than a wrapper around the :mod:`threading` module."
msgstr ""
"El :mod:`multiprocessing.dummy` replica la API de :mod:`multiprocessing` "
"pero no es más que un contenedor alrededor del módulo :mod:`threading`."

#: ../Doc/library/multiprocessing.rst:2762
msgid ""
"In particular, the ``Pool`` function provided by :mod:`multiprocessing."
"dummy` returns an instance of :class:`ThreadPool`, which is a subclass of :"
"class:`Pool` that supports all the same method calls but uses a pool of "
"worker threads rather than worker processes."
msgstr ""
"En particular, la función ``Pool`` ofrecida por :mod:`multiprocessing.dummy` "
"retorna un instancia de :class:`ThreadPool`, la cual es un subclase de :"
"class:`Pool` que soporta todas las mismas llamadas, pero usa un *pool* de "
"hebras trabajadoras en vez de procesos trabajadores."

#: ../Doc/library/multiprocessing.rst:2770
msgid ""
"A thread pool object which controls a pool of worker threads to which jobs "
"can be submitted.  :class:`ThreadPool` instances are fully interface "
"compatible with :class:`Pool` instances, and their resources must also be "
"properly managed, either by using the pool as a context manager or by "
"calling :meth:`~multiprocessing.pool.Pool.close` and :meth:`~multiprocessing."
"pool.Pool.terminate` manually."
msgstr ""
"Un objeto de *pool* de hebras que controla un *pool* de hebras trabajadoras "
"a las cuales se pueden enviar trabajos. La interfaz de las instancias de :"
"class:`ThreadPool` son totalmente compatibles con las instancias de :class:"
"`Pool`, y sus recursos también deben ser debidamente administrador, ya sea "
"usando el *pool* como un gestor de contexto, o llamando a :meth:"
"`~multiprocessing.pool.Pool.close` y :meth:`~multiprocessing.pool.Pool."
"terminate` manualmente."

#: ../Doc/library/multiprocessing.rst:2777
msgid ""
"*processes* is the number of worker threads to use.  If *processes* is "
"``None`` then the number returned by :func:`os.cpu_count` is used."
msgstr ""
"*processes* es el número de hebras de trabajo a utilizar. Si *processes* es "
"``None`` , se utiliza el número retornado por :func:`os.cpu_count`."

#: ../Doc/library/multiprocessing.rst:2783
msgid ""
"Unlike :class:`Pool`, *maxtasksperchild* and *context* cannot be provided."
msgstr ""
"A diferencia de :class:`Pool`, *maxtasksperchild* and *context* no se pueden "
"entregar."

#: ../Doc/library/multiprocessing.rst:2787
msgid ""
"A :class:`ThreadPool` shares the same interface as :class:`Pool`, which is "
"designed around a pool of processes and predates the introduction of the :"
"class:`concurrent.futures` module.  As such, it inherits some operations "
"that don't make sense for a pool backed by threads, and it has its own type "
"for representing the status of asynchronous jobs, :class:`AsyncResult`, that "
"is not understood by any other libraries."
msgstr ""
"Un :class:`ThreadPool` comparte la misma interfaz que :class:`Pool`, la cual "
"está diseñada alrededor de un *pool* de procesos, y precede la introducción "
"del módulo :class:`concurrent.futures`. Como tal, hereda algunas operaciones "
"que no tienen sentido para un *pool* basado en hebras, y tiene su propio "
"tipo para representar el estado de trabajos asíncronos, :class:"
"`AsyncResult`, el cual no es entendido por otras librerías."

#: ../Doc/library/multiprocessing.rst:2794
msgid ""
"Users should generally prefer to use :class:`concurrent.futures."
"ThreadPoolExecutor`, which has a simpler interface that was designed around "
"threads from the start, and which returns :class:`concurrent.futures.Future` "
"instances that are compatible with many other libraries, including :mod:"
"`asyncio`."
msgstr ""
"Los usuarios deberían por lo general preferir usar :class:`concurrent."
"futures.ThreadPoolExecutor`, el cual tiene una interfaz más simple que fue "
"diseñada alrededor de hebras desde un principio, y que retorna instancias "
"de :class:`concurrent.futures.Future`, las que son compatibles con muchas "
"más librerías, incluyendo :mod:`asyncio`."

#: ../Doc/library/multiprocessing.rst:2804
msgid "Programming guidelines"
msgstr "Pautas de programación"

#: ../Doc/library/multiprocessing.rst:2806
msgid ""
"There are certain guidelines and idioms which should be adhered to when "
"using :mod:`multiprocessing`."
msgstr ""
"Hay ciertas pautas y expresiones idiomáticas que deben tenerse en cuenta al "
"usar :mod:`multiprocessing` ."

#: ../Doc/library/multiprocessing.rst:2811
msgid "All start methods"
msgstr "Todos los métodos de inicio"

#: ../Doc/library/multiprocessing.rst:2813
msgid "The following applies to all start methods."
msgstr "Lo siguiente se aplica a todos los métodos de inicio."

#: ../Doc/library/multiprocessing.rst:2815
msgid "Avoid shared state"
msgstr "Evita estado compartido"

#: ../Doc/library/multiprocessing.rst:2817
msgid ""
"As far as possible one should try to avoid shifting large amounts of data "
"between processes."
msgstr ""
"En la medida de lo posible, se debe tratar de evitar el desplazamiento de "
"grandes cantidades de datos entre procesos."

#: ../Doc/library/multiprocessing.rst:2820
msgid ""
"It is probably best to stick to using queues or pipes for communication "
"between processes rather than using the lower level synchronization "
"primitives."
msgstr ""
"Probablemente sea mejor seguir usando colas (*queues*) o tuberías (*pipes*) "
"para la comunicación entre procesos en lugar de usar las primitivas de "
"sincronización de nivel inferior."

#: ../Doc/library/multiprocessing.rst:2824
msgid "Picklability"
msgstr "Serialización (*picklability*)"

#: ../Doc/library/multiprocessing.rst:2826
msgid "Ensure that the arguments to the methods of proxies are picklable."
msgstr ""
"Asegúrese que todos los argumentos de los métodos de *proxies* son "
"serializables (*pickable*)"

#: ../Doc/library/multiprocessing.rst:2828
msgid "Thread safety of proxies"
msgstr "Seguridad de hilos de *proxies*"

#: ../Doc/library/multiprocessing.rst:2830
msgid ""
"Do not use a proxy object from more than one thread unless you protect it "
"with a lock."
msgstr ""
"No usa un objeto proxy de más de un hilo a menos que lo proteja con un "
"candado (*lock*)."

#: ../Doc/library/multiprocessing.rst:2833
msgid ""
"(There is never a problem with different processes using the *same* proxy.)"
msgstr ""
"(Nunca hay un problema con diferentes procesos que usan el *mismo* proxy.)"

#: ../Doc/library/multiprocessing.rst:2835
msgid "Joining zombie processes"
msgstr "Uniéndose a procesos zombies"

#: ../Doc/library/multiprocessing.rst:2837
#, fuzzy
msgid ""
"On POSIX when a process finishes but has not been joined it becomes a "
"zombie. There should never be very many because each time a new process "
"starts (or :func:`~multiprocessing.active_children` is called) all completed "
"processes which have not yet been joined will be joined.  Also calling a "
"finished process's :meth:`Process.is_alive <multiprocessing.Process."
"is_alive>` will join the process.  Even so it is probably good practice to "
"explicitly join all the processes that you start."
msgstr ""
"En Unix, cuando un proceso finaliza pero no se ha unido, se convierte en un "
"zombie. Nunca debería haber muchos porque cada vez que se inicia un nuevo "
"proceso (o se llama :func:`~multiprocessing.active_children`) se unirán "
"todos los procesos completados que aún no se hayan unido. También llamando a "
"un proceso terminado :meth:`Process.is_alive <multiprocessing.Process."
"is_alive>` se unirá al proceso. Aun así, probablemente sea una buena "
"práctica unir explícitamente todos los procesos que comience."

#: ../Doc/library/multiprocessing.rst:2845
msgid "Better to inherit than pickle/unpickle"
msgstr "Mejor heredar que serializar/deserializar (*pickle/unpickle*)"

#: ../Doc/library/multiprocessing.rst:2847
msgid ""
"When using the *spawn* or *forkserver* start methods many types from :mod:"
"`multiprocessing` need to be picklable so that child processes can use "
"them.  However, one should generally avoid sending shared objects to other "
"processes using pipes or queues. Instead you should arrange the program so "
"that a process which needs access to a shared resource created elsewhere can "
"inherit it from an ancestor process."
msgstr ""
"Cuando se usan los métodos de inicio *spawn* o *forkserver*, muchos tipos "
"de :mod:`multiprocesamiento` deben ser seleccionables para que los procesos "
"secundarios puedan usarlos. Sin embargo, generalmente se debe evitar enviar "
"objetos compartidos a otros procesos mediante tuberías o colas. En su lugar, "
"debe organizar el programa para que un proceso que necesita acceso a un "
"recurso compartido creado en otro lugar pueda heredarlo de un proceso "
"ancestro."

#: ../Doc/library/multiprocessing.rst:2855
msgid "Avoid terminating processes"
msgstr "Evita procesos de finalización"

#: ../Doc/library/multiprocessing.rst:2857
msgid ""
"Using the :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"method to stop a process is liable to cause any shared resources (such as "
"locks, semaphores, pipes and queues) currently being used by the process to "
"become broken or unavailable to other processes."
msgstr ""
"El uso del método :meth:`Process.terminate <multiprocessing.Process."
"terminate>` para detener un proceso puede causar que los recursos "
"compartidos (como candados, semáforos, tuberías  y colas) que el proceso "
"utiliza actualmente se rompan o no disponible para otros procesos."

#: ../Doc/library/multiprocessing.rst:2863
msgid ""
"Therefore it is probably best to only consider using :meth:`Process."
"terminate <multiprocessing.Process.terminate>` on processes which never use "
"any shared resources."
msgstr ""
"Por lo tanto, probablemente sea mejor considerar usar :meth:`Process."
"terminate <multiprocessing.Process.terminate>` en procesos que nunca usan "
"recursos compartidos."

#: ../Doc/library/multiprocessing.rst:2867
msgid "Joining processes that use queues"
msgstr "Unirse a procesos que usan colas"

#: ../Doc/library/multiprocessing.rst:2869
msgid ""
"Bear in mind that a process that has put items in a queue will wait before "
"terminating until all the buffered items are fed by the \"feeder\" thread to "
"the underlying pipe.  (The child process can call the :meth:`Queue."
"cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` method of the "
"queue to avoid this behaviour.)"
msgstr ""
"Tenga en cuenta que un proceso que ha puesto elementos en una cola esperará "
"antes de finalizar hasta que todos los elementos almacenados en búfer sean "
"alimentados por el hilo \"alimentador\" a la tubería subyacente. (El proceso "
"secundario puede llamar al método :meth:`Queue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>` de la cola para evitar este "
"comportamiento)."

#: ../Doc/library/multiprocessing.rst:2875
msgid ""
"This means that whenever you use a queue you need to make sure that all "
"items which have been put on the queue will eventually be removed before the "
"process is joined.  Otherwise you cannot be sure that processes which have "
"put items on the queue will terminate.  Remember also that non-daemonic "
"processes will be joined automatically."
msgstr ""
"Esto significa que siempre que use una cola debe asegurarse de que todos los "
"elementos que se hayan puesto en la cola se eliminarán antes de unirse al "
"proceso. De lo contrario, no puede estar seguro de que los procesos que han "
"puesto elementos en la cola finalizarán. Recuerde también que los procesos "
"no demoníacos se unirán automáticamente."

#: ../Doc/library/multiprocessing.rst:2881
msgid "An example which will deadlock is the following::"
msgstr "Un ejemplo que de bloqueo mutuo (*deadlock*) es el siguiente ::"

#: ../Doc/library/multiprocessing.rst:2895
msgid ""
"A fix here would be to swap the last two lines (or simply remove the ``p."
"join()`` line)."
msgstr ""
"Una solución aquí sería intercambiar las dos últimas líneas (o simplemente "
"eliminar la línea ``p.join()``)."

#: ../Doc/library/multiprocessing.rst:2898
msgid "Explicitly pass resources to child processes"
msgstr "Se pasan recursos explícitamente a procesos hijos"

#: ../Doc/library/multiprocessing.rst:2900
#, fuzzy
msgid ""
"On POSIX using the *fork* start method, a child process can make use of a "
"shared resource created in a parent process using a global resource.  "
"However, it is better to pass the object as an argument to the constructor "
"for the child process."
msgstr ""
"En Unix que utiliza el método de inicio *fork*, un proceso secundario puede "
"hacer uso de un recurso compartido creado en un proceso primario utilizando "
"un recurso global. Sin embargo, es mejor pasar el objeto como argumento al "
"constructor para el proceso secundario."

#: ../Doc/library/multiprocessing.rst:2905
msgid ""
"Apart from making the code (potentially) compatible with Windows and the "
"other start methods this also ensures that as long as the child process is "
"still alive the object will not be garbage collected in the parent process.  "
"This might be important if some resource is freed when the object is garbage "
"collected in the parent process."
msgstr ""
"Además de hacer que el código (potencialmente) sea compatible con Windows y "
"los otros métodos de inicio, esto también garantiza que mientras el proceso "
"secundario siga vivo, el objeto no se recolectará en el proceso primario. "
"Esto podría ser importante si se libera algún recurso cuando el objeto es "
"basura recolectada en el proceso padre."

#: ../Doc/library/multiprocessing.rst:2912
msgid "So for instance ::"
msgstr "Entonces por ejemplo ::"

#: ../Doc/library/multiprocessing.rst:2924
msgid "should be rewritten as ::"
msgstr "debería ser reescrito como ::"

#: ../Doc/library/multiprocessing.rst:2936
msgid "Beware of replacing :data:`sys.stdin` with a \"file like object\""
msgstr ""
"Tenga cuidado de reemplazar :data:`sys.stdin` con un *\"file like object\"*"

#: ../Doc/library/multiprocessing.rst:2938
msgid ":mod:`multiprocessing` originally unconditionally called::"
msgstr ":mod:`multiprocessing` original e incondicionalmente llamado::"

#: ../Doc/library/multiprocessing.rst:2942
msgid ""
"in the :meth:`multiprocessing.Process._bootstrap` method --- this resulted "
"in issues with processes-in-processes. This has been changed to::"
msgstr ""
"en el método :meth:`multiprocessing.Process._bootstrap` --- Esto dio lugar a "
"problemas con los procesos en proceso. Esto ha sido cambiado a::"

#: ../Doc/library/multiprocessing.rst:2948
msgid ""
"Which solves the fundamental issue of processes colliding with each other "
"resulting in a bad file descriptor error, but introduces a potential danger "
"to applications which replace :func:`sys.stdin` with a \"file-like object\" "
"with output buffering.  This danger is that if multiple processes call :meth:"
"`~io.IOBase.close()` on this file-like object, it could result in the same "
"data being flushed to the object multiple times, resulting in corruption."
msgstr ""
"Lo que resuelve el problema fundamental de los procesos que chocan entre sí "
"dando como resultado un error de descriptor de archivo incorrecto, pero "
"presenta un peligro potencial para las aplicaciones que reemplazan :func:"
"`sys.stdin` con un \"objeto similar a un archivo\" con almacenamiento en "
"búfer de salida. Este peligro es que si varios procesos invocan :meth:`~io."
"IOBase.close()` en este objeto similar a un archivo, podría ocasionar que "
"los mismos datos se vacíen al objeto varias veces, lo que provocaría "
"corrupción."

#: ../Doc/library/multiprocessing.rst:2955
msgid ""
"If you write a file-like object and implement your own caching, you can make "
"it fork-safe by storing the pid whenever you append to the cache, and "
"discarding the cache when the pid changes. For example::"
msgstr ""
"Si escribe un objeto similar a un archivo e implementa su propio "
"almacenamiento en caché, puede hacer que sea seguro para la bifurcación "
"(*fork-safe*) almacenando el pid cada vez que se agrega al caché y "
"descartando el caché cuando cambia el pid. Por ejemplo::"

#: ../Doc/library/multiprocessing.rst:2967
msgid ""
"For more information, see :issue:`5155`, :issue:`5313` and :issue:`5331`"
msgstr ""
"Para más información, consulte :issue:`5155`, :issue:`5313` y :issue:`5331`"

#: ../Doc/library/multiprocessing.rst:2970
msgid "The *spawn* and *forkserver* start methods"
msgstr "Los métodos de inicio *spawn* y *forkserver*"

#: ../Doc/library/multiprocessing.rst:2972
msgid ""
"There are a few extra restriction which don't apply to the *fork* start "
"method."
msgstr ""
"Hay algunas restricciones adicionales que no se aplican al método de inicio "
"*fork*."

#: ../Doc/library/multiprocessing.rst:2975
msgid "More picklability"
msgstr "Más serialización (*pickability*)"

#: ../Doc/library/multiprocessing.rst:2977
msgid ""
"Ensure that all arguments to :meth:`Process.__init__` are picklable. Also, "
"if you subclass :class:`~multiprocessing.Process` then make sure that "
"instances will be picklable when the :meth:`Process.start <multiprocessing."
"Process.start>` method is called."
msgstr ""
"Asegúrese de que todos los argumentos para :meth:`Process.__init__` sean "
"serializables (*picklable*). Además, si la subclase es :class:"
"`~multiprocessing.Process` asegúrese de que las instancias serán "
"serializables cuando se llame al método :meth:`Process.start "
"<multiprocessing.Process.start>`."

#: ../Doc/library/multiprocessing.rst:2982
msgid "Global variables"
msgstr "Variables globales"

#: ../Doc/library/multiprocessing.rst:2984
msgid ""
"Bear in mind that if code run in a child process tries to access a global "
"variable, then the value it sees (if any) may not be the same as the value "
"in the parent process at the time that :meth:`Process.start <multiprocessing."
"Process.start>` was called."
msgstr ""
"Tenga en cuenta que si el código que se ejecuta en un proceso secundario "
"intenta acceder a una variable global, entonces el valor que ve (si lo hay) "
"puede no ser el mismo que el valor en el proceso primario en el momento en "
"que fue llamado :meth:`Process.start <multiprocessing.Process.start>`."

#: ../Doc/library/multiprocessing.rst:2989
msgid ""
"However, global variables which are just module level constants cause no "
"problems."
msgstr ""
"Sin embargo, las variables globales que son solo constantes de nivel de "
"módulo no causan problemas."

#: ../Doc/library/multiprocessing.rst:2994
msgid "Safe importing of main module"
msgstr "Importando de manera segura el módulo principal"

#: ../Doc/library/multiprocessing.rst:2996
#, fuzzy
msgid ""
"Make sure that the main module can be safely imported by a new Python "
"interpreter without causing unintended side effects (such as starting a new "
"process)."
msgstr ""
"Asegúrese de que un nuevo intérprete de Python pueda importar de forma "
"segura el módulo principal sin causar efectos secundarios no deseados (como "
"comenzar un nuevo proceso)."

#: ../Doc/library/multiprocessing.rst:3000
msgid ""
"For example, using the *spawn* or *forkserver* start method running the "
"following module would fail with a :exc:`RuntimeError`::"
msgstr ""
"Por ejemplo, usando el método de inicio *spawn* o *forkserver* ejecutando "
"este módulo fallaría produciendo :exc:`RuntimeError`::"

#: ../Doc/library/multiprocessing.rst:3012
msgid ""
"Instead one should protect the \"entry point\" of the program by using ``if "
"__name__ == '__main__':`` as follows::"
msgstr ""
"En su lugar, se debe proteger el \"punto de entrada\" (*\"entry point\"*) "
"del programa utilizando como sigue ``if __name__ == '__main__':`` ::"

#: ../Doc/library/multiprocessing.rst:3026
msgid ""
"(The ``freeze_support()`` line can be omitted if the program will be run "
"normally instead of frozen.)"
msgstr ""
"(La línea ``freeze_support()`` puede omitirse si el programa se ejecuta "
"normalmente en lugar de congelarse)."

#: ../Doc/library/multiprocessing.rst:3029
msgid ""
"This allows the newly spawned Python interpreter to safely import the module "
"and then run the module's ``foo()`` function."
msgstr ""
"Esto permite que el intérprete de Python recién generado importe de forma "
"segura el módulo y luego ejecute la función del módulo ``foo()``."

#: ../Doc/library/multiprocessing.rst:3032
msgid ""
"Similar restrictions apply if a pool or manager is created in the main "
"module."
msgstr ""
"Se aplican restricciones similares si se crea un grupo o administrador en el "
"módulo principal."

#: ../Doc/library/multiprocessing.rst:3039
msgid "Examples"
msgstr "Ejemplos"

#: ../Doc/library/multiprocessing.rst:3041
msgid "Demonstration of how to create and use customized managers and proxies:"
msgstr "Demostración de cómo crear y usar gerentes y proxies personalizados:"

#: ../Doc/library/multiprocessing.rst:3047
msgid "Using :class:`~multiprocessing.pool.Pool`:"
msgstr "Usando :class:`~multiprocessing.pool.Pool`:"

#: ../Doc/library/multiprocessing.rst:3053
msgid ""
"An example showing how to use queues to feed tasks to a collection of worker "
"processes and collect the results:"
msgstr ""
"Un ejemplo que muestra cómo usar las colas para alimentar tareas a una "
"colección de procesos de trabajo y recopilar los resultados:"

#~ msgid ""
#~ "Set the method which should be used to start child processes. *method* "
#~ "can be ``'fork'``, ``'spawn'`` or ``'forkserver'``."
#~ msgstr ""
#~ "Se establece el método que se debe usar para iniciar procesos "
#~ "secundarios. *method* puede ser ``'fork'``, ``'spawn'`` o "
#~ "``'forkserver'``."
