# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org / https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-06 11:59-0400\n"
"PO-Revision-Date: 2020-08-21 23:43+0200\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.3.1\n"
"Last-Translator: Cristián Maureira-Fredes <cmaureirafredes@gmail.com>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Language: es\n"

#: ../Doc/library/heapq.rst:2
msgid ":mod:`heapq` --- Heap queue algorithm"
msgstr ":mod:`heapq` --- Algoritmo de colas montículos (*heap*)"

#: ../Doc/library/heapq.rst:12
msgid "**Source code:** :source:`Lib/heapq.py`"
msgstr "**Código fuente:** :source:`Lib/heapq.py`"

#: ../Doc/library/heapq.rst:16
msgid ""
"This module provides an implementation of the heap queue algorithm, also "
"known as the priority queue algorithm."
msgstr ""
"Este módulo proporciona una implementación del algoritmo de montículos, "
"también conocido como algoritmo de cola con prioridad."

#: ../Doc/library/heapq.rst:19
msgid ""
"Heaps are binary trees for which every parent node has a value less than or "
"equal to any of its children.  This implementation uses arrays for which "
"``heap[k] <= heap[2*k+1]`` and ``heap[k] <= heap[2*k+2]`` for all *k*, "
"counting elements from zero.  For the sake of comparison, non-existing "
"elements are considered to be infinite.  The interesting property of a heap "
"is that its smallest element is always the root, ``heap[0]``."
msgstr ""
"Los montículos son árboles binarios para los cuales cada nodo padre tiene un "
"valor menor o igual que cualquiera de sus hijos. Esta implementación utiliza "
"matrices para las cuales ``heap[k] <= heap[2*k+1]`` y ``heap[k] <= heap[2*k"
"+2]`` para todo *k*, contando los elementos desde cero. Para poder comparar, "
"los elementos inexistentes se consideran infinitos. La propiedad interesante "
"de un montículo es que su elemento más pequeño es siempre la raíz, "
"``heap[0]``."

#: ../Doc/library/heapq.rst:26
msgid ""
"The API below differs from textbook heap algorithms in two aspects: (a) We "
"use zero-based indexing.  This makes the relationship between the index for "
"a node and the indexes for its children slightly less obvious, but is more "
"suitable since Python uses zero-based indexing. (b) Our pop method returns "
"the smallest item, not the largest (called a \"min heap\" in textbooks; a "
"\"max heap\" is more common in texts because of its suitability for in-place "
"sorting)."
msgstr ""
"El API que se presenta a continuación difiere de los algoritmos de los "
"libros de texto en dos aspectos: (a) Utilizamos la indexación basada en "
"cero. Esto hace que la relación entre el índice de un nodo y los índices de "
"sus hijos sea un poco menos evidente, pero es más adecuado ya que Python "
"utiliza la indexación basada en cero. (b) Nuestro método \"pop\" retorna el "
"elemento más pequeño, no el más grande (llamado \"min heap\" o montículo por "
"mínimo en los libros de texto; un \"max heap\" o montículo por máximos es "
"más común en los textos debido a su idoneidad para la clasificación in situ)."

#: ../Doc/library/heapq.rst:33
msgid ""
"These two make it possible to view the heap as a regular Python list without "
"surprises: ``heap[0]`` is the smallest item, and ``heap.sort()`` maintains "
"the heap invariant!"
msgstr ""
"Estos dos permiten ver el montículo como una lista Python normal sin "
"sorpresas: ``heap[0]`` es el ítem más pequeño, y ``heap.sort()`` mantiene el "
"montículo invariable!"

#: ../Doc/library/heapq.rst:37
msgid ""
"To create a heap, use a list initialized to ``[]``, or you can transform a "
"populated list into a heap via function :func:`heapify`."
msgstr ""
"Para crear un montículo, usa una lista inicializada como ``[]``, o puedes "
"transformar una lista poblada en un montículo a través de la función :func:"
"`heapify`."

#: ../Doc/library/heapq.rst:40
msgid "The following functions are provided:"
msgstr "Las siguientes funciones están provistas:"

#: ../Doc/library/heapq.rst:45
msgid "Push the value *item* onto the *heap*, maintaining the heap invariant."
msgstr ""
"Empujar el valor *item* en el *heap*, manteniendo el montículo invariable."

#: ../Doc/library/heapq.rst:50
msgid ""
"Pop and return the smallest item from the *heap*, maintaining the heap "
"invariant.  If the heap is empty, :exc:`IndexError` is raised.  To access "
"the smallest item without popping it, use ``heap[0]``."
msgstr ""
"Desapila o *pop* y retorna el elemento más pequeño del *heap*, manteniendo "
"el montículo invariable. Si el montículo está vacío, :exc:`IndexError` se "
"lanza. Para acceder al elemento más pequeño sin necesidad de desapilar, "
"usa``heap[0]``."

#: ../Doc/library/heapq.rst:57
msgid ""
"Push *item* on the heap, then pop and return the smallest item from the "
"*heap*.  The combined action runs more efficiently than :func:`heappush` "
"followed by a separate call to :func:`heappop`."
msgstr ""
"Apila el elemento o *iem* en el montículo, y luego desapila y retorna el "
"elemento más pequeño del montículo. La acción combinada se ejecuta más "
"eficientemente que :func:`heappush` seguido de una llamada separada a :func:"
"`heappop`."

#: ../Doc/library/heapq.rst:64
msgid "Transform list *x* into a heap, in-place, in linear time."
msgstr ""
"Transformar la lista *x* en un montículo, en el lugar, en tiempo lineal."

#: ../Doc/library/heapq.rst:69
msgid ""
"Pop and return the smallest item from the *heap*, and also push the new "
"*item*. The heap size doesn't change. If the heap is empty, :exc:"
"`IndexError` is raised."
msgstr ""
"Desapila y retorna el elemento más pequeño del *heap*, y también apile el "
"nuevo *item*. El tamaño del montículo no cambia. Si el montículo está "
"vacío, :exc:`IndexError` se eleva."

#: ../Doc/library/heapq.rst:72
msgid ""
"This one step operation is more efficient than a :func:`heappop` followed "
"by :func:`heappush` and can be more appropriate when using a fixed-size "
"heap. The pop/push combination always returns an element from the heap and "
"replaces it with *item*."
msgstr ""
"Esta operación de un solo paso es más eficiente que un :func:`heappop` "
"seguido por :func:`heappush` y puede ser más apropiada cuando se utiliza un "
"montículo de tamaño fijo. La combinación pop/push siempre retorna un "
"elemento del montículo y lo reemplaza con *item*."

#: ../Doc/library/heapq.rst:77
msgid ""
"The value returned may be larger than the *item* added.  If that isn't "
"desired, consider using :func:`heappushpop` instead.  Its push/pop "
"combination returns the smaller of the two values, leaving the larger value "
"on the heap."
msgstr ""
"El valor retornado puede ser mayor que el *item* añadido. Si no se desea "
"eso, considere usar :func:`heappushpop` en su lugar. Su combinación push/pop "
"retorna el menor de los dos valores, dejando el mayor valor en el montículo."

#: ../Doc/library/heapq.rst:83
msgid "The module also offers three general purpose functions based on heaps."
msgstr ""
"El módulo también ofrece tres funciones de propósito general basadas en los "
"montículos."

#: ../Doc/library/heapq.rst:88
msgid ""
"Merge multiple sorted inputs into a single sorted output (for example, merge "
"timestamped entries from multiple log files).  Returns an :term:`iterator` "
"over the sorted values."
msgstr ""
"Fusionar varias entradas ordenadas en una sola salida ordenada (por ejemplo, "
"fusionar entradas con marca de tiempo de varios archivos de registro). "
"Retorna un :term:`iterator` sobre los valores ordenados."

#: ../Doc/library/heapq.rst:92
msgid ""
"Similar to ``sorted(itertools.chain(*iterables))`` but returns an iterable, "
"does not pull the data into memory all at once, and assumes that each of the "
"input streams is already sorted (smallest to largest)."
msgstr ""
"Similar a ``sorted(itertools.chain(*iterables))`` pero retorna un iterable, "
"no hala los datos a la memoria de una sola vez, y asume que cada uno de los "
"flujos de entrada ya están ordenado (de menor a mayor)."

#: ../Doc/library/heapq.rst:96
msgid ""
"Has two optional arguments which must be specified as keyword arguments."
msgstr ""
"Tiene dos argumentos opcionales que deben ser especificados como argumentos "
"de palabras clave."

#: ../Doc/library/heapq.rst:98
msgid ""
"*key* specifies a :term:`key function` of one argument that is used to "
"extract a comparison key from each input element.  The default value is "
"``None`` (compare the elements directly)."
msgstr ""
"*key* especifica una :term:`key function` de un argumento que se utiliza "
"para extraer una clave de comparación de cada elemento de entrada. El valor "
"por defecto es ``None`` (compara los elementos directamente)."

#: ../Doc/library/heapq.rst:102
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the input elements "
"are merged as if each comparison were reversed. To achieve behavior similar "
"to ``sorted(itertools.chain(*iterables), reverse=True)``, all iterables must "
"be sorted from largest to smallest."
msgstr ""
"*reverse* es un valor booleano. Si se establece en ``True``, entonces los "
"elementos de entrada se fusionan como si cada comparación se invirtiera. "
"Para lograr un comportamiento similar a ``sorted(itertools."
"chain(*iterables), reverse=True)``, todos los iterables deben ser ordenados "
"de mayor a menor."

#: ../Doc/library/heapq.rst:107
msgid "Added the optional *key* and *reverse* parameters."
msgstr "Añadió los parámetros opcionales de *key* y *reverse*."

#: ../Doc/library/heapq.rst:113
msgid ""
"Return a list with the *n* largest elements from the dataset defined by "
"*iterable*.  *key*, if provided, specifies a function of one argument that "
"is used to extract a comparison key from each element in *iterable* (for "
"example, ``key=str.lower``).  Equivalent to:  ``sorted(iterable, key=key, "
"reverse=True)[:n]``."
msgstr ""
"Retorna una lista con los *n* elementos más grandes del conjunto de datos "
"definidos por *iterable*. *key*, si se proporciona, especifica una función "
"de un argumento que se utiliza para extraer una clave de comparación de cada "
"elemento en *iterable* (por ejemplo, ``key=str.lower``). Equivalente a:  "
"``sorted(iterable, key=clave, reverse=True)[:n]``."

#: ../Doc/library/heapq.rst:122
msgid ""
"Return a list with the *n* smallest elements from the dataset defined by "
"*iterable*.  *key*, if provided, specifies a function of one argument that "
"is used to extract a comparison key from each element in *iterable* (for "
"example, ``key=str.lower``).  Equivalent to:  ``sorted(iterable, key=key)[:"
"n]``."
msgstr ""
"Retorna una lista con los *n* elementos más pequeños del conjunto de datos "
"definidos por *iterable*. *key*, si se proporciona, especifica una función "
"de un argumento que se utiliza para extraer una clave de comparación de cada "
"elemento en *iterable* (por ejemplo, ``key=str.lower``). Equivalente a:  "
"``sorted(iterable, key=clave)[:n]``."

#: ../Doc/library/heapq.rst:128
msgid ""
"The latter two functions perform best for smaller values of *n*.  For larger "
"values, it is more efficient to use the :func:`sorted` function.  Also, when "
"``n==1``, it is more efficient to use the built-in :func:`min` and :func:"
"`max` functions.  If repeated usage of these functions is required, consider "
"turning the iterable into an actual heap."
msgstr ""
"Las dos últimas funciones funcionan mejor para valores más pequeños de *n*. "
"Para valores más grandes, es más eficiente usar la función :func:`sorted`. "
"Además, cuando ``n==1``, es más eficiente usar las funciones incorporadas :"
"func:`min` y :func:`max``. Si se requiere el uso repetido de estas "
"funciones, considere convertir lo iterable en un verdadero montículo."

#: ../Doc/library/heapq.rst:136
msgid "Basic Examples"
msgstr "Ejemplos Básicos"

#: ../Doc/library/heapq.rst:138
msgid ""
"A `heapsort <https://en.wikipedia.org/wiki/Heapsort>`_ can be implemented by "
"pushing all values onto a heap and then popping off the smallest values one "
"at a time::"
msgstr ""
"Un `heapsort\" <https://en.wikipedia.org/wiki/Heapsort>`_ puede ser "
"implementado empujando todos los valores en un montículo y luego desapilando "
"los valores más pequeños uno a la vez::"

#: ../Doc/library/heapq.rst:151
msgid ""
"This is similar to ``sorted(iterable)``, but unlike :func:`sorted`, this "
"implementation is not stable."
msgstr ""
"Esto es similar a ``sorted(iterable)``, pero a diferencia de :func:`sorted`, "
"esta implementación no es estable."

#: ../Doc/library/heapq.rst:154
msgid ""
"Heap elements can be tuples.  This is useful for assigning comparison values "
"(such as task priorities) alongside the main record being tracked::"
msgstr ""
"Los elementos del montículo pueden ser tuplas. Esto es útil para asignar "
"valores de comparación (como las prioridades de las tareas) junto con el "
"registro principal que se está rastreando::"

#: ../Doc/library/heapq.rst:167
msgid "Priority Queue Implementation Notes"
msgstr "Notas de Aplicación de la Cola de Prioridades"

#: ../Doc/library/heapq.rst:169
msgid ""
"A `priority queue <https://en.wikipedia.org/wiki/Priority_queue>`_ is common "
"use for a heap, and it presents several implementation challenges:"
msgstr ""
"Una `cola de prioridad <https://en.wikipedia.org/wiki/Priority_queue>`_ es "
"de uso común para un montículo, y presenta varios desafíos de implementación:"

#: ../Doc/library/heapq.rst:172
msgid ""
"Sort stability:  how do you get two tasks with equal priorities to be "
"returned in the order they were originally added?"
msgstr ""
"Estabilidad de la clasificación: ¿cómo se consigue que dos tareas con "
"iguales prioridades sean retornadas en el orden en que fueron añadidas "
"originalmente?"

#: ../Doc/library/heapq.rst:175
msgid ""
"Tuple comparison breaks for (priority, task) pairs if the priorities are "
"equal and the tasks do not have a default comparison order."
msgstr ""
"Interrupciones de comparación en tupla para pares (prioridad, tarea) si las "
"prioridades son iguales y las tareas no tienen un orden de comparación por "
"defecto."

#: ../Doc/library/heapq.rst:178
msgid ""
"If the priority of a task changes, how do you move it to a new position in "
"the heap?"
msgstr ""
"¿Si la prioridad de una tarea cambia, cómo la mueves a una nueva posición en "
"el montículo?"

#: ../Doc/library/heapq.rst:181
msgid ""
"Or if a pending task needs to be deleted, how do you find it and remove it "
"from the queue?"
msgstr ""
"¿O si una tarea pendiente necesita ser borrada, cómo la encuentras y la "
"eliminas de la cola?"

#: ../Doc/library/heapq.rst:184
msgid ""
"A solution to the first two challenges is to store entries as 3-element list "
"including the priority, an entry count, and the task.  The entry count "
"serves as a tie-breaker so that two tasks with the same priority are "
"returned in the order they were added. And since no two entry counts are the "
"same, the tuple comparison will never attempt to directly compare two tasks."
msgstr ""
"Una solución a los dos primeros desafíos es almacenar las entradas como una "
"lista de 3 elementos que incluya la prioridad, un recuento de entradas y la "
"tarea. El recuento de entradas sirve como un desempate para que dos tareas "
"con la misma prioridad sean retornadas en el orden en que fueron añadidas. Y "
"como no hay dos recuentos de entradas iguales, la comparación tupla nunca "
"intentará comparar directamente dos tareas."

#: ../Doc/library/heapq.rst:190
msgid ""
"Another solution to the problem of non-comparable tasks is to create a "
"wrapper class that ignores the task item and only compares the priority "
"field::"
msgstr ""
"Otra solución al problema de las tareas no comparables es crear una clase "
"envolvente que ignore el elemento de la tarea y sólo compare el campo de "
"prioridad::"

#: ../Doc/library/heapq.rst:201
msgid ""
"The remaining challenges revolve around finding a pending task and making "
"changes to its priority or removing it entirely.  Finding a task can be done "
"with a dictionary pointing to an entry in the queue."
msgstr ""
"Los desafíos restantes giran en torno a encontrar una tarea pendiente y "
"hacer cambios en su prioridad o eliminarla por completo. Encontrar una tarea "
"se puede hacer con un diccionario que apunta a una entrada en la cola."

#: ../Doc/library/heapq.rst:205
msgid ""
"Removing the entry or changing its priority is more difficult because it "
"would break the heap structure invariants.  So, a possible solution is to "
"mark the entry as removed and add a new entry with the revised priority::"
msgstr ""
"Eliminar la entrada o cambiar su prioridad es más difícil porque rompería "
"las invariantes de la estructura del montículo. Por lo tanto, una posible "
"solución es marcar la entrada como eliminada y añadir una nueva entrada con "
"la prioridad revisada::"

#: ../Doc/library/heapq.rst:239
msgid "Theory"
msgstr "Teoría"

#: ../Doc/library/heapq.rst:241
msgid ""
"Heaps are arrays for which ``a[k] <= a[2*k+1]`` and ``a[k] <= a[2*k+2]`` for "
"all *k*, counting elements from 0.  For the sake of comparison, non-existing "
"elements are considered to be infinite.  The interesting property of a heap "
"is that ``a[0]`` is always its smallest element."
msgstr ""
"Los montículos son conjuntos para los cuales``a[k] <= a[2*k+1]`` y \"a[k] <= "
"a[2*k+2]`` para todos los *k*, contando los elementos desde 0. Para "
"comparar, los elementos no existentes se consideran infinitos. La "
"interesante propiedad de un montículo es que ``a[0]`` es siempre su elemento "
"más pequeño."

#: ../Doc/library/heapq.rst:246
msgid ""
"The strange invariant above is meant to be an efficient memory "
"representation for a tournament.  The numbers below are *k*, not ``a[k]``::"
msgstr ""
"La extraña invariante de arriba intenta ser una representación eficiente de "
"la memoria para un torneo. Los números de abajo son *k*, no``a[k]``::"

#: ../Doc/library/heapq.rst:259
msgid ""
"In the tree above, each cell *k* is topping ``2*k+1`` and ``2*k+2``. In a "
"usual binary tournament we see in sports, each cell is the winner over the "
"two cells it tops, and we can trace the winner down the tree to see all "
"opponents s/he had.  However, in many computer applications of such "
"tournaments, we do not need to trace the history of a winner. To be more "
"memory efficient, when a winner is promoted, we try to replace it by "
"something else at a lower level, and the rule becomes that a cell and the "
"two cells it tops contain three different items, but the top cell \"wins\" "
"over the two topped cells."
msgstr ""
"En el árbol de arriba, cada celda *k* está coronada por ``2*k+1`` y ``2*k"
"+2``. En un torneo binario habitual que vemos en los deportes, cada celda es "
"el ganador sobre las dos celdas que supera, y podemos rastrear al ganador "
"hasta el árbol para ver todos los oponentes que tuvo. Sin embargo, en muchas "
"aplicaciones informáticas de tales torneos, no necesitamos rastrear la "
"historia de un ganador. Para ser más eficientes en la memoria, cuando un "
"ganador es ascendido, tratamos de reemplazarlo por algo más en un nivel "
"inferior, y la regla se convierte en que una celda y las dos celdas que "
"supera contienen tres elementos diferentes, pero la celda superior \"gana\" "
"sobre las dos celdas superiores."

#: ../Doc/library/heapq.rst:268
msgid ""
"If this heap invariant is protected at all time, index 0 is clearly the "
"overall winner.  The simplest algorithmic way to remove it and find the "
"\"next\" winner is to move some loser (let's say cell 30 in the diagram "
"above) into the 0 position, and then percolate this new 0 down the tree, "
"exchanging values, until the invariant is re-established. This is clearly "
"logarithmic on the total number of items in the tree. By iterating over all "
"items, you get an O(n log n) sort."
msgstr ""
"Si esta invariante del montículo está protegida en todo momento, el índice 0 "
"es claramente el ganador general. La forma algorítmica más simple de "
"eliminarlo y encontrar el \"próximo\" ganador es mover algún perdedor "
"(digamos la celda 30 en el diagrama de arriba) a la posición 0, y luego "
"filtrar este nuevo 0 por el árbol, intercambiando valores, hasta que la "
"invariante se reestablezca. Esto es claramente logarítmico en el número "
"total de elementos del árbol. Al iterar sobre todos los elementos, se "
"obtiene una clasificación O(n log n)."

#: ../Doc/library/heapq.rst:275
msgid ""
"A nice feature of this sort is that you can efficiently insert new items "
"while the sort is going on, provided that the inserted items are not \"better"
"\" than the last 0'th element you extracted.  This is especially useful in "
"simulation contexts, where the tree holds all incoming events, and the \"win"
"\" condition means the smallest scheduled time.  When an event schedules "
"other events for execution, they are scheduled into the future, so they can "
"easily go into the heap.  So, a heap is a good structure for implementing "
"schedulers (this is what I used for my MIDI sequencer :-)."
msgstr ""
"Una buena característica de este tipo es que puedes insertar nuevos "
"elementos de manera eficiente mientras se realiza la clasificación, siempre "
"y cuando los elementos insertados no sean \"mejores\" que el último 0'th "
"elemento que has extraído. Esto es especialmente útil en contextos de "
"simulación, donde el árbol contiene todos los eventos entrantes, y la "
"condición de \"ganar\" significa el menor tiempo programado. Cuando un "
"evento programa otros eventos para su ejecución, se programan en el futuro, "
"para que puedan ir fácilmente al montículo. Por lo tanto, un montículo es "
"una buena estructura para implementar planificadores o *schedulers* (esto es "
"lo que usé para mi secuenciador MIDI :-)."

#: ../Doc/library/heapq.rst:284
msgid ""
"Various structures for implementing schedulers have been extensively "
"studied, and heaps are good for this, as they are reasonably speedy, the "
"speed is almost constant, and the worst case is not much different than the "
"average case. However, there are other representations which are more "
"efficient overall, yet the worst cases might be terrible."
msgstr ""
"Se han estudiado extensamente varias estructuras para implementar los "
"planificadores, y los montículos son buenos para ello, ya que son "
"razonablemente rápidos, la velocidad es casi constante, y el peor de los "
"casos no es muy diferente del caso promedio. Sin embargo, hay otras "
"representaciones que son más eficientes en general, aunque los peores casos "
"podrían ser terribles."

#: ../Doc/library/heapq.rst:290
msgid ""
"Heaps are also very useful in big disk sorts.  You most probably all know "
"that a big sort implies producing \"runs\" (which are pre-sorted sequences, "
"whose size is usually related to the amount of CPU memory), followed by a "
"merging passes for these runs, which merging is often very cleverly "
"organised [#]_. It is very important that the initial sort produces the "
"longest runs possible.  Tournaments are a good way to achieve that.  If, "
"using all the memory available to hold a tournament, you replace and "
"percolate items that happen to fit the current run, you'll produce runs "
"which are twice the size of the memory for random input, and much better for "
"input fuzzily ordered."
msgstr ""
"Los montículos también son muy útiles en las grandes  ordenaciones de "
"elementos en discos de memoria. Lo más probable es que todos sepan que un "
"tipo grande implica la producción de \"ejecuciones\" (que son secuencias "
"preclasificadas, cuyo tamaño suele estar relacionado con la cantidad de "
"memoria de la CPU), seguidas de una fusión de pases para estas ejecuciones, "
"cuya fusión suele estar muy inteligentemente organizada [#]_. Es muy "
"importante que la clasificación inicial produzca las ejecuciones posibles "
"más largas. Los torneos son una buena manera de lograrlo. Si, utilizando "
"toda la memoria disponible para celebrar un torneo, sustituyes y filtras los "
"elementos que encajan en la carrera actual, producirás carreras que tienen "
"el doble del tamaño de la memoria para la entrada aleatoria, y mucho mejor "
"para la entrada ordenada de forma difusa."

#: ../Doc/library/heapq.rst:300
msgid ""
"Moreover, if you output the 0'th item on disk and get an input which may not "
"fit in the current tournament (because the value \"wins\" over the last "
"output value), it cannot fit in the heap, so the size of the heap "
"decreases.  The freed memory could be cleverly reused immediately for "
"progressively building a second heap, which grows at exactly the same rate "
"the first heap is melting.  When the first heap completely vanishes, you "
"switch heaps and start a new run.  Clever and quite effective!"
msgstr ""
"Además, si se da salida al *0’th item* en el disco y se obtiene una entrada "
"que no puede caber en el torneo actual (porque el valor \"gana\" sobre el "
"último valor de salida), no puede caber en el montículo, por lo que el "
"tamaño del montículo disminuye. La memoria liberada podría ser "
"ingeniosamente reutilizada inmediatamente para construir progresivamente un "
"segundo montículo, que crece exactamente al mismo ritmo que el primer "
"montículo se está fundiendo. Cuando el primer montículo se desvanece "
"completamente, se cambia de montículo y se inicia una nueva carrera. "
"¡Ingenioso y muy efectivo!"

#: ../Doc/library/heapq.rst:308
msgid ""
"In a word, heaps are useful memory structures to know.  I use them in a few "
"applications, and I think it is good to keep a 'heap' module around. :-)"
msgstr ""
"En una palabra, los montículos son estructuras de memoria útiles a conocer. "
"Las uso en algunas aplicaciones, y creo que es bueno tener un módulo 'heap' "
"alrededor. :-)"

#: ../Doc/library/heapq.rst:312
msgid "Footnotes"
msgstr "Notas al pie de página"

#: ../Doc/library/heapq.rst:313
msgid ""
"The disk balancing algorithms which are current, nowadays, are more annoying "
"than clever, and this is a consequence of the seeking capabilities of the "
"disks. On devices which cannot seek, like big tape drives, the story was "
"quite different, and one had to be very clever to ensure (far in advance) "
"that each tape movement will be the most effective possible (that is, will "
"best participate at \"progressing\" the merge).  Some tapes were even able "
"to read backwards, and this was also used to avoid the rewinding time. "
"Believe me, real good tape sorts were quite spectacular to watch! From all "
"times, sorting has always been a Great Art! :-)"
msgstr ""
"Los algoritmos de balanceo de discos que están vigentes hoy en día, son más "
"molestos que inteligentes, y esto es una consecuencia de las capacidades de "
"búsqueda de los discos. En los dispositivos que no pueden buscar, como las "
"grandes unidades de cinta, la historia era muy diferente, y había que ser "
"muy inteligente para asegurarse (con mucha antelación) de que cada "
"movimiento de la cinta fuera el más efectivo (es decir, que participara "
"mejor en el \"progreso\" de la fusión). Algunas cintas eran incluso capaces "
"de leer al revés, y esto también se utilizó para evitar el tiempo "
"rebobinado. Créanme, ¡la ordenación de elementos en cinta realmente buenos "
"fueron espectaculares de ver! ¡Desde todos los tiempos, la ordenación de "
"elementos siempre ha sido un Gran Arte! :-)"
