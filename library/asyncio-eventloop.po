# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-03-19 11:16+0100\n"
"PO-Revision-Date: 2020-09-22 17:54+0000\n"
"Last-Translator: Cristián Maureira-Fredes <cmaureirafredes@gmail.com>\n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../Doc/library/asyncio-eventloop.rst:6
msgid "Event Loop"
msgstr "Bucle de eventos"

#: ../Doc/library/asyncio-eventloop.rst:8
msgid ""
"**Source code:** :source:`Lib/asyncio/events.py`, :source:`Lib/asyncio/"
"base_events.py`"
msgstr ""
"**Código fuente:** :source:`Lib/asyncio/events.py`, :source:`Lib/asyncio/"
"base_events.py`"

#: ../Doc/library/asyncio-eventloop.rst:14
msgid "Preface"
msgstr "Prólogo"

#: ../Doc/library/asyncio-eventloop.rst:15
msgid ""
"The event loop is the core of every asyncio application. Event loops run "
"asynchronous tasks and callbacks, perform network IO operations, and run "
"subprocesses."
msgstr ""
"El bucle de eventos es el núcleo de cada aplicación asyncio. Los bucles de "
"eventos ejecutan tareas asíncronas y llamadas de retorno, realizan "
"operaciones de E/S de red y ejecutan subprocesos."

#: ../Doc/library/asyncio-eventloop.rst:19
msgid ""
"Application developers should typically use the high-level asyncio "
"functions, such as :func:`asyncio.run`, and should rarely need to reference "
"the loop object or call its methods.  This section is intended mostly for "
"authors of lower-level code, libraries, and frameworks, who need finer "
"control over the event loop behavior."
msgstr ""
"Los desarrolladores de aplicaciones normalmente deberían usar las funciones "
"asyncio de alto nivel, como: :func:`asyncio.run`, y rara vez deberían "
"necesitar hacer referencia al objeto de bucle o llamar a sus métodos. Esta "
"sección esta dirigida principalmente a autores de código de nivel inferior, "
"bibliotecas y frameworks, quienes necesitan un control mas preciso sobre el "
"comportamiento del bucle de eventos."

#: ../Doc/library/asyncio-eventloop.rst:26
msgid "Obtaining the Event Loop"
msgstr "Obtención del bucle de eventos"

#: ../Doc/library/asyncio-eventloop.rst:27
msgid ""
"The following low-level functions can be used to get, set, or create an "
"event loop:"
msgstr ""
"Las siguientes funciones de bajo nivel se pueden utilizar para obtener, "
"establecer o crear un bucle de eventos:"

#: ../Doc/library/asyncio-eventloop.rst:32
msgid "Return the running event loop in the current OS thread."
msgstr ""
"Retorna el bucle de eventos en ejecución en el hilo del sistema operativo "
"actual."

#: ../Doc/library/asyncio-eventloop.rst:34
msgid ""
"If there is no running event loop a :exc:`RuntimeError` is raised. This "
"function can only be called from a coroutine or a callback."
msgstr ""
"Si no hay un bucle de eventos en ejecución, se levanta un :exc:"
"`RuntimeError`. Esta función únicamente puede ser llamada desde una "
"corrutina o una llamada de retorno."

#: ../Doc/library/asyncio-eventloop.rst:41
msgid "Get the current event loop."
msgstr "Obtiene bucle de eventos actual."

#: ../Doc/library/asyncio-eventloop.rst:43
msgid ""
"If there is no current event loop set in the current OS thread, the OS "
"thread is main, and :func:`set_event_loop` has not yet been called, asyncio "
"will create a new event loop and set it as the current one."
msgstr ""
"Si no hay un bucle de eventos actual establecido en el hilo actual del "
"sistema operativo, el hilo del sistema operativo es el principal, y :func:"
"`set_event_loop` aún no ha sido llamado, asyncio creará un nuevo bucle de "
"eventos y lo establecerá como el actual."

#: ../Doc/library/asyncio-eventloop.rst:48
msgid ""
"Because this function has rather complex behavior (especially when custom "
"event loop policies are in use), using the :func:`get_running_loop` function "
"is preferred to :func:`get_event_loop` in coroutines and callbacks."
msgstr ""
"Dado que esta función tiene un comportamiento bastante complejo "
"(especialmente cuando están en uso las políticas de bucle de eventos "
"personalizadas), usar la función :func:`get_running_loop` es preferible "
"antes que :func:`get_event_loop` en corrutinas y llamadas de retorno."

#: ../Doc/library/asyncio-eventloop.rst:53
msgid ""
"Consider also using the :func:`asyncio.run` function instead of using lower "
"level functions to manually create and close an event loop."
msgstr ""
"Considere también usar la función :func:`asyncio.run` en lugar de usar "
"funciones de bajo nivel para crear y cerrar manualmente un bucle de eventos."

#: ../Doc/library/asyncio-eventloop.rst:58
msgid "Set *loop* as a current event loop for the current OS thread."
msgstr ""
"Establece *loop* como el bucle de eventos actual para el hilo actual del "
"sistema operativo."

#: ../Doc/library/asyncio-eventloop.rst:62
msgid "Create a new event loop object."
msgstr "Crea un nuevo objeto de bucle de eventos."

#: ../Doc/library/asyncio-eventloop.rst:64
msgid ""
"Note that the behaviour of :func:`get_event_loop`, :func:`set_event_loop`, "
"and :func:`new_event_loop` functions can be altered by :ref:`setting a "
"custom event loop policy <asyncio-policies>`."
msgstr ""
"Tenga en cuenta que el comportamiento de las funciones :func:"
"`get_event_loop`, :func:`set_event_loop`, y :func:`new_event_loop` puede ser "
"modificado mediante :ref:`estableciendo una política de bucle de eventos "
"personalizada <asyncio-policies>`."

#: ../Doc/library/asyncio-eventloop.rst:70
msgid "Contents"
msgstr "Contenidos"

#: ../Doc/library/asyncio-eventloop.rst:71
msgid "This documentation page contains the following sections:"
msgstr "Esta página de documentación contiene las siguientes secciones:"

#: ../Doc/library/asyncio-eventloop.rst:73
msgid ""
"The `Event Loop Methods`_ section is the reference documentation of the "
"event loop APIs;"
msgstr ""
"La sección `Métodos del bucle de eventos`_ es la documentación de referencia "
"de las APIs del bucle de eventos;"

#: ../Doc/library/asyncio-eventloop.rst:76
msgid ""
"The `Callback Handles`_ section documents the :class:`Handle` and :class:"
"`TimerHandle` instances which are returned from scheduling methods such as :"
"meth:`loop.call_soon` and :meth:`loop.call_later`;"
msgstr ""
"La sección `Callback Handles`_ documenta las instancias :class:`Handle` y :"
"class:`TimerHandle` las cuales son retornadas por métodos planificados como :"
"meth:`loop.call_soon` y :meth:`loop.call_later`;"

#: ../Doc/library/asyncio-eventloop.rst:80
msgid ""
"The `Server Objects`_ section documents types returned from event loop "
"methods like :meth:`loop.create_server`;"
msgstr ""
"La sección `Objetos del servidor`_ documenta tipos retornados por los "
"métodos del bucle de eventos como :meth:`loop.create_server`;"

#: ../Doc/library/asyncio-eventloop.rst:83
msgid ""
"The `Event Loop Implementations`_ section documents the :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop` classes;"
msgstr ""
"La sección `Implementaciones de bucle de eventos`_ documenta las clases :"
"class:`SelectorEventLoop` y :class:`ProactorEventLoop`;"

#: ../Doc/library/asyncio-eventloop.rst:86
msgid ""
"The `Examples`_ section showcases how to work with some event loop APIs."
msgstr ""
"La sección `Ejemplos`_ muestra como trabajar con algunas APIs de bucle de "
"eventos."

#: ../Doc/library/asyncio-eventloop.rst:93
msgid "Event Loop Methods"
msgstr "Métodos del bucle de eventos"

#: ../Doc/library/asyncio-eventloop.rst:95
msgid "Event loops have **low-level** APIs for the following:"
msgstr "Los bucles de eventos tienen APIs de **bajo nivel** para lo siguiente:"

#: ../Doc/library/asyncio-eventloop.rst:103
msgid "Running and stopping the loop"
msgstr "Iniciar y para el bucle"

#: ../Doc/library/asyncio-eventloop.rst:107
msgid "Run until the *future* (an instance of :class:`Future`) has completed."
msgstr ""
"Se ejecuta hasta que *future* (una instancia de :class:`Future`) se haya "
"completado."

#: ../Doc/library/asyncio-eventloop.rst:110
msgid ""
"If the argument is a :ref:`coroutine object <coroutine>` it is implicitly "
"scheduled to run as a :class:`asyncio.Task`."
msgstr ""
"Si el argumento es un :ref:`objeto corrutina <coroutine>` está "
"implícitamente planificado para ejecutarse como una :class:`asyncio.Task`."

#: ../Doc/library/asyncio-eventloop.rst:113
msgid "Return the Future's result or raise its exception."
msgstr "Retorna el resultado del Futuro o genera una excepción."

#: ../Doc/library/asyncio-eventloop.rst:117
msgid "Run the event loop until :meth:`stop` is called."
msgstr "Ejecuta el bucle de eventos hasta que :meth:`stop` es llamado."

#: ../Doc/library/asyncio-eventloop.rst:119
msgid ""
"If :meth:`stop` is called before :meth:`run_forever()` is called, the loop "
"will poll the I/O selector once with a timeout of zero, run all callbacks "
"scheduled in response to I/O events (and those that were already scheduled), "
"and then exit."
msgstr ""
"Si :meth:`stop` es llamado antes que :meth:`run_forever()`, el bucle va a "
"sondear el selector de E/S una sola vez con un plazo de ejecución de cero, "
"ejecuta todas las llamadas planificadas como respuesta a eventos E/S (y "
"aquellas que ya hayan sido planificados), y entonces termina."

#: ../Doc/library/asyncio-eventloop.rst:124
msgid ""
"If :meth:`stop` is called while :meth:`run_forever` is running, the loop "
"will run the current batch of callbacks and then exit. Note that new "
"callbacks scheduled by callbacks will not run in this case; instead, they "
"will run the next time :meth:`run_forever` or :meth:`run_until_complete` is "
"called."
msgstr ""
"Si :meth:`stop` es llamado mientras :meth:`run_forever` se está ejecutando, "
"el loop ejecutará el lote actual de llamadas y después finalizará. Tenga en "
"cuenta que llamadas planificadas por otras llamadas no se ejecutarán en este "
"caso; en su lugar, ellas correrán la próxima vez que :meth:`run_forever` o :"
"meth:`run_until_complete` sean llamados."

#: ../Doc/library/asyncio-eventloop.rst:132
msgid "Stop the event loop."
msgstr "Detener el bucle de eventos."

#: ../Doc/library/asyncio-eventloop.rst:136
msgid "Return ``True`` if the event loop is currently running."
msgstr "Retorna ``True`` si el bucle de eventos esta en ejecución actualmente."

#: ../Doc/library/asyncio-eventloop.rst:140
msgid "Return ``True`` if the event loop was closed."
msgstr "Retorna ``True`` si el bucle de eventos se cerró."

#: ../Doc/library/asyncio-eventloop.rst:144
msgid "Close the event loop."
msgstr "Cierra el bucle de eventos."

#: ../Doc/library/asyncio-eventloop.rst:146
msgid ""
"The loop must not be running when this function is called. Any pending "
"callbacks will be discarded."
msgstr ""
"El bucle no debe estar en ejecución cuando se llama a esta función. "
"Cualquier llamada de retorno pendiente será descartada."

#: ../Doc/library/asyncio-eventloop.rst:149
msgid ""
"This method clears all queues and shuts down the executor, but does not wait "
"for the executor to finish."
msgstr ""
"Este método limpia todas las colas y apaga el ejecutor, pero no espera a que "
"el ejecutor termine."

#: ../Doc/library/asyncio-eventloop.rst:152
msgid ""
"This method is idempotent and irreversible.  No other methods should be "
"called after the event loop is closed."
msgstr ""
"Este método es idempotente e irreversible. No se debe llamar ningún otro "
"método después que el bucle de eventos es cerrado."

#: ../Doc/library/asyncio-eventloop.rst:157
msgid ""
"Schedule all currently open :term:`asynchronous generator` objects to close "
"with an :meth:`~agen.aclose()` call.  After calling this method, the event "
"loop will issue a warning if a new asynchronous generator is iterated. This "
"should be used to reliably finalize all scheduled asynchronous generators."
msgstr ""
"Programa todos los objetos :term:`asynchronous generator` abiertos "
"actualmente para cerrarlos con una llamada :meth:`~agen.aclose()`. Después "
"de llamar este método, el bucle de eventos emitirá una advertencia si un "
"nuevo generador asíncrono es iterado. Esto debe ser usado para finalizar de "
"manera confiable todos los generadores asíncronos planificados."

#: ../Doc/library/asyncio-eventloop.rst:163
#: ../Doc/library/asyncio-eventloop.rst:183
msgid ""
"Note that there is no need to call this function when :func:`asyncio.run` is "
"used."
msgstr ""
"Tenga en cuenta que no hay necesidad de llamar esta función cuando :func:"
"`asyncio.run` es utilizado."

#: ../Doc/library/asyncio-eventloop.rst:166
#: ../Doc/library/asyncio-eventloop.rst:1074
#: ../Doc/library/asyncio-eventloop.rst:1456
msgid "Example::"
msgstr "Ejemplo::"

#: ../Doc/library/asyncio-eventloop.rst:178
msgid ""
"Schedule the closure of the default executor and wait for it to join all of "
"the threads in the :class:`ThreadPoolExecutor`. After calling this method, "
"a :exc:`RuntimeError` will be raised if :meth:`loop.run_in_executor` is "
"called while using the default executor."
msgstr ""

#: ../Doc/library/asyncio-eventloop.rst:190
msgid "Scheduling callbacks"
msgstr "Programación de llamadas de retorno"

#: ../Doc/library/asyncio-eventloop.rst:194
#, fuzzy
msgid ""
"Schedule the *callback* :term:`callback` to be called with *args* arguments "
"at the next iteration of the event loop."
msgstr ""
"Planifica un *callback* para ser ejecutada con los argumentos *args* en la "
"próxima iteración del bucle de eventos."

#: ../Doc/library/asyncio-eventloop.rst:197
msgid ""
"Callbacks are called in the order in which they are registered. Each "
"callback will be called exactly once."
msgstr ""
"Llamadas que son ejecutadas en el orden en el que fueron registradas. Cada "
"llamada será ejecutada exactamente una sola vez."

#: ../Doc/library/asyncio-eventloop.rst:200
#: ../Doc/library/asyncio-eventloop.rst:263
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"Un argumento *context* opcional y solo de palabra clave que permite "
"especificar una clase :class:`contextvars.Context` personalizada en la cual "
"*callback* será ejecutada. Cuando no se provee *context* el contexto actual "
"es utilizado."

#: ../Doc/library/asyncio-eventloop.rst:204
msgid ""
"An instance of :class:`asyncio.Handle` is returned, which can be used later "
"to cancel the callback."
msgstr ""
"Una instancia de :class:`asyncio.Handle` es retornada, que puede ser "
"utilizada después para cancelar la llamada."

#: ../Doc/library/asyncio-eventloop.rst:207
msgid "This method is not thread-safe."
msgstr "Este método no es seguro para subprocesos."

#: ../Doc/library/asyncio-eventloop.rst:211
msgid ""
"A thread-safe variant of :meth:`call_soon`.  Must be used to schedule "
"callbacks *from another thread*."
msgstr ""
"Una variante de :meth:`call_soon` que es segura para subprocesos. Debe ser "
"usada en llamadas planificadas *desde otro hilo*."

#: ../Doc/library/asyncio-eventloop.rst:214
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Vea sección :ref:`concurrencia y multiproceso <asyncio-multithreading>` de "
"la documentación."

#: ../Doc/library/asyncio-eventloop.rst:217
#: ../Doc/library/asyncio-eventloop.rst:267
#: ../Doc/library/asyncio-eventloop.rst:287
msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr ""
"Fue agregado el parámetro solo de palabra clave *context*. Vea :pep:`567` "
"para mas detalles."

#: ../Doc/library/asyncio-eventloop.rst:225
msgid ""
"Most :mod:`asyncio` scheduling functions don't allow passing keyword "
"arguments.  To do that, use :func:`functools.partial`::"
msgstr ""
"La mayoría de las funciones planificadas de :mod:`asyncio` no permiten pasar "
"argumentos de palabra clave. Para hacer eso utilice :func:`functools."
"partial`::"

#: ../Doc/library/asyncio-eventloop.rst:232
msgid ""
"Using partial objects is usually more convenient than using lambdas, as "
"asyncio can render partial objects better in debug and error messages."
msgstr ""
"El uso de objetos parciales es usualmente mas conveniente que utilizar "
"lambdas, ya que asyncio puede renderizar mejor objetos parciales en mensajes "
"de depuración y error."

#: ../Doc/library/asyncio-eventloop.rst:240
msgid "Scheduling delayed callbacks"
msgstr "Planificando llamadas retardadas"

#: ../Doc/library/asyncio-eventloop.rst:242
msgid ""
"Event loop provides mechanisms to schedule callback functions to be called "
"at some point in the future.  Event loop uses monotonic clocks to track time."
msgstr ""
"El bucle de eventos provee mecanismos para planificar funciones de llamadas "
"que serán ejecutadas en algún punto en el futuro. El bucle de eventos usa "
"relojes monotónicos para seguir el tiempo."

#: ../Doc/library/asyncio-eventloop.rst:249
msgid ""
"Schedule *callback* to be called after the given *delay* number of seconds "
"(can be either an int or a float)."
msgstr ""
"Planifica *callback* para ser ejecutada luego de *delay* número de segundos "
"(puede ser tanto un entero como un flotante)."

#: ../Doc/library/asyncio-eventloop.rst:252
#: ../Doc/library/asyncio-eventloop.rst:284
msgid ""
"An instance of :class:`asyncio.TimerHandle` is returned which can be used to "
"cancel the callback."
msgstr ""
"Una instancia de :class:`asyncio.TimerHandle` es retornada, la que puede ser "
"utilizada para cancelar la ejecución."

#: ../Doc/library/asyncio-eventloop.rst:255
msgid ""
"*callback* will be called exactly once.  If two callbacks are scheduled for "
"exactly the same time, the order in which they are called is undefined."
msgstr ""
"*callback* será ejecutada exactamente una sola vez. Si dos llamadas son "
"planificadas para el mismo momento exacto, el orden en el que son ejecutadas "
"es indefinido."

#: ../Doc/library/asyncio-eventloop.rst:259
msgid ""
"The optional positional *args* will be passed to the callback when it is "
"called. If you want the callback to be called with keyword arguments use :"
"func:`functools.partial`."
msgstr ""
"El argumento posicional opcional *args* será pasado a la llamada cuando esta "
"sea ejecutada. Si quieres que la llamada sea ejecutada con argumentos de "
"palabra clave usa :func:`functools.partial`."

#: ../Doc/library/asyncio-eventloop.rst:271
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"*delay* could not exceed one day. This has been fixed in Python 3.8."
msgstr ""
"En Python 3.7 y versiones anteriores con la implementación del bucle de "
"eventos predeterminada, el *delay* no puede exceder un día. Esto fue "
"arreglado en Python 3.8."

#: ../Doc/library/asyncio-eventloop.rst:278
msgid ""
"Schedule *callback* to be called at the given absolute timestamp *when* (an "
"int or a float), using the same time reference as :meth:`loop.time`."
msgstr ""
"Planifica *callback* para ser ejecutada en una marca de tiempo absoluta "
"*when* (un entero o un flotante), usando la misma referencia de tiempo que :"
"meth:`loop.time`."

#: ../Doc/library/asyncio-eventloop.rst:282
msgid "This method's behavior is the same as :meth:`call_later`."
msgstr "El comportamiento de este método es el mismo que :meth:`call_later`."

#: ../Doc/library/asyncio-eventloop.rst:291
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"difference between *when* and the current time could not exceed one day.  "
"This has been fixed in Python 3.8."
msgstr ""
"En Python 3.7 y versiones anteriores con la implementación del bucle de "
"eventos predeterminada, la diferencia entre *when* y el tiempo actual no "
"puede exceder un día. Esto fue arreglado en Python 3.8."

#: ../Doc/library/asyncio-eventloop.rst:298
msgid ""
"Return the current time, as a :class:`float` value, according to the event "
"loop's internal monotonic clock."
msgstr ""
"Retorna el tiempo actual, como un :class:`float`, de acuerdo al reloj "
"monotónico interno del bucle de evento."

#: ../Doc/library/asyncio-eventloop.rst:302
msgid ""
"In Python 3.7 and earlier timeouts (relative *delay* or absolute *when*) "
"should not exceed one day.  This has been fixed in Python 3.8."
msgstr ""
"En Python 3.7 y versiones anteriores los tiempos de espera (*delay* relativo "
"o *when* absoluto) no deben exceder un día. Esto fue arreglado en Python 3.8."

#: ../Doc/library/asyncio-eventloop.rst:308
msgid "The :func:`asyncio.sleep` function."
msgstr "La función :func:`asyncio.sleep`."

#: ../Doc/library/asyncio-eventloop.rst:312
msgid "Creating Futures and Tasks"
msgstr "Creando Futuros y Tareas"

#: ../Doc/library/asyncio-eventloop.rst:316
msgid "Create an :class:`asyncio.Future` object attached to the event loop."
msgstr "Crea un objeto :class:`asyncio.Future` adjunto al bucle de eventos."

#: ../Doc/library/asyncio-eventloop.rst:318
msgid ""
"This is the preferred way to create Futures in asyncio. This lets third-"
"party event loops provide alternative implementations of the Future object "
"(with better performance or instrumentation)."
msgstr ""
"Esta es la manera preferida de crear Futures en asyncio. Esto permite que "
"bucles de eventos de terceros provean implementaciones alternativas del "
"objeto Future (con mejor rendimiento o instrumentación)."

#: ../Doc/library/asyncio-eventloop.rst:326
msgid ""
"Schedule the execution of a :ref:`coroutine`. Return a :class:`Task` object."
msgstr ""
"Planifica la ejecución de una :ref:`Coroutine`. Retorna un objeto :class:"
"`Task`."

#: ../Doc/library/asyncio-eventloop.rst:329
msgid ""
"Third-party event loops can use their own subclass of :class:`Task` for "
"interoperability. In this case, the result type is a subclass of :class:"
"`Task`."
msgstr ""
"Bucles de eventos de terceros pueden usar sus propias subclases de :class:"
"`Task` por interoperabilidad. En este caso, el tipo de resultado es una "
"subclase de :class:`Task`."

#: ../Doc/library/asyncio-eventloop.rst:333
msgid ""
"If the *name* argument is provided and not ``None``, it is set as the name "
"of the task using :meth:`Task.set_name`."
msgstr ""
"Si el argumento *name* es provisto y no ``None``, se establece como el "
"nombre de la tarea usando :meth:`Task.set_name`."

#: ../Doc/library/asyncio-eventloop.rst:336
msgid "Added the ``name`` parameter."
msgstr "Agregado el parámetro ``name``."

#: ../Doc/library/asyncio-eventloop.rst:341
msgid "Set a task factory that will be used by :meth:`loop.create_task`."
msgstr ""
"Establece una fábrica de tareas que será utilizada por :meth:`loop."
"create_task`."

#: ../Doc/library/asyncio-eventloop.rst:344
msgid ""
"If *factory* is ``None`` the default task factory will be set. Otherwise, "
"*factory* must be a *callable* with the signature matching ``(loop, coro)``, "
"where *loop* is a reference to the active event loop, and *coro* is a "
"coroutine object.  The callable must return a :class:`asyncio.Future`-"
"compatible object."
msgstr ""
"Si *factory* es ``None`` se establecerá la fábrica de tareas por defecto. En "
"cualquier otro caso, *factory* debe ser un *callable* con la misma firma "
"``(loop, coro)``, donde *loop* es una referencia al bucle de eventos activo "
"y *coro* es un objeto de corrutina. El ejecutable debe retornar una objeto :"
"class:`asyncio.Future` compatible."

#: ../Doc/library/asyncio-eventloop.rst:352
msgid "Return a task factory or ``None`` if the default one is in use."
msgstr ""
"Retorna una fábrica de tareas o ``None`` si la predefinida está en uso."

#: ../Doc/library/asyncio-eventloop.rst:356
msgid "Opening network connections"
msgstr "Abriendo conexiones de red"

#: ../Doc/library/asyncio-eventloop.rst:365
msgid ""
"Open a streaming transport connection to a given address specified by *host* "
"and *port*."
msgstr ""
"Abre una conexión de transmisión de transporte a una dirección especificada "
"por *host* y *port*."

#: ../Doc/library/asyncio-eventloop.rst:368
msgid ""
"The socket family can be either :py:data:`~socket.AF_INET` or :py:data:"
"`~socket.AF_INET6` depending on *host* (or the *family* argument, if "
"provided)."
msgstr ""
"La familia de sockets puede ser tanto :py:data:`~socket.AF_INET` como :py:"
"data:`~socket.AF_INET6` dependiendo de *host* (o del argumento *family* si "
"es que fue provisto)."

#: ../Doc/library/asyncio-eventloop.rst:372
msgid "The socket type will be :py:data:`~socket.SOCK_STREAM`."
msgstr "El tipo de socket será :py:data:`~socket.SOCK_STREAM`."

#: ../Doc/library/asyncio-eventloop.rst:374
#: ../Doc/library/asyncio-eventloop.rst:990
#: ../Doc/library/asyncio-eventloop.rst:1006
msgid ""
"*protocol_factory* must be a callable returning an :ref:`asyncio protocol "
"<asyncio-protocol>` implementation."
msgstr ""
"*protocol_factory* debe ser un ejecutable que retorna una implementación "
"del :ref:`asyncio protocol <asyncio-protocol>`."

#: ../Doc/library/asyncio-eventloop.rst:377
msgid ""
"This method will try to establish the connection in the background. When "
"successful, it returns a ``(transport, protocol)`` pair."
msgstr ""
"Este método tratará de establecer la conexión en un segundo plano. Cuando es "
"exitosa, retorna un par ``(transport, protocol)``."

#: ../Doc/library/asyncio-eventloop.rst:380
msgid "The chronological synopsis of the underlying operation is as follows:"
msgstr "La sinopsis cronológica de las operaciones subyacentes es como sigue:"

#: ../Doc/library/asyncio-eventloop.rst:382
msgid ""
"The connection is established and a :ref:`transport <asyncio-transport>` is "
"created for it."
msgstr ""
"La conexión es establecida y un :ref:`transport <asyncio-transport>` es "
"creado para ello."

#: ../Doc/library/asyncio-eventloop.rst:385
msgid ""
"*protocol_factory* is called without arguments and is expected to return a :"
"ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"*protocol_factory* es llamado sin argumentos y se espera que retorne una "
"instancia de :ref:`protocol <asyncio-protocol>`."

#: ../Doc/library/asyncio-eventloop.rst:388
msgid ""
"The protocol instance is coupled with the transport by calling its :meth:"
"`~BaseProtocol.connection_made` method."
msgstr ""
"La instancia del protocolo se acopla con el transporte mediante el llamado "
"de su método :meth:`~BaseProtocol.connection_made`."

#: ../Doc/library/asyncio-eventloop.rst:391
msgid "A ``(transport, protocol)`` tuple is returned on success."
msgstr ""
"Una tupla ``(transport, protocol)`` es retornada cuando se tiene éxito."

#: ../Doc/library/asyncio-eventloop.rst:393
msgid ""
"The created transport is an implementation-dependent bidirectional stream."
msgstr ""
"El transporte creado es una transmisión (*stream*) bidireccional que depende "
"de la implementación."

#: ../Doc/library/asyncio-eventloop.rst:396
#: ../Doc/library/asyncio-eventloop.rst:518
msgid "Other arguments:"
msgstr "Otros argumentos:"

#: ../Doc/library/asyncio-eventloop.rst:398
msgid ""
"*ssl*: if given and not false, a SSL/TLS transport is created (by default a "
"plain TCP transport is created).  If *ssl* is a :class:`ssl.SSLContext` "
"object, this context is used to create the transport; if *ssl* is :const:"
"`True`, a default context returned from :func:`ssl.create_default_context` "
"is used."
msgstr ""
"*ssl*: si se provee y no es falso, un transporte SSL/TLS es creado (de "
"manera predeterminada se crea un transporte TCP plano).  Si *ssl* es un "
"objeto :class:`ssl.SSLContext`, este contexto es utilizado para crear el "
"transporte; si *ssl* es :const:`True`, se utiliza un contexto predeterminado "
"retornado por :func:`ssl.create_default_context`."

#: ../Doc/library/asyncio-eventloop.rst:404
msgid ":ref:`SSL/TLS security considerations <ssl-security>`"
msgstr ":ref:`Consideraciones de seguridad SSL/TLS <ssl-security>`"

#: ../Doc/library/asyncio-eventloop.rst:406
msgid ""
"*server_hostname* sets or overrides the hostname that the target server's "
"certificate will be matched against.  Should only be passed if *ssl* is not "
"``None``.  By default the value of the *host* argument is used.  If *host* "
"is empty, there is no default and you must pass a value for "
"*server_hostname*.  If *server_hostname* is an empty string, hostname "
"matching is disabled (which is a serious security risk, allowing for "
"potential man-in-the-middle attacks)."
msgstr ""
"*server_hostname* establece o reemplaza el nombre de servidor (*hostname*) "
"contra el cual el certificado del servidor de destino será comparado. Sólo "
"debería ser pasado si *ssl* no es ``None``. De manera predeterminada es "
"usado el valor del argumento *host*.  Si *host* está vacío, no hay valor "
"predeterminado y debes pasar un valor para *server_hostname*. Si "
"*server_hostname* es una cadena vacía, la comparación de nombres de "
"servidores es deshabilitada (lo que es un riesgo de seguridad serio, "
"permitiendo potenciales ataques de hombre-en-el-medio, *man-in-the-middle "
"attacks*)."

#: ../Doc/library/asyncio-eventloop.rst:414
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to getaddrinfo() for *host* resolution. If given, "
"these should all be integers from the corresponding :mod:`socket` module "
"constants."
msgstr ""
"*family*, *proto*, *flags* son dirección de familia, protocolo y banderas "
"opcionales que serán pasadas a través de `getaddrinfo()` para la resolución "
"de *host*. Si están dados, todos ellos deberían ser enteros de las "
"constantes del módulo :mod:`socket` correspondiente."

#: ../Doc/library/asyncio-eventloop.rst:419
#, fuzzy
msgid ""
"*happy_eyeballs_delay*, if given, enables Happy Eyeballs for this "
"connection. It should be a floating-point number representing the amount of "
"time in seconds to wait for a connection attempt to complete, before "
"starting the next attempt in parallel. This is the \"Connection Attempt Delay"
"\" as defined in :rfc:`8305`. A sensible default value recommended by the "
"RFC is ``0.25`` (250 milliseconds)."
msgstr ""
"*happy_eyeballs_delay*, si es provisto, habilita Globos Oculares Felices "
"(*Happy Eyeballs*) para esta conexión. Debería ser un número con coma "
"flotante representando la cantidad de tiempo en segundos a esperar para que "
"un intento de conexión se complete, antes de empezar el próximo intento en "
"paralelo.  Este es el retraso de intento de conexión (*Connection Attempt "
"Delay*) como es definido en :rfc:`8305`. Un valor predefinido sensible que "
"es recomendado por el RFC es ``0.25`` (250 milisegundos)."

#: ../Doc/library/asyncio-eventloop.rst:427
msgid ""
"*interleave* controls address reordering when a host name resolves to "
"multiple IP addresses. If ``0`` or unspecified, no reordering is done, and "
"addresses are tried in the order returned by :meth:`getaddrinfo`. If a "
"positive integer is specified, the addresses are interleaved by address "
"family, and the given integer is interpreted as \"First Address Family Count"
"\" as defined in :rfc:`8305`. The default is ``0`` if *happy_eyeballs_delay* "
"is not specified, and ``1`` if it is."
msgstr ""
"*interleave* controla reordenamientos de dirección cuando un nombre de "
"servidor resuelve a múltiples direcciones IP. Si es ``0`` o no es "
"especificado, no se hace ningún reordenamiento, y las direcciones son "
"intentadas en el orden retornado por :meth:`getaddrinfo`. Si un entero "
"positivo es especificado, las direcciones son intercaladas por dirección de "
"familia, y el entero dado es interpretado como \"Número de familias de la "
"primera dirección\" (*First Address Family Count*) como es definida en :rfc:"
"`8305`. El valor predefinido es ``0`` si *happy_eyeballs_delay* no es "
"especificado, y ``1`` si lo es."

#: ../Doc/library/asyncio-eventloop.rst:436
msgid ""
"*sock*, if given, should be an existing, already connected :class:`socket."
"socket` object to be used by the transport. If *sock* is given, none of "
"*host*, *port*, *family*, *proto*, *flags*, *happy_eyeballs_delay*, "
"*interleave* and *local_addr* should be specified."
msgstr ""
"*sock*, si está dado, debe ser un objeto :class:`socket.socket` existente y "
"ya conectado, que será utilizado por el transporte. Si *sock* es dado, "
"ningún *host*, *port*, *family*, *proto*, *flags*, *happy_eyeballs_delay*, "
"*interleave* o *local_addr* deben ser especificados."

#: ../Doc/library/asyncio-eventloop.rst:442
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket to locally.  The *local_host* and *local_port* are looked up "
"using ``getaddrinfo()``, similarly to *host* and *port*."
msgstr ""
"*local_addr*, si está dado, es una tupla ``(local_host, local_port)``usada "
"para enlazar el socket localmente.  Los *local_host* y *local_port* son "
"buscados usando ``getaddrinfo()``, de manera similar que con *host* y "
"*puerto*."

#: ../Doc/library/asyncio-eventloop.rst:446
#: ../Doc/library/asyncio-eventloop.rst:799
msgid ""
"*ssl_handshake_timeout* is (for a TLS connection) the time in seconds to "
"wait for the TLS handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* es (para una conexión TLS) el tiempo en segundos a "
"esperar que se complete el apretón de manos (*handshake*) TLS antes de "
"abortar la conexión. ``60.0`` segundos si es ``None`` (predefinido)."

#: ../Doc/library/asyncio-eventloop.rst:452
msgid "Added the *happy_eyeballs_delay* and *interleave* parameters."
msgstr "Agregados los parámetros *happy_eyeballs_delay* y *interleave*."

#: ../Doc/library/asyncio-eventloop.rst:454
msgid ""
"Happy Eyeballs Algorithm: Success with Dual-Stack Hosts. When a server's "
"IPv4 path and protocol are working, but the server's IPv6 path and protocol "
"are not working, a dual-stack client application experiences significant "
"connection delay compared to an IPv4-only client.  This is undesirable "
"because it causes the dual- stack client to have a worse user experience.  "
"This document specifies requirements for algorithms that reduce this user-"
"visible delay and provides an algorithm."
msgstr ""
"Algoritmo de Globos Oculares Felices (*Happy Eyeballs*): Éxito con "
"Servidores de Doble-Pila (Dual-Stack Hosts). Cuando la ruta IPv4 y el "
"protocolo de un servidor están funcionando, pero la ruta IPv6 y el protocolo "
"no están funcionando, una aplicación del cliente de doble-pila experimenta "
"una demora de conexión significante en comparación con un cliente sólo de "
"IPv4.  Esto no es deseable porque causa que el cliente de doble-pila tenga "
"la peor experiencia de usuario. Este documento especifica requerimientos "
"para algoritmos que reducen esta demora visible por el usuario, y provee un "
"algoritmo."

#: ../Doc/library/asyncio-eventloop.rst:463
msgid "For more information: https://tools.ietf.org/html/rfc6555"
msgstr "Para mas información: https://tools.ietf.org/html/rfc6555"

#: ../Doc/library/asyncio-eventloop.rst:467
#: ../Doc/library/asyncio-eventloop.rst:584
#: ../Doc/library/asyncio-eventloop.rst:737
msgid "The *ssl_handshake_timeout* parameter."
msgstr "El parámetro *ssl_handshake_timeout*."

#: ../Doc/library/asyncio-eventloop.rst:471
#: ../Doc/library/asyncio-eventloop.rst:667
msgid ""
"The socket option :py:data:`~socket.TCP_NODELAY` is set by default for all "
"TCP connections."
msgstr ""
"La opción del socket :py:data:`~socket.TCP_NODELAY` es establecida de manera "
"predeterminada para todas las conexiones TCP."

#: ../Doc/library/asyncio-eventloop.rst:476
#: ../Doc/library/asyncio-eventloop.rst:672
msgid "Added support for SSL/TLS in :class:`ProactorEventLoop`."
msgstr "Agregado el soporte para SSL/TLS en :class:`ProactorEventLoop`."

#: ../Doc/library/asyncio-eventloop.rst:480
msgid ""
"The :func:`open_connection` function is a high-level alternative API.  It "
"returns a pair of (:class:`StreamReader`, :class:`StreamWriter`) that can be "
"used directly in async/await code."
msgstr ""
"La función :func:`open_connection` es una API alternativa de alto nivel. "
"Retorna un par de (:class:`StreamReader`, :class:`StreamWriter`) que puede "
"ser usado directamente en código async/await."

#: ../Doc/library/asyncio-eventloop.rst:491
msgid ""
"The parameter *reuse_address* is no longer supported, as using :py:data:"
"`~sockets.SO_REUSEADDR` poses a significant security concern for UDP. "
"Explicitly passing ``reuse_address=True`` will raise an exception."
msgstr ""
"El parámetro *reuse_address* ya no es soportado, como utiliza :py:data:"
"`~sockets.SO_REUSEADDR` plantea un problema de seguridad importante para "
"UDP. Pasando explícitamente ``reuse_address=True`` lanzará una excepción."

#: ../Doc/library/asyncio-eventloop.rst:495
msgid ""
"When multiple processes with differing UIDs assign sockets to an identical "
"UDP socket address with ``SO_REUSEADDR``, incoming packets can become "
"randomly distributed among the sockets."
msgstr ""
"Cuando múltiples procesos con UIDs diferentes asignan sockets a una misma "
"dirección socket UDP con ``SO_REUSEADDR``, los paquetes entrantes pueden "
"distribuirse aleatoriamente entre los sockets."

#: ../Doc/library/asyncio-eventloop.rst:499
msgid ""
"For supported platforms, *reuse_port* can be used as a replacement for "
"similar functionality. With *reuse_port*, :py:data:`~sockets.SO_REUSEPORT` "
"is used instead, which specifically prevents processes with differing UIDs "
"from assigning sockets to the same socket address."
msgstr ""
"Para plataformas soportadas, *reuse_port* puede ser utilizado como un "
"reemplazo para funcionalidades similares. Con *reuse_port*, :py:data:"
"`~sockets.SO_REUSEPORT` es usado en su lugar, que específicamente previene "
"que procesos con distintos UIDs asignen sockets a la misma dirección de "
"socket."

#: ../Doc/library/asyncio-eventloop.rst:505
msgid "Create a datagram connection."
msgstr "Crea un datagrama de conexión."

#: ../Doc/library/asyncio-eventloop.rst:507
msgid ""
"The socket family can be either :py:data:`~socket.AF_INET`, :py:data:"
"`~socket.AF_INET6`, or :py:data:`~socket.AF_UNIX`, depending on *host* (or "
"the *family* argument, if provided)."
msgstr ""
"La familia de socket puede ser tanto :py:data:`~socket.AF_INET`, :py:data:"
"`~socket.AF_INET6`, como :py:data:`~socket.AF_UNIX`, dependiendo de *host* "
"(o del argumento *family*, si fue provisto)."

#: ../Doc/library/asyncio-eventloop.rst:511
msgid "The socket type will be :py:data:`~socket.SOCK_DGRAM`."
msgstr "El tipo de socket será :py:data:`~socket.SOCK_DGRAM`."

#: ../Doc/library/asyncio-eventloop.rst:513
#: ../Doc/library/asyncio-eventloop.rst:609
#: ../Doc/library/asyncio-eventloop.rst:720
msgid ""
"*protocol_factory* must be a callable returning a :ref:`protocol <asyncio-"
"protocol>` implementation."
msgstr ""
"*protocol_factory* debe ser un ejecutable que retorne una implementación de :"
"ref:`protocol <asyncio-protocol>`."

#: ../Doc/library/asyncio-eventloop.rst:516
#: ../Doc/library/asyncio-eventloop.rst:570
msgid "A tuple of ``(transport, protocol)`` is returned on success."
msgstr ""
"Una tupla de ``(transport, protocol)`` es retornada cuando se tiene éxito."

#: ../Doc/library/asyncio-eventloop.rst:520
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket to locally.  The *local_host* and *local_port* are looked up "
"using :meth:`getaddrinfo`."
msgstr ""
"*local_addr*, si está dado, es una tupla ``(local_host, local_port)`` usada "
"para enlazar el socket localmente. Los *local_host* y *local_port* son "
"buscados utilizando :meth:`getaddrinfo`."

#: ../Doc/library/asyncio-eventloop.rst:524
msgid ""
"*remote_addr*, if given, is a ``(remote_host, remote_port)`` tuple used to "
"connect the socket to a remote address.  The *remote_host* and *remote_port* "
"are looked up using :meth:`getaddrinfo`."
msgstr ""
"*remote_addr*, si está dado, es una tupla ``(remote_host, remote_port)`` "
"utilizada para conectar el socket a una dirección remota. Los *remote_host* "
"y *remote_port* son buscados utilizando :meth:`getaddrinfo`."

#: ../Doc/library/asyncio-eventloop.rst:528
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to :meth:`getaddrinfo` for *host* resolution. If "
"given, these should all be integers from the corresponding :mod:`socket` "
"module constants."
msgstr ""
"*family*, *proto*, *flags* son direcciones de familia, protocolo y banderas "
"opcionales que serán pasadas a través de :meth:`getaddrinfo` para la "
"resolución de *host*. Si está dado, estos deben ser todos enteros de las "
"constantes del módulo :mod:`socket` correspondiente."

#: ../Doc/library/asyncio-eventloop.rst:533
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows and some "
"Unixes. If the :py:data:`~socket.SO_REUSEPORT` constant is not defined then "
"this capability is unsupported."
msgstr ""
"*reuse_port* dice al kernel que habilite este punto de conexión para ser "
"unido al mismo puerto de la misma forma que otros puntos de conexión "
"existentes también están unidos, siempre y cuando todos ellos establezcan "
"esta bandera al ser creados. Esta opción no es soportada en Windows y "
"algunos sistemas Unix. Si la constante :py:data:`~socket.SO_REUSEPORT` no "
"está definida entonces esta funcionalidad no es soportada."

#: ../Doc/library/asyncio-eventloop.rst:539
msgid ""
"*allow_broadcast* tells the kernel to allow this endpoint to send messages "
"to the broadcast address."
msgstr ""
"*allow_broadcast* dice al kernel que habilite este punto de conexión para "
"enviar mensajes a la dirección de transmisión (*broadcast*)."

#: ../Doc/library/asyncio-eventloop.rst:542
msgid ""
"*sock* can optionally be specified in order to use a preexisting, already "
"connected, :class:`socket.socket` object to be used by the transport. If "
"specified, *local_addr* and *remote_addr* should be omitted (must be :const:"
"`None`)."
msgstr ""
"*sock* puede opcionalmente ser especificado para usar un objeto :class:"
"`socket.socket` preexistente y ya conectado que será utilizado por el "
"transporte. Si están especificados, *local_addr* y *remote_addr* deben ser "
"omitidos (tienen que ser :const:`None`)."

#: ../Doc/library/asyncio-eventloop.rst:547
msgid ""
"See :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` and :"
"ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` examples."
msgstr ""
"Refiérase a los ejemplos :ref:`UDP echo client protocol <asyncio-udp-echo-"
"client-protocol>` y :ref:`UDP echo server protocol <asyncio-udp-echo-server-"
"protocol>`."

#: ../Doc/library/asyncio-eventloop.rst:550
msgid ""
"The *family*, *proto*, *flags*, *reuse_address*, *reuse_port, "
"*allow_broadcast*, and *sock* parameters were added."
msgstr ""
"Los parámetros *family*, *proto*, *flags*, *reuse_address*, *reuse_port*, "
"*allow_broadcast* y *sock* fueron agregados."

#: ../Doc/library/asyncio-eventloop.rst:554
msgid ""
"The *reuse_address* parameter is no longer supported due to security "
"concerns."
msgstr ""
"El parámetro *reuse_address* ya no es soportado debido a problemas de "
"seguridad."

#: ../Doc/library/asyncio-eventloop.rst:558
msgid "Added support for Windows."
msgstr "Se agregó soporte para Windows."

#: ../Doc/library/asyncio-eventloop.rst:565
msgid "Create a Unix connection."
msgstr "Crear una conexión Unix."

#: ../Doc/library/asyncio-eventloop.rst:567
msgid ""
"The socket family will be :py:data:`~socket.AF_UNIX`; socket type will be :"
"py:data:`~socket.SOCK_STREAM`."
msgstr ""
"La familia de sockets será :py:data:`~socket.AF_UNIX`; el tipo de socket "
"será :py:data:`~socket.SOCK_STREAM`."

#: ../Doc/library/asyncio-eventloop.rst:572
msgid ""
"*path* is the name of a Unix domain socket and is required, unless a *sock* "
"parameter is specified.  Abstract Unix sockets, :class:`str`, :class:"
"`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* es el nombre de un dominio de un socket Unix y es requerido, a menos "
"que un parámetro *sock* sea especificado. Los socket Unix abstractos, :class:"
"`str`, :class:`bytes`, y :class:`~pathlib.Path` son soportados."

#: ../Doc/library/asyncio-eventloop.rst:577
msgid ""
"See the documentation of the :meth:`loop.create_connection` method for "
"information about arguments to this method."
msgstr ""
"Vea la documentación del método :meth:`loop.create_connection` para "
"información acerca de los argumentos de este método."

#: ../Doc/library/asyncio-eventloop.rst:581
#: ../Doc/library/asyncio-eventloop.rst:701
#: ../Doc/library/asyncio-eventloop.rst:1057
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`Availability <availability>`: Unix."

#: ../Doc/library/asyncio-eventloop.rst:588
msgid "The *path* parameter can now be a :term:`path-like object`."
msgstr "El parámetro *path* ahora puede ser un :term:`path-like object`."

#: ../Doc/library/asyncio-eventloop.rst:592
msgid "Creating network servers"
msgstr "Creando servidores de red"

#: ../Doc/library/asyncio-eventloop.rst:602
msgid ""
"Create a TCP server (socket type :data:`~socket.SOCK_STREAM`) listening on "
"*port* of the *host* address."
msgstr ""
"Crea un servidor TCP (tipo de socket :data:`~socket.SOCK_STREAM`) escuchando "
"en *port* de la dirección *host*."

#: ../Doc/library/asyncio-eventloop.rst:605
msgid "Returns a :class:`Server` object."
msgstr "Retorna un objeto :class:`Server`."

#: ../Doc/library/asyncio-eventloop.rst:607
msgid "Arguments:"
msgstr "Argumentos:"

#: ../Doc/library/asyncio-eventloop.rst:612
msgid ""
"The *host* parameter can be set to several types which determine where the "
"server would be listening:"
msgstr ""
"El parámetro *host* puede ser establecido a distintos tipos que determinan "
"donde el servidor estaría escuchando:"

#: ../Doc/library/asyncio-eventloop.rst:615
msgid ""
"If *host* is a string, the TCP server is bound to a single network interface "
"specified by *host*."
msgstr ""
"Si *host* es una cadena, el servidor TCP está enlazado a una sola interfaz "
"de red especificada por *host*."

#: ../Doc/library/asyncio-eventloop.rst:618
msgid ""
"If *host* is a sequence of strings, the TCP server is bound to all network "
"interfaces specified by the sequence."
msgstr ""
"Si *host* es una secuencia de cadenas, el servidor TCP está enlazado a todas "
"las interfaces de red especificadas por la secuencia."

#: ../Doc/library/asyncio-eventloop.rst:621
msgid ""
"If *host* is an empty string or ``None``, all interfaces are assumed and a "
"list of multiple sockets will be returned (most likely one for IPv4 and "
"another one for IPv6)."
msgstr ""
"Si *host* es una cadena vacía o ``None``, se asumen todas las interfaces y "
"una lista con múltiples sockets será retornada (mas probablemente uno para "
"IPv4 y otro para IPv6)."

#: ../Doc/library/asyncio-eventloop.rst:625
msgid ""
"*family* can be set to either :data:`socket.AF_INET` or :data:`~socket."
"AF_INET6` to force the socket to use IPv4 or IPv6. If not set, the *family* "
"will be determined from host name (defaults to :data:`~socket.AF_UNSPEC`)."
msgstr ""
"*family* puede ser establecido como :data:`socket.AF_INET` o :data:`~socket."
"AF_INET6` para forzar al socket a usar IPv4 o IPv6. Si no es establecido, la "
"*family* será determinada por medio del nombre del host (por defecto será :"
"data:`~socket.AF_UNSPEC`)."

#: ../Doc/library/asyncio-eventloop.rst:630
msgid "*flags* is a bitmask for :meth:`getaddrinfo`."
msgstr "*flags* es una máscara de bits para :meth:`getaddrinfo`."

#: ../Doc/library/asyncio-eventloop.rst:632
msgid ""
"*sock* can optionally be specified in order to use a preexisting socket "
"object. If specified, *host* and *port* must not be specified."
msgstr ""
"*sock* puede ser especificado opcionalmente para usar objetos socket "
"preexistentes. Si se utiliza, entonces *host* y *port* no deben ser "
"especificados."

#: ../Doc/library/asyncio-eventloop.rst:635
msgid ""
"*backlog* is the maximum number of queued connections passed to :meth:"
"`~socket.socket.listen` (defaults to 100)."
msgstr ""
"*backlog* es el número máximo de conexiones encoladas pasadas a :meth:"
"`~socket.socket.listen` (el valor predeterminado es 100)."

#: ../Doc/library/asyncio-eventloop.rst:638
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` instance to enable TLS over "
"the accepted connections."
msgstr ""
"*ssl* puede ser establecido como una instancia de :class:`~ssl.SSLContext` "
"para habilitar TLS sobre las conexiones aceptadas."

#: ../Doc/library/asyncio-eventloop.rst:641
msgid ""
"*reuse_address* tells the kernel to reuse a local socket in ``TIME_WAIT`` "
"state, without waiting for its natural timeout to expire. If not specified "
"will automatically be set to ``True`` on Unix."
msgstr ""
"*reuse_address* indica al kernel que reutilice un socket local en estado "
"``TIME_WAIT``, sin esperar que su plazo de ejecución expire. Si no es "
"especificado será establecido automáticamente como ``True`` en Unix."

#: ../Doc/library/asyncio-eventloop.rst:646
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows."
msgstr ""
"*reuse_port* dice al kernel que habilite este punto de conexión para ser "
"unido al mismo puerto de la misma forma que otros puntos de conexión "
"existentes también están unidos, siempre y cuando todos ellos establezcan "
"esta bandera al ser creados."

#: ../Doc/library/asyncio-eventloop.rst:651
msgid ""
"*ssl_handshake_timeout* is (for a TLS server) the time in seconds to wait "
"for the TLS handshake to complete before aborting the connection. ``60.0`` "
"seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* es (para un servidor TLS) el tiempo en segundos a "
"esperar por el apretón de manos (*handshake*) TLS a ser completado antes de "
"abortar la conexión. ``60.0`` si es ``None`` (su valor predeterminado)."

#: ../Doc/library/asyncio-eventloop.rst:655
msgid ""
"*start_serving* set to ``True`` (the default) causes the created server to "
"start accepting connections immediately.  When set to ``False``, the user "
"should await on :meth:`Server.start_serving` or :meth:`Server.serve_forever` "
"to make the server to start accepting connections."
msgstr ""
"*start_serving* establecido como ``True`` (de manera predeterminada) produce "
"que los servidores creados comiencen a aceptar conexiones inmediatamente. Si "
"es establecido como ``False``, el usuario debe esperar por :meth:`Server."
"start_serving` o :meth:`Server.serve_forever` para que el servidor comience "
"a aceptar conexiones."

#: ../Doc/library/asyncio-eventloop.rst:663
msgid "Added *ssl_handshake_timeout* and *start_serving* parameters."
msgstr "Agregados los parámetros *ssl_handshake_timeout* y *start_serving*."

#: ../Doc/library/asyncio-eventloop.rst:676
msgid "The *host* parameter can be a sequence of strings."
msgstr "El parámetro *host* puede ser una secuencia de cadenas."

#: ../Doc/library/asyncio-eventloop.rst:680
msgid ""
"The :func:`start_server` function is a higher-level alternative API that "
"returns a pair of :class:`StreamReader` and :class:`StreamWriter` that can "
"be used in an async/await code."
msgstr ""
"La función :func:`start_server` es una API alternativa de alto nivel que "
"retorna un par de :class:`StreamReader` y :class:`StreamWriter` que pueden "
"ser usados en código async/await."

#: ../Doc/library/asyncio-eventloop.rst:689
msgid ""
"Similar to :meth:`loop.create_server` but works with the :py:data:`~socket."
"AF_UNIX` socket family."
msgstr ""
"Similar a :meth:`loop.create_server` pero funciona con la familia de "
"sockets :py:data:`~socket.AF_UNIX`."

#: ../Doc/library/asyncio-eventloop.rst:692
msgid ""
"*path* is the name of a Unix domain socket, and is required, unless a *sock* "
"argument is provided.  Abstract Unix sockets, :class:`str`, :class:`bytes`, "
"and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* es el nombre de un dominio de socket Unix, y es requerido a menos que "
"el argumento *sock* sea provisto. Son soportados sockets unix abstractos, :"
"class:`str`, :class:`bytes`, y rutas :class:`~pathlib.Path`."

#: ../Doc/library/asyncio-eventloop.rst:697
msgid ""
"See the documentation of the :meth:`loop.create_server` method for "
"information about arguments to this method."
msgstr ""
"Vea la documentación de el método :meth:`loop.create_server` para mas "
"información acerca de los argumentos de este método."

#: ../Doc/library/asyncio-eventloop.rst:704
msgid "The *ssl_handshake_timeout* and *start_serving* parameters."
msgstr "Los parámetros *ssl_handshake_timeout*y *start_serving*."

#: ../Doc/library/asyncio-eventloop.rst:708
msgid "The *path* parameter can now be a :class:`~pathlib.Path` object."
msgstr "El parámetro *path* ahora puede ser un objeto :class:`~pathlib.Path`."

#: ../Doc/library/asyncio-eventloop.rst:713
msgid "Wrap an already accepted connection into a transport/protocol pair."
msgstr "Envuelve una conexión ya aceptada en un par de transporte/protocolo."

#: ../Doc/library/asyncio-eventloop.rst:715
msgid ""
"This method can be used by servers that accept connections outside of "
"asyncio but that use asyncio to handle them."
msgstr ""
"Este método puede ser usado por servidores que acepten conexiones por fuera "
"de asyncio, pero que usen asyncio para manejarlas."

#: ../Doc/library/asyncio-eventloop.rst:718
#: ../Doc/library/asyncio-eventloop.rst:785
msgid "Parameters:"
msgstr "Parámetros:"

#: ../Doc/library/asyncio-eventloop.rst:723
msgid ""
"*sock* is a preexisting socket object returned from :meth:`socket.accept "
"<socket.socket.accept>`."
msgstr ""
"*sock* es un objeto socket preexistente retornado por :meth:`socket.accept "
"<socket.socket.accept>`."

#: ../Doc/library/asyncio-eventloop.rst:726
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` to enable SSL over the "
"accepted connections."
msgstr ""
"*ssl* puede ser establecido como un :class:`~ssl.SSLContext` para habilitar "
"SSL sobre las conexiones aceptadas."

#: ../Doc/library/asyncio-eventloop.rst:729
msgid ""
"*ssl_handshake_timeout* is (for an SSL connection) the time in seconds to "
"wait for the SSL handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* es (para una conexión SSL) el tiempo en segundos que "
"se esperará para que se complete el apretón de manos (*handshake*) SSL antes "
"de abortar la conexión. ``60.0`` si es ``None`` (su valor predeterminado)."

#: ../Doc/library/asyncio-eventloop.rst:733
msgid "Returns a ``(transport, protocol)`` pair."
msgstr "Retorna un par ``(transport, protocol)``."

#: ../Doc/library/asyncio-eventloop.rst:743
msgid "Transferring files"
msgstr "Transfiriendo archivos"

#: ../Doc/library/asyncio-eventloop.rst:748
msgid ""
"Send a *file* over a *transport*.  Return the total number of bytes sent."
msgstr ""
"Envía un *file* a través de un *transport*. Retorna el numero total de bytes "
"enviados."

#: ../Doc/library/asyncio-eventloop.rst:751
msgid "The method uses high-performance :meth:`os.sendfile` if available."
msgstr ""
"El método usa :meth:`os.sendfile` de alto rendimiento si está disponible."

#: ../Doc/library/asyncio-eventloop.rst:753
msgid "*file* must be a regular file object opened in binary mode."
msgstr "*file* debe ser un objeto de archivo regular abierto en modo binario."

#: ../Doc/library/asyncio-eventloop.rst:755
#: ../Doc/library/asyncio-eventloop.rst:945
msgid ""
"*offset* tells from where to start reading the file. If specified, *count* "
"is the total number of bytes to transmit as opposed to sending the file "
"until EOF is reached. File position is always updated, even when this method "
"raises an error, and :meth:`file.tell() <io.IOBase.tell>` can be used to "
"obtain the actual number of bytes sent."
msgstr ""
"*offset* indica desde donde se empezará a leer el archivo. Si es "
"especificado, *count* es el número total de bytes a transmitir en "
"contraposición con enviar el archivo hasta que se alcance EOF. La posición "
"del archivo es actualizada siempre, incluso cuando este método genere un "
"error, y :meth:`file.tell() <io.IOBase.tell>` puede ser usado para obtener "
"el número de bytes enviados hasta el momento."

#: ../Doc/library/asyncio-eventloop.rst:762
msgid ""
"*fallback* set to ``True`` makes asyncio to manually read and send the file "
"when the platform does not support the sendfile system call (e.g. Windows or "
"SSL socket on Unix)."
msgstr ""
"*fallback* establecido como ``True`` hace que asyncio lea y envíe el archivo "
"manualmente cuando la plataforma no soporta la llamada de envío de archivos "
"del sistema (por ejemplo, Windows o sockets SSL en Unix)."

#: ../Doc/library/asyncio-eventloop.rst:766
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support the "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"Lanza :exc:`SendfileNotAvailableError` si el sistema no soporta la llamada "
"de envío de archivos del sistema y *fallback* es ``True``."

#: ../Doc/library/asyncio-eventloop.rst:773
msgid "TLS Upgrade"
msgstr "Actualización de TLS"

#: ../Doc/library/asyncio-eventloop.rst:779
msgid "Upgrade an existing transport-based connection to TLS."
msgstr "Actualiza una conexión basada en transporte ya existente a TLS."

#: ../Doc/library/asyncio-eventloop.rst:781
msgid ""
"Return a new transport instance, that the *protocol* must start using "
"immediately after the *await*.  The *transport* instance passed to the "
"*start_tls* method should never be used again."
msgstr ""
"Retorna una nueva instancia de transporte, que el *protocol* debe empezar a "
"usar inmediatamente después del *await*. La instancia *transport* pasada al "
"método *start_tls* nunca debe ser usada de nuevo."

#: ../Doc/library/asyncio-eventloop.rst:787
msgid ""
"*transport* and *protocol* instances that methods like :meth:`~loop."
"create_server` and :meth:`~loop.create_connection` return."
msgstr ""
"Las instancias *transport* y *protocol* que retornan los métodos como :meth:"
"`~loop.create_server` y :meth:`~loop.create_connection`."

#: ../Doc/library/asyncio-eventloop.rst:791
msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr "*sslcontext*: una instancia configurada de :class:`~ssl.SSLContext`."

#: ../Doc/library/asyncio-eventloop.rst:793
msgid ""
"*server_side* pass ``True`` when a server-side connection is being upgraded "
"(like the one created by :meth:`~loop.create_server`)."
msgstr ""
"*server_side* pasa `True` cuando se actualiza una conexión del lado del "
"servidor (como en el caso de una creada por :meth:`~loop.create_server`)."

#: ../Doc/library/asyncio-eventloop.rst:796
msgid ""
"*server_hostname*: sets or overrides the host name that the target server's "
"certificate will be matched against."
msgstr ""
"*server_hostname*: establece o reemplaza el nombre del host contra el cual "
"se compara el certificado del servidor de destino."

#: ../Doc/library/asyncio-eventloop.rst:807
msgid "Watching file descriptors"
msgstr "Viendo descriptores de archivos"

#: ../Doc/library/asyncio-eventloop.rst:811
msgid ""
"Start monitoring the *fd* file descriptor for read availability and invoke "
"*callback* with the specified arguments once *fd* is available for reading."
msgstr ""
"Empieza a monitorear el descriptor de archivos *fd* para disponibilidad de "
"lectura e invoca *callback* con los argumentos especificados una vez que "
"*fd* está habilitado para ser leído."

#: ../Doc/library/asyncio-eventloop.rst:817
msgid "Stop monitoring the *fd* file descriptor for read availability."
msgstr ""
"Deja de monitorear el descriptor de archivos *fd* para disponibilidad de "
"lectura."

#: ../Doc/library/asyncio-eventloop.rst:821
msgid ""
"Start monitoring the *fd* file descriptor for write availability and invoke "
"*callback* with the specified arguments once *fd* is available for writing."
msgstr ""
"Empieza a monitorear el descriptor de archivos *fd* para disponibilidad de "
"escritura e invoca *callback* con los argumentos especificados una vez que "
"*fd* está habilitado para ser escrito."

#: ../Doc/library/asyncio-eventloop.rst:825
#: ../Doc/library/asyncio-eventloop.rst:1044
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *callback*."
msgstr ""
"Use :func:`functools.partial` :ref:`para pasar argumentos de palabra clave "
"<asyncio-pass-keywords>` a *callback*."

#: ../Doc/library/asyncio-eventloop.rst:830
msgid "Stop monitoring the *fd* file descriptor for write availability."
msgstr ""
"Deja de monitorear el descriptor de archivos *fd* para disponibilidad de "
"escritura."

#: ../Doc/library/asyncio-eventloop.rst:832
msgid ""
"See also :ref:`Platform Support <asyncio-platform-support>` section for some "
"limitations of these methods."
msgstr ""
"Vea también la sección :ref:`Soporte de plataforma <asyncio-platform-"
"support>` para algunas limitaciones de estos métodos."

#: ../Doc/library/asyncio-eventloop.rst:837
msgid "Working with socket objects directly"
msgstr "Trabajar con objetos sockets directamente"

#: ../Doc/library/asyncio-eventloop.rst:839
msgid ""
"In general, protocol implementations that use transport-based APIs such as :"
"meth:`loop.create_connection` and :meth:`loop.create_server` are faster than "
"implementations that work with sockets directly. However, there are some use "
"cases when performance is not critical, and working with :class:`~socket."
"socket` objects directly is more convenient."
msgstr ""
"En general, implementaciones de protocolo que usen APIs basadas en "
"transporte como :meth:`loop.create_connection` y :meth:`loop.create_server` "
"son mas rápidas que aquellas implementaciones que trabajan con directamente "
"con sockets. De cualquier forma, hay algunos casos de uso en los cuales el "
"rendimiento no es crítico, y trabajar directamente con objetos :class:"
"`~socket.socket` es mas conveniente."

#: ../Doc/library/asyncio-eventloop.rst:848
msgid ""
"Receive up to *nbytes* from *sock*.  Asynchronous version of :meth:`socket."
"recv() <socket.socket.recv>`."
msgstr ""
"Recibe hasta *nbytes* de *sock*. Versión asíncrona de :meth:`socket.recv() "
"<socket.socket.recv>`."

#: ../Doc/library/asyncio-eventloop.rst:851
msgid "Return the received data as a bytes object."
msgstr "Retorna los datos recibidos como un objeto bytes."

#: ../Doc/library/asyncio-eventloop.rst:853
#: ../Doc/library/asyncio-eventloop.rst:867
#: ../Doc/library/asyncio-eventloop.rst:882
#: ../Doc/library/asyncio-eventloop.rst:895
#: ../Doc/library/asyncio-eventloop.rst:921
#: ../Doc/library/asyncio-eventloop.rst:959
msgid "*sock* must be a non-blocking socket."
msgstr "*sock* debe ser un socket no bloqueante."

#: ../Doc/library/asyncio-eventloop.rst:855
msgid ""
"Even though this method was always documented as a coroutine method, "
"releases before Python 3.7 returned a :class:`Future`. Since Python 3.7 this "
"is an ``async def`` method."
msgstr ""
"A pesar de que este método siempre fue documentado como un método de "
"corrutina, los lanzamientos previos a Python 3.7 retornaban un :class:"
"`Future`. Desde Python 3.7 este es un método ``async def``."

#: ../Doc/library/asyncio-eventloop.rst:862
msgid ""
"Receive data from *sock* into the *buf* buffer.  Modeled after the blocking :"
"meth:`socket.recv_into() <socket.socket.recv_into>` method."
msgstr ""
"Recibe datos desde *sock* en el búfer *buf*. Modelado después del método "
"bloqueante :meth:`socket.recv_into() <socket.socket.recv_into>`."

#: ../Doc/library/asyncio-eventloop.rst:865
msgid "Return the number of bytes written to the buffer."
msgstr "Retorna el número de bytes escritos en el búfer."

#: ../Doc/library/asyncio-eventloop.rst:873
msgid ""
"Send *data* to the *sock* socket. Asynchronous version of :meth:`socket."
"sendall() <socket.socket.sendall>`."
msgstr ""
"Envía *data* al socket *sock*. Versión asíncrona de :meth:`socket.sendall() "
"<socket.socket.sendall>`."

#: ../Doc/library/asyncio-eventloop.rst:876
msgid ""
"This method continues to send to the socket until either all data in *data* "
"has been sent or an error occurs.  ``None`` is returned on success.  On "
"error, an exception is raised. Additionally, there is no way to determine "
"how much data, if any, was successfully processed by the receiving end of "
"the connection."
msgstr ""
"Este método continua enviando al socket hasta que se hayan enviado todos los "
"datos en *data* u ocurra un error. ``None`` es retornado cuando se tiene "
"éxito. Cuando ocurre un error, se lanza una excepción. Adicionalmente, no "
"hay manera de determinar cuantos datos, si es que se hubo alguno, se "
"procesaron correctamente por el extremo receptor de la conexión."

#: ../Doc/library/asyncio-eventloop.rst:884
msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned an :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""
"A pesar de que este método siempre fue documentado como un método de "
"corrutina, antes de Python 3.7 retorna un :class:`Future`. Desde Python 3.7, "
"este es un método ``async def``."

#: ../Doc/library/asyncio-eventloop.rst:891
msgid "Connect *sock* to a remote socket at *address*."
msgstr "Conecta *sock* a un socket remoto en *address*."

#: ../Doc/library/asyncio-eventloop.rst:893
msgid ""
"Asynchronous version of :meth:`socket.connect() <socket.socket.connect>`."
msgstr "Versión asíncrona de :meth:`socket.connect() <socket.socket.connect>`."

#: ../Doc/library/asyncio-eventloop.rst:897
msgid ""
"``address`` no longer needs to be resolved.  ``sock_connect`` will try to "
"check if the *address* is already resolved by calling :func:`socket."
"inet_pton`.  If not, :meth:`loop.getaddrinfo` will be used to resolve the "
"*address*."
msgstr ""
"``address`` ya no necesita ser resuelto. ``sock_connect`` va a intentar "
"verificar si *address* ya fue resuelto a partir del llamado de :func:`socket."
"inet_pton`. Si no lo fue, se utilizará :meth:`loop.getaddrinfo` ara resolver "
"*address*."

#: ../Doc/library/asyncio-eventloop.rst:906
msgid ""
":meth:`loop.create_connection` and  :func:`asyncio.open_connection() "
"<open_connection>`."
msgstr ""
":meth:`loop.create_connection` y :func:`asyncio.open_connection() "
"<open_connection>`."

#: ../Doc/library/asyncio-eventloop.rst:912
msgid ""
"Accept a connection.  Modeled after the blocking :meth:`socket.accept() "
"<socket.socket.accept>` method."
msgstr ""
"Acepta una conexión. Modelado después del método bloqueante :meth:`socket."
"accept() <socket.socket.accept>`."

#: ../Doc/library/asyncio-eventloop.rst:915
msgid ""
"The socket must be bound to an address and listening for connections. The "
"return value is a pair ``(conn, address)`` where *conn* is a *new* socket "
"object usable to send and receive data on the connection, and *address* is "
"the address bound to the socket on the other end of the connection."
msgstr ""
"El socket debe estar vinculado a una conexión y escuchando conexiones. El "
"valor retornado es un par ``(conn, address)`` donde *conn* es un objeto "
"socket *nuevo* que puede ser usado para enviar y recibir datos en la "
"conexión, y *address*\n"
" es la dirección enlazada al socket en el otro extremo de la conexión."

#: ../Doc/library/asyncio-eventloop.rst:923
msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned a :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""
"A pesar de que este método siempre fue documentado como un método de "
"corrutina, antes de Python 3.7 retorna un :class:`Future`. Desde Python 3.7, "
"este es un método ``async def``."

#: ../Doc/library/asyncio-eventloop.rst:930
msgid ":meth:`loop.create_server` and :func:`start_server`."
msgstr ":meth:`loop.create_server` y :func:`start_server`."

#: ../Doc/library/asyncio-eventloop.rst:935
msgid ""
"Send a file using high-performance :mod:`os.sendfile` if possible. Return "
"the total number of bytes sent."
msgstr ""
"Envía un archivo usando :mod:`os.sendfile` de alto rendimiento si es "
"posible. Retorna el número total de bytes enviados."

#: ../Doc/library/asyncio-eventloop.rst:938
msgid ""
"Asynchronous version of :meth:`socket.sendfile() <socket.socket.sendfile>`."
msgstr ""
"Versión asíncrona de :meth:`socket.sendfile() <socket.socket.sendfile>`."

#: ../Doc/library/asyncio-eventloop.rst:940
msgid ""
"*sock* must be a non-blocking :const:`socket.SOCK_STREAM` :class:`~socket."
"socket`."
msgstr ""
"*sock* debe ser un :const:`socket.SOCK_STREAM` :class:`~socket.socket` no "
"bloqueante."

#: ../Doc/library/asyncio-eventloop.rst:943
msgid "*file* must be a regular file object open in binary mode."
msgstr "*file* debe ser un objeto de archivo regular abierto en modo binario."

#: ../Doc/library/asyncio-eventloop.rst:952
msgid ""
"*fallback*, when set to ``True``, makes asyncio manually read and send the "
"file when the platform does not support the sendfile syscall (e.g. Windows "
"or SSL socket on Unix)."
msgstr ""
"*fallback*, cuando es establecida como ``True``, hace que asyncio lea y "
"escriba el archivo manualmente cuando el sistema no soporta la llamada de "
"envío de archivos del sistema (por ejemplo, Windows o sockets SSL en Unix)."

#: ../Doc/library/asyncio-eventloop.rst:956
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"Lanza :exc:`SendfileNotAvailableError` si el sistema no soporta la llamada "
"de envío de archivos del sistema *sendfile* y *fallback* es ``False``."

#: ../Doc/library/asyncio-eventloop.rst:965
msgid "DNS"
msgstr "DNS"

#: ../Doc/library/asyncio-eventloop.rst:970
msgid "Asynchronous version of :meth:`socket.getaddrinfo`."
msgstr "Versión asíncrona de :meth:`socket.getaddrinfo`."

#: ../Doc/library/asyncio-eventloop.rst:974
msgid "Asynchronous version of :meth:`socket.getnameinfo`."
msgstr "Asynchronous version of :meth:`socket.getnameinfo`."

#: ../Doc/library/asyncio-eventloop.rst:976
msgid ""
"Both *getaddrinfo* and *getnameinfo* methods were always documented to "
"return a coroutine, but prior to Python 3.7 they were, in fact, returning :"
"class:`asyncio.Future` objects.  Starting with Python 3.7 both methods are "
"coroutines."
msgstr ""
"Ambos métodos *getaddrinfo* y *getnameinfo* siempre fueron documentados para "
"retornar una corrutina, pero antes de Python 3.7 retornaban, de hecho, "
"objetos :class:`Future`. A partir de Python 3.7, ambos métodos son "
"corrutinas."

#: ../Doc/library/asyncio-eventloop.rst:984
msgid "Working with pipes"
msgstr "Trabajando con tuberías"

#: ../Doc/library/asyncio-eventloop.rst:988
msgid "Register the read end of *pipe* in the event loop."
msgstr "Registra el fin de lectura de *pipe* en el bucle de eventos."

#: ../Doc/library/asyncio-eventloop.rst:993
msgid "*pipe* is a :term:`file-like object <file object>`."
msgstr "*pipe* es un :term:`objeto de tipo archivo <file object>`."

#: ../Doc/library/asyncio-eventloop.rst:995
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports the :class:"
"`ReadTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""
"Retorna un par ``(transport, protocol)``, donde *transport*  soporta la "
"interface :class:`ReadTransport` y *protocol* es un objeto instanciado por "
"*protocol_factory*."

#: ../Doc/library/asyncio-eventloop.rst:999
#: ../Doc/library/asyncio-eventloop.rst:1015
msgid ""
"With :class:`SelectorEventLoop` event loop, the *pipe* is set to non-"
"blocking mode."
msgstr ""
"Con el bucle de eventos :class:`SelectorEventLoop`, el *pipe* es establecido "
"en modo no bloqueante."

#: ../Doc/library/asyncio-eventloop.rst:1004
msgid "Register the write end of *pipe* in the event loop."
msgstr "Registra el fin de escritura de *pipe* en el bucle de eventos."

#: ../Doc/library/asyncio-eventloop.rst:1009
msgid "*pipe* is :term:`file-like object <file object>`."
msgstr "*pipe* es un :term:`objeto de tipo archivo <file object>`."

#: ../Doc/library/asyncio-eventloop.rst:1011
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports :class:"
"`WriteTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""
"Retorna un par ``(transport, protocol)``, donde *transport* soporta la "
"interface :class:`WriteTransport` y *protocol* es un objeto inicializado por "
"*protocol_factory*."

#: ../Doc/library/asyncio-eventloop.rst:1020
msgid ""
":class:`SelectorEventLoop` does not support the above methods on Windows.  "
"Use :class:`ProactorEventLoop` instead for Windows."
msgstr ""
":class:`SelectorEventLoop` no soporta los métodos anteriores en windows. En "
"su lugar, use :class:`ProactorEventLoop` para Windows."

#: ../Doc/library/asyncio-eventloop.rst:1025
msgid ""
"The :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` methods."
msgstr ""
"Los métodos :meth:`loop.subprocess_exec` y :meth:`loop.subprocess_shell`."

#: ../Doc/library/asyncio-eventloop.rst:1030
msgid "Unix signals"
msgstr "Señales Unix"

#: ../Doc/library/asyncio-eventloop.rst:1034
msgid "Set *callback* as the handler for the *signum* signal."
msgstr "Establece *callback* como el gestor para la señal *signum*."

#: ../Doc/library/asyncio-eventloop.rst:1036
msgid ""
"The callback will be invoked by *loop*, along with other queued callbacks "
"and runnable coroutines of that event loop. Unlike signal handlers "
"registered using :func:`signal.signal`, a callback registered with this "
"function is allowed to interact with the event loop."
msgstr ""
"La llamada será invocada por *loop*, junto con otras llamadas encoladas y "
"corrutinas ejecutables de ese bucle de eventos. A menos que los gestores de "
"señal la registren usando :func:`signal.signal`, una llamada registrada con "
"esta función tiene permitido interactuar con el bucle de eventos."

#: ../Doc/library/asyncio-eventloop.rst:1041
msgid ""
"Raise :exc:`ValueError` if the signal number is invalid or uncatchable. "
"Raise :exc:`RuntimeError` if there is a problem setting up the handler."
msgstr ""
"Lanza :exc:`ValueError` si el número de señal es invalido o inalcanzable. "
"Lanza :exc:`RuntimeError` si hay algún problema preparando el gestor."

#: ../Doc/library/asyncio-eventloop.rst:1047
msgid ""
"Like :func:`signal.signal`, this function must be invoked in the main thread."
msgstr ""
"Como :func:`signal.signal`, esta función debe ser invocada en el hilo "
"principal."

#: ../Doc/library/asyncio-eventloop.rst:1052
msgid "Remove the handler for the *sig* signal."
msgstr "Elimina el gestor para la señal *sig*."

#: ../Doc/library/asyncio-eventloop.rst:1054
msgid ""
"Return ``True`` if the signal handler was removed, or ``False`` if no "
"handler was set for the given signal."
msgstr ""
"Retorna ``True`` si el gestor de señal fue eliminado, o ``False`` si no se "
"estableció gestor para la señal dada."

#: ../Doc/library/asyncio-eventloop.rst:1061
msgid "The :mod:`signal` module."
msgstr "El módulo :mod:`signal`."

#: ../Doc/library/asyncio-eventloop.rst:1065
msgid "Executing code in thread or process pools"
msgstr "Ejecutando código en un hilos o grupos de procesos"

#: ../Doc/library/asyncio-eventloop.rst:1069
#, fuzzy
msgid "Arrange for *func* to be called in the specified executor."
msgstr "Arregla que *func* sea llamada en el ejecutor especificado."

#: ../Doc/library/asyncio-eventloop.rst:1071
msgid ""
"The *executor* argument should be an :class:`concurrent.futures.Executor` "
"instance. The default executor is used if *executor* is ``None``."
msgstr ""
"El argumento *executor* debe ser una instancia de :class:`concurrent.futures."
"Executor`. El ejecutor predeterminado es usado si *executor* es ``None``."

#: ../Doc/library/asyncio-eventloop.rst:1115
msgid "This method returns a :class:`asyncio.Future` object."
msgstr "Este método retorna un objeto :class:`asyncio.Future`."

#: ../Doc/library/asyncio-eventloop.rst:1117
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *func*."
msgstr ""
"Use :func:`functools.partial` :ref:`para pasar argumentos de palabra clave "
"<asyncio-pass-keywords>` a *func*."

#: ../Doc/library/asyncio-eventloop.rst:1120
#, fuzzy
msgid ""
":meth:`loop.run_in_executor` no longer configures the ``max_workers`` of the "
"thread pool executor it creates, instead leaving it up to the thread pool "
"executor (:class:`~concurrent.futures.ThreadPoolExecutor`) to set the "
"default."
msgstr ""
":meth:`loop.run_in_executor` ya no configura el ``max_workers`` del ejecutor "
"del grupo de subprocesos que crea, sino que lo deja al ejecutor del grupo de "
"subprocesos (:class:`~concurrent.futures.ThreadPoolExecutor`) para "
"configurar al predeterminado."

#: ../Doc/library/asyncio-eventloop.rst:1129
msgid ""
"Set *executor* as the default executor used by :meth:`run_in_executor`. "
"*executor* should be an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor`."
msgstr ""
"Establece *executor* como el ejecutor predeterminado utilizado por :meth:"
"`run_in_executor`. *executor* debe ser una instancia de :class:`~concurrent."
"futures.ThreadPoolExecutor`."

#: ../Doc/library/asyncio-eventloop.rst:1133
msgid ""
"Using an executor that is not an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor` is deprecated and will trigger an error in Python 3.9."
msgstr ""
"Usar un ejecutor que no es una instancia de :class:`~concurrent.futures."
"ThreadPoolExecutor` es obsoleto y disparará un error en Python 3.9."

#: ../Doc/library/asyncio-eventloop.rst:1138
msgid ""
"*executor* must be an instance of :class:`concurrent.futures."
"ThreadPoolExecutor`."
msgstr ""
"*executor* debe ser una instancia de :class:`concurrent.futures."
"ThreadPoolExecutor`."

#: ../Doc/library/asyncio-eventloop.rst:1143
msgid "Error Handling API"
msgstr "API para manejo de errores"

#: ../Doc/library/asyncio-eventloop.rst:1145
msgid "Allows customizing how exceptions are handled in the event loop."
msgstr ""
"Permite personalizar como son manejadas las excepciones en el bucle de "
"eventos."

#: ../Doc/library/asyncio-eventloop.rst:1149
msgid "Set *handler* as the new event loop exception handler."
msgstr ""
"Establece *handler* como el nuevo gestor de excepciones del bucle de eventos."

#: ../Doc/library/asyncio-eventloop.rst:1151
msgid ""
"If *handler* is ``None``, the default exception handler will be set.  "
"Otherwise, *handler* must be a callable with the signature matching ``(loop, "
"context)``, where ``loop`` is a reference to the active event loop, and "
"``context`` is a ``dict`` object containing the details of the exception "
"(see :meth:`call_exception_handler` documentation for details about context)."
msgstr ""
"Si *handler* es ``None``, se establecerá el gestor de excepciones "
"predeterminado. De otro modo, *handler* debe ser un invocable con la misma "
"firma ``(loop, context)``, donde ``loop`` es una referencia al bucle de "
"eventos activo, y ``context`` es un objeto ``dict`` que contiene los "
"detalles de la excepción (vea la documentación de :meth:"
"`call_exception_handler` para detalles acerca del contexto)."

#: ../Doc/library/asyncio-eventloop.rst:1161
msgid ""
"Return the current exception handler, or ``None`` if no custom exception "
"handler was set."
msgstr ""
"Retorna el gesto de excepciones actual, o ``None`` si no fue establecido "
"ningún gestor de excepciones personalizado."

#: ../Doc/library/asyncio-eventloop.rst:1168
msgid "Default exception handler."
msgstr "Gestor de excepciones por defecto."

#: ../Doc/library/asyncio-eventloop.rst:1170
msgid ""
"This is called when an exception occurs and no exception handler is set. "
"This can be called by a custom exception handler that wants to defer to the "
"default handler behavior."
msgstr ""
"Esto es llamado cuando ocurre una excepción y no se estableció ningún gestor "
"de excepciones. Esto puede ser llamado por un gestor de excepciones "
"personalizado que quiera cambiar el comportamiento del gestor predeterminado."

#: ../Doc/library/asyncio-eventloop.rst:1174
msgid ""
"*context* parameter has the same meaning as in :meth:"
"`call_exception_handler`."
msgstr ""
"El parámetro *context* tiene el mismo significado que en :meth:"
"`call_exception_handler`."

#: ../Doc/library/asyncio-eventloop.rst:1179
msgid "Call the current event loop exception handler."
msgstr "Llama al gestor de excepciones del bucle de eventos actual."

#: ../Doc/library/asyncio-eventloop.rst:1181
msgid ""
"*context* is a ``dict`` object containing the following keys (new keys may "
"be introduced in future Python versions):"
msgstr ""
"*context* es un objeto ``dict`` conteniendo las siguientes claves (en "
"futuras versiones de Python podrían introducirse nuevas claves):"

#: ../Doc/library/asyncio-eventloop.rst:1184
msgid "'message': Error message;"
msgstr "'message': Mensaje de error;"

#: ../Doc/library/asyncio-eventloop.rst:1185
msgid "'exception' (optional): Exception object;"
msgstr "'exception' (opcional): Objeto de excepción;"

#: ../Doc/library/asyncio-eventloop.rst:1186
msgid "'future' (optional): :class:`asyncio.Future` instance;"
msgstr "'future' (opcional): instancia de :class:`asyncio.Future`;"

#: ../Doc/library/asyncio-eventloop.rst:1187
msgid "'handle' (optional): :class:`asyncio.Handle` instance;"
msgstr "'handle' (opcional): instancia de :class:`asyncio.Handle`;"

#: ../Doc/library/asyncio-eventloop.rst:1188
msgid "'protocol' (optional): :ref:`Protocol <asyncio-protocol>` instance;"
msgstr ""
"'protocol' (opcional): instancia de :ref:`Protocol <asyncio-protocol>`;"

#: ../Doc/library/asyncio-eventloop.rst:1189
msgid "'transport' (optional): :ref:`Transport <asyncio-transport>` instance;"
msgstr ""
"'transport' (opcional): instancia de :ref:`Transport <asyncio-transport>`;"

#: ../Doc/library/asyncio-eventloop.rst:1190
msgid "'socket' (optional): :class:`socket.socket` instance."
msgstr "'socket' (opcional): instancia de :class:`socket.socket`."

#: ../Doc/library/asyncio-eventloop.rst:1194
msgid ""
"This method should not be overloaded in subclassed event loops.  For custom "
"exception handling, use the :meth:`set_exception_handler()` method."
msgstr ""
"Este método no debe ser sobrecargado en bucles de eventos en subclase. Para "
"gestión de excepciones personalizadas, use el método :meth:"
"`set_exception_handler()`."

#: ../Doc/library/asyncio-eventloop.rst:1199
msgid "Enabling debug mode"
msgstr "Habilitando el modo depuración"

#: ../Doc/library/asyncio-eventloop.rst:1203
msgid "Get the debug mode (:class:`bool`) of the event loop."
msgstr "Obtiene el modo depuración (:class:`bool`) del bucle de eventos."

#: ../Doc/library/asyncio-eventloop.rst:1205
msgid ""
"The default value is ``True`` if the environment variable :envvar:"
"`PYTHONASYNCIODEBUG` is set to a non-empty string, ``False`` otherwise."
msgstr ""
"El valor predeterminado es ``True`` si la variable de entorno :envvar:"
"`PYTHONASYNCIODEBUG` es establecida a una cadena no vacía, de otro modo será "
"``False``."

#: ../Doc/library/asyncio-eventloop.rst:1211
msgid "Set the debug mode of the event loop."
msgstr "Establece el modo de depuración del bucle de eventos."

#: ../Doc/library/asyncio-eventloop.rst:1215
#, fuzzy
msgid ""
"The new :ref:`Python Development Mode <devmode>` can now also be used to "
"enable the debug mode."
msgstr ""
"La nueva opción de linea de comandos ``-X dev`` ahora también puede ser "
"utilizada para habilitar el modo depuración."

#: ../Doc/library/asyncio-eventloop.rst:1220
msgid "The :ref:`debug mode of asyncio <asyncio-debug-mode>`."
msgstr "El :ref:`modo depuración de asyncio <asyncio-debug-mode>`."

#: ../Doc/library/asyncio-eventloop.rst:1224
msgid "Running Subprocesses"
msgstr "Ejecutando Subprocesos"

#: ../Doc/library/asyncio-eventloop.rst:1226
msgid ""
"Methods described in this subsections are low-level.  In regular async/await "
"code consider using the high-level :func:`asyncio.create_subprocess_shell` "
"and :func:`asyncio.create_subprocess_exec` convenience functions instead."
msgstr ""
"Los métodos descritos en esta subsección son de bajo nivel. En código async/"
"await regular considere usar las convenientes funciones de alto nivel :func:"
"`asyncio.create_subprocess_shell` y :func:`asyncio.create_subprocess_exec`."

#: ../Doc/library/asyncio-eventloop.rst:1233
msgid ""
"The default asyncio event loop on **Windows** does not support subprocesses. "
"See :ref:`Subprocess Support on Windows <asyncio-windows-subprocess>` for "
"details."
msgstr ""
"El bucle de eventos predeterminado de asyncio en **Windows** no soporta "
"subprocesos. Vea :ref:`Soporte de subprocesos en Windows <asyncio-windows-"
"subprocess>` para mas detalles."

#: ../Doc/library/asyncio-eventloop.rst:1241
msgid ""
"Create a subprocess from one or more string arguments specified by *args*."
msgstr ""
"Crea un subproceso de uno o mas argumentos de cadena especificados por "
"*args*."

#: ../Doc/library/asyncio-eventloop.rst:1244
msgid "*args* must be a list of strings represented by:"
msgstr "*args* debe ser una lista de cadenas representadas por:"

#: ../Doc/library/asyncio-eventloop.rst:1246
msgid ":class:`str`;"
msgstr ":class:`str`;"

#: ../Doc/library/asyncio-eventloop.rst:1247
msgid ""
"or :class:`bytes`, encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`."
msgstr ""
"o :class:`bytes`, codificados a la :ref:`codificación del sistema de "
"archivos <filesystem-encoding>`."

#: ../Doc/library/asyncio-eventloop.rst:1250
msgid ""
"The first string specifies the program executable, and the remaining strings "
"specify the arguments.  Together, string arguments form the ``argv`` of the "
"program."
msgstr ""
"La primer cadena especifica el programa ejecutable, y las cadenas restantes "
"especifican los argumentos. En conjunto, los argumentos de cadena forman el "
"``argv`` del programa."

#: ../Doc/library/asyncio-eventloop.rst:1254
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=False`` and the list of strings passed as the first "
"argument; however, where :class:`~subprocess.Popen` takes a single argument "
"which is list of strings, *subprocess_exec* takes multiple string arguments."
msgstr ""
"Esto es similar a la clase de la librería estándar :class:`subprocess.Popen` "
"llamada con ``shell=False`` y la lista de cadenas pasadas como el primer "
"argumento; de cualquier forma, cuando :class:`~subprocess.Popen` toma un "
"sólo argumento que es una lista de cadenas, *subprocess_exec* toma múltiples "
"cadenas como argumentos."

#: ../Doc/library/asyncio-eventloop.rst:1260
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`asyncio.SubprocessProtocol` class."
msgstr ""
"El *protocol_factory* debe ser un ejecutable que retorne una subclase de la "
"clase :class:`asyncio.SubprocessProtocol`."

#: ../Doc/library/asyncio-eventloop.rst:1263
msgid "Other parameters:"
msgstr "Otros parámetros:"

#: ../Doc/library/asyncio-eventloop.rst:1265
msgid "*stdin* can be any of these:"
msgstr "*stdin* puede ser cualquier de estos:"

#: ../Doc/library/asyncio-eventloop.rst:1267
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard input stream using :meth:`~loop.connect_write_pipe`"
msgstr ""
"un objeto de tipo archivo representando una tubería que será conectada al "
"flujo de entrada estándar del subproceso utilizando :meth:`~loop."
"connect_write_pipe`"

#: ../Doc/library/asyncio-eventloop.rst:1270
#: ../Doc/library/asyncio-eventloop.rst:1282
#: ../Doc/library/asyncio-eventloop.rst:1294
msgid ""
"the :const:`subprocess.PIPE` constant (default) which will create a new pipe "
"and connect it,"
msgstr ""
"la constante :const:`subprocess.PIPE` (predeterminado) que creará una "
"tubería nueva y la conectará,"

#: ../Doc/library/asyncio-eventloop.rst:1272
#: ../Doc/library/asyncio-eventloop.rst:1284
#: ../Doc/library/asyncio-eventloop.rst:1296
msgid ""
"the value ``None`` which will make the subprocess inherit the file "
"descriptor from this process"
msgstr ""
"el valor ``None`` que hará que el subproceso herede el descriptor de archivo "
"de este proceso"

#: ../Doc/library/asyncio-eventloop.rst:1274
#: ../Doc/library/asyncio-eventloop.rst:1286
#: ../Doc/library/asyncio-eventloop.rst:1298
msgid ""
"the :const:`subprocess.DEVNULL` constant which indicates that the special :"
"data:`os.devnull` file will be used"
msgstr ""
"la constante :const:`subprocess.DEVNULL` que indica que el archivo especial :"
"data:`os.devnull` será utilizado"

#: ../Doc/library/asyncio-eventloop.rst:1277
msgid "*stdout* can be any of these:"
msgstr "*stdout* puede ser cualquier de estos:"

#: ../Doc/library/asyncio-eventloop.rst:1279
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard output stream using :meth:`~loop.connect_write_pipe`"
msgstr ""
"un objeto de tipo archivo representando una tubería que será conectada al "
"flujo de salida estándar del subproceso utilizando :meth:`~loop."
"connect_write_pipe`"

#: ../Doc/library/asyncio-eventloop.rst:1289
msgid "*stderr* can be any of these:"
msgstr "*stderr* puede ser cualquier de estos:"

#: ../Doc/library/asyncio-eventloop.rst:1291
msgid ""
"a file-like object representing a pipe to be connected to the subprocess's "
"standard error stream using :meth:`~loop.connect_write_pipe`"
msgstr ""
"un objeto de tipo archivo representando una tubería que será conectada al "
"flujo de error estándar del subproceso utilizando :meth:`~loop."
"connect_write_pipe`"

#: ../Doc/library/asyncio-eventloop.rst:1300
msgid ""
"the :const:`subprocess.STDOUT` constant which will connect the standard "
"error stream to the process' standard output stream"
msgstr ""
"la constante :const:`subprocess.STDOUT` que conectará el flujo de errores "
"predeterminado al flujo de salida predeterminado del proceso"

#: ../Doc/library/asyncio-eventloop.rst:1303
msgid ""
"All other keyword arguments are passed to :class:`subprocess.Popen` without "
"interpretation, except for *bufsize*, *universal_newlines*, *shell*, *text*, "
"*encoding* and *errors*, which should not be specified at all."
msgstr ""
"El resto de argumentos de palabra clave son pasados a :class:`subprocess."
"Popen` sin interpretación, excepto por *bufsize*, *universal_newlines*, "
"*shell*, *text*, *encoding* y *errors*, que no deben ser especificados en lo "
"absoluto."

#: ../Doc/library/asyncio-eventloop.rst:1308
msgid ""
"The ``asyncio`` subprocess API does not support decoding the streams as "
"text. :func:`bytes.decode` can be used to convert the bytes returned from "
"the stream to text."
msgstr ""
"La API subproceso ``asyncio`` no soporta decodificar los flujos como texto. :"
"func:`bytes.decode` puede ser usado para convertir a texto los bytes "
"retornados por el flujo."

#: ../Doc/library/asyncio-eventloop.rst:1312
msgid ""
"See the constructor of the :class:`subprocess.Popen` class for documentation "
"on other arguments."
msgstr ""
"Vea el constructor de la clase :class:`subprocess.Popen` para documentación "
"acerca de otros argumentos."

#: ../Doc/library/asyncio-eventloop.rst:1315
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`asyncio.SubprocessTransport` base class and *protocol* is an "
"object instantiated by the *protocol_factory*."
msgstr ""
"Retorna un par de ``(transport, protocol)``, donde *transport* se ajusta a "
"la clase base :class:`asyncio.SubprocessTransport` y *protocol* es un objeto "
"instanciado por *protocol_factory*."

#: ../Doc/library/asyncio-eventloop.rst:1323
msgid ""
"Create a subprocess from *cmd*, which can be a :class:`str` or a :class:"
"`bytes` string encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`, using the platform's \"shell\" syntax."
msgstr ""
"Crea un subproceso desde *cmd*, que puede ser una cadena :class:`str` o :"
"class:`bytes` codificado a la :ref:`codificación del sistema de archivos "
"<filesystem-encoding>`, usando la sintaxis \"shell\" de la plataforma."

#: ../Doc/library/asyncio-eventloop.rst:1328
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=True``."
msgstr ""
"Esto es similar a la clase de la librería estándar :class:`subprocess.Popen` "
"llamada con ``shell=True``."

#: ../Doc/library/asyncio-eventloop.rst:1331
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`SubprocessProtocol` class."
msgstr ""
"El *protocol_factory* debe ser un ejecutable que retorne una subclase de la "
"clase :class:`asyncio.SubprocessProtocol`."

#: ../Doc/library/asyncio-eventloop.rst:1334
msgid ""
"See :meth:`~loop.subprocess_exec` for more details about the remaining "
"arguments."
msgstr ""
"Vea :meth:`~loop.subprocess_exec` para mas detalles acerca de los argumentos "
"restantes."

#: ../Doc/library/asyncio-eventloop.rst:1337
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`SubprocessTransport` base class and *protocol* is an object "
"instantiated by the *protocol_factory*."
msgstr ""
"Retorna un par de ``(transport, protocol)``, donde *transport* se ajusta a "
"la clase base :class:`SubprocessTransport` y *protocol* es un objeto "
"instanciado por *protocol_factory*."

#: ../Doc/library/asyncio-eventloop.rst:1342
msgid ""
"It is the application's responsibility to ensure that all whitespace and "
"special characters are quoted appropriately to avoid `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"vulnerabilities. The :func:`shlex.quote` function can be used to properly "
"escape whitespace and special characters in strings that are going to be "
"used to construct shell commands."
msgstr ""
"Es responsabilidad de la aplicación asegurar que todos los espacios en "
"blanco y caracteres especiales estén escapados correctamente para evitar "
"vulnerabilidades de `inyección de código <https://en.wikipedia.org/wiki/"
"Shell_injection#Shell_injection>`_. La función :func:`shlex.quote` puede ser "
"usada para escapar apropiadamente espacios en blanco y caracteres especiales "
"en cadenas que van a ser usadas para construir comandos de consola."

#: ../Doc/library/asyncio-eventloop.rst:1351
msgid "Callback Handles"
msgstr "Gestores de llamadas"

#: ../Doc/library/asyncio-eventloop.rst:1355
msgid ""
"A callback wrapper object returned by :meth:`loop.call_soon`, :meth:`loop."
"call_soon_threadsafe`."
msgstr ""
"Un objeto de contenedor de llamada retornado por :meth:`loop.call_soon`, :"
"meth:`loop.call_soon_threadsafe`."

#: ../Doc/library/asyncio-eventloop.rst:1360
msgid ""
"Cancel the callback.  If the callback has already been canceled or executed, "
"this method has no effect."
msgstr ""
"Cancela la llamada. Si la llamada ya fue cancelada o ejecutada, este método "
"no tiene efecto."

#: ../Doc/library/asyncio-eventloop.rst:1365
msgid "Return ``True`` if the callback was cancelled."
msgstr "Retorna ``True`` si la llamada fue cancelada."

#: ../Doc/library/asyncio-eventloop.rst:1371
msgid ""
"A callback wrapper object returned by :meth:`loop.call_later`, and :meth:"
"`loop.call_at`."
msgstr ""
"Un objeto de contenedor de llamada retornado por :meth:`loop.call_later`, "
"and :meth:`loop.call_at`."

#: ../Doc/library/asyncio-eventloop.rst:1374
msgid "This class is a subclass of :class:`Handle`."
msgstr "Esta clase es una subclase de :class:`Handle`."

#: ../Doc/library/asyncio-eventloop.rst:1378
msgid "Return a scheduled callback time as :class:`float` seconds."
msgstr ""
"Retorna el tiempo de una llamada planificada como :class:`float` segundos."

#: ../Doc/library/asyncio-eventloop.rst:1380
msgid ""
"The time is an absolute timestamp, using the same time reference as :meth:"
"`loop.time`."
msgstr ""
"El tiempo es una marca de tiempo absoluta, usando la misma referencia de "
"tiempo que :meth:`loop.time`."

#: ../Doc/library/asyncio-eventloop.rst:1387
msgid "Server Objects"
msgstr "Objetos Servidor"

#: ../Doc/library/asyncio-eventloop.rst:1389
msgid ""
"Server objects are created by :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :func:`start_server`, and :func:`start_unix_server` "
"functions."
msgstr ""
"Los objetos de servidor son creados por las funciones :meth:`loop."
"create_server`, :meth:`loop.create_unix_server`, :func:`start_server`, y :"
"func:`start_unix_server`."

#: ../Doc/library/asyncio-eventloop.rst:1393
msgid "Do not instantiate the class directly."
msgstr "No instanciar la clase directamente."

#: ../Doc/library/asyncio-eventloop.rst:1397
msgid ""
"*Server* objects are asynchronous context managers.  When used in an ``async "
"with`` statement, it's guaranteed that the Server object is closed and not "
"accepting new connections when the ``async with`` statement is completed::"
msgstr ""
"Los objetos *Server* son gestores de asíncronos de contexto. Cuando son "
"usados en una declaración ``async with``, está garantizado que el objeto "
"Servidor está cerrado y no está aceptando nuevas conexiones cuando la "
"declaración ``async with`` es completada::"

#: ../Doc/library/asyncio-eventloop.rst:1410
msgid "Server object is an asynchronous context manager since Python 3.7."
msgstr ""
"El objeto Servidor es un gestor asíncrono de contexto desde Python 3.7."

#: ../Doc/library/asyncio-eventloop.rst:1415
msgid ""
"Stop serving: close listening sockets and set the :attr:`sockets` attribute "
"to ``None``."
msgstr ""
"Deja de servir: deja de escuchar sockets y establece el atributo :attr:"
"`sockets` a ``None``."

#: ../Doc/library/asyncio-eventloop.rst:1418
msgid ""
"The sockets that represent existing incoming client connections are left "
"open."
msgstr ""
"Los sockets que representan conexiones entrantes existentes de clientes se "
"dejan abiertas."

#: ../Doc/library/asyncio-eventloop.rst:1421
msgid ""
"The server is closed asynchronously, use the :meth:`wait_closed` coroutine "
"to wait until the server is closed."
msgstr ""
"El servidor es cerrado de manera asíncrona, usa la corrutina :meth:"
"`wait_closed` para esperar hasta que el servidor esté cerrado."

#: ../Doc/library/asyncio-eventloop.rst:1426
msgid "Return the event loop associated with the server object."
msgstr "Retorna el bucle de eventos asociado con el objeto Servidor."

#: ../Doc/library/asyncio-eventloop.rst:1432
msgid "Start accepting connections."
msgstr "Comienza a aceptar conexiones."

#: ../Doc/library/asyncio-eventloop.rst:1434
msgid ""
"This method is idempotent, so it can be called when the server is already "
"being serving."
msgstr ""
"Este método es idempotente, así que puede ser llamado cuando el servidor ya "
"está sirviendo."

#: ../Doc/library/asyncio-eventloop.rst:1437
msgid ""
"The *start_serving* keyword-only parameter to :meth:`loop.create_server` "
"and :meth:`asyncio.start_server` allows creating a Server object that is not "
"accepting connections initially.  In this case ``Server.start_serving()``, "
"or :meth:`Server.serve_forever` can be used to make the Server start "
"accepting connections."
msgstr ""
"El parámetro sólo de palabra clave *start_serving* de :meth:`loop."
"create_server` y :meth:`asyncio.start_server` permite crear un objeto "
"Servidor que no está aceptando conexiones inicialmente. En este caso "
"``Server.start_serving()``, o :meth:`Server.serve_forever` pueden ser usados "
"para hacer que el servidor empiece a aceptar conexiones."

#: ../Doc/library/asyncio-eventloop.rst:1448
msgid ""
"Start accepting connections until the coroutine is cancelled. Cancellation "
"of ``serve_forever`` task causes the server to be closed."
msgstr ""
"Comienza a aceptar conexiones hasta que la corrutina sea cancelada. La "
"cancelación de la tarea ``serve_forever`` hace que el servidor sea cerrado."

#: ../Doc/library/asyncio-eventloop.rst:1452
msgid ""
"This method can be called if the server is already accepting connections.  "
"Only one ``serve_forever`` task can exist per one *Server* object."
msgstr ""
"Este método puede ser llamado si el servidor ya está aceptando conexiones. "
"Solamente una tarea ``serve_forever`` puede existir para un objeto *Server*."

#: ../Doc/library/asyncio-eventloop.rst:1474
msgid "Return ``True`` if the server is accepting new connections."
msgstr "Retorna ``True`` si el servidor está aceptando nuevas conexiones."

#: ../Doc/library/asyncio-eventloop.rst:1480
msgid "Wait until the :meth:`close` method completes."
msgstr "Espera hasta que el método :meth:`close` se complete."

#: ../Doc/library/asyncio-eventloop.rst:1484
msgid "List of :class:`socket.socket` objects the server is listening on."
msgstr ""
"Lista todos los objetos :class:`socket.socket` en los que el servidor está "
"escuchando."

#: ../Doc/library/asyncio-eventloop.rst:1486
msgid ""
"Prior to Python 3.7 ``Server.sockets`` used to return an internal list of "
"server sockets directly.  In 3.7 a copy of that list is returned."
msgstr ""
"Antes de Python 3.7 ``Server.sockets`` solía retornar directamente una lista "
"interna de servidores socket. En 3.7 se retorna una copia de esa lista."

#: ../Doc/library/asyncio-eventloop.rst:1495
msgid "Event Loop Implementations"
msgstr "Implementaciones del bucle de eventos"

#: ../Doc/library/asyncio-eventloop.rst:1497
msgid ""
"asyncio ships with two different event loop implementations: :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop`."
msgstr ""
"asyncio viene con dos implementaciones diferentes del bucle de eventos: :"
"class:`SelectorEventLoop` y :class:`ProactorEventLoop`."

#: ../Doc/library/asyncio-eventloop.rst:1500
msgid ""
"By default asyncio is configured to use :class:`SelectorEventLoop` on Unix "
"and :class:`ProactorEventLoop` on Windows."
msgstr ""
"De manera predefinida asyncio está configurado para usar :class:"
"`SelectorEventLoop` en Unix y :class:`ProactorEventLoop` en Windows."

#: ../Doc/library/asyncio-eventloop.rst:1506
msgid "An event loop based on the :mod:`selectors` module."
msgstr "Un bucle de eventos basado en el módulo :mod:`selectors`."

#: ../Doc/library/asyncio-eventloop.rst:1508
msgid ""
"Uses the most efficient *selector* available for the given platform.  It is "
"also possible to manually configure the exact selector implementation to be "
"used::"
msgstr ""
"Usa el *selector* disponible mas eficiente para la plataforma dada. También "
"es posible configurar manualmente la implementación exacta del selector a "
"utilizar::"

#: ../Doc/library/asyncio-eventloop.rst:1520
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`Disponibilidad <availability>`: Unix, Windows."

#: ../Doc/library/asyncio-eventloop.rst:1525
msgid "An event loop for Windows that uses \"I/O Completion Ports\" (IOCP)."
msgstr ""
"Un bucle de eventos para Windows que usa \"E/S Puertos de Finalización"
"\" (IOCP)."

#: ../Doc/library/asyncio-eventloop.rst:1528
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Disponibilidad <availability>`: Windows."

#: ../Doc/library/asyncio-eventloop.rst:1531
msgid ""
"`MSDN documentation on I/O Completion Ports <https://docs.microsoft.com/en-"
"ca/windows/desktop/FileIO/i-o-completion-ports>`_."
msgstr ""
"`Documentaci´on de MSDN sobre E/S Puertos de Finalización <https://docs."
"microsoft.com/en-ca/windows/desktop/FileIO/i-o-completion-ports>`_."

#: ../Doc/library/asyncio-eventloop.rst:1537
msgid "Abstract base class for asyncio-compliant event loops."
msgstr "Clase base abstracta para bucles de evento compatibles con asyncio."

#: ../Doc/library/asyncio-eventloop.rst:1539
msgid ""
"The :ref:`Event Loop Methods <asyncio-event-loop>` section lists all methods "
"that an alternative implementation of ``AbstractEventLoop`` should have "
"defined."
msgstr ""
"La sección :ref:`Métodos del bucle de eventos <asyncio-event-loop>` lista "
"todos los métodos que como implementación alternativa de "
"``AbstractEventLoop`` debería haber estado definido."

#: ../Doc/library/asyncio-eventloop.rst:1545
msgid "Examples"
msgstr "Examples"

#: ../Doc/library/asyncio-eventloop.rst:1547
msgid ""
"Note that all examples in this section **purposefully** show how to use the "
"low-level event loop APIs, such as :meth:`loop.run_forever` and :meth:`loop."
"call_soon`.  Modern asyncio applications rarely need to be written this way; "
"consider using the high-level functions like :func:`asyncio.run`."
msgstr ""
"Nótese que todos los ejemplos en esta sección muestran **a propósito** como "
"usar las APIs de bucle de eventos de bajo nivel, como ser :meth:`loop."
"run_forever` y :meth:`loop.call_soon`. Aplicaciones asyncio modernas "
"raramente necesitan ser escritas de esta manera; considere utilizar "
"funciones de alto nivel como :func:`asyncio.run`."

#: ../Doc/library/asyncio-eventloop.rst:1557
msgid "Hello World with call_soon()"
msgstr "Hola Mundo con call_soon()"

#: ../Doc/library/asyncio-eventloop.rst:1559
msgid ""
"An example using the :meth:`loop.call_soon` method to schedule a callback. "
"The callback displays ``\"Hello World\"`` and then stops the event loop::"
msgstr ""
"Un ejemplo usando el método :meth:`loop.call_soon` para planificar una "
"llamada. La llamada muestra ``\"Hello World\"`` y luego para el bucle de "
"eventos::"

#: ../Doc/library/asyncio-eventloop.rst:1583
msgid ""
"A similar :ref:`Hello World <coroutine>` example created with a coroutine "
"and the :func:`run` function."
msgstr ""
"Un ejemplo similar de :ref:`Hola Mundo <coroutine>` creado con una corrutina "
"y la función :func:`run`."

#: ../Doc/library/asyncio-eventloop.rst:1590
msgid "Display the current date with call_later()"
msgstr "Muestra la fecha actual con call_later()"

#: ../Doc/library/asyncio-eventloop.rst:1592
msgid ""
"An example of a callback displaying the current date every second. The "
"callback uses the :meth:`loop.call_later` method to reschedule itself after "
"5 seconds, and then stops the event loop::"
msgstr ""
"Un ejemplo de llamada mostrando la fecha actual cada un segundo. La llamada "
"usa el método :meth:`loop.call_later` para volver a planificarse después de "
"5 segundos, y después para el bucle de eventos::"

#: ../Doc/library/asyncio-eventloop.rst:1620
msgid ""
"A similar :ref:`current date <asyncio_example_sleep>` example created with a "
"coroutine and the :func:`run` function."
msgstr ""
"Un ejemplo similar a :ref:`fecha actual <asyncio_example_sleep>` creado con "
"una corrutina y la función :func:`run`."

#: ../Doc/library/asyncio-eventloop.rst:1627
msgid "Watch a file descriptor for read events"
msgstr "Mirar un descriptor de archivo para leer eventos"

#: ../Doc/library/asyncio-eventloop.rst:1629
msgid ""
"Wait until a file descriptor received some data using the :meth:`loop."
"add_reader` method and then close the event loop::"
msgstr ""
"Espera hasta que el descriptor de archivo reciba algún dato usando el "
"método :meth:`loop.add_reader` y entonces cierra el bucle de eventos::"

#: ../Doc/library/asyncio-eventloop.rst:1667
msgid ""
"A similar :ref:`example <asyncio_example_create_connection>` using "
"transports, protocols, and the :meth:`loop.create_connection` method."
msgstr ""
"Un :ref:`ejemplo <asyncio_example_create_connection>` similar usando "
"transportes, protocolos y el método :meth:`loop.create_connection`."

#: ../Doc/library/asyncio-eventloop.rst:1671
msgid ""
"Another similar :ref:`example <asyncio_example_create_connection-streams>` "
"using the high-level :func:`asyncio.open_connection` function and streams."
msgstr ""
"Otro :ref:`ejemplo <asyncio_example_create_connection-streams>` similar "
"usando la función de alto nivel :func:`asyncio.open_connection` y "
"transmisiones."

#: ../Doc/library/asyncio-eventloop.rst:1679
msgid "Set signal handlers for SIGINT and SIGTERM"
msgstr "Establece los gestores de señal para SIGINT y SIGTERM"

#: ../Doc/library/asyncio-eventloop.rst:1681
msgid "(This ``signals`` example only works on Unix.)"
msgstr "(Este ejemplo de ``signals`` solamente funcionan en Unix.)"

#: ../Doc/library/asyncio-eventloop.rst:1683
msgid ""
"Register handlers for signals :py:data:`SIGINT` and :py:data:`SIGTERM` using "
"the :meth:`loop.add_signal_handler` method::"
msgstr ""
"Registra gestores para las señales :py:data:`SIGINT` y :py:data:`SIGTERM` "
"usando el método :meth:`loop.add_signal_handler`::"
