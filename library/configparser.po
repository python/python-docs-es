# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2023-12-24 12:44+0100\n"
"Last-Translator: Claudia Millan <clmilneb@gmail.com>\n"
"Language-Team: python-doc-es\n"
"Language: es_PE\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.13.0\n"
"X-Generator: Poedit 3.0.1\n"

#: ../Doc/library/configparser.rst:2
msgid ":mod:`configparser` --- Configuration file parser"
msgstr ":mod:`configparser` --- *Parser* para archivos de configuración"

#: ../Doc/library/configparser.rst:14
msgid "**Source code:** :source:`Lib/configparser.py`"
msgstr "**Código fuente:** :source:`Lib/configparser.py`"

#: ../Doc/library/configparser.rst:24
msgid ""
"This module provides the :class:`ConfigParser` class which implements a "
"basic configuration language which provides a structure similar to what's "
"found in Microsoft Windows INI files.  You can use this to write Python "
"programs which can be customized by end users easily."
msgstr ""
"Este módulo provee la clase :class:`ConfigParser`, la cual implementa un "
"lenguaje básico de configuración que proporciona una estructura similar a la "
"encontrada en los archivos INI de Microsoft Windows. Puedes utilizarla para "
"escribir programas Python que los usuarios finales puedan personalizar con "
"facilidad."

#: ../Doc/library/configparser.rst:31
msgid ""
"This library does *not* interpret or write the value-type prefixes used in "
"the Windows Registry extended version of INI syntax."
msgstr ""
"Esta biblioteca *no* interpreta o escribe los prefijos valor-tipo usados en "
"la versión extendida de la sintaxis INI, utilizada en el registro de Windows."

#: ../Doc/library/configparser.rst:38
msgid "Module :mod:`tomllib`"
msgstr "Módulo :mod:`tomllib`"

#: ../Doc/library/configparser.rst:37
msgid ""
"TOML is a well-specified format for application configuration files. It is "
"specifically designed to be an improved version of INI."
msgstr ""
"TOML es un formato bien-especificado para archivos de configuración de "
"aplicaciones. Está específicamente diseñado para ser una versión mejorada de "
"INI."

#: ../Doc/library/configparser.rst:42
msgid "Module :mod:`shlex`"
msgstr "Módulo :mod:`shlex`"

#: ../Doc/library/configparser.rst:41
msgid ""
"Support for creating Unix shell-like mini-languages which can also be used "
"for application configuration files."
msgstr ""
"Soporta la creación de un mini-lenguaje parecido a shell de Unix, que puede "
"utilizarse para archivos de configuración de aplicaciones."

#: ../Doc/library/configparser.rst:45
msgid "Module :mod:`json`"
msgstr "Módulo :mod:`json`"

#: ../Doc/library/configparser.rst:45
msgid ""
"The ``json`` module implements a subset of JavaScript syntax which is "
"sometimes used for configuration, but does not support comments."
msgstr ""
"El módulo ``json`` implementa un subconjunto de la sintaxis de JavaScript, "
"que también puede utilizarse para configuración, pero no soporta comentarios."

#: ../Doc/library/configparser.rst:60
msgid "Quick Start"
msgstr "Inicio Rápido"

#: ../Doc/library/configparser.rst:62
msgid "Let's take a very basic configuration file that looks like this:"
msgstr "Tomemos un archivo de configuración muy básico, el cual luce así:"

#: ../Doc/library/configparser.rst:79
msgid ""
"The structure of INI files is described `in the following section "
"<#supported-ini-file-structure>`_.  Essentially, the file consists of "
"sections, each of which contains keys with values. :mod:`configparser` "
"classes can read and write such files.  Let's start by creating the above "
"configuration file programmatically."
msgstr ""
"La estructura de los archivos INI es descrita `en la siguiente sección "
"<#supported-ini-file-structure>`_.  En esencia, el archivo consiste de "
"secciones, cada una de las cuales contiene claves con valores. Las clases :"
"mod:`configparser` pueden leer y escribir dichos archivos. Comencemos "
"creando el anterior archivo de configuración de forma programática."

#: ../Doc/library/configparser.rst:103
msgid ""
"As you can see, we can treat a config parser much like a dictionary. There "
"are differences, `outlined later <#mapping-protocol-access>`_, but the "
"behavior is very close to what you would expect from a dictionary."
msgstr ""
"Como puedes ver, podemos tratar al *config parser* como a un diccionario. "
"Existen diferencias,  `descritas posteriormente <#mapping-protocol-"
"access>`_, pero su comportamiento es muy parecido al que esperarías de un "
"diccionario."

#: ../Doc/library/configparser.rst:107
msgid ""
"Now that we have created and saved a configuration file, let's read it back "
"and explore the data it holds."
msgstr ""
"Ahora que hemos creado y guardado el archivo de configuración, vamos a "
"releerlo y analizar los datos que contiene."

#: ../Doc/library/configparser.rst:142
msgid ""
"As we can see above, the API is pretty straightforward.  The only bit of "
"magic involves the ``DEFAULT`` section which provides default values for all "
"other sections [1]_.  Note also that keys in sections are case-insensitive "
"and stored in lowercase [1]_."
msgstr ""
"Como podemos apreciar, la API es muy clara. La única 'porción de magia' está "
"en la sección ``DEFAULT``, la cual proporciona los valores por defecto para "
"todas las demás secciones [1]_. Observe también que las claves de las "
"secciones son insensibles a mayúsculas y minúsculas, pero se almacenan en "
"minúscula [1]_."

#: ../Doc/library/configparser.rst:147
msgid ""
"It is possible to read several configurations into a single :class:"
"`ConfigParser`, where the most recently added configuration has the highest "
"priority. Any conflicting keys are taken from the more recent configuration "
"while the previously existing keys are retained."
msgstr ""
"Es posible leer varias configuraciones en un único :class:`ConfigParser`, "
"siendo la configuración añadida más recientemente la que tendrá la prioridad "
"más alta. Las claves que entren en conflicto se toman de la configuración "
"más reciente mientras que las claves preexistentes se mantienen."

#: ../Doc/library/configparser.rst:168
msgid ""
"This behaviour is equivalent to a :meth:`ConfigParser.read` call with "
"several files passed to the *filenames* parameter."
msgstr ""
"Este comportamiento es equivalente a una llamada a :meth:`ConfigParser.read` "
"pasando varios ficheros en el parámetro *filenames*."

#: ../Doc/library/configparser.rst:173
msgid "Supported Datatypes"
msgstr "Tipos de Datos Soportados"

#: ../Doc/library/configparser.rst:175
msgid ""
"Config parsers do not guess datatypes of values in configuration files, "
"always storing them internally as strings.  This means that if you need "
"other datatypes, you should convert on your own:"
msgstr ""
"Los *config parsers* no especulan respecto a los tipos de datos de los "
"valores en los archivos de configuración, siempre los almacenan internamente "
"como cadenas de caracteres. Esto significa que si necesitas otros tipos de "
"datos, deberás hacer la conversión por ti mismo:"

#: ../Doc/library/configparser.rst:186
msgid ""
"Since this task is so common, config parsers provide a range of handy getter "
"methods to handle integers, floats and booleans.  The last one is the most "
"interesting because simply passing the value to ``bool()`` would do no good "
"since ``bool('False')`` is still ``True``.  This is why config parsers also "
"provide :meth:`~ConfigParser.getboolean`.  This method is case-insensitive "
"and recognizes Boolean values from ``'yes'``/``'no'``, ``'on'``/``'off'``, "
"``'true'``/``'false'`` and ``'1'``/``'0'`` [1]_.  For example:"
msgstr ""
"Dado que esta tarea es muy común, los *config parsers* proporcionan una "
"amplia variedad de útiles métodos de lectura (*getter*) que manejan enteros, "
"números de punto flotante y booleanos. Este último es el más interesante, "
"porque puede no ser correcto pasar simplemente el valor a ``bool()``, ya que "
"``bool('False')`` resultará en ``True``. Por esta razón los *config parsers* "
"proporcionan también el método :meth:`~ConfigParser.getboolean`. Este método "
"es insensible a mayúsculas y minúsculas, y reconoce como valores booleanos a "
"los valores ``'yes'``/``'no'``, ``'on'``/``'off'``, ``'true'``/``'false'`` "
"and ``'1'``/``'0'`` [1]_.  Por ejemplo:"

#: ../Doc/library/configparser.rst:203
msgid ""
"Apart from :meth:`~ConfigParser.getboolean`, config parsers also provide "
"equivalent :meth:`~ConfigParser.getint` and :meth:`~ConfigParser.getfloat` "
"methods.  You can register your own converters and customize the provided "
"ones. [1]_"
msgstr ""
"Además de :meth:`~ConfigParser.getboolean`, los *config parsers* también "
"proporcionan los métodos equivalentes :meth:`~ConfigParser.getint` y :meth:"
"`~ConfigParser.getfloat`. Puedes registrar tus propios conversores, y "
"personalizar los que se proporcionan. [1]_"

# Posterioremente se utiliza el término "fallback value", y eso, junto al
# código ejemplo, aclaran de qué se trata.
#: ../Doc/library/configparser.rst:209
msgid "Fallback Values"
msgstr "Valores de contingencia"

#: ../Doc/library/configparser.rst:211
msgid ""
"As with a dictionary, you can use a section's :meth:`get` method to provide "
"fallback values:"
msgstr ""
"Similar a un diccionario, puedes utilizar el método :meth:`get` de una "
"sección para especificar valores de contingencia (*fallback values*):"

# Aquí he utilizado la expresión "valor de último recurso" como traducción de
# "fallback value", otras opciones son "valor alternativo", "valor auxiliar",
# "valor sustitutivo".
# No puedo usar "valor por defecto", ya que hay otros valores por defecto (los
# que se asignan en la sección DEFAULT).
#: ../Doc/library/configparser.rst:224
msgid ""
"Please note that default values have precedence over fallback values. For "
"instance, in our example the ``'CompressionLevel'`` key was specified only "
"in the ``'DEFAULT'`` section.  If we try to get it from the section "
"``'topsecret.server.example'``, we will always get the default, even if we "
"specify a fallback:"
msgstr ""
"Por favor, fíjate que los valores por defecto tienen prioridad sobre los "
"valores de contingencia (*fallback*). Así, en nuestro ejemplo, la clave "
"``'CompressionLevel'`` sólo fue especificada en la sección ``'DEFAULT'``. Si "
"tratamos de obtener su valor de la sección ``'topsecret.server.example'``, "
"obtendremos siempre el valor por defecto, incluso si especificamos un valor "
"de contingencia:"

#: ../Doc/library/configparser.rst:235
msgid ""
"One more thing to be aware of is that the parser-level :meth:`get` method "
"provides a custom, more complex interface, maintained for backwards "
"compatibility.  When using this method, a fallback value can be provided via "
"the ``fallback`` keyword-only argument:"
msgstr ""
"Otra cuestión que hay que tener en cuenta, es que el método a nivel "
"analizador (*parser*) :meth:`get` proporciona una interfaz personalizada, "
"más compleja, que se mantiene por compatibilidad con versiones anteriores. "
"Cuando se utiliza este método, se puede proporcionar un valor de "
"contingencia mediante el argumento de sólo-palabra clave (*keyword-only*) "
"``fallback``:"

#: ../Doc/library/configparser.rst:246
msgid ""
"The same ``fallback`` argument can be used with the :meth:`~ConfigParser."
"getint`, :meth:`~ConfigParser.getfloat` and :meth:`~ConfigParser.getboolean` "
"methods, for example:"
msgstr ""
"El mismo argumento ``fallback`` puede utilizarse con los métodos :meth:"
"`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat` y :meth:"
"`~ConfigParser.getboolean`, por ejemplo:"

#: ../Doc/library/configparser.rst:262
msgid "Supported INI File Structure"
msgstr "Estructura soportada para el archivo ini"

#: ../Doc/library/configparser.rst:264
msgid ""
"A configuration file consists of sections, each led by a ``[section]`` "
"header, followed by key/value entries separated by a specific string (``=`` "
"or ``:`` by default [1]_).  By default, section names are case sensitive but "
"keys are not [1]_.  Leading and trailing whitespace is removed from keys and "
"values. Values can be omitted if the parser is configured to allow it [1]_, "
"in which case the key/value delimiter may also be left out.  Values can also "
"span multiple lines, as long as they are indented deeper than the first line "
"of the value.  Depending on the parser's mode, blank lines may be treated as "
"parts of multiline values or ignored."
msgstr ""
"Un archivo de configuración consta de secciones, cada una iniciada por una "
"cabecera ``[section]``, seguida por registros clave-valor separados por una "
"cadena de caracteres específica (``=`` ó ``:`` por defecto [1]_). De forma "
"predeterminada, los nombres de sección son sensibles a mayúsculas y "
"minúsculas pero las claves no [1]_. Los espacios al inicio y final de las "
"claves y valores son eliminados. Los valores pueden ser omitidos si el "
"*parser* está configurado para permitirlo [1]_, en cuyo caso el delimitador "
"del dato clave-valor puede ser omitido también. Los valores pueden ocupar "
"varias líneas, siempre y cuando tengan una indentación mayor que la primera "
"línea del valor. Dependiendo del modo del *parser*, las líneas en blanco "
"pueden tratarse como parte de un valor multilínea o ser ignoradas."

#: ../Doc/library/configparser.rst:274
msgid ""
"By default,  a valid section name can be any string that does not contain '\\"
"\\n' or ']'. To change this, see :attr:`ConfigParser.SECTCRE`."
msgstr ""
"De forma predeterminada, un nombre de sección válido puede ser cualquier "
"cadena de texto que no contenga '\\\\n' or ']'. Para cambiar esto, consulte :"
"attr:`ConfigParser.SECTCRE`."

#: ../Doc/library/configparser.rst:277
msgid ""
"Configuration files may include comments, prefixed by specific characters "
"(``#`` and ``;`` by default [1]_).  Comments may appear on their own on an "
"otherwise empty line, possibly indented. [1]_"
msgstr ""
"Los archivos de configuración pueden incluir comentarios, con caracteres "
"específicos como prefijos (``#`` y ``;`` por defecto [1]_). Los comentarios "
"pueden ocupar su propia línea, posiblemente indentada. [1]_"

#: ../Doc/library/configparser.rst:281 ../Doc/library/configparser.rst:344
msgid "For example:"
msgstr "Por ejemplo:"

#: ../Doc/library/configparser.rst:329
msgid "Interpolation of values"
msgstr "Interpolación de valores"

#: ../Doc/library/configparser.rst:331
msgid ""
"On top of the core functionality, :class:`ConfigParser` supports "
"interpolation.  This means values can be preprocessed before returning them "
"from ``get()`` calls."
msgstr ""
"En el nivel superior de su funcionalidad central, :class:`ConfigParser` "
"soporta la interpolación. Esto significa que los valores pueden ser "
"preprocesados, antes de ser retornados por los llamados a ``get()``."

#: ../Doc/library/configparser.rst:339
msgid ""
"The default implementation used by :class:`ConfigParser`.  It enables values "
"to contain format strings which refer to other values in the same section, "
"or values in the special default section [1]_.  Additional default values "
"can be provided on initialization."
msgstr ""
"Es la implementación por defecto que utiliza :class:`ConfigParser`. Permite "
"valores que contengan cadenas de formato, que hacen referencia a otros "
"valores en la misma sección o a valores presentes en la sección especial "
"*default* [1]_. Valores por defecto adicionales pueden ser proporcionados en "
"la inicialización."

#: ../Doc/library/configparser.rst:357
#, python-format
msgid ""
"In the example above, :class:`ConfigParser` with *interpolation* set to "
"``BasicInterpolation()`` would resolve ``%(home_dir)s`` to the value of "
"``home_dir`` (``/Users`` in this case).  ``%(my_dir)s`` in effect would "
"resolve to ``/Users/lumberjack``.  All interpolations are done on demand so "
"keys used in the chain of references do not have to be specified in any "
"specific order in the configuration file."
msgstr ""
"En el ejemplo anterior, :class:`ConfigParser` con la *interpolación* "
"establecida a ``BasicInterpolation()`` puede resolver ``%(home_dir)s`` al "
"valor ``home_dir`` (``/Users`` en este caso).  En efecto, ``%(my_dir)s`` "
"podría resolverse como ``/Users/lumberjack``. Todas las interpolaciones son "
"realizadas bajo demanda, de modo que las claves utilizadas en la cadena de "
"referencias no requieren un orden específico en el archivo de configuración."

#: ../Doc/library/configparser.rst:364
#, python-format
msgid ""
"With ``interpolation`` set to ``None``, the parser would simply return "
"``%(my_dir)s/Pictures`` as the value of ``my_pictures`` and ``%(home_dir)s/"
"lumberjack`` as the value of ``my_dir``."
msgstr ""
"Con ``interpolation`` establecida al valor ``None``, el *parser* retornará "
"simplemente ``%(my_dir)s/Pictures`` como el valor de ``my_pictures`` y "
"``%(home_dir)s/lumberjack`` como el valor de ``my_dir``."

#: ../Doc/library/configparser.rst:372
msgid ""
"An alternative handler for interpolation which implements a more advanced "
"syntax, used for instance in ``zc.buildout``.  Extended interpolation is "
"using ``${section:option}`` to denote a value from a foreign section. "
"Interpolation can span multiple levels.  For convenience, if the ``section:"
"`` part is omitted, interpolation defaults to the current section (and "
"possibly the default values from the special section)."
msgstr ""
"Es un gestor alternativo para la interpolación, que implementa una sintaxis "
"más avanzada; es utilizado, por ejemplo, en ``zc.buildout``.  La "
"interpolación es extendida al utilizar ``${section:option}``, a fin de "
"especificar un valor que proviene de una sección externa. La interpolación "
"puede cubrir múltiples niveles. Por conveniencia, si la parte ``section:`` "
"es omitida, la interpolación utilizará la sección actual (y posiblemente los "
"valores por defecto establecidos en la sección especial)."

#: ../Doc/library/configparser.rst:379
msgid ""
"For example, the configuration specified above with basic interpolation, "
"would look like this with extended interpolation:"
msgstr ""
"Por ejemplo, la configuración indicada anteriormente, con interpolación "
"básica, luciría de la siguiente manera utilizando interpolación extendida:"

#: ../Doc/library/configparser.rst:393
msgid "Values from other sections can be fetched as well:"
msgstr "También pueden buscarse valores en otras secciones:"

#: ../Doc/library/configparser.rst:415
msgid "Mapping Protocol Access"
msgstr "Acceso por protocolo de mapeo"

#: ../Doc/library/configparser.rst:419
msgid ""
"Mapping protocol access is a generic name for functionality that enables "
"using custom objects as if they were dictionaries.  In case of :mod:"
"`configparser`, the mapping interface implementation is using the "
"``parser['section']['option']`` notation."
msgstr ""
"El acceso por protocolo de mapeo es un nombre genérico asignado a la "
"funcionalidad que permite el uso de objetos personalizados como si fuesen "
"diccionarios. En el caso de :mod:`configparser`, la implementación de la "
"interfaz de mapeo utiliza la notación ``parser['section']['option']``."

#: ../Doc/library/configparser.rst:424
msgid ""
"``parser['section']`` in particular returns a proxy for the section's data "
"in the parser.  This means that the values are not copied but they are taken "
"from the original parser on demand.  What's even more important is that when "
"values are changed on a section proxy, they are actually mutated in the "
"original parser."
msgstr ""
"En particular, ``parser['section']`` retorna un proxy para los datos de la "
"sección en el *parser*. Esto significa que los valores no son copiados, sino "
"que son tomados del *parser* original sobre la marcha."

#: ../Doc/library/configparser.rst:430
msgid ""
":mod:`configparser` objects behave as close to actual dictionaries as "
"possible. The mapping interface is complete and adheres to the :class:"
"`~collections.abc.MutableMapping` ABC. However, there are a few differences "
"that should be taken into account:"
msgstr ""
"Los objetos de :mod:`configparser` se comportan de forma tan similar a un "
"diccionario como se puede. La interfaz de mapeo es completa y se ciñe a la :"
"class:`~collections.abc.MutableMapping` ABC. Sin embargo, existen unas "
"pequeñas diferencias que deben tomarse en cuenta:"

#: ../Doc/library/configparser.rst:435
msgid ""
"By default, all keys in sections are accessible in a case-insensitive manner "
"[1]_.  E.g. ``for option in parser[\"section\"]`` yields only "
"``optionxform``'ed option key names.  This means lowercased keys by "
"default.  At the same time, for a section that holds the key ``'a'``, both "
"expressions return ``True``::"
msgstr ""
"Por defecto, todas las claves de las secciones se pueden acceder de una "
"forma insensible a mayúsculas y minúsculas [1]_. Ej. ``for option in "
"parser[\"section\"]`` entrega solamente nombres de claves de opción que han "
"pasado por ``optionxform``. Esto significa, claves en minúscula por defecto. "
"A la vez, para una sección que contiene la clave ``'a'``, ambas expresiones "
"retornan ``True``::"

#: ../Doc/library/configparser.rst:443
msgid ""
"All sections include ``DEFAULTSECT`` values as well which means that ``."
"clear()`` on a section may not leave the section visibly empty.  This is "
"because default values cannot be deleted from the section (because "
"technically they are not there).  If they are overridden in the section, "
"deleting causes the default value to be visible again.  Trying to delete a "
"default value causes a :exc:`KeyError`."
msgstr ""
"Todas las secciones también incluyen valores ``DEFAULTSECT``, lo que "
"significa que ``.clear()`` en una sección puede no significar que esta quede "
"vacía de forma visible. Ello debido a que los valores por defecto no pueden "
"ser borrados de la sección (ya que técnicamente no están allí). Si fueron "
"redefinidas en la sección, su borrado ocasiona que los valores por defecto "
"sean visibles de nuevo. Cualquier intento de borrar un valor por defecto "
"ocasiona una excepción :exc:`KeyError`."

#: ../Doc/library/configparser.rst:450
msgid "``DEFAULTSECT`` cannot be removed from the parser:"
msgstr "``DEFAULTSECT`` no puede ser eliminado del *parser*:"

#: ../Doc/library/configparser.rst:452
msgid "trying to delete it raises :exc:`ValueError`,"
msgstr "el intento de borrarlo lanza una excepción :exc:`ValueError`,"

#: ../Doc/library/configparser.rst:454
msgid "``parser.clear()`` leaves it intact,"
msgstr "``parser.clear()`` lo deja intacto,"

#: ../Doc/library/configparser.rst:456
msgid "``parser.popitem()`` never returns it."
msgstr "``parser.popitem()`` nunca lo retorna."

#: ../Doc/library/configparser.rst:458
msgid ""
"``parser.get(section, option, **kwargs)`` - the second argument is **not** a "
"fallback value.  Note however that the section-level ``get()`` methods are "
"compatible both with the mapping protocol and the classic configparser API."
msgstr ""
"``parser.get(section, option, **kwargs)`` - el segundo argumento **no** es "
"un valor de contingencia. Observe, sin embargo, que los métodos ``get()`` a "
"nivel de sección son compatibles tanto con el protocolo de mapeo como con la "
"API clásica de *configparser*."

#: ../Doc/library/configparser.rst:462
msgid ""
"``parser.items()`` is compatible with the mapping protocol (returns a list "
"of *section_name*, *section_proxy* pairs including the DEFAULTSECT).  "
"However, this method can also be invoked with arguments: ``parser."
"items(section, raw, vars)``.  The latter call returns a list of *option*, "
"*value* pairs for a specified ``section``, with all interpolations expanded "
"(unless ``raw=True`` is provided)."
msgstr ""
"``parser.items()`` es compatible con el protocolo de mapeo (retorna una "
"lista de pares *section_name*, *section_proxy* que estén incluidos en "
"DEFAULTSECT). Sin embargo, este método también puede ser invocado con los "
"argumentos: ``parser.items(section, raw, vars)``.  Esta última llamada "
"retorna una lista de pares *option*, *value* para una ``section`` "
"específica, con todas las interpolaciones expandidas (a menos que se "
"especifique ``raw=True``)."

#: ../Doc/library/configparser.rst:469
msgid ""
"The mapping protocol is implemented on top of the existing legacy API so "
"that subclasses overriding the original interface still should have mappings "
"working as expected."
msgstr ""
"El protocolo de mapeo se implementa en el nivel superior de la actual API "
"heredada, de modo que esas subclases que sobre-escriben la interfaz original "
"aún deberían hacer funcionar el mapeo como se esperaría."

#: ../Doc/library/configparser.rst:475
msgid "Customizing Parser Behaviour"
msgstr "Personalizando el comportamiento del parser"

#: ../Doc/library/configparser.rst:477
msgid ""
"There are nearly as many INI format variants as there are applications using "
"it. :mod:`configparser` goes a long way to provide support for the largest "
"sensible set of INI styles available.  The default functionality is mainly "
"dictated by historical background and it's very likely that you will want to "
"customize some of the features."
msgstr ""
"Existen casi tantas variantes del formato INI como aplicaciones que lo "
"usen. :mod:`configparser` llega muy lejos al proporcionar soporte al mayor "
"conjunto sensible de estilos de INI disponibles. La funcionalidad "
"predeterminada es impuesta principalmente por antecedentes históricos y es "
"muy probable que quieras personalizar algunas de las funcionalidades."

#: ../Doc/library/configparser.rst:483
msgid ""
"The most common way to change the way a specific config parser works is to "
"use the :meth:`__init__` options:"
msgstr ""
"La forma más común para modificar cómo funciona un *config parser* "
"específico consiste en el uso de las opciones de :meth:`__init__`:"

#: ../Doc/library/configparser.rst:486
msgid "*defaults*, default value: ``None``"
msgstr "*defaults*, valor por defecto: ``None``"

#: ../Doc/library/configparser.rst:488
msgid ""
"This option accepts a dictionary of key-value pairs which will be initially "
"put in the ``DEFAULT`` section.  This makes for an elegant way to support "
"concise configuration files that don't specify values which are the same as "
"the documented default."
msgstr ""
"Esta opción acepta un diccionario de pares clave-valor, que debe ser "
"colocado inicialmente en la sección ``DEFAULT``. De este modo se obtiene una "
"manera elegante de apoyar los archivos de configuración concisos, que no "
"especifican valores que sean los mismos documentados por defecto."

#: ../Doc/library/configparser.rst:493
msgid ""
"Hint: if you want to specify default values for a specific section, use :"
"meth:`read_dict` before you read the actual file."
msgstr ""
"Consejo: si quieres especificar valores por defecto para una sección "
"específica, usa :meth:`read_dict` antes de leer el archivo real."

#: ../Doc/library/configparser.rst:496
msgid "*dict_type*, default value: :class:`dict`"
msgstr "*dict_type*, valor por defecto: :class:`dict`"

#: ../Doc/library/configparser.rst:498
msgid ""
"This option has a major impact on how the mapping protocol will behave and "
"how the written configuration files look.  With the standard dictionary, "
"every section is stored in the order they were added to the parser.  Same "
"goes for options within sections."
msgstr ""
"Esta opción tiene un gran impacto en cómo funcionará el protocolo de mapeo, "
"y cómo lucirán los archivos de configuración a escribir. Con el diccionario "
"estándar, cada sección se almacena en el orden en que se añadieron al "
"*parser*. Lo mismo ocurre con las opciones dentro de las secciones."

#: ../Doc/library/configparser.rst:503
msgid ""
"An alternative dictionary type can be used for example to sort sections and "
"options on write-back."
msgstr ""
"Un tipo alternativo de diccionario puede ser utilizado, por ejemplo, para "
"ordenar las secciones y opciones en un modo a posteriori (*write-back*)."

#: ../Doc/library/configparser.rst:506
msgid ""
"Please note: there are ways to add a set of key-value pairs in a single "
"operation.  When you use a regular dictionary in those operations, the order "
"of the keys will be ordered.  For example:"
msgstr ""
"Por favor, tome en cuenta que: existen formas de agregar un par clave-valor "
"en una sola operación. Cuando se utiliza un diccionario común en tales "
"operaciones, el orden de las claves será el empleado en la creación. Por "
"ejemplo:"

#: ../Doc/library/configparser.rst:528
msgid "*allow_no_value*, default value: ``False``"
msgstr "*allow_no_value*, valor por defecto: ``False``"

#: ../Doc/library/configparser.rst:530
msgid ""
"Some configuration files are known to include settings without values, but "
"which otherwise conform to the syntax supported by :mod:`configparser`.  The "
"*allow_no_value* parameter to the constructor can be used to indicate that "
"such values should be accepted:"
msgstr ""
"Se sabe que algunos archivos de configuración incluyen elementos sin indicar "
"un valor, aunque cumplan con la sintaxis soportada por :mod:`configparser` "
"en todo lo demás. El parámetro *allow_no_value* le indica al constructor que "
"tales valores deben ser aceptados:"

#: ../Doc/library/configparser.rst:565
msgid "*delimiters*, default value: ``('=', ':')``"
msgstr "*delimiters*, valor por defecto: ``('=', ':')``"

#: ../Doc/library/configparser.rst:567
msgid ""
"Delimiters are substrings that delimit keys from values within a section. "
"The first occurrence of a delimiting substring on a line is considered a "
"delimiter.  This means values (but not keys) can contain the delimiters."
msgstr ""
"Los *delimiters* son cadenas de caracteres que separan las claves de los "
"valores dentro de una sección. La primera ocurrencia de una cadena de "
"separación en una línea se considera como un separador. Esto significa que "
"los valores pueden contener separadores, no así las claves."

#: ../Doc/library/configparser.rst:571
msgid ""
"See also the *space_around_delimiters* argument to :meth:`ConfigParser."
"write`."
msgstr ""
"Vea también el argumento *space_around_delimiters* de :meth:`ConfigParser."
"write`."

#: ../Doc/library/configparser.rst:574
msgid "*comment_prefixes*, default value: ``('#', ';')``"
msgstr "*comment_prefixes*, valor por defecto: ``('#', ';')``"

#: ../Doc/library/configparser.rst:576
msgid "*inline_comment_prefixes*, default value: ``None``"
msgstr "*inline_comment_prefixes*, valor por defecto: ``None``"

#: ../Doc/library/configparser.rst:578
msgid ""
"Comment prefixes are strings that indicate the start of a valid comment "
"within a config file. *comment_prefixes* are used only on otherwise empty "
"lines (optionally indented) whereas *inline_comment_prefixes* can be used "
"after every valid value (e.g. section names, options and empty lines as "
"well).  By default inline comments are disabled and ``'#'`` and ``';'`` are "
"used as prefixes for whole line comments."
msgstr ""
"Los prefijos de comentario son cadenas de caracteres que indican el inicio "
"de un comentario válido dentro de un archivo de configuración. Los "
"*comment_prefixes* son utilizados solamente en lo que serían líneas en "
"blanco (opcionalmente indentadas), mientras que *inline_comment_prefixes* "
"pueden ser utilizados después de cada valor válido (ej. nombres de sección, "
"opciones y también líneas en blanco). De forma predeterminada, los "
"comentarios en la misma línea están deshabilitados, y tanto ``'#'`` como "
"``';'`` se utilizan como prefijos para comentarios que ocupan toda la línea."

#: ../Doc/library/configparser.rst:585
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``comment_prefixes=('#',';')`` and ``inline_comment_prefixes=(';',)``."
msgstr ""
"En versiones previas de :mod:`configparser` el comportamiento correspondía a "
"``comment_prefixes=('#',';')`` e ``inline_comment_prefixes=(';',)``."

#: ../Doc/library/configparser.rst:589
msgid ""
"Please note that config parsers don't support escaping of comment prefixes "
"so using *inline_comment_prefixes* may prevent users from specifying option "
"values with characters used as comment prefixes.  When in doubt, avoid "
"setting *inline_comment_prefixes*.  In any circumstances, the only way of "
"storing comment prefix characters at the beginning of a line in multiline "
"values is to interpolate the prefix, for example::"
msgstr ""
"Por favor, observe que los *config parsers* no soportan el escapado de los "
"prefijos de comentarios, de modo que la utilización de los "
"*inline_comment_prefixes* puede impedir que los usuarios especifiquen "
"valores de opciones que incluyan caracteres empleados como prefijos de "
"comentarios. Ante la duda, evite especificar los *inline_comment_prefixes*. "
"En cualquier circunstancia, la única forma de almacenar caracteres prefijos "
"de comentario al inicio de una línea, en valores multilínea, es mediante la "
"interpolación del prefijo, por ejemplo::"

#: ../Doc/library/configparser.rst:635
msgid "*strict*, default value: ``True``"
msgstr "*strict*, valor por defecto: ``True``"

#: ../Doc/library/configparser.rst:637
msgid ""
"When set to ``True``, the parser will not allow for any section or option "
"duplicates while reading from a single source (using :meth:`read_file`, :"
"meth:`read_string` or :meth:`read_dict`).  It is recommended to use strict "
"parsers in new applications."
msgstr ""
"Cuando tiene el valor ``True``, el *parser* no permitirá duplicados en "
"ninguna sección u opción, al efectuar la lectura desde una sola fuente "
"(utilizando :meth:`read_file`, :meth:`read_string` ó :meth:`read_dict`). Se "
"recomienda el uso de *strict parsers* en las aplicaciones nuevas."

#: ../Doc/library/configparser.rst:642
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``strict=False``."
msgstr ""
"En versiones previas de :mod:`configparser` el comportamiento correspondía a "
"``strict=False``."

#: ../Doc/library/configparser.rst:646
msgid "*empty_lines_in_values*, default value: ``True``"
msgstr "*empty_lines_in_values*, valor por defecto: ``True``"

#: ../Doc/library/configparser.rst:648
msgid ""
"In config parsers, values can span multiple lines as long as they are "
"indented more than the key that holds them.  By default parsers also let "
"empty lines to be parts of values.  At the same time, keys can be "
"arbitrarily indented themselves to improve readability.  In consequence, "
"when configuration files get big and complex, it is easy for the user to "
"lose track of the file structure.  Take for instance:"
msgstr ""
"En los *config parsers*, los valores pueden abarcar varias líneas, siempre y "
"cuando estén indentadas a un nivel superior al de la clave que las contiene. "
"De forma predeterminada, los *parsers* permiten que las líneas en blanco "
"formen parte de los valores. Igualmente, las claves pueden estar indentadas "
"a sí mismas de forma arbitraria, a fin de mejorar la legibilidad. Por lo "
"tanto, cuando los archivos de configuración se vuelven grandes y complejos, "
"es fácil para el usuario el perder la pista de la estructura del archivo. "
"Tomemos como ejemplo:"

#: ../Doc/library/configparser.rst:663
msgid ""
"This can be especially problematic for the user to see if she's using a "
"proportional font to edit the file.  That is why when your application does "
"not need values with empty lines, you should consider disallowing them.  "
"This will make empty lines split keys every time.  In the example above, it "
"would produce two keys, ``key`` and ``this``."
msgstr ""
"Esto puede ser especialmente problemático de observar por parte del usuario, "
"en caso que se esté utilizando un tipo de fuente proporcional para editar el "
"archivo. Y es por ello que, cuando tu aplicación no necesite valores con "
"líneas en blanco, debes considerar invalidarlas. Esto ocasionaría que las "
"líneas en blanco sirvan para dividir a las claves, siempre. En el ejemplo "
"anterior, produciría dos claves: ``key`` y ``this``."

#: ../Doc/library/configparser.rst:669
msgid ""
"*default_section*, default value: ``configparser.DEFAULTSECT`` (that is: "
"``\"DEFAULT\"``)"
msgstr ""
"*default_section*, valor por defecto: ``configparser.DEFAULTSECT`` (es "
"decir: ``\"DEFAULT\"``)"

#: ../Doc/library/configparser.rst:672
msgid ""
"The convention of allowing a special section of default values for other "
"sections or interpolation purposes is a powerful concept of this library, "
"letting users create complex declarative configurations.  This section is "
"normally called ``\"DEFAULT\"`` but this can be customized to point to any "
"other valid section name.  Some typical values include: ``\"general\"`` or "
"``\"common\"``.  The name provided is used for recognizing default sections "
"when reading from any source and is used when writing configuration back to "
"a file.  Its current value can be retrieved using the ``parser_instance."
"default_section`` attribute and may be modified at runtime (i.e. to convert "
"files from one format to another)."
msgstr ""
"El convenio de permitir una sección especial con valores por defecto para "
"otras secciones, o con propósito de interpolación, es un concepto poderoso "
"de esta librería, el cual permite a los usuarios crear configuraciones "
"declarativas complejas. Esta sección se suele denominar ``\"DEFAULT\"``, "
"pero puede personalizarse para corresponder a cualquier otro nombre de "
"sección. Algunas valores comunes son: ``\"general\"`` ó ``\"common\"``. El "
"nombre proporcionado es utilizado para reconocer las secciones por defecto "
"al momento de realizar la lectura desde cualquier fuente, y es utilizado "
"ante cualquier escritura al archivo de configuración. Su valor actual puede "
"obtenerse utilizando el atributo ``parser_instance.default_section`` y puede "
"ser modificado en tiempo de ejecución (es decir, para convertir archivos de "
"un formato a otro)."

#: ../Doc/library/configparser.rst:683
msgid "*interpolation*, default value: ``configparser.BasicInterpolation``"
msgstr ""
"*interpolation*, valor por defecto: ``configparser.BasicInterpolation``"

#: ../Doc/library/configparser.rst:685
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_. :class:"
"`RawConfigParser` has a default value of ``None``."
msgstr ""
"El comportamiento de la interpolación puede ser personalizado al "
"proporcionar un gestor personalizado mediante el argumento *interpolation*. "
"El valor ``None`` se utiliza para desactivar la interpolación por completo, "
"mientras que ``ExtendedInterpolation()`` proporciona una variante más "
"avanzada, inspirada por ``zc.buildout``. Más información al respecto en la "
"`sección dedicada de la documentación <#interpolation-of-values>`_. El :"
"class:`RawConfigParser` tiene un valor por defecto de ``None``."

#: ../Doc/library/configparser.rst:692
msgid "*converters*, default value: not set"
msgstr "*converters*, valor por defecto: no definido"

#: ../Doc/library/configparser.rst:694
msgid ""
"Config parsers provide option value getters that perform type conversion.  "
"By default :meth:`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat`, "
"and :meth:`~ConfigParser.getboolean` are implemented.  Should other getters "
"be desirable, users may define them in a subclass or pass a dictionary where "
"each key is a name of the converter and each value is a callable "
"implementing said conversion.  For instance, passing ``{'decimal': decimal."
"Decimal}`` would add :meth:`getdecimal` on both the parser object and all "
"section proxies.  In other words, it will be possible to write both "
"``parser_instance.getdecimal('section', 'key', fallback=0)`` and "
"``parser_instance['section'].getdecimal('key', 0)``."
msgstr ""
"Los *config parsers* proporcionan métodos para lectura (*getters*) de "
"valores de opciones, que llevan a cabo la conversión de tipo. Están "
"implementados los métodos :meth:`~ConfigParser.getint`, :meth:`~ConfigParser."
"getfloat`, y :meth:`~ConfigParser.getboolean`, de forma predeterminada. Si "
"se desean otros métodos de lectura (*getters*), los usuarios pueden "
"definirlos en una subclase o pasar un diccionario donde cada clave sea el "
"nombre del conversor y cada valor es un invocable (*callable*) que "
"implemente la conversión requerida. Por ejemplo, al pasar ``{'decimal': "
"decimal.Decimal}`` se agregaría :meth:`getdecimal` tanto en el objeto "
"*parser* como en todas las secciones proxies. En otras palabras, sería "
"posible escribir tanto ``parser_instance.getdecimal('section', 'key', "
"fallback=0)`` como ``parser_instance['section'].getdecimal('key', 0)``."

#: ../Doc/library/configparser.rst:705
msgid ""
"If the converter needs to access the state of the parser, it can be "
"implemented as a method on a config parser subclass.  If the name of this "
"method starts with ``get``, it will be available on all section proxies, in "
"the dict-compatible form (see the ``getdecimal()`` example above)."
msgstr ""
"Si el conversor necesita acceder al estado del *parser*, este puede ser "
"implementado como un método en una subclase del *config parser*. Si el "
"nombre de este método comienza con ``get``, estará disponible en todas las "
"secciones proxy, en su forma compatible con diccionarios (vea el ejemplo "
"anterior de ``getdecimal()``)."

#: ../Doc/library/configparser.rst:710
msgid ""
"More advanced customization may be achieved by overriding default values of "
"these parser attributes.  The defaults are defined on the classes, so they "
"may be overridden by subclasses or by attribute assignment."
msgstr ""
"Una personalización más avanzada puede conseguirse al sustituir los valores "
"por defecto de estos atributos del *parser*. Los valores por defecto son "
"definidos en las clases, de modo que pueden ser sustituidos por las "
"subclases o mediante la asignación de atributos."

#: ../Doc/library/configparser.rst:716
msgid ""
"By default when using :meth:`~ConfigParser.getboolean`, config parsers "
"consider the following values ``True``: ``'1'``, ``'yes'``, ``'true'``, "
"``'on'`` and the following values ``False``: ``'0'``, ``'no'``, ``'false'``, "
"``'off'``.  You can override this by specifying a custom dictionary of "
"strings and their Boolean outcomes. For example:"
msgstr ""
"Por defecto, al utilizar el método :meth:`~ConfigParser.getboolean`, los "
"*config parsers* consideran a los siguientes valores como ``True``: ``'1'``, "
"``'yes'``, ``'true'``, ``'on'`` y a los siguientes valores como ``False``: "
"``'0'``, ``'no'``, ``'false'``, ``'off'``.  Puedes cambiar ello "
"proporcionando un diccionario personalizado de cadenas de caracteres, con "
"sus correspondientes valores booleanos. Por ejemplo:"

#: ../Doc/library/configparser.rst:734
msgid ""
"Other typical Boolean pairs include ``accept``/``reject`` or ``enabled``/"
"``disabled``."
msgstr ""
"Otros pares booleanos comunes incluyen ``accept``/``reject`` ó ``enabled``/"
"``disabled``."

#: ../Doc/library/configparser.rst:740
msgid ""
"This method transforms option names on every read, get, or set operation.  "
"The default converts the name to lowercase.  This also means that when a "
"configuration file gets written, all keys will be lowercase.  Override this "
"method if that's unsuitable. For example:"
msgstr ""
"Este método realiza la transformación de los nombres de opciones para cada "
"operación de lectura, obtención o asignación. Por defecto convierte los "
"nombres a minúsculas. Esto significa que, cuando un archivo de configuración "
"es escrito, todas las claves son convertidas a minúsculas. Sobre-escribe "
"este método si tal comportamiento no es adecuado. Por ejemplo:"

#: ../Doc/library/configparser.rst:770
msgid ""
"The optionxform function transforms option names to a canonical form. This "
"should be an idempotent function: if the name is already in canonical form, "
"it should be returned unchanged."
msgstr ""
"La función *optionxform* transforma los nombres de opción a una forma "
"canónica. Esta debería ser una función idempotente: si el nombre ya está en "
"su forma canónica, debería retornarse sin cambios."

#: ../Doc/library/configparser.rst:777
msgid ""
"A compiled regular expression used to parse section headers.  The default "
"matches ``[section]`` to the name ``\"section\"``.  Whitespace is considered "
"part of the section name, thus ``[  larch  ]`` will be read as a section of "
"name ``\"  larch  \"``.  Override this attribute if that's unsuitable.  For "
"example:"
msgstr ""
"Es una expresión regular compilada que se utiliza para parsear cabeceras de "
"sección. Por defecto hace corresponder ``[section]`` con el nombre "
"``\"section\"``. Los espacios en blanco son considerados parte del nombre de "
"sección, por lo que ``[  larch  ]`` será leído como la sección de nombre "
"``\"  larch  \"``. Sobre-escribe este atributo si tal comportamiento no es "
"adecuado. Por ejemplo:"

#: ../Doc/library/configparser.rst:805
msgid ""
"While ConfigParser objects also use an ``OPTCRE`` attribute for recognizing "
"option lines, it's not recommended to override it because that would "
"interfere with constructor options *allow_no_value* and *delimiters*."
msgstr ""
"Mientras que los objetos *ConfigParser* también utilizan un atributo "
"``OPTCRE`` para reconocer las líneas de opciones, no se recomienda su sobre-"
"escritura porque puede interferir con las opciones *allow_no_value* y "
"*delimiters* del constructor."

#: ../Doc/library/configparser.rst:811
msgid "Legacy API Examples"
msgstr "Ejemplos de la API heredada"

#: ../Doc/library/configparser.rst:813
msgid ""
"Mainly because of backwards compatibility concerns, :mod:`configparser` "
"provides also a legacy API with explicit ``get``/``set`` methods.  While "
"there are valid use cases for the methods outlined below, mapping protocol "
"access is preferred for new projects.  The legacy API is at times more "
"advanced, low-level and downright counterintuitive."
msgstr ""
":mod:`configparser` proporciona también una API heredada con métodos ``get``/"
"``set`` explícitos; ello, principalmente debido a asuntos de compatibilidad "
"con versiones anteriores. Aunque existen casos de uso válidos para los "
"métodos descritos a continuación, se prefiere el acceso por protocolo de "
"mapeo para los proyectos nuevos. La API heredada es al mismo tiempo más "
"avanzada, de bajo nivel y sumamente contradictoria."

#: ../Doc/library/configparser.rst:819
msgid "An example of writing to a configuration file::"
msgstr "Un ejemplo de escritura a un archivo de configuración::"

#: ../Doc/library/configparser.rst:842
msgid "An example of reading the configuration file again::"
msgstr "Un ejemplo de lectura de un archivo de configuración, nuevamente::"

#: ../Doc/library/configparser.rst:860
msgid "To get interpolation, use :class:`ConfigParser`::"
msgstr "Para obtener la interpolación, utilice :class:`ConfigParser`::"

#: ../Doc/library/configparser.rst:893
msgid ""
"Default values are available in both types of ConfigParsers.  They are used "
"in interpolation if an option used is not defined elsewhere. ::"
msgstr ""
"Los valores por defecto están disponibles en ambos tipos de ConfigParsers. "
"Ellos son utilizados en la interpolación cuando una opción utilizada no está "
"definida en otro lugar. ::"

#: ../Doc/library/configparser.rst:911
msgid "ConfigParser Objects"
msgstr "Objetos ConfigParser"

#: ../Doc/library/configparser.rst:915
msgid ""
"The main configuration parser.  When *defaults* is given, it is initialized "
"into the dictionary of intrinsic defaults.  When *dict_type* is given, it "
"will be used to create the dictionary objects for the list of sections, for "
"the options within a section, and for the default values."
msgstr ""
"La *config parser* principal. Si se proporciona *defaults*, su valor es "
"inicializado en el diccionario de valores por defecto intrínsecos. Si se "
"proporciona *dict_type*, se utiliza para crear el diccionario de objetos "
"para la lista de secciones, las opciones dentro de una sección, y los "
"valores por defecto."

#: ../Doc/library/configparser.rst:920
msgid ""
"When *delimiters* is given, it is used as the set of substrings that divide "
"keys from values.  When *comment_prefixes* is given, it will be used as the "
"set of substrings that prefix comments in otherwise empty lines. Comments "
"can be indented.  When *inline_comment_prefixes* is given, it will be used "
"as the set of substrings that prefix comments in non-empty lines."
msgstr ""
"Si se proporciona *delimiters*, se utiliza como un conjunto de cadenas de "
"caracteres que dividen las claves de los valores. Si se proporciona "
"*comment_prefixes*, se utiliza como un conjunto de cadenas de caracteres que "
"preceden a los comentarios, en líneas que estarían, de otro modo, vacías.  "
"Los comentarios pueden estar indentados. Si se proporciona "
"*inline_comment_prefixes*, se utiliza como un conjunto de cadenas de "
"caracteres que preceden a los comentarios en líneas que no están vacías."

#: ../Doc/library/configparser.rst:926
msgid ""
"When *strict* is ``True`` (the default), the parser won't allow for any "
"section or option duplicates while reading from a single source (file, "
"string or dictionary), raising :exc:`DuplicateSectionError` or :exc:"
"`DuplicateOptionError`.  When *empty_lines_in_values* is ``False`` (default: "
"``True``), each empty line marks the end of an option.  Otherwise, internal "
"empty lines of a multiline option are kept as part of the value. When "
"*allow_no_value* is ``True`` (default: ``False``), options without values "
"are accepted; the value held for these is ``None`` and they are serialized "
"without the trailing delimiter."
msgstr ""
"Cuando *strict* es ``True`` (por defecto), el *parser* no permitirá "
"duplicados en ninguna sección u opción, al realizar la lectura de una sola "
"fuente (archivo, cadena de caracteres o diccionario), generando una "
"excepción :exc:`DuplicateSectionError` ó :exc:`DuplicateOptionError`.  "
"Cuando *empty_lines_in_values* es ``False`` (valor por defecto: ``True``), "
"cada línea en blanco indica el fin de una opción.  De otro modo, las líneas "
"en blanco de una opción multilínea son tratadas como parte del valor de "
"esta. Cuando *allow_no_value* es ``True`` (valor por defecto: ``False``), se "
"aceptan opciones sin valores; el valor que toman esas opciones es ``None`` y "
"serán serializadas sin el delimitador final."

#: ../Doc/library/configparser.rst:936
msgid ""
"When *default_section* is given, it specifies the name for the special "
"section holding default values for other sections and interpolation purposes "
"(normally named ``\"DEFAULT\"``).  This value can be retrieved and changed "
"at runtime using the ``default_section`` instance attribute. This won't re-"
"evaluate an already parsed config file, but will be used when writing parsed "
"settings to a new config file."
msgstr ""
"Cuando se proporciona *default_section*, se define el nombre de la sección "
"especial que contiene valores por defecto para otras secciones y con "
"propósito de interpolación (habitualmente denominada ``\"DEFAULT\"``). Este "
"valor puede obtenerse y modificarse en tiempo de ejecución utilizando el "
"atributo de instancia ``default_section``. Esto no volverá a evaluar un "
"fichero de configuración previamente analizado sintácticamente (*parsed*), "
"pero se usará al escribir configuraciones de analizado sintáctico (*parsed*) "
"en un nuevo fichero de configuración."

#: ../Doc/library/configparser.rst:943
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_."
msgstr ""
"La interpolación puede personalizarse al proporcionar un gestor "
"personalizado, mediante el argumento *interpolation*. El valor ``None`` se "
"utiliza para desactivar la interpolación completamente, "
"``ExtendedInterpolation()`` proporciona una variante avanzada, inspirada en "
"``zc.buildout``. Más al respecto puede encontrarse en la `correspondiente "
"sección de la documentación <#interpolation-of-values>`_."

#: ../Doc/library/configparser.rst:949
#, python-format
msgid ""
"All option names used in interpolation will be passed through the :meth:"
"`optionxform` method just like any other option name reference.  For "
"example, using the default implementation of :meth:`optionxform` (which "
"converts option names to lower case), the values ``foo %(bar)s`` and ``foo "
"%(BAR)s`` are equivalent."
msgstr ""
"Todos los nombres de opción que se utilizan en la interpolación pasarán por "
"el método :meth:`optionxform`, igual que cualquier otra referencia a un "
"nombre de opción. Por lo tanto, si se utiliza la implementación por defecto "
"de :meth:`optionxform` (la cual convierte los nombres de opción a "
"minúsculas), los valores ``foo %(bar)s`` y ``foo %(BAR)s`` son equivalentes."

#: ../Doc/library/configparser.rst:955
msgid ""
"When *converters* is given, it should be a dictionary where each key "
"represents the name of a type converter and each value is a callable "
"implementing the conversion from string to the desired datatype.  Every "
"converter gets its own corresponding :meth:`get*()` method on the parser "
"object and section proxies."
msgstr ""
"Cuando se proporciona *converters*, este debe ser un diccionario, donde cada "
"clave representa el nombre de un conversor, y cada valor un invocable que "
"implementa la conversión de la cadena de caracteres al tipo de datos "
"deseado. Cada conversor recibe su método :meth:`get*()` correspondiente en "
"el objeto *parser* y los proxies de sección."

#: ../Doc/library/configparser.rst:961
msgid "The default *dict_type* is :class:`collections.OrderedDict`."
msgstr ""
"El valor por defecto de *dict_type* es :class:`collections.OrderedDict`."

#: ../Doc/library/configparser.rst:964
msgid ""
"*allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* and *interpolation* were added."
msgstr ""
"se agregaron los argumentos *allow_no_value*, *delimiters*, "
"*comment_prefixes*, *strict*, *empty_lines_in_values*, *default_section* y "
"*interpolation*."

#: ../Doc/library/configparser.rst:969
msgid "The *converters* argument was added."
msgstr "Se agregó el argumento *converters*."

#: ../Doc/library/configparser.rst:972
msgid ""
"The *defaults* argument is read with :meth:`read_dict()`, providing "
"consistent behavior across the parser: non-string keys and values are "
"implicitly converted to strings."
msgstr ""
"El argumento *defaults* es leído con :meth:`read_dict()`, proporcionando un "
"comportamiento consistente en el *parser*: las claves y valores que no sean "
"cadenas de caracteres son convertidas a tales."

#: ../Doc/library/configparser.rst:977 ../Doc/library/configparser.rst:1240
msgid ""
"The default *dict_type* is :class:`dict`, since it now preserves insertion "
"order."
msgstr ""
"El valor por defecto para *dict_type* es :class:`dict`, dado que este ahora "
"preserva el orden de inserción."

#: ../Doc/library/configparser.rst:983
msgid "Return a dictionary containing the instance-wide defaults."
msgstr ""
"Retorna un diccionario que contiene los valores por defecto para toda la "
"instancia."

#: ../Doc/library/configparser.rst:988
msgid ""
"Return a list of the sections available; the *default section* is not "
"included in the list."
msgstr ""
"Retorna una lista de las secciones disponibles; *default section* no se "
"incluye en la lista."

#: ../Doc/library/configparser.rst:994
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised.  The name of "
"the section must be a string; if not, :exc:`TypeError` is raised."
msgstr ""
"Agrega una sección llamada *section* a la instancia. Si ya existe una "
"sección con el nombre proporcionado, se genera la excepción :exc:"
"`DuplicateSectionError`. Si se suministra el nombre *default section*, se "
"genera la excepción :exc:`ValueError`. El nombre de la sección debe ser una "
"cadena de caracteres, de lo contrario, se genera la excepción :exc:"
"`TypeError`."

#: ../Doc/library/configparser.rst:999
msgid "Non-string section names raise :exc:`TypeError`."
msgstr ""
"Nombres de sección que no sean del tipo cadena de caracteres generan la "
"excepción :exc:`TypeError`."

#: ../Doc/library/configparser.rst:1005
msgid ""
"Indicates whether the named *section* is present in the configuration. The "
"*default section* is not acknowledged."
msgstr ""
"Indica si la sección de nombre *section* existe en la configuración. No se "
"permite *default section*."

#: ../Doc/library/configparser.rst:1011
msgid "Return a list of options available in the specified *section*."
msgstr "Retorna una lista de opciones disponibles en la sección especificada."

#: ../Doc/library/configparser.rst:1016
msgid ""
"If the given *section* exists, and contains the given *option*, return :"
"const:`True`; otherwise return :const:`False`.  If the specified *section* "
"is :const:`None` or an empty string, DEFAULT is assumed."
msgstr ""
"Si la sección indicada existe, y esta contiene las opción proporcionada, "
"retorna :const:`True`; de lo contrario, retorna :const:`False`. Si la "
"sección especificada es :const:`None` o una cadena de caracteres vacía, se "
"asume DEFAULT."

#: ../Doc/library/configparser.rst:1023
msgid ""
"Attempt to read and parse an iterable of filenames, returning a list of "
"filenames which were successfully parsed."
msgstr ""
"Intenta leer y analizar sintácticamente (*parse*) un iterable de nombres de "
"archivos, retornando una lista de nombres de archivos que han sido "
"analizados (*parsed*) con éxito."

#: ../Doc/library/configparser.rst:1026
msgid ""
"If *filenames* is a string, a :class:`bytes` object or a :term:`path-like "
"object`, it is treated as a single filename.  If a file named in *filenames* "
"cannot be opened, that file will be ignored.  This is designed so that you "
"can specify an iterable of potential configuration file locations (for "
"example, the current directory, the user's home directory, and some system-"
"wide directory), and all existing configuration files in the iterable will "
"be read."
msgstr ""
"Si *filenames* es una cadena de caracteres, un objeto :class:`bytes` o un :"
"term:`path-like object`, es tratado como un simple nombre de archivo. Si un "
"archivo mencionado en *filenames* no puede ser abierto, será ignorado. Está "
"diseñado de forma que puedas especificar un iterable de potenciales "
"ubicaciones para archivos de configuración (por ejemplo, el directorio "
"actual, el directorio *home* del usuario, o algún directorio del sistema), y "
"todos los archivos de configuración existentes serán leídos."

#: ../Doc/library/configparser.rst:1035
msgid ""
"If none of the named files exist, the :class:`ConfigParser` instance will "
"contain an empty dataset.  An application which requires initial values to "
"be loaded from a file should load the required file or files using :meth:"
"`read_file` before calling :meth:`read` for any optional files::"
msgstr ""
"Si no existe ninguno de los archivos mencionados, la instancia de :class:"
"`ConfigParser` contendrá un conjunto de datos vacío. Una aplicación que "
"requiera valores iniciales, que sean cargados desde un archivo,  deberá "
"cargar el(los) archivo(s) requerido(s) utilizando :meth:`read_file` antes de "
"llamar a :meth:`read` para cualquier otro archivo opcional::"

#: ../Doc/library/configparser.rst:1048
msgid ""
"The *encoding* parameter.  Previously, all files were read using the default "
"encoding for :func:`open`."
msgstr ""
"El parámetro *encoding*. Anteriormente, todos los archivos eran leídos "
"utilizando la codificación por defecto de la la función :func:`open`."

#: ../Doc/library/configparser.rst:1052
msgid "The *filenames* parameter accepts a :term:`path-like object`."
msgstr "El parámetro *filenames* acepta un :term:`path-like object`."

#: ../Doc/library/configparser.rst:1055
msgid "The *filenames* parameter accepts a :class:`bytes` object."
msgstr "El parámetro *filenames* acepta un objeto :class:`bytes`."

#: ../Doc/library/configparser.rst:1061
msgid ""
"Read and parse configuration data from *f* which must be an iterable "
"yielding Unicode strings (for example files opened in text mode)."
msgstr ""
"Leer y analizar (*parse*) los datos de configuración de *f*, el cual debe "
"ser un iterable que retorne cadenas de caracteres Unicode (por ejemplo, "
"archivos abiertos en modo texto)."

#: ../Doc/library/configparser.rst:1064
msgid ""
"Optional argument *source* specifies the name of the file being read.  If "
"not given and *f* has a :attr:`name` attribute, that is used for *source*; "
"the default is ``'<???>'``."
msgstr ""
"El argumento opcional *source* especifica el nombre del archivo que se está "
"leyendo. Si no se proporciona y *f* tiene un atributo :attr:`name`, este es "
"utilizado como *source*; el valor por defecto es ``'<???>'``."

#: ../Doc/library/configparser.rst:1068
msgid "Replaces :meth:`readfp`."
msgstr "Reemplaza a :meth:`readfp`."

#: ../Doc/library/configparser.rst:1073
msgid "Parse configuration data from a string."
msgstr ""
"Analiza (*parse*) los datos de configuración desde una cadena de caracteres."

#: ../Doc/library/configparser.rst:1075
msgid ""
"Optional argument *source* specifies a context-specific name of the string "
"passed.  If not given, ``'<string>'`` is used.  This should commonly be a "
"filesystem path or a URL."
msgstr ""
"El argumento opcional *source* especifica un nombre para la cadena de "
"caracteres proporcionada, relativo al contexto. Si no se proporciona, se "
"utiliza ``'<string>'``. Esto, por lo general, debería ser una ruta de "
"archivo o una URL."

#: ../Doc/library/configparser.rst:1084
msgid ""
"Load configuration from any object that provides a dict-like ``items()`` "
"method.  Keys are section names, values are dictionaries with keys and "
"values that should be present in the section.  If the used dictionary type "
"preserves order, sections and their keys will be added in order. Values are "
"automatically converted to strings."
msgstr ""
"Carga la configuración a partir de cualquier objeto que proporcione un "
"método ``items()``, similar a un diccionario. Las claves son nombres de "
"secciones, los valores son diccionarios con claves y valores que deben estar "
"presentes en la sección. Si el tipo de diccionario utilizado preserva el "
"orden, las secciones y sus claves serán agregados en orden. Los valores son "
"convertidos a cadenas de caracteres de forma automática."

#: ../Doc/library/configparser.rst:1090
msgid ""
"Optional argument *source* specifies a context-specific name of the "
"dictionary passed.  If not given, ``<dict>`` is used."
msgstr ""
"El argumento opcional *source* especifica un nombre para el diccionario "
"proporcionado, relativo al contexto. Si no se proporciona, se utiliza "
"``<dict>``."

#: ../Doc/library/configparser.rst:1093
msgid "This method can be used to copy state between parsers."
msgstr "Este método puede utilizarse para copiar el estado entre *parsers*."

#: ../Doc/library/configparser.rst:1100
msgid ""
"Get an *option* value for the named *section*.  If *vars* is provided, it "
"must be a dictionary.  The *option* is looked up in *vars* (if provided), "
"*section*, and in *DEFAULTSECT* in that order.  If the key is not found and "
"*fallback* is provided, it is used as a fallback value.  ``None`` can be "
"provided as a *fallback* value."
msgstr ""
"Obtiene el valor de una *option* para la sección indicada. Si se proporciona "
"*vars*, tiene que ser un diccionario. El valor de *option* será buscado en "
"*vars* (si se proporciona), en *section* y en *DEFAULTSECT*, en ese orden. "
"Si la clave no se encuentra, y se ha proporcionado *fallback*, este es "
"utilizado como un valor de contingencia. Se puede utilizar ``None`` como "
"valor de contingencia (*fallback*)."

#: ../Doc/library/configparser.rst:1106
msgid ""
"All the ``'%'`` interpolations are expanded in the return values, unless the "
"*raw* argument is true.  Values for interpolation keys are looked up in the "
"same manner as the option."
msgstr ""
"Todas las interpolaciones ``'%'`` son expandidas en el valor retornado, a "
"menos que el argumento *raw* sea *true*. Los valores para la interpolación "
"de las claves son buscados de la misma forma que para la opción."

#: ../Doc/library/configparser.rst:1110
msgid ""
"Arguments *raw*, *vars* and *fallback* are keyword only to protect users "
"from trying to use the third argument as the *fallback* fallback (especially "
"when using the mapping protocol)."
msgstr ""
"Los argumentos *raw*, *vars* y *fallback* son argumentos nombrados "
"solamente, a fin de proteger a los usuarios de los intentos de emplear el "
"tercer argumento como el valor de contingencia de *fallback* (especialmente "
"cuando se utiliza el protocolo de mapeo)."

#: ../Doc/library/configparser.rst:1118
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to an integer.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"Un cómodo método para forzar a entero el valor de la opción de la sección "
"indicada. Revise :meth:`get` para una explicación acerca de *raw*, *vars* y "
"*fallback*."

#: ../Doc/library/configparser.rst:1125
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a floating point number.  See :meth:`get` for explanation of *raw*, "
"*vars* and *fallback*."
msgstr ""
"Un cómodo método para forzar a número de punto flotante el valor de la "
"opción de la sección indicada. Revise :meth:`get` para una explicación "
"acerca de *raw*, *vars* y *fallback*."

#: ../Doc/library/configparser.rst:1132
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a Boolean value.  Note that the accepted values for the option are "
"``'1'``, ``'yes'``, ``'true'``, and ``'on'``, which cause this method to "
"return ``True``, and ``'0'``, ``'no'``, ``'false'``, and ``'off'``, which "
"cause it to return ``False``.  These string values are checked in a case-"
"insensitive manner.  Any other value will cause it to raise :exc:"
"`ValueError`.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"Un cómodo método para forzar a booleano el valor de la opción de la sección "
"indicada. Tome nota que los valores aceptados para la opción son ``'1'``, "
"``'yes'``, ``'true'``, and ``'on'``, para que el método retorne ``True``, y "
"``'0'``, ``'no'``, ``'false'``, y ``'off'`` para que el método retorne "
"``False``. Esos valores de cadenas de caracteres son revisados sin "
"diferenciar mayúsculas de minúsculas. Cualquier otro valor ocasionará que se "
"genere la excepción :exc:`ValueError`. Revise :meth:`get` para una "
"explicación acerca de *raw*, *vars* y *fallback*."

#: ../Doc/library/configparser.rst:1145
msgid ""
"When *section* is not given, return a list of *section_name*, "
"*section_proxy* pairs, including DEFAULTSECT."
msgstr ""
"Cuando no se proporciona el argumento *section*, retorna una lista de pares "
"*section_name*, *section_proxy*, incluyendo DEFAULTSECT."

#: ../Doc/library/configparser.rst:1148
msgid ""
"Otherwise, return a list of *name*, *value* pairs for the options in the "
"given *section*.  Optional arguments have the same meaning as for the :meth:"
"`get` method."
msgstr ""
"De lo contrario, retorna una lista de pares *name*, *value* para las "
"opciones de la sección especificada. Los argumentos opcionales tienen el "
"mismo significado que en el método :meth:`get`."

#: ../Doc/library/configparser.rst:1152
msgid ""
"Items present in *vars* no longer appear in the result.  The previous "
"behaviour mixed actual parser options with variables provided for "
"interpolation."
msgstr ""
"Los elementos que estén en *vars* no aparecen en el resultado. El "
"comportamiento previo mezcla las opciones actuales del *parser* con las "
"variables proporcionadas para la interpolación."

#: ../Doc/library/configparser.rst:1160
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  *option* and *value* must be "
"strings; if not, :exc:`TypeError` is raised."
msgstr ""
"Si la sección indicada existe, asigna el valor especificado a la opción "
"indicada; en caso contrario, genera la excepción :exc:`NoSectionError`. "
"*option* y *value* deben ser cadenas de caracteres; de lo contrario, se "
"genera la excepción :exc:`TypeError`."

#: ../Doc/library/configparser.rst:1167
msgid ""
"Write a representation of the configuration to the specified :term:`file "
"object`, which must be opened in text mode (accepting strings).  This "
"representation can be parsed by a future :meth:`read` call.  If "
"*space_around_delimiters* is true, delimiters between keys and values are "
"surrounded by spaces."
msgstr ""
"Escribe una representación de la configuración al :term:`file object` "
"especificado, el cual debe ser abierto en modo texto (aceptando cadenas de "
"caracteres). Esta representación puede ser analizada (*parsed*) por una "
"posterior llamada a :meth:`read`. Si *space_around_delimiters* es *true*, "
"los delimitadores entre claves y valores son rodeados por espacios."

#: ../Doc/library/configparser.rst:1175
msgid ""
"Comments in the original configuration file are not preserved when writing "
"the configuration back. What is considered a comment, depends on the given "
"values for *comment_prefix* and *inline_comment_prefix*."
msgstr ""
"Los comentarios presentes en el fichero original no se mantienen cuando se "
"vuelve a escribir la configuración. Qué es considerado un comentario depende "
"de los valores asignados a *comment_prefix* e *inline_comment_prefix*."

#: ../Doc/library/configparser.rst:1183
msgid ""
"Remove the specified *option* from the specified *section*.  If the section "
"does not exist, raise :exc:`NoSectionError`.  If the option existed to be "
"removed, return :const:`True`; otherwise return :const:`False`."
msgstr ""
"Elimina la opción especificada de la sección indicada. Si la sección no "
"existe, se genera una excepción :exc:`NoSectionError`. Si la opción existía "
"antes de la eliminación, retorna :const:`True`; de lo contrario retorna :"
"const:`False`."

#: ../Doc/library/configparser.rst:1191
msgid ""
"Remove the specified *section* from the configuration.  If the section in "
"fact existed, return ``True``.  Otherwise return ``False``."
msgstr ""
"Elimina la sección especificada de la configuración. Si la sección existía, "
"retorna ``True``. De lo contrario, retorna ``False``."

#: ../Doc/library/configparser.rst:1197
msgid ""
"Transforms the option name *option* as found in an input file or as passed "
"in by client code to the form that should be used in the internal "
"structures.  The default implementation returns a lower-case version of "
"*option*; subclasses may override this or client code can set an attribute "
"of this name on instances to affect this behavior."
msgstr ""
"Transforma el nombre de opción *option* de la forma en que se encontraba en "
"el archivo de entrada o como fue pasada por el código del cliente, a la "
"forma en que debe ser utilizada en las estructuras internas. La "
"implementación por defecto retorna una versión en minúsculas de *option*; "
"las subclases pueden sobre-escribirla o el código del cliente puede asignar "
"un atributo de su nombre en las instancias, para afectar su comportamiento."

#: ../Doc/library/configparser.rst:1203
msgid ""
"You don't need to subclass the parser to use this method, you can also set "
"it on an instance, to a function that takes a string argument and returns a "
"string.  Setting it to ``str``, for example, would make option names case "
"sensitive::"
msgstr ""
"No necesitas crear una subclase del *parser* para utilizar este método, ya "
"que también puedes asignarlo en una instancia a una función, la cual reciba "
"una cadena de caracteres como argumento y retorne otra. Por ejemplo, "
"estableciéndola a ``str``, se hará que los nombres de opciones sean "
"sensibles a mayúsculas y minúsculas::"

#: ../Doc/library/configparser.rst:1211
msgid ""
"Note that when reading configuration files, whitespace around the option "
"names is stripped before :meth:`optionxform` is called."
msgstr ""
"Tome en cuenta que cuando se leen archivos de configuración, los espacios en "
"blanco alrededor de los nombres de opción son eliminados antes de llamar a :"
"meth:`optionxform`."

#: ../Doc/library/configparser.rst:1217
msgid ""
"The maximum depth for recursive interpolation for :meth:`get` when the *raw* "
"parameter is false.  This is relevant only when the default *interpolation* "
"is used."
msgstr ""
"La profundidad máxima de interpolación para :meth:`get` cuando el parámetro "
"*raw* es *false*. Esto es de importancia solamente cuando la interpolación "
"por defecto es empleada."

#: ../Doc/library/configparser.rst:1225
msgid "RawConfigParser Objects"
msgstr "Objetos RawConfigParser"

#: ../Doc/library/configparser.rst:1235
msgid ""
"Legacy variant of the :class:`ConfigParser`.  It has interpolation disabled "
"by default and allows for non-string section names, option names, and values "
"via its unsafe ``add_section`` and ``set`` methods, as well as the legacy "
"``defaults=`` keyword argument handling."
msgstr ""
"Variante heredada de :class:`ConfigParser`. Tiene la interpolación "
"deshabilitada por defecto y permite nombres de sección que no sean cadenas "
"de caracteres, nombres de opciones, y valores a través de sus métodos "
"inseguros ``add_section`` y ``set``, así como el manejo heredado del "
"argumento nombrado ``defaults=``."

#: ../Doc/library/configparser.rst:1245
msgid ""
"Consider using :class:`ConfigParser` instead which checks types of the "
"values to be stored internally.  If you don't want interpolation, you can "
"use ``ConfigParser(interpolation=None)``."
msgstr ""
"Considere el uso de :class:`ConfigParser` en su lugar, el cual verifica los "
"tipos de datos de los valores que se almacenarán internamente. Si no quieres "
"la interpolación, puedes utilizar ``ConfigParser(interpolation=None)``."

#: ../Doc/library/configparser.rst:1252
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised."
msgstr ""
"Agrega a la instancia una sección de nombre *section*. Si ya existe una "
"sección con el nombre proporcionado, se genera la excepción :exc:"
"`DuplicateSectionError`. Si se suministra el nombre *default section*, se "
"genera la excepción :exc:`ValueError`."

#: ../Doc/library/configparser.rst:1256
msgid ""
"Type of *section* is not checked which lets users create non-string named "
"sections.  This behaviour is unsupported and may cause internal errors."
msgstr ""
"No se comprueba el tipo de datos de *section*, con lo cual se permite que "
"los usuarios creen secciones con nombres que no sean cadenas de caracteres. "
"Este comportamiento no está soportado y puede ocasionar errores internos."

#: ../Doc/library/configparser.rst:1262
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  While it is possible to use :class:"
"`RawConfigParser` (or :class:`ConfigParser` with *raw* parameters set to "
"true) for *internal* storage of non-string values, full functionality "
"(including interpolation and output to files) can only be achieved using "
"string values."
msgstr ""
"Si existe la sección indicada, asigna el valor especificado a la sección "
"indicada; de lo contrario, genera la excepción :exc:`NoSectionError`. Aunque "
"es posible utilizar :class:`RawConfigParser` (ó :class:`ConfigParser` con "
"parámetros *raw* con valor *true*) como almacenamiento interno para valores "
"que no sean cadenas de caracteres, el funcionamiento completo (incluyendo la "
"interpolación y escritura en archivos) sólo puede lograrse utilizando "
"valores del tipo cadena de caracteres."

#: ../Doc/library/configparser.rst:1269
msgid ""
"This method lets users assign non-string values to keys internally.  This "
"behaviour is unsupported and will cause errors when attempting to write to a "
"file or get it in non-raw mode.  **Use the mapping protocol API** which does "
"not allow such assignments to take place."
msgstr ""
"Este método permite que los usuarios asignen valores que no sean cadenas de "
"caracteres a las claves, internamente. Este comportamiento no está soportado "
"y causará errores cuando se intente escribir en un archivo o cuando se "
"intente obtenerlo en un modo no *raw*. **Utilice la API del protocolo de "
"mapeo**, la cual no permite ese tipo de asignaciones."

#: ../Doc/library/configparser.rst:1276
msgid "Exceptions"
msgstr "Excepciones"

#: ../Doc/library/configparser.rst:1280
msgid "Base class for all other :mod:`configparser` exceptions."
msgstr "Clase base para todas las otras excepciones :mod:`configparser`."

#: ../Doc/library/configparser.rst:1285
msgid "Exception raised when a specified section is not found."
msgstr "Excepción generada cuando no se encuentra una sección especificada."

#: ../Doc/library/configparser.rst:1290
msgid ""
"Exception raised if :meth:`add_section` is called with the name of a section "
"that is already present or in strict parsers when a section if found more "
"than once in a single input file, string or dictionary."
msgstr ""
"Excepción generada si el método :meth:`add_section` es llamado "
"proporcionando el nombre de una sección que ya existe, o, en caso de "
"*parsers* estrictos, si una sección se encuentra más de una vez en un solo "
"archivo de entrada, cadena de caracteres o diccionario."

#: ../Doc/library/configparser.rst:1294
msgid ""
"Optional ``source`` and ``lineno`` attributes and arguments to :meth:"
"`__init__` were added."
msgstr ""
"Al método :meth:`__init__` se agregaron los atributos y argumentos "
"opcionales ``source`` y ``lineno``."

#: ../Doc/library/configparser.rst:1301
msgid ""
"Exception raised by strict parsers if a single option appears twice during "
"reading from a single file, string or dictionary. This catches misspellings "
"and case sensitivity-related errors, e.g. a dictionary may have two keys "
"representing the same case-insensitive configuration key."
msgstr ""
"Excepción generada por *parsers* estrictos si una sola opción aparece dos "
"veces durante la lectura de un solo archivo, cadena de caracteres o "
"diccionario. Captura errores de escritura o relacionados con el uso de "
"mayúsculas y minúsculas, ej. un diccionario podría tener dos claves que "
"representan la misma clave de configuración bajo un esquema insensible a "
"mayúsculas y minúsculas."

#: ../Doc/library/configparser.rst:1309
msgid ""
"Exception raised when a specified option is not found in the specified "
"section."
msgstr ""
"Excepción generada cuando una opción especificada no se encuentra en una "
"sección indicada."

#: ../Doc/library/configparser.rst:1315
msgid ""
"Base class for exceptions raised when problems occur performing string "
"interpolation."
msgstr ""
"Clase base para excepciones generadas por problemas que ocurren al realizar "
"la interpolación de cadenas de caracteres."

#: ../Doc/library/configparser.rst:1321
msgid ""
"Exception raised when string interpolation cannot be completed because the "
"number of iterations exceeds :const:`MAX_INTERPOLATION_DEPTH`.  Subclass of :"
"exc:`InterpolationError`."
msgstr ""
"Excepción generada cuando la interpolación de cadenas de caracteres no puede "
"completarse, debido a que el número de iteraciones excede a :const:"
"`MAX_INTERPOLATION_DEPTH`. Subclase de :exc:`InterpolationError`."

#: ../Doc/library/configparser.rst:1328
msgid ""
"Exception raised when an option referenced from a value does not exist. "
"Subclass of :exc:`InterpolationError`."
msgstr ""
"Excepción generada cuando no existe una opción referida por un valor. "
"Subclase de :exc:`InterpolationError`."

#: ../Doc/library/configparser.rst:1334
msgid ""
"Exception raised when the source text into which substitutions are made does "
"not conform to the required syntax.  Subclass of :exc:`InterpolationError`."
msgstr ""
"Excepción generada cuando el texto fuente, donde se realizan las "
"sustituciones, no se ajusta a la sintaxis requerida. Subclase de :exc:"
"`InterpolationError`."

#: ../Doc/library/configparser.rst:1340
msgid ""
"Exception raised when attempting to parse a file which has no section "
"headers."
msgstr ""
"Excepción generada cuando se intenta analizar (*parse*) un archivo que no "
"tiene encabezados de sección."

#: ../Doc/library/configparser.rst:1346
msgid "Exception raised when errors occur attempting to parse a file."
msgstr ""
"Excepción generada cuando ocurren errores intentando analizar (*parse*) un "
"archivo."

#: ../Doc/library/configparser.rst:1348
msgid ""
"The ``filename`` attribute and :meth:`__init__` constructor argument were "
"removed.  They have been available using the name ``source`` since 3.2."
msgstr ""
"El atributo ``filename`` y el argumento del constructor :meth:`__init__` "
"fueron eliminados. Estos han estado disponibles usando el nombre ``source`` "
"desde 3.2."

#: ../Doc/library/configparser.rst:1353
msgid "Footnotes"
msgstr "Notas al pie"

#: ../Doc/library/configparser.rst:1354
msgid ""
"Config parsers allow for heavy customization.  If you are interested in "
"changing the behaviour outlined by the footnote reference, consult the "
"`Customizing Parser Behaviour`_ section."
msgstr ""
"Los *config parsers* permiten una gran personalización. Si estás interesado "
"en modificar el comportamiento descrito por la referencia de la nota al pie, "
"consulta la sección `Customizing Parser Behaviour`_."

#: ../Doc/library/configparser.rst:16
msgid ".ini"
msgstr ".ini"

#: ../Doc/library/configparser.rst:16
msgid "file"
msgstr "file"

#: ../Doc/library/configparser.rst:16
msgid "configuration"
msgstr "configuration"

#: ../Doc/library/configparser.rst:16
msgid "ini file"
msgstr "ini file"

#: ../Doc/library/configparser.rst:16
msgid "Windows ini file"
msgstr "Windows ini file"

#: ../Doc/library/configparser.rst:335
msgid "% (percent)"
msgstr "% (percent)"

#: ../Doc/library/configparser.rst:335 ../Doc/library/configparser.rst:368
msgid "interpolation in configuration files"
msgstr "interpolation in configuration files"

#: ../Doc/library/configparser.rst:368
msgid "$ (dollar)"
msgstr "$ (dollar)"

#~ msgid "Use :meth:`read_file` instead."
#~ msgstr "Utilice :meth:`read_file` en su lugar."

#~ msgid ""
#~ ":meth:`readfp` now iterates on *fp* instead of calling ``fp.readline()``."
#~ msgstr ""
#~ "Ahora, :meth:`readfp` itera sobre *fp*, en lugar de llamar a ``fp."
#~ "readline()``."

#~ msgid ""
#~ "For existing code calling :meth:`readfp` with arguments which don't "
#~ "support iteration, the following generator may be used as a wrapper "
#~ "around the file-like object::"
#~ msgstr ""
#~ "Para el código existente, que llama a :meth:`readfp` sin argumentos que "
#~ "soporten la iteración, el siguiente generador puede utilizarse como un "
#~ "envoltorio (*wrapper*) para el objeto semejante a archivo::"

#~ msgid ""
#~ "Instead of ``parser.readfp(fp)`` use ``parser."
#~ "read_file(readline_generator(fp))``."
#~ msgstr ""
#~ "Utilice ``parser.read_file(readline_generator(fp))`` en lugar de ``parser."
#~ "readfp(fp)``."
