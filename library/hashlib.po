# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org / https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-06 11:59-0400\n"
"PO-Revision-Date: 2020-10-29 14:39+0100\n"
"Last-Translator: Álvaro Mondéjar <mondejar1994@gmail.com>\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es\n"
"X-Generator: Poedit 2.4.1\n"

#: ../Doc/library/hashlib.rst:2
msgid ":mod:`hashlib` --- Secure hashes and message digests"
msgstr ":mod:`hashlib` --- Hashes seguros y resúmenes de mensajes"

#: ../Doc/library/hashlib.rst:10
msgid "**Source code:** :source:`Lib/hashlib.py`"
msgstr "**Código fuente:** :source:`Lib/hashlib.py`"

#: ../Doc/library/hashlib.rst:23
msgid ""
"This module implements a common interface to many different secure hash and "
"message digest algorithms.  Included are the FIPS secure hash algorithms "
"SHA1, SHA224, SHA256, SHA384, and SHA512 (defined in FIPS 180-2) as well as "
"RSA's MD5 algorithm (defined in Internet :rfc:`1321`).  The terms \"secure "
"hash\" and \"message digest\" are interchangeable.  Older algorithms were "
"called message digests.  The modern term is secure hash."
msgstr ""
"Este módulo implementa una interfaz común a diferentes algoritmos de hash y "
"resúmenes de mensajes seguros. Están incluidos los algoritmos de hash FIPS "
"seguros SHA1, SHA224, SHA226, SHA384 y SHA512 (definidos en FIPS 180-2) "
"además del algoritmo MD5 de RSA (definido en Internet :rfc:`1321`). Los "
"términos \"hash seguro\" y \"resumen de mensaje\" son intercambiables. Los "
"algoritmos más antiguos fueron denominados resúmenes de mensajes. El término "
"moderno es hash seguro."

#: ../Doc/library/hashlib.rst:32
msgid ""
"If you want the adler32 or crc32 hash functions, they are available in the :"
"mod:`zlib` module."
msgstr ""
"Si quieres las funciones de hash adler32 o crc32, están disponibles en el "
"módulo :mod:`zlib`."

#: ../Doc/library/hashlib.rst:37
msgid ""
"Some algorithms have known hash collision weaknesses, refer to the \"See also"
"\" section at the end."
msgstr ""
"Algunos algoritmos tienen conocidas debilidades de colisión de hash, "
"consulte la sección \"Ver también\" al final."

#: ../Doc/library/hashlib.rst:44
msgid "Hash algorithms"
msgstr "Algoritmos de hash"

#: ../Doc/library/hashlib.rst:46
msgid ""
"There is one constructor method named for each type of :dfn:`hash`.  All "
"return a hash object with the same simple interface. For example: use :func:"
"`sha256` to create a SHA-256 hash object. You can now feed this object with :"
"term:`bytes-like objects <bytes-like object>` (normally :class:`bytes`) "
"using the :meth:`update` method. At any point you can ask it for the :dfn:"
"`digest` of the concatenation of the data fed to it so far using the :meth:"
"`digest` or :meth:`hexdigest` methods."
msgstr ""
"Hay un método constructor nombrado para cada tipo de :dfn:`hash`. Todos "
"retornan un objeto de hash con la misma interfaz simple. Por ejemplo, usa :"
"func:`sha256` para crear un objeto de hash SHA-256. Ahora puedes alimentar "
"este objeto con :term:`objetos como bytes <bytes-like object>` (normalmente :"
"class:`bytes`) usando el método :meth:`update`. En cualquier punto puedes "
"pedir el resumen (:dfn:`digest`) de la concatenación de los datos "
"alimentados al mismo usando los métodos :meth:`digest` o :meth:`hexdigest`."

#: ../Doc/library/hashlib.rst:56
msgid ""
"For better multithreading performance, the Python :term:`GIL` is released "
"for data larger than 2047 bytes at object creation or on update."
msgstr ""
"Para un rendimiento multihilo mejor, el :term:`GIL` de Python es liberado "
"para datos superiores a 2047 bytes en la creación o actualización de objetos."

#: ../Doc/library/hashlib.rst:61
msgid ""
"Feeding string objects into :meth:`update` is not supported, as hashes work "
"on bytes, not on characters."
msgstr ""
"La alimentación de objetos de cadenas en :meth:`update` no está soportada, "
"ya que los hashes funcionan en bytes, no en caracteres."

#: ../Doc/library/hashlib.rst:66
msgid ""
"Constructors for hash algorithms that are always present in this module are :"
"func:`sha1`, :func:`sha224`, :func:`sha256`, :func:`sha384`, :func:"
"`sha512`, :func:`blake2b`, and :func:`blake2s`. :func:`md5` is normally "
"available as well, though it may be missing if you are using a rare \"FIPS "
"compliant\" build of Python. Additional algorithms may also be available "
"depending upon the OpenSSL library that Python uses on your platform. On "
"most platforms the :func:`sha3_224`, :func:`sha3_256`, :func:`sha3_384`, :"
"func:`sha3_512`, :func:`shake_128`, :func:`shake_256` are also available."
msgstr ""
"Los constructores para algoritmos de hash siempre presentes en este módulo "
"son :func:`sha1`, :func:`sha224`, :func:`sha256`, :func:`sha384`, :func:"
"`sha512`, :func:`blake2b` y :func:`blake2s`. :func:`md5` también está "
"disponible normalmente, aunque puede faltar si estás usando una construcción "
"de Python que cumple de forma rara con los requisitos FIPS. Algoritmos "
"adicionales también pueden estar disponibles dependiendo de la biblioteca "
"OpenSSL que Python usa en tu plataforma. En la mayoría de plataformas las "
"funciones :func:`sha3_224`, :func:`sha3_256`, :func:`sha3_384`, :func:"
"`sha3_512`, :func:`shake_128` y :func:`shake_256` también están disponibles."

#: ../Doc/library/hashlib.rst:76
msgid ""
"SHA3 (Keccak) and SHAKE constructors :func:`sha3_224`, :func:`sha3_256`, :"
"func:`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256`."
msgstr ""
"Constructores SHA3 (Keccak) y SHAKE :func:`sha3_224`, :func:`sha3_256`, :"
"func:`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256`."

#: ../Doc/library/hashlib.rst:80
msgid ":func:`blake2b` and :func:`blake2s` were added."
msgstr "Fueron añadidas :func:`blake2b` y :func:`blake2s`."

#: ../Doc/library/hashlib.rst:83
msgid ""
"For example, to obtain the digest of the byte string ``b'Nobody inspects the "
"spammish repetition'``::"
msgstr ""
"Por ejemplo, para obtener el resumen de la cadena de bytes ``b'Nobody "
"inspects the spammish repetition'``::"

#: ../Doc/library/hashlib.rst:97
msgid "More condensed:"
msgstr "Más resumido:"

#: ../Doc/library/hashlib.rst:104
msgid ""
"Is a generic constructor that takes the string *name* of the desired "
"algorithm as its first parameter.  It also exists to allow access to the "
"above listed hashes as well as any other algorithms that your OpenSSL "
"library may offer.  The named constructors are much faster than :func:`new` "
"and should be preferred."
msgstr ""
"Es un constructor genérico que toma la cadena *name* del algoritmo deseado "
"como su primer parámetro. También existe para permitir acceso a los hashes "
"arriba listados así como cualquiera de los otros algoritmos que tu "
"biblioteca OpenSSL puede ofrecer. Los constructores nombrados son mucho más "
"rápidos que :func:`new` y deberían preferirse."

#: ../Doc/library/hashlib.rst:110
msgid "Using :func:`new` with an algorithm provided by OpenSSL:"
msgstr "Usando :func:`new` con un algoritmo provisto por OpenSSL:"

#: ../Doc/library/hashlib.rst:117
msgid "Hashlib provides the following constant attributes:"
msgstr "Hashlib provee los siguientes atributos constantes:"

#: ../Doc/library/hashlib.rst:121
msgid ""
"A set containing the names of the hash algorithms guaranteed to be supported "
"by this module on all platforms.  Note that 'md5' is in this list despite "
"some upstream vendors offering an odd \"FIPS compliant\" Python build that "
"excludes it."
msgstr ""
"Un conjunto que contiene los nombres de los algoritmos garantizados a ser "
"soportados por este módulo en todas las plataformas. Ten en cuenta que 'md5' "
"se encuentra en esta lista a pesar de que algunos proveedores ofrecen una "
"extraña construcción Python \"compatible con FIPS\" que la excluye."

#: ../Doc/library/hashlib.rst:130
msgid ""
"A set containing the names of the hash algorithms that are available in the "
"running Python interpreter.  These names will be recognized when passed to :"
"func:`new`.  :attr:`algorithms_guaranteed` will always be a subset.  The "
"same algorithm may appear multiple times in this set under different names "
"(thanks to OpenSSL)."
msgstr ""
"Un conjunto que contiene los nombres de los algoritmos de hash que están "
"disponibles en el intérprete de Python en ejecución. Estos nombres serán "
"reconocidos cuando sean pasados a :func:`new`. :attr:`algorithms_guaranteed` "
"siempre será un subconjunto. El mismo algoritmo puede aparecer múltiples "
"veces en este conjunto bajo diferentes nombres (gracias a OpenSSL)."

#: ../Doc/library/hashlib.rst:138
msgid ""
"The following values are provided as constant attributes of the hash objects "
"returned by the constructors:"
msgstr ""
"Los siguientes valores son provistos como atributos constantes de los "
"objetos hash retornados por los constructores:"

#: ../Doc/library/hashlib.rst:144
msgid "The size of the resulting hash in bytes."
msgstr "El tamaño del hash resultante en bytes."

#: ../Doc/library/hashlib.rst:148
msgid "The internal block size of the hash algorithm in bytes."
msgstr "El tamaño del bloque interno del algoritmo de hash en bytes."

#: ../Doc/library/hashlib.rst:150
msgid "A hash object has the following attributes:"
msgstr "Un objeto hash tiene los siguientes atributos:"

#: ../Doc/library/hashlib.rst:154
msgid ""
"The canonical name of this hash, always lowercase and always suitable as a "
"parameter to :func:`new` to create another hash of this type."
msgstr ""
"El nombre canónico de este hash, siempre en minúsculas y siempre adecuado "
"como un parámetro a :func:`new` para crear otro hash de este tipo."

#: ../Doc/library/hashlib.rst:157
msgid ""
"The name attribute has been present in CPython since its inception, but "
"until Python 3.4 was not formally specified, so may not exist on some "
"platforms."
msgstr ""
"El atributo *name* ha estado presente en CPython desde su inicio, pero desde "
"Python 3.4 no fue especificado formalmente, por lo que puede no existir en "
"algunas plataformas."

#: ../Doc/library/hashlib.rst:162
msgid "A hash object has the following methods:"
msgstr "Un objeto hash tiene los siguientes métodos:"

#: ../Doc/library/hashlib.rst:167
msgid ""
"Update the hash object with the :term:`bytes-like object`. Repeated calls "
"are equivalent to a single call with the concatenation of all the arguments: "
"``m.update(a); m.update(b)`` is equivalent to ``m.update(a+b)``."
msgstr ""
"Actualiza el objeto de hash con el :term:`bytes-like object`. Invocaciones "
"repetidas son equivalentes a una única invocación con la concatenación de "
"todos los argumentos: ``m.update(a); m.update(b)`` es equivalente a ``m."
"update(a+b)``."

#: ../Doc/library/hashlib.rst:172
msgid ""
"The Python GIL is released to allow other threads to run while hash updates "
"on data larger than 2047 bytes is taking place when using hash algorithms "
"supplied by OpenSSL."
msgstr ""
"El GIL de Python es liberado para permitir a otros hilos ejecutarse mientras "
"ocurren actualizaciones de hash en datos con tamaños superiores a 2047 bytes "
"cuando se usan algoritmos de hash suministrados por OpenSSL."

#: ../Doc/library/hashlib.rst:180
msgid ""
"Return the digest of the data passed to the :meth:`update` method so far. "
"This is a bytes object of size :attr:`digest_size` which may contain bytes "
"in the whole range from 0 to 255."
msgstr ""
"Retorna el resumen de los datos pasados al método :meth:`update` hasta el "
"momento. Este es un objeto de bytes de tamaño :attr:`digest_size` el cual "
"puede contener bytes en el rango completo desde 0 a 255."

#: ../Doc/library/hashlib.rst:187 ../Doc/library/hashlib.rst:215
msgid ""
"Like :meth:`digest` except the digest is returned as a string object of "
"double length, containing only hexadecimal digits.  This may be used to "
"exchange the value safely in email or other non-binary environments."
msgstr ""
"Como :meth:`digest` excepto que el resumen es retornado como un objeto de "
"cadena del doble de largo, conteniendo sólo dígitos hexadecimales. Este "
"puede ser usado para intercambiar el valor de forma segura en correos "
"electrónicos u otros entornos no binarios."

#: ../Doc/library/hashlib.rst:194
msgid ""
"Return a copy (\"clone\") of the hash object.  This can be used to "
"efficiently compute the digests of data sharing a common initial substring."
msgstr ""
"Retorna una copia (\"clon\") del objeto hash. Este puede ser usado para "
"calcular eficientemente los resúmenes de datos compartiendo una subcadena "
"inicial común."

#: ../Doc/library/hashlib.rst:199
msgid "SHAKE variable length digests"
msgstr "Resúmenes SHAKE de largo variable"

#: ../Doc/library/hashlib.rst:201
msgid ""
"The :func:`shake_128` and :func:`shake_256` algorithms provide variable "
"length digests with length_in_bits//2 up to 128 or 256 bits of security. As "
"such, their digest methods require a length. Maximum length is not limited "
"by the SHAKE algorithm."
msgstr ""
"Los algoritmos :func:`shake_128` y :func:`shake_256` proveen resúmenes de "
"largo variable con largo_en_bits//2 hasta 128 ó 256 bits de seguridad. Como "
"tales, sus métodos de resumen requieren un largo. El largo máximo no está "
"limitado por el algoritmo SHAKE."

#: ../Doc/library/hashlib.rst:208
msgid ""
"Return the digest of the data passed to the :meth:`update` method so far. "
"This is a bytes object of size *length* which may contain bytes in the whole "
"range from 0 to 255."
msgstr ""
"Retorna el resumen de los datos pasados al método :meth:`update` hasta el "
"momento. Este es un objeto de bytes de tamaño *length* el cual puede "
"contener bytes en el rango completo desde 0 a 255."

#: ../Doc/library/hashlib.rst:221
msgid "Key derivation"
msgstr "Derivación de clave"

#: ../Doc/library/hashlib.rst:223
msgid ""
"Key derivation and key stretching algorithms are designed for secure "
"password hashing. Naive algorithms such as ``sha1(password)`` are not "
"resistant against brute-force attacks. A good password hashing function must "
"be tunable, slow, and include a `salt <https://en.wikipedia.org/wiki/Salt_"
"%28cryptography%29>`_."
msgstr ""
"Los algoritmos de derivación de clave y estiramiento de clave están "
"diseñados para el cifrado seguro de contraseña. Algoritmos ingenuos como "
"``sha1(password)`` no son resistentes contra ataques de fuerza bruta. Una "
"buena función hash de contraseña debe ser afinable, lenta e incluir una `sal "
"<https://es.wikipedia.org/wiki/Sal_(criptograf%C3%ADa)>`_."

#: ../Doc/library/hashlib.rst:231
msgid ""
"The function provides PKCS#5 password-based key derivation function 2. It "
"uses HMAC as pseudorandom function."
msgstr ""
"La función provee contraseñas PKCS#5 basadas en función de derivación de "
"clave 2. Usa HMAC como función de pseudoaleatoriedad."

#: ../Doc/library/hashlib.rst:234
msgid ""
"The string *hash_name* is the desired name of the hash digest algorithm for "
"HMAC, e.g. 'sha1' or 'sha256'. *password* and *salt* are interpreted as "
"buffers of bytes. Applications and libraries should limit *password* to a "
"sensible length (e.g. 1024). *salt* should be about 16 or more bytes from a "
"proper source, e.g. :func:`os.urandom`."
msgstr ""
"La cadena *hash_name* es el nombre deseado del algoritmo de resumen de hash "
"para HMAC, ej. 'sha1' o 'sha256'. *password* y *salt* son interpretados como "
"búferes de bytes. Aplicaciones y bibliotecas deberían limitar *password* a "
"un largo razonable (ej. 1024). *salt* debería ser sobre 16 o más bytes desde "
"una fuente adecuada, ej. :func:`os.urandom`."

#: ../Doc/library/hashlib.rst:240
msgid ""
"The number of *iterations* should be chosen based on the hash algorithm and "
"computing power. As of 2013, at least 100,000 iterations of SHA-256 are "
"suggested."
msgstr ""
"El número de *iterations* debería ser elegido basado en el algoritmo de hash "
"y el poder de cómputo. A partir del 2013, se sugiere al menos 100,000 "
"iteraciones de SHA-256."

#: ../Doc/library/hashlib.rst:244
msgid ""
"*dklen* is the length of the derived key. If *dklen* is ``None`` then the "
"digest size of the hash algorithm *hash_name* is used, e.g. 64 for SHA-512."
msgstr ""
"*dklen* es el largo de la clave derivada. Si *dklen* es ``None`` entonces el "
"tamaño de resumen del algoritmo de hash *hash_name* es usado, ej. 64 para "
"SHA-512."

#: ../Doc/library/hashlib.rst:256
msgid ""
"A fast implementation of *pbkdf2_hmac* is available with OpenSSL.  The "
"Python implementation uses an inline version of :mod:`hmac`. It is about "
"three times slower and doesn't release the GIL."
msgstr ""
"Una implementación rápida de *pbkdf2_hmac* está disponible con OpenSSL. La "
"implementación Python usa una versión en línea de :mod:`hmac`. Es "
"aproximadamente tres veces más lenta y no libera el GIL."

#: ../Doc/library/hashlib.rst:262
msgid ""
"The function provides scrypt password-based key derivation function as "
"defined in :rfc:`7914`."
msgstr ""
"La función provee una contraseña scrypt basada en una función derivación de "
"clave como es definida en :rfc:`7914`."

#: ../Doc/library/hashlib.rst:265
msgid ""
"*password* and *salt* must be :term:`bytes-like objects <bytes-like "
"object>`.  Applications and libraries should limit *password* to a sensible "
"length (e.g. 1024).  *salt* should be about 16 or more bytes from a proper "
"source, e.g. :func:`os.urandom`."
msgstr ""
"*password* y *salt* deben ser :term:`objetos de bytes <bytes-like object>`. "
"Aplicaciones y bibliotecas deberían limitar *password* a un largo razonable "
"(ej. 1024). *salt* debería ser aproximadamente 16 o más bytes de una fuente "
"adecuada, ej. :func:`os.unrandom`."

#: ../Doc/library/hashlib.rst:270
msgid ""
"*n* is the CPU/Memory cost factor, *r* the block size, *p* parallelization "
"factor and *maxmem* limits memory (OpenSSL 1.1.0 defaults to 32 MiB). "
"*dklen* is the length of the derived key."
msgstr ""
"*n* es el factor de coste de CPU/Memoria, *r* el tamaño de bloque, *p* el "
"factor de paralelización y *maxmem* limita la memoria (OpenSSL 1.1.0 por "
"defecto a 32 MiB). *dklen* es el largo de la clave derivada."

#: ../Doc/library/hashlib.rst:275
msgid ":ref:`Availability <availability>`: OpenSSL 1.1+."
msgstr ":ref:`Disponibilidad <availability>`: OpenSSL 1.1+."

#: ../Doc/library/hashlib.rst:280
msgid "BLAKE2"
msgstr "BLAKE2"

#: ../Doc/library/hashlib.rst:287
msgid ""
"BLAKE2_ is a cryptographic hash function defined in :rfc:`7693` that comes "
"in two flavors:"
msgstr ""
"BLAKE2_ es una función de hash criptográfico definida en :rfc:`7693` que "
"viene en dos sabores:"

#: ../Doc/library/hashlib.rst:290
msgid ""
"**BLAKE2b**, optimized for 64-bit platforms and produces digests of any size "
"between 1 and 64 bytes,"
msgstr ""
"**BLAKE2b**, optimizada para plataformas de 64 bits y produce resúmenes de "
"cualquier tamaño entre 1 y 64 bytes,"

#: ../Doc/library/hashlib.rst:293
msgid ""
"**BLAKE2s**, optimized for 8- to 32-bit platforms and produces digests of "
"any size between 1 and 32 bytes."
msgstr ""
"**BLAKE2s**, optimizada para plataformas de 8 a 32 bits y produce resúmenes "
"de cualquier tamaño entre 1 y 32 bytes."

#: ../Doc/library/hashlib.rst:296
msgid ""
"BLAKE2 supports **keyed mode** (a faster and simpler replacement for HMAC_), "
"**salted hashing**, **personalization**, and **tree hashing**."
msgstr ""
"BLAKE2 proporciona el **modo keyed** (un remplazamiento más simple rápido "
"para HMAC_), **cifrado salado** (*salted hashing*), **personalización** y "
"**cifrado de árbol**."

#: ../Doc/library/hashlib.rst:299
msgid ""
"Hash objects from this module follow the API of standard library's :mod:"
"`hashlib` objects."
msgstr ""
"Los objetos hash de este módulo siguen los estándares de los objetos de la "
"biblioteca :mod:`hashlib`."

#: ../Doc/library/hashlib.rst:304
msgid "Creating hash objects"
msgstr "Creando objetos hash"

#: ../Doc/library/hashlib.rst:306
msgid "New hash objects are created by calling constructor functions:"
msgstr "Se crean nuevos objetos hash invocando a las funciones de constructor:"

#: ../Doc/library/hashlib.rst:318
msgid ""
"These functions return the corresponding hash objects for calculating "
"BLAKE2b or BLAKE2s. They optionally take these general parameters:"
msgstr ""
"Estas funciones retornan los objetos hash correspondientes para calcular "
"BLAKE2b o BLAKE2s. Ellas toman opcionalmente estos parámetros generales:"

#: ../Doc/library/hashlib.rst:321
msgid ""
"*data*: initial chunk of data to hash, which must be :term:`bytes-like "
"object`.  It can be passed only as positional argument."
msgstr ""
"*data*: trozo inicial de datos a cifrar, el cual debe ser un :term:`bytes-"
"like object`. Puede ser pasado sólo como argumento posicional."

#: ../Doc/library/hashlib.rst:324
msgid "*digest_size*: size of output digest in bytes."
msgstr "*digest_size*: tamaño del resumen de salida en bytes."

#: ../Doc/library/hashlib.rst:326
msgid ""
"*key*: key for keyed hashing (up to 64 bytes for BLAKE2b, up to 32 bytes for "
"BLAKE2s)."
msgstr ""
"*key*: clave para el cifrado de clave (*keyed hashing*) (hasta 64 bytes para "
"BLAKE2b, hasta 32 bytes para BLAKE2s)."

#: ../Doc/library/hashlib.rst:329
msgid ""
"*salt*: salt for randomized hashing (up to 16 bytes for BLAKE2b, up to 8 "
"bytes for BLAKE2s)."
msgstr ""
"*salt*: sal para el cifrado aleatorio (hasta 16 bytes para BLAKE2b, hasta 8 "
"bytes para BLAKE2s)."

#: ../Doc/library/hashlib.rst:332
msgid ""
"*person*: personalization string (up to 16 bytes for BLAKE2b, up to 8 bytes "
"for BLAKE2s)."
msgstr ""
"*person*: cadena de personalización (hasta 16 bytes para BLAKE2b, hasta 8 "
"bytes para BLAKE2s)."

#: ../Doc/library/hashlib.rst:335
msgid "The following table shows limits for general parameters (in bytes):"
msgstr ""
"La siguiente tabla muestra los límites para parámetros generales (en bytes):"

#: ../Doc/library/hashlib.rst:338
msgid "Hash"
msgstr "Cifrado"

#: ../Doc/library/hashlib.rst:338
msgid "digest_size"
msgstr "digest_size"

#: ../Doc/library/hashlib.rst:338
msgid "len(key)"
msgstr "len(key)"

#: ../Doc/library/hashlib.rst:338
msgid "len(salt)"
msgstr "len(salt)"

#: ../Doc/library/hashlib.rst:338
msgid "len(person)"
msgstr "len(person)"

#: ../Doc/library/hashlib.rst:340
msgid "BLAKE2b"
msgstr "BLAKE2b"

#: ../Doc/library/hashlib.rst:340
msgid "64"
msgstr "64"

#: ../Doc/library/hashlib.rst:340
msgid "16"
msgstr "16"

#: ../Doc/library/hashlib.rst:341
msgid "BLAKE2s"
msgstr "BLAKE2s"

#: ../Doc/library/hashlib.rst:341
msgid "32"
msgstr "32"

#: ../Doc/library/hashlib.rst:341
msgid "8"
msgstr "8"

#: ../Doc/library/hashlib.rst:346
msgid ""
"BLAKE2 specification defines constant lengths for salt and personalization "
"parameters, however, for convenience, this implementation accepts byte "
"strings of any size up to the specified length. If the length of the "
"parameter is less than specified, it is padded with zeros, thus, for "
"example, ``b'salt'`` and ``b'salt\\x00'`` is the same value. (This is not "
"the case for *key*.)"
msgstr ""
"La especificación BLAKE2 define largos constantes para los parámetros de sal "
"y personalización, sin embargo, por conveniencia, esta implementación acepta "
"cadenas de bytes de cualquier tamaño hasta el largo especificado. Si el "
"largo del parámetro es menor que el especificado, es acolchado con ceros, "
"por lo tanto, por ejemplo, ``b'salt'`` y ``b'salt\\x00'`` es el mismo valor. "
"(Este no es el caso para *key*.)"

#: ../Doc/library/hashlib.rst:353
msgid "These sizes are available as module `constants`_ described below."
msgstr ""
"Estos tamaños están disponibles como `constantes`_ del módulo descritas "
"abajo."

#: ../Doc/library/hashlib.rst:355
msgid ""
"Constructor functions also accept the following tree hashing parameters:"
msgstr ""
"Las funciones constructoras también aceptan los siguientes parámetros de "
"cifrado de árbol:"

#: ../Doc/library/hashlib.rst:357
msgid "*fanout*: fanout (0 to 255, 0 if unlimited, 1 in sequential mode)."
msgstr ""
"*fanout*: despliegue en abanico (0 a 255, 0 si ilimitado, 1 en modo "
"secuencial)."

#: ../Doc/library/hashlib.rst:359
msgid ""
"*depth*: maximal depth of tree (1 to 255, 255 if unlimited, 1 in sequential "
"mode)."
msgstr ""
"*depth*: profundidad máxima del árbol (1 a 255, 255 si ilimitado, 1 en modo "
"secuencial)."

#: ../Doc/library/hashlib.rst:362
msgid ""
"*leaf_size*: maximal byte length of leaf (0 to 2**32-1, 0 if unlimited or in "
"sequential mode)."
msgstr ""
"*leaf_size*: tamaño máximo en bytes de hoja (0 a 2**32-1, 0 si ilimitado o "
"en modo secuencial)."

#: ../Doc/library/hashlib.rst:365
msgid ""
"*node_offset*: node offset (0 to 2**64-1 for BLAKE2b, 0 to 2**48-1 for "
"BLAKE2s, 0 for the first, leftmost, leaf, or in sequential mode)."
msgstr ""
"*node_offset*: desplazamiento del nodo (0 a 2**64-1 para BLAKE2b, 0 a 2**48 "
"para BLAKE2s, 0 para la primera, la hoja más a la izquierda o en modo "
"secuencial)."

#: ../Doc/library/hashlib.rst:368
msgid ""
"*node_depth*: node depth (0 to 255, 0 for leaves, or in sequential mode)."
msgstr ""
"*node_depth*: profundidad de nodo (0 a 255, 0 para hojas o en modo "
"secuencial)."

#: ../Doc/library/hashlib.rst:370
msgid ""
"*inner_size*: inner digest size (0 to 64 for BLAKE2b, 0 to 32 for BLAKE2s, 0 "
"in sequential mode)."
msgstr ""
"*inner_size*: tamaño interno del resumen (0 a 64 para BLAKE2b, 0 a 32 para "
"BLAKE2s, 0 en modo secuencial)."

#: ../Doc/library/hashlib.rst:373
msgid ""
"*last_node*: boolean indicating whether the processed node is the last one "
"(`False` for sequential mode)."
msgstr ""
"*last_node*: booleano indicando si el nodo procesado es el último (`False` "
"para modo secuencial)."

#: ../Doc/library/hashlib.rst:379
msgid ""
"See section 2.10 in `BLAKE2 specification <https://blake2.net/"
"blake2_20130129.pdf>`_ for comprehensive review of tree hashing."
msgstr ""
"Consulta la sección 2.10 en la `especificación BLAKE2 <https://blake2.net/"
"blake2_20130129.pdf>` para una revisión integral del cifrado en árbol."

#: ../Doc/library/hashlib.rst:385
msgid "Constants"
msgstr "Constantes"

#: ../Doc/library/hashlib.rst:390
msgid "Salt length (maximum length accepted by constructors)."
msgstr "Largo de sal (largo máximo aceptado por los constructores)."

#: ../Doc/library/hashlib.rst:396
msgid ""
"Personalization string length (maximum length accepted by constructors)."
msgstr ""
"Largo de cadena de personalización (largo máximo aceptado por los "
"constructores)."

#: ../Doc/library/hashlib.rst:402
msgid "Maximum key size."
msgstr "Tamaño máximo de clave."

#: ../Doc/library/hashlib.rst:408
msgid "Maximum digest size that the hash function can output."
msgstr "Tamaño máximo de resumen que puede producir la función hash."

#: ../Doc/library/hashlib.rst:412
msgid "Examples"
msgstr "Ejemplos"

#: ../Doc/library/hashlib.rst:415
msgid "Simple hashing"
msgstr "Cifrado simple"

#: ../Doc/library/hashlib.rst:417
msgid ""
"To calculate hash of some data, you should first construct a hash object by "
"calling the appropriate constructor function (:func:`blake2b` or :func:"
"`blake2s`), then update it with the data by calling :meth:`update` on the "
"object, and, finally, get the digest out of the object by calling :meth:"
"`digest` (or :meth:`hexdigest` for hex-encoded string)."
msgstr ""
"Para calcular el hash de algunos datos, primero debes construir un objeto "
"hash invocando a la función del constructor apropiada (:func:`blake2b` o :"
"func:`blake2s`), entonces actualizarlo con los datos invocando :meth:"
"`update` en el objeto y, finalmente, obtener el resumen del objeto "
"invocando :meth:`digest` (o :meth:`hexdigest` para una cadena codificada en "
"hexadecimal)."

#: ../Doc/library/hashlib.rst:430
msgid ""
"As a shortcut, you can pass the first chunk of data to update directly to "
"the constructor as the positional argument:"
msgstr ""
"Como atajo, puedes pasar el primer trozo de datos para actualizar "
"directamente el constructor como el argumento posicional:"

#: ../Doc/library/hashlib.rst:437
msgid ""
"You can call :meth:`hash.update` as many times as you need to iteratively "
"update the hash:"
msgstr ""
"Puedes invocar :meth:`hash.update` tantas veces como necesites para "
"actualizar el hash iterativamente:"

#: ../Doc/library/hashlib.rst:450
msgid "Using different digest sizes"
msgstr "Usar diferentes tamaños de resumen"

#: ../Doc/library/hashlib.rst:452
msgid ""
"BLAKE2 has configurable size of digests up to 64 bytes for BLAKE2b and up to "
"32 bytes for BLAKE2s. For example, to replace SHA-1 with BLAKE2b without "
"changing the size of output, we can tell BLAKE2b to produce 20-byte digests:"
msgstr ""
"BLAKE2 tiene tamaño de resúmenes configurables de hasta 64 bytes para "
"BLAKE2b y 32 bytes para BLAKE2s. Por ejemplo, para remplazar SHA-1 con "
"BLAKE2b sin cambiar el tamaño de la salida, puedes decirle a BLAKE2b que "
"produzca resúmenes de 20 bytes:"

#: ../Doc/library/hashlib.rst:466
msgid ""
"Hash objects with different digest sizes have completely different outputs "
"(shorter hashes are *not* prefixes of longer hashes); BLAKE2b and BLAKE2s "
"produce different outputs even if the output length is the same:"
msgstr ""
"Objetos hash con diferentes tamaños de resumen tienen salidas completamente "
"diferentes (hashes más cortos *no* son prefijos de hashes más largos); "
"BLAKE2b y BLAKE2s producen salidas diferentes incluso si el largo de salida "
"es el mismo:"

#: ../Doc/library/hashlib.rst:482
msgid "Keyed hashing"
msgstr "Cifrado de clave"

#: ../Doc/library/hashlib.rst:484
msgid ""
"Keyed hashing can be used for authentication as a faster and simpler "
"replacement for `Hash-based message authentication code <https://en."
"wikipedia.org/wiki/Hash-based_message_authentication_code>`_ (HMAC). BLAKE2 "
"can be securely used in prefix-MAC mode thanks to the indifferentiability "
"property inherited from BLAKE."
msgstr ""
"El cifrado de clave puede ser usado para autentificación como remplazo más "
"rápido y simple para `Código de autentificación de mensajes en clave-hash "
"<https://es.wikipedia.org/wiki/HMAC>`_ (HMAC). BLAKE2 puede ser usado de "
"forma segura en modo de prefijo MAC gracias a la propiedad de "
"indiferenciabilidad heredada de BLAKE."

#: ../Doc/library/hashlib.rst:490
msgid ""
"This example shows how to get a (hex-encoded) 128-bit authentication code "
"for message ``b'message data'`` with key ``b'pseudorandom key'``::"
msgstr ""
"Este ejemplo muestra como obtener un código de autentificación (codificado "
"como hexadecimal) de 128 bits para el mensaje ``b'message data'`` con la "
"clave ``b'pseudorandom key'``::"

#: ../Doc/library/hashlib.rst:500
msgid ""
"As a practical example, a web application can symmetrically sign cookies "
"sent to users and later verify them to make sure they weren't tampered with::"
msgstr ""
"Como ejemplo práctico, una aplicación web puede firmar simétricamente "
"cookies enviadas a los usuarios y verificarlas más tarde para asegurar que "
"no fueron manipuladas con::"

#: ../Doc/library/hashlib.rst:529
msgid ""
"Even though there's a native keyed hashing mode, BLAKE2 can, of course, be "
"used in HMAC construction with :mod:`hmac` module::"
msgstr ""
"Incluso aunque hay un modo de cifrado de claves nativo, BLAKE2 puede, por "
"supuesto, ser usado en construcción de HMAC con el módulo :mod:`hmac`::"

#: ../Doc/library/hashlib.rst:540
msgid "Randomized hashing"
msgstr "Cifrado aleatorio"

#: ../Doc/library/hashlib.rst:542
msgid ""
"By setting *salt* parameter users can introduce randomization to the hash "
"function. Randomized hashing is useful for protecting against collision "
"attacks on the hash function used in digital signatures."
msgstr ""
"Definiendo el parámetro *salt* los usuarios pueden introducir aleatoriedad a "
"la función hash. El cifrado aleatorio es útil para proteger contra ataques "
"de colisión en la función hash usada en firmas digitales."

#: ../Doc/library/hashlib.rst:546
msgid ""
"Randomized hashing is designed for situations where one party, the message "
"preparer, generates all or part of a message to be signed by a second party, "
"the message signer. If the message preparer is able to find cryptographic "
"hash function collisions (i.e., two messages producing the same hash value), "
"then they might prepare meaningful versions of the message that would "
"produce the same hash value and digital signature, but with different "
"results (e.g., transferring $1,000,000 to an account, rather than $10). "
"Cryptographic hash functions have been designed with collision resistance as "
"a major goal, but the current concentration on attacking cryptographic hash "
"functions may result in a given cryptographic hash function providing less "
"collision resistance than expected. Randomized hashing offers the signer "
"additional protection by reducing the likelihood that a preparer can "
"generate two or more messages that ultimately yield the same hash value "
"during the digital signature generation process --- even if it is practical "
"to find collisions for the hash function. However, the use of randomized "
"hashing may reduce the amount of security provided by a digital signature "
"when all portions of the message are prepared by the signer."
msgstr ""
"El cifrado aleatorio está diseñado para situaciones en las que una parte, el "
"preparador del mensaje, genera todo o parte de un mensaje para ser firmado "
"por una segunda parte, el firmante del mensaje. Si el preparador del mensaje "
"es capaz de encontrar colisiones de funciones hash criptográficas (ej., dos "
"mensajes produciendo el mismo valor de hash), entonces ellos pueden preparar "
"versiones significativas del mensaje que producirían el mismo valor de hash "
"y firma digital, pero con diferentes resultados (ej., transfiriendo "
"1,000,000 $ a una cuenta, en lugar de 10 $), Las funciones de hash "
"criptográfico han sido diseñadas con resistencia de colisión como objetivo "
"principal, pero la concentración actual en el ataque a las funciones hash "
"criptográficas puede resultar en una función hash criptográfica dada que "
"provea menor resistencia de colisión de la esperada. El cifrado aleatorio "
"ofrece al firmante protección adicional reduciendo la probabilidad de que un "
"preparador puede generar dos o más mensajes que en última instancia producen "
"el mismo valor hash durante el proceso de generación de la firma digital, "
"--- incluso si es práctico encontrar colisiones para la función hash. Sin "
"embargo, el uso de cifrado aleatorio puede reducir la cantidad de seguridad "
"provista por una firma digital cuando todas las porciones del mensaje son "
"preparadas por el firmante."

#: ../Doc/library/hashlib.rst:565
msgid ""
"(`NIST SP-800-106 \"Randomized Hashing for Digital Signatures\" <https://"
"csrc.nist.gov/publications/detail/sp/800-106/final>`_)"
msgstr ""
"(`NIST SP-800-106 \"Randomized Hashing for Digital Signatures\" <https://"
"csrc.nist.gov/publications/detail/sp/800-106/final>`_)"

#: ../Doc/library/hashlib.rst:568
msgid ""
"In BLAKE2 the salt is processed as a one-time input to the hash function "
"during initialization, rather than as an input to each compression function."
msgstr ""
"En BLAKE2 la sal es procesada como una entrada de una vez a la función hash "
"durante la inicialización, en lugar de como una entrada para cada función de "
"compresión."

#: ../Doc/library/hashlib.rst:573
msgid ""
"*Salted hashing* (or just hashing) with BLAKE2 or any other general-purpose "
"cryptographic hash function, such as SHA-256, is not suitable for hashing "
"passwords.  See `BLAKE2 FAQ <https://blake2.net/#qa>`_ for more information."
msgstr ""
"El *cifrado salado* (o sólo cifrado) con BLAKE2 o cualquier otra función de "
"hash criptográfico de propósito general, como SHA-256, no son aptas para "
"cifrar contraseñas. Ver `BLAKE2 FAQ <https://blake2.net/#qa>`_ para más "
"información."

#: ../Doc/library/hashlib.rst:596
msgid "Personalization"
msgstr "Personalización"

#: ../Doc/library/hashlib.rst:598
msgid ""
"Sometimes it is useful to force hash function to produce different digests "
"for the same input for different purposes. Quoting the authors of the Skein "
"hash function:"
msgstr ""
"A veces es útil forzar a la función hash para producir diferentes resúmenes "
"para la misma entrada para diferentes propósitos. Citando a los autores de "
"la función hash Skein:"

#: ../Doc/library/hashlib.rst:602
msgid ""
"We recommend that all application designers seriously consider doing this; "
"we have seen many protocols where a hash that is computed in one part of the "
"protocol can be used in an entirely different part because two hash "
"computations were done on similar or related data, and the attacker can "
"force the application to make the hash inputs the same. Personalizing each "
"hash function used in the protocol summarily stops this type of attack."
msgstr ""
"Recomendamos que todos los diseñadores de aplicaciones consideren seriamente "
"hacer esto; hemos visto muchos protocolos donde un hash que es calculado en "
"una parte del protocolo puede ser usado en una parte completamente diferente "
"porque dos cálculos hash fueron realizados en datos similares o "
"relacionados, y el atacante puede forzar a la aplicación a hacer las "
"entradas hash iguales. Personalizar cada función hash usada en el protocolo "
"resumidamente detiene este tipo de ataque."

#: ../Doc/library/hashlib.rst:609
msgid ""
"(`The Skein Hash Function Family <http://www.skein-hash.info/sites/default/"
"files/skein1.3.pdf>`_, p. 21)"
msgstr ""
"(`The Skein Hash Function Family <http://www.skein-hash.info/sites/default/"
"files/skein1.3.pdf>`_, p. 21)"

#: ../Doc/library/hashlib.rst:613
msgid "BLAKE2 can be personalized by passing bytes to the *person* argument::"
msgstr "BLAKE2 puede ser personalizado pasando bytes al argumento *person*::"

#: ../Doc/library/hashlib.rst:627
msgid ""
"Personalization together with the keyed mode can also be used to derive "
"different keys from a single one."
msgstr ""
"Se puede usar también personalización en conjunto con el modo de clave para "
"derivar diferentes claves desde una sola."

#: ../Doc/library/hashlib.rst:641
msgid "Tree mode"
msgstr "Modo de árbol"

#: ../Doc/library/hashlib.rst:643
msgid "Here's an example of hashing a minimal tree with two leaf nodes::"
msgstr "Aquí hay un ejemplo de cifrar un árbol mínimo con dos nodos de hoja::"

#: ../Doc/library/hashlib.rst:649
msgid ""
"This example uses 64-byte internal digests, and returns the 32-byte final "
"digest::"
msgstr ""
"Este ejemplo usa resúmenes internos de 64 bytes, y retorna el resumen final "
"de 32 bytes::"

#: ../Doc/library/hashlib.rst:679
msgid "Credits"
msgstr "Créditos"

#: ../Doc/library/hashlib.rst:681
msgid ""
"BLAKE2_ was designed by *Jean-Philippe Aumasson*, *Samuel Neves*, *Zooko "
"Wilcox-O'Hearn*, and *Christian Winnerlein* based on SHA-3_ finalist BLAKE_ "
"created by *Jean-Philippe Aumasson*, *Luca Henzen*, *Willi Meier*, and "
"*Raphael C.-W. Phan*."
msgstr ""
"BLAKE2_ fue diseñado por *Jean-Philippe Aumasson*, *Samuel Neves*, *Zooko "
"Wilcox-O'Hearn* y *Christian Winnerlein* basado en el SHA-3_ finalista "
"BLAKE_ creado por *Jean-Philippe Aumasson*, *Luca Henzen*, *Willi Meier* y "
"*Raphael C.-W. Phan*."

#: ../Doc/library/hashlib.rst:686
msgid ""
"It uses core algorithm from ChaCha_ cipher designed by *Daniel J.  "
"Bernstein*."
msgstr ""
"Usa el algoritmo núcleo del cifrado ChaCha_ diseñado por *Daniel J. "
"Bernstein*."

#: ../Doc/library/hashlib.rst:688
msgid ""
"The stdlib implementation is based on pyblake2_ module. It was written by "
"*Dmitry Chestnykh* based on C implementation written by *Samuel Neves*. The "
"documentation was copied from pyblake2_ and written by *Dmitry Chestnykh*."
msgstr ""
"La implementación stdlib está basada en el módulo pyblake2_. Fue escrita por "
"*Dmitry Chestnykh* basada en la implementación C escrita por *Samuel Neves*. "
"La documentación fue copiada desde pyblake2_ y escrita por *Dmitry "
"Chestnykh*."

#: ../Doc/library/hashlib.rst:692
msgid "The C code was partly rewritten for Python by *Christian Heimes*."
msgstr ""
"El código C fue parcialmente reescrito para Python por *Christian Heimes*."

#: ../Doc/library/hashlib.rst:694
msgid ""
"The following public domain dedication applies for both C hash function "
"implementation, extension code, and this documentation:"
msgstr ""
"La siguiente dedicación de dominio público aplica tanto para la "
"implementación de la función hash C, el código de extensión y su "
"documentación:"

#: ../Doc/library/hashlib.rst:697
msgid ""
"To the extent possible under law, the author(s) have dedicated all copyright "
"and related and neighboring rights to this software to the public domain "
"worldwide. This software is distributed without any warranty."
msgstr ""
"En la medida en que la ley lo permite, el/los autor/es han dedicado todos "
"los derechos de autor y los derechos relacionados y vecinos de este software "
"al dominio público mundial. Este software se distribuye sin ninguna garantía."

#: ../Doc/library/hashlib.rst:701
msgid ""
"You should have received a copy of the CC0 Public Domain Dedication along "
"with this software. If not, see https://creativecommons.org/publicdomain/"
"zero/1.0/."
msgstr ""
"Deberías haber recibido una copia de la Dedicación CC0 de Dominio Público "
"junto a este software. Si no, consulta https://creativecommons.org/"
"publicdomain/zero/1.0/."

#: ../Doc/library/hashlib.rst:705
msgid ""
"The following people have helped with development or contributed their "
"changes to the project and the public domain according to the Creative "
"Commons Public Domain Dedication 1.0 Universal:"
msgstr ""
"Las siguientes personas han ayudado con el desarrollo o contribuyeron con "
"sus cambios al proyecto y el dominio público de acuerdo a Creative Commons "
"Public Domain Dedication 1.0 Universal:"

#: ../Doc/library/hashlib.rst:709
msgid "*Alexandr Sokolovskiy*"
msgstr "*Alexandr Sokolovskiy*"

#: ../Doc/library/hashlib.rst:723
msgid "Module :mod:`hmac`"
msgstr "Módulo :mod:`hmac`"

#: ../Doc/library/hashlib.rst:723
msgid "A module to generate message authentication codes using hashes."
msgstr ""
"Un módulo para generar mensajes de códigos de autentificación usando hashes."

#: ../Doc/library/hashlib.rst:726
msgid "Module :mod:`base64`"
msgstr "Módulo :mod:`base64`"

#: ../Doc/library/hashlib.rst:726
msgid "Another way to encode binary hashes for non-binary environments."
msgstr "Otra forma de codificar hashes binarios para entornos no binarios."

#: ../Doc/library/hashlib.rst:729
msgid "https://blake2.net"
msgstr "https://blake2.net"

#: ../Doc/library/hashlib.rst:729
msgid "Official BLAKE2 website."
msgstr "Sitio web oficial de BLAKE2."

#: ../Doc/library/hashlib.rst:732
msgid ""
"https://csrc.nist.gov/csrc/media/publications/fips/180/2/archive/2002-08-01/"
"documents/fips180-2.pdf"
msgstr ""
"https://csrc.nist.gov/csrc/media/publications/fips/180/2/archive/2002-08-01/"
"documents/fips180-2.pdf"

#: ../Doc/library/hashlib.rst:732
msgid "The FIPS 180-2 publication on Secure Hash Algorithms."
msgstr "La publicación FIPS 180-2 sobre Algoritmos de Cifrado Seguros."

#: ../Doc/library/hashlib.rst:736
msgid ""
"https://en.wikipedia.org/wiki/"
"Cryptographic_hash_function#Cryptographic_hash_algorithms"
msgstr ""
"https://en.wikipedia.org/wiki/"
"Cryptographic_hash_function#Cryptographic_hash_algorithms"

#: ../Doc/library/hashlib.rst:735
msgid ""
"Wikipedia article with information on which algorithms have known issues and "
"what that means regarding their use."
msgstr ""
"Artículo de Wikipedia con información sobre cuáles algoritmos tienen errores "
"conocidos y lo que eso significa con respecto a su uso."

#: ../Doc/library/hashlib.rst:738
msgid "https://www.ietf.org/rfc/rfc2898.txt"
msgstr "https://www.ietf.org/rfc/rfc2898.txt"

#: ../Doc/library/hashlib.rst:739
msgid "PKCS #5: Password-Based Cryptography Specification Version 2.0"
msgstr "PKCS #5: Password-Based Cryptography Specification Version 2.0"
