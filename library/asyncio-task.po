# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-05 12:54+0200\n"
"PO-Revision-Date: 2020-11-25 18:11-0300\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: Alcides Rivarola\n"
"Language: es\n"
"X-Generator: Poedit 2.4.2\n"

#: ../Doc/library/asyncio-task.rst:6
msgid "Coroutines and Tasks"
msgstr "Corrutinas y Tareas"

#: ../Doc/library/asyncio-task.rst:8
msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr ""
"Esta sección describe las API de asyncio de alto nivel para trabajar con "
"corrutinas y tareas."

#: ../Doc/library/asyncio-task.rst:19 ../Doc/library/asyncio-task.rst:121
msgid "Coroutines"
msgstr "Corrutinas"

#: ../Doc/library/asyncio-task.rst:21
msgid ""
":term:`Coroutines <coroutine>` declared with the async/await syntax is the "
"preferred way of writing asyncio applications.  For example, the following "
"snippet of code (requires Python 3.7+) prints \"hello\", waits 1 second, and "
"then prints \"world\"::"
msgstr ""
":term:`Coroutines <coroutine>` declarado con la sintaxis async/await es la "
"forma preferida de escribir aplicaciones asyncio. Por ejemplo, el siguiente "
"fragmento de código (requiere Python 3.7+) imprime \"hola\", espera 1 "
"segundo y, a continuación, imprime \"mundo\"::"

#: ../Doc/library/asyncio-task.rst:37
msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr ""
"Tenga en cuenta que simplemente llamando a una corrutina no programará para "
"que se ejecute::"

#: ../Doc/library/asyncio-task.rst:43
msgid "To actually run a coroutine, asyncio provides three main mechanisms:"
msgstr ""
"Para ejecutar realmente una corrutina, asyncio proporciona tres mecanismos "
"principales:"

#: ../Doc/library/asyncio-task.rst:45
msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\" "
"function (see the above example.)"
msgstr ""
"La función :func:`asyncio.run` para ejecutar la función de punto de entrada "
"de nivel superior \"main()\" (consulte el ejemplo anterior.)"

#: ../Doc/library/asyncio-task.rst:48
msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\" "
"after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr ""
"Esperando en una corrutina. El siguiente fragmento de código imprimirá \"hola"
"\" después de esperar 1 segundo y luego imprimirá \"mundo\" después de "
"esperar *otros* 2 segundos::"

#: ../Doc/library/asyncio-task.rst:69
msgid "Expected output::"
msgstr "Salida esperada::"

#: ../Doc/library/asyncio-task.rst:76
msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ""
"La función :func:`asyncio.create_task` para ejecutar corrutinas "
"concurrentemente como asyncio :class:`Tasks <Task>`."

#: ../Doc/library/asyncio-task.rst:79
msgid ""
"Let's modify the above example and run two ``say_after`` coroutines "
"*concurrently*::"
msgstr ""
"Modifiquemos el ejemplo anterior y ejecutemos dos corrutinas ``say_after`` "
"*concurrentemente*::"

#: ../Doc/library/asyncio-task.rst:98
msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr ""
"Tenga en cuenta que la salida esperada ahora muestra que el fragmento de "
"código se ejecuta 1 segundo más rápido que antes::"

#: ../Doc/library/asyncio-task.rst:110
msgid "Awaitables"
msgstr "Esperables"

#: ../Doc/library/asyncio-task.rst:112
msgid ""
"We say that an object is an **awaitable** object if it can be used in an :"
"keyword:`await` expression.  Many asyncio APIs are designed to accept "
"awaitables."
msgstr ""
"Decimos que un objeto es un objeto **esperable** si se puede utilizar en una "
"expresión :keyword:`await`. Muchas API de asyncio están diseñadas para "
"aceptar los valores esperables."

#: ../Doc/library/asyncio-task.rst:116
msgid ""
"There are three main types of *awaitable* objects: **coroutines**, "
"**Tasks**, and **Futures**."
msgstr ""
"Hay tres tipos principales de objetos *esperables*: **corrutinas**, "
"**Tareas** y **Futuros**."

#: ../Doc/library/asyncio-task.rst:122
msgid ""
"Python coroutines are *awaitables* and therefore can be awaited from other "
"coroutines::"
msgstr ""
"Las corrutinas de Python son *esperables* y por lo tanto se pueden esperar "
"de otras corrutinas::"

#: ../Doc/library/asyncio-task.rst:143
msgid ""
"In this documentation the term \"coroutine\" can be used for two closely "
"related concepts:"
msgstr ""
"En esta documentación se puede utilizar el término \"corrutina\" para dos "
"conceptos estrechamente relacionados:"

#: ../Doc/library/asyncio-task.rst:146
msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr "una *función corrutina*: una función :keyword:`async def`;"

#: ../Doc/library/asyncio-task.rst:148
msgid ""
"a *coroutine object*: an object returned by calling a *coroutine function*."
msgstr ""
"un *objeto corrutina*: un objeto retornado llamando a una *función "
"corrutina*."

#: ../Doc/library/asyncio-task.rst:151
msgid ""
"asyncio also supports legacy :ref:`generator-based "
"<asyncio_generator_based_coro>` coroutines."
msgstr ""
"asyncio también es compatible con corrutinas heredadas :ref:`generator-based "
"<asyncio_generator_based_coro>`."

#: ../Doc/library/asyncio-task.rst:156
msgid "Tasks"
msgstr "Tareas"

#: ../Doc/library/asyncio-task.rst:157
msgid "*Tasks* are used to schedule coroutines *concurrently*."
msgstr "*Las tareas* se utilizan para programar corrutinas *concurrentemente*."

#: ../Doc/library/asyncio-task.rst:159
msgid ""
"When a coroutine is wrapped into a *Task* with functions like :func:`asyncio."
"create_task` the coroutine is automatically scheduled to run soon::"
msgstr ""
"Cuando una corrutina se envuelve en una *Tarea* con funciones como :func:"
"`asyncio.create_task` la corrutina se programa automáticamente para "
"ejecutarse pronto::"

#: ../Doc/library/asyncio-task.rst:181
msgid "Futures"
msgstr "Futuros"

#: ../Doc/library/asyncio-task.rst:182
msgid ""
"A :class:`Future` is a special **low-level** awaitable object that "
"represents an **eventual result** of an asynchronous operation."
msgstr ""
"Un :class:`Future` es un objeto esperable especial de **bajo-nivel** que "
"representa un **resultado eventual** de una operación asíncrona."

#: ../Doc/library/asyncio-task.rst:185
msgid ""
"When a Future object is *awaited* it means that the coroutine will wait "
"until the Future is resolved in some other place."
msgstr ""
"Cuando un objeto Future es *esperado* significa que la corrutina esperará "
"hasta que el Future se resuelva en algún otro lugar."

#: ../Doc/library/asyncio-task.rst:188
msgid ""
"Future objects in asyncio are needed to allow callback-based code to be used "
"with async/await."
msgstr ""
"Los objetos Future de asyncio son necesarios para permitir que el código "
"basado en retro llamada se use con async/await."

#: ../Doc/library/asyncio-task.rst:191
msgid ""
"Normally **there is no need** to create Future objects at the application "
"level code."
msgstr ""
"Normalmente , **no es necesario** crear objetos Future en el código de nivel "
"de aplicación."

#: ../Doc/library/asyncio-task.rst:194
msgid ""
"Future objects, sometimes exposed by libraries and some asyncio APIs, can be "
"awaited::"
msgstr ""
"Los objetos Future, a veces expuestos por bibliotecas y algunas API de "
"asyncio, pueden ser esperados::"

#: ../Doc/library/asyncio-task.rst:206
msgid ""
"A good example of a low-level function that returns a Future object is :meth:"
"`loop.run_in_executor`."
msgstr ""
"Un buen ejemplo de una función de bajo nivel que retorna un objeto Future "
"es :meth:`loop.run_in_executor`."

#: ../Doc/library/asyncio-task.rst:211
msgid "Running an asyncio Program"
msgstr "Ejecutando un programa asyncio"

#: ../Doc/library/asyncio-task.rst:215
msgid "Execute the :term:`coroutine` *coro* and return the result."
msgstr "Ejecuta la :term:`coroutine` *coro* y retornando el resultado."

#: ../Doc/library/asyncio-task.rst:217
msgid ""
"This function runs the passed coroutine, taking care of managing the asyncio "
"event loop and *finalizing asynchronous generators*."
msgstr ""
"Esta función ejecuta la corrutina pasada, encargándose de administrar el "
"bucle de eventos asyncio y *finalizar los generadores asíncronos*."

#: ../Doc/library/asyncio-task.rst:221
msgid ""
"This function cannot be called when another asyncio event loop is running in "
"the same thread."
msgstr ""
"Esta función no se puede llamar cuando otro bucle de eventos asyncio se está "
"ejecutando en el mismo hilo."

#: ../Doc/library/asyncio-task.rst:224
msgid "If *debug* is ``True``, the event loop will be run in debug mode."
msgstr ""
"Si *debug* es ``True``, el bucle de eventos se ejecutará en modo debug."

#: ../Doc/library/asyncio-task.rst:226
msgid ""
"This function always creates a new event loop and closes it at the end.  It "
"should be used as a main entry point for asyncio programs, and should "
"ideally only be called once."
msgstr ""
"Esta función siempre crea un nuevo ciclo de eventos y lo cierra al final. "
"Debe usarse como un punto de entrada principal para los programas asyncio, e "
"idealmente solo debe llamarse una vez."

#: ../Doc/library/asyncio-task.rst:230 ../Doc/library/asyncio-task.rst:354
#: ../Doc/library/asyncio-task.rst:463 ../Doc/library/asyncio-task.rst:593
msgid "Example::"
msgstr "Ejemplo::"

#: ../Doc/library/asyncio-task.rst:242
msgid ""
"The source code for ``asyncio.run()`` can be found in :source:`Lib/asyncio/"
"runners.py`."
msgstr ""
"El código fuente para ``asyncio.run()`` se puede encontrar en :source:`Lib/"
"asyncio/runners.py`."

#: ../Doc/library/asyncio-task.rst:246
msgid "Creating Tasks"
msgstr "Creando Tareas"

#: ../Doc/library/asyncio-task.rst:250
msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a :class:`Task` and "
"schedule its execution.  Return the Task object."
msgstr ""
"Envuelve una :ref:`coroutine <coroutine>` *coro* en una :class:`Task` y "
"programa su ejecución. Retorna el objeto Tarea."

#: ../Doc/library/asyncio-task.rst:253
msgid ""
"If *name* is not ``None``, it is set as the name of the task using :meth:"
"`Task.set_name`."
msgstr ""
"Si *name* no es ``None``, se establece como el nombre de la tarea mediante :"
"meth:`Task.set_name`."

#: ../Doc/library/asyncio-task.rst:256
msgid ""
"The task is executed in the loop returned by :func:`get_running_loop`, :exc:"
"`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""
"La tarea se ejecuta en el bucle retornado por :func:`get_running_loop`, :exc:"
"`RuntimeError` se genera si no hay ningún bucle en ejecución en el "
"subproceso actual."

#: ../Doc/library/asyncio-task.rst:260
msgid ""
"This function has been **added in Python 3.7**.  Prior to Python 3.7, the "
"low-level :func:`asyncio.ensure_future` function can be used instead::"
msgstr ""
"Esta función se ha **añadido en Python 3.7**. Antes de Python 3.7, la "
"función de bajo nivel :func:`asyncio.ensure_future` se puede utilizar en su "
"lugar::"

#: ../Doc/library/asyncio-task.rst:277 ../Doc/library/asyncio-task.rst:716
msgid "Added the ``name`` parameter."
msgstr "Se ha añadido el parámetro ``name``."

#: ../Doc/library/asyncio-task.rst:282
msgid "Sleeping"
msgstr "Durmiendo"

#: ../Doc/library/asyncio-task.rst:286
msgid "Block for *delay* seconds."
msgstr "Bloquea por *delay* segundos."

#: ../Doc/library/asyncio-task.rst:288
msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr ""
"Si se proporciona *result*, se retorna al autor de la llamada cuando se "
"completa la corrutina."

#: ../Doc/library/asyncio-task.rst:291
msgid ""
"``sleep()`` always suspends the current task, allowing other tasks to run."
msgstr ""
"``sleep()`` siempre suspende la tarea actual, permitiendo que se ejecuten "
"otras tareas."

#: ../Doc/library/asyncio-task.rst:296 ../Doc/library/asyncio-task.rst:351
#: ../Doc/library/asyncio-task.rst:430 ../Doc/library/asyncio-task.rst:460
#: ../Doc/library/asyncio-task.rst:545 ../Doc/library/asyncio-task.rst:592
#: ../Doc/library/asyncio-task.rst:721
msgid "The *loop* parameter."
msgstr "El parámetro *loop*."

#: ../Doc/library/asyncio-task.rst:299
msgid ""
"Example of coroutine displaying the current date every second for 5 seconds::"
msgstr ""
"Ejemplo de una rutina que muestra la fecha actual cada segundo durante 5 "
"segundos::"

#: ../Doc/library/asyncio-task.rst:318
msgid "Running Tasks Concurrently"
msgstr "Ejecutando Tareas Concurrentemente"

#: ../Doc/library/asyncio-task.rst:322
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* sequence "
"*concurrently*."
msgstr ""
"Ejecute :ref:`objetos esperables <asyncio-awaitables>` en la secuencia *aws* "
"de forma *concurrently*."

#: ../Doc/library/asyncio-task.rst:325
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task."
msgstr ""
"Si cualquier esperable en *aws* es una corrutina, se programa "
"automáticamente como una Tarea."

#: ../Doc/library/asyncio-task.rst:328
msgid ""
"If all awaitables are completed successfully, the result is an aggregate "
"list of returned values.  The order of result values corresponds to the "
"order of awaitables in *aws*."
msgstr ""
"Si todos los esperables se completan correctamente, el resultado es una "
"lista agregada de valores retornados. El orden de los valores de resultado "
"corresponde al orden de esperables en *aws*."

#: ../Doc/library/asyncio-task.rst:332
msgid ""
"If *return_exceptions* is ``False`` (default), the first raised exception is "
"immediately propagated to the task that awaits on ``gather()``.  Other "
"awaitables in the *aws* sequence **won't be cancelled** and will continue to "
"run."
msgstr ""
"Si *return_exceptions* es ``False`` (valor predeterminado), la primera "
"excepción provocada se propaga inmediatamente a la tarea que espera en "
"``gather()``. Otros esperables en la secuencia *aws* **no se cancelarán** y "
"continuarán ejecutándose."

#: ../Doc/library/asyncio-task.rst:337
msgid ""
"If *return_exceptions* is ``True``, exceptions are treated the same as "
"successful results, and aggregated in the result list."
msgstr ""
"Si *return_exceptions* es ``True``, las excepciones se tratan igual que los "
"resultados correctos y se agregan en la lista de resultados."

#: ../Doc/library/asyncio-task.rst:340
msgid ""
"If ``gather()`` is *cancelled*, all submitted awaitables (that have not "
"completed yet) are also *cancelled*."
msgstr ""
"Si ``gather()`` es *cancelado*, todos los esperables enviados (que aún no se "
"han completado) también se *cancelan*."

#: ../Doc/library/asyncio-task.rst:343
msgid ""
"If any Task or Future from the *aws* sequence is *cancelled*, it is treated "
"as if it raised :exc:`CancelledError` -- the ``gather()`` call is **not** "
"cancelled in this case.  This is to prevent the cancellation of one "
"submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""
"Si alguna Tarea o Futuro de la secuencia *aws* se *cancela*, se trata como "
"si se lanzara :exc:`CancelledError` -- la llamada ``gather()`` **no** se "
"cancela en este caso. Esto es para evitar la cancelación de una Tarea/Futuro "
"enviada para hacer que otras Tareas/Futuros sean canceladas."

#: ../Doc/library/asyncio-task.rst:388
msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr ""
"Si se cancela el propio *gather*, la cancelación se propaga "
"independientemente de *return_exceptions*."

#: ../Doc/library/asyncio-task.rst:394
msgid "Shielding From Cancellation"
msgstr "Protección contra Cancelación"

#: ../Doc/library/asyncio-task.rst:398
msgid ""
"Protect an :ref:`awaitable object <asyncio-awaitables>` from being :meth:"
"`cancelled <Task.cancel>`."
msgstr ""
"Protege un :ref:`objeto esperable <asyncio-awaitables>` de ser :meth:"
"`cancelado <Task.cancel>`."

#: ../Doc/library/asyncio-task.rst:401 ../Doc/library/asyncio-task.rst:441
msgid "If *aw* is a coroutine it is automatically scheduled as a Task."
msgstr "Si *aw* es una corrutina, se programa automáticamente como una Tarea."

#: ../Doc/library/asyncio-task.rst:403
msgid "The statement::"
msgstr "La declaración::"

#: ../Doc/library/asyncio-task.rst:407
msgid "is equivalent to::"
msgstr "es equivalente a::"

#: ../Doc/library/asyncio-task.rst:411
msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises a :exc:"
"`CancelledError`."
msgstr ""
"*excepto* que si la corrutina que lo contiene se cancela, la tarea que se "
"ejecuta en ``something()`` no se cancela. Desde el punto de vista de "
"``something()``, la cancelación no ocurrió. Aunque su invocador siga "
"cancelado, por lo que la expresión \"await\" sigue generando un :exc:"
"`CancelledError`."

#: ../Doc/library/asyncio-task.rst:417
msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr ""
"Si ``something()`` se cancela por otros medios (es decir, desde dentro de sí "
"mismo) eso también cancelaría ``shield()``."

#: ../Doc/library/asyncio-task.rst:420
msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr ""
"Si se desea ignorar por completo la cancelación (no se recomienda) la "
"función ``shield()`` debe combinarse con una cláusula try/except, como se "
"indica a continuación::"

#: ../Doc/library/asyncio-task.rst:434
msgid "Timeouts"
msgstr "Tiempo agotado"

#: ../Doc/library/asyncio-task.rst:438
msgid ""
"Wait for the *aw* :ref:`awaitable <asyncio-awaitables>` to complete with a "
"timeout."
msgstr ""
"Espere a que el *aw* :ref:`esperable <asyncio-awaitables>` se complete con "
"un tiempo agotado."

#: ../Doc/library/asyncio-task.rst:443
msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait "
"for.  If *timeout* is ``None``, block until the future completes."
msgstr ""
"*timeout* puede ser ``None`` o punto flotante o un número entero de segundos "
"a esperar. Si *timeout* es ``None``, se bloquea hasta que futuro se complete."

#: ../Doc/library/asyncio-task.rst:447
msgid ""
"If a timeout occurs, it cancels the task and raises :exc:`asyncio."
"TimeoutError`."
msgstr ""
"Si se produce un agotamiento de tiempo, cancela la tarea y genera :exc:"
"`asyncio.TimeoutError`."

#: ../Doc/library/asyncio-task.rst:450
msgid ""
"To avoid the task :meth:`cancellation <Task.cancel>`, wrap it in :func:"
"`shield`."
msgstr ""
"Para evitar la :meth:`cancelación <Task.cancel>` de la tarea , envuélvala "
"en :func:`shield`."

#: ../Doc/library/asyncio-task.rst:453
msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*."
msgstr ""
"La función esperará hasta que el futuro este cancelado, por lo que el tiempo "
"de espera total puede superar el *timeout*."

#: ../Doc/library/asyncio-task.rst:456
msgid "If the wait is cancelled, the future *aw* is also cancelled."
msgstr "Si se cancela la espera, el futuro *aw* también se cancela."

#: ../Doc/library/asyncio-task.rst:483
msgid ""
"When *aw* is cancelled due to a timeout, ``wait_for`` waits for *aw* to be "
"cancelled.  Previously, it raised :exc:`asyncio.TimeoutError` immediately."
msgstr ""
"Cuando *aw* se cancela debido a un agotamiento de tiempo, ``wait_for`` "
"espera a que se cancele *aw*. Anteriormente, se lanzó inmediatamente :exc:"
"`asyncio.TimeoutError`."

#: ../Doc/library/asyncio-task.rst:490
msgid "Waiting Primitives"
msgstr "Esperando Primitivas"

#: ../Doc/library/asyncio-task.rst:495
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* set "
"concurrently and block until the condition specified by *return_when*."
msgstr ""
"Ejecute :ref:`objetos esperables <asyncio-awaitables>` en el conjunto *aws* "
"simultáneamente y bloquee hasta que la condición especificada por "
"*return_when*."

#: ../Doc/library/asyncio-task.rst:499
msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr "Retorna dos conjuntos de Tareas/Futuros: ``(done, pending)``."

#: ../Doc/library/asyncio-task.rst:501
msgid "Usage::"
msgstr "Uso::"

#: ../Doc/library/asyncio-task.rst:505
msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum "
"number of seconds to wait before returning."
msgstr ""
"*timeout* (un punto flotante o int), si se especifica, se puede utilizar "
"para controlar el número máximo de segundos que hay que esperar antes de "
"retornar."

#: ../Doc/library/asyncio-task.rst:508
msgid ""
"Note that this function does not raise :exc:`asyncio.TimeoutError`. Futures "
"or Tasks that aren't done when the timeout occurs are simply returned in the "
"second set."
msgstr ""
"Tenga en cuenta que esta función no lanza :exc:`asyncio.TimeoutError`. Los "
"Futuros o Tareas que no terminan cuando se agota el tiempo simplemente se "
"retornan en el segundo conjunto."

#: ../Doc/library/asyncio-task.rst:512
msgid ""
"*return_when* indicates when this function should return.  It must be one of "
"the following constants:"
msgstr ""
"*return_when* indica cuándo debe retornar esta función. Debe ser una de las "
"siguientes constantes:"

#: ../Doc/library/asyncio-task.rst:518
msgid "Constant"
msgstr "Constante"

#: ../Doc/library/asyncio-task.rst:518
msgid "Description"
msgstr "Descripción"

#: ../Doc/library/asyncio-task.rst:520
msgid ":const:`FIRST_COMPLETED`"
msgstr ":const:`FIRST_COMPLETED`"

#: ../Doc/library/asyncio-task.rst:520
msgid "The function will return when any future finishes or is cancelled."
msgstr "La función retornará cuando cualquier Futuro termine o se cancele."

#: ../Doc/library/asyncio-task.rst:523
msgid ":const:`FIRST_EXCEPTION`"
msgstr ":const:`FIRST_EXCEPTION`"

#: ../Doc/library/asyncio-task.rst:523
msgid ""
"The function will return when any future finishes by raising an exception.  "
"If no future raises an exception then it is equivalent to :const:"
"`ALL_COMPLETED`."
msgstr ""
"La función retornará cuando cualquier Futuro finalice lanzando una "
"excepción. Si ningún Futuro lanza una excepción, entonces es equivalente a :"
"const:`ALL_COMPLETED`."

#: ../Doc/library/asyncio-task.rst:529
msgid ":const:`ALL_COMPLETED`"
msgstr ":const:`ALL_COMPLETED`"

#: ../Doc/library/asyncio-task.rst:529
msgid "The function will return when all futures finish or are cancelled."
msgstr "La función retornará cuando todos los Futuros terminen o se cancelen."

#: ../Doc/library/asyncio-task.rst:533
msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr ""
"A diferencia de :func:`~asyncio.wait_for`, ``wait()`` no cancela los Futuros "
"cuando se produce un agotamiento de tiempo."

#: ../Doc/library/asyncio-task.rst:538
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task.  Passing coroutines objects to ``wait()`` directly is deprecated as it "
"leads to :ref:`confusing behavior <asyncio_example_wait_coroutine>`."
msgstr ""
"Si cualquier aguardable en *aws* es una corrutina, se programa "
"automáticamente como una Tarea. El paso de objetos corrutinas a ``wait()`` "
"directamente está en desuso, ya que conduce a :ref:`comportamiento confuso "
"<asyncio_example_wait_coroutine>`."

#: ../Doc/library/asyncio-task.rst:550
msgid ""
"``wait()`` schedules coroutines as Tasks automatically and later returns "
"those implicitly created Task objects in ``(done, pending)`` sets.  "
"Therefore the following code won't work as expected::"
msgstr ""
"``wait()`` programa las corrutinas como Tareas automáticamente y "
"posteriormente retorna los objetos Tarea creados implícitamente en conjuntos "
"``(done, pending)``. Por lo tanto, el código siguiente no funcionará como se "
"esperaba::"

#: ../Doc/library/asyncio-task.rst:563
msgid "Here is how the above snippet can be fixed::"
msgstr "Aquí es cómo se puede arreglar el fragmento de código anterior::"

#: ../Doc/library/asyncio-task.rst:576
msgid "Passing coroutine objects to ``wait()`` directly is deprecated."
msgstr "El paso de objetos corrutina a ``wait()`` directamente está en desuso."

#: ../Doc/library/asyncio-task.rst:582
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* set "
"concurrently.  Return an iterator of :class:`Future` objects. Each Future "
"object returned represents the earliest result from the set of the remaining "
"awaitables."
msgstr ""
"Ejecute :ref:`objetos aguardables <asyncio-awaitables>` en el conjunto *aws* "
"simultáneamente. Devuelve un iterador de objetos :class:`Future`. Cada "
"objeto Future devuelto representa el resultado más antiguo del conjunto de "
"los aguardables restantes."

#: ../Doc/library/asyncio-task.rst:587
msgid ""
"Raises :exc:`asyncio.TimeoutError` if the timeout occurs before all Futures "
"are done."
msgstr ""
"Lanza :exc:`asyncio.TimeoutError` si el agotamiento de tiempo ocurre antes "
"que todos los Futuros terminen."

#: ../Doc/library/asyncio-task.rst:601
msgid "Scheduling From Other Threads"
msgstr "Planificación Desde Otros Hilos"

#: ../Doc/library/asyncio-task.rst:605
msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr ""
"Envía una corrutina al bucle de eventos especificado. Seguro para Hilos."

#: ../Doc/library/asyncio-task.rst:607
msgid ""
"Return a :class:`concurrent.futures.Future` to wait for the result from "
"another OS thread."
msgstr ""
"Retorna :class:`concurrent.futures.Future` para esperar el resultado de otro "
"hilo del SO (Sistema Operativo)."

#: ../Doc/library/asyncio-task.rst:610
msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr ""
"Esta función está pensada para llamarse desde un hilo del SO diferente al "
"que se ejecuta el bucle de eventos. Ejemplo::"

#: ../Doc/library/asyncio-task.rst:622
msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr ""
"Si se lanza una excepción en la corrutina, el Futuro retornado será "
"notificado. También se puede utilizar para cancelar la tarea en el bucle de "
"eventos::"

#: ../Doc/library/asyncio-task.rst:636
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Consulte la sección de la documentación :ref:`Concurrencia y multi hilos "
"<asyncio-multithreading>`."

#: ../Doc/library/asyncio-task.rst:639
msgid ""
"Unlike other asyncio functions this function requires the *loop* argument to "
"be passed explicitly."
msgstr ""
"A diferencia de otras funciones asyncio, esta función requiere que el "
"argumento *loop* se pase explícitamente."

#: ../Doc/library/asyncio-task.rst:646
msgid "Introspection"
msgstr "Introspección"

#: ../Doc/library/asyncio-task.rst:651
msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr ""
"Retorna la instancia :class:`Task` actualmente en ejecución o ``None`` si no "
"se está ejecutando ninguna tarea."

#: ../Doc/library/asyncio-task.rst:654
msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr ""
"Si *loop* es ``None`` :func:`get_running_loop` se utiliza para obtener el "
"bucle actual."

#: ../Doc/library/asyncio-task.rst:662
msgid "Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr ""
"Retorna un conjunto de objetos :class:`Task` que se ejecutan por el bucle."

#: ../Doc/library/asyncio-task.rst:665
msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr ""
"Si *loop* es ``None``, :func:`get_running_loop` se utiliza para obtener el "
"bucle actual."

#: ../Doc/library/asyncio-task.rst:672
msgid "Task Object"
msgstr "Objeto Task"

#: ../Doc/library/asyncio-task.rst:676
msgid ""
"A :class:`Future-like <Future>` object that runs a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr ""
"Un objeto :class:`similar a Futuro <Future>` que ejecuta Python :ref:"
"`coroutine <coroutine>`. No es seguro hilos."

#: ../Doc/library/asyncio-task.rst:679
msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""
"Las tareas se utilizan para ejecutar corrutinas en bucles de eventos. Si una "
"corrutina aguarda en un Futuro, la Tarea suspende la ejecución de la "
"corrutina y espera la finalización del Futuro. Cuando el Futuro *termina*, "
"se reanuda la ejecución de la corrutina envuelta."

#: ../Doc/library/asyncio-task.rst:685
msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr ""
"Los bucles de eventos usan la programación cooperativa: un bucle de eventos "
"ejecuta una tarea a la vez. Mientras una Tarea espera para la finalización "
"de un Futuro, el bucle de eventos ejecuta otras tareas, retorno de llamada o "
"realiza operaciones de E/S."

#: ../Doc/library/asyncio-task.rst:690
msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""
"Utilice la función de alto nivel :func:`asyncio.create_task` para crear "
"Tareas, o las funciones de bajo nivel :meth:`loop.create_task` o :func:"
"`ensure_future`. Se desaconseja la creación de instancias manuales de Tareas."

#: ../Doc/library/asyncio-task.rst:695
msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""
"Para cancelar una Tarea en ejecución, utilice el método :meth:`cancel`. "
"Llamarlo hará que la tarea lance una excepción :exc:`CancelledError` en la "
"corrutina contenida. Si una corrutina está esperando en un objeto Futuro "
"durante la cancelación, se cancelará el objeto Futuro."

#: ../Doc/library/asyncio-task.rst:700
msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method "
"returns ``True`` if the wrapped coroutine did not suppress the :exc:"
"`CancelledError` exception and was actually cancelled."
msgstr ""
":meth:`cancelled` se puede utilizar para comprobar si la Tarea fue "
"cancelada. El método devuelve ``True`` si la corrutina contenida no suprimió "
"la excepción :exc:`CancelledError` y se canceló realmente."

#: ../Doc/library/asyncio-task.rst:705
msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except :"
"meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""
":class:`asyncio.Task` hereda de :class:`Future` todas sus API excepto :meth:"
"`Future.set_result` y :meth:`Future.set_exception`."

#: ../Doc/library/asyncio-task.rst:709
msgid ""
"Tasks support the :mod:`contextvars` module.  When a Task is created it "
"copies the current context and later runs its coroutine in the copied "
"context."
msgstr ""
"Las tareas admiten el módulo :mod:`contextvars`. Cuando se crea una Tarea, "
"copia el contexto actual y, posteriormente, ejecuta su corrutina en el "
"contexto copiado."

#: ../Doc/library/asyncio-task.rst:713
msgid "Added support for the :mod:`contextvars` module."
msgstr "Agregado soporte para el módulo :mod:`contextvars`."

#: ../Doc/library/asyncio-task.rst:724
msgid "Request the Task to be cancelled."
msgstr "Solicita que se cancele la Tarea."

#: ../Doc/library/asyncio-task.rst:726
msgid ""
"This arranges for a :exc:`CancelledError` exception to be thrown into the "
"wrapped coroutine on the next cycle of the event loop."
msgstr ""
"Esto hace que una excepción :exc:`CancelledError` sea lanzada a la corrutina "
"contenida en el próximo ciclo del bucle de eventos."

#: ../Doc/library/asyncio-task.rst:729
msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, unlike :meth:"
"`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task will "
"be cancelled, although suppressing cancellation completely is not common and "
"is actively discouraged."
msgstr ""
"La corrutina entonces tiene la oportunidad de limpiar o incluso denegar la "
"solicitud suprimiendo la excepción con un bloque :keyword:`try` ... ..."
"``except CancelledError`` ... :keyword:`finally`. Por lo tanto, a diferencia "
"de :meth:`Future.cancel`, :meth:`Task.cancel` no garantiza que la tarea será "
"cancelada, aunque suprimir la cancelación por completo no es común y se "
"desalienta activamente."

#: ../Doc/library/asyncio-task.rst:739
msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr ""
"En el ejemplo siguiente se muestra cómo las corrutinas pueden interceptar la "
"solicitud de cancelación::"

#: ../Doc/library/asyncio-task.rst:778
msgid "Return ``True`` if the Task is *cancelled*."
msgstr "Retorna ``True`` si la Tarea se *cancela*."

#: ../Doc/library/asyncio-task.rst:780
msgid ""
"The Task is *cancelled* when the cancellation was requested with :meth:"
"`cancel` and the wrapped coroutine propagated the :exc:`CancelledError` "
"exception thrown into it."
msgstr ""
"La tarea se *cancela* cuando se solicitó la cancelación con :meth:`cancel` y "
"la corrutina contenida propagó la excepción :exc:`CancelledError` que se le "
"ha lanzado."

#: ../Doc/library/asyncio-task.rst:786
msgid "Return ``True`` if the Task is *done*."
msgstr "Retorna ``True`` si la Tarea está *finalizada*."

#: ../Doc/library/asyncio-task.rst:788
msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr ""
"Una tarea está *finalizada* cuando la corrutina contenida retornó un valor, "
"lanzó una excepción, o se canceló la Tarea."

#: ../Doc/library/asyncio-task.rst:793
msgid "Return the result of the Task."
msgstr "Retorna el resultado de la Tarea."

#: ../Doc/library/asyncio-task.rst:795
msgid ""
"If the Task is *done*, the result of the wrapped coroutine is returned (or "
"if the coroutine raised an exception, that exception is re-raised.)"
msgstr ""
"Si la tarea está *terminada*, se devuelve el resultado de la corrutina "
"contenida (o si la corrutina lanzó una excepción, esa excepción se vuelve a "
"relanzar.)"

#: ../Doc/library/asyncio-task.rst:799 ../Doc/library/asyncio-task.rst:813
msgid ""
"If the Task has been *cancelled*, this method raises a :exc:`CancelledError` "
"exception."
msgstr ""
"Si la Tarea ha sido *cancelada*, este método lanza una excepción :exc:"
"`CancelledError`."

#: ../Doc/library/asyncio-task.rst:802
msgid ""
"If the Task's result isn't yet available, this method raises a :exc:"
"`InvalidStateError` exception."
msgstr ""
"Si el resultado de la Tarea aún no está disponible, este método lanza una "
"excepción :exc:`InvalidStateError`."

#: ../Doc/library/asyncio-task.rst:807
msgid "Return the exception of the Task."
msgstr "Retorna la excepción de la Tarea."

#: ../Doc/library/asyncio-task.rst:809
msgid ""
"If the wrapped coroutine raised an exception that exception is returned.  If "
"the wrapped coroutine returned normally this method returns ``None``."
msgstr ""
"Si la corrutina contenida lanzó una excepción, esa excepción es retornada. "
"Si la corrutina contenida retorna normalmente, este método retorna ``None``."

#: ../Doc/library/asyncio-task.rst:816
msgid ""
"If the Task isn't *done* yet, this method raises an :exc:`InvalidStateError` "
"exception."
msgstr ""
"Si la Tarea aún no está *terminada*, este método lanza una excepción :exc:"
"`InvalidStateError`."

#: ../Doc/library/asyncio-task.rst:821
msgid "Add a callback to be run when the Task is *done*."
msgstr ""
"Agrega una retro llamada que se ejecutará cuando la Tarea esté *terminada*."

#: ../Doc/library/asyncio-task.rst:823 ../Doc/library/asyncio-task.rst:832
msgid "This method should only be used in low-level callback-based code."
msgstr ""
"Este método solo se debe usar en código basado en retrollamada de bajo nivel."

#: ../Doc/library/asyncio-task.rst:825
msgid ""
"See the documentation of :meth:`Future.add_done_callback` for more details."
msgstr ""
"Consulte la documentación de :meth:`Future.add_done_callback` para obtener "
"más detalles."

#: ../Doc/library/asyncio-task.rst:830
msgid "Remove *callback* from the callbacks list."
msgstr "Remueve la *retrollamada* de la lista de retrollamadas."

#: ../Doc/library/asyncio-task.rst:834
msgid ""
"See the documentation of :meth:`Future.remove_done_callback` for more "
"details."
msgstr ""
"Consulte la documentación de :meth:`Future.remove_done_callback` para "
"obtener más detalles."

#: ../Doc/library/asyncio-task.rst:839
msgid "Return the list of stack frames for this Task."
msgstr "Retorna la lista de marcos de pila para esta tarea."

#: ../Doc/library/asyncio-task.rst:841
msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception, "
"this returns the list of traceback frames."
msgstr ""
"Si la corrutina contenida no se termina, esto retorna la pila donde se "
"suspende. Si la corrutina se ha completado correctamente o se ha cancelado, "
"retorna una lista vacía. Si la corrutina terminó por una excepción, esto "
"retorna la lista de marcos de seguimiento."

#: ../Doc/library/asyncio-task.rst:847
msgid "The frames are always ordered from oldest to newest."
msgstr "Los marcos siempre se ordenan de más antiguo a más nuevo."

#: ../Doc/library/asyncio-task.rst:849
msgid "Only one stack frame is returned for a suspended coroutine."
msgstr "Solo se retorna un marco de pila para una corrutina suspendida."

# No se muy bien como se traduciría traceback. Podría ser seguimiento
#: ../Doc/library/asyncio-task.rst:851
#, fuzzy
msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""
"El argumento opcional *limit* establece el número máximo de marcos que se "
"retornarán; de forma predeterminada se retornan todos los marcos "
"disponibles. El orden de la lista devuelta varía en función de si se retorna "
"una pila o un traceback: se devuelven los marcos más recientes de una pila, "
"pero se devuelven los marcos más antiguos de un traceback. (Esto coincide "
"con el comportamiento del módulo traceback.)"

#: ../Doc/library/asyncio-task.rst:860
msgid "Print the stack or traceback for this Task."
msgstr "Imprime la pila o el seguimiento de esta tarea."

#: ../Doc/library/asyncio-task.rst:862
msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr ""
"Esto produce una salida similar a la del módulo traceback para los marcos "
"recuperados por :meth:`get_stack`."

#: ../Doc/library/asyncio-task.rst:865
msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr "El argumento *limit* se pasa directamente a :meth:`get_stack`."

#: ../Doc/library/asyncio-task.rst:867
msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stderr`."
msgstr ""
"El argumento *file* es un flujo de E/S en el que se escribe la salida; por "
"defecto, la salida se escribe en :data:`sys.stderr`."

#: ../Doc/library/asyncio-task.rst:872
msgid "Return the coroutine object wrapped by the :class:`Task`."
msgstr "Retorna el objeto corrutina contenido por :class:`Task`."

#: ../Doc/library/asyncio-task.rst:878
msgid "Return the name of the Task."
msgstr "Retorna el nombre de la Tarea."

#: ../Doc/library/asyncio-task.rst:880
msgid ""
"If no name has been explicitly assigned to the Task, the default asyncio "
"Task implementation generates a default name during instantiation."
msgstr ""
"Si no se ha asignado explícitamente ningún nombre a la Tarea, la "
"implementación de Tarea asyncio predeterminada genera un nombre "
"predeterminado durante la creación de instancias."

#: ../Doc/library/asyncio-task.rst:888
msgid "Set the name of the Task."
msgstr "Establece el nombre de la Tarea."

#: ../Doc/library/asyncio-task.rst:890
msgid ""
"The *value* argument can be any object, which is then converted to a string."
msgstr ""
"El argumento *value* puede ser cualquier objeto, que luego se convierte en "
"una cadena."

#: ../Doc/library/asyncio-task.rst:893
msgid ""
"In the default Task implementation, the name will be visible in the :func:"
"`repr` output of a task object."
msgstr ""
"En la implementación de Task predeterminada, el nombre será visible en la "
"salida :func:`repr` de un objeto de tarea."

#: ../Doc/library/asyncio-task.rst:900
msgid "Return a set of all tasks for an event loop."
msgstr "Retorna un conjunto de todas las tareas para un bucle de eventos."

#: ../Doc/library/asyncio-task.rst:902
msgid ""
"By default all tasks for the current event loop are returned. If *loop* is "
"``None``, the :func:`get_event_loop` function is used to get the current "
"loop."
msgstr ""
"De forma predeterminada, se retornan todas las tareas del bucle de eventos "
"actual. Si *loop* es ``None``, la función :func:`get_event_loop` se utiliza "
"para obtener el bucle actual."

#: ../Doc/library/asyncio-task.rst:908
msgid ""
"Do not call this as a task method. Use the :func:`asyncio.all_tasks` "
"function instead."
msgstr ""
"No llame a esto como un método de tarea. Utilice la función :func:`asyncio."
"all_tasks` en su lugar."

#: ../Doc/library/asyncio-task.rst:913
msgid "Return the currently running task or ``None``."
msgstr "Retorna la tarea que se está ejecutando actualmente o ``None``."

#: ../Doc/library/asyncio-task.rst:915
msgid ""
"If *loop* is ``None``, the :func:`get_event_loop` function is used to get "
"the current loop."
msgstr ""
"Si *bucle* es ``None``, la función :func:`get_event_loop` se utiliza para "
"obtener el bucle actual."

#: ../Doc/library/asyncio-task.rst:920
msgid ""
"Do not call this as a task method.  Use the :func:`asyncio.current_task` "
"function instead."
msgstr ""
"No llame a esto como un método de tarea. Utilice la función :func:`asyncio."
"current_task` en su lugar."

#: ../Doc/library/asyncio-task.rst:927
msgid "Generator-based Coroutines"
msgstr "Corrutinas basadas en generadores"

#: ../Doc/library/asyncio-task.rst:931
msgid ""
"Support for generator-based coroutines is **deprecated** and is scheduled "
"for removal in Python 3.10."
msgstr ""
"La compatibilidad con corrutinas basadas en generadores está **en desuso** y "
"está programada para su eliminación en Python 3.10."

#: ../Doc/library/asyncio-task.rst:934
msgid ""
"Generator-based coroutines predate async/await syntax.  They are Python "
"generators that use ``yield from`` expressions to await on Futures and other "
"coroutines."
msgstr ""
"Las corrutinas basadas en generadores son anteriores a la sintaxis async/"
"await. Son generadores de Python que utilizan expresiones ``yield from`` "
"para esperar en Futuros y otras corrutinas."

#: ../Doc/library/asyncio-task.rst:938
msgid ""
"Generator-based coroutines should be decorated with :func:`@asyncio."
"coroutine <asyncio.coroutine>`, although this is not enforced."
msgstr ""
"Las corrutinas basadas en generadores deben estar decoradas con :func:"
"`@asyncio.coroutine <asyncio.coroutine>`, aunque esto no se aplica."

#: ../Doc/library/asyncio-task.rst:945
msgid "Decorator to mark generator-based coroutines."
msgstr "Decorador para marcar corrutinas basadas en generadores."

# No sé si legacy está bien traducido dado el contexto
#: ../Doc/library/asyncio-task.rst:947
#, fuzzy
msgid ""
"This decorator enables legacy generator-based coroutines to be compatible "
"with async/await code::"
msgstr ""
"Este decorador permite que las corrutinas basadas en generadores heredados "
"sean compatibles con el código async/await::"

#: ../Doc/library/asyncio-task.rst:957
msgid "This decorator should not be used for :keyword:`async def` coroutines."
msgstr ""
"Este decorador no debe utilizarse para corrutinas :keyword:`async def`."

#: ../Doc/library/asyncio-task.rst:962
msgid "Use :keyword:`async def` instead."
msgstr "Usar :keyword:`async def` en su lugar."

#: ../Doc/library/asyncio-task.rst:966
msgid "Return ``True`` if *obj* is a :ref:`coroutine object <coroutine>`."
msgstr "Retorna ``True`` si *obj* es un :ref:`coroutine object <coroutine>`."

#: ../Doc/library/asyncio-task.rst:968
msgid ""
"This method is different from :func:`inspect.iscoroutine` because it returns "
"``True`` for generator-based coroutines."
msgstr ""
"Este método es diferente de :func:`inspect.iscoroutine` porque retorna "
"``True`` para corrutinas basadas en generadores."

#: ../Doc/library/asyncio-task.rst:973
msgid "Return ``True`` if *func* is a :ref:`coroutine function <coroutine>`."
msgstr ""
"Retorna ``True`` si *func* es una :ref:`coroutine function <coroutine>`."

#: ../Doc/library/asyncio-task.rst:976
msgid ""
"This method is different from :func:`inspect.iscoroutinefunction` because it "
"returns ``True`` for generator-based coroutine functions decorated with :"
"func:`@coroutine <coroutine>`."
msgstr ""
"Este método es diferente de :func:`inspect.iscoroutinefunction` porque "
"retorna ``True`` para funciones de corrutinas basadas en generadores "
"decoradas con :func:`@coroutine <coroutine>`."
