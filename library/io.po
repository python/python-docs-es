# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-05 12:54+0200\n"
"PO-Revision-Date: 2020-07-27 18:51-0400\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Last-Translator: Douglas Cueva <dougcueva@gmail.com>\n"
"Language: io\n"
"X-Generator: Poedit 2.3.1\n"

#: ../Doc/library/io.rst:2
msgid ":mod:`io` --- Core tools for working with streams"
msgstr ":mod:`io` --- Herramientas principales para trabajar con *streams*"

#: ../Doc/library/io.rst:15
msgid "**Source code:** :source:`Lib/io.py`"
msgstr "**Código fuente:** :source:`Lib/io.py`"

#: ../Doc/library/io.rst:22
msgid "Overview"
msgstr "Resumen"

#: ../Doc/library/io.rst:27
msgid ""
"The :mod:`io` module provides Python's main facilities for dealing with "
"various types of I/O.  There are three main types of I/O: *text I/O*, "
"*binary I/O* and *raw I/O*.  These are generic categories, and various "
"backing stores can be used for each of them.  A concrete object belonging to "
"any of these categories is called a :term:`file object`.  Other common terms "
"are *stream* and *file-like object*."
msgstr ""
"El módulo :mod:`io` provee las facilidades principales de Python para "
"manejar diferentes tipos de E/S. Hay tres diferentes tipos de E/S: *texto E/"
"S*, *binario E/S* e *E/S sin formato*. Estas son categorías generales y "
"varios respaldos de almacenamiento se pueden usar para cada una de ellas. Un "
"objeto concreto perteneciendo a cualquiera de estas categorías se llama un :"
"term:`file object`. Otros términos comunes son *stream* y *file-like object*."

#: ../Doc/library/io.rst:34
msgid ""
"Independent of its category, each concrete stream object will also have "
"various capabilities: it can be read-only, write-only, or read-write. It can "
"also allow arbitrary random access (seeking forwards or backwards to any "
"location), or only sequential access (for example in the case of a socket or "
"pipe)."
msgstr ""
"Independiente de su categoría, cada objeto *stream* también tendrá varias "
"capacidades: puede ser solamente para lectura, solo escritura, or lectura y "
"escritura. También permite arbitrariamente acceso aleatorio (buscando "
"adelante o hacia atrás en cualquier lugar) o solamente acceso secuencial "
"(por ejemplo en el caso de un *socket* o *pipe*)."

#: ../Doc/library/io.rst:40
msgid ""
"All streams are careful about the type of data you give to them.  For "
"example giving a :class:`str` object to the ``write()`` method of a binary "
"stream will raise a :exc:`TypeError`.  So will giving a :class:`bytes` "
"object to the ``write()`` method of a text stream."
msgstr ""
"Todas los *streams* son cuidadosas del tipo de datos que se les provee. Por "
"ejemplo dando un objeto de clase :class:`str` al método ``write()`` de un "
"*stream* binaria lanzará un :exc:`TypeError`. También dándole un objeto de "
"tipo :class:`bytes` al método ``write()`` de un *stream* de tipo texto."

#: ../Doc/library/io.rst:45
msgid ""
"Operations that used to raise :exc:`IOError` now raise :exc:`OSError`, "
"since :exc:`IOError` is now an alias of :exc:`OSError`."
msgstr ""
"Operaciones que lanzarán un :exc:`IOError` ahora lanzan :exc:`OSError`, ya "
"que :exc:`IOError` es un alias de :exc:`OSError`."

#: ../Doc/library/io.rst:51 ../Doc/library/io.rst:777
#: ../Doc/library/io.rst:1032
msgid "Text I/O"
msgstr "E/S Texto"

#: ../Doc/library/io.rst:53
msgid ""
"Text I/O expects and produces :class:`str` objects.  This means that "
"whenever the backing store is natively made of bytes (such as in the case of "
"a file), encoding and decoding of data is made transparently as well as "
"optional translation of platform-specific newline characters."
msgstr ""
"E/S de tipo texto espera y produce objetos de clase :class:`str`. Esto "
"significa que cuando el respaldo de almacenamiento está compuesto de forma "
"nativa de *bytes* (como en el caso de un archivo), la codificación y "
"descodificación de datos está hecho de forma transparente tanto como "
"traducción opcional de caracteres de nueva línea específicos de la "
"plataforma."

#: ../Doc/library/io.rst:58
msgid ""
"The easiest way to create a text stream is with :meth:`open()`, optionally "
"specifying an encoding::"
msgstr ""
"La manera más fácil de crear un *stream* de tipo texto es con el método :"
"meth:`open()`, con la opción de especificar una codificación::"

#: ../Doc/library/io.rst:63
msgid ""
"In-memory text streams are also available as :class:`StringIO` objects::"
msgstr ""
"*Streams* de texto en memoria también están disponibles como objetos de "
"tipo :class:`StringIO`::"

#: ../Doc/library/io.rst:67
msgid ""
"The text stream API is described in detail in the documentation of :class:"
"`TextIOBase`."
msgstr ""
"El *API* (interfaz de programación de aplicaciones) de *streams* tipo texto "
"está descrito con detalle en la documentación de :class:`TextIOBase`."

#: ../Doc/library/io.rst:72 ../Doc/library/io.rst:1020
msgid "Binary I/O"
msgstr "E/S Binaria"

# I'm not sure if I have to translate the <bytes-like object> link
#: ../Doc/library/io.rst:74
msgid ""
"Binary I/O (also called *buffered I/O*) expects :term:`bytes-like objects "
"<bytes-like object>` and produces :class:`bytes` objects.  No encoding, "
"decoding, or newline translation is performed.  This category of streams can "
"be used for all kinds of non-text data, and also when manual control over "
"the handling of text data is desired."
msgstr ""
"E/S binaria (también conocido como *buffered E/S*) espera :term:`objetos "
"tipo bytes<bytes-like object>` y produce objetos tipo :class:`bytes`. No se "
"hace codificación, descodificación, o traducciones de nueva línea. Esta "
"categoría de *streams* puede ser usada para todos tipos de datos sin texto, "
"y también cuando se desea control manual sobre el manejo de dato textual."

#: ../Doc/library/io.rst:80
msgid ""
"The easiest way to create a binary stream is with :meth:`open()` with "
"``'b'`` in the mode string::"
msgstr ""
"La manera más fácil para crear un *stream* binario es con el método :meth:"
"`open()` con ``'b'`` en el modo de la cadena de caracteres::"

#: ../Doc/library/io.rst:85
msgid ""
"In-memory binary streams are also available as :class:`BytesIO` objects::"
msgstr ""
"Los *streams* binarios en memoria también están disponibles como objetos "
"tipo :class:`BytesIO`::"

#: ../Doc/library/io.rst:89
msgid ""
"The binary stream API is described in detail in the docs of :class:"
"`BufferedIOBase`."
msgstr ""
"El *API* de *stream* binario está descrito con detalle en la documentación "
"de :class:`BufferedIOBase`."

#: ../Doc/library/io.rst:92
msgid ""
"Other library modules may provide additional ways to create text or binary "
"streams.  See :meth:`socket.socket.makefile` for example."
msgstr ""
"Otros módulos bibliotecarios pueden proveer maneras alternativas para crear "
"*streams* de tipo texto o binario. Ver :meth:`socket.socket.makefile` como "
"ejemplo."

#: ../Doc/library/io.rst:97
msgid "Raw I/O"
msgstr "E/S sin formato"

#: ../Doc/library/io.rst:99
msgid ""
"Raw I/O (also called *unbuffered I/O*) is generally used as a low-level "
"building-block for binary and text streams; it is rarely useful to directly "
"manipulate a raw stream from user code.  Nevertheless, you can create a raw "
"stream by opening a file in binary mode with buffering disabled::"
msgstr ""
"E/S sin formato (también conocido como *unbuffered E/S*) es generalmente "
"usado como un fundamento de nivel bajo para *streams* binario y tipo texto; "
"es raramente útil para manipular directamente *streams* sin formatos del "
"código de usuario. Sin embargo puedes crear un *stream* sin formato abriendo "
"un archivo en modo binario con el búfer apagado::"

#: ../Doc/library/io.rst:106
msgid ""
"The raw stream API is described in detail in the docs of :class:`RawIOBase`."
msgstr ""
"El *API* de *streams* sin formato está descrito con detalle en la "
"documentación de :class:`RawIOBase`."

#: ../Doc/library/io.rst:110
msgid "High-level Module Interface"
msgstr "Interfaz de módulo de alto nivel"

#: ../Doc/library/io.rst:114
msgid ""
"An int containing the default buffer size used by the module's buffered I/O "
"classes.  :func:`open` uses the file's blksize (as obtained by :func:`os."
"stat`) if possible."
msgstr ""
"Un *int* que contiene el búfer de tamaño predeterminado usado por las clases "
"de tipo E/S. :func:`open` utiliza el *blksize* del archivo (obtenido por :"
"func:`os.stat`) si es posible."

#: ../Doc/library/io.rst:121
msgid "This is an alias for the builtin :func:`open` function."
msgstr "Esto es un alias para la función incorporada :func:`open`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``open`` with arguments ``path``, "
"``mode``, ``flags``."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``open`` con los "
"argumentos``path``, ``mode``, ``flags``."

#: ../Doc/library/io.rst:125
msgid ""
"This function raises an :ref:`auditing event <auditing>` ``open`` with "
"arguments ``path``, ``mode`` and ``flags``. The ``mode`` and ``flags`` "
"arguments may have been modified or inferred from the original call."
msgstr ""
"Esta función lanza un :ref:`evento de auditoría <auditing>` ``open`` con los "
"argumentos ``path``, ``mode`` y ``flags``. Los argumentos ``mode`` y "
"``flags`` pueden haber sido modificados o inferido desde el pedido original."

#: ../Doc/library/io.rst:132
msgid ""
"Opens the provided file with mode ``'rb'``. This function should be used "
"when the intent is to treat the contents as executable code."
msgstr ""
"Abre el archivo dado con el modo ``'rb'``. Esta función debe ser usado "
"cuando la intención es tratar el contenido como código ejecutable."

#: ../Doc/library/io.rst:135
msgid "``path`` should be a :class:`str` and an absolute path."
msgstr "``path`` debe ser un :class:`str` y una ruta absoluta."

#: ../Doc/library/io.rst:137
msgid ""
"The behavior of this function may be overridden by an earlier call to the :c:"
"func:`PyFile_SetOpenCodeHook`. However, assuming that ``path`` is a :class:"
"`str` and an absolute path, ``open_code(path)`` should always behave the "
"same as ``open(path, 'rb')``. Overriding the behavior is intended for "
"additional validation or preprocessing of the file."
msgstr ""
"Se puede anular el comportamiento de esta función haciendo un pedido "
"anterior a :c:func:`PyFile_SetOpenCodeHook`. Sin embargo, asumiendo que "
"``path`` es un :class:`str` y una ruta absoluta, ``open_code(path)`` debería "
"manejarse al igual que ``open(path, ‘rb')``. El propósito de anular el "
"comportamiento existe para validación adicional o para el preprocesamiento "
"del archivo."

#: ../Doc/library/io.rst:148
msgid ""
"This is a compatibility alias for the builtin :exc:`BlockingIOError` "
"exception."
msgstr ""
"Esto es un alias de compatibilidad para la incorporada excepción :exc:"
"`BlockingIOError`."

#: ../Doc/library/io.rst:154
msgid ""
"An exception inheriting :exc:`OSError` and :exc:`ValueError` that is raised "
"when an unsupported operation is called on a stream."
msgstr ""
"Una excepción heredando :exc:`OSError` y :exc:`ValueError` que es generado "
"cuando se llama a una operación no admitida en un *stream*."

#: ../Doc/library/io.rst:159
msgid "In-memory streams"
msgstr "*Streams* en memoria"

#: ../Doc/library/io.rst:161
msgid ""
"It is also possible to use a :class:`str` or :term:`bytes-like object` as a "
"file for both reading and writing.  For strings :class:`StringIO` can be "
"used like a file opened in text mode.  :class:`BytesIO` can be used like a "
"file opened in binary mode.  Both provide full read-write capabilities with "
"random access."
msgstr ""
"Es posible usar un :class:`str` o :term:`bytes-like object` como un archivo "
"para lectura y escritura. Para cadena de caracteres :class:`StringIO` pueden "
"ser usados como un archivo abierto en modo texto. :class:`BytesIO` puede ser "
"usado como un archivo abierto in modo binario. Ambos proveen completa "
"capacidad para lectura y escritura con acceso aleatorio."

#: ../Doc/library/io.rst:171
msgid ":mod:`sys`"
msgstr ":mod:`sys`"

#: ../Doc/library/io.rst:171
msgid ""
"contains the standard IO streams: :data:`sys.stdin`, :data:`sys.stdout`, "
"and :data:`sys.stderr`."
msgstr ""
"contiene los *streams* estándar de IO :data:`sys.stdin`, :data:`sys.stdout`, "
"y :data:`sys.stderr`."

#: ../Doc/library/io.rst:176
msgid "Class hierarchy"
msgstr "Jerarquía de clases"

#: ../Doc/library/io.rst:178
msgid ""
"The implementation of I/O streams is organized as a hierarchy of classes.  "
"First :term:`abstract base classes <abstract base class>` (ABCs), which are "
"used to specify the various categories of streams, then concrete classes "
"providing the standard stream implementations."
msgstr ""
"La implementación de *streams* E/S está organizada como una jerarquía de "
"clases. Primero :term:`abstract base classes <abstract base class>` (ABC), "
"que son usados para especificar las varias categorías de *streams*, luego "
"las clases concretas proveen un *stream* estándar de implementaciones."

#: ../Doc/library/io.rst:185
msgid ""
"The abstract base classes also provide default implementations of some "
"methods in order to help implementation of concrete stream classes.  For "
"example, :class:`BufferedIOBase` provides unoptimized implementations of :"
"meth:`~IOBase.readinto` and :meth:`~IOBase.readline`."
msgstr ""
"Las clases abstractas base también proveen implementaciones predeterminadas "
"de algunos métodos para ayudar implementar clases de *streams* concretos. "
"Por ejemplo, :class:`BufferedIOBase` proporciona implementaciones no "
"optimizadas de :meth:`~IOBase.readinto` y :meth:`~IOBase.readline`."

#: ../Doc/library/io.rst:190
msgid ""
"At the top of the I/O hierarchy is the abstract base class :class:`IOBase`.  "
"It defines the basic interface to a stream.  Note, however, that there is no "
"separation between reading and writing to streams; implementations are "
"allowed to raise :exc:`UnsupportedOperation` if they do not support a given "
"operation."
msgstr ""
"En la parte superior de la jerarquía E/S está la clase abstracta base :class:"
"`IOBase`. Define la interfaz básica del *stream*. Tenga en cuenta que no hay "
"separación entre *streams* de lectura y escritura; implementaciones están "
"permitidos lanzar :exc:`UnsupportedOperation` si no apoyan la operación."

#: ../Doc/library/io.rst:195
msgid ""
"The :class:`RawIOBase` ABC extends :class:`IOBase`.  It deals with the "
"reading and writing of bytes to a stream.  :class:`FileIO` subclasses :class:"
"`RawIOBase` to provide an interface to files in the machine's file system."
msgstr ""
"La clase :class:`RawIOBase` extiende :class:`IOBase`. Maneja la lectura y "
"escritura de bytes a un *stream*. :class:`FileIO` subclasifica :class:"
"`RawIOBase` para proveer una interfaz a los archivos en el sistema de "
"archivos de la máquina."

#: ../Doc/library/io.rst:199
msgid ""
"The :class:`BufferedIOBase` ABC deals with buffering on a raw byte stream (:"
"class:`RawIOBase`).  Its subclasses, :class:`BufferedWriter`, :class:"
"`BufferedReader`, and :class:`BufferedRWPair` buffer streams that are "
"readable, writable, and both readable and writable.  :class:`BufferedRandom` "
"provides a buffered interface to random access streams.  Another :class:"
"`BufferedIOBase` subclass, :class:`BytesIO`, is a stream of in-memory bytes."
msgstr ""
"La :class:`BufferedIOBase` ABC maneja el búfer en un *stream* de *bytes* sin "
"formato (:class:`RawIOBase`). Sus subclasificaciones, :class:"
"`BufferedWriter`, :class:`BufferedReader`, y :class:`BufferedRWPair` "
"*streams* de búfer que son legible, grabable, y ambos legible y grabable.  :"
"class:`BufferedRandom` provee un interfaz búfer a *streams* de acceso "
"aleatorio. Otra subclasificación :class:`BufferedIOBase`, :class:`BytesIO`, "
"es un *stream* de *bytes* en memoria."

#: ../Doc/library/io.rst:207
msgid ""
"The :class:`TextIOBase` ABC, another subclass of :class:`IOBase`, deals with "
"streams whose bytes represent text, and handles encoding and decoding to and "
"from strings. :class:`TextIOWrapper`, which extends it, is a buffered text "
"interface to a buffered raw stream (:class:`BufferedIOBase`). Finally, :"
"class:`StringIO` is an in-memory stream for text."
msgstr ""
"El :class:`TextIOBase` ABC, otra subclasificación de :class:`IOBase`, trata "
"con los *streams* cuyos *bytes* representan texto, y maneja la codificación "
"y descodificación para cadenas de caracteres y de estos mismos. :class:"
"`TextIOWrapper`, que extiende a este, es un interfaz textual almacenado un "
"*stream* sin formato amortiguado (:class:`BufferedIOBase`). Finalmente, :"
"class:`StringIO`  es una *stream* en memoria para texto."

#: ../Doc/library/io.rst:213
msgid ""
"Argument names are not part of the specification, and only the arguments of :"
"func:`open` are intended to be used as keyword arguments."
msgstr ""
"Los nombres de los argumentos no son parte de la especificación, y solo los "
"argumentos de :func:`open` están destinados a ser utilizados como argumentos "
"de palabras clave."

#: ../Doc/library/io.rst:216
msgid ""
"The following table summarizes the ABCs provided by the :mod:`io` module:"
msgstr ""
"La siguiente tabla resume los ABC proporcionado por el módulo :mod:`io` "
"module:"

#: ../Doc/library/io.rst:221
msgid "ABC"
msgstr "ABC"

#: ../Doc/library/io.rst:221
msgid "Inherits"
msgstr "Hereda"

#: ../Doc/library/io.rst:221
msgid "Stub Methods"
msgstr "Métodos de trozos (*Stub*)"

#: ../Doc/library/io.rst:221
msgid "Mixin Methods and Properties"
msgstr "Métodos Mixin y propiedades"

#: ../Doc/library/io.rst:223 ../Doc/library/io.rst:228
#: ../Doc/library/io.rst:230 ../Doc/library/io.rst:232
msgid ":class:`IOBase`"
msgstr ":class:`IOBase`"

#: ../Doc/library/io.rst:223
msgid "``fileno``, ``seek``, and ``truncate``"
msgstr "``fileno``, ``seek``, and ``truncate``"

#: ../Doc/library/io.rst:223
msgid ""
"``close``, ``closed``, ``__enter__``, ``__exit__``, ``flush``, ``isatty``, "
"``__iter__``, ``__next__``, ``readable``, ``readline``, ``readlines``, "
"``seekable``, ``tell``, ``writable``, and ``writelines``"
msgstr ""
"``close``, ``closed``, ``__enter__``, ``__exit__``, ``flush``, ``isatty``, "
"``__iter__``, ``__next__``, ``readable``, ``readline``, ``readlines``, "
"``seekable``, ``tell``, ``writable``, and ``writelines``"

#: ../Doc/library/io.rst:228
msgid ":class:`RawIOBase`"
msgstr ":class:`RawIOBase`"

#: ../Doc/library/io.rst:228
msgid "``readinto`` and ``write``"
msgstr "``readinto`` and ``write``"

#: ../Doc/library/io.rst:228
msgid "Inherited :class:`IOBase` methods, ``read``, and ``readall``"
msgstr "Métodos :class:`IOBase` heredados, ``read``, and ``readall``"

#: ../Doc/library/io.rst:230
msgid ":class:`BufferedIOBase`"
msgstr ":class:`BufferedIOBase`"

#: ../Doc/library/io.rst:230
msgid "``detach``, ``read``, ``read1``, and ``write``"
msgstr "``detach``, ``read``, ``read1``, and ``write``"

#: ../Doc/library/io.rst:230
msgid "Inherited :class:`IOBase` methods, ``readinto``, and ``readinto1``"
msgstr "Métodos :class:`IOBase` heredados, ``readinto``, and ``readinto1``"

#: ../Doc/library/io.rst:232
msgid ":class:`TextIOBase`"
msgstr ":class:`TextIOBase`"

#: ../Doc/library/io.rst:232
msgid "``detach``, ``read``, ``readline``, and ``write``"
msgstr "``detach``, ``read``, ``readline``, and ``write``"

#: ../Doc/library/io.rst:232
msgid ""
"Inherited :class:`IOBase` methods, ``encoding``, ``errors``, and ``newlines``"
msgstr ""
"Métodos :class:`IOBase` heredados, ``encoding``, ``errors``, and ``newlines``"

#: ../Doc/library/io.rst:239
msgid "I/O Base Classes"
msgstr "Clases base E/S"

#: ../Doc/library/io.rst:243
msgid ""
"The abstract base class for all I/O classes, acting on streams of bytes. "
"There is no public constructor."
msgstr ""
"La clase base abstracta para todas las clases de tipo E/S, actuando sobre "
"*streams* de *bytes*. No hay constructor público."

#: ../Doc/library/io.rst:246
msgid ""
"This class provides empty abstract implementations for many methods that "
"derived classes can override selectively; the default implementations "
"represent a file that cannot be read, written or seeked."
msgstr ""
"Esta clase provee implementaciones abstractas vacías para muchos métodos que "
"clases que derivadas pueden anular selectivamente; la implementación "
"predeterminada representa un archivo que no se puede leer, grabar o ser "
"buscado."

#: ../Doc/library/io.rst:251
msgid ""
"Even though :class:`IOBase` does not declare :meth:`read` or :meth:`write` "
"because their signatures will vary, implementations and clients should "
"consider those methods part of the interface.  Also, implementations may "
"raise a :exc:`ValueError` (or :exc:`UnsupportedOperation`) when operations "
"they do not support are called."
msgstr ""
"Aunque :class:`IOBase` no declara el método :meth:`read` o :meth:`write` "
"porque sus firmas varían, implementaciones y clientes deberían considerar "
"usar métodos como parte de la interfaz. Las implementaciones también podrían "
"lanzar un :exc:`ValueError` (o :exc:`UnsupportedOperation`) cuando "
"operaciones que estos no apoyan son usados."

#: ../Doc/library/io.rst:257
msgid ""
"The basic type used for binary data read from or written to a file is :class:"
"`bytes`.  Other :term:`bytes-like objects <bytes-like object>` are accepted "
"as method arguments too.  Text I/O classes work with :class:`str` data."
msgstr ""
"El tipo básico usado para leer datos binarios o grabar un archivo es :class:"
"`bytes`. Otros :term:`bytes-like objects <bytes-like object>` son aceptados "
"como argumentos para métodos también. Clases de tipo E/S funcionan usando "
"datos de tipo :class:`str`."

#: ../Doc/library/io.rst:261
msgid ""
"Note that calling any method (even inquiries) on a closed stream is "
"undefined.  Implementations may raise :exc:`ValueError` in this case."
msgstr ""
"Tenga en cuenta que llamando cualquier método (incluso indagaciones) en un "
"*stream* cerrada es indefinido. En este caso implementaciones podrían lanzar "
"un error :exc:`ValueError`."

#: ../Doc/library/io.rst:264
msgid ""
":class:`IOBase` (and its subclasses) supports the iterator protocol, meaning "
"that an :class:`IOBase` object can be iterated over yielding the lines in a "
"stream.  Lines are defined slightly differently depending on whether the "
"stream is a binary stream (yielding bytes), or a text stream (yielding "
"character strings).  See :meth:`~IOBase.readline` below."
msgstr ""
":class:`IOBase` (y sus subclasificaciones) apoyan el protocolo iterador, "
"significando que un objeto de clase :class:`IOBase` puede ser iterado sobre "
"el rendimiento de las líneas en un *stream* de datos. Líneas son definidas "
"un poco diferente dependiendo si el *stream* es de tipo binario (produciendo "
"*bytes*), o un *stream* de texto (produciendo cadenas de caracteres). Ver :"
"meth:`~IOBase.readline` abajo."

#: ../Doc/library/io.rst:270
msgid ""
":class:`IOBase` is also a context manager and therefore supports the :"
"keyword:`with` statement.  In this example, *file* is closed after the :"
"keyword:`!with` statement's suite is finished---even if an exception occurs::"
msgstr ""
":class:`IOBase` es también un gestor de contexto y por ende apoya la "
"declaración :keyword:`with`. En este ejemplo, *file* es cerrado después de "
"que la declaración :keyword:`!with` termina--incluso si alguna excepción "
"ocurre::"

#: ../Doc/library/io.rst:277
msgid ":class:`IOBase` provides these data attributes and methods:"
msgstr ":class:`IOBase` provee los siguientes atributos y métodos:"

#: ../Doc/library/io.rst:281
msgid ""
"Flush and close this stream. This method has no effect if the file is "
"already closed. Once the file is closed, any operation on the file (e.g. "
"reading or writing) will raise a :exc:`ValueError`."
msgstr ""
"Cierra el *stream*. Este método no tiene efecto si el archivo ya está "
"cerrado. Cuándo está cerrado, cualquier operación que se le haga al archivo "
"(ej. leer or grabar) lanzará el error :exc:`ValueError`."

#: ../Doc/library/io.rst:285
msgid ""
"As a convenience, it is allowed to call this method more than once; only the "
"first call, however, will have an effect."
msgstr ""
"Como conveniencia, se permite llamar este método más que una vez. Sin "
"embargo, solamente el primer llamado tenderá efecto."

#: ../Doc/library/io.rst:290
msgid "``True`` if the stream is closed."
msgstr "``True`` si está cerrada el *stream*."

#: ../Doc/library/io.rst:294
msgid ""
"Return the underlying file descriptor (an integer) of the stream if it "
"exists.  An :exc:`OSError` is raised if the IO object does not use a file "
"descriptor."
msgstr ""
"Retorna el descriptor de archivo subyacente (un número de tipo entero) de el "
"*stream* si existe. Un :exc:`OSError` se lanza si el objeto IO no tiene un "
"archivo descriptor."

#: ../Doc/library/io.rst:300
msgid ""
"Flush the write buffers of the stream if applicable.  This does nothing for "
"read-only and non-blocking streams."
msgstr ""
"Vacía los buffers de grabación del *stream* si corresponde. Esto no hace "
"nada para *streams* que son solamente de lectura o *streams* sin bloqueo."

#: ../Doc/library/io.rst:305
msgid ""
"Return ``True`` if the stream is interactive (i.e., connected to a terminal/"
"tty device)."
msgstr ""
"Retorna ``True``  si el *stream* es interactiva (ej., si está conectado a un "
"terminal o dispositivo tty)."

#: ../Doc/library/io.rst:310
msgid ""
"Return ``True`` if the stream can be read from.  If ``False``, :meth:`read` "
"will raise :exc:`OSError`."
msgstr ""
"Retorna ``True`` si el *stream* puede ser leída. Si es ``False``, el método :"
"meth:`read`  lanzará un :exc:`OSError`."

#: ../Doc/library/io.rst:315
msgid ""
"Read and return one line from the stream.  If *size* is specified, at most "
"*size* bytes will be read."
msgstr ""
"Lee y retorna una línea del *stream*. Si *size* (tamaño) es especificado, se "
"capturará un máximo de ése mismo tamaño especificado en *bytes*."

#: ../Doc/library/io.rst:318
msgid ""
"The line terminator is always ``b'\\n'`` for binary files; for text files, "
"the *newline* argument to :func:`open` can be used to select the line "
"terminator(s) recognized."
msgstr ""
"El terminador de la línea siempre es ``b'\\n'`` para archivos de tipo "
"binario; para archivos de tipo texto el argumento *newline* para la función :"
"func:`open` pueden ser usados para seleccionar las líneas terminadoras "
"reconocidas."

#: ../Doc/library/io.rst:324
msgid ""
"Read and return a list of lines from the stream.  *hint* can be specified to "
"control the number of lines read: no more lines will be read if the total "
"size (in bytes/characters) of all lines so far exceeds *hint*."
msgstr ""
"Lee y retorna una lista de líneas del *stream*. *hint* puede ser "
"especificado para controlar el número de líneas que se lee: no se leerán más "
"líneas si el tamaño total (en *bytes* / caracteres) de todas las líneas "
"excede *hint*."

#: ../Doc/library/io.rst:328
msgid ""
"Note that it's already possible to iterate on file objects using ``for line "
"in file: ...`` without calling ``file.readlines()``."
msgstr ""
"Tenga en cuenta que ya es posible iterar sobre objetos de archivo usando "
"``for line in file: …`` sin llamar ``file.readlines()``."

#: ../Doc/library/io.rst:333
msgid ""
"Change the stream position to the given byte *offset*.  *offset* is "
"interpreted relative to the position indicated by *whence*.  The default "
"value for *whence* is :data:`SEEK_SET`.  Values for *whence* are:"
msgstr ""
"Cambiar la posición del *stream* al dado *byte* *offset*. *offset* se "
"interpreta en relación con la posición indicada por *whence*. El valor dado "
"para *whence* es :data:`SEEK_SET`. Valores para *whence* son:"

#: ../Doc/library/io.rst:337
msgid ""
":data:`SEEK_SET` or ``0`` -- start of the stream (the default); *offset* "
"should be zero or positive"
msgstr ""
":data:`SEEK_SET` o ``0`` -- inicio del *stream* (el dado); *offset* debería "
"ser cero o positivo"

#: ../Doc/library/io.rst:339
msgid ""
":data:`SEEK_CUR` or ``1`` -- current stream position; *offset* may be "
"negative"
msgstr ""
":data:`SEEK_CUR` o ``1`` -- posición actual del *stream*; *offset* puede ser "
"negativo"

#: ../Doc/library/io.rst:341
msgid ""
":data:`SEEK_END` or ``2`` -- end of the stream; *offset* is usually negative"
msgstr ""
":data:`SEEK_END` o ``2`` -- fin del *stream*; *offset* is usualmente negativo"

#: ../Doc/library/io.rst:344
msgid "Return the new absolute position."
msgstr "Retorna la nueva posición absoluta."

#: ../Doc/library/io.rst:346 ../Doc/library/io.rst:853
msgid "The ``SEEK_*`` constants."
msgstr "Los constantes``SEEK_*``."

#: ../Doc/library/io.rst:349
msgid ""
"Some operating systems could support additional values, like :data:`os."
"SEEK_HOLE` or :data:`os.SEEK_DATA`. The valid values for a file could depend "
"on it being open in text or binary mode."
msgstr ""
"Algunos sistemas operativos pueden apoyar valores adicionales, como :data:"
"`os.SEEK_HOLE` o :data:`os.SEEK_DATA`. Los valores válidos para un archivo "
"podrían depender de que esté abierto en modo texto o binario."

#: ../Doc/library/io.rst:356
msgid ""
"Return ``True`` if the stream supports random access.  If ``False``, :meth:"
"`seek`, :meth:`tell` and :meth:`truncate` will raise :exc:`OSError`."
msgstr ""
"Retorna ``True`` si el *stream* apoya acceso aleatorio. Si retorna "
"``False``, :meth:`seek`, :meth:`tell` y :meth:`truncate`  lanzarán :exc:"
"`OSError`."

#: ../Doc/library/io.rst:361
msgid "Return the current stream position."
msgstr "Retorna la posición actual del *stream*."

#: ../Doc/library/io.rst:365
msgid ""
"Resize the stream to the given *size* in bytes (or the current position if "
"*size* is not specified).  The current stream position isn't changed. This "
"resizing can extend or reduce the current file size.  In case of extension, "
"the contents of the new file area depend on the platform (on most systems, "
"additional bytes are zero-filled).  The new file size is returned."
msgstr ""
"Cambia el tamaño del *stream* al *size* dado en *bytes* (o la posición "
"actual si no se especifica *size*). La posición actual del *stream* no se "
"cambia. Este cambio de tamaño puede incrementar o reducir el tamaño actual "
"del archivo. En caso de extensión, los contenidos del área del nuevo archivo "
"depende de la plataforma (en la mayoría de los sistemas *bytes* adicionales "
"son llenos de cero). Se retorna el nuevo tamaño del archivo."

#: ../Doc/library/io.rst:372
msgid "Windows will now zero-fill files when extending."
msgstr "*Windows* llenará los archivos con cero cuando extienda."

#: ../Doc/library/io.rst:377
msgid ""
"Return ``True`` if the stream supports writing.  If ``False``, :meth:`write` "
"and :meth:`truncate` will raise :exc:`OSError`."
msgstr ""
"Retorna ``True`` si el *stream* apoya grabación.  Si retorna ``False``, :"
"meth:`write` y :meth:`truncate` lanzarán :exc:`OSError`."

#: ../Doc/library/io.rst:382
msgid ""
"Write a list of lines to the stream.  Line separators are not added, so it "
"is usual for each of the lines provided to have a line separator at the end."
msgstr ""
"Escribir una lista de líneas al *stream*. No se agrega separadores de "
"líneas, así que es usual que las líneas tengan separador al final."

#: ../Doc/library/io.rst:388
msgid ""
"Prepare for object destruction. :class:`IOBase` provides a default "
"implementation of this method that calls the instance's :meth:`~IOBase."
"close` method."
msgstr ""
"Prepara para la destrucción de un objeto. :class:`IOBase` proporciona una "
"implementación dada de este método que ejecuta las instancias del método :"
"meth:`~IOBase.close`."

#: ../Doc/library/io.rst:395
msgid ""
"Base class for raw binary I/O.  It inherits :class:`IOBase`.  There is no "
"public constructor."
msgstr ""
"Clase base para binarios de tipo E/S sin formato. Hereda la clase :class:"
"`IOBase`. No hay constructor público."

#: ../Doc/library/io.rst:398
msgid ""
"Raw binary I/O typically provides low-level access to an underlying OS "
"device or API, and does not try to encapsulate it in high-level primitives "
"(this is left to Buffered I/O and Text I/O, described later in this page)."
msgstr ""
"E/S binario sin formato proporciona acceso de nivel bajo a algún dispositivo "
"del sistema operativo o API, y no intenta de encapsular primitivos de alto "
"nivel (esta función se le deja a E/S de tipo búfer y E/S de tipo texto; esto "
"se describe más adelante)."

#: ../Doc/library/io.rst:402
msgid ""
"In addition to the attributes and methods from :class:`IOBase`, :class:"
"`RawIOBase` provides the following methods:"
msgstr ""
"Además de los atributos y métodos de :class:`IOBase`, la clase :class:"
"`RawIOBase` proporciona los siguientes métodos:"

#: ../Doc/library/io.rst:407
msgid ""
"Read up to *size* bytes from the object and return them.  As a convenience, "
"if *size* is unspecified or -1, all bytes until EOF are returned. Otherwise, "
"only one system call is ever made.  Fewer than *size* bytes may be returned "
"if the operating system call returns fewer than *size* bytes."
msgstr ""
"Lee hasta el *size* de los *bytes* del objeto y los retorna. Como "
"conveniencia si no se especifica *size* o es -1, se retornan todos los "
"*bytes* hasta que se retorne el fin del archivo. Sino, se hace solo un "
"llamado al sistema. Se pueden retornar menos de *size* *bytes* si la llamada "
"del sistema operativo retorna menos de *size* *bytes*."

#: ../Doc/library/io.rst:412
msgid ""
"If 0 bytes are returned, and *size* was not 0, this indicates end of file. "
"If the object is in non-blocking mode and no bytes are available, ``None`` "
"is returned."
msgstr ""
"Si se retorna 0 *bytes* y el *size* no era 0, esto indica que es el fin del "
"archivo. Si el objeto está en modo sin bloqueo y no hay *bytes* disponibles, "
"se retorna ``None``."

#: ../Doc/library/io.rst:416
msgid ""
"The default implementation defers to :meth:`readall` and :meth:`readinto`."
msgstr ""
"La implementación dada difiera al método :meth:`readall` y :meth:`readinto`."

#: ../Doc/library/io.rst:421
msgid ""
"Read and return all the bytes from the stream until EOF, using multiple "
"calls to the stream if necessary."
msgstr ""
"Lee y retorna todos los *bytes* del *stream* hasta llegar al fin del "
"archivo, usando, si es necesario, varias llamadas al *stream*."

#: ../Doc/library/io.rst:426
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b*, and "
"return the number of bytes read.  For example, *b* might be a :class:"
"`bytearray`. If the object is in non-blocking mode and no bytes are "
"available, ``None`` is returned."
msgstr ""
"Lee *bytes* en objeto pre-asignado y grabable :term:`bytes-like object` *b*, "
"y retorna el número de *bytes* leído. Por ejemplo, *b* puede ser una clase "
"de tipo :class:`bytearray`. Si el objeto está en modo sin bloquear y no hay "
"*bytes* disponibles, se retorna ``None``."

#: ../Doc/library/io.rst:434
msgid ""
"Write the given :term:`bytes-like object`, *b*, to the underlying raw "
"stream, and return the number of bytes written.  This can be less than the "
"length of *b* in bytes, depending on specifics of the underlying raw stream, "
"and especially if it is in non-blocking mode.  ``None`` is returned if the "
"raw stream is set not to block and no single byte could be readily written "
"to it.  The caller may release or mutate *b* after this method returns, so "
"the implementation should only access *b* during the method call."
msgstr ""
"Escribe :term:`bytes-like object` dado, *b*, al *stream* subyacente y "
"retorna la cantidad de *bytes* grabadas. Esto puede ser menos que la "
"longitud de *b* en *bytes*, dependiendo de la especificaciones del *stream* "
"subyacente, especialmente si no está en modo no-bloqueo. ``None`` se retorna "
"si el *stream* sin formato está configurado para no bloquear y ningún *byte* "
"puede ser rápidamente grabada. El llamador puede deshacer o mutar *b* "
"después que retorne este método, así que la implementación solo debería "
"acceder *b* durante la ejecución al método."

#: ../Doc/library/io.rst:447
msgid ""
"Base class for binary streams that support some kind of buffering. It "
"inherits :class:`IOBase`. There is no public constructor."
msgstr ""
"Clase base para *streams* binarios que apoyan algún tipo de búfer. Hereda :"
"class:`IOBase`. No hay constructor público."

#: ../Doc/library/io.rst:450
msgid ""
"The main difference with :class:`RawIOBase` is that methods :meth:`read`, :"
"meth:`readinto` and :meth:`write` will try (respectively) to read as much "
"input as requested or to consume all given output, at the expense of making "
"perhaps more than one system call."
msgstr ""
"La diferencia principal de :class:`RawIOBase` es que los métodos :meth:"
"`read`, :meth:`readinto` y :meth:`write` intentarán (respectivamente) leer "
"la cantidad de información solicitada o consumir toda la salida dada, a "
"expensas de hacer más de una llamada al sistema."

#: ../Doc/library/io.rst:455
msgid ""
"In addition, those methods can raise :exc:`BlockingIOError` if the "
"underlying raw stream is in non-blocking mode and cannot take or give enough "
"data; unlike their :class:`RawIOBase` counterparts, they will never return "
"``None``."
msgstr ""
"Adicionalmente, esos métodos pueden lanzar un :exc:`BlockingIOError` si el "
"*stream* sin formato subyacente está en modo no bloqueo y no puede obtener "
"or dar más datos; a diferencia de sus contrapartes :class:`RawIOBase`, estos "
"nunca retornarán ``None``."

#: ../Doc/library/io.rst:460
msgid ""
"Besides, the :meth:`read` method does not have a default implementation that "
"defers to :meth:`readinto`."
msgstr ""
"Además, el método :meth:`read` no tiene una implementación dada que difiere "
"al método :meth:`readinto`."

#: ../Doc/library/io.rst:463
msgid ""
"A typical :class:`BufferedIOBase` implementation should not inherit from a :"
"class:`RawIOBase` implementation, but wrap one, like :class:`BufferedWriter` "
"and :class:`BufferedReader` do."
msgstr ""
"Una implementación típica de :class:`BufferedIOBase` no debería heredar una "
"implementación de :class:`RawIOBase`, es más, debería envolver como uno, así "
"como hacen las clases :class:`BufferedWriter` y :class:`BufferedReader`."

#: ../Doc/library/io.rst:467
msgid ""
":class:`BufferedIOBase` provides or overrides these methods and attribute in "
"addition to those from :class:`IOBase`:"
msgstr ""
":class:`BufferedIOBase` provee o anula estos métodos y atributos en adición "
"a los de :class:`IOBase`:"

#: ../Doc/library/io.rst:472
msgid ""
"The underlying raw stream (a :class:`RawIOBase` instance) that :class:"
"`BufferedIOBase` deals with.  This is not part of the :class:"
"`BufferedIOBase` API and may not exist on some implementations."
msgstr ""
"El *stream* sin formato subyacente ( una instancia :class:`RawIOBase`) que :"
"class:`BufferedIOBase` maneja. Esto no es parte de la API :class:"
"`BufferedIOBase` y posiblemente no exista en algunas implementaciones."

#: ../Doc/library/io.rst:478
msgid "Separate the underlying raw stream from the buffer and return it."
msgstr "Separa el *stream* subyacente del búfer y lo retorna."

#: ../Doc/library/io.rst:480
msgid ""
"After the raw stream has been detached, the buffer is in an unusable state."
msgstr ""
"Luego que el *stream* sin formato ha sido separado, el búfer está en un "
"estado inutilizable."

#: ../Doc/library/io.rst:483
msgid ""
"Some buffers, like :class:`BytesIO`, do not have the concept of a single raw "
"stream to return from this method.  They raise :exc:`UnsupportedOperation`."
msgstr ""
"Algunos búfer, como :class:`BytesIO`, no tienen el concepto de un *stream* "
"sin formato singular para retornar de este método. Lanza un :exc:"
"`UnsupportedOperation`."

#: ../Doc/library/io.rst:491
msgid ""
"Read and return up to *size* bytes.  If the argument is omitted, ``None``, "
"or negative, data is read and returned until EOF is reached.  An empty :"
"class:`bytes` object is returned if the stream is already at EOF."
msgstr ""
"Lee y retorna hasta *size* en *bytes*. Si el argumento está omitido, "
"``None``, o es negativo, los datos son leídos y retornados hasta que se "
"alcance el fin del archivo. Un objeto :class:`bytes` vacío se retorna si el "
"*stream* está al final del archivo."

#: ../Doc/library/io.rst:495
msgid ""
"If the argument is positive, and the underlying raw stream is not "
"interactive, multiple raw reads may be issued to satisfy the byte count "
"(unless EOF is reached first).  But for interactive raw streams, at most one "
"raw read will be issued, and a short result does not imply that EOF is "
"imminent."
msgstr ""
"Si el argumento es positivo, y el *stream* subyacente no es interactiva, "
"varias lecturas sin formato pueden ser otorgadas para satisfacer la cantidad "
"de *byte* (al menos que primero se llegue al fin del archivo). Pero para los "
"*streams* sin formato interactivas, a lo sumo una lectura sin formato será  "
"emitida y un resultado corto no implica que se haya llegado al fin del "
"archivo."

#: ../Doc/library/io.rst:501 ../Doc/library/io.rst:524
#: ../Doc/library/io.rst:534
msgid ""
"A :exc:`BlockingIOError` is raised if the underlying raw stream is in non "
"blocking-mode, and has no data available at the moment."
msgstr ""
"Un :exc:`BlockingIOError` se lanza si el *stream* subyacente está en modo no "
"bloqueo y no tiene datos al momento."

#: ../Doc/library/io.rst:506
msgid ""
"Read and return up to *size* bytes, with at most one call to the underlying "
"raw stream's :meth:`~RawIOBase.read` (or :meth:`~RawIOBase.readinto`) "
"method.  This can be useful if you are implementing your own buffering on "
"top of a :class:`BufferedIOBase` object."
msgstr ""
"Lee y retorna hasta *size* en *bytes* con al menos una llamada al método :"
"meth:`~RawIOBase.read` (o :meth:`~RawIOBase.readinto`) del *stream* "
"subyacente. Esto puede ser útil si estás implementando tu propio búfer por "
"encima de un objeto :class:`BufferedIOBase`."

#: ../Doc/library/io.rst:512
msgid ""
"If *size* is ``-1`` (the default), an arbitrary number of bytes are returned "
"(more than zero unless EOF is reached)."
msgstr ""
"Si *size* es ``-1`` (el valor dado) se retorna un monto arbitrario de "
"*bytes* (más que cero al menos que se haya llegado al fin del archivo)."

#: ../Doc/library/io.rst:517
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b* and "
"return the number of bytes read. For example, *b* might be a :class:"
"`bytearray`."
msgstr ""
"Lee *bytes* a un objeto predeterminado y grabable :term:`bytes-like object` "
"*b* y retorna el número de *bytes* leídos. Por ejemplo, *b* puede ser un :"
"class:`bytearray`."

#: ../Doc/library/io.rst:521
msgid ""
"Like :meth:`read`, multiple reads may be issued to the underlying raw "
"stream, unless the latter is interactive."
msgstr ""
"Como :meth:`read`, varias lecturas pueden ser otorgadas al *stream* sin "
"formato subyacente al menos que esto último sea interactivo."

#: ../Doc/library/io.rst:529
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b*, "
"using at most one call to the underlying raw stream's :meth:`~RawIOBase."
"read` (or :meth:`~RawIOBase.readinto`) method. Return the number of bytes "
"read."
msgstr ""
"Leer *bytes* a un objeto predeterminado y grabable :term:`bytes-like object` "
"*b* usando por lo menos una llamada al método :meth:`~RawIOBase.read` (o :"
"meth:`~RawIOBase.readinto`) del *stream* subyacente. Retorna la cantidad de "
"*bytes* leídas."

#: ../Doc/library/io.rst:541
msgid ""
"Write the given :term:`bytes-like object`, *b*, and return the number of "
"bytes written (always equal to the length of *b* in bytes, since if the "
"write fails an :exc:`OSError` will be raised).  Depending on the actual "
"implementation, these bytes may be readily written to the underlying stream, "
"or held in a buffer for performance and latency reasons."
msgstr ""
"Escribe el :term:`bytes-like object` dado, *b*, y retorna el número de bytes "
"grabados (siempre el equivalente en longitud de *b* en bytes, ya que si "
"falla la grabación se lanza un :exc:`OSError`). Dependiendo en la "
"implementación actual estos bytes pueden ser grabados rápidamente al "
"*stream* subyacente o mantenido en un búfer por razones de rendimiento y "
"latencia."

#: ../Doc/library/io.rst:548
msgid ""
"When in non-blocking mode, a :exc:`BlockingIOError` is raised if the data "
"needed to be written to the raw stream but it couldn't accept all the data "
"without blocking."
msgstr ""
"Cuando estás en modo no bloqueo, se lanza un :exc:`BlockingIOError` si los "
"datos tenían que ser grabadas al *stream* sin formato pero no pudo aceptar "
"todos los datos sin bloquear."

#: ../Doc/library/io.rst:552
msgid ""
"The caller may release or mutate *b* after this method returns, so the "
"implementation should only access *b* during the method call."
msgstr ""
"El llamador puede otorgar o mutar *b* después que este método retorne algo, "
"entonces la implementación debería acceder solamente a *b* durante la "
"llamada al método."

#: ../Doc/library/io.rst:557
msgid "Raw File I/O"
msgstr "Archivo sin formato E/S"

#: ../Doc/library/io.rst:561
msgid ""
":class:`FileIO` represents an OS-level file containing bytes data. It "
"implements the :class:`RawIOBase` interface (and therefore the :class:"
"`IOBase` interface, too)."
msgstr ""
":class:`FileIO` representa un archivo de nivel OS conteniendo datos en "
"*bytes*. Implementa la interfaz :class:`RawIOBase` (y por ende también la "
"interfaz :class:`IOBase`)."

#: ../Doc/library/io.rst:565
msgid "The *name* can be one of two things:"
msgstr "El *name* puede ser una de dos cosas:"

#: ../Doc/library/io.rst:567
msgid ""
"a character string or :class:`bytes` object representing the path to the "
"file which will be opened. In this case closefd must be ``True`` (the "
"default) otherwise an error will be raised."
msgstr ""
"una cadena de caracteres u objeto de tipo :class:`bytes` representando la "
"ruta del archivo en la que fue abierto. En este caso *closefd* es ``True`` "
"(el valor dado) de otra manera un error será dada."

#: ../Doc/library/io.rst:570
msgid ""
"an integer representing the number of an existing OS-level file descriptor "
"to which the resulting :class:`FileIO` object will give access. When the "
"FileIO object is closed this fd will be closed as well, unless *closefd* is "
"set to ``False``."
msgstr ""
"un *integer* representando el número de descriptores de archivos de nivel OS "
"que resultan dando acceso a través del objeto :class:`FileIO`. Cuando el "
"objeto *FileIO* está cerrado este fd cerrará también a no ser que *closefd* "
"esté configurado a ``False``."

#: ../Doc/library/io.rst:575
msgid ""
"The *mode* can be ``'r'``, ``'w'``, ``'x'`` or ``'a'`` for reading "
"(default), writing, exclusive creation or appending. The file will be "
"created if it doesn't exist when opened for writing or appending; it will be "
"truncated when opened for writing. :exc:`FileExistsError` will be raised if "
"it already exists when opened for creating. Opening a file for creating "
"implies writing, so this mode behaves in a similar way to ``'w'``. Add a "
"``'+'`` to the mode to allow simultaneous reading and writing."
msgstr ""
"El *mode* puede ser ``'r'``, ``'w'``, ``'x'`` o``'a'`` para lectura (el "
"valor dado), grabación, creación exclusiva o anexando. Si no existe el "
"archivo se creará cuando se abra para grabar o anexar; se truncará cuando se "
"abra para grabar. Se lanzará un error :exc:`FileExistsError`   si ya existe "
"cuando se abra para crear. Abriendo un archivo para crear implica grabar "
"entonces este modo se comporta similarmente a ``'w'``. Agrega un ``'+'``  al "
"modo para permitir lectura y grabación simultáneas."

#: ../Doc/library/io.rst:583
msgid ""
"The :meth:`read` (when called with a positive argument), :meth:`readinto` "
"and :meth:`write` methods on this class will only make one system call."
msgstr ""
"Los métodos :meth:`read` (cuando se llama con un argumento positivo), :meth:"
"`readinto` y :meth:`write` en esta clase harán solo una llamada al sistema."

#: ../Doc/library/io.rst:586
msgid ""
"A custom opener can be used by passing a callable as *opener*. The "
"underlying file descriptor for the file object is then obtained by calling "
"*opener* with (*name*, *flags*). *opener* must return an open file "
"descriptor (passing :mod:`os.open` as *opener* results in functionality "
"similar to passing ``None``)."
msgstr ""
"Un abridor personalizado puede ser usado pasando un llamador como *opener*. "
"El descriptor de archivo subyacente es obtenido llamando *opener* con "
"(*name*, *flags*). *opener* debe retornar un descriptor de archivo abierto "
"(pasando :mod:`os.open` como *opener* resulta con funcionamiento similar a "
"pasando ``None``)."

#: ../Doc/library/io.rst:592
msgid "The newly created file is :ref:`non-inheritable <fd_inheritance>`."
msgstr "El archivo recién creado es :ref:`non-inheritable <fd_inheritance>`."

#: ../Doc/library/io.rst:594
msgid ""
"See the :func:`open` built-in function for examples on using the *opener* "
"parameter."
msgstr ""
"Ver la función incorporada :func:`open` para ejemplos usando el parámetro "
"*opener*."

#: ../Doc/library/io.rst:597
msgid "The *opener* parameter was added. The ``'x'`` mode was added."
msgstr "El parámetro *opener* fue agregado. El modo ``'x'`` fue agregado."

#: ../Doc/library/io.rst:601
msgid "The file is now non-inheritable."
msgstr "El archivo ahora no es heredable."

#: ../Doc/library/io.rst:604
msgid ""
"In addition to the attributes and methods from :class:`IOBase` and :class:"
"`RawIOBase`, :class:`FileIO` provides the following data attributes:"
msgstr ""
"Además de los atributos y métodos de las clases :class:`IOBase` y :class:"
"`RawIOBase`, :class:`FileIO`, estos proveen los siguientes atributos:"

#: ../Doc/library/io.rst:610
msgid "The mode as given in the constructor."
msgstr "El modo dado en el constructor."

#: ../Doc/library/io.rst:614
msgid ""
"The file name.  This is the file descriptor of the file when no name is "
"given in the constructor."
msgstr ""
"El nombre del archivo. Este es el descriptor del archivo cuando no se "
"proporciona ningún nombre en el constructor."

#: ../Doc/library/io.rst:619
msgid "Buffered Streams"
msgstr "*Streams* almacenados (búfer)"

#: ../Doc/library/io.rst:621
msgid ""
"Buffered I/O streams provide a higher-level interface to an I/O device than "
"raw I/O does."
msgstr ""
"*Streams* E/S almacenadas (búfer) proveen una interfaz de más alto nivel a "
"un dispositivo E/S que a un E/S sin formato."

#: ../Doc/library/io.rst:626
msgid ""
"A stream implementation using an in-memory bytes buffer.  It inherits :class:"
"`BufferedIOBase`.  The buffer is discarded when the :meth:`~IOBase.close` "
"method is called."
msgstr ""
"Una implementación de *stream* usando búferes de *bytes* en memoria. Hereda :"
"class:`BufferedIOBase`.  El búfer está descartado cuando se llama al método :"
"meth:`~IOBase.close`."

#: ../Doc/library/io.rst:630
msgid ""
"The optional argument *initial_bytes* is a :term:`bytes-like object` that "
"contains initial data."
msgstr ""
"El argumento opcional *initial_bytes* es un :term:`bytes-like object` que "
"contiene datos iniciales."

#: ../Doc/library/io.rst:633
msgid ""
":class:`BytesIO` provides or overrides these methods in addition to those "
"from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""
":class:`BytesIO` provee o anula estos métodos además de los de :class:"
"`BufferedIOBase` y :class:`IOBase`:"

#: ../Doc/library/io.rst:638
msgid ""
"Return a readable and writable view over the contents of the buffer without "
"copying them.  Also, mutating the view will transparently update the "
"contents of the buffer::"
msgstr ""
"Retorna una vista legible y grabable acerca de los contenidos del búfer sin "
"copiarlos. Además mutando la vista actualizará de forma transparente los "
"contenidos del búfer::"

#: ../Doc/library/io.rst:649
msgid ""
"As long as the view exists, the :class:`BytesIO` object cannot be resized or "
"closed."
msgstr ""
"Mientras exista la vista el objeto :class:`BytesIO` no se le puede cambiar "
"el tamaño o cerrado."

#: ../Doc/library/io.rst:656
msgid "Return :class:`bytes` containing the entire contents of the buffer."
msgstr "Retorna :class:`bytes` que contiene los contenidos enteros del búfer."

#: ../Doc/library/io.rst:661
msgid "In :class:`BytesIO`, this is the same as :meth:`~BufferedIOBase.read`."
msgstr ""
"En la clase :class:`BytesIO` esto es lo mismo que :meth:`~BufferedIOBase."
"read`."

#: ../Doc/library/io.rst:663 ../Doc/library/io.rst:704
msgid "The *size* argument is now optional."
msgstr "Ahora es opcional el argumento *size*."

#: ../Doc/library/io.rst:668
msgid ""
"In :class:`BytesIO`, this is the same as :meth:`~BufferedIOBase.readinto`."
msgstr ""
"En la clase :class:`BytesIO` esto es lo mismo que :meth:`~BufferedIOBase."
"readinto`."

#: ../Doc/library/io.rst:674
msgid ""
"A buffer providing higher-level access to a readable, sequential :class:"
"`RawIOBase` object.  It inherits :class:`BufferedIOBase`. When reading data "
"from this object, a larger amount of data may be requested from the "
"underlying raw stream, and kept in an internal buffer. The buffered data can "
"then be returned directly on subsequent reads."
msgstr ""
"Un búfer dando un nivel de alto acceso a un objeto  :class:`RawIOBase` "
"legible y secuencial. Hereda :class:`BufferedIOBase`. Al leer datos de este "
"objeto se puede solicitar una mayor cantidad de datos del *stream* sin "
"formato subyacente, y mantener el búfer interno. Los datos que han pasado "
"por el proceso de búfer pueden ser retornados directamente en lecturas "
"posteriores."

#: ../Doc/library/io.rst:680
msgid ""
"The constructor creates a :class:`BufferedReader` for the given readable "
"*raw* stream and *buffer_size*.  If *buffer_size* is omitted, :data:"
"`DEFAULT_BUFFER_SIZE` is used."
msgstr ""
"El constructor crea un :class:`BufferedReader` para el *stream* legible sin "
"formato *raw* y *buffer_size*. Si se omite *buffer_size* se usa :data:"
"`DEFAULT_BUFFER_SIZE`."

#: ../Doc/library/io.rst:684
msgid ""
":class:`BufferedReader` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""
":class:`BufferedReader` provee o anula los métodos en adición a los de :"
"class:`BufferedIOBase` y :class:`IOBase`:"

#: ../Doc/library/io.rst:689
msgid ""
"Return bytes from the stream without advancing the position.  At most one "
"single read on the raw stream is done to satisfy the call. The number of "
"bytes returned may be less or more than requested."
msgstr ""
"Retorna *bytes* del *stream* sin avanzar la posición. Al menos una lectura "
"se hace al *stream* sin formato para satisfacer el llamado. El número de "
"bytes retornados puede ser menor o mayor al solicitado."

#: ../Doc/library/io.rst:695
msgid ""
"Read and return *size* bytes, or if *size* is not given or negative, until "
"EOF or if the read call would block in non-blocking mode."
msgstr ""
"Lee y retorna *size* *bytes* o si no se da *size*, o es negativo, hasta el "
"fin del archivo o si la llamada leída podría bloquear in modo no bloquear."

#: ../Doc/library/io.rst:700
msgid ""
"Read and return up to *size* bytes with only one call on the raw stream. If "
"at least one byte is buffered, only buffered bytes are returned. Otherwise, "
"one raw stream read call is made."
msgstr ""
"Lee y retorna hasta el tamaño *size* en *bytes* con solo un llamado al "
"*stream*. Si al menos un *byte* pasa por el proceso de búfer, solo se "
"retornan *buffered bytes*. De lo contrario se realiza un llamado de lectura "
"de un *stream* sin formato."

#: ../Doc/library/io.rst:710
msgid ""
"A buffer providing higher-level access to a writeable, sequential :class:"
"`RawIOBase` object.  It inherits :class:`BufferedIOBase`. When writing to "
"this object, data is normally placed into an internal buffer.  The buffer "
"will be written out to the underlying :class:`RawIOBase` object under "
"various conditions, including:"
msgstr ""
"Un búfer que proporciona un nivel alto de acceso a un objeto  :class:"
"`RawIOBase` grabable y secuencial. Hereda :class:`BufferedIOBase`. Al "
"escribir a este objeto, los datos normalmente se colocan en un búfer "
"interno. El búfer se escribirá en el objeto :class:`RawIOBase` subyacente "
"bajo varias condiciones, incluyendo:"

#: ../Doc/library/io.rst:716
msgid "when the buffer gets too small for all pending data;"
msgstr ""
"cuando el búfer se vuelve demasiado pequeño para todos los datos pendientes;"

#: ../Doc/library/io.rst:717
msgid "when :meth:`flush()` is called;"
msgstr "cuando se llama :meth:`flush()`;"

#: ../Doc/library/io.rst:718
msgid ""
"when a :meth:`seek()` is requested (for :class:`BufferedRandom` objects);"
msgstr ""
"cuando se pide un método :meth:`seek()` (para objetos "
":class:`BufferedRandom`);"

#: ../Doc/library/io.rst:719
msgid "when the :class:`BufferedWriter` object is closed or destroyed."
msgstr "cuando el objeto :class:`BufferedWriter` is cerrado o anulado."

#: ../Doc/library/io.rst:721
msgid ""
"The constructor creates a :class:`BufferedWriter` for the given writeable "
"*raw* stream.  If the *buffer_size* is not given, it defaults to :data:"
"`DEFAULT_BUFFER_SIZE`."
msgstr ""
"El constructor crea un :class:`BufferedWriter` para el *stream* grabable "
"*raw*. Si no es dado el *buffer_size*, recurre el valor :data:"
"`DEFAULT_BUFFER_SIZE`."

#: ../Doc/library/io.rst:725
msgid ""
":class:`BufferedWriter` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""
":class:`BufferedWriter` provee o anula estos métodos además de los de :class:"
"`BufferedIOBase` y :class:`IOBase`:"

#: ../Doc/library/io.rst:730
msgid ""
"Force bytes held in the buffer into the raw stream.  A :exc:"
"`BlockingIOError` should be raised if the raw stream blocks."
msgstr ""
"Forzar bytes retenidos en el búfer al *stream* sin formato. Un :exc:"
"`BlockingIOError` debería ser lanzado si el *stream* sin formato bloquea."

#: ../Doc/library/io.rst:735
msgid ""
"Write the :term:`bytes-like object`, *b*, and return the number of bytes "
"written.  When in non-blocking mode, a :exc:`BlockingIOError` is raised if "
"the buffer needs to be written out but the raw stream blocks."
msgstr ""
"Escribe el :term:`bytes-like object`, *b*, y retorna el número de bytes "
"grabados. Cuando estás en modo no-bloqueo, se lanza un :exc:"
"`BlockingIOError` si el búfer tiene que ser escrito pero el *stream* sin "
"formato bloquea."

#: ../Doc/library/io.rst:743
msgid ""
"A buffered interface to random access streams.  It inherits :class:"
"`BufferedReader` and :class:`BufferedWriter`."
msgstr ""
"Una interfaz búfer para *streams* de acceso aleatorio. Hereda :class:"
"`BufferedReader` y :class:`BufferedWriter`."

#: ../Doc/library/io.rst:746
msgid ""
"The constructor creates a reader and writer for a seekable raw stream, given "
"in the first argument.  If the *buffer_size* is omitted it defaults to :data:"
"`DEFAULT_BUFFER_SIZE`."
msgstr ""
"El constructor crea un lector y una grabación para un *stream* sin formato "
"buscable, dado en el primer argumento. Si se omite el *buffer_size* este "
"recae sobre el valor predeterminado :data:`DEFAULT_BUFFER_SIZE`."

#: ../Doc/library/io.rst:750
msgid ""
":class:`BufferedRandom` is capable of anything :class:`BufferedReader` or :"
"class:`BufferedWriter` can do.  In addition, :meth:`seek` and :meth:`tell` "
"are guaranteed to be implemented."
msgstr ""
":class:`BufferedRandom` es capaz de todo lo que puede hacer :class:"
"`BufferedReader` o :class:`BufferedWriter`. Adicionalmente, se garantiza "
"implementar :meth:`seek` y :meth:`tell`."

#: ../Doc/library/io.rst:757
msgid ""
"A buffered I/O object combining two unidirectional :class:`RawIOBase` "
"objects -- one readable, the other writeable -- into a single bidirectional "
"endpoint.  It inherits :class:`BufferedIOBase`."
msgstr ""
"Un objeto búfer E/S combinando dos objetos :class:`RawIOBase` "
"unidireccionales -- uno legible y el otro escribible -- a un punto final "
"singular bidireccional. Hereda :class:`BufferedIOBase`."

#: ../Doc/library/io.rst:761
msgid ""
"*reader* and *writer* are :class:`RawIOBase` objects that are readable and "
"writeable respectively.  If the *buffer_size* is omitted it defaults to :"
"data:`DEFAULT_BUFFER_SIZE`."
msgstr ""
"*reader* y *writer* son objetos :class:`RawIOBase` que son respectivamente "
"legibles y escribibles. Si se omite *buffer_size* este se recae sobre el "
"valor predeterminado :data:`DEFAULT_BUFFER_SIZE`."

#: ../Doc/library/io.rst:765
msgid ""
":class:`BufferedRWPair` implements all of :class:`BufferedIOBase`\\'s "
"methods except for :meth:`~BufferedIOBase.detach`, which raises :exc:"
"`UnsupportedOperation`."
msgstr ""
":class:`BufferedRWPair` implementa todos los métodos de :class:"
"`BufferedIOBase` excepto por :meth:`~BufferedIOBase.detach`, que lanza un :"
"exc:`UnsupportedOperation`."

#: ../Doc/library/io.rst:771
msgid ""
":class:`BufferedRWPair` does not attempt to synchronize accesses to its "
"underlying raw streams.  You should not pass it the same object as reader "
"and writer; use :class:`BufferedRandom` instead."
msgstr ""
":class:`BufferedRWPair` no intenta sincronizar accesos al *stream* sin "
"formato subyacente. No debes pasar el mismo objeto como legible y "
"escribible; usa :class:`BufferedRandom` en su lugar."

#: ../Doc/library/io.rst:781
msgid ""
"Base class for text streams.  This class provides a character and line based "
"interface to stream I/O.  It inherits :class:`IOBase`. There is no public "
"constructor."
msgstr ""
"Clase base para los *streams* de tipo texto. Esta clase proporciona una "
"interfaz basada en caracteres y líneas para transmitir E/S. Hereda :class:"
"`IOBase`. No hay constructor público."

#: ../Doc/library/io.rst:785
msgid ""
":class:`TextIOBase` provides or overrides these data attributes and methods "
"in addition to those from :class:`IOBase`:"
msgstr ""
":class:`TextIOBase` provee o anula estos atributos y métodos de datos además "
"de los de :class:`IOBase`:"

#: ../Doc/library/io.rst:790
msgid ""
"The name of the encoding used to decode the stream's bytes into strings, and "
"to encode strings into bytes."
msgstr ""
"El nombre de la codificación utilizada para decodificar los *bytes* del "
"*stream* a cadenas de caracteres y para codificar cadenas de caracteres en "
"bytes."

#: ../Doc/library/io.rst:795
msgid "The error setting of the decoder or encoder."
msgstr "La configuración de error del decodificador o codificador."

#: ../Doc/library/io.rst:799
msgid ""
"A string, a tuple of strings, or ``None``, indicating the newlines "
"translated so far.  Depending on the implementation and the initial "
"constructor flags, this may not be available."
msgstr ""
"Una cadena de caracteres, una tupla de cadena de caracteres, o ``None``, "
"indicando las nuevas líneas traducidas hasta ese momento. Dependiendo de la "
"implementación y los indicadores iniciales del constructor, esto puede no "
"estar disponible."

#: ../Doc/library/io.rst:805
msgid ""
"The underlying binary buffer (a :class:`BufferedIOBase` instance) that :"
"class:`TextIOBase` deals with.  This is not part of the :class:`TextIOBase` "
"API and may not exist in some implementations."
msgstr ""
"El búfer binario subyacente (una instancia :class:`BufferedIOBase`) que "
"maneja :class:`TextIOBase`. Esto no es parte del API de :class:`TextIOBase` "
"y puede no existir en algunas implementaciones."

#: ../Doc/library/io.rst:811
msgid ""
"Separate the underlying binary buffer from the :class:`TextIOBase` and "
"return it."
msgstr ""
"Separa el búfer binario subyacente de :class:`TextIOBase` y lo retorna."

#: ../Doc/library/io.rst:814
msgid ""
"After the underlying buffer has been detached, the :class:`TextIOBase` is in "
"an unusable state."
msgstr ""
"Una vez que se ha separado el búfer subyacente, la :class:`TextIOBase` está "
"en un estado inutilizable."

#: ../Doc/library/io.rst:817
msgid ""
"Some :class:`TextIOBase` implementations, like :class:`StringIO`, may not "
"have the concept of an underlying buffer and calling this method will raise :"
"exc:`UnsupportedOperation`."
msgstr ""
"Algunas implementaciones de :class:`TextIOBase`, como :class:`StringIO`, "
"puede no tener el concepto de un búfer subyacente y llamar a este método se "
"lanzará :exc:`UnsupportedOperation`."

#: ../Doc/library/io.rst:825
msgid ""
"Read and return at most *size* characters from the stream as a single :class:"
"`str`.  If *size* is negative or ``None``, reads until EOF."
msgstr ""
"Lee y retorna como máximo *size* caracteres del *stream* como un :class:"
"`str` singular. Si *size* es negativo o ``None``, lee hasta llegar al fin "
"del archivo."

#: ../Doc/library/io.rst:830
msgid ""
"Read until newline or EOF and return a single ``str``.  If the stream is "
"already at EOF, an empty string is returned."
msgstr ""
"Leer hasta la nueva línea o fin del archivo y retorna un ``str`` singular. "
"Si el *stream* está al fin del archivo una cadena de caracteres se retorna."

#: ../Doc/library/io.rst:833
msgid "If *size* is specified, at most *size* characters will be read."
msgstr "Si se especifica *size* como máximo *size* de caracteres será leído."

#: ../Doc/library/io.rst:837
msgid ""
"Change the stream position to the given *offset*.  Behaviour depends on the "
"*whence* parameter.  The default value for *whence* is :data:`SEEK_SET`."
msgstr ""
"Cambia la posición del *stream* dada *offset*. El comportamiento depende del "
"parámetro *whence*. El valor dado de *whence* es :data:`SEEK_SET`."

#: ../Doc/library/io.rst:841
msgid ""
":data:`SEEK_SET` or ``0``: seek from the start of the stream (the default); "
"*offset* must either be a number returned by :meth:`TextIOBase.tell`, or "
"zero.  Any other *offset* value produces undefined behaviour."
msgstr ""
":data:`SEEK_SET` o ``0``: buscar el inicio del *stream* (el dado); *offset* "
"debería ser un número dado por :meth:`TextIOBase.tell`, o cero. Cualquier "
"otro valor *offset* produce comportamiento indefinido."

#: ../Doc/library/io.rst:845
msgid ""
":data:`SEEK_CUR` or ``1``: \"seek\" to the current position; *offset* must "
"be zero, which is a no-operation (all other values are unsupported)."
msgstr ""
":data:`SEEK_CUR` o ``1``: buscar la posición actual; *offset* debería ser "
"cero, que es una operación no (no se apoya ningún otro valor)."

#: ../Doc/library/io.rst:848
msgid ""
":data:`SEEK_END` or ``2``: seek to the end of the stream; *offset* must be "
"zero (all other values are unsupported)."
msgstr ""
":data:`SEEK_END` o ``2``: buscar el fin del *stream*; *offset* debería ser "
"cero (cualquier otro valor no es apoyado)."

#: ../Doc/library/io.rst:851
msgid "Return the new absolute position as an opaque number."
msgstr "Retorna la nueva posición absoluta como un número opaco."

#: ../Doc/library/io.rst:858
msgid ""
"Return the current stream position as an opaque number.  The number does not "
"usually represent a number of bytes in the underlying binary storage."
msgstr ""
"Retorna la posición actual de la secuencia como un número opaco. El número "
"no suele representar una cantidad de bytes en el almacenamiento binario "
"subyacente."

#: ../Doc/library/io.rst:864
msgid ""
"Write the string *s* to the stream and return the number of characters "
"written."
msgstr ""
"Escribe la cadena de caracteres *s* al *stream* y retorna el número de "
"caracteres grabadas."

#: ../Doc/library/io.rst:871
msgid ""
"A buffered text stream over a :class:`BufferedIOBase` binary stream. It "
"inherits :class:`TextIOBase`."
msgstr ""
"Una secuencia de texto almacenado sobre un *stream* binario :class:"
"`BufferedIOBase`. Hereda :class:`TextIOBase`."

#: ../Doc/library/io.rst:874
msgid ""
"*encoding* gives the name of the encoding that the stream will be decoded or "
"encoded with.  It defaults to :func:`locale.getpreferredencoding(False) "
"<locale.getpreferredencoding>`."
msgstr ""
"*encoding* da el nombre de la codificación con que el *stream* será "
"codificada o descodificado. Se da al valor predeterminado :func:`locale."
"getpreferredencoding(False) <locale.getpreferredencoding>`."

#: ../Doc/library/io.rst:878
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled.  Pass ``'strict'`` to raise a :exc:`ValueError` "
"exception if there is an encoding error (the default of ``None`` has the "
"same effect), or pass ``'ignore'`` to ignore errors.  (Note that ignoring "
"encoding errors can lead to data loss.)  ``'replace'`` causes a replacement "
"marker (such as ``'?'``) to be inserted where there is malformed data. "
"``'backslashreplace'`` causes malformed data to be replaced by a backslashed "
"escape sequence.  When writing, ``'xmlcharrefreplace'`` (replace with the "
"appropriate XML character reference)  or ``'namereplace'`` (replace with ``"
"\\N{...}`` escape sequences) can be used.  Any other error handling name "
"that has been registered with :func:`codecs.register_error` is also valid."
msgstr ""
"*errors* es una cadena de caracteres opcional que especifica cómo se manejan "
"los errores codificados y descodificados. Pasa ``'strict'`` para lanzar una "
"excepción :exc:`ValueError` si hay un error codificado (el valor "
"predeterminado ``None`` tiene el mismo efecto), o pasa ``'ignore'`` para "
"ignorar errores. (Tenga en cuenta que ignorar errores puede llevar a perder "
"datos). ``'replace'`` causa un marcador de reemplazo (como ``'?'``) para ser "
"insertado donde haya datos mal formados. ``'backslashreplace'`` reemplaza "
"datos mal formados con una secuencia de escape de tipo barra invertida. "
"Cuando se escribe, ``'xmlcharrefreplace'``  (reemplazar con la referencia "
"apropiada de XML) o ``'namereplace'`` (reemplazar con secuencias de "
"caracteres ``\\N{…}``) pueden ser usadas. Cualquier otro nombre de manejador "
"de errores que hayan sido registrados con :func:`codecs.register_error` "
"también son validas."

#: ../Doc/library/io.rst:894
msgid ""
"*newline* controls how line endings are handled.  It can be ``None``, "
"``''``, ``'\\n'``, ``'\\r'``, and ``'\\r\\n'``.  It works as follows:"
msgstr ""
"*newline* controla cómo finalizar las terminaciones de líneas. Pueden ser "
"``None``, ``''``, ``'\\n'``, ``'\\r'``, and ``'\\r\\n'``. Funciona de la "
"siguiente manera:"

#: ../Doc/library/io.rst:897
msgid ""
"When reading input from the stream, if *newline* is ``None``, :term:"
"`universal newlines` mode is enabled.  Lines in the input can end in "
"``'\\n'``, ``'\\r'``, or ``'\\r\\n'``, and these are translated into "
"``'\\n'`` before being returned to the caller.  If it is ``''``, universal "
"newlines mode is enabled, but line endings are returned to the caller "
"untranslated. If it has any of the other legal values, input lines are only "
"terminated by the given string, and the line ending is returned to the "
"caller untranslated."
msgstr ""
"Al leer la entrada del *stream*, si *newline* es ``None``, el modo :term:"
"`universal newlines` está habilitada. Líneas en la entrada pueden terminar "
"en ``'\\n'``, ``'\\r'``, o ``'\\r\\n'``, y estos son traducidos a ``'\\n'`` "
"antes de ser retornados al llamador. Si es ``''``, se habilita el modo "
"universal de nuevas líneas, pero las terminaciones de líneas son retornados "
"al llamador sin traducir. Si tiene cualquiera de los otros valores legales, "
"líneas de ingreso son terminadas por la cadena de caracteres dada, y la "
"línea final se retorna al llamado sin traducir."

#: ../Doc/library/io.rst:906
msgid ""
"When writing output to the stream, if *newline* is ``None``, any ``'\\n'`` "
"characters written are translated to the system default line separator, :"
"data:`os.linesep`.  If *newline* is ``''`` or ``'\\n'``, no translation "
"takes place.  If *newline* is any of the other legal values, any ``'\\n'`` "
"characters written are translated to the given string."
msgstr ""
"Al escribir la salida al *stream*, si *newline* es ``None``, cualquier "
"carácter ``'\\n'`` escrito son traducidos a la línea separador *default* del "
"sistema, :data:`os.linesep`. Si *newline* es ``''`` o ``'\\n'``, la "
"traducción no ocurre. Si *newline* es de cualquier de los otros valores "
"legales, cualquier carácter ``'\\n'`` escrito es traducido a la cadena de "
"caracteres dada."

#: ../Doc/library/io.rst:912
msgid ""
"If *line_buffering* is ``True``, :meth:`flush` is implied when a call to "
"write contains a newline character or a carriage return."
msgstr ""
"Si *line_buffering* es ``True``, se implica :meth:`flush` cuando una llamada "
"a grabar contiene un carácter de nueva línea o un retorno."

#: ../Doc/library/io.rst:915
msgid ""
"If *write_through* is ``True``, calls to :meth:`write` are guaranteed not to "
"be buffered: any data written on the :class:`TextIOWrapper` object is "
"immediately handled to its underlying binary *buffer*."
msgstr ""
"Si *write_through* es ``True``, llamadas a :meth:`write` no garantizan ser "
"pasados por el proceso de búfer: cualquier dato grabado en el objeto :class:"
"`TextIOWrapper` es inmediatamente manejado por el *buffer* binario "
"subyacente."

#: ../Doc/library/io.rst:919
msgid "The *write_through* argument has been added."
msgstr "Se ha agregado el argumento *write_through*."

#: ../Doc/library/io.rst:922
msgid ""
"The default *encoding* is now ``locale.getpreferredencoding(False)`` instead "
"of ``locale.getpreferredencoding()``. Don't change temporary the locale "
"encoding using :func:`locale.setlocale`, use the current locale encoding "
"instead of the user preferred encoding."
msgstr ""
"La codificación (*encoding*) por defecto es ahora ``locale."
"getpreferredencoding(False)`` en vez de ``locale.getpreferredencoding()``. "
"No cambie temporalmente la codificación local usando :func:`locale."
"setlocale`, use la codificación local actual en vez del preferido del "
"usuario."

#: ../Doc/library/io.rst:928
msgid ""
":class:`TextIOWrapper` provides these members in addition to those of :class:"
"`TextIOBase` and its parents:"
msgstr ""
":class:`TextIOWrapper` provee estos miembros además de las de :class:"
"`TextIOBase` y sus padres:"

#: ../Doc/library/io.rst:933
msgid "Whether line buffering is enabled."
msgstr "Si el almacenamiento en línea está habilitado."

#: ../Doc/library/io.rst:937
msgid "Whether writes are passed immediately to the underlying binary buffer."
msgstr "Si grabaciones son pasadas inmediatamente al búfer binario subyacente."

#: ../Doc/library/io.rst:945
msgid ""
"Reconfigure this text stream using new settings for *encoding*, *errors*, "
"*newline*, *line_buffering* and *write_through*."
msgstr ""
"Reconfigura este *stream* textual usando las nuevas configuraciones de "
"*encoding*, *errors*, *newline*, *line_buffering* y *write_through*."

#: ../Doc/library/io.rst:948
msgid ""
"Parameters not specified keep current settings, except ``errors='strict'`` "
"is used when *encoding* is specified but *errors* is not specified."
msgstr ""
"Los parámetros que no son especificados mantienen las configuraciones "
"actuales, excepto por ``errors='strict'`` cuando *encoding* se especifica "
"pero *errors* no está especificado."

#: ../Doc/library/io.rst:952
msgid ""
"It is not possible to change the encoding or newline if some data has "
"already been read from the stream. On the other hand, changing encoding "
"after write is possible."
msgstr ""
"No es posible cambiar la codificación o nueva línea si algunos datos han "
"sido captados por el *stream*. Sin embargo, cambiando la codificación "
"después de grabar es posible."

#: ../Doc/library/io.rst:956
msgid ""
"This method does an implicit stream flush before setting the new parameters."
msgstr ""
"Este método hace una nivelación implícita del *stream* antes de configurar "
"los nuevos parámetros."

#: ../Doc/library/io.rst:964
msgid ""
"An in-memory stream for text I/O.  The text buffer is discarded when the :"
"meth:`~IOBase.close` method is called."
msgstr ""
"Un *stream* en memoria para E/S de tipo texto. El búfer de tipo texto es "
"descartado cuando se llama al método :meth:`~IOBase.close`."

#: ../Doc/library/io.rst:967
msgid ""
"The initial value of the buffer can be set by providing *initial_value*. If "
"newline translation is enabled, newlines will be encoded as if by :meth:"
"`~TextIOBase.write`.  The stream is positioned at the start of the buffer."
msgstr ""
"El valor inicial del búfer puede ser configurado dando *initial_value*. Si "
"la traducción de la nueva línea es habilitado, nuevas líneas serán "
"codificado como si fuera por :meth:`~TextIOBase.write`. El *stream* está "
"posicionado al inicio del búfer."

#: ../Doc/library/io.rst:972
msgid ""
"The *newline* argument works like that of :class:`TextIOWrapper`. The "
"default is to consider only ``\\n`` characters as ends of lines and to do no "
"newline translation.  If *newline* is set to ``None``, newlines are written "
"as ``\\n`` on all platforms, but universal newline decoding is still "
"performed when reading."
msgstr ""
"El argumento *newline* funciona como :class:`TextIOWrapper`. El valor dado "
"es considerado solamente como caracteres ``\\n`` al final de las lineas y no "
"hacen ninguna traducción de nuevas lineas. Si *newline* está configurado con "
"``None``, nuevas lineas son escritas como ``\\n`` en todas las plataformas, "
"pero descodificación universal de las nuevas lineas todavía se realiza "
"cuando se lee."

#: ../Doc/library/io.rst:978
msgid ""
":class:`StringIO` provides this method in addition to those from :class:"
"`TextIOBase` and its parents:"
msgstr ""
":class:`StringIO` provee este método además de los de :class:`TextIOBase` y "
"sus padres:"

#: ../Doc/library/io.rst:983
msgid ""
"Return a ``str`` containing the entire contents of the buffer. Newlines are "
"decoded as if by :meth:`~TextIOBase.read`, although the stream position is "
"not changed."
msgstr ""
"Retorna un ``str`` que contiene el contenido entero de los búfer. Nuevas "
"lineas son descodificados como si fuera :meth:`~TextIOBase.read`, aunque la "
"posición de la transmisión no haya cambiado."

#: ../Doc/library/io.rst:987
msgid "Example usage::"
msgstr "Ejemplos de uso::"

#: ../Doc/library/io.rst:1009
msgid ""
"A helper codec that decodes newlines for :term:`universal newlines` mode. It "
"inherits :class:`codecs.IncrementalDecoder`."
msgstr ""
"Un códec auxiliar que descodifica nuevas líneas para el modo :term:"
"`universal newlines`. Hereda :class:`codecs.IncrementalDecoder`."

#: ../Doc/library/io.rst:1014
msgid "Performance"
msgstr "Rendimiento"

#: ../Doc/library/io.rst:1016
msgid ""
"This section discusses the performance of the provided concrete I/O "
"implementations."
msgstr ""
"Esta sección discute el rendimiento de las implementaciones concretas de E/S "
"proporcionadas."

#: ../Doc/library/io.rst:1022
msgid ""
"By reading and writing only large chunks of data even when the user asks for "
"a single byte, buffered I/O hides any inefficiency in calling and executing "
"the operating system's unbuffered I/O routines.  The gain depends on the OS "
"and the kind of I/O which is performed.  For example, on some modern OSes "
"such as Linux, unbuffered disk I/O can be as fast as buffered I/O.  The "
"bottom line, however, is that buffered I/O offers predictable performance "
"regardless of the platform and the backing device.  Therefore, it is almost "
"always preferable to use buffered I/O rather than unbuffered I/O for binary "
"data."
msgstr ""
"Leyendo y grabando solamente grandes porciones de datos incluso cuando el "
"usuario pide para solo un byte, E/S de tipo búfer esconde toda ineficiencia "
"llamando y ejecutando las rutinas E/S del sistema operativo que no ha pasado "
"por el proceso de búfer. La ganancia depende en el OS y el tipo de E/S que "
"se ejecuta. Por ejemplo, en algunos sistemas operativos modernos como Linux, "
"un disco E/S sin búfer puede ser rápido como un E/S búfer. Al final, sin "
"embargo, es que el E/S búfer ofrece rendimiento predecible "
"independientemente de la plataforma y el dispositivo de respaldo. Entonces "
"es siempre preferible user E/S búfer que E/S sin búfer para datos binarios."

#: ../Doc/library/io.rst:1034
msgid ""
"Text I/O over a binary storage (such as a file) is significantly slower than "
"binary I/O over the same storage, because it requires conversions between "
"unicode and binary data using a character codec.  This can become noticeable "
"handling huge amounts of text data like large log files.  Also, :meth:"
"`TextIOWrapper.tell` and :meth:`TextIOWrapper.seek` are both quite slow due "
"to the reconstruction algorithm used."
msgstr ""
"E/S de tipo texto por sobre un almacenamiento binario (como un archivo) es "
"más lento que un E/S binario sobre el mismo almacenamiento porque requiere "
"conversiones entre unicode y datos binarios usando un códec de caracteres. "
"Esto puede ser notable al manejar datos enormes de texto como archivos de "
"registro. También :meth:`TextIOWrapper.tell` y :meth:`TextIOWrapper.seek` "
"son bastante lentos debido al uso del algoritmo de reconstrucción."

#: ../Doc/library/io.rst:1041
msgid ""
":class:`StringIO`, however, is a native in-memory unicode container and will "
"exhibit similar speed to :class:`BytesIO`."
msgstr ""
":class:`StringIO`, sin embargo, es un contenedor unicode nativo en memoria y "
"exhibirá una velocidad similar a :class:`BytesIO`."

#: ../Doc/library/io.rst:1045
msgid "Multi-threading"
msgstr "Multihilo"

#: ../Doc/library/io.rst:1047
msgid ""
":class:`FileIO` objects are thread-safe to the extent that the operating "
"system calls (such as ``read(2)`` under Unix) they wrap are thread-safe too."
msgstr ""
"objetos :class:`FileIO` son seguros para subprocesos en la medida en que las "
"llamadas al sistema operativo(como ``read(2)`` en Unix) que envuelven "
"también son seguros para subprocesos."

#: ../Doc/library/io.rst:1050
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, :class:"
"`BufferedWriter`, :class:`BufferedRandom` and :class:`BufferedRWPair`) "
"protect their internal structures using a lock; it is therefore safe to call "
"them from multiple threads at once."
msgstr ""
"Objetos binarios búfer (instancias de :class:`BufferedReader`, :class:"
"`BufferedWriter`, :class:`BufferedRandom` y :class:`BufferedRWPair`) "
"protegen sus estructuras internas usando un bloqueo; es seguro, entonces, "
"llamarlos de varios hilos a la vez."

#: ../Doc/library/io.rst:1055
msgid ":class:`TextIOWrapper` objects are not thread-safe."
msgstr "objetos :class:`TextIOWrapper` no son seguros para subprocesos."

#: ../Doc/library/io.rst:1058
msgid "Reentrancy"
msgstr "Reentrada"

#: ../Doc/library/io.rst:1060
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, :class:"
"`BufferedWriter`, :class:`BufferedRandom` and :class:`BufferedRWPair`) are "
"not reentrant.  While reentrant calls will not happen in normal situations, "
"they can arise from doing I/O in a :mod:`signal` handler.  If a thread tries "
"to re-enter a buffered object which it is already accessing, a :exc:"
"`RuntimeError` is raised.  Note this doesn't prohibit a different thread "
"from entering the buffered object."
msgstr ""
"Objetos binarios búfer (instancias de :class:`BufferedReader`, :class:"
"`BufferedWriter`, :class:`BufferedRandom` y :class:`BufferedRWPair`) no son "
"reentrante. Mientras llamadas reentrantes no ocurren en situaciones normales "
"pueden surgir haciendo E/S en un manejador :mod:`signal`. Si un hilo trata "
"de entrar de nuevo a un objeto búfer que se está accediendo actualmente, se "
"lanza un :exc:`RuntimeError`. Tenga en cuenta que esto no prohíbe un hilo "
"diferente entrando un objeto búfer."

#: ../Doc/library/io.rst:1068
msgid ""
"The above implicitly extends to text files, since the :func:`open()` "
"function will wrap a buffered object inside a :class:`TextIOWrapper`.  This "
"includes standard streams and therefore affects the built-in function :func:"
"`print()` as well."
msgstr ""
"Lo de arriba de forma implícita extiende a los archivos de tipo texto ya que "
"la función :func:`open()` envolverá un objeto almacenado en un :class:"
"`TextIOWrapper`. Esto incluye *streams* estándar y por ende afecta la "
"función :func:`print()` también."
