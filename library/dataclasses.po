# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2023-02-17 16:40-0300\n"
"Last-Translator: Francisco Mora <fr.morac@duocuc.cl>\n"
"Language: es_ES\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.0\n"

#: ../Doc/library/dataclasses.rst:2
msgid ":mod:`dataclasses` --- Data Classes"
msgstr ":mod:`dataclasses` --- Clases de datos"

#: ../Doc/library/dataclasses.rst:10
msgid "**Source code:** :source:`Lib/dataclasses.py`"
msgstr "**Código fuente:** :source:`Lib/dataclasses.py`"

#: ../Doc/library/dataclasses.rst:14
#, fuzzy
msgid ""
"This module provides a decorator and functions for automatically adding "
"generated :term:`special method`\\s such as :meth:`~object.__init__` and :"
"meth:`~object.__repr__` to user-defined classes.  It was originally "
"described in :pep:`557`."
msgstr ""
"Este módulo provee un decorador y funciones para añadir :term:`métodos "
"especiales <special method>` automáticamente, como :meth:`__init__` y :meth:"
"`__repr__` por ejemplo, a clases definidas por el usuario. Fue originalmente "
"descrito en :pep:`557`."

#: ../Doc/library/dataclasses.rst:19
msgid ""
"The member variables to use in these generated methods are defined using :"
"pep:`526` type annotations.  For example, this code::"
msgstr ""
"Las variables miembro a utilizar en estos métodos generados son definidas "
"teniendo en cuenta anotaciones de tipo :pep:`526`. Por ejemplo, en este "
"código::"

#: ../Doc/library/dataclasses.rst:34
#, fuzzy
msgid ""
"will add, among other things, a :meth:`~object.__init__` that looks like::"
msgstr ""
"Añadirá, además de otros métodos, un método :meth:`__init__` con la "
"siguiente estructura::"

#: ../Doc/library/dataclasses.rst:41
msgid ""
"Note that this method is automatically added to the class: it is not "
"directly specified in the ``InventoryItem`` definition shown above."
msgstr ""
"Es importante observar que este método es añadido a la clase "
"automáticamente; está implícito en la definición de ``InventoryItem`` "
"implementada arriba."

#: ../Doc/library/dataclasses.rst:47
msgid "Module contents"
msgstr "Contenidos del módulo"

#: ../Doc/library/dataclasses.rst:51
msgid ""
"This function is a :term:`decorator` that is used to add generated :term:"
"`special method`\\s to classes, as described below."
msgstr ""
"Esta función es un :term:`decorator` utilizado para añadir a las clases :"
"term:`los métodos especiales <special method>` generados, como se describe a "
"continuación."

#: ../Doc/library/dataclasses.rst:54
msgid ""
"The :func:`dataclass` decorator examines the class to find ``field``\\s.  A "
"``field`` is defined as a class variable that has a :term:`type annotation "
"<variable annotation>`.  With two exceptions described below, nothing in :"
"func:`dataclass` examines the type specified in the variable annotation."
msgstr ""
"El decorador :func:`dataclass` examina la clase para encontrar ``fields``. "
"Un ``field`` ('campo') se define como una variable de clase que tiene una :"
"term:`anotación de variable <variable annotation>`. A excepción de los dos "
"casos descritos debajo, nada en :func:`dataclass` examina el tipo "
"especificado en la anotación de variable."

#: ../Doc/library/dataclasses.rst:60
msgid ""
"The order of the fields in all of the generated methods is the order in "
"which they appear in the class definition."
msgstr ""
"El orden de los campos en los métodos generados es el mismo en el que se "
"encuentran en la definición de la clase."

#: ../Doc/library/dataclasses.rst:63
msgid ""
"The :func:`dataclass` decorator will add various \"dunder\" methods to the "
"class, described below.  If any of the added methods already exist in the "
"class, the behavior depends on the parameter, as documented below. The "
"decorator returns the same class that it is called on; no new class is "
"created."
msgstr ""
"El decorador :func:`dataclass` añade varios métodos "
"\"*dunder*\" (abreviación de *double underline*) a la clase, descritos a "
"continuación. Si alguno de los métodos añadidos ya existe en la definición "
"de la clase, el comportamiento dependerá del parámetro, como se documenta "
"abajo. El decorador retorna la misma clase con la que es llamado, no crea "
"una nueva."

#: ../Doc/library/dataclasses.rst:69
msgid ""
"If :func:`dataclass` is used just as a simple decorator with no parameters, "
"it acts as if it has the default values documented in this signature.  That "
"is, these three uses of :func:`dataclass` are equivalent::"
msgstr ""
"Si :func:`dataclass` es llamado como un simple decorador sin parámetros, "
"actúa con los valores por defecto documentados aquí. Específicamente, los "
"siguientes tres usos de :func:`dataclass` son equivalentes::"

#: ../Doc/library/dataclasses.rst:87
msgid "The parameters to :func:`dataclass` are:"
msgstr "Los parámetros de :func:`dataclass` son:"

#: ../Doc/library/dataclasses.rst:89
#, fuzzy
msgid ""
"``init``: If true (the default), a :meth:`~object.__init__` method will be "
"generated."
msgstr ""
"``init``: Si es verdadero (valor por defecto), el método :meth:`__init__` "
"será generado."

#: ../Doc/library/dataclasses.rst:92
#, fuzzy
msgid ""
"If the class already defines :meth:`~object.__init__`, this parameter is "
"ignored."
msgstr "Si la clase ya define :meth:`__init__`, este parámetro es ignorado."

#: ../Doc/library/dataclasses.rst:95
#, fuzzy
msgid ""
"``repr``: If true (the default), a :meth:`~object.__repr__` method will be "
"generated.  The generated repr string will have the class name and the name "
"and repr of each field, in the order they are defined in the class.  Fields "
"that are marked as being excluded from the repr are not included.  For "
"example: ``InventoryItem(name='widget', unit_price=3.0, "
"quantity_on_hand=10)``."
msgstr ""
"``repr``: Si es verdadero (valor por defecto), el método :meth:`__repr__` es "
"generado. La cadena de representación generada tendrá el nombre de la clase "
"junto al nombre y la representación de cada uno de sus campos, en el mismo "
"orden en el que están definidos en la clase. Es posible indicar que ciertos "
"campos no sean incluidos en la representación. Por ejemplo: "
"``InventoryItem(name='widget', unit_price=3.0, quantity_on_hand=10)``."

#: ../Doc/library/dataclasses.rst:102
#, fuzzy
msgid ""
"If the class already defines :meth:`~object.__repr__`, this parameter is "
"ignored."
msgstr "Si la clase ya define :meth:`__repr__`, este parámetro es ignorado."

#: ../Doc/library/dataclasses.rst:105
#, fuzzy
msgid ""
"``eq``: If true (the default), an :meth:`~object.__eq__` method will be "
"generated.  This method compares the class as if it were a tuple of its "
"fields, in order.  Both instances in the comparison must be of the identical "
"type."
msgstr ""
"``eq``: Si es verdadero (por defecto), el método :meth:`__eq__` es generado. "
"Este método compara entre instancias de la clase representando cada una de "
"ellas mediante una tupla, siendo los elementos de la misma los campos de la "
"clase ubicados en el mismo orden en el que fueron definidos (dos tuplas son "
"iguales si, y sólo si, sus campos son iguales)."

#: ../Doc/library/dataclasses.rst:110
#, fuzzy
msgid ""
"If the class already defines :meth:`~object.__eq__`, this parameter is "
"ignored."
msgstr "Si la clase ya define :meth:`__eq__`, este parámetro es ignorado."

#: ../Doc/library/dataclasses.rst:113
#, fuzzy
msgid ""
"``order``: If true (the default is ``False``), :meth:`~object.__lt__`, :meth:"
"`~object.__le__`, :meth:`~object.__gt__`, and :meth:`~object.__ge__` methods "
"will be generated.  These compare the class as if it were a tuple of its "
"fields, in order.  Both instances in the comparison must be of the identical "
"type.  If ``order`` is true and ``eq`` is false, a :exc:`ValueError` is "
"raised."
msgstr ""
"``order``: Si es verdadero (``False`` es el valor por defecto), los métodos :"
"meth:`__lt__`, :meth:`__le__`, :meth:`__gt__` y :meth:`__ge__` serán "
"generados. Estos métodos comparan la clase como si fuera una tupla con sus "
"campos, en orden. Ambas instancias en la comparación deben ser del mismo "
"tipo. Si ``order`` es verdadero y ``eq`` falso, se lanza una excepción :exc:"
"`ValueError`."

#: ../Doc/library/dataclasses.rst:120
#, fuzzy
msgid ""
"If the class already defines any of :meth:`~object.__lt__`, :meth:`~object."
"__le__`, :meth:`~object.__gt__`, or :meth:`~object.__ge__`, then :exc:"
"`TypeError` is raised."
msgstr ""
"Si la clase ya define :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__` o :meth:"
"`__ge__`, se lanza una excepción :exc:`TypeError`."

#: ../Doc/library/dataclasses.rst:124
#, fuzzy
msgid ""
"``unsafe_hash``: If ``False`` (the default), a :meth:`~object.__hash__` "
"method is generated according to how ``eq`` and ``frozen`` are set."
msgstr ""
"``unsafe_hash``: Si es ``False`` (por defecto), se genera el método :meth:"
"`__hash__` de acuerdo a los valores de ``eq`` y ``frozen`` definidos."

#: ../Doc/library/dataclasses.rst:127
#, fuzzy
msgid ""
":meth:`~object.__hash__` is used by built-in :meth:`hash()`, and when "
"objects are added to hashed collections such as dictionaries and sets.  "
"Having a :meth:`~object.__hash__` implies that instances of the class are "
"immutable. Mutability is a complicated property that depends on the "
"programmer's intent, the existence and behavior of :meth:`~object.__eq__`, "
"and the values of the ``eq`` and ``frozen`` flags in the :func:`dataclass` "
"decorator."
msgstr ""
":meth:`__hash__` es utilizado por la función incorporada :meth:`hash()` y "
"cuando los objetos definidos por la clase son añadidos a colecciones hash, "
"como por ejemplo diccionarios y conjuntos. Definir el método :meth:"
"`__hash__` en una clase implica que sus instancias son inmutables. La "
"mutabilidad es una propiedad compleja, ya que depende de cómo el programador "
"utilice el objeto, la existencia y comportamiento de :meth:`__eq__` y del "
"valor asignado a las flags ``eq`` y ``frozen`` en el decorador :func:"
"`dataclass`."

#: ../Doc/library/dataclasses.rst:134
#, fuzzy
msgid ""
"By default, :func:`dataclass` will not implicitly add a :meth:`~object."
"__hash__` method unless it is safe to do so.  Neither will it add or change "
"an existing explicitly defined :meth:`~object.__hash__` method.  Setting the "
"class attribute ``__hash__ = None`` has a specific meaning to Python, as "
"described in the :meth:`~object.__hash__` documentation."
msgstr ""
"Por defecto, :func:`dataclass` no añade de forma implícita el método :meth:"
"`__hash__` a menos que sea seguro hacerlo. Tampoco añade o cambia un método :"
"meth:`__hash__` previamente definido de forma explícita. Definir el atributo "
"de clase ``__hash__ = None`` tiene un significado específico en Python, "
"descrito en la documentación dedicada a :meth:`__hash__`."

#: ../Doc/library/dataclasses.rst:140
#, fuzzy
msgid ""
"If :meth:`~object.__hash__` is not explicitly defined, or if it is set to "
"``None``, then :func:`dataclass` *may* add an implicit :meth:`~object."
"__hash__` method. Although not recommended, you can force :func:`dataclass` "
"to create a :meth:`~object.__hash__` method with ``unsafe_hash=True``. This "
"might be the case if your class is logically immutable but can nonetheless "
"be mutated. This is a specialized use case and should be considered "
"carefully."
msgstr ""
"Si :meth:`__hash__` no está definido explícitamente, o si está configurado "
"como ``None``, entonces :func:`dataclass` *puede* agregar un método "
"implícito :meth:`__hash__`. Aunque no se recomienda, puede forzar un :func:"
"`dataclass` a crear un método :meth:`__hash__` con ``unsafe_hash=True``. "
"Este podría ser el caso si su clase es lógicamente inmutable pero, no "
"obstante, puede mutar. Este es un caso de uso especializado y debe "
"considerarse detenidamente."

#: ../Doc/library/dataclasses.rst:147
#, fuzzy
msgid ""
"Here are the rules governing implicit creation of a :meth:`~object.__hash__` "
"method.  Note that you cannot both have an explicit :meth:`~object.__hash__` "
"method in your dataclass and set ``unsafe_hash=True``; this will result in "
"a :exc:`TypeError`."
msgstr ""
"A continuación se explican las reglas que se aplican en la creación "
"implícita del método :meth:`__hash__`. Observar que no es compatible definir "
"explícitamente un método :meth:`__hash__` en su clase de datos y al mismo "
"tiempo asignar ``unsafe_hash=True``; esto lanza una excepción :exc:"
"`TypeError`."

#: ../Doc/library/dataclasses.rst:152
#, fuzzy
msgid ""
"If ``eq`` and ``frozen`` are both true, by default :func:`dataclass` will "
"generate a :meth:`~object.__hash__` method for you.  If ``eq`` is true and "
"``frozen`` is false, :meth:`~object.__hash__` will be set to ``None``, "
"marking it unhashable (which it is, since it is mutable).  If ``eq`` is "
"false, :meth:`~object.__hash__` will be left untouched meaning the :meth:"
"`~object.__hash__` method of the superclass will be used (if the superclass "
"is :class:`object`, this means it will fall back to id-based hashing)."
msgstr ""
"Si ``eq`` y ``frozen`` son ambos verdaderos, :func:`dataclass` genera por "
"defecto un método :meth:`hash` por ti. En el caso que ``eq`` sea verdadero y "
"``frozen`` falso, a :meth:`__hash__` se le asigna ``None``, en consecuencia "
"será *unhashable* (lo cual es deseable, ya que es mutable). Si ``eq`` es "
"falso, :meth:`__hash__` permanece sin cambios, por lo que en este caso se "
"hará uso del método :meth:`hash` heredado de la superclase (lo que implica "
"que si la superclase es :class:`object`, se aplicará el *hashing* basado en "
"el id de los objetos)."

#: ../Doc/library/dataclasses.rst:160
#, fuzzy
msgid ""
"``frozen``: If true (the default is ``False``), assigning to fields will "
"generate an exception.  This emulates read-only frozen instances.  If :meth:"
"`~object.__setattr__` or :meth:`~object.__delattr__` is defined in the "
"class, then :exc:`TypeError` is raised.  See the discussion below."
msgstr ""
"``frozen``: Si es verdadero (el valor por defecto es ``False``), cualquier "
"intento de asignación a un campo de la clase lanza una excepción. Esto emula "
"el comportamiento de las instancias congeladas (*frozen*) de sólo lectura. "
"Si :meth:`__setattr__` o :meth:`__delattr__` son definidos en la clase, se "
"lanzará una excepción :exc:`TypeError`. Esto es ampliado más abajo."

#: ../Doc/library/dataclasses.rst:165
#, fuzzy
msgid ""
"``match_args``: If true (the default is ``True``), the ``__match_args__`` "
"tuple will be created from the list of parameters to the generated :meth:"
"`~object.__init__` method (even if :meth:`~object.__init__` is not "
"generated, see above).  If false, or if ``__match_args__`` is already "
"defined in the class, then ``__match_args__`` will not be generated."
msgstr ""
"``match_args``: si es verdadero (el valor predeterminado es ``True``), la "
"tupla ``__match_args__`` se creará a partir de la lista de parámetros para "
"el método :meth:`__init__` generado (incluso si no se genera :meth:"
"`__init__`, consulte más arriba). Si es falso, o si ``__match_args__`` ya "
"está definido en la clase, no se generará ``__match_args__``."

#: ../Doc/library/dataclasses.rst:174
#, fuzzy
msgid ""
"``kw_only``: If true (the default value is ``False``), then all fields will "
"be marked as keyword-only.  If a field is marked as keyword-only, then the "
"only effect is that the :meth:`~object.__init__` parameter generated from a "
"keyword-only field must be specified with a keyword when :meth:`~object."
"__init__` is called.  There is no effect on any other aspect of "
"dataclasses.  See the :term:`parameter` glossary entry for details.  Also "
"see the :const:`KW_ONLY` section."
msgstr ""
"``kw_only``: si es verdadero (el valor predeterminado es ``False``), todos "
"los campos se marcarán solo como palabra clave. Si un campo está marcado "
"como solo de palabra clave, el único efecto es que el parámetro :meth:"
"`__init__` generado a partir de un campo de solo palabra clave debe "
"especificarse con una palabra clave cuando se llama a :meth:`__init__`. No "
"hay ningún efecto sobre ningún otro aspecto de las clases de datos. Consulte "
"la entrada del glosario :term:`parameter` para obtener más detalles. "
"Consulte también la sección :const:`KW_ONLY`."

#: ../Doc/library/dataclasses.rst:185
#, fuzzy
msgid ""
"``slots``: If true (the default is ``False``), :attr:`~object.__slots__` "
"attribute will be generated and new class will be returned instead of the "
"original one. If :attr:`~object.__slots__` is already defined in the class, "
"then :exc:`TypeError` is raised."
msgstr ""
"``slots``: si es verdadero (el valor predeterminado es ``False``), se "
"generará el atributo :attr:`__slots__` y se devolverá una nueva clase en "
"lugar de la original. Si :attr:`__slots__` ya está definido en la clase, se "
"genera :exc:`TypeError`."

#: ../Doc/library/dataclasses.rst:192
#, fuzzy
msgid ""
"If a field name is already included in the ``__slots__`` of a base class, it "
"will not be included in the generated ``__slots__`` to prevent :ref:"
"`overriding them <datamodel-note-slots>`. Therefore, do not use "
"``__slots__`` to retrieve the field names of a dataclass. Use :func:`fields` "
"instead. To be able to determine inherited slots, base class ``__slots__`` "
"may be any iterable, but *not* an iterator."
msgstr ""
"Si un nombre de campo ya está incluido en las ``__slots__`` de una clase "
"base, no se incluirá en las ``__slots__`` generadas para evitar que se "
"`sobreescriban <https://docs.python.org/3/reference/datamodel.html#notes-on-"
"using-slots>`_. Por lo tanto, no utilice ``__slots__`` para recuperar los "
"nombres de campo de una clase de datos. Utilice :func:`fields` en su lugar. "
"Para poder determinar las ranuras heredadas, la clase base ``__slots__`` "
"puede ser cualquier iterable, pero *no* un iterador."

# No estoy seguro de si es correcto traducir slot por "ranura".
#: ../Doc/library/dataclasses.rst:202
msgid ""
"``weakref_slot``: If true (the default is ``False``), add a slot named "
"\"__weakref__\", which is required to make an instance weakref-able.  It is "
"an error to specify ``weakref_slot=True`` without also specifying "
"``slots=True``."
msgstr ""
"``weakref_slot``: Si es verdadero (por defecto es ``False``), añade una "
"ranura llamada \"__weakref__\", que es necesaria para generar una instancia "
"referenciable de forma débil. Es un error especificar ``weakref_slot=True`` "
"sin especificar también ``slots=True``."

#: ../Doc/library/dataclasses.rst:209
msgid ""
"``field``\\s may optionally specify a default value, using normal Python "
"syntax::"
msgstr ""
"Los ``fields`` pueden especificar un valor por defecto opcionalmente, "
"simplemente usando la sintaxis normal de Python::"

#: ../Doc/library/dataclasses.rst:217
#, fuzzy
msgid ""
"In this example, both ``a`` and ``b`` will be included in the added :meth:"
"`~object.__init__` method, which will be defined as::"
msgstr ""
"En este ejemplo, tanto ``a`` como ``b`` serán incluidos en el método :meth:"
"`__init__` agregado, el cual será definido como sigue::"

#: ../Doc/library/dataclasses.rst:222
msgid ""
":exc:`TypeError` will be raised if a field without a default value follows a "
"field with a default value.  This is true whether this occurs in a single "
"class, or as a result of class inheritance."
msgstr ""
"Si, en la definición de una clase, a un campo con valor por defecto le sigue "
"un campo sin valor por defecto será lanzada una excepción :exc:`TypeError`. "
"Esto se aplica también a la implementación de una clase única o como "
"resultado de herencia de clases."

#: ../Doc/library/dataclasses.rst:228
msgid ""
"For common and simple use cases, no other functionality is required.  There "
"are, however, some dataclass features that require additional per-field "
"information.  To satisfy this need for additional information, you can "
"replace the default field value with a call to the provided :func:`field` "
"function.  For example::"
msgstr ""
"Para casos de uso común, estas funcionalidades son suficientes. Sin embargo, "
"existen otras características de las clases de datos que requieren "
"información adicional en ciertos campos. Para satisfacer esta necesidad, es "
"posible reemplazar cualquier valor por defecto de un campo mediante una "
"llamada a la función :func:`field`. Por ejemplo::"

#: ../Doc/library/dataclasses.rst:241
msgid ""
"As shown above, the :const:`MISSING` value is a sentinel object used to "
"detect if some parameters are provided by the user. This sentinel is used "
"because ``None`` is a valid value for some parameters with a distinct "
"meaning.  No code should directly use the :const:`MISSING` value."
msgstr ""
"Como se muestra arriba, el valor :const:`MISSING` es un objeto centinela que "
"se usa para detectar si el usuario proporciona algunos parámetros. Este "
"centinela se utiliza porque ``None`` es un valor válido para algunos "
"parámetros con un significado distinto. Ningún código debe utilizar "
"directamente el valor :const:`MISSING`."

#: ../Doc/library/dataclasses.rst:246
msgid "The parameters to :func:`field` are:"
msgstr "Los parámetros de :func:`field` son:"

#: ../Doc/library/dataclasses.rst:248
msgid ""
"``default``: If provided, this will be the default value for this field.  "
"This is needed because the :meth:`field` call itself replaces the normal "
"position of the default value."
msgstr ""
"``default``: Si es provisto, este será el valor por defecto para este campo. "
"Es necesario que sea definido ya que la propia llamada a :meth:`field` "
"reemplaza la posición normal del valor por defecto."

#: ../Doc/library/dataclasses.rst:252
msgid ""
"``default_factory``: If provided, it must be a zero-argument callable that "
"will be called when a default value is needed for this field.  Among other "
"purposes, this can be used to specify fields with mutable default values, as "
"discussed below.  It is an error to specify both ``default`` and "
"``default_factory``."
msgstr ""
"``default_factory``: Si es provisto, debe ser un objeto invocable sin "
"argumentos, el cual será llamado cuando el valor por defecto de este campo "
"sea necesario. Además de otros propósitos, puede ser utilizado para "
"especificar campos con valores por defecto mutables, como se explica a "
"continuación. Especificar tanto ``default`` como ``default_factory`` resulta "
"en un error."

#: ../Doc/library/dataclasses.rst:258
#, fuzzy
msgid ""
"``init``: If true (the default), this field is included as a parameter to "
"the generated :meth:`~object.__init__` method."
msgstr ""
"``init``: Si es verdadero (por defecto), este campo es incluido como "
"parámetro del método :meth:`__init__` generado."

#: ../Doc/library/dataclasses.rst:261
#, fuzzy
msgid ""
"``repr``: If true (the default), this field is included in the string "
"returned by the generated :meth:`~object.__repr__` method."
msgstr ""
"``repr``: Si es verdadero (por defecto), este campo es incluido en la cadena "
"de caracteres que retorna el método :meth:`__repr__` generado."

#: ../Doc/library/dataclasses.rst:264
#, fuzzy
msgid ""
"``hash``: This can be a bool or ``None``.  If true, this field is included "
"in the generated :meth:`~object.__hash__` method.  If ``None`` (the "
"default), use the value of ``compare``: this would normally be the expected "
"behavior.  A field should be considered in the hash if it's used for "
"comparisons.  Setting this value to anything other than ``None`` is "
"discouraged."
msgstr ""
"``hash``: Su valor puede ser de tipo booleano o ``None``. Si es verdadero, "
"este campo es incluido en el método :meth:`__hash__` generado. Si es "
"``None`` (por defecto), utiliza el valor de ``compare``: normalmente éste es "
"el comportamiento esperado. Un campo debería ser considerado para el *hash* "
"si es compatible con operaciones de comparación. Está desaconsejado "
"establecer este valor en algo que no sea ``None``."

#: ../Doc/library/dataclasses.rst:271
msgid ""
"One possible reason to set ``hash=False`` but ``compare=True`` would be if a "
"field is expensive to compute a hash value for, that field is needed for "
"equality testing, and there are other fields that contribute to the type's "
"hash value.  Even if a field is excluded from the hash, it will still be "
"used for comparisons."
msgstr ""
"Una posible razón para definir ``hash=False`` y ``compare=True`` podría ser "
"el caso en el que computar el valor *hash* para dicho campo es costoso pero "
"el campo es necesario para los métodos de comparación, siempre que existan "
"otros campos que contribuyen al valor hash del tipo. Incluso si un campo se "
"excluye del hash, se seguirá utilizando a la hora de comparar."

#: ../Doc/library/dataclasses.rst:277
#, fuzzy
msgid ""
"``compare``: If true (the default), this field is included in the generated "
"equality and comparison methods (:meth:`~object.__eq__`, :meth:`~object."
"__gt__`, et al.)."
msgstr ""
"``compare``: Si es verdadero (por defecto), este campo es incluido en los "
"métodos de comparación generados (:meth:`__eq__`, :meth:`__gt__` y otros)."

#: ../Doc/library/dataclasses.rst:281
msgid ""
"``metadata``: This can be a mapping or None. None is treated as an empty "
"dict.  This value is wrapped in :func:`~types.MappingProxyType` to make it "
"read-only, and exposed on the :class:`Field` object. It is not used at all "
"by Data Classes, and is provided as a third-party extension mechanism. "
"Multiple third-parties can each have their own key, to use as a namespace in "
"the metadata."
msgstr ""
"``metadata``: Puede ser un mapeo o *None*. *None* es tratado como un "
"diccionario vacío. Este valor es envuelto en :func:`~types.MappingProxyType` "
"para que sea de sólo lectura y visible en el objeto :class:`Field`. No es "
"utilizado por las clases de datos, mas bien es provisto como un mecanismo de "
"extensión de terceros. Varios terceros pueden tener su propia clave para "
"utilizar como espacio de nombres en *metadata*."

#: ../Doc/library/dataclasses.rst:289
#, fuzzy
msgid ""
"``kw_only``: If true, this field will be marked as keyword-only. This is "
"used when the generated :meth:`~object.__init__` method's parameters are "
"computed."
msgstr ""
"``kw_only``: si es verdadero, este campo se marcará como solo palabra clave. "
"Se utiliza cuando se calculan los parámetros del método :meth:`__init__` "
"generado."

#: ../Doc/library/dataclasses.rst:295
msgid ""
"If the default value of a field is specified by a call to :func:`field()`, "
"then the class attribute for this field will be replaced by the specified "
"``default`` value.  If no ``default`` is provided, then the class attribute "
"will be deleted.  The intent is that after the :func:`dataclass` decorator "
"runs, the class attributes will all contain the default values for the "
"fields, just as if the default value itself were specified.  For example, "
"after::"
msgstr ""
"Si el valor por defecto de un campo es especificado por una llamada a :func:"
"`field()`, los atributos de clase para este campo serán reemplazados por los "
"especificados en el valor ``default``. Si el valor de ``default`` no es "
"provisto, el atributo de clase será eliminado. La idea es que, después que "
"la ejecución del decorador :func:`dataclass`, todos los atributos de la "
"clase contengan los valores por defecto de cada campo, como si fueran "
"definidos uno por uno. Por ejemplo, luego de::"

#: ../Doc/library/dataclasses.rst:311
msgid ""
"The class attribute ``C.z`` will be ``10``, the class attribute ``C.t`` will "
"be ``20``, and the class attributes ``C.x`` and ``C.y`` will not be set."
msgstr ""
"El atributo de clase ``C.z`` será ``10``, el atributo de clase ``C.t`` será "
"``20`` y los atributos de clase ``C.x`` y ``C.y`` no serán definidos."

#: ../Doc/library/dataclasses.rst:317
msgid ""
":class:`Field` objects describe each defined field. These objects are "
"created internally, and are returned by the :func:`fields` module-level "
"method (see below).  Users should never instantiate a :class:`Field` object "
"directly.  Its documented attributes are:"
msgstr ""
"Los objetos :class:`Field` describen cada campo definido. Estos objetos son "
"creados internamente y son retornados por el método :func:`fields` definido "
"en este módulo (explicado más abajo). Los usuarios no deben instanciar un "
"objeto :class:`Field` directamente. Sus atributos documentados son:"

#: ../Doc/library/dataclasses.rst:322
msgid "``name``: The name of the field."
msgstr "``name``: El nombre del campo."

#: ../Doc/library/dataclasses.rst:324
msgid "``type``: The type of the field."
msgstr "``type``: El tipo del campo."

#: ../Doc/library/dataclasses.rst:326
msgid ""
"``default``, ``default_factory``, ``init``, ``repr``, ``hash``, ``compare``, "
"``metadata``, and ``kw_only`` have the identical meaning and values as they "
"do in the :func:`field` function."
msgstr ""
"``default``, ``default_factory``, ``init``, ``repr``, ``hash``, ``compare`` "
"y ``metadata`` tienen los mismos valores y significados respecto a la "
"declaración de :func:`field` (ver arriba)."

#: ../Doc/library/dataclasses.rst:330
msgid ""
"Other attributes may exist, but they are private and must not be inspected "
"or relied on."
msgstr ""
"Pueden existir otros atributos, pero son privados y no deberían ser "
"considerados ni depender de ellos."

#: ../Doc/library/dataclasses.rst:335
msgid ""
"Returns a tuple of :class:`Field` objects that define the fields for this "
"dataclass.  Accepts either a dataclass, or an instance of a dataclass. "
"Raises :exc:`TypeError` if not passed a dataclass or instance of one. Does "
"not return pseudo-fields which are ``ClassVar`` or ``InitVar``."
msgstr ""
"Retorna una tupla de objetos :class:`Field` que definen los campos para esta "
"clase de datos. Acepta tanto una clase de datos como una instancia de esta. "
"Lanza una excepción :exc:`TypeError` si se le pasa cualquier otro objeto. No "
"retorna pseudocampos, que son ``ClassVar`` o ``InitVar``."

#: ../Doc/library/dataclasses.rst:342
#, fuzzy
msgid ""
"Converts the dataclass ``obj`` to a dict (by using the factory function "
"``dict_factory``).  Each dataclass is converted to a dict of its fields, as "
"``name: value`` pairs.  dataclasses, dicts, lists, and tuples are recursed "
"into.  Other objects are copied with :func:`copy.deepcopy`."
msgstr ""
"Convierte la clase de datos ``instance`` en un diccionario (usando la "
"función fábrica ``dict_factory``). Cada clase de datos es convertida a un "
"diccionario con sus campos como parejas ``name: value``. Las clases de "
"datos, diccionarios, listas y tuplas son convertidas recursivamente. Por "
"ejemplo::"

#: ../Doc/library/dataclasses.rst:348
msgid "Example of using :func:`asdict` on nested dataclasses::"
msgstr "Ejemplo de uso de :func:`asdict` en clases de datos anidadas::"

# No estoy seguro de la traducción shallow copy como copia superficial.
#: ../Doc/library/dataclasses.rst:365 ../Doc/library/dataclasses.rst:385
#, fuzzy
msgid "To create a shallow copy, the following workaround may be used::"
msgstr ""
"Para crear una copia superficial, se puede utilizar la siguiente solución::"

#: ../Doc/library/dataclasses.rst:369
#, fuzzy
msgid ""
":func:`asdict` raises :exc:`TypeError` if ``obj`` is not a dataclass "
"instance."
msgstr ""
"Lanza una excepción :exc:`TypeError` si ``instance`` no es una instancia de "
"una clase de datos."

#: ../Doc/library/dataclasses.rst:374
#, fuzzy
msgid ""
"Converts the dataclass ``obj`` to a tuple (by using the factory function "
"``tuple_factory``).  Each dataclass is converted to a tuple of its field "
"values.  dataclasses, dicts, lists, and tuples are recursed into. Other "
"objects are copied with :func:`copy.deepcopy`."
msgstr ""
"Convierte la clase de datos ``instance`` a una tupla (usando la función "
"fábrica ``tuple_factory``). Cada clase de datos es convertida a una tupla "
"con los valores de sus campos. Las clases de datos, diccionarios, listas y "
"tuplas son convertidas recursivamente."

#: ../Doc/library/dataclasses.rst:380
msgid "Continuing from the previous example::"
msgstr "Continuando con el ejemplo anterior::"

#: ../Doc/library/dataclasses.rst:389
#, fuzzy
msgid ""
":func:`astuple` raises :exc:`TypeError` if ``obj`` is not a dataclass "
"instance."
msgstr ""
"Lanza una excepción :exc:`TypeError` si ``instance`` no es una instancia de "
"una clase de datos."

#: ../Doc/library/dataclasses.rst:394
#, fuzzy
msgid ""
"Creates a new dataclass with name ``cls_name``, fields as defined in "
"``fields``, base classes as given in ``bases``, and initialized with a "
"namespace as given in ``namespace``.  ``fields`` is an iterable whose "
"elements are each either ``name``, ``(name, type)``, or ``(name, type, "
"Field)``.  If just ``name`` is supplied, ``typing.Any`` is used for "
"``type``.  The values of ``init``, ``repr``, ``eq``, ``order``, "
"``unsafe_hash``, ``frozen``, ``match_args``, ``kw_only``, ``slots``, and "
"``weakref_slot`` have the same meaning as they do in :func:`dataclass`."
msgstr ""
"Crea una nueva clase de datos con el nombre ``cls_name``, con los campos "
"definidos en ``fields``, con las clases base dadas en ``bases`` e "
"inicializada con el espacio de nombres dado en ``namespace``. ``fields`` es "
"un iterable que cumple con una de estas formas: ``name``, ``(name, type)`` o "
"``(name, type, Field)``. Si solo ``name`` es proporcionado, ``typing.Any`` "
"es usado para ``type``. Los valores ``init``, ``repr``, ``eq``, ``order``, "
"``unsafe_hash`` y ``frozen`` tienen el mismo significado que en la función :"
"func:`dataclass`."

#: ../Doc/library/dataclasses.rst:404
msgid ""
"If ``module`` is defined, the ``__module__`` attribute of the dataclass is "
"set to that value. By default, it is set to the module name of the caller."
msgstr ""

#: ../Doc/library/dataclasses.rst:408
msgid ""
"This function is not strictly required, because any Python mechanism for "
"creating a new class with ``__annotations__`` can then apply the :func:"
"`dataclass` function to convert that class to a dataclass.  This function is "
"provided as a convenience.  For example::"
msgstr ""
"Esta función no es estrictamente necesaria debido a que cualquier mecanismo "
"de Python para crear una nueva clase con ``__annotations__`` puede usar la "
"función :func:`dataclass` para convertir esa clase en una clase de datos. "
"Esta función se proporciona simplemente por comodidad. Por ejemplo::"

#: ../Doc/library/dataclasses.rst:420
msgid "Is equivalent to::"
msgstr "Es equivalente a::"

#: ../Doc/library/dataclasses.rst:433
#, fuzzy
msgid ""
"Creates a new object of the same type as ``obj``, replacing fields with "
"values from ``changes``.  If ``obj`` is not a Data Class, raises :exc:"
"`TypeError`.  If values in ``changes`` do not specify fields, raises :exc:"
"`TypeError`."
msgstr ""
"Crea un nuevo objeto del mismo tipo que ``instance``, reemplazando los "
"campos correspondientes con los valores de ``changes``. Si ``instance`` no "
"es una clase de datos se lanza una excepción :exc:`TypeError`. Si los "
"valores en ``changes`` no especifican campos, también se lanza una "
"excepción :exc:`TypeError`."

#: ../Doc/library/dataclasses.rst:438
#, fuzzy
msgid ""
"The newly returned object is created by calling the :meth:`~object.__init__` "
"method of the dataclass.  This ensures that :meth:`__post_init__`, if "
"present, is also called."
msgstr ""
"El objeto recién retornado es creado llamando al método :meth:`__init__` de "
"la clase de datos. Esto asegura que :meth:`__post_init__`, si existe, "
"también será llamado."

#: ../Doc/library/dataclasses.rst:442
#, fuzzy
msgid ""
"Init-only variables without default values, if any exist, must be specified "
"on the call to :func:`replace` so that they can be passed to :meth:`~object."
"__init__` and :meth:`__post_init__`."
msgstr ""
"Las variables de solo inicialización sin valores predeterminados, si "
"existen, deben especificarse en la llamada a :func:`replace` para que puedan "
"pasarse a :meth:`__init__` y :meth:`__post_init__`."

#: ../Doc/library/dataclasses.rst:446
msgid ""
"It is an error for ``changes`` to contain any fields that are defined as "
"having ``init=False``.  A :exc:`ValueError` will be raised in this case."
msgstr ""
"Es un error que ``changes`` contenga cualquier campo que esté definido como "
"``init=False``. Una excepción :exc:`ValueError` se lanzará en este caso."

#: ../Doc/library/dataclasses.rst:450
msgid ""
"Be forewarned about how ``init=False`` fields work during a call to :func:"
"`replace`.  They are not copied from the source object, but rather are "
"initialized in :meth:`__post_init__`, if they're initialized at all.  It is "
"expected that ``init=False`` fields will be rarely and judiciously used.  If "
"they are used, it might be wise to have alternate class constructors, or "
"perhaps a custom ``replace()`` (or similarly named) method which handles "
"instance copying."
msgstr ""
"Tenga en cuenta cómo funcionan los campos ``init=False`` durante una llamada "
"a :func:`replace`. No se copian del objeto de origen, sino que, de "
"inicializarse, lo hacen en :meth:`__post_init__`. Se espera que los campos "
"``init=False`` se utilicen en contadas ocasiones y con prudencia. Si se "
"utilizan, podría ser conveniente tener constructores de clase alternativos, "
"o quizás un método personalizado ``replace()`` (o con un nombre similar) que "
"maneje la copia de instancias."

#: ../Doc/library/dataclasses.rst:461
msgid ""
"Return ``True`` if its parameter is a dataclass or an instance of one, "
"otherwise return ``False``."
msgstr ""
"Retorna ``True`` si su parámetro es una clase de datos o una instancia de "
"una, en caso contrario retorna ``False``."

#: ../Doc/library/dataclasses.rst:464
msgid ""
"If you need to know if a class is an instance of a dataclass (and not a "
"dataclass itself), then add a further check for ``not isinstance(obj, "
"type)``::"
msgstr ""
"Si se necesita conocer si una clase es una instancia de *dataclass* (y no "
"una clase de datos en si misma), se debe agregar una verificación adicional "
"para ``not isinstance(obj, type)``::"

#: ../Doc/library/dataclasses.rst:473
msgid "A sentinel value signifying a missing default or default_factory."
msgstr ""
"Un valor centinela que significa que falta un default o default_factory."

#: ../Doc/library/dataclasses.rst:477
#, fuzzy
msgid ""
"A sentinel value used as a type annotation.  Any fields after a pseudo-field "
"with the type of :const:`KW_ONLY` are marked as keyword-only fields.  Note "
"that a pseudo-field of type :const:`KW_ONLY` is otherwise completely "
"ignored.  This includes the name of such a field.  By convention, a name of "
"``_`` is used for a :const:`KW_ONLY` field.  Keyword-only fields signify :"
"meth:`~object.__init__` parameters that must be specified as keywords when "
"the class is instantiated."
msgstr ""
"Un valor centinela utilizado como anotación de tipo. Cualquier campo después "
"de un pseudocampo con el tipo de :const:`KW_ONLY` se marca como campos de "
"solo palabras clave. Tenga en cuenta que, de lo contrario, un pseudocampo de "
"tipo :const:`KW_ONLY` se ignora por completo. Esto incluye el nombre de "
"dicho campo. Por convención, se utiliza un nombre de ``_`` para un campo :"
"const:`KW_ONLY`. Los campos de solo palabras clave significan parámetros :"
"meth:`__init__` que deben especificarse como palabras clave cuando se crea "
"una instancia de la clase."

#: ../Doc/library/dataclasses.rst:486
msgid ""
"In this example, the fields ``y`` and ``z`` will be marked as keyword-only "
"fields::"
msgstr ""
"En este ejemplo, los campos ``y`` y ``z`` se marcarán como campos de solo "
"palabras clave:"

#: ../Doc/library/dataclasses.rst:497
msgid ""
"In a single dataclass, it is an error to specify more than one field whose "
"type is :const:`KW_ONLY`."
msgstr ""
"En una sola clase de datos, es un error especificar más de un campo cuyo "
"tipo es :const:`KW_ONLY`."

#: ../Doc/library/dataclasses.rst:504
#, fuzzy
msgid ""
"Raised when an implicitly defined :meth:`~object.__setattr__` or :meth:"
"`~object.__delattr__` is called on a dataclass which was defined with "
"``frozen=True``. It is a subclass of :exc:`AttributeError`."
msgstr ""
"Se genera cuando se llama a un :meth:`__setattr__` o :meth:`__delattr__` "
"definido implícitamente en una clase de datos que se definió con "
"``frozen=True``. Es una subclase de :exc:`AttributeError`."

#: ../Doc/library/dataclasses.rst:511
msgid "Post-init processing"
msgstr "Procesamiento posterior a la inicialización"

#: ../Doc/library/dataclasses.rst:515
#, fuzzy
msgid ""
"When defined on the class, it will be called by the generated :meth:`~object."
"__init__`, normally as ``self.__post_init__()``. However, if any ``InitVar`` "
"fields are defined, they will also be passed to :meth:`__post_init__` in the "
"order they were defined in the class.  If no :meth:`~object.__init__` method "
"is generated, then :meth:`__post_init__` will not automatically be called."
msgstr ""
"El código del método generado :meth:`__init__` llamará a un método llamado :"
"meth:`__post_init__`, si :meth:`__post_init__` está definido en la clase. "
"Normalmente se llamará como ``self.__post_init__()``. Sin embargo, si se "
"define algún campo ``InitVar``, también se pasarán a :meth:`__post_init__` "
"en el orden en que se definieron en la clase. Si no se genera el método :"
"meth:`__init__`, entonces :meth:`__post_init__` no se llamará "
"automáticamente."

#: ../Doc/library/dataclasses.rst:522
msgid ""
"Among other uses, this allows for initializing field values that depend on "
"one or more other fields.  For example::"
msgstr ""
"Entre otros usos, esto permite inicializar valores de campo que dependen de "
"uno o más campos. Por ejemplo::"

#: ../Doc/library/dataclasses.rst:534
#, fuzzy
msgid ""
"The :meth:`~object.__init__` method generated by :func:`dataclass` does not "
"call base class :meth:`~object.__init__` methods. If the base class has an :"
"meth:`~object.__init__` method that has to be called, it is common to call "
"this method in a :meth:`__post_init__` method::"
msgstr ""
"El método :meth:`__init__` generado por :func:`dataclass` no llama a los "
"métodos :meth:`__init__` de la clase base. Si la clase base tiene un método :"
"meth:`__init__` que debe llamarse, es común llamar a este método en un "
"método :meth:`__post_init__`:"

#: ../Doc/library/dataclasses.rst:551
#, fuzzy
msgid ""
"Note, however, that in general the dataclass-generated :meth:`~object."
"__init__` methods don't need to be called, since the derived dataclass will "
"take care of initializing all fields of any base class that is a dataclass "
"itself."
msgstr ""
"Sin embargo, tenga en cuenta que, en general, no es necesario llamar a los "
"métodos :meth:`__init__` generados por la clase de datos, ya que la clase de "
"datos derivada se encargará de inicializar todos los campos de cualquier "
"clase base que sea una clase de datos en sí."

#: ../Doc/library/dataclasses.rst:555
msgid ""
"See the section below on init-only variables for ways to pass parameters to :"
"meth:`__post_init__`.  Also see the warning about how :func:`replace` "
"handles ``init=False`` fields."
msgstr ""
"Consulta la sección sobre variables de solo inicialización que hay a "
"continuación para conocer las posibles formas de pasar parámetros a :meth:"
"`__post_init__`. También vea la advertencia sobre cómo :func:`replace` "
"maneja los campos ``init = False``."

#: ../Doc/library/dataclasses.rst:560
msgid "Class variables"
msgstr "Variables de clase"

#: ../Doc/library/dataclasses.rst:562
#, fuzzy
msgid ""
"One of the few places where :func:`dataclass` actually inspects the type of "
"a field is to determine if a field is a class variable as defined in :pep:"
"`526`.  It does this by checking if the type of the field is ``typing."
"ClassVar``.  If a field is a ``ClassVar``, it is excluded from consideration "
"as a field and is ignored by the dataclass mechanisms.  Such ``ClassVar`` "
"pseudo-fields are not returned by the module-level :func:`fields` function."
msgstr ""
"Uno de los dos casos donde :func:`dataclass` realmente inspecciona el tipo "
"de un campo, es para determinar si dicho campo es una variable de clase como "
"se define en :pep:`526`. Lo hace comprobando si el tipo del campo es "
"``typing.ClassVar``. Si un campo es una ``ClassVar``, se deja de considerar "
"como campo y los mecanismos de las clases de datos lo ignoran. Tales "
"pseudocampos ``ClassVar`` no son retornados por la función del módulo :func:"
"`fields`."

#: ../Doc/library/dataclasses.rst:571
msgid "Init-only variables"
msgstr "Variable de solo inicialización"

#: ../Doc/library/dataclasses.rst:573
#, fuzzy
msgid ""
"Another place where :func:`dataclass` inspects a type annotation is to "
"determine if a field is an init-only variable.  It does this by seeing if "
"the type of a field is of type ``dataclasses.InitVar``.  If a field is an "
"``InitVar``, it is considered a pseudo-field called an init-only field.  As "
"it is not a true field, it is not returned by the module-level :func:"
"`fields` function.  Init-only fields are added as parameters to the "
"generated :meth:`~object.__init__` method, and are passed to the optional :"
"meth:`__post_init__` method.  They are not otherwise used by dataclasses."
msgstr ""
"El otro caso donde :func:`dataclass` inspecciona una anotación de tipo es "
"para determinar si un campo es una variable de solo inicialización. Lo hace "
"comprobando si el tipo de un campo es ``dataclasses.InitVar``. Si un campo "
"es un ``InitVar``, se considera un pseudocampo llamado 'campo de solo "
"inicialización'. Como no es un campo verdadero, no es retornado por la "
"función del módulo :func:`fields`. Los campos de solo inicialización se "
"agregan como parámetros al método generado :meth:`__init__` y se pasan al "
"método opcional :meth:`__post_init__`. No son utilizados de otra manera por "
"las clases de datos."

#: ../Doc/library/dataclasses.rst:583
msgid ""
"For example, suppose a field will be initialized from a database, if a value "
"is not provided when creating the class::"
msgstr ""
"Por ejemplo, supongamos que se va a inicializar un campo desde una base de "
"datos, de no proporcionarse un valor al crear la clase::"

#: ../Doc/library/dataclasses.rst:598
msgid ""
"In this case, :func:`fields` will return :class:`Field` objects for ``i`` "
"and ``j``, but not for ``database``."
msgstr ""
"En este caso, :func:`fields` retornará objetos :class:`Field` para ``i`` y "
"``j``, pero no para ``database``."

#: ../Doc/library/dataclasses.rst:602
msgid "Frozen instances"
msgstr "Instancias congeladas"

#: ../Doc/library/dataclasses.rst:604
#, fuzzy
msgid ""
"It is not possible to create truly immutable Python objects.  However, by "
"passing ``frozen=True`` to the :meth:`dataclass` decorator you can emulate "
"immutability.  In that case, dataclasses will add :meth:`~object."
"__setattr__` and :meth:`~object.__delattr__` methods to the class.  These "
"methods will raise a :exc:`FrozenInstanceError` when invoked."
msgstr ""
"No es posible crear objetos verdaderamente inmutables en Python. Sin "
"embargo, se puede emular la inmutabilidad pasando ``frozen=True`` al "
"decorador :meth:`dataclass`. En este caso, las clases de datos añadirán los "
"métodos :meth:`__setattr__` y :meth:`__delattr__` a la clase. Estos métodos "
"lanzarán una excepción :exc:`FrozenInstanceError` cuando sean llamados."

#: ../Doc/library/dataclasses.rst:610
#, fuzzy
msgid ""
"There is a tiny performance penalty when using ``frozen=True``: :meth:"
"`~object.__init__` cannot use simple assignment to initialize fields, and "
"must use :meth:`!object.__setattr__`."
msgstr ""
"Hay una pequeña penalización de rendimiento cuando se usa ``frozen=True``, "
"esto se debe a que :meth:`__init__` no puede usar una asignación simple para "
"inicializar campos, viéndose obligado a usar :meth:`object.__setattr__`."

#: ../Doc/library/dataclasses.rst:615
msgid "Inheritance"
msgstr "Herencia"

#: ../Doc/library/dataclasses.rst:617
msgid ""
"When the dataclass is being created by the :meth:`dataclass` decorator, it "
"looks through all of the class's base classes in reverse MRO (that is, "
"starting at :class:`object`) and, for each dataclass that it finds, adds the "
"fields from that base class to an ordered mapping of fields. After all of "
"the base class fields are added, it adds its own fields to the ordered "
"mapping.  All of the generated methods will use this combined, calculated "
"ordered mapping of fields.  Because the fields are in insertion order, "
"derived classes override base classes.  An example::"
msgstr ""
"Cuando la clase de datos está siendo creada por el decorador :meth:"
"`dataclass`, revisa todas las clases base de la clase en el MRO invertido "
"(es decir, comenzando en :class:`object`) y, para cada clase de datos que "
"encuentra, agrega los campos de esa clase base a un mapeo ordenado. Después "
"de agregar todos los campos de la clase base, agrega sus propios campos al "
"mapeo. Todos los métodos generados utilizarán este mapeo ordenado calculado "
"combinando los campos. Como los campos están en orden de inserción, las "
"clases derivadas anulan las clases base. Un ejemplo::"

#: ../Doc/library/dataclasses.rst:637
msgid ""
"The final list of fields is, in order, ``x``, ``y``, ``z``.  The final type "
"of ``x`` is ``int``, as specified in class ``C``."
msgstr ""
"La lista final de campos es, en orden, ``x``, ``y``, ``z``. El tipo final de "
"``x`` es ``int``, como se especifica en la clase ``C``."

#: ../Doc/library/dataclasses.rst:640
#, fuzzy
msgid ""
"The generated :meth:`~object.__init__` method for ``C`` will look like::"
msgstr "El método :meth:`__init__` generado para ``C`` se verá como::"

#: ../Doc/library/dataclasses.rst:645
#, fuzzy
msgid "Re-ordering of keyword-only parameters in :meth:`~object.__init__`"
msgstr "Reordenar los parámetros de solo palabras clave en :meth:`__init__`"

#: ../Doc/library/dataclasses.rst:647
#, fuzzy
msgid ""
"After the parameters needed for :meth:`~object.__init__` are computed, any "
"keyword-only parameters are moved to come after all regular (non-keyword-"
"only) parameters.  This is a requirement of how keyword-only parameters are "
"implemented in Python: they must come after non-keyword-only parameters."
msgstr ""
"Una vez que se calculan los parámetros necesarios para :meth:`__init__`, "
"todos los parámetros de solo palabras clave se mueven después de todos los "
"parámetros normales (no solo de palabras clave). Este es un requisito de "
"cómo se implementan los parámetros de solo palabras clave en Python: deben "
"ir después de los parámetros que no son solo de palabras clave."

#: ../Doc/library/dataclasses.rst:653
msgid ""
"In this example, ``Base.y``, ``Base.w``, and ``D.t`` are keyword-only "
"fields, and ``Base.x`` and ``D.z`` are regular fields::"
msgstr ""
"En este ejemplo, ``Base.y``, ``Base.w`` y ``D.t`` son campos de solo "
"palabras clave, y ``Base.x`` y ``D.z`` son campos regulares:"

#: ../Doc/library/dataclasses.rst:668
#, fuzzy
msgid ""
"The generated :meth:`~object.__init__` method for ``D`` will look like::"
msgstr "El método :meth:`__init__` generado para ``C`` se verá como::"

#: ../Doc/library/dataclasses.rst:672
msgid ""
"Note that the parameters have been re-ordered from how they appear in the "
"list of fields: parameters derived from regular fields are followed by "
"parameters derived from keyword-only fields."
msgstr ""
"Tenga en cuenta que los parámetros se han reordenado a partir de cómo "
"aparecen en la lista de campos: los parámetros derivados de los campos "
"regulares son seguidos por los parámetros derivados de los campos de solo "
"palabras clave."

#: ../Doc/library/dataclasses.rst:676
#, fuzzy
msgid ""
"The relative ordering of keyword-only parameters is maintained in the re-"
"ordered :meth:`~object.__init__` parameter list."
msgstr ""
"El orden relativo de los parámetros de solo palabras clave se mantiene en la "
"lista de parámetros :meth:`__init__` reordenada."

#: ../Doc/library/dataclasses.rst:681
msgid "Default factory functions"
msgstr "Funciones fábrica por defecto"

#: ../Doc/library/dataclasses.rst:683
msgid ""
"If a :func:`field` specifies a ``default_factory``, it is called with zero "
"arguments when a default value for the field is needed.  For example, to "
"create a new instance of a list, use::"
msgstr ""
"Si un :func:`field` especifica una ``default_factory``, se llama sin "
"argumentos cuando se necesita un valor predeterminado para el campo. Por "
"ejemplo, para crear una nueva instancia de una lista, debe usarse::"

#: ../Doc/library/dataclasses.rst:689
#, fuzzy
msgid ""
"If a field is excluded from :meth:`~object.__init__` (using ``init=False``) "
"and the field also specifies ``default_factory``, then the default factory "
"function will always be called from the generated :meth:`~object.__init__` "
"function.  This happens because there is no other way to give the field an "
"initial value."
msgstr ""
"Si un campo está excluido de :meth:`__init__` (usando ``init = False``) y el "
"campo también especifica ``default_factory``, entonces la función de fábrica "
"predeterminada siempre se llamará desde la función generada :meth:"
"`__init__`. Esto sucede porque no existe otra forma de darle al campo un "
"valor inicial."

#: ../Doc/library/dataclasses.rst:696
msgid "Mutable default values"
msgstr "Valores por defecto mutables"

#: ../Doc/library/dataclasses.rst:698
msgid ""
"Python stores default member variable values in class attributes. Consider "
"this example, not using dataclasses::"
msgstr ""
"Python almacena los valores miembros por defecto en atributos de clase. "
"Considera este ejemplo, sin usar clases de datos::"

#: ../Doc/library/dataclasses.rst:713
msgid ""
"Note that the two instances of class ``C`` share the same class variable "
"``x``, as expected."
msgstr ""
"Tenga en cuenta que, tal como cabe esperar, las dos instancias de la clase "
"``C`` comparten la misma variable de clase ``x``."

#: ../Doc/library/dataclasses.rst:716
msgid "Using dataclasses, *if* this code was valid::"
msgstr "Usando clases de datos, *si* este código fuera válido:"

#: ../Doc/library/dataclasses.rst:724
msgid "it would generate code similar to::"
msgstr "generaría un código similar a::"

#: ../Doc/library/dataclasses.rst:735
#, fuzzy
msgid ""
"This has the same issue as the original example using class ``C``. That is, "
"two instances of class ``D`` that do not specify a value for ``x`` when "
"creating a class instance will share the same copy of ``x``.  Because "
"dataclasses just use normal Python class creation they also share this "
"behavior.  There is no general way for Data Classes to detect this "
"condition.  Instead, the :func:`dataclass` decorator will raise a :exc:"
"`ValueError` if it detects an unhashable default parameter.  The assumption "
"is that if a value is unhashable, it is mutable.  This is a partial "
"solution, but it does protect against many common errors."
msgstr ""
"Esto tiene el mismo problema que el ejemplo original usando la clase ``C``. "
"Es decir, dos instancias de la clase ``D`` que no especifican un valor para "
"``x`` al crear una instancia de clase compartirán la misma copia de ``x``. "
"Debido a que las clases de datos solo usan la creación normal de clases de "
"Python, también comparten este comportamiento. No existe una forma general "
"de que las clases de datos detecten esta condición. En cambio, el decorador :"
"func:`dataclass` lanzará un :exc:`TypeError` si detecta un parámetro "
"predeterminado de tipo ``list``, ``dict`` o ``set``. Esta es una solución "
"parcial, pero protege contra muchos errores comunes."

#: ../Doc/library/dataclasses.rst:746
msgid ""
"Using default factory functions is a way to create new instances of mutable "
"types as default values for fields::"
msgstr ""
"Usar las funciones de fábrica por defecto es una forma de crear nuevas "
"instancias de tipos mutables como valores por defecto para campos::"

# Creo que no es la mejor traducción pero no se me ocurre otra.
#: ../Doc/library/dataclasses.rst:755
#, fuzzy
msgid ""
"Instead of looking for and disallowing objects of type ``list``, ``dict``, "
"or ``set``, unhashable objects are now not allowed as default values.  "
"Unhashability is used to approximate mutability."
msgstr ""
"En lugar de buscar y desautorizar objetos de tipo ``list``, ``dict``, o "
"``set``, ahora no se permiten objetos sin un hash como valores por defecto.  "
"La Incalculabilidad se utiliza para aproximar la mutabilidad."

#: ../Doc/library/dataclasses.rst:762
msgid "Descriptor-typed fields"
msgstr "Campos tipo descriptor"

#: ../Doc/library/dataclasses.rst:764
msgid ""
"Fields that are assigned :ref:`descriptor objects <descriptors>` as their "
"default value have the following special behaviors:"
msgstr ""
"Los campos a los que se asigna :ref:`objetos descriptor <descriptors>` como "
"valor por defecto tienen los siguientes comportamientos especiales:"

#: ../Doc/library/dataclasses.rst:767
msgid ""
"The value for the field passed to the dataclass's ``__init__`` method is "
"passed to the descriptor's ``__set__`` method rather than overwriting the "
"descriptor object."
msgstr ""
"El valor del campo pasado al método ``__init__`` de la clase de datos se "
"pasa al método ``__set__`` del descriptor en lugar de sobrescribir el objeto "
"descriptor."

#: ../Doc/library/dataclasses.rst:770
msgid ""
"Similarly, when getting or setting the field, the descriptor's ``__get__`` "
"or ``__set__`` method is called rather than returning or overwriting the "
"descriptor object."
msgstr ""
"Del mismo modo, al obtener o establecer el campo, se llama al método "
"``__get__`` o ``__set__`` del descriptor en lugar de retornar o sobrescribir "
"el objeto descriptor."

#: ../Doc/library/dataclasses.rst:773
msgid ""
"To determine whether a field contains a default value, ``dataclasses`` will "
"call the descriptor's ``__get__`` method using its class access form (i.e. "
"``descriptor.__get__(obj=None, type=cls)``.  If the descriptor returns a "
"value in this case, it will be used as the field's default. On the other "
"hand, if the descriptor raises :exc:`AttributeError` in this situation, no "
"default value will be provided for the field."
msgstr ""
"Para determinar si un campo contiene un valor por defecto, ``dataclasses`` "
"llamará al método ``__get__`` del descriptor utilizando su forma de acceso a "
"la clase (es decir, ``descriptor.__get__(obj=None, type=cls)``.  Si el "
"descriptor devuelve un valor en este caso, se utilizará como valor por "
"defecto del campo. Por otro lado, si el descriptor devuelve :exc:"
"`AttributeError` en esta situación, no se proporcionará ningún valor por "
"defecto para el campo."

#: ../Doc/library/dataclasses.rst:808
msgid ""
"Note that if a field is annotated with a descriptor type, but is not "
"assigned a descriptor object as its default value, the field will act like a "
"normal field."
msgstr ""
"Tenga en cuenta que si un campo está anotado con un tipo de descriptor, pero "
"no se le asigna un objeto descriptor como valor por defecto, el campo "
"actuará como un campo normal."
