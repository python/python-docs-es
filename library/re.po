# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/PyCampES/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-05 12:54+0200\n"
"PO-Revision-Date: 2020-05-23 23:33+0200\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: Miguel Hernandez <jose.miguel.heca@gmail.com>\n"
"Language: es\n"
"X-Generator: Poedit 2.3.1\n"

#: ../Doc/library/re.rst:2
msgid ":mod:`re` --- Regular expression operations"
msgstr ":mod:`re` --- Operaciones con expresiones regulares"

#: ../Doc/library/re.rst:10
msgid "**Source code:** :source:`Lib/re.py`"
msgstr "**Código fuente:** :source:`Lib/re.py`"

#: ../Doc/library/re.rst:14
msgid ""
"This module provides regular expression matching operations similar to those "
"found in Perl."
msgstr ""
"Este módulo proporciona operaciones de coincidencia de expresiones regulares "
"similares a las encontradas en Perl."

#: ../Doc/library/re.rst:17
msgid ""
"Both patterns and strings to be searched can be Unicode strings (:class:"
"`str`) as well as 8-bit strings (:class:`bytes`). However, Unicode strings "
"and 8-bit strings cannot be mixed: that is, you cannot match a Unicode "
"string with a byte pattern or vice-versa; similarly, when asking for a "
"substitution, the replacement string must be of the same type as both the "
"pattern and the search string."
msgstr ""
"Tanto los patrones como las cadenas de texto a buscar pueden ser cadenas de "
"Unicode (:class:`str`) así como cadenas de 8 bits (:class:`bytes`). Sin "
"embargo, las cadenas Unicode y las cadenas de 8 bits no se pueden mezclar: "
"es decir, no se puede hacer coincidir una cadena Unicode con un patrón de "
"bytes o viceversa; del mismo modo, al pedir una sustitución, la cadena de "
"sustitución debe ser del mismo tipo que el patrón y la cadena de búsqueda."

#: ../Doc/library/re.rst:24
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal. Also, "
"please note that any invalid escape sequences in Python's usage of the "
"backslash in string literals now generate a :exc:`DeprecationWarning` and in "
"the future this will become a :exc:`SyntaxError`. This behaviour will happen "
"even if it is a valid escape sequence for a regular expression."
msgstr ""
"Las expresiones regulares usan el carácter de barra invertida (``'\\'``) "
"para indicar formas especiales o para permitir el uso de caracteres "
"especiales sin invocar su significado especial.  Esto choca con el uso de "
"Python de este carácter para el mismo propósito con los literales de cadena; "
"por ejemplo, para hacer coincidir una barra invertida literal, se podría "
"escribir ``'\\\\\\\\'`` como patrón, porque la expresión regular debe ser ``"
"\\\\``, y cada barra invertida debe ser expresada como ``\\\\`` dentro de un "
"literal de cadena regular de Python.  También, notar que cualquier secuencia "
"de escape inválida mientras se use la barra invertida de Python en los "
"literales de cadena ahora genera un :exc:`DeprecationWarning` y en el futuro "
"esto se convertirá en un :exc:`SyntaxError`.  Este comportamiento ocurrirá "
"incluso si es una secuencia de escape válida para una expresión regular."

#: ../Doc/library/re.rst:36
msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal "
"prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string containing "
"``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string containing "
"a newline.  Usually patterns will be expressed in Python code using this raw "
"string notation."
msgstr ""
"La solución es usar la notación de cadena *raw* de Python para los patrones "
"de expresiones regulares; las barras invertidas no se manejan de ninguna "
"manera especial en un literal de cadena prefijado con ``'r'``.  Así que ``r"
"\"\\n\"`` es una cadena de dos caracteres que contiene ``'\\'`` y ``'n'``, "
"mientras que ``\"\\n\"`` es una cadena de un carácter que contiene una nueva "
"línea.  Normalmente los patrones se expresan en código Python usando esta "
"notación de cadena *raw*."

#: ../Doc/library/re.rst:43
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular "
"expressions <re-objects>`.  The functions are shortcuts that don't require "
"you to compile a regex object first, but miss some fine-tuning parameters."
msgstr ""
"Es importante señalar que la mayoría de las operaciones de expresiones "
"regulares están disponibles como funciones y métodos a nivel de módulo en :"
"ref:`compiled regular expressions <re-objects>` (expresiones regulares "
"compiladas).  Las funciones son atajos que no requieren de compilar un "
"objeto regex primero, aunque pasan por alto algunos parámetros de ajuste."

#: ../Doc/library/re.rst:51
msgid ""
"The third-party `regex <https://pypi.org/project/regex/>`_ module, which has "
"an API compatible with the standard library :mod:`re` module, but offers "
"additional functionality and a more thorough Unicode support."
msgstr ""
"El módulo de terceros `regex <https://pypi.org/project/regex/>`_ , cuenta "
"con una API compatible con el módulo de la biblioteca estándar :mod:`re`, el "
"cual ofrece una funcionalidad adicional y un soporte Unicode más completo."

#: ../Doc/library/re.rst:59
msgid "Regular Expression Syntax"
msgstr "Sintaxis de expresiones regulares"

#: ../Doc/library/re.rst:61
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the "
"functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""
"Una expresión regular (o RE, por sus siglas en inglés) especifica un "
"conjunto de cadenas que coinciden con ella; las funciones de este módulo "
"permiten comprobar si una determinada cadena coincide con una expresión "
"regular dada (o si una expresión regular dada coincide con una determinada "
"cadena, que se reduce a lo mismo)."

#: ../Doc/library/re.rst:66
msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described "
"here.  For details of the theory and implementation of regular expressions, "
"consult the Friedl book [Frie09]_, or almost any textbook about compiler "
"construction."
msgstr ""
"Las expresiones regulares pueden ser concatenadas para formar nuevas "
"expresiones regulares; si *A* y *B* son ambas expresiones regulares, "
"entonces *AB* es también una expresión regular. En general, si una cadena "
"*p* coincide con *A* y otra cadena *q* coincide con *B*, la cadena *porque* "
"coincidirá con AB.  Esto se mantiene a menos que *A* o *B* contengan "
"operaciones de baja precedencia; condiciones límite entre *A* y *B*; o "
"tengan referencias de grupo numeradas.  Así, las expresiones complejas "
"pueden construirse fácilmente a partir de expresiones primitivas más simples "
"como las que se describen aquí.  Para detalles de la teoría e implementación "
"de las expresiones regulares, consulte el libro de Friedl [Frie09]_, o casi "
"cualquier libro de texto sobre la construcción de compiladores."

#: ../Doc/library/re.rst:76
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr ""
"A continuación se explica brevemente el formato de las expresiones "
"regulares.  Para más información y una presentación más amena, consultar la :"
"ref:`regex-howto`."

#: ../Doc/library/re.rst:79
msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""
"Las expresiones regulares pueden contener tanto caracteres especiales como "
"ordinarios. La mayoría de los caracteres ordinarios, como ``'A'``, ``'a'``, "
"o ``'0'`` son las expresiones regulares más sencillas; simplemente se "
"ajustan a sí mismas.  Se pueden concatenar caracteres ordinarios, así que "
"``last`` coincide con la cadena ``'last'``.  (En el resto de esta sección, "
"se escribirán los RE en ``este estilo especial``, normalmente sin comillas, "
"y las cadenas que deban coincidir ``'entre comillas simples'``.)"

#: ../Doc/library/re.rst:86
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted."
msgstr ""
"Algunos caracteres, como ``'|'`` o ``'('``, son especiales. Los caracteres "
"especiales representan clases de caracteres ordinarios, o afectan a la forma "
"en que se interpretan las expresiones regulares que los rodean."

#: ../Doc/library/re.rst:90
msgid ""
"Repetition qualifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) cannot be "
"directly nested. This avoids ambiguity with the non-greedy modifier suffix "
"``?``, and with other modifiers in other implementations. To apply a second "
"repetition to an inner repetition, parentheses may be used. For example, the "
"expression ``(?:a{6})*`` matches any multiple of six ``'a'`` characters."
msgstr ""
"Los delimitadores de repetición (``*``, ``+``, ``?``, ``{m,n}``, etc.) no "
"pueden ser anidados directamente. Esto evita la ambigüedad con el sufijo "
"modificador no *greedy* (codiciosos) ``?``, y con otros modificadores en "
"otras implementaciones. Para aplicar una segunda repetición a una repetición "
"interna, se pueden usar paréntesis. Por ejemplo, la expresión ``(?:a{6})*`` "
"coincide con cualquier múltiplo de seis caracteres ``'a'``."

#: ../Doc/library/re.rst:97
msgid "The special characters are:"
msgstr "Los caracteres especiales son:"

#: ../Doc/library/re.rst:104 ../Doc/library/re.rst:1409
msgid "``.``"
msgstr "``.``"

#: ../Doc/library/re.rst:102
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline."
msgstr ""
"(Punto.) En el modo predeterminado, esto coincide con cualquier carácter "
"excepto con una nueva línea.  Si se ha especificado el indicador :const:"
"`DOTALL`, esto coincide con cualquier carácter que incluya una nueva línea."

#: ../Doc/library/re.rst:110
msgid "``^``"
msgstr "``^``"

#: ../Doc/library/re.rst:109
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr ""
"(Circunflejo.)  Coincide con el comienzo de la cadena, y en modo :const:"
"`MULTILINE` también coincide inmediatamente después de cada nueva línea."

#: ../Doc/library/re.rst:121
msgid "``$``"
msgstr "``$``"

#: ../Doc/library/re.rst:115
msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression ``foo"
"$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in "
"``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in :const:"
"`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will find two "
"(empty) matches: one just before the newline, and one at the end of the "
"string."
msgstr ""
"Coincide con el final de la cadena o justo antes de la nueva línea al final "
"de la cadena, y en modo :const:`MULTILINE` también coincide antes de una "
"nueva línea.  ``foo`` coincide con 'foo' y 'foobar', mientras que la "
"expresión regular ``foo$`` sólo coincide con 'foo'.  Más interesante aún, al "
"buscar ``foo.$`` en ``'foo1\\nfoo2\\n'`` coincide con 'foo2' normalmente, "
"pero solo 'foo1' en :const:`MULTILINE``; si busca un solo ``$`` en ``'foo"
"\\n'`` encontrará dos coincidencias (vacías): una justo antes de una nueva "
"línea, y otra al final de la cadena."

#: ../Doc/library/re.rst:128
msgid "``*``"
msgstr "``*``"

#: ../Doc/library/re.rst:126
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""
"Hace que el RE resultante coincida con 0 o más repeticiones del RE "
"precedente, tantas repeticiones como sean posibles.  ``ab*`` coincidirá con "
"'a', 'ab' o 'a' seguido de cualquier número de 'b'."

#: ../Doc/library/re.rst:135
msgid "``+``"
msgstr "``+``"

#: ../Doc/library/re.rst:133
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr ""
"Hace que la RE resultante coincida con 1 o más repeticiones de la RE "
"precedente. ``ab+`` coincidirá con 'a' seguido de cualquier número distinto "
"de cero de 'b'; no coincidirá solo con 'a'."

#: ../Doc/library/re.rst:141
msgid "``?``"
msgstr "``?``"

#: ../Doc/library/re.rst:140
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr ""
"Hace que la RE resultante coincida con 0 o 1 repeticiones de la RE "
"precedente. ``ab?`` coincidirá con 'a' o 'ab'."

#: ../Doc/library/re.rst:155
msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

#: ../Doc/library/re.rst:149
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` qualifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``'<a> b <c>'``, it will match the entire "
"string, and not just ``'<a>'``.  Adding ``?`` after the qualifier makes it "
"perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``'<a>'``."
msgstr ""
"Los delimitadores \"*\", \"+\" y \"*\" son todos :dfn:`greedy` (codiciosos); "
"coinciden con la mayor cantidad de texto posible.  A veces este "
"comportamiento no es deseado; si el RE ``<.*>`` se utiliza para coincidir "
"con ``'<a> b <c>'``, coincidirá con toda la cadena, y no sólo con "
"``'<a>'``.  Añadiendo ``?`` después del delimitador hace que se realice la "
"coincidencia de manera :dfn:`non-greedy` o :dfn:`minimal`; coincidirá la "
"*mínima* cantidad de caracteres como sea posible.  Usando el RE ``<.*?>`` "
"sólo coincidirá con ``'<a>'``."

#: ../Doc/library/re.rst:163
msgid "``{m}``"
msgstr "``{m}``"

#: ../Doc/library/re.rst:161
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""
"Especifica que exactamente *m* copias de la RE anterior deben coincidir; "
"menos coincidencias hacen que la RE entera no coincida.  Por ejemplo, ``a{6}"
"`` coincidirá exactamente con seis caracteres ``'a'``, pero no con cinco."

#: ../Doc/library/re.rst:172
msgid "``{m,n}``"
msgstr "``{m,n}``"

#: ../Doc/library/re.rst:166
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m* "
"specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``'aaaab'`` or a thousand "
"``'a'`` characters followed by a ``'b'``, but not ``'aaab'``. The comma may "
"not be omitted or the modifier would be confused with the previously "
"described form."
msgstr ""
"Hace que el RE resultante coincida de *m* a *n* repeticiones del RE "
"precedente, tratando de coincidir con el mayor número de repeticiones "
"posible.  Por ejemplo, ``a{3,5}`` coincidirá de 3 a 5 caracteres ``'a'``.  "
"Omitiendo *m* se especifica un límite inferior de cero, y omitiendo *n* se "
"especifica un límite superior infinito.  Por ejemplo, ``a{4,}b`` coincidirá "
"con ``'aaaab'`` o mil caracteres ``'a'`` seguidos de una ``'b'``, pero no "
"``'aaab'``. La coma no puede ser omitida o el modificador se confundiría con "
"la forma descrita anteriormente."

#: ../Doc/library/re.rst:179
msgid "``{m,n}?``"
msgstr "``{m,n}?``"

#: ../Doc/library/re.rst:175
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is "
"the non-greedy version of the previous qualifier.  For example, on the 6-"
"character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters, "
"while ``a{3,5}?`` will only match 3 characters."
msgstr ""
"Hace que el RE resultante coincida de *m* a *n* repeticiones del RE "
"precedente, tratando de coincidir con el *mínimo de* repeticiones posible.  "
"Esta es la versión *non-greedy* (no codiciosa) del delimitador anterior.  "
"Por ejemplo, en la cadena de 6 caracteres ``'aaaaaaa'``, ``a{3,5}`` "
"coincidirá con 5 caracteres ``'a'``, mientras que ``a{3,5}?`` solo "
"coincidirá con 3 caracteres."

#: ../Doc/library/re.rst:194
msgid "``\\``"
msgstr "``\\``"

#: ../Doc/library/re.rst:184
#, fuzzy
msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr ""
"O bien se escapan a los caracteres especiales (lo que le permite hacer "
"coincidir caracteres como ``'*'``, ``'?'``, y así sucesivamente), o se "
"señala una secuencia especial; las secuencias especiales se explican más "
"adelante."

#: ../Doc/library/re.rst:188
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""
"Si no se utiliza una cadena raw para expresar el patrón, recuerde que Python "
"también utiliza la barra inversa como secuencia de escape en los literales "
"de la cadena; si el analizador sintáctico de Python no reconoce la secuencia "
"de escape, la barra inversa y el carácter subsiguiente se incluyen en la "
"cadena resultante.  Sin embargo, si Python quisiera reconocer la secuencia "
"resultante, la barra invertida debería repetirse dos veces.  Esto es "
"complicado y difícil de entender, por lo que se recomienda encarecidamente "
"utilizar cadenas raw para todas las expresiones salvo las más simples."

#: ../Doc/library/re.rst:254
msgid "``[]``"
msgstr "``[]``"

#: ../Doc/library/re.rst:200
msgid "Used to indicate a set of characters.  In a set:"
msgstr "Se utiliza para indicar un conjunto de caracteres.  En un conjunto:"

#: ../Doc/library/re.rst:202
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr ""
"Los caracteres pueden ser listados individualmente, ej. ``[amk]`` coincidirá "
"con ``'a'``, ``'m'``, o ``'k'``."

#: ../Doc/library/re.rst:207
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase "
"ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[-a]`` or ``[a-]``), it will match a literal ``'-'``."
msgstr ""
"Los rangos de caracteres se pueden indicar mediante dos caracteres y "
"separándolos con un ``'-'``. Por ejemplo, ``[a-z]`` coincidirá con cualquier "
"letra ASCII en minúscula, ``[0-5][0-9]`` coincidirá con todos los números de "
"dos dígitos desde el ``00`` hasta el ``59``, y ``[0-9A-Fa-f]`` coincidirá "
"con cualquier dígito hexadecimal.  Si se escapa ``-`` (por ejemplo, ``[a\\-"
"z]``) o si se coloca como el primer o el último carácter (por ejemplo, ``[-"
"a]`` o ``[a-]``), coincidirá con un literal ``'-'``."

#: ../Doc/library/re.rst:214
msgid ""
"Special characters lose their special meaning inside sets.  For example, "
"``[(+*)]`` will match any of the literal characters ``'('``, ``'+'``, "
"``'*'``, or ``')'``."
msgstr ""
"Los caracteres especiales pierden su significado especial dentro de los "
"sets.  Por ejemplo, ``[(+*)]`` coincidirá con cualquiera de los caracteres "
"literales ``'('``, ``'+'``, ``'*'``, o ``')'``."

#: ../Doc/library/re.rst:220
msgid ""
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"accepted inside a set, although the characters they match depends on "
"whether :const:`ASCII` or :const:`LOCALE` mode is in force."
msgstr ""
"Las clases de caracteres como ``\\w`` o ``\\S`` (definidas más adelante) "
"también se aceptan dentro de un conjunto, aunque los caracteres que "
"coinciden dependen de si el modo :const:`ASCII` o :const:`LOCALE` está "
"activo."

#: ../Doc/library/re.rst:226
msgid ""
"Characters that are not within a range can be matched by :dfn:"
"`complementing` the set.  If the first character of the set is ``'^'``, all "
"the characters that are *not* in the set will be matched.  For example, "
"``[^5]`` will match any character except ``'5'``, and ``[^^]`` will match "
"any character except ``'^'``.  ``^`` has no special meaning if it's not the "
"first character in the set."
msgstr ""
"Los caracteres que no están dentro de un rango pueden ser coincidentes con :"
"dfn:`complementing` el conjunto. Si el primer carácter del conjunto es "
"``'^'``, todos los caracteres que *no* están en el conjunto coincidirán. Por "
"ejemplo, ``[^5]`` coincidirá con cualquier carácter excepto con ``'5'``, y "
"``[^^]`` coincidirá con cualquier carácter excepto con ``'^'``. ``^`` no "
"tiene un significado especial si no es el primer carácter del conjunto."

#: ../Doc/library/re.rst:233
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will both match a parenthesis."
msgstr ""
"Para coincidir con un ``']'`` literal dentro de un set, se debe preceder con "
"una barra inversa, o colocarlo al principio del set. Por ejemplo, tanto ``[()"
"[\\][{}]`` como ``[]()[{}]`` coincidirá con los paréntesis, corchetes y "
"llaves."

#: ../Doc/library/re.rst:242
msgid ""
"Support of nested sets and set operations as in `Unicode Technical Standard "
"#18`_ might be added in the future.  This would change the syntax, so to "
"facilitate this change a :exc:`FutureWarning` will be raised in ambiguous "
"cases for the time being. That includes sets starting with a literal ``'['`` "
"or containing literal character sequences ``'--'``, ``'&&'``, ``'~~'``, and "
"``'||'``.  To avoid a warning escape them with a backslash."
msgstr ""
"El soporte de conjuntos anidados y operaciones de conjuntos como en `Unicode "
"Technical Standard #18`_ podría ser añadido en el futuro. Esto cambiaría la "
"sintaxis, así que por el momento se planteará un :exc:`FutureWarning` en "
"casos ambiguos para facilitar este cambio. Ello incluye conjuntos que "
"empiecen con un literal ``'['`` o que contengan secuencias de caracteres "
"literales ``'—'``, ``'&&'``, ``'~~'`` y ``'||'``. Para evitar una "
"advertencia, utilizar el código de escape con una barra inversa."

#: ../Doc/library/re.rst:252
msgid ""
":exc:`FutureWarning` is raised if a character set contains constructs that "
"will change semantically in the future."
msgstr ""
":exc:`FutureWarning` se genera si un conjunto de caracteres contiene "
"construcciones que cambiarán semánticamente en el futuro."

#: ../Doc/library/re.rst:267
msgid "``|``"
msgstr "``|``"

#: ../Doc/library/re.rst:259
msgid ""
"``A|B``, where *A* and *B* can be arbitrary REs, creates a regular "
"expression that will match either *A* or *B*.  An arbitrary number of REs "
"can be separated by the ``'|'`` in this way.  This can be used inside groups "
"(see below) as well.  As the target string is scanned, REs separated by "
"``'|'`` are tried from left to right. When one pattern completely matches, "
"that branch is accepted. This means that once *A* matches, *B* will not be "
"tested further, even if it would produce a longer overall match.  In other "
"words, the ``'|'`` operator is never greedy.  To match a literal ``'|'``, "
"use ``\\|``, or enclose it inside a character class, as in ``[|]``."
msgstr ""
"``A|B``, donde *A* y *B* pueden ser RE arbitrarias, crea una expresión "
"regular que coincidirá con *A* or *B*. Un número arbitrario de RE puede ser "
"separado por ``'|'`` de esta manera. Esto puede también ser usado dentro de "
"grupos (ver más adelante). Cuando la cadena de destino es procesada, los RE "
"separados por ``'|'`` son probados de izquierda a derecha. Cuando un patrón "
"coincide completamente, esa rama es aceptada. Esto significa que una vez que "
"*A* coincida, *B* no se comprobará más, incluso si se produce una "
"coincidencia general más larga. En otras palabras, el operador de ``'|'`` "
"nunca es codicioso. Para emparejar un literal ``'|'``, se usa ``\\|``, o se "
"envuelve dentro de una clase de caracteres, como en ``[|]``."

#: ../Doc/library/re.rst:277
msgid "``(...)``"
msgstr "``(...)``"

#: ../Doc/library/re.rst:273
msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates "
"the start and end of a group; the contents of a group can be retrieved after "
"a match has been performed, and can be matched later in the string with the "
"``\\number`` special sequence, described below.  To match the literals "
"``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside a "
"character class: ``[(]``, ``[)]``."
msgstr ""
"Coincide con cualquier expresión regular que esté dentro de los paréntesis, "
"e indica el comienzo y el final de un grupo; el contenido de un grupo puede "
"ser recuperado después de que se haya realizado una coincidencia, y puede "
"coincidir más adelante en la cadena con la secuencia especial ``\\number``, "
"que se describe más adelante. Para hacer coincidir los literales ```'('`` o "
"``')'``, se usa ``\\(`` o ``\\)``, o se envuelve dentro de una clase de "
"caracteres: ``[(]``, ``[)]``."

#: ../Doc/library/re.rst:286
msgid "``(?...)``"
msgstr "``(?...)``"

#: ../Doc/library/re.rst:282
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""
"Esta es una notación de extensión (un ``'?'`` después de un ``'('`` no tiene "
"ningún otro significado). El primer carácter después de ``'?'`` determina el "
"significado y la sintaxis de la construcción. Las extensiones normalmente no "
"crean un nuevo grupo; ``(?P<name>…)`` es la única excepción a esta regla. A "
"continuación se muestran las extensiones actualmente soportadas."

#: ../Doc/library/re.rst:300
msgid "``(?aiLmsux)``"
msgstr "``(?aiLmsux)``"

#: ../Doc/library/re.rst:289
msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.)  The group matches the empty string; the letters "
"set the corresponding flags: :const:`re.A` (ASCII-only matching), :const:`re."
"I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M` (multi-"
"line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode matching), "
"and :const:`re.X` (verbose), for the entire regular expression. (The flags "
"are described in :ref:`contents-of-module-re`.) This is useful if you wish "
"to include the flags as part of the regular expression, instead of passing a "
"*flag* argument to the :func:`re.compile` function.  Flags should be used "
"first in the expression string."
msgstr ""
"(Una o más letras del conjunto ``'a'``, ``'i'``, ``'L'``, ``'m'``, ``'s'``, "
"``'u'``, ``'x'``.) El grupo coincide con la cadena vacía; las letras ponen "
"los indicadores correspondientes: :const:`re.A` (coincidencia sólo en "
"ASCII), :const:`re.I` (ignorar mayúsculas o minúsculas), :const:`re. L` "
"(dependiente de la localización), :const:`re.M` (multilínea), :const:`re.S` "
"(el punto coincide con todo), :const:`re.U` (coincidencia con Unicode), y :"
"const:`re.X` (modo *verbose*), para toda la expresión regular. (Los "
"indicadores se describen en :ref:`contents-of-module-re`.) Esto es útil si "
"se desea incluir los indicadores como parte de la expresión regular, en "
"lugar de pasar un argumento *flag* (indicador) a la función :func:`re."
"compile`. Los indicadores deben ser usados primero en la cadena de expresión."

#: ../Doc/library/re.rst:308
msgid "``(?:...)``"
msgstr "``(?:...)``"

#: ../Doc/library/re.rst:305
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group "
"*cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr ""
"Una versión no capturable de los paréntesis regulares. Hace coincidir "
"cualquier expresión regular que esté dentro de los paréntesis, pero la "
"subcadena coincidente con el grupo *no puede* ser recuperada después de "
"realizar una coincidencia o referenciada más adelante en el patrón."

#: ../Doc/library/re.rst:334
msgid "``(?aiLmsux-imsx:...)``"
msgstr "``(?aiLmsux-imsx:...)``"

#: ../Doc/library/re.rst:311
msgid ""
"(Zero or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``, optionally followed by ``'-'`` followed by one or "
"more letters from the ``'i'``, ``'m'``, ``'s'``, ``'x'``.) The letters set "
"or remove the corresponding flags: :const:`re.A` (ASCII-only matching), :"
"const:`re.I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M` "
"(multi-line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode "
"matching), and :const:`re.X` (verbose), for the part of the expression. (The "
"flags are described in :ref:`contents-of-module-re`.)"
msgstr ""
"(Cero o más letras del conjunto ``'a'``, ``'i'``, ``'L'``, ``'m'``, ``'s'``, "
"``'u'``, ``'x'``, opcionalmente seguido de ``'-'`` seguido de una o más "
"letras de ``'i'``, ``'m'``, ``'s'``, ``'x'``.) Las letras ponen o quitan los "
"indicadores correspondientes: :const:`re.A` (coincidencia sólo en ASCII), :"
"const:`re.I` (ignorar mayúsculas o minúsculas), :const:`re. L` (dependiente "
"de la localización), :const:`re.M` (multilínea), :const:`re.S` (el punto "
"coincide con todo), :const:`re.U` (coincidencia con Unicode), y :const:`re."
"X` (modo *verbose*) para la parte de la expresión. (Los indicadores se "
"describen en :ref:`contents-of-module-re`.)"

#: ../Doc/library/re.rst:321
msgid ""
"The letters ``'a'``, ``'L'`` and ``'u'`` are mutually exclusive when used as "
"inline flags, so they can't be combined or follow ``'-'``.  Instead, when "
"one of them appears in an inline group, it overrides the matching mode in "
"the enclosing group.  In Unicode patterns ``(?a:...)`` switches to ASCII-"
"only matching, and ``(?u:...)`` switches to Unicode matching (default).  In "
"byte pattern ``(?L:...)`` switches to locale depending matching, and ``(?"
"a:...)`` switches to ASCII-only matching (default). This override is only in "
"effect for the narrow inline group, and the original matching mode is "
"restored outside of the group."
msgstr ""
"Las letras ``'a'``, ``'L'`` y ``'u'`` se excluyen mutuamente cuando se usan "
"como indicadores en línea, así que no pueden combinarse o ser seguidos por "
"``'-'``. En cambio, cuando uno de ellos aparece en un grupo dentro de la "
"línea, anula el modo de coincidencia en el grupo que lo rodea. En los "
"patrones Unicode, ``(?a:…)`` cambia al modo de concordancia sólo en ASCII, y "
"``(?u:…)`` cambia al modo de concordancia Unicode (por defecto). En el "
"patrón de bytes ``(?L:…)`` se cambia a una correspondencia en función de la "
"localidad, y ``(?a:…)`` se cambia a una correspondencia sólo en ASCII "
"(predeterminado). Esta anulación sólo tiene efecto para el grupo de línea "
"restringida, y el modo de coincidencia original se restaura fuera del grupo."

#: ../Doc/library/re.rst:333
msgid "The letters ``'a'``, ``'L'`` and ``'u'`` also can be used in a group."
msgstr ""
"Las letras ``'a'``, ``'L'`` y ``'u'`` también pueden ser usadas en un grupo."

#: ../Doc/library/re.rst:361
msgid "``(?P<name>...)``"
msgstr "``(?P<name>...)``"

#: ../Doc/library/re.rst:339
msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and each group name must be defined only once within a "
"regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr ""
"Similar a los paréntesis regulares, pero la subcadena coincidente con el "
"grupo es accesible a través del nombre simbólico del grupo *name* "
"(nombrado). Los nombres de grupo deben ser identificadores válidos de "
"Python, y cada nombre de grupo debe ser definido sólo una vez dentro de una "
"expresión regular.  Un grupo simbólico es también un grupo numerado, del "
"mismo modo que si el grupo no tuviera nombre."

#: ../Doc/library/re.rst:345
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is ``(?"
"P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either "
"single or double quotes):"
msgstr ""
"Los grupos nombrados pueden ser referenciados en tres contextos. Si el "
"patrón es ``(?P<quote>['\"]).*?(?P=quote)`` (es decir, hacer coincidir una "
"cadena citada con comillas simples o dobles):"

#: ../Doc/library/re.rst:350
msgid "Context of reference to group \"quote\""
msgstr "Contexto de la referencia al grupo \"quote\" (cita)"

#: ../Doc/library/re.rst:350
msgid "Ways to reference it"
msgstr "Formas de hacer referencia"

#: ../Doc/library/re.rst:352
msgid "in the same pattern itself"
msgstr "en el mismo patrón en sí mismo"

#: ../Doc/library/re.rst:352
msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=quote)`` (como se muestra)"

#: ../Doc/library/re.rst:353 ../Doc/library/re.rst:360
msgid "``\\1``"
msgstr "``\\1``"

#: ../Doc/library/re.rst:355
msgid "when processing match object *m*"
msgstr "cuando se procesa el objeto de la coincidencia *m*"

#: ../Doc/library/re.rst:355
msgid "``m.group('quote')``"
msgstr "``m.group('quote')``"

#: ../Doc/library/re.rst:356
msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('quote')`` (etc.)"

#: ../Doc/library/re.rst:358
msgid "in a string passed to the *repl* argument of ``re.sub()``"
msgstr "en una cadena pasada al argumento *repl* de ``re.sub()``"

#: ../Doc/library/re.rst:358
msgid "``\\g<quote>``"
msgstr "``\\g<quote>``"

#: ../Doc/library/re.rst:359
msgid "``\\g<1>``"
msgstr "``\\g<1>``"

#: ../Doc/library/re.rst:367
msgid "``(?P=name)``"
msgstr "``(?P=name)``"

#: ../Doc/library/re.rst:366
msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr ""
"Una referencia inversa a un grupo nombrado; coincide con cualquier texto "
"correspondido por el grupo anterior llamado *name*."

#: ../Doc/library/re.rst:372
msgid "``(?#...)``"
msgstr "``(?#...)``"

#: ../Doc/library/re.rst:372
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "Un comentario; el contenido de los paréntesis es simplemente ignorado."

#: ../Doc/library/re.rst:379
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../Doc/library/re.rst:377
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a :dfn:`lookahead assertion`.  For example, ``Isaac (?"
"=Asimov)`` will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""
"Coincide si ``…`` coincide con el siguiente patrón, pero no procesa nada de "
"la cadena. Esto se llama una :dfn:`lookahead assertion` (aserción de "
"búsqueda anticipada). Por ejemplo, ``Isaac (?=Asimov)`` coincidirá con "
"``'Isaac '`` sólo si va seguido de ``'Asimov'``."

#: ../Doc/library/re.rst:386
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../Doc/library/re.rst:384
msgid ""
"Matches if ``...`` doesn't match next.  This is a :dfn:`negative lookahead "
"assertion`. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only "
"if it's *not* followed by ``'Asimov'``."
msgstr ""
"Coincide si ``…`` no coincide con el siguiente. Esta es una :dfn:`negative "
"lookahead assertion` (aserción negativa de búsqueda anticipada). Por "
"ejemplo, ``Isaac (?!Asimov)`` coincidirá con ``'Isaac '`` sólo si *no* es "
"seguido por ``'Asimov'``."

#: ../Doc/library/re.rst:413
msgid "``(?<=...)``"
msgstr "``(?<=...)``"

#: ../Doc/library/re.rst:391
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``'abcdef'``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed "
"length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and ``a{3,4}"
"`` are not.  Note that patterns which start with positive lookbehind "
"assertions will not match at the beginning of the string being searched; you "
"will most likely want to use the :func:`search` function rather than the :"
"func:`match` function:"
msgstr ""
"Coincide si la posición actual en la cadena es precedida por una "
"coincidencia para ``…`` que termina en la posición actual.  Esto se llama "
"una :dfn:`positive lookbehind assertion` (aserciones positivas de búsqueda "
"tardía). ``(?<=abc)def`` encontrará una coincidencia en ``'abcdef'``, ya que "
"la búsqueda tardía hará una copia de seguridad de 3 caracteres y comprobará "
"si el patrón contenido coincide. El patrón contenido sólo debe coincidir con "
"cadenas de alguna longitud fija, lo que significa que ``abc`` o ``a|b`` "
"están permitidas, pero ``a*`` y ``a{3,4}`` no lo están.  Hay que tener en "
"cuenta que los patrones que empiezan con aserciones positivas de búsqueda "
"tardía no coincidirán con el principio de la cadena que se está buscando; lo "
"más probable es que se quiera usar la función :func:`search` en lugar de la "
"función :func:`match`:"

#: ../Doc/library/re.rst:406
msgid "This example looks for a word following a hyphen:"
msgstr "Este ejemplo busca una palabra seguida de un guión:"

#: ../Doc/library/re.rst:412
msgid "Added support for group references of fixed length."
msgstr "Se añadió apoyo a las referencias de grupo de longitud fija."

#: ../Doc/library/re.rst:422
msgid "``(?<!...)``"
msgstr "``(?<!...)``"

#: ../Doc/library/re.rst:418
msgid ""
"Matches if the current position in the string is not preceded by a match for "
"``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar to "
"positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length.  Patterns which start with negative lookbehind "
"assertions may match at the beginning of the string being searched."
msgstr ""
"Coincide si la posición actual en la cadena no está precedida por una "
"coincidencia de \"…\".  Esto se llama una :dfn:`negative lookbehind "
"assertion` (Aserciones negativas de búsqueda tardía).  Similar a las "
"aserciones positivas de búsqueda tardía, el patrón contenido sólo debe "
"coincidir con cadenas de alguna longitud fija.  Los patrones que empiezan "
"con aserciones negativas pueden coincidir al principio de la cadena que se "
"busca."

#: ../Doc/library/re.rst:431
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/name)yes-pattern|no-pattern)``"

#: ../Doc/library/re.rst:425
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>|$)`` is a poor email matching pattern, which will match with "
"``'<user@host.com>'`` as well as ``'user@host.com'``, but not with "
"``'<user@host.com'`` nor ``'user@host.com>'``."
msgstr ""
"Tratará de coincidir con el ``yes-pattern`` (con patrón) si el grupo con un "
"*id* o  *nombre* existe, y con el ``no-pattern`` (sin patrón) si no existe. "
"El ``no-pattern`` es opcional y puede ser omitido. Por ejemplo, ``(<)?(\\w+@"
"\\w+(?:\\.\\w+)+)(?(1)>||$)`` es un patrón de coincidencia de correo "
"electrónico deficiente, ya que coincidirá con ``'<user@host.com>'`` así como "
"con ``'user@host.com'``, pero no con ``'<user@host.com'`` ni con "
"``'user@host.com>'``."

#: ../Doc/library/re.rst:433
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII letter, "
"then the resulting RE will match the second character.  For example, ``\\$`` "
"matches the character ``'$'``."
msgstr ""
"Las secuencias especiales consisten en ``'\\'`` y un carácter de la lista "
"que aparece más adelante. Si el carácter ordinario no es un dígito ASCII o "
"una letra ASCII, entonces el RE resultante coincidirá con el segundo "
"carácter.  Por ejemplo, ``\\$`` coincide con el carácter ``'$'``."

#: ../Doc/library/re.rst:448
msgid "``\\number``"
msgstr "``\\number``"

#: ../Doc/library/re.rst:441
msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first "
"digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""
"Coincide con el contenido del grupo del mismo número.  Los grupos se numeran "
"empezando por el 1. Por ejemplo, ``(.+) \\1`` coincide con ``'el el'`` o "
"``'55 55'``, pero no con ``'elel'`` (notar el espacio después del grupo).  "
"Esta secuencia especial sólo puede ser usada para hacer coincidir uno de los "
"primeros 99 grupos.  Si el primer dígito del *número* es 0, o el *número* "
"tiene 3 dígitos octales, no se interpretará como una coincidencia de grupo, "
"sino como el carácter con valor octal *número*. Dentro de los ``'['`` y "
"``']'`` de una clase de caracteres, todos los escapes numéricos son tratados "
"como caracteres."

#: ../Doc/library/re.rst:453
msgid "``\\A``"
msgstr "``\\A``"

#: ../Doc/library/re.rst:453
msgid "Matches only at the start of the string."
msgstr "Coincide sólo al principio de la cadena."

#: ../Doc/library/re.rst:469
msgid "``\\b``"
msgstr "``\\b``"

#: ../Doc/library/re.rst:458
msgid ""
"Matches the empty string, but only at the beginning or end of a word. A word "
"is defined as a sequence of word characters.  Note that formally, ``\\b`` is "
"defined as the boundary between a ``\\w`` and a ``\\W`` character (or vice "
"versa), or between ``\\w`` and the beginning/end of the string. This means "
"that ``r'\\bfoo\\b'`` matches ``'foo'``, ``'foo.'``, ``'(foo)'``, ``'bar foo "
"baz'`` but not ``'foobar'`` or ``'foo3'``."
msgstr ""
"Coincide con la cadena vacía, pero sólo al principio o al final de una "
"palabra. Una palabra se define como una secuencia de caracteres de "
"palabras.  Notar que formalmente, ``\\b`` se define como el límite entre un "
"carácter ``\\w`` y un carácter ``\\W`` (o viceversa), o entre ``\\w`` y el "
"principio/fin de la cadena. Esto significa que ``r'\\bfoo\\b'`` coincide con "
"``'foo'``, ``'foo.'``, ``'(foo)'``, ``'bar foo baz'`` pero no ``'foobar'`` o "
"``'foo3'``."

#: ../Doc/library/re.rst:465
msgid ""
"By default Unicode alphanumerics are the ones used in Unicode patterns, but "
"this can be changed by using the :const:`ASCII` flag.  Word boundaries are "
"determined by the current locale if the :const:`LOCALE` flag is used. Inside "
"a character range, ``\\b`` represents the backspace character, for "
"compatibility with Python's string literals."
msgstr ""
"Por defecto, los alfanuméricos Unicode son los que se usan en los patrones "
"Unicode, pero esto se puede cambiar usando el indicador :const:`ASCII`.  Los "
"límites de las palabras están determinados por la localización actual si se "
"usa el indicador :const:`LOCALE`. Dentro de un rango de caracteres, ``\\b`` "
"representa el carácter de retroceso (*backspace*), para compatibilidad con "
"los literales de las cadenas de Python."

#: ../Doc/library/re.rst:480
msgid "``\\B``"
msgstr "``\\B``"

#: ../Doc/library/re.rst:474
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word.  This means that ``r'py\\B'`` matches ``'python'``, ``'py3'``, "
"``'py2'``, but not ``'py'``, ``'py.'``, or ``'py!'``. ``\\B`` is just the "
"opposite of ``\\b``, so word characters in Unicode patterns are Unicode "
"alphanumerics or the underscore, although this can be changed by using the :"
"const:`ASCII` flag.  Word boundaries are determined by the current locale if "
"the :const:`LOCALE` flag is used."
msgstr ""
"Coincide con la cadena vacía, pero sólo cuando *no* está al principio o al "
"final de una palabra.  Esto significa que ``r'py\\B'`` coincide con "
"``'python'``, ``'py3'``, ``'py2'``, pero no con ``'py'``, ``'py.'`` o "
"``'py!'``. ``\\B`` es justo lo opuesto a ``\\b``, por lo que los caracteres "
"de las palabras en los patrones de Unicode son alfanuméricos o el subrayado, "
"aunque esto puede ser cambiado usando el indicador :const:`ASCII`.  Los "
"límites de las palabras están determinados por la localización actual si se "
"usa el indicador :const:`LOCALE`."

#: ../Doc/library/re.rst:492
msgid "``\\d``"
msgstr "``\\d``"

#: ../Doc/library/re.rst:489 ../Doc/library/re.rst:509
#: ../Doc/library/re.rst:529
msgid "For Unicode (str) patterns:"
msgstr "Para los patrones de Unicode (str):"

#: ../Doc/library/re.rst:486
msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category [Nd]).  This includes ``[0-9]``, and also many other "
"digit characters.  If the :const:`ASCII` flag is used only ``[0-9]`` is "
"matched."
msgstr ""
"Coincide con cualquier dígito decimal de Unicode (es decir, cualquier "
"carácter de la categoría de caracteres de Unicode [Nd]).  Esto incluye a "
"``[0-9]``, y también muchos otros caracteres de dígitos.  Si se usa el "
"indicador :const:`ASCII`, sólo coincide con ``[0-9]``."

#: ../Doc/library/re.rst:492 ../Doc/library/re.rst:513
#: ../Doc/library/re.rst:535
msgid "For 8-bit (bytes) patterns:"
msgstr "Para patrones de 8 bits (bytes):"

#: ../Doc/library/re.rst:492
msgid "Matches any decimal digit; this is equivalent to ``[0-9]``."
msgstr "Coincide con cualquier dígito decimal; esto equivale a ``[0-9]``."

#: ../Doc/library/re.rst:499
msgid "``\\D``"
msgstr "``\\D``"

#: ../Doc/library/re.rst:497
msgid ""
"Matches any character which is not a decimal digit. This is the opposite of "
"``\\d``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^0-9]``."
msgstr ""
"Coincide con cualquier carácter que no sea un dígito decimal. Esto es lo "
"opuesto a ``\\d``. Si se usa el indicador :const:`ASCII` esto se convierte "
"en el equivalente a ``[^0-9]``."

#: ../Doc/library/re.rst:513
msgid "``\\s``"
msgstr "``\\s``"

#: ../Doc/library/re.rst:505
msgid ""
"Matches Unicode whitespace characters (which includes ``[ \\t\\n\\r\\f"
"\\v]``, and also many other characters, for example the non-breaking spaces "
"mandated by typography rules in many languages). If the :const:`ASCII` flag "
"is used, only ``[ \\t\\n\\r\\f\\v]`` is matched."
msgstr ""
"Coincide con los caracteres de los espacios en blanco de Unicode (que "
"incluye ``[ \\t\\n\\r\\f\\v]``, y también muchos otros caracteres, por "
"ejemplo los espacios duros exigidos por las reglas tipográficas en muchos "
"idiomas). Si se usa el indicador :const:`ASCII``, sólo ``[ \\t\\n\\r\\f"
"\\v]`` coincide."

#: ../Doc/library/re.rst:512
msgid ""
"Matches characters considered whitespace in the ASCII character set; this is "
"equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"Coincide con los caracteres considerados como espacios en blanco en el "
"conjunto de caracteres ASCII, lo que equivale a ``[ \\t\\n\\r\\f\\v]``."

#: ../Doc/library/re.rst:520
msgid "``\\S``"
msgstr "``\\S``"

#: ../Doc/library/re.rst:518
msgid ""
"Matches any character which is not a whitespace character. This is the "
"opposite of ``\\s``. If the :const:`ASCII` flag is used this becomes the "
"equivalent of ``[^ \\t\\n\\r\\f\\v]``."
msgstr ""
"Coincide con cualquier personaje que no sea un carácter de espacio en "
"blanco. Esto es lo opuesto a ``\\s``. Si se usa el indicador :const:`ASCII` "
"se convierte en el equivalente a ``[^ \\t\\n\\r\\f\\v]`."

#: ../Doc/library/re.rst:535
msgid "``\\w``"
msgstr "``\\w``"

#: ../Doc/library/re.rst:526
msgid ""
"Matches Unicode word characters; this includes most characters that can be "
"part of a word in any language, as well as numbers and the underscore. If "
"the :const:`ASCII` flag is used, only ``[a-zA-Z0-9_]`` is matched."
msgstr ""
"Coincide con los caracteres de palabras de Unicode; esto incluye la mayoría "
"de los caracteres que pueden formar parte de una palabra en cualquier "
"idioma, así como los números y el guión bajo. Si se usa el indicador :const:"
"`ASCII`, sólo coincide con ``[a-zA-Z0-9_]``."

#: ../Doc/library/re.rst:532
msgid ""
"Matches characters considered alphanumeric in the ASCII character set; this "
"is equivalent to ``[a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, "
"matches characters considered alphanumeric in the current locale and the "
"underscore."
msgstr ""
"Coincide con los caracteres considerados alfanuméricos en el conjunto de "
"caracteres ASCII; esto equivale a ``[a-zA-Z0-9_]``.  Si se usa el indicador :"
"const:`LOCALE`, coincide con los caracteres considerados alfanuméricos en la "
"localidad actual y el guión bajo."

#: ../Doc/library/re.rst:544
msgid "``\\W``"
msgstr "``\\W``"

#: ../Doc/library/re.rst:540
msgid ""
"Matches any character which is not a word character. This is the opposite of "
"``\\w``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, matches characters "
"which are neither alphanumeric in the current locale nor the underscore."
msgstr ""
"Coincide con cualquier personaje que no sea un carácter de palabras. Esto es "
"lo opuesto a ``\\w``. Si se usa el indicador :const:`ASCII` esto se "
"convierte en el equivalente a ``[^a-zA-Z0-9_]``.  Si se usa el indicador :"
"const:`LOCALE`, coincide con los caracteres que no son ni alfanuméricos en "
"la localidad actual ni con el guión bajo."

#: ../Doc/library/re.rst:549
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../Doc/library/re.rst:549
msgid "Matches only at the end of the string."
msgstr "Coincide sólo el final de la cadena."

#: ../Doc/library/re.rst:565
msgid ""
"Most of the standard escapes supported by Python string literals are also "
"accepted by the regular expression parser::"
msgstr ""
"La mayoría de los escapes estándar soportados por los literales de la cadena "
"de Python también son aceptados por el analizador de expresiones regulares::"

#: ../Doc/library/re.rst:572
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr ""
"(Notar que ``\\b`` se usa para representar los límites de las palabras, y "
"significa \"retroceso\" (*backspace*) sólo dentro de las clases de "
"caracteres.)"

#: ../Doc/library/re.rst:575
msgid ""
"``'\\u'``, ``'\\U'``, and ``'\\N'`` escape sequences are only recognized in "
"Unicode patterns.  In bytes patterns they are errors.  Unknown escapes of "
"ASCII letters are reserved for future use and treated as errors."
msgstr ""
"Las secuencias de escape ``'\\u'``, ``'\\U'`` y ``'\\N'`` sólo se reconocen "
"en los patrones Unicode.  En los patrones de bytes son errores.  Los escapes "
"desconocidos de las letras ASCII se reservan para su uso posterior y se "
"consideran errores."

#: ../Doc/library/re.rst:579
msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0, or "
"if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""
"Los escapes octales se incluyen en una forma limitada.  Si el primer dígito "
"es un 0, o si hay tres dígitos octales, se considera un escape octal. De lo "
"contrario, es una referencia de grupo.  En cuanto a los literales de cadena, "
"los escapes octales siempre tienen como máximo tres dígitos de longitud."

#: ../Doc/library/re.rst:584
msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr "Se han añadido las secuencias de escape ``'\\u'`` y ``'\\U'``."

#: ../Doc/library/re.rst:587
msgid ""
"Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr ""
"Los escapes desconocidos que consisten en ``'\\'`` y una letra ASCII ahora "
"son errores."

#: ../Doc/library/re.rst:590
msgid ""
"The ``'\\N{name}'`` escape sequence has been added. As in string literals, "
"it expands to the named Unicode character (e.g. ``'\\N{EM DASH}'``)."
msgstr ""
"Se añadió la secuencia de escape ``'\\N{name}'``. Como en los literales de "
"cadena, se expande al carácter Unicode nombrado (por ej. ``'\\N{EM DASH}'``)."

#: ../Doc/library/re.rst:598
msgid "Module Contents"
msgstr "Contenidos del módulo"

#: ../Doc/library/re.rst:600
msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr ""
"El módulo define varias funciones, constantes y una excepción. Algunas de "
"las funciones son versiones simplificadas de los métodos completos de las "
"expresiones regulares compiladas.  La mayoría de las aplicaciones no "
"triviales utilizan siempre la forma compilada."

#: ../Doc/library/re.rst:605
msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a subclass "
"of :class:`enum.IntFlag`."
msgstr ""
"Ahora las constantes de indicadores son instancias de :class:`RegexFlag`, "
"que es una subclase de :class:`enum.IntFlag`."

#: ../Doc/library/re.rst:611
msgid ""
"Compile a regular expression pattern into a :ref:`regular expression object "
"<re-objects>`, which can be used for matching using its :func:`~Pattern."
"match`, :func:`~Pattern.search` and other methods, described below."
msgstr ""
"Compila un patrón de expresión regular en un :ref:`regular expression object "
"<re-objects>`, que puede ser usado para las coincidencias usando :func:"
"`~Pattern.match`, :func:`~Pattern.search` y otros métodos, descritos más "
"adelante."

#: ../Doc/library/re.rst:616
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the following variables, combined using bitwise OR (the "
"``|`` operator)."
msgstr ""
"El comportamiento de la expresión puede modificarse especificando un valor "
"de *indicadores*. Los valores pueden ser cualquiera de las siguientes "
"variables, combinadas usando el operador OR (el operador ``|``)."

#: ../Doc/library/re.rst:620
msgid "The sequence ::"
msgstr "La secuencia ::"

#: ../Doc/library/re.rst:625
msgid "is equivalent to ::"
msgstr "es equivalente a ::"

#: ../Doc/library/re.rst:629
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr ""
"pero usando :func:`re.compile` y guardando el objeto resultante de la "
"expresión regular para su reutilización es más eficiente cuando la expresión "
"será usada varias veces en un solo programa."

#: ../Doc/library/re.rst:635
msgid ""
"The compiled versions of the most recent patterns passed to :func:`re."
"compile` and the module-level matching functions are cached, so programs "
"that use only a few regular expressions at a time needn't worry about "
"compiling regular expressions."
msgstr ""
"Las versiones compiladas de los patrones más recientes pasaron a :func:`re."
"compile` y las funciones de coincidencia a nivel de módulo están en caché, "
"así que los programas que usan sólo unas pocas expresiones regulares a la "
"vez no tienen que preocuparse de compilar expresiones regulares."

#: ../Doc/library/re.rst:644
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and ``"
"\\S`` perform ASCII-only matching instead of full Unicode matching.  This is "
"only meaningful for Unicode patterns, and is ignored for byte patterns. "
"Corresponds to the inline flag ``(?a)``."
msgstr ""
"Hace que ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` y ``"
"\\S`` realicen una coincidencia ASCII en lugar de una concordancia Unicode.  "
"Esto sólo tiene sentido para los patrones de Unicode, y se ignora para los "
"patrones de bytes. Corresponde al indicador en línea ``(?a)``."

#: ../Doc/library/re.rst:649
msgid ""
"Note that for backward compatibility, the :const:`re.U` flag still exists "
"(as well as its synonym :const:`re.UNICODE` and its embedded counterpart ``(?"
"u)``), but these are redundant in Python 3 since matches are Unicode by "
"default for strings (and Unicode matching isn't allowed for bytes)."
msgstr ""
"Notar que para la compatibilidad con versiones anteriores, el indicador :"
"const:`re.U` todavía existe (así como su sinónimo :const:`re.UNICODE` y su "
"contraparte incrustada ``(?u)``), pero estos son redundantes en Python 3 ya "
"que las coincidencias son Unicode por defecto para las cadenas (y no se "
"permite la coincidencia Unicode para los bytes)."

#: ../Doc/library/re.rst:658
msgid ""
"Display debug information about compiled expression. No corresponding inline "
"flag."
msgstr ""
"Muestra información de depuración (*debug*) sobre la expresión compilada. No "
"hay un indicador en línea que corresponda."

#: ../Doc/library/re.rst:665
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also "
"match lowercase letters.  Full Unicode matching (such as ``Ü`` matching "
"``ü``) also works unless the :const:`re.ASCII` flag is used to disable non-"
"ASCII matches.  The current locale does not change the effect of this flag "
"unless the :const:`re.LOCALE` flag is also used. Corresponds to the inline "
"flag ``(?i)``."
msgstr ""
"Realiza una coincidencia insensible a las mayúsculas y minúsculas; "
"expresiones como ``[A-Z]`` también coincidirán con las minúsculas.  La "
"coincidencia completa de Unicode (como ``Ü`` coincidencia ``ü``) también "
"funciona a menos que el indicador :const:`re.ASCII` se utilice para "
"desactivar las coincidencias que no sean ASCII.  La localización vigente no "
"cambia el efecto de este indicador a menos que también se use el indicador :"
"const:`re.LOCALE`. Corresponde al indicador en línea ``(?i)``."

#: ../Doc/library/re.rst:672
msgid ""
"Note that when the Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in "
"combination with the :const:`IGNORECASE` flag, they will match the 52 ASCII "
"letters and 4 additional non-ASCII letters: 'İ' (U+0130, Latin capital "
"letter I with dot above), 'ı' (U+0131, Latin small letter dotless i), 'ſ' (U"
"+017F, Latin small letter long s) and 'K' (U+212A, Kelvin sign). If the :"
"const:`ASCII` flag is used, only letters 'a' to 'z' and 'A' to 'Z' are "
"matched."
msgstr ""
"Notar que cuando los patrones Unicode ``[a-z]`` o ``[A-Z]`` se usan en "
"combinación con el indicador :const:`IGNORECASE``, coincidirán con las 52 "
"letras ASCII y 4 letras adicionales no ASCII: 'İ' (U+0130, letra mayúscula "
"latina I con punto arriba), 'ı' (U+0131, letra minúscula latina sin punto "
"i), 'ſ' (U+017F, letra minúscula latina s larga) y 'K' (U+212A, signo "
"Kelvin). Si se usa el indicador :const:`ASCII`, sólo las letras de la 'a' a "
"la 'z' y de la 'A' a la 'Z' coinciden."

#: ../Doc/library/re.rst:683
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale.  This flag can be used only with bytes "
"patterns.  The use of this flag is discouraged as the locale mechanism is "
"very unreliable, it only handles one \"culture\" at a time, and it only "
"works with 8-bit locales.  Unicode matching is already enabled by default in "
"Python 3 for Unicode (str) patterns, and it is able to handle different "
"locales/languages. Corresponds to the inline flag ``(?L)``."
msgstr ""

#: ../Doc/library/re.rst:692
msgid ""
":const:`re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :const:`re.ASCII`."
msgstr ""

#: ../Doc/library/re.rst:696
msgid ""
"Compiled regular expression objects with the :const:`re.LOCALE` flag no "
"longer depend on the locale at compile time.  Only the locale at matching "
"time affects the result of matching."
msgstr ""

#: ../Doc/library/re.rst:705
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string "
"and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string. Corresponds to the inline flag ``(?m)``."
msgstr ""

#: ../Doc/library/re.rst:717
msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline. "
"Corresponds to the inline flag ``(?s)``."
msgstr ""

#: ../Doc/library/re.rst:727
msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class, or when preceded by an unescaped backslash, or "
"within tokens like ``*?``, ``(?:`` or ``(?P<...>``. When a line contains a "
"``#`` that is not in a character class and is not preceded by an unescaped "
"backslash, all characters from the leftmost such ``#`` through the end of "
"the line are ignored."
msgstr ""

#: ../Doc/library/re.rst:736
msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr ""

#: ../Doc/library/re.rst:744
msgid "Corresponds to the inline flag ``(?x)``."
msgstr ""

#: ../Doc/library/re.rst:749
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding :ref:"
"`match object <match-objects>`.  Return ``None`` if no position in the "
"string matches the pattern; note that this is different from finding a zero-"
"length match at some point in the string."
msgstr ""

#: ../Doc/library/re.rst:758
msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :ref:`match object <match-"
"objects>`.  Return ``None`` if the string does not match the pattern; note "
"that this is different from a zero-length match."
msgstr ""

#: ../Doc/library/re.rst:763
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr ""

#: ../Doc/library/re.rst:766
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""

#: ../Doc/library/re.rst:772
msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""

#: ../Doc/library/re.rst:782
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list. ::"
msgstr ""

#: ../Doc/library/re.rst:797
msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string::"
msgstr ""

#: ../Doc/library/re.rst:804
msgid ""
"That way, separator components are always found at the same relative indices "
"within the result list."
msgstr ""

#: ../Doc/library/re.rst:807
msgid ""
"Empty matches for the pattern split the string only when not adjacent to a "
"previous empty match."
msgstr ""

#: ../Doc/library/re.rst:817 ../Doc/library/re.rst:897
#: ../Doc/library/re.rst:921
msgid "Added the optional flags argument."
msgstr ""

#: ../Doc/library/re.rst:820
msgid ""
"Added support of splitting on a pattern that could match an empty string."
msgstr ""

#: ../Doc/library/re.rst:826
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings.  The *string* is scanned left-to-right, and matches are returned in "
"the order found.  If one or more groups are present in the pattern, return a "
"list of groups; this will be a list of tuples if the pattern has more than "
"one group.  Empty matches are included in the result."
msgstr ""

#: ../Doc/library/re.rst:832 ../Doc/library/re.rst:843
msgid "Non-empty matches can now start just after a previous empty match."
msgstr ""

#: ../Doc/library/re.rst:838
msgid ""
"Return an :term:`iterator` yielding :ref:`match objects <match-objects>` "
"over all non-overlapping matches for the RE *pattern* in *string*.  The "
"*string* is scanned left-to-right, and matches are returned in the order "
"found.  Empty matches are included in the result."
msgstr ""

#: ../Doc/library/re.rst:849
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string "
"or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, ``"
"\\r`` is converted to a carriage return, and so forth.  Unknown escapes of "
"ASCII letters are reserved for future use and treated as errors.  Other "
"unknown escapes such as ``\\&`` are left alone. Backreferences, such as ``"
"\\6``, are replaced with the substring matched by group 6 in the pattern. "
"For example::"
msgstr ""

#: ../Doc/library/re.rst:865
msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single :ref:`match object <match-"
"objects>` argument, and returns the replacement string.  For example::"
msgstr ""

#: ../Doc/library/re.rst:877
msgid "The pattern may be a string or a :ref:`pattern object <re-objects>`."
msgstr ""

#: ../Doc/library/re.rst:879
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero, "
"all occurrences will be replaced. Empty matches for the pattern are replaced "
"only when not adjacent to a previous empty match, so ``sub('x*', '-', "
"'abxd')`` returns ``'-a-b--d-'``."
msgstr ""

#: ../Doc/library/re.rst:887
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched "
"by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. ``"
"\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore "
"equivalent to ``\\2``, but isn't ambiguous in a replacement such as ``"
"\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not a "
"reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr ""

#: ../Doc/library/re.rst:900 ../Doc/library/re.rst:924
#: ../Doc/library/re.rst:1155
msgid "Unmatched groups are replaced with an empty string."
msgstr ""

#: ../Doc/library/re.rst:903
msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter now "
"are errors."
msgstr ""

#: ../Doc/library/re.rst:907
msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now are "
"errors."
msgstr ""

#: ../Doc/library/re.rst:911
msgid ""
"Empty matches for the pattern are replaced when adjacent to a previous non-"
"empty match."
msgstr ""

#: ../Doc/library/re.rst:918
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string, "
"number_of_subs_made)``."
msgstr ""

#: ../Doc/library/re.rst:930
msgid ""
"Escape special characters in *pattern*. This is useful if you want to match "
"an arbitrary literal string that may have regular expression metacharacters "
"in it.  For example::"
msgstr ""

#: ../Doc/library/re.rst:945
msgid ""
"This function must not be used for the replacement string in :func:`sub` "
"and :func:`subn`, only backslashes should be escaped.  For example::"
msgstr ""

#: ../Doc/library/re.rst:953
msgid "The ``'_'`` character is no longer escaped."
msgstr ""

#: ../Doc/library/re.rst:956
msgid ""
"Only characters that can have special meaning in a regular expression are "
"escaped. As a result, ``'!'``, ``'\"'``, ``'%'``, ``\"'\"``, ``','``, "
"``'/'``, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``, ``'@'``, and ``\"`\"`` "
"are no longer escaped."
msgstr ""

#: ../Doc/library/re.rst:965
msgid "Clear the regular expression cache."
msgstr ""

#: ../Doc/library/re.rst:970
msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or "
"matching.  It is never an error if a string contains no match for a "
"pattern.  The error instance has the following additional attributes:"
msgstr ""

#: ../Doc/library/re.rst:978
msgid "The unformatted error message."
msgstr ""

#: ../Doc/library/re.rst:982
msgid "The regular expression pattern."
msgstr ""

#: ../Doc/library/re.rst:986
msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr ""

#: ../Doc/library/re.rst:990
msgid "The line corresponding to *pos* (may be ``None``)."
msgstr ""

#: ../Doc/library/re.rst:994
msgid "The column corresponding to *pos* (may be ``None``)."
msgstr ""

#: ../Doc/library/re.rst:996
msgid "Added additional attributes."
msgstr ""

#: ../Doc/library/re.rst:1002
msgid "Regular Expression Objects"
msgstr ""

#: ../Doc/library/re.rst:1004
msgid ""
"Compiled regular expression objects support the following methods and "
"attributes:"
msgstr ""

#: ../Doc/library/re.rst:1009
msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding :ref:`match object "
"<match-objects>`.  Return ``None`` if no position in the string matches the "
"pattern; note that this is different from finding a zero-length match at "
"some point in the string."
msgstr ""

#: ../Doc/library/re.rst:1015
msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent "
"to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""

#: ../Doc/library/re.rst:1021
msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found; otherwise, if *rx* is a "
"compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``. ::"
msgstr ""

#: ../Doc/library/re.rst:1036
msgid ""
"If zero or more characters at the *beginning* of *string* match this regular "
"expression, return a corresponding :ref:`match object <match-objects>`. "
"Return ``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""

#: ../Doc/library/re.rst:1041 ../Doc/library/re.rst:1059
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the :"
"meth:`~Pattern.search` method. ::"
msgstr ""

#: ../Doc/library/re.rst:1049
msgid ""
"If you want to locate a match anywhere in *string*, use :meth:`~Pattern."
"search` instead (see also :ref:`search-vs-match`)."
msgstr ""

#: ../Doc/library/re.rst:1055
msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""

#: ../Doc/library/re.rst:1073
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr ""

#: ../Doc/library/re.rst:1078
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""

#: ../Doc/library/re.rst:1085
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""

#: ../Doc/library/re.rst:1092
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr ""

#: ../Doc/library/re.rst:1097
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr ""

#: ../Doc/library/re.rst:1102
msgid ""
"The regex matching flags.  This is a combination of the flags given to :func:"
"`.compile`, any ``(?...)`` inline flags in the pattern, and implicit flags "
"such as :data:`UNICODE` if the pattern is a Unicode string."
msgstr ""

#: ../Doc/library/re.rst:1109
msgid "The number of capturing groups in the pattern."
msgstr ""

#: ../Doc/library/re.rst:1114
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr ""

#: ../Doc/library/re.rst:1121
msgid "The pattern string from which the pattern object was compiled."
msgstr ""

#: ../Doc/library/re.rst:1124
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Compiled "
"regular expression objects are considered atomic."
msgstr ""

#: ../Doc/library/re.rst:1132
msgid "Match Objects"
msgstr ""

#: ../Doc/library/re.rst:1134
msgid ""
"Match objects always have a boolean value of ``True``. Since :meth:`~Pattern."
"match` and :meth:`~Pattern.search` return ``None`` when there is no match, "
"you can test whether there was a match with a simple ``if`` statement::"
msgstr ""

#: ../Doc/library/re.rst:1143
msgid "Match objects support the following methods and attributes:"
msgstr ""

#: ../Doc/library/re.rst:1148
msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~Pattern.sub` method. Escapes such "
"as ``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, ``"
"\\g<name>``) are replaced by the contents of the corresponding group."
msgstr ""

#: ../Doc/library/re.rst:1160
msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match, "
"the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned. ::"
msgstr ""

#: ../Doc/library/re.rst:1182
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an :exc:"
"`IndexError` exception is raised."
msgstr ""

#: ../Doc/library/re.rst:1187
msgid "A moderately complicated example::"
msgstr ""

#: ../Doc/library/re.rst:1195
msgid "Named groups can also be referred to by their index::"
msgstr ""

#: ../Doc/library/re.rst:1202
msgid "If a group matches multiple times, only the last match is accessible::"
msgstr ""

#: ../Doc/library/re.rst:1211
msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match::"
msgstr ""

#: ../Doc/library/re.rst:1227
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``."
msgstr ""

#: ../Doc/library/re.rst:1231 ../Doc/library/re.rst:1453
msgid "For example::"
msgstr ""

#: ../Doc/library/re.rst:1237
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given::"
msgstr ""

#: ../Doc/library/re.rst:1250
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed "
"by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example::"
msgstr ""

#: ../Doc/library/re.rst:1262
msgid ""
"Return the indices of the start and end of the substring matched by *group*; "
"*group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""

#: ../Doc/library/re.rst:1270
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, ``m."
"start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are both "
"2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""

#: ../Doc/library/re.rst:1275
msgid "An example that will remove *remove_this* from email addresses::"
msgstr ""

#: ../Doc/library/re.rst:1285
msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. Note "
"that if *group* did not contribute to the match, this is ``(-1, -1)``. "
"*group* defaults to zero, the entire match."
msgstr ""

#: ../Doc/library/re.rst:1292
msgid ""
"The value of *pos* which was passed to the :meth:`~Pattern.search` or :meth:"
"`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This is the "
"index into the string at which the RE engine started looking for a match."
msgstr ""

#: ../Doc/library/re.rst:1299
msgid ""
"The value of *endpos* which was passed to the :meth:`~Pattern.search` or :"
"meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This is "
"the index into the string beyond which the RE engine will not go."
msgstr ""

#: ../Doc/library/re.rst:1306
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, ``((a)"
"(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the string "
"``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == 2``, if "
"applied to the same string."
msgstr ""

#: ../Doc/library/re.rst:1315
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr ""

#: ../Doc/library/re.rst:1321
msgid ""
"The :ref:`regular expression object <re-objects>` whose :meth:`~Pattern."
"match` or :meth:`~Pattern.search` method produced this match instance."
msgstr ""

#: ../Doc/library/re.rst:1327
msgid "The string passed to :meth:`~Pattern.match` or :meth:`~Pattern.search`."
msgstr ""

#: ../Doc/library/re.rst:1330
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Match objects "
"are considered atomic."
msgstr ""

#: ../Doc/library/re.rst:1338
msgid "Regular Expression Examples"
msgstr "Ejemplos de expresiones regulares"

#: ../Doc/library/re.rst:1342
msgid "Checking for a Pair"
msgstr "Buscando un par"

#: ../Doc/library/re.rst:1344
msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully::"
msgstr ""
"En este ejemplo, se utilizará la siguiente función de ayuda para mostrar los "
"objetos de coincidencia con un poco más de gracia::"

#: ../Doc/library/re.rst:1352
msgid ""
"Suppose you are writing a poker program where a player's hand is represented "
"as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr ""
"Supongamos que se está escribiendo un programa de póquer en el que la mano "
"de un jugador se representa como una cadena de 5 caracteres en la que cada "
"carácter representa una carta, \"a\" para el as, \"k\" para el rey, \"q\" "
"para la reina, \"j\" para la jota, \"t\" para el 10, y del \" 2\" al \"9\" "
"representando la carta con ese valor."

#: ../Doc/library/re.rst:1357
msgid "To see if a given string is a valid hand, one could do the following::"
msgstr ""
"Para ver si una cadena dada es una mano válida, se podría hacer lo "
"siguiente::"

#: ../Doc/library/re.rst:1367
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences "
"as such::"
msgstr ""
"Esa última mano, ``\"727ak\"``, contenía un par, o dos de las mismas cartas "
"de valor. Para igualar esto con una expresión regular, se podrían usar "
"referencias inversas como tales::"

#: ../Doc/library/re.rst:1377
msgid ""
"To find out what card the pair consists of, one could use the :meth:`~Match."
"group` method of the match object in the following manner::"
msgstr ""
"Para averiguar en qué carta consiste el par, se podría utilizar el método :"
"meth:`~Match.group` del objeto de coincidencia de la siguiente manera::"

#: ../Doc/library/re.rst:1396
msgid "Simulating scanf()"
msgstr "Simular scanf()"

#: ../Doc/library/re.rst:1400
msgid ""
"Python does not currently have an equivalent to :c:func:`scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than :c:"
"func:`scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :c:func:`scanf` format tokens and regular "
"expressions."
msgstr ""
"Python no tiene actualmente un equivalente a :c:func:`scanf`.  Las "
"expresiones regulares son generalmente más poderosas, aunque también más "
"verbosas, que las cadenas de formato :c:func:`scanf`.  La tabla siguiente "
"ofrece algunos mapeos más o menos equivalentes entre tokens de formato :c:"
"func:`scanf` y expresiones regulares."

#: ../Doc/library/re.rst:1407
msgid ":c:func:`scanf` Token"
msgstr "Token :c:func:`scanf`"

#: ../Doc/library/re.rst:1407
msgid "Regular Expression"
msgstr "Expresión regular"

#: ../Doc/library/re.rst:1409
#, python-format
msgid "``%c``"
msgstr "``%c``"

#: ../Doc/library/re.rst:1411
#, python-format
msgid "``%5c``"
msgstr "``%5c``"

#: ../Doc/library/re.rst:1411
msgid "``.{5}``"
msgstr "``.{5}``"

#: ../Doc/library/re.rst:1413
#, python-format
msgid "``%d``"
msgstr "``%d``"

#: ../Doc/library/re.rst:1413
msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

#: ../Doc/library/re.rst:1415
#, python-format
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr "``%e``, ``%E``, ``%f``, ``%g``"

#: ../Doc/library/re.rst:1415
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

#: ../Doc/library/re.rst:1417
#, python-format
msgid "``%i``"
msgstr "``%i``"

#: ../Doc/library/re.rst:1417
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

#: ../Doc/library/re.rst:1419
#, python-format
msgid "``%o``"
msgstr "``%o``"

#: ../Doc/library/re.rst:1419
msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

#: ../Doc/library/re.rst:1421
#, python-format
msgid "``%s``"
msgstr "``%s``"

#: ../Doc/library/re.rst:1421
msgid "``\\S+``"
msgstr "``\\S+``"

#: ../Doc/library/re.rst:1423
#, python-format
msgid "``%u``"
msgstr "``%u``"

#: ../Doc/library/re.rst:1423
msgid "``\\d+``"
msgstr "``\\d+``"

#: ../Doc/library/re.rst:1425
#, python-format
msgid "``%x``, ``%X``"
msgstr "``%x``, ``%X``"

#: ../Doc/library/re.rst:1425
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

#: ../Doc/library/re.rst:1428
msgid "To extract the filename and numbers from a string like ::"
msgstr "Para extraer el nombre de archivo y los números de una cadena como ::"

#: ../Doc/library/re.rst:1432
msgid "you would use a :c:func:`scanf` format like ::"
msgstr "se usaría un formato :c:func:`scanf` como ::"

#: ../Doc/library/re.rst:1436
msgid "The equivalent regular expression would be ::"
msgstr "La expresión regular equivalente sería ::"

#: ../Doc/library/re.rst:1444
msgid "search() vs. match()"
msgstr "search() vs. match()"

#: ../Doc/library/re.rst:1448
msgid ""
"Python offers two different primitive operations based on regular "
"expressions: :func:`re.match` checks for a match only at the beginning of "
"the string, while :func:`re.search` checks for a match anywhere in the "
"string (this is what Perl does by default)."
msgstr ""
"Python ofrece dos operaciones primitivas diferentes basadas en expresiones "
"regulares: :func:`re.match` comprueba si hay una coincidencia sólo al "
"principio de la cadena, mientras que :func:`re.search` comprueba si hay una "
"coincidencia en cualquier parte de la cadena (esto es lo que hace Perl por "
"defecto)."

#: ../Doc/library/re.rst:1459
msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr ""
"Las expresiones regulares que comienzan con ``'^'`` pueden ser usadas con :"
"func:`search` para restringir la coincidencia al principio de la cadena::"

#: ../Doc/library/re.rst:1467
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each "
"line. ::"
msgstr ""
"Notar, sin embargo, que en el modo :const:`MULTILINE` :func:`match` sólo "
"coincide al principio de la cadena, mientras que usando :func:`search` con "
"una expresión regular que comienza con ``'^'`` coincidirá al principio de "
"cada línea. ::"

#: ../Doc/library/re.rst:1477
msgid "Making a Phonebook"
msgstr "Haciendo una guía telefónica"

#: ../Doc/library/re.rst:1479
msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""
":func:`split` divide una cadena en una lista delimitada por el patrón "
"recibido.  El método es muy útil para convertir datos textuales en "
"estructuras de datos que pueden ser fácilmente leídas y modificadas por "
"Python, como se demuestra en el siguiente ejemplo en el que se crea una guía "
"telefónica."

#: ../Doc/library/re.rst:1484
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax"
msgstr ""
"Primero, aquí está la información.  Normalmente puede venir de un archivo, "
"aquí se usa la sintaxis de cadena de triple comilla"

#: ../Doc/library/re.rst:1497
msgid ""
"The entries are separated by one or more newlines. Now we convert the string "
"into a list with each nonempty line having its own entry:"
msgstr ""
"Las entradas (*entries*) están separadas por una o más líneas nuevas. Ahora "
"se convierte la cadena en una lista en la que cada línea no vacía tiene su "
"propia entrada:"

#: ../Doc/library/re.rst:1510
msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""
"Finalmente, se divide cada entrada en una lista con nombre, apellido, número "
"de teléfono y dirección.  Se utiliza el parámetro ``maxsplit`` (división "
"máxima) de :func:`split` porque la dirección tiene espacios dentro del "
"patrón de división:"

#: ../Doc/library/re.rst:1523
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""
"El patrón ``:?`` coincide con los dos puntos después del apellido, de manera "
"que no aparezca en la lista de resultados.  Con ``maxsplit`` de ``4``, se "
"podría separar el número de casa del nombre de la calle:"

#: ../Doc/library/re.rst:1538
msgid "Text Munging"
msgstr ""

#: ../Doc/library/re.rst:1540
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""

#: ../Doc/library/re.rst:1557
msgid "Finding all Adverbs"
msgstr ""

#: ../Doc/library/re.rst:1559
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if a writer wanted to find all of "
"the adverbs in some text, they might use :func:`findall` in the following "
"manner::"
msgstr ""

#: ../Doc/library/re.rst:1570
msgid "Finding all Adverbs and their Positions"
msgstr ""

#: ../Doc/library/re.rst:1572
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides :ref:`match objects "
"<match-objects>` instead of strings.  Continuing with the previous example, "
"if a writer wanted to find all of the adverbs *and their positions* in some "
"text, they would use :func:`finditer` in the following manner::"
msgstr ""

#: ../Doc/library/re.rst:1586
msgid "Raw String Notation"
msgstr ""

#: ../Doc/library/re.rst:1588
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without "
"it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical::"
msgstr ""

#: ../Doc/library/re.rst:1598
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical::"
msgstr ""

#: ../Doc/library/re.rst:1610
msgid "Writing a Tokenizer"
msgstr ""

#: ../Doc/library/re.rst:1612
msgid ""
"A `tokenizer or scanner <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"analyzes a string to categorize groups of characters.  This is a useful "
"first step in writing a compiler or interpreter."
msgstr ""

#: ../Doc/library/re.rst:1616
msgid ""
"The text categories are specified with regular expressions.  The technique "
"is to combine those into a single master regular expression and to loop over "
"successive matches::"
msgstr ""

#: ../Doc/library/re.rst:1672
msgid "The tokenizer produces the following output::"
msgstr ""

#: ../Doc/library/re.rst:1695
msgid ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. The third edition of the book no longer covers Python at all, but the "
"first edition covered writing good regular expression patterns in great "
"detail."
msgstr ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. La tercera edición del libro ya no abarca a Python en absoluto, pero "
"la primera edición cubría la escritura de buenos patrones de expresiones "
"regulares con gran detalle."
