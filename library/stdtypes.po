# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2024-01-27 18:16+0100\n"
"Last-Translator: José Luis Salgado Banda\n"
"Language-Team: python-doc-es\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.13.0\n"
"X-Generator: Poedit 3.0.1\n"

#: ../Doc/library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "Tipos integrados"

#: ../Doc/library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""
"Esta sección describe los tipos de datos estándar que vienen incluidos en el "
"intérprete."

#: ../Doc/library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr ""
"Los principales tipos de datos son: numéricos, secuencias, mapas, clases, "
"instancias y excepciones."

#: ../Doc/library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"Algunas clases de tipo colección son mutables. Los métodos que añaden, "
"retiran u ordenan sus miembros en su lugar, y a no ser que retornen un "
"elemento concreto, nunca retornan la propia instancia contenedora, sino "
"``None``."

#: ../Doc/library/stdtypes.rst:22
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared for equality, tested for truth "
"value, and converted to a string (with the :func:`repr` function or the "
"slightly different :func:`str` function).  The latter function is implicitly "
"used when an object is written by the :func:`print` function."
msgstr ""
"Algunas operaciones son soportadas por varios tipos de objetos diferentes; "
"por ejemplo, prácticamente todos los objetos pueden ser comparados por "
"igualdad, evaluados para ser considerados como valores booleanos, o "
"representarse en forma de cadena de caracteres (ya sea con la función :func:"
"`repr` o con la función ligeramente diferente :func:`str`). Esta última es "
"la usada implícitamente cuando un objeto se escribe con la función :func:"
"`print`."

#: ../Doc/library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "Evaluar como valor verdadero/falso"

#: ../Doc/library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"Cualquier objeto puede ser evaluado como si fuera un valor verdadero o "
"falso, para ser usado directamente en sentencias :keyword:`if` o :keyword:"
"`while`, o como un operador en una operación booleana como las que veremos "
"más adelante."

#: ../Doc/library/stdtypes.rst:46
#, fuzzy
msgid ""
"By default, an object is considered true unless its class defines either a :"
"meth:`~object.__bool__` method that returns ``False`` or a :meth:`__len__` "
"method that returns zero, when called with the object. [1]_  Here are most "
"of the built-in objects considered false:"
msgstr ""
"Por defecto, un objeto se considera verdadero a no ser que su clase defina o "
"bien un método :meth:`__bool__` que retorna ``False`` o un método :meth:"
"`__len__` que retorna cero, cuando se invoque desde ese objeto. [1]_ Aquí "
"están listados la mayoría de los objetos integrados que se evalúan como "
"falsos:"

#: ../Doc/library/stdtypes.rst:55
#, fuzzy
msgid "constants defined to be false: ``None`` and ``False``"
msgstr "constantes definidas para tener valor falso: ``None`` y ``False``."

#: ../Doc/library/stdtypes.rst:57
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr ""
"cero en cualquiera de los diferentes tipos numéricos: ``0``, ``0.0``, "
"``0j``, ``Decimal(0)``, ``Fraction(0, 1)``"

#: ../Doc/library/stdtypes.rst:60
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr ""
"cualquier colección o secuencia vacía: ``''``, ``()``, ``[]``, ``{}``, "
"``set()``, ``range(0)``"

#: ../Doc/library/stdtypes.rst:69
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"Las operaciones y funciones integradas que tienen como resultado un booleano "
"siempre retornan ``0`` o ``False`` para un valor falso, y ``1`` o ``True`` "
"para un valor verdadero, a no ser que se indique otra cosa. (Hay una "
"excepción importante: Las operaciones booleanas ``or`` y ``and`` siempre "
"retornan uno de los dos operadores.)"

#: ../Doc/library/stdtypes.rst:78
msgid "Boolean Operations --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"
msgstr ""
"Operaciones booleanas --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"

#: ../Doc/library/stdtypes.rst:82
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr ""
"Estas son las operaciones booleanas, ordenadas de menor a mayor prioridad:"

#: ../Doc/library/stdtypes.rst:85 ../Doc/library/stdtypes.rst:143
#: ../Doc/library/stdtypes.rst:275 ../Doc/library/stdtypes.rst:365
#: ../Doc/library/stdtypes.rst:415 ../Doc/library/stdtypes.rst:963
#: ../Doc/library/stdtypes.rst:1168
msgid "Operation"
msgstr "Operación"

#: ../Doc/library/stdtypes.rst:85 ../Doc/library/stdtypes.rst:275
#: ../Doc/library/stdtypes.rst:365 ../Doc/library/stdtypes.rst:415
#: ../Doc/library/stdtypes.rst:963 ../Doc/library/stdtypes.rst:1168
msgid "Result"
msgstr "Resultado"

#: ../Doc/library/stdtypes.rst:85 ../Doc/library/stdtypes.rst:275
#: ../Doc/library/stdtypes.rst:415 ../Doc/library/stdtypes.rst:963
#: ../Doc/library/stdtypes.rst:1168 ../Doc/library/stdtypes.rst:2418
#: ../Doc/library/stdtypes.rst:3636
msgid "Notes"
msgstr "Notas"

#: ../Doc/library/stdtypes.rst:87
msgid "``x or y``"
msgstr "``x or y``"

#: ../Doc/library/stdtypes.rst:87
#, fuzzy
msgid "if *x* is true, then *x*, else *y*"
msgstr "si *x* es falso, entonces *x*, si no, *y*"

#: ../Doc/library/stdtypes.rst:87 ../Doc/library/stdtypes.rst:965
#: ../Doc/library/stdtypes.rst:968 ../Doc/library/stdtypes.rst:1179
#: ../Doc/library/stdtypes.rst:2424 ../Doc/library/stdtypes.rst:3642
msgid "\\(1)"
msgstr "\\(1)"

#: ../Doc/library/stdtypes.rst:90
msgid "``x and y``"
msgstr "``x and y``"

#: ../Doc/library/stdtypes.rst:90
msgid "if *x* is false, then *x*, else *y*"
msgstr "si *x* es falso, entonces *x*, si no, *y*"

#: ../Doc/library/stdtypes.rst:90 ../Doc/library/stdtypes.rst:288
#: ../Doc/library/stdtypes.rst:308 ../Doc/library/stdtypes.rst:1207
#: ../Doc/library/stdtypes.rst:2428 ../Doc/library/stdtypes.rst:2430
#: ../Doc/library/stdtypes.rst:3646 ../Doc/library/stdtypes.rst:3648
msgid "\\(2)"
msgstr "\\(2)"

#: ../Doc/library/stdtypes.rst:93
msgid "``not x``"
msgstr "``not x``"

#: ../Doc/library/stdtypes.rst:93
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "si *x* es falso, entonces ``True``, si no, ``False``"

#: ../Doc/library/stdtypes.rst:93 ../Doc/library/stdtypes.rst:977
#: ../Doc/library/stdtypes.rst:1210 ../Doc/library/stdtypes.rst:2432
#: ../Doc/library/stdtypes.rst:2434 ../Doc/library/stdtypes.rst:2436
#: ../Doc/library/stdtypes.rst:2438 ../Doc/library/stdtypes.rst:3650
#: ../Doc/library/stdtypes.rst:3652 ../Doc/library/stdtypes.rst:3654
#: ../Doc/library/stdtypes.rst:3656
msgid "\\(3)"
msgstr "\\(3)"

#: ../Doc/library/stdtypes.rst:102 ../Doc/library/stdtypes.rst:319
#: ../Doc/library/stdtypes.rst:433 ../Doc/library/stdtypes.rst:1014
#: ../Doc/library/stdtypes.rst:1218 ../Doc/library/stdtypes.rst:2464
#: ../Doc/library/stdtypes.rst:3686
msgid "Notes:"
msgstr "Notas:"

#: ../Doc/library/stdtypes.rst:105
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr ""
"Este operador usa lógica cortocircuitada, por lo que solo evalúa el segundo "
"argumento si el primero es falso."

#: ../Doc/library/stdtypes.rst:109
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr ""
"Este operador usa lógica cortocircuitada, por lo que solo evalúa el segundo "
"argumento si el primero es verdadero."

#: ../Doc/library/stdtypes.rst:113
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"El operador ``not`` tiene menos prioridad que los operadores no booleanos, "
"así que ``not a == b`` se interpreta como ``not (a == b)``, y ``a == not b`` "
"es un error sintáctico."

#: ../Doc/library/stdtypes.rst:120
msgid "Comparisons"
msgstr "Comparaciones"

#: ../Doc/library/stdtypes.rst:134
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"Existen ocho operadores de comparación en Python. Todos comparten el mismo "
"nivel de prioridad (que es mayor que el nivel de las operaciones booleanas). "
"Las comparaciones pueden encadenarse de cualquier manera; por ejemplo, ``x < "
"y <= z`` equivale a ``x < y and y <= z``, excepto porque *y* solo se evalúa "
"una vez (no obstante, en ambos casos *z* no se evalúa si no es verdad que "
"``x < y``)."

#: ../Doc/library/stdtypes.rst:140
msgid "This table summarizes the comparison operations:"
msgstr "Esta tabla resume las operaciones de comparación:"

#: ../Doc/library/stdtypes.rst:143 ../Doc/library/stdtypes.rst:2395
#: ../Doc/library/stdtypes.rst:2418 ../Doc/library/stdtypes.rst:3613
#: ../Doc/library/stdtypes.rst:3636
msgid "Meaning"
msgstr "Significado"

#: ../Doc/library/stdtypes.rst:145
msgid "``<``"
msgstr "``<``"

#: ../Doc/library/stdtypes.rst:145
msgid "strictly less than"
msgstr "estrictamente menor que"

#: ../Doc/library/stdtypes.rst:147
msgid "``<=``"
msgstr "``<=``"

#: ../Doc/library/stdtypes.rst:147
msgid "less than or equal"
msgstr "menor o igual que"

#: ../Doc/library/stdtypes.rst:149
msgid "``>``"
msgstr "``>``"

#: ../Doc/library/stdtypes.rst:149
msgid "strictly greater than"
msgstr "estrictamente mayor que"

#: ../Doc/library/stdtypes.rst:151
msgid "``>=``"
msgstr "``>=``"

#: ../Doc/library/stdtypes.rst:151
msgid "greater than or equal"
msgstr "mayor o igual que"

#: ../Doc/library/stdtypes.rst:153
msgid "``==``"
msgstr "``==``"

#: ../Doc/library/stdtypes.rst:153
msgid "equal"
msgstr "igual que"

#: ../Doc/library/stdtypes.rst:155
msgid "``!=``"
msgstr "``!=``"

#: ../Doc/library/stdtypes.rst:155
msgid "not equal"
msgstr "diferente que"

#: ../Doc/library/stdtypes.rst:157
msgid "``is``"
msgstr "``is``"

#: ../Doc/library/stdtypes.rst:157
msgid "object identity"
msgstr "igualdad a nivel de identidad (Son el mismo objeto)"

#: ../Doc/library/stdtypes.rst:159
msgid "``is not``"
msgstr "``is not``"

#: ../Doc/library/stdtypes.rst:159
msgid "negated object identity"
msgstr "desigualdad a nivel de identidad (no son el mismo objeto)"

#: ../Doc/library/stdtypes.rst:166
msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. The ``==`` operator is always defined but for some object types (for "
"example, class objects) is equivalent to :keyword:`is`. The ``<``, ``<=``, "
"``>`` and ``>=`` operators are only defined where they make sense; for "
"example, they raise a :exc:`TypeError` exception when one of the arguments "
"is a complex number."
msgstr ""
"Nunca se comparan iguales los objetos que son de tipos diferentes, con la "
"excepción de los tipos numéricos. El operador ``==`` siempre está definido, "
"pero en algunos tipos de objetos (como por ejemplo, las clases) es "
"equivalente al operador :keyword:`is`. Los operadores ``<``, ``<=``, ``>`` y "
"``>=`` solo están definidos cuando tienen sentido; por ejemplo, si uno de "
"los operadores es un número complejo, la comparación lanzará una excepción "
"de tipo :exc:`TypeError`."

#: ../Doc/library/stdtypes.rst:180
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`~object.__eq__` method."
msgstr ""
"Las instancias de una clase que no son idénticas normalmente se comparan "
"como diferentes, a no ser que la clase defina el método :meth:`~object."
"__eq__`."

#: ../Doc/library/stdtypes.rst:183
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of "
"the methods :meth:`~object.__lt__`, :meth:`~object.__le__`, :meth:`~object."
"__gt__`, and :meth:`~object.__ge__` (in general, :meth:`~object.__lt__` and :"
"meth:`~object.__eq__` are sufficient, if you want the conventional meanings "
"of the comparison operators)."
msgstr ""
"Las instancias de una clase no pueden ordenarse con respecto a otras "
"instancias de la misma clase, ni con otro tipo de objetos, a no ser que la "
"clase defina suficientes métodos :meth:`~object.__lt__`, :meth:`~object."
"__le__`, :meth:`~object.__gt__` y :meth:`~object.__ge__` (en general, :meth:"
"`~object.__lt__` y :meth:`~object.__eq__` son suficientes, si solo necesitas "
"los significados convencionales de los operadores de comparación)."

#: ../Doc/library/stdtypes.rst:190
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ""
"El comportamiento de los operadores :keyword:`is` e :keyword:`is not` no se "
"puede personalizar; además, se pueden aplicar a dos objetos cualquiera y "
"nunca lanzar una excepción."

#: ../Doc/library/stdtypes.rst:198
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and :"
"keyword:`not in`, are supported by types that are :term:`iterable` or "
"implement the :meth:`__contains__` method."
msgstr ""
"Hay otras dos operaciones con la misma prioridad sintáctica: :keyword:`in` "
"y :keyword:`not in`, que son soportadas por aquellos tipos de datos que son "
"de tipo :term:`iterable` o que implementen el método :meth:`__contains__`."

#: ../Doc/library/stdtypes.rst:205
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "Tipos numéricos --- :class:`int`, :class:`float`, :class:`complex`"

#: ../Doc/library/stdtypes.rst:215
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating "
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating point "
"numbers are usually implemented using :c:expr:`double` in C; information "
"about the precision and internal representation of floating point numbers "
"for the machine on which your program is running is available in :data:`sys."
"float_info`.  Complex numbers have a real and imaginary part, which are each "
"a floating point number.  To extract these parts from a complex number *z*, "
"use ``z.real`` and ``z.imag``. (The standard library includes the additional "
"numeric types :mod:`fractions.Fraction`, for rationals, and :mod:`decimal."
"Decimal`, for floating-point numbers with user-definable precision.)"
msgstr ""
"Hay tres tipos numéricos distintos: :dfn:`integers`, :dfn:`floating point "
"numbers` y :dfn:`complex numbers`. Además, los booleanos son un subtipo de "
"los enteros. Los enteros tiene precisión ilimitada. Los números en coma "
"flotante se implementan normalmente usando el tipo :c:expr:`double` de C; "
"hay más información sobre la precisión y la representación interna de los "
"números en coma flotante usadas por la máquina sobre la que se ejecuta tu "
"programa en :data:`sys.float_info`. Los números complejos tienen una parte "
"real y otra imaginaria, ambas representadas con números en coma flotante. "
"Para extraer estas partes del número complejo *z* se usan los métodos ``z."
"real`` y ``z.imag``. (La librería estándar incluye tipos numéricos "
"adicionales: :mod:`fractions.Fraction` para números racionales y :mod:"
"`decimal.Decimal` para números en coma flotante con precisión definida por "
"el usuario.)"

#: ../Doc/library/stdtypes.rst:237
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number "
"with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""
"Los números se crean a partir de literales numéricos, o como resultado de "
"una combinación de funciones integradas y operadores. Expresiones literales "
"de números (incluyendo números expresados en hexadecimal, octal o binario) "
"producen enteros. Si la expresión literal contiene un punto decimal o un "
"signo de exponente, se genera un número en coma flotante. Si se añade como "
"sufijo una ``'j'`` o una ``'J'`` a un literal numérico, se genera un número "
"imaginario puro (un número complejo con la parte real a cero), que se puede "
"sumar a un número entero o de coma flotante para obtener un número complejo "
"con parte real e imaginaria."

#: ../Doc/library/stdtypes.rst:262
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point, which is narrower than complex. A comparison between numbers "
"of different types behaves as though the exact values of those numbers were "
"being compared. [2]_"
msgstr ""
"Python soporta completamente una aritmética mixta: cuando un operador "
"binario de tipo aritmético se encuentra con que los operandos son de tipos "
"numéricos diferentes, el operando con el tipo de dato más \"estrecho\" o "
"restrictivo se convierte o amplía hasta el nivel del otro operando, donde el "
"número entero es más estrecho que el coma flotante, que es más estrecho que "
"el número complejo. Las comparaciones entre números de diferentes tipos se "
"comportan como si se compararan los valores exactos de estos. [2]_"

#: ../Doc/library/stdtypes.rst:268
msgid ""
"The constructors :func:`int`, :func:`float`, and :func:`complex` can be used "
"to produce numbers of a specific type."
msgstr ""
"Las funciones constructoras :func:`int`, :func:`float` y :func:`complex` se "
"pueden usar para generar números de cada tipo determinado."

#: ../Doc/library/stdtypes.rst:271
msgid ""
"All numeric types (except complex) support the following operations (for "
"priorities of the operations, see :ref:`operator-summary`):"
msgstr ""
"Todos los tipos numéricos (menos los complejos) soportan las siguientes "
"operaciones (para las prioridades de las operaciones, véase :ref:`operator-"
"summary`):"

#: ../Doc/library/stdtypes.rst:275
msgid "Full documentation"
msgstr "Documentación completa"

#: ../Doc/library/stdtypes.rst:277
msgid "``x + y``"
msgstr "``x + y``"

#: ../Doc/library/stdtypes.rst:277
msgid "sum of *x* and *y*"
msgstr "suma de *x* e *y*"

#: ../Doc/library/stdtypes.rst:279
msgid "``x - y``"
msgstr "``x - y``"

#: ../Doc/library/stdtypes.rst:279
msgid "difference of *x* and *y*"
msgstr "resta de *x* e *y*"

#: ../Doc/library/stdtypes.rst:281
msgid "``x * y``"
msgstr "``x * y``"

#: ../Doc/library/stdtypes.rst:281
msgid "product of *x* and *y*"
msgstr "multiplicación de *x* por *y*"

#: ../Doc/library/stdtypes.rst:283
msgid "``x / y``"
msgstr "``x / y``"

#: ../Doc/library/stdtypes.rst:283
msgid "quotient of *x* and *y*"
msgstr "división de *x* entre *y*"

#: ../Doc/library/stdtypes.rst:285
msgid "``x // y``"
msgstr "``x // y``"

#: ../Doc/library/stdtypes.rst:285
msgid "floored quotient of *x* and *y*"
msgstr "división entera a la baja de *x* entre *y*"

#: ../Doc/library/stdtypes.rst:285
#, fuzzy
msgid "\\(1)\\(2)"
msgstr "(1)(2)"

#: ../Doc/library/stdtypes.rst:288
msgid "``x % y``"
msgstr "``x % y``"

#: ../Doc/library/stdtypes.rst:288
msgid "remainder of ``x / y``"
msgstr "resto o residuo de ``x / y``"

#: ../Doc/library/stdtypes.rst:290
msgid "``-x``"
msgstr "``-x``"

#: ../Doc/library/stdtypes.rst:290
msgid "*x* negated"
msgstr "valor de *x*, negado"

#: ../Doc/library/stdtypes.rst:292
msgid "``+x``"
msgstr "``+x``"

#: ../Doc/library/stdtypes.rst:292
msgid "*x* unchanged"
msgstr "valor de *x*, sin cambiar"

#: ../Doc/library/stdtypes.rst:294
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../Doc/library/stdtypes.rst:294
msgid "absolute value or magnitude of *x*"
msgstr "valor absoluto de la magnitud de *x*"

#: ../Doc/library/stdtypes.rst:294
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../Doc/library/stdtypes.rst:297
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../Doc/library/stdtypes.rst:297
msgid "*x* converted to integer"
msgstr "valor de *x* convertido a entero"

#: ../Doc/library/stdtypes.rst:297
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: ../Doc/library/stdtypes.rst:297
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../Doc/library/stdtypes.rst:299
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../Doc/library/stdtypes.rst:299
msgid "*x* converted to floating point"
msgstr "valor de *x* convertido a número de coma flotante"

#: ../Doc/library/stdtypes.rst:299
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: ../Doc/library/stdtypes.rst:299
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../Doc/library/stdtypes.rst:301
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: ../Doc/library/stdtypes.rst:301
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""
"un número complejo, con parte real *re* y parte imaginaria *im*. El valor de "
"*im* por defecto vale cero."

#: ../Doc/library/stdtypes.rst:301 ../Doc/library/stdtypes.rst:1200
#: ../Doc/library/stdtypes.rst:2426 ../Doc/library/stdtypes.rst:3673
msgid "\\(6)"
msgstr "\\(6)"

#: ../Doc/library/stdtypes.rst:301
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../Doc/library/stdtypes.rst:305
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: ../Doc/library/stdtypes.rst:305
msgid "conjugate of the complex number *c*"
msgstr "conjugado del número complejo *c*"

#: ../Doc/library/stdtypes.rst:308
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../Doc/library/stdtypes.rst:308
msgid "the pair ``(x // y, x % y)``"
msgstr "el par de valores ``(x // y, x % y)``"

#: ../Doc/library/stdtypes.rst:308
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../Doc/library/stdtypes.rst:310
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../Doc/library/stdtypes.rst:310 ../Doc/library/stdtypes.rst:312
msgid "*x* to the power *y*"
msgstr "*x* elevado a *y*"

#: ../Doc/library/stdtypes.rst:310 ../Doc/library/stdtypes.rst:312
#: ../Doc/library/stdtypes.rst:1189 ../Doc/library/stdtypes.rst:1192
#: ../Doc/library/stdtypes.rst:2451 ../Doc/library/stdtypes.rst:2454
#: ../Doc/library/stdtypes.rst:2457 ../Doc/library/stdtypes.rst:3669
#: ../Doc/library/stdtypes.rst:3676
msgid "\\(5)"
msgstr "\\(5)"

#: ../Doc/library/stdtypes.rst:310
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../Doc/library/stdtypes.rst:312
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../Doc/library/stdtypes.rst:322
msgid ""
"Also referred to as integer division.  For operands of type :class:`int`, "
"the result has type :class:`int`.  For operands of type :class:`float`, the "
"result has type :class:`float`.  In general, the result is a whole integer, "
"though the result's type is not necessarily :class:`int`.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"También conocida como división entera a la baja. Para operandos de tipo :"
"class:`int`, el resultado será de tipo :class:`int`. Para operandos de tipo :"
"class:`float`, el resultado será de tipo :class:`float`. En general, el "
"resultado es un número entero en el sentido matemático, pero no "
"necesariamente de tipo entero :class:`int`. El resultado se redondea de "
"forma automática hacia menos infinito: ``1//2`` es ``0``, ``(-1)//2`` es "
"``-1``, ``1//(-2)`` es ``-1`` y ``(-1)//(-2)`` es ``0``."

#: ../Doc/library/stdtypes.rst:330
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr ""
"No es apropiada para números complejos. Es preferible convertir a valores en "
"coma flotante usando la función :func:`abs` si fuera apropiado."

#: ../Doc/library/stdtypes.rst:341
#, fuzzy
msgid ""
"Conversion from :class:`float` to :class:`int` truncates, discarding the "
"fractional part. See functions :func:`math.floor` and :func:`math.ceil` for "
"alternative conversions."
msgstr ""
"Conversiones desde coma flotante a entero pueden redondearse o truncarse "
"como en C; véanse las funciones :func:`math.floor` y :func:`math.ceil` para "
"un mayor control."

#: ../Doc/library/stdtypes.rst:346
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"float también acepta las cadenas de caracteres \"*nan*\" e \"*inf*\", con un "
"prefijo opcional \"+\" o \"-\", para los valores *Not a Number* (*NaN*) e "
"infinito positivo o negativo."

#: ../Doc/library/stdtypes.rst:350
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"Python define ``pow(0, 0)`` y ``0 ** 0`` para que valgan ``1``, como es "
"práctica habitual en los lenguajes de programación."

#: ../Doc/library/stdtypes.rst:354
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr ""
"Los literales numéricos aceptables incluyen los dígitos desde el ``0`` hasta "
"el ``9``, así como cualquier carácter Unicode equivalente (puntos de código "
"con la propiedad ``Nd``)."

#: ../Doc/library/stdtypes.rst:357
#, fuzzy
msgid ""
"See `the Unicode Standard <https://unicode.org/Public/UNIDATA/extracted/"
"DerivedNumericType.txt>`_ for a complete list of code points with the ``Nd`` "
"property."
msgstr ""
"Véase https://www.unicode.org/Public/14.0.0/ucd/extracted/DerivedNumericType."
"txt para una lista completa de los puntos de código con la propiedad ``Nd``."

#: ../Doc/library/stdtypes.rst:361
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr ""
"Todas las clases derivadas de :class:`numbers.Real` (:class:`int` y :class:"
"`float`) también soportan las siguientes operaciones:"

#: ../Doc/library/stdtypes.rst:367
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: ../Doc/library/stdtypes.rst:367
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* truncado a :class:`~numbers.Integral`"

#: ../Doc/library/stdtypes.rst:370
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: ../Doc/library/stdtypes.rst:370
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr ""
"El valor de *x* redondeado a *n* dígitos, redondeando la mitad al número par "
"más cercano (redondeo del banquero). Si no se especifica valor para *n*, se "
"asume 0."

#: ../Doc/library/stdtypes.rst:374
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: ../Doc/library/stdtypes.rst:374
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "el mayor número :class:`~numbers.Integral` que sea <= *x*"

#: ../Doc/library/stdtypes.rst:377
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../Doc/library/stdtypes.rst:377
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "el menor número :class:`~numbers.Integral` que sea >= *x*"

#: ../Doc/library/stdtypes.rst:381
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr ""
"Para más operaciones numéricas consulta los módulos :mod:`math` y :mod:"
"`cmath`."

#: ../Doc/library/stdtypes.rst:390
msgid "Bitwise Operations on Integer Types"
msgstr "Operaciones de bits en números enteros"

#: ../Doc/library/stdtypes.rst:404
msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr ""
"Las operaciones a nivel de bit solo tienen sentido con números enteros. El "
"resultado de una de estas operaciones se calcula como si se hubiera "
"realizado en una representación en complemento a dos que tuviera un número "
"infinito de bits de signo."

#: ../Doc/library/stdtypes.rst:408
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr ""
"La prioridad de todas las operaciones de bits son menores que las "
"operaciones numéricas, pero mayores que las comparaciones; la operación "
"unaria ``~`` tiene la misma prioridad que las otras operaciones unarias "
"numéricas (``+`` y ``-``)."

#: ../Doc/library/stdtypes.rst:412
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr ""
"Esta tabla lista las operaciones de bits, ordenadas de menor a mayor "
"prioridad:"

#: ../Doc/library/stdtypes.rst:417
msgid "``x | y``"
msgstr "``x | y``"

#: ../Doc/library/stdtypes.rst:417
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "la operación :dfn:`or` entre *x* e *y*"

#: ../Doc/library/stdtypes.rst:417 ../Doc/library/stdtypes.rst:420
#: ../Doc/library/stdtypes.rst:423 ../Doc/library/stdtypes.rst:1213
#: ../Doc/library/stdtypes.rst:2440 ../Doc/library/stdtypes.rst:2444
#: ../Doc/library/stdtypes.rst:3658 ../Doc/library/stdtypes.rst:3662
msgid "\\(4)"
msgstr "\\(4)"

#: ../Doc/library/stdtypes.rst:420
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../Doc/library/stdtypes.rst:420
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "la operación :dfn:`exclusive or` entre *x* e *y*"

#: ../Doc/library/stdtypes.rst:423
msgid "``x & y``"
msgstr "``x & y``"

#: ../Doc/library/stdtypes.rst:423
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "la operación :dfn:`and` entre *x* e *y*"

#: ../Doc/library/stdtypes.rst:426
msgid "``x << n``"
msgstr "``x << n``"

#: ../Doc/library/stdtypes.rst:426
msgid "*x* shifted left by *n* bits"
msgstr "valor de *x* desplazado a la izquierda *n* bits"

#: ../Doc/library/stdtypes.rst:426
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../Doc/library/stdtypes.rst:428
msgid "``x >> n``"
msgstr "``x >> n``"

#: ../Doc/library/stdtypes.rst:428
msgid "*x* shifted right by *n* bits"
msgstr "valor de *x* desplazado a la derecha *n* bits"

#: ../Doc/library/stdtypes.rst:428
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../Doc/library/stdtypes.rst:430
msgid "``~x``"
msgstr "``~x``"

#: ../Doc/library/stdtypes.rst:430
msgid "the bits of *x* inverted"
msgstr "invierte los bits de *x*"

#: ../Doc/library/stdtypes.rst:436
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr ""
"Los desplazamientos negativos son ilegales y lanzarán una excepción de tipo :"
"exc:`ValueError`."

#: ../Doc/library/stdtypes.rst:439
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``."
msgstr ""
"Un desplazamiento de *n* bits a la izquierda es equivalente a multiplicar "
"por ``pow(2, n)``."

#: ../Doc/library/stdtypes.rst:442
msgid ""
"A right shift by *n* bits is equivalent to floor division by ``pow(2, n)``."
msgstr ""
"Un desplazamiento de *n* bits a la derecha es equivalente a efectuar la "
"división entera a la baja entre ``pow(2, n)``."

#: ../Doc/library/stdtypes.rst:445
msgid ""
"Performing these calculations with at least one extra sign extension bit in "
"a finite two's complement representation (a working bit-width of ``1 + max(x."
"bit_length(), y.bit_length())`` or more) is sufficient to get the same "
"result as if there were an infinite number of sign bits."
msgstr ""
"Realizar estos cálculos con al menos un bit extra de signo en una "
"representación finita de un número en complemento a dos (un ancho de bits de "
"trabajo de ``1 + max(x.bit_length(), y.bit_length())`` o más) es suficiente "
"para obtener el mismo resultado que si se hubiera realizado con un número "
"infinito de bits de signo."

#: ../Doc/library/stdtypes.rst:452
msgid "Additional Methods on Integer Types"
msgstr "Métodos adicionales de los enteros"

#: ../Doc/library/stdtypes.rst:454
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"El tipo int implementa la :term:`clase base abstracta` :class:`numbers."
"Integral`. Además, proporciona los siguientes métodos:"

#: ../Doc/library/stdtypes.rst:459
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr ""
"Retorna el número de bits necesarios para representar un número entero, "
"excluyendo el bit de signo y los ceros a la izquierda::"

#: ../Doc/library/stdtypes.rst:468
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x."
"bit_length()`` returns ``0``."
msgstr ""
"De forma más precisa, si ``x`` es distinto de cero, entonces ``x."
"bit_length()`` es el único número entero positivo ``k`` tal que ``2**(k-1) "
"<= abs(x) < 2**k``. De igual manera, cuando ``abs(x)`` es lo suficientemente "
"pequeño para tener un logaritmo redondeado correctamente, entonces ``k = 1 + "
"int(log(abs(x), 2))``. Si ``x`` es cero, entonces ``x.bit_length()`` retorna "
"``0``."

#: ../Doc/library/stdtypes.rst:474 ../Doc/library/stdtypes.rst:497
#: ../Doc/library/stdtypes.rst:542 ../Doc/library/stdtypes.rst:586
msgid "Equivalent to::"
msgstr "Equivale a::"

#: ../Doc/library/stdtypes.rst:485
msgid ""
"Return the number of ones in the binary representation of the absolute value "
"of the integer. This is also known as the population count. Example::"
msgstr ""
"Retorna el número de unos en la representación binaria del valor absoluto "
"del entero. Esto también se conoce como el recuento de la población. "
"Ejemplo::"

#: ../Doc/library/stdtypes.rst:506
msgid "Return an array of bytes representing an integer."
msgstr "Retorna un arreglo de bytes que representan el número entero."

#: ../Doc/library/stdtypes.rst:518
msgid ""
"The integer is represented using *length* bytes, and defaults to 1.  An :exc:"
"`OverflowError` is raised if the integer is not representable with the given "
"number of bytes."
msgstr ""
"El número entero se representa usando el número de bits indicados con "
"*length* y el valor predeterminado es 1. Se lanzará la excepción :exc:"
"`OverflowError` si no se puede representar el entero con ese número de bits."

#: ../Doc/library/stdtypes.rst:522
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder* "
"is ``\"little\"``, the most significant byte is at the end of the byte array."
msgstr ""
"El argumento *byteorder* determina el orden de representación del número "
"entero y el valor predeterminado es ``\"big\"``. Si *byteorder* es "
"``\"big\"``, el byte más significativo ocupa la primera posición del arreglo "
"del byte. Si *byteorder* es ``\"little\"``, el byte más significativo estará "
"en la última posición."

#: ../Doc/library/stdtypes.rst:528
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"El parámetro *signed* determina si se usa el complemento a dos para "
"representar los números enteros. Si *signed* es ``False``, y se usa un valor "
"entero negativo, se lanzará la excepción :exc:`OverflowError`. El valor por "
"defecto para *signed* es ``False``."

#: ../Doc/library/stdtypes.rst:533
msgid ""
"The default values can be used to conveniently turn an integer into a single "
"byte object::"
msgstr ""

#: ../Doc/library/stdtypes.rst:539
#, fuzzy
msgid ""
"However, when using the default arguments, don't try to convert a value "
"greater than 255 or you'll get an :exc:`OverflowError`."
msgstr ""
"Los valores por defecto se pueden usar para convertir convenientemente un "
"número entero en un objeto de un solo byte. Sim embargo, cuando utilices los "
"argumentos predeterminados, no intentes convertir un valor mayor a 255 u "
"obtendrás una excepción :exc:`OverflowError`::"

#: ../Doc/library/stdtypes.rst:555
msgid "Added default argument values for ``length`` and ``byteorder``."
msgstr ""
"Se agregaron valores de argumentos predeterminados para ``length`` y "
"``byteorder``."

#: ../Doc/library/stdtypes.rst:560
msgid "Return the integer represented by the given array of bytes."
msgstr "Retorna el número entero que se representa por el arreglo de bytes."

#: ../Doc/library/stdtypes.rst:573
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr ""
"El argumento *bytes* debe ser o bien un :term:`objeto tipo binario <bytes-"
"like object>` o un iterable que produzca bytes."

#: ../Doc/library/stdtypes.rst:576
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder* "
"is ``\"little\"``, the most significant byte is at the end of the byte "
"array.  To request the native byte order of the host system, use :data:`sys."
"byteorder` as the byte order value."
msgstr ""
"El argumento *byteorder* determina el orden de representación del número "
"entero y el valor predeterminado es ``\"big\"``. Si *byteorder* es "
"``\"big\"``, el byte más significativo ocupa la primera posición en el "
"arreglo del byte. Si *byteorder* es ``\"little\"``, el byte más "
"significativo estará en la última posición. Para solicitar el orden de bytes "
"nativo del sistema host, usa :data:`sys.byteorder` como valor de orden de "
"bytes."

#: ../Doc/library/stdtypes.rst:583
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr ""
"El argumento *signed* indica si se representará el número entero usando "
"complemento a dos."

#: ../Doc/library/stdtypes.rst:603
msgid "Added default argument value for ``byteorder``."
msgstr "Se agregó valor de argumento predeterminado para ``byteorder``."

#: ../Doc/library/stdtypes.rst:608
#, fuzzy
msgid ""
"Return a pair of integers whose ratio is equal to the original integer and "
"has a positive denominator.  The integer ratio of integers (whole numbers) "
"is always the integer as the numerator and ``1`` as the denominator."
msgstr ""
"Retorna una pareja de números enteros cuya proporción es igual a la del "
"numero entero original, y con un denominador positivo. En el caso de números "
"enteros, la proporción siempre es el entero en el numerador y ``1`` en el "
"denominador."

#: ../Doc/library/stdtypes.rst:617
msgid ""
"Returns ``True``. Exists for duck type compatibility with :meth:`float."
"is_integer`."
msgstr ""

#: ../Doc/library/stdtypes.rst:622
msgid "Additional Methods on Float"
msgstr "Métodos adicionales de float"

# Verificar que el glosario el termino aparezca como clase base abstracta
#: ../Doc/library/stdtypes.rst:624
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"El tipo float implementa la :term:`clase base abstracta` :class:`numbers."
"Real`. Los números float tienen además los siguientes métodos."

#: ../Doc/library/stdtypes.rst:629
#, fuzzy
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original "
"float. The ratio is in lowest terms and has a positive denominator.  Raises :"
"exc:`OverflowError` on infinities and a :exc:`ValueError` on NaNs."
msgstr ""
"Retorna una pareja de números enteros cuya proporción es exactamente igual "
"que la del valor en punto flotante original, con un denominador positivo. Si "
"se llama con valores infinitos lanza una excepción de tipo :exc:"
"`OverflowError` y si se llama con *NaN* (*Not A Number*) lanza una excepción "
"de tipo :exc:`ValueError`."

#: ../Doc/library/stdtypes.rst:636
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""
"Retorna ``True`` si el valor en coma flotante es finita con valor integral, "
"y ``False`` en caso contrario::"

#: ../Doc/library/stdtypes.rst:644
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"Hay dos métodos que convierten desde y hacia cadenas de caracteres en "
"hexadecimal. Como los valores en coma flotante en Python se almacenan "
"internamente en binario, las conversiones desde o hacia cadenas *decimales* "
"pueden implicar un pequeño error de redondeo. Pero con cadenas de caracteres "
"en hexadecimal, las cadenas se corresponden y permiten representar de forma "
"exacta los números en coma flotante. Esto puede ser útil, ya sea a la hora "
"de depurar errores, o en procesos numéricos."

#: ../Doc/library/stdtypes.rst:655
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"Retorna la representación de un valor en coma flotante en forma de cadena de "
"caracteres en hexadecimal. Para números finitos, la representación siempre "
"empieza con el prefijo ``0x``, y con una ``p`` justo antes del exponente."

#: ../Doc/library/stdtypes.rst:663
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""
"Método de clase que retorna el valor en coma flotante que se representa por "
"la cadena de caracteres en hexadecimal *s*. La cadena de caracteres *s* "
"puede tener espacios en blanco al principio o al final."

#: ../Doc/library/stdtypes.rst:668
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr ""
"Nótese que :meth:`float.hex` es un método de instancia, mientras que :meth:"
"`float.fromhex` es un método de clase."

#: ../Doc/library/stdtypes.rst:671
msgid "A hexadecimal string takes the form::"
msgstr "Una cadena de caracteres en hexadecimal sigue este formato::"

#: ../Doc/library/stdtypes.rst:675
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""
"donde el componente opcional ``sign`` puede ser o bien ``+`` o ``-``, las "
"componentes ``integer`` y ``fraction`` son cadenas de caracteres que solo "
"usan dígitos hexadecimales, y ``exponent`` es un número decimal, precedido "
"con un signo opcional. No se distingue entre mayúsculas y minúsculas, y debe "
"haber al menos un dígito hexadecimal tanto en la parte entera como en la "
"fracción. Esta sintaxis es similar a la sintaxis especificada en la sección "
"6.4.4.2 del estándar C99, y es también la sintaxis usada en Java desde la "
"versión 1.5. En particular, la salida de :meth:`float.hex` se puede usar "
"como una cadena de caracteres en hexadecimal en código C o Java, y las "
"cadenas de caracteres hexadecimal producidas por el carácter de formato "
"``%a`` en C, o por el método Java, ``Double.toHexString``, son aceptadas "
"por :meth:`float.fromhex`."

#: ../Doc/library/stdtypes.rst:688
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"Nótese que el valor del exponente se expresa en decimal, no en hexadecimal, "
"e indica la potencia de 2 por la que debemos multiplicar el coeficiente. Por "
"ejemplo, la cadena de caracteres hexadecimal ``0x3.a7p10`` representa el "
"número en coma flotante ``(3 + 10./16 + 7./16**2) * 2.0**10``, o ``3740.0``::"

#: ../Doc/library/stdtypes.rst:698
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""
"Si aplicamos la operación inversa a ``3740.0`` retorna una cadena de "
"caracteres hexadecimal diferente que, aun así, representa el mismo número::"

#: ../Doc/library/stdtypes.rst:708
msgid "Hashing of numeric types"
msgstr "Calculo del *hash* de tipos numéricos"

#: ../Doc/library/stdtypes.rst:710
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement "
"that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`~object."
"__hash__` method documentation for more details).  For ease of "
"implementation and efficiency across a variety of numeric types (including :"
"class:`int`, :class:`float`, :class:`decimal.Decimal` and :class:`fractions."
"Fraction`) Python's hash for numeric types is based on a single mathematical "
"function that's defined for any rational number, and hence applies to all "
"instances of :class:`int` and :class:`fractions.Fraction`, and all finite "
"instances of :class:`float` and :class:`decimal.Decimal`.  Essentially, this "
"function is given by reduction modulo ``P`` for a fixed prime ``P``.  The "
"value of ``P`` is made available to Python as the :attr:`modulus` attribute "
"of :data:`sys.hash_info`."
msgstr ""
"Para dos números ``x`` e ``y``, posiblemente de tipos diferentes, se "
"requiere que ``hash(x) == hash(y)`` sea verdadero siempre que ``x == y`` "
"(véase la documentación sobre el método :meth:`~object.__hash__` para más "
"detalles). Por razones tanto de eficiencia como de facilidad de "
"implementación entre los tipos numéricos diferentes (incluyendo :class:"
"`int`, :class:`float`, :class:`decimal.Decimal` y :class:`fractions."
"Fraction`), el método de *hash* de Python se basa en una función matemática "
"sencilla que está definida para cualquier número racional, con lo cual se "
"puede aplicar a todas las instancias de :class:`int` y :class:`fractions."
"Fraction`, y a todas las instancias finitas de :class:`float` y :class:"
"`decimal.Decimal`. En esencia, lo que hace esta función es una reducción "
"módulo ``P`` para un valor fijo del número primo ``P``. El valor de ``P`` "
"está disponible en Python como atributo de :data:`sys.hash_info` con el "
"nombre de :attr:`modulus`."

#: ../Doc/library/stdtypes.rst:725
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"Actualmente, el número primo usado es ``P = 2**31 - 1`` para máquinas de 32 "
"bits, y ``P = 2**61 - 1`` en máquinas de 64 bits."

#: ../Doc/library/stdtypes.rst:728
msgid "Here are the rules in detail:"
msgstr "Aquí están las reglas en detalle:"

#: ../Doc/library/stdtypes.rst:730
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible "
"by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n, "
"P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"Si ``x = m / n`` es un número racional no negativo y ``n`` no es divisible "
"por ``P``, se define ``hash(x)`` como ``m * invmod(n, P) % P``, donde "
"``invmod(n, P)`` retorna la inversa de ``n`` módulo ``P``."

#: ../Doc/library/stdtypes.rst:734
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule "
"above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"Si ``x = m / n`` es un número racional no negativo y ``n`` es divisible por "
"``P`` (pero no así ``m``), entonces ``n`` no tiene módulo inverso de ``P`` y "
"no se puede aplicar la regla anterior; en este caso, ``hash(x)`` retorna el "
"valor constante definido en ``sys.hash_info.inf``."

#: ../Doc/library/stdtypes.rst:739
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as ``-"
"hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"Si ``x = m / n`` es un número racional negativo se define ``hash(x)`` como "
"``-hash(-x)``. Si el resultado fuera ``-1``, lo cambia por ``-2``."

#: ../Doc/library/stdtypes.rst:743
msgid ""
"The particular values ``sys.hash_info.inf`` and ``-sys.hash_info.inf`` are "
"used as hash values for positive infinity or negative infinity "
"(respectively)."
msgstr ""
"Los valores concretos ``sys.hash_info.inf`` y ``-sys.hash_info.inf`` se usan "
"como valores *hash* para infinito positivo o infinito negativo "
"(respectivamente)."

#: ../Doc/library/stdtypes.rst:747
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + sys.hash_info."
"imag * hash(z.imag)``, reduced modulo ``2**sys.hash_info.width`` so that it "
"lies in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"Para un número complejo ``z`` (una instancia de la clase :class:`complex`), "
"el valor de *hash* se calcula combinando los valores de *hash* de la parte "
"real e imaginaria, usando la fórmula ``hash(z.real) + sys.hash_info.imag * "
"hash(z.imag)``, módulo reducido ``2**sys.hash_info.width``, de forma que el "
"valor obtenido esté en rango ``range(-2**(sys.hash_info.width - 1), 2**(sys."
"hash_info.width - 1))``. De nuevo, si el resultado fuera ``-1``, se "
"reemplaza por ``-2``."

#: ../Doc/library/stdtypes.rst:755
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, :class:"
"`float`, or :class:`complex`::"
msgstr ""
"Para clarificar las reglas previas, aquí mostramos un ejemplo de código "
"Python, equivalente al cálculo realizado en la función *hash*, para calcular "
"el *hash* de un número racional de tipo :class:`float` o :class:`complex`::"

#: ../Doc/library/stdtypes.rst:810
#, fuzzy
msgid "Boolean Type - :class:`bool`"
msgstr "Tipos mapa --- :class:`dict`"

#: ../Doc/library/stdtypes.rst:812
msgid ""
"Booleans represent truth values. The :class:`bool` type has exactly two "
"constant instances: ``True`` and ``False``."
msgstr ""

#: ../Doc/library/stdtypes.rst:820
msgid ""
"The built-in function :func:`bool`  converts any value to a boolean, if the "
"value can be interpreted as a truth value (see section :ref:`truth` above)."
msgstr ""

#: ../Doc/library/stdtypes.rst:823
msgid ""
"For logical operations, use the :ref:`boolean operators <boolean>` ``and``, "
"``or`` and ``not``. When applying the bitwise operators ``&``, ``|``, ``^`` "
"to two booleans, they return a bool equivalent to the logical operations "
"\"and\", \"or\", \"xor\". However, the logical operators ``and``, ``or`` and "
"``!=`` should be preferred over ``&``, ``|`` and ``^``."
msgstr ""

#: ../Doc/library/stdtypes.rst:832
msgid ""
"The use of the bitwise inversion operator ``~`` is deprecated and will raise "
"an error in Python 3.14."
msgstr ""

#: ../Doc/library/stdtypes.rst:835
msgid ""
":class:`bool` is a subclass of :class:`int` (see :ref:`typesnumeric`). In "
"many numeric contexts, ``False`` and ``True`` behave like the integers 0 and "
"1, respectively. However, relying on this is discouraged; explicitly convert "
"using :func:`int` instead."
msgstr ""

#: ../Doc/library/stdtypes.rst:843
msgid "Iterator Types"
msgstr "Tipos de iteradores"

#: ../Doc/library/stdtypes.rst:851
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"Python soporta el concepto de iteradores sobre contenedores. Esto se "
"implementa usando dos métodos diferentes: Estos son usados por las clases "
"definidas por el usuario para soportar iteración. Las secuencias, que se "
"describirán con mayor detalle, siempre soportan la iteración."

#: ../Doc/library/stdtypes.rst:856
msgid ""
"One method needs to be defined for container objects to provide :term:"
"`iterable` support:"
msgstr ""
"Es necesario definir un método para que los objetos contenedores "
"proporcionen compatibilidad :term:`iterable`:"

# Como traducimos slot?
#: ../Doc/library/stdtypes.rst:863
msgid ""
"Return an :term:`iterator` object.  The object is required to support the "
"iterator protocol described below.  If a container supports different types "
"of iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects "
"in the Python/C API."
msgstr ""
"Retorna un objeto :term:`iterator`. Este objeto es requerido para soportar "
"el protocolo de iteración que se describe a continuación. Si un contenedor "
"soporta diferentes tipos de iteración, se pueden implementar métodos "
"adicionales para estos iteradores. (Por ejemplo, un tipo de contenedor que "
"puede soportar distintas formas de iteración podría ser una estructura de "
"tipo árbol que proporcione a la vez un recorrido en profundidad o en "
"anchura). Este método se corresponde al *slot* :c:member:`~PyTypeObject."
"tp_iter` de la estructura usada para los objetos Python en la API Python/C."

#: ../Doc/library/stdtypes.rst:872
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"Los objetos iteradores en si necesitan definir los siguientes dos métodos, "
"que forma juntos el :dfn:`iterator protocol`:"

#: ../Doc/library/stdtypes.rst:878
msgid ""
"Return the :term:`iterator` object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements.  This method corresponds to the :c:member:`~PyTypeObject."
"tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""
"Retorna el propio objeto :term:`iterator`. Este método es necesario para "
"permitir tanto a los contenedores como a los iteradores usar la palabras "
"clave :keyword:`for` o :keyword:`in`. Este método se corresponde con el "
"*slot* :c:member:`~PyTypeObject.tp_iter` de la estructura usada para los "
"objetos Python en la API Python/C."

#: ../Doc/library/stdtypes.rst:887
msgid ""
"Return the next item from the :term:`iterator`.  If there are no further "
"items, raise the :exc:`StopIteration` exception.  This method corresponds to "
"the :c:member:`~PyTypeObject.tp_iternext` slot of the type structure for "
"Python objects in the Python/C API."
msgstr ""
"Retorna el siguiente elemento del :term:`iterator`. Si no hubiera más "
"elementos, lanza la excepción :exc:`StopIteration`. Este método se "
"corresponde con el *slot* :c:member:`~PyTypeObject.tp_iternext` de la "
"estructura usada para los objetos Python en la API Python/C."

#: ../Doc/library/stdtypes.rst:892
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr ""
"Python define varios objetos iteradores que permiten iterar sobre las "
"secuencias, ya sean generales o específicas, diccionarios y otras "
"estructuras de datos especializadas. Los tipos específicos no son tan "
"importantes como la implementación del protocolo iterador."

#: ../Doc/library/stdtypes.rst:897
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises :exc:"
"`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"Una vez que la ejecución del método :meth:`~iterator.__next__` lanza la "
"excepción :exc:`StopIteration`, debe continuar haciéndolo en subsiguientes "
"llamadas al método. Si una implementación no cumple esto, se considera rota."

#: ../Doc/library/stdtypes.rst:905
msgid "Generator Types"
msgstr "Tipos generador"

#: ../Doc/library/stdtypes.rst:907
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator object "
"(technically, a generator object) supplying the :meth:`__iter__` and :meth:"
"`~generator.__next__` methods. More information about generators can be "
"found in :ref:`the documentation for the yield expression <yieldexpr>`."
msgstr ""
"Los :term:`generator` de Python proporcionan una manera cómoda de "
"implementar el protocolo iterador. Si un objeto de tipo contenedor "
"implementa el método :meth:`__iter__` como un generador, de forma automática "
"este retornará un objeto iterador (técnicamente, un objeto generador) que "
"implementa los métodos :meth:`__iter__` y :meth:`~generator.__next__`. Se "
"puede obtener más información acerca de los generadores en :ref:`la "
"documentación de la expresión yield <yieldexpr>`."

#: ../Doc/library/stdtypes.rst:919
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr "Tipos secuencia --- :class:`list`, :class:`tuple`, :class:`range`"

#: ../Doc/library/stdtypes.rst:921
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""
"Hay tres tipos básicos de secuencia: listas, tuplas y objetos de tipo rango. "
"Existen tipos de secuencia especiales usados para el procesado de :ref:"
"`datos binarios <binaryseq>` y :ref:`cadenas de caracteres <textseq>` que se "
"describirán en secciones específicas."

#: ../Doc/library/stdtypes.rst:930
msgid "Common Sequence Operations"
msgstr "Operaciones comunes de las secuencias"

#: ../Doc/library/stdtypes.rst:934
msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom "
"sequence types."
msgstr ""
"Las operaciones de la siguiente tabla están soportadas por la mayoría de los "
"tipos secuencia, tanto mutables como inmutables. La clase ABC :class:"
"`collections.abc.Sequence` se incluye para facilitar la implementación "
"correcta de estas operaciones en nuestros propios tipos de secuencias."

#: ../Doc/library/stdtypes.rst:939
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k* "
"are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""
"La tabla lista las operaciones ordenadas de menor a mayor prioridad. En la "
"tabla, *s* y *t* representan secuencias del mismo tipo, *n*, *i*, *j* y *k* "
"son números enteros y *x* es un objeto arbitrario que cumple con cualquier "
"restricción de tipo o valor impuesta por *s*."

#: ../Doc/library/stdtypes.rst:944
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""
"Las operaciones ``in`` y ``not in`` tienen la misma prioridad que los "
"operadores de comparación. Las operaciones ``+`` (concatenación) y ``*`` "
"(repetición) tienen la misma prioridad que sus equivalentes numéricos. [3]_"

#: ../Doc/library/stdtypes.rst:965
msgid "``x in s``"
msgstr "``x in s``"

#: ../Doc/library/stdtypes.rst:965
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr ""
"``True`` si un elemento de *s* es igual a *x*, ``False`` en caso contrario"

#: ../Doc/library/stdtypes.rst:968
msgid "``x not in s``"
msgstr "``x not in s``"

#: ../Doc/library/stdtypes.rst:968
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr ""
"``False`` si un elemento de *s* es igual a *x*, ``True`` en caso contrario"

#: ../Doc/library/stdtypes.rst:971
msgid "``s + t``"
msgstr "``s + t``"

#: ../Doc/library/stdtypes.rst:971
msgid "the concatenation of *s* and *t*"
msgstr "la concatenación de *s* y *t*"

#: ../Doc/library/stdtypes.rst:971
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../Doc/library/stdtypes.rst:974
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` o ``n * s``"

#: ../Doc/library/stdtypes.rst:974
msgid "equivalent to adding *s* to itself *n* times"
msgstr "equivale a concatenar *s* consigo mismo *n* veces"

#: ../Doc/library/stdtypes.rst:974
msgid "(2)(7)"
msgstr "(2)(7)"

#: ../Doc/library/stdtypes.rst:977
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../Doc/library/stdtypes.rst:977
msgid "*i*\\ th item of *s*, origin 0"
msgstr "El elemento *i-esimo* de *s*, empezando a contar en 0"

#: ../Doc/library/stdtypes.rst:979
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: ../Doc/library/stdtypes.rst:979
msgid "slice of *s* from *i* to *j*"
msgstr "el segmento de *s* desde *i* hasta *j*"

#: ../Doc/library/stdtypes.rst:979
msgid "(3)(4)"
msgstr "(3)(4)"

#: ../Doc/library/stdtypes.rst:981
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: ../Doc/library/stdtypes.rst:981
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "el segmento de *s* desde *i* hasta *j*, con paso *k*"

#: ../Doc/library/stdtypes.rst:981
msgid "(3)(5)"
msgstr "(3)(5)"

#: ../Doc/library/stdtypes.rst:984
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../Doc/library/stdtypes.rst:984
msgid "length of *s*"
msgstr "longitud de *s*"

#: ../Doc/library/stdtypes.rst:986
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../Doc/library/stdtypes.rst:986
msgid "smallest item of *s*"
msgstr "el elemento más pequeño de *s*"

#: ../Doc/library/stdtypes.rst:988
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../Doc/library/stdtypes.rst:988
msgid "largest item of *s*"
msgstr "el elemento más grande de *s*"

#: ../Doc/library/stdtypes.rst:990
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: ../Doc/library/stdtypes.rst:990
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr ""
"índice de la primera ocurrencia de *x* en *s* (en la posición *i* o "
"superior, y antes de *j*)"

#: ../Doc/library/stdtypes.rst:990 ../Doc/library/stdtypes.rst:3644
msgid "\\(8)"
msgstr "\\(8)"

#: ../Doc/library/stdtypes.rst:994
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../Doc/library/stdtypes.rst:994
msgid "total number of occurrences of *x* in *s*"
msgstr "número total de ocurrencias de *x* en *s*"

#: ../Doc/library/stdtypes.rst:998
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal "
"and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""
"También se pueden comparar secuencias del mismo tipo. En particular, las "
"tuplas y las listas se comparan por orden lexicográfico, comparando los "
"elementos en la misma posición. Esto significa que, para que se consideren "
"iguales, todos los elementos correspondientes deben ser iguales entre si, y "
"las dos secuencias deben ser del mismo tipo y de la misma longitud. (Para "
"más detalles, véase :ref:`comparisons` en la referencia del lenguaje)."

#: ../Doc/library/stdtypes.rst:1008
msgid ""
"Forward and reversed iterators over mutable sequences access values using an "
"index.  That index will continue to march forward (or backward) even if the "
"underlying sequence is mutated.  The iterator terminates only when an :exc:"
"`IndexError` or a :exc:`StopIteration` is encountered (or when the index "
"drops below zero)."
msgstr ""
"Los iteradores directos e inversos sobre secuencias mutables acceden a "
"valores al usar un índice. Este índice continuará avanzando (o "
"retrocediendo) incluso si la secuencia subyacente está mutada. El iterador "
"termina solo cuando se encuentra un :exc:`IndexError` o un :exc:"
"`StopIteration` (o cuando el índice cae por debajo de cero)."

#: ../Doc/library/stdtypes.rst:1017
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such "
"as :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""
"Aunque las operaciones ``in`` y ``not in`` se usan generalmente para "
"comprobar si un elemento está dentro de un contenedor, en algunas secuencias "
"especializadas (como :class:`str`, :class:`bytes` y :class:`bytearray`) "
"también se pueden usar para comprobar si está incluida una secuencia::"

#: ../Doc/library/stdtypes.rst:1026
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""
"Valores de *n* menores que ``0`` se consideran como ``0`` (que produce una "
"secuencia vacía del mismo tipo que *s*). Nótese que los elementos de la "
"secuencia *s* no se copian, sino que se referencian múltiples veces. Esto a "
"menudo confunde a programadores noveles de Python; considérese::"

#: ../Doc/library/stdtypes.rst:1038
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way::"
msgstr ""
"Lo que ha pasado es que ``[[]]`` es una lista de un elemento, siendo este "
"elemento una lista vacía, así que los tres elementos de ``[[]] * 3`` son "
"referencias a la misma lista vacía. Modificar cualquiera de los elementos de "
"``lists`` modifica la lista inicial. Para crear una lista de listas "
"independientes entre si, se puede hacer::"

#: ../Doc/library/stdtypes.rst:1050
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-multidimensional-"
"list`."
msgstr ""
"Se puede consultar una explicación más completa en esta entrada de la lista "
"de preguntas más frecuentes :ref:`faq-multidimensional-list`."

#: ../Doc/library/stdtypes.rst:1054
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"Si *i* o *j* es negativo, el índice es relativo al final de la secuencia "
"*s*: Se realiza la sustitución ``len(s) + i`` o ``len(s) + j``. Nótese que "
"``-0`` sigue siendo ``0``."

#: ../Doc/library/stdtypes.rst:1059
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""
"El segmento de *s* desde *i* hasta *j* se define como la secuencia de "
"elementos con índice *k*, de forma que ``i <= k < j``. Si *i* o *j* es mayor "
"que ``len(s)`` se usa ``len(s)``. Si *i* se omite o es ``None``, se usa "
"``0``. Si *j* se omite o es ``None``, se usa ``len(s)``. Si *i* es mayor o "
"igual a *j*, el segmento está vacío."

#: ../Doc/library/stdtypes.rst:1066
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is "
"``None``, it is treated like ``1``."
msgstr ""
"El segmento de *s*, desde *i* hasta *j* con paso *k*, se define como la "
"secuencia de elementos con índice ``x = i + n*k`` tal que ``0 <= n < (j-i)/"
"k``. En otras palabras, los índices son ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` "
"y así consecutivamente, hasta que se alcance el valor de *j* (pero sin "
"incluir nunca *j*). Cuando *k* es positivo, *i* y *j* se limitan al valor de "
"``len(s)``, si fueran mayores. Si *k* es negativo, *i* y *j* se reducen de "
"``len(s) - 1``. Si *i* o *j* se omiten o su valor es ``None``, se convierten "
"es valores \"finales\" (donde el sentido de final depende del signo de *k*). "
"Nótese que *k* no puede valer ``0``. Si *k* vale ``None``, se considera como "
"``1``."

#: ../Doc/library/stdtypes.rst:1077
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""
"La concatenación de secuencias inmutables siempre produce un nuevo objeto. "
"Esto significa que construir una secuencia usando la concatenación tiene un "
"coste en ejecución cuadrático respecto al tamaño de la secuencia final. Para "
"obtener un rendimiento lineal, se puede optar por una de las alternativas "
"siguientes:"

#: ../Doc/library/stdtypes.rst:1082
msgid ""
"if concatenating :class:`str` objects, you can build a list and use :meth:"
"`str.join` at the end or else write to an :class:`io.StringIO` instance and "
"retrieve its value when complete"
msgstr ""
"en vez de concatenar objetos de tipo :class:`str`, se puede construir una "
"lista y usar finalmente el método :meth:`str.join`, o bien utilizar una "
"instancia de la clase :class:`io.StringIO` y recuperar el valor final "
"completo"

# Duda sobre como traducir *in place*
#: ../Doc/library/stdtypes.rst:1086
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use :meth:`bytes."
"join` or :class:`io.BytesIO`, or you can do in-place concatenation with a :"
"class:`bytearray` object.  :class:`bytearray` objects are mutable and have "
"an efficient overallocation mechanism"
msgstr ""
"de forma similar, en vez de concatenar objetos de tipo :class:`bytes` se "
"puede usar el método :meth:`bytes.join`, la clase :class:`io.BytesIO`, o se "
"puede realizar una modificación interna usando un objeto de la clase :class:"
"`bytearray`. Los objetos de tipo :class:`bytearray` son mutables y tienen un "
"mecanismo interno de gestión muy eficiente"

#: ../Doc/library/stdtypes.rst:1091
msgid "if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ""
"en vez de concatenar tuplas (instancias de :class:`tuple`), usar una lista (:"
"class:`list`) y expandirla"

#: ../Doc/library/stdtypes.rst:1093
msgid "for other types, investigate the relevant class documentation"
msgstr "para otros tipos, investiga la documentación relevante de la clase"

#: ../Doc/library/stdtypes.rst:1097
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr ""
"Algunos tipos de secuencia (como la clase :class:`range`) solo soportan "
"elementos que siguen un patrón específico, y por tanto no soportan la "
"concatenación ni la repetición."

#: ../Doc/library/stdtypes.rst:1102
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. These "
"arguments allow efficient searching of subsections of the sequence. Passing "
"the extra arguments is roughly equivalent to using ``s[i:j].index(x)``, only "
"without copying any data and with the returned index being relative to the "
"start of the sequence rather than the start of the slice."
msgstr ""
"El método ``index`` lanza la excepción :exc:`ValueError` si *x* no se "
"encuentra en *s*. No todas las implementaciones soportan los parámetros "
"opcionales *i* y *j*. Estos parámetros permiten una búsqueda eficiente de "
"partes de una secuencia. Usar estos parámetros es más o menos equivalente a "
"usar ``s[i:j].index(x)``, pero sin copiar ningún dato y con el valor de "
"índice retornado como valor relativo al inicio de la secuencia, en vez de al "
"inicio del segmento."

#: ../Doc/library/stdtypes.rst:1113
msgid "Immutable Sequence Types"
msgstr "Tipos de secuencia inmutables"

#: ../Doc/library/stdtypes.rst:1120
msgid ""
"The only operation that immutable sequence types generally implement that is "
"not also implemented by mutable sequence types is support for the :func:"
"`hash` built-in."
msgstr ""
"La única operación que las secuencias inmutables implementan generalmente, y "
"que no esta definida también en las secuencias mutables, es el soporte para "
"el cálculo de la función predefinida :func:`hash`."

#: ../Doc/library/stdtypes.rst:1124
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and :class:"
"`frozenset` instances."
msgstr ""
"Este soporte permite usar secuencias inmutables, como por ejemplo las "
"instancias de la clase :class:`tuple`, como claves para diccionarios (:class:"
"`dict`), así como ser almacenadas en conjuntos (:class:`set`) o conjuntos "
"congelados (:class:`frozenset`)."

#: ../Doc/library/stdtypes.rst:1128
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr ""
"Intentar calcular el *hash* de una secuencia inmutable que contenga objetos "
"mutables producirá una excepción de tipo :exc:`TypeError`."

#: ../Doc/library/stdtypes.rst:1135
msgid "Mutable Sequence Types"
msgstr "Tipos de secuencia mutables"

#: ../Doc/library/stdtypes.rst:1142
msgid ""
"The operations in the following table are defined on mutable sequence types. "
"The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""
"Las operaciones de la siguiente tabla están definidas para todas los tipos "
"de secuencia mutables. La clase ABC :class:`collections.abc.MutableSequence` "
"se incluye para facilitar la implementación correcta de un tipo de secuencia "
"propio."

#: ../Doc/library/stdtypes.rst:1146
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""
"En la tabla, *s* es una instancia de una secuencia de tipo mutable, *t* es "
"cualquier objeto iterable y *x* es un objeto arbitrario que cumple las "
"restricciones de tipo y valor que vengan impuestas por *s* (como ejemplo, la "
"clase :class:`bytearray` solo acepta enteros que cumplan la condición ``0 <= "
"x <= 255``)."

#: ../Doc/library/stdtypes.rst:1170
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../Doc/library/stdtypes.rst:1170
msgid "item *i* of *s* is replaced by *x*"
msgstr "el elemento *i* de *s* es reemplazado por *x*"

#: ../Doc/library/stdtypes.rst:1173
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../Doc/library/stdtypes.rst:1173
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr ""
"el segmento de valores de *s* que van de *i* a *j* es reemplazada por el "
"contenido del iterador *t*"

#: ../Doc/library/stdtypes.rst:1177
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../Doc/library/stdtypes.rst:1177
msgid "same as ``s[i:j] = []``"
msgstr "equivalente a ``s[i:j] = []``"

#: ../Doc/library/stdtypes.rst:1179
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../Doc/library/stdtypes.rst:1179
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr ""
"los elementos de ``s[i:j:k]`` son reemplazados por los elementos de *t*"

#: ../Doc/library/stdtypes.rst:1182
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../Doc/library/stdtypes.rst:1182
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "borra los elementos de ``s[i:j:k]`` de la lista"

#: ../Doc/library/stdtypes.rst:1185
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../Doc/library/stdtypes.rst:1185
msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr ""
"añade *x* al final de la secuencia (equivale a ``s[len(s):len(s)] = [x]``)"

#: ../Doc/library/stdtypes.rst:1189
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../Doc/library/stdtypes.rst:1189
msgid "removes all items from *s* (same as ``del s[:]``)"
msgstr "elimina todos los elementos de *s* (equivale a ``del s[:]``)"

#: ../Doc/library/stdtypes.rst:1192
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../Doc/library/stdtypes.rst:1192
msgid "creates a shallow copy of *s* (same as ``s[:]``)"
msgstr "crea una copia superficial de *s* (equivale a ``s[:]``)"

#: ../Doc/library/stdtypes.rst:1195
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` o ``s += t``"

#: ../Doc/library/stdtypes.rst:1195
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr ""
"extiende *s* con los contenidos de *t* (en la mayoría de los casos equivale "
"a ``s[len(s):len(s)] = t``)"

#: ../Doc/library/stdtypes.rst:1200
msgid "``s *= n``"
msgstr "``s *= n``"

#: ../Doc/library/stdtypes.rst:1200
msgid "updates *s* with its contents repeated *n* times"
msgstr "actualiza *s* con su contenido repetido *n* veces"

#: ../Doc/library/stdtypes.rst:1203
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../Doc/library/stdtypes.rst:1203
msgid ""
"inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr ""
"inserta *x* en *s* en la posición indicada por el índice *i* (equivale a "
"``s[i:i] = [x]``)"

#: ../Doc/library/stdtypes.rst:1207
msgid "``s.pop()`` or ``s.pop(i)``"
msgstr "``s.pop()`` o ``s.pop(i)``"

#: ../Doc/library/stdtypes.rst:1207
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr ""
"retorna el elemento en la posición indicada por *i*, y a la vez lo elimina "
"de la secuencia *s*"

#: ../Doc/library/stdtypes.rst:1210
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../Doc/library/stdtypes.rst:1210
msgid "remove the first item from *s* where ``s[i]`` is equal to *x*"
msgstr "elimina el primer elemento de *s* tal que ``s[i]`` sea igual a *x*"

#: ../Doc/library/stdtypes.rst:1213
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

# Duda sobre como traducir *in place*
#: ../Doc/library/stdtypes.rst:1213
msgid "reverses the items of *s* in place"
msgstr "invierte el orden de los elementos de *s*, a nivel interno"

#: ../Doc/library/stdtypes.rst:1221
msgid "*t* must have the same length as the slice it is replacing."
msgstr ""
"La secuencia *t* debe tener la misma longitud que el segmento a la que "
"reemplaza."

#: ../Doc/library/stdtypes.rst:1224
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr ""
"El parámetro opcional *i* tiene un valor por defecto de ``-1``, así que si "
"no se especifica se retorna el último valor y este se elimina de la "
"secuencia."

#: ../Doc/library/stdtypes.rst:1228
msgid ":meth:`remove` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr ""
"El método :meth:`remove` lanza la excepción :exc:`ValueError` cuando no se "
"encuentra *x* en *s*."

# side effect ' efecto secundario?
#: ../Doc/library/stdtypes.rst:1231
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates by "
"side effect, it does not return the reversed sequence."
msgstr ""
"El método :meth:`reverse` modifica la secuencia internamente, por motivos de "
"eficiencia espacial para secuencias muy grandes. Como recordatorio al "
"usuario de que el método produce un efecto secundario, no se retorna la "
"secuencia invertida."

#: ../Doc/library/stdtypes.rst:1236
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations (such "
"as :class:`dict` and :class:`set`). :meth:`!copy` is not part of the :class:"
"`collections.abc.MutableSequence` ABC, but most concrete mutable sequence "
"classes provide it."
msgstr ""
"Ambos métodos :meth:`clear` y :meth:`!copy` se incluyen por consistencia con "
"las interfaces de clases que no soportan operaciones de segmentación (como "
"las clases :class:`dict` y :class:`set`). El método :meth:`!copy` no es "
"parte de la clase ABC :class:`collections.abc.MutableSequence`, pero la "
"mayoría de las clases finales de tipo secuencia mutable lo incluyen."

#: ../Doc/library/stdtypes.rst:1242
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr "Los métodos :meth:`clear` y :meth:`!copy`."

#: ../Doc/library/stdtypes.rst:1246
msgid ""
"The value *n* is an integer, or an object implementing :meth:`~object."
"__index__`.  Zero and negative values of *n* clear the sequence.  Items in "
"the sequence are not copied; they are referenced multiple times, as "
"explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""
"El valor de *n* es un entero, o un objeto que implemente el método :meth:"
"`~object.__index__`. Los valores negativos, junto con el cero, producen una "
"lista vacía. Los elementos de la secuencia no son copiados, sino que se "
"referencian múltiples veces, tal y como se explicó para ``s * n`` en :ref:"
"`typesseq-common`."

#: ../Doc/library/stdtypes.rst:1255
msgid "Lists"
msgstr "Listas"

#: ../Doc/library/stdtypes.rst:1259
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr ""
"Las listas son secuencia mutables, usadas normalmente para almacenar "
"colecciones de elementos homogéneos (donde el grado de similitud de los "
"mismos depende de la aplicación)."

#: ../Doc/library/stdtypes.rst:1265
msgid "Lists may be constructed in several ways:"
msgstr "Las listas se pueden construir de diferentes formas:"

#: ../Doc/library/stdtypes.rst:1267
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr "Usando un par de corchetes para definir una lista vacía: ``[]``"

#: ../Doc/library/stdtypes.rst:1268
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""
"Usando corchetes, separando los elementos incluidos con comas: ``[a]``, "
"``[a, b, c]``"

#: ../Doc/library/stdtypes.rst:1269
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr ""
"Usando una lista intensiva o por comprensión: ``[x for x in iterable]``"

#: ../Doc/library/stdtypes.rst:1270
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr "Usando el constructor de tipo: ``list()`` o ``list(iterable)``"

#: ../Doc/library/stdtypes.rst:1272
msgid ""
"The constructor builds a list whose items are the same and in the same order "
"as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""
"La lista se construye con los mismos elementos y en el mismo orden que "
"*iterable*, donde *iterable* puede ser una secuencia, un contenedor que "
"soporta iteración, o un objeto iterador. Si *iterable* es de por si una "
"lista, se construye y retorna una copia, como si se hubiera llamado a "
"``iterable[:]``. Por ejemplo, ``list('abc')`` retorna ``['a', 'b', 'c']`` y "
"``list( (1, 2, 3) )`` retorna ``[1, 2, 3]``. Si no se pasan parámetros, se "
"construye una nueva lista vacía, ``[]``."

# Traduccion de built-ins
#: ../Doc/library/stdtypes.rst:1281
msgid ""
"Many other operations also produce lists, including the :func:`sorted` built-"
"in."
msgstr ""
"Muchas otras operaciones también producen listas, incluyendo la función "
"incorporada :func:`sorted`."

#: ../Doc/library/stdtypes.rst:1284
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable "
"<typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""
"Las listas implementan todas las operaciones :ref:`comunes <typesseq-"
"common>` y :ref:`mutables <typesseq-mutable>` propias de las secuencias. "
"Además, las listas incorporan los siguientes métodos:"

#: ../Doc/library/stdtypes.rst:1290
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""
"Este método ordena la lista *in situ* (se modifica internamente), usando "
"únicamente comparaciones de tipo ``<``. Las excepciones no son capturadas "
"internamente: si alguna comparación falla, la operación entera de ordenación "
"falla (y la lista probablemente haya quedado modificada parcialmente)."

# Ver como se ha traducido la referencia.
#: ../Doc/library/stdtypes.rst:1295
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref:"
"`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
"El método :meth:`sort` acepta dos parámetros, que solo pueden pasarse por "
"nombre (:ref:`keyword-only arguments <keyword-only_parameter>`):"

#: ../Doc/library/stdtypes.rst:1298
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""
"El parámetro *key* especifica una función de un argumento que se usa para "
"obtener, para cada elemento de la lista, un valor concreto o clave (*key*) a "
"usar en las operaciones de comparación (por ejemplo, ``key=str.lower``). El "
"elemento clave para cada elemento se calcula una única vez y se reutiliza "
"para todo el proceso de ordenamiento. El valor por defecto, ``None``, hace "
"que la lista se ordene comparando directamente los elementos, sin obtener "
"valores clave."

#: ../Doc/library/stdtypes.rst:1305
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style "
"*cmp* function to a *key* function."
msgstr ""
"La utilidad :func:`functools.cmp_to_key` se puede usar para convertir una "
"función *cmp* del estilo de la versión 2.x a una función *key*."

#: ../Doc/library/stdtypes.rst:1308
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"El valor de *reverse* es un valor booleano. Si se define como ``True``, "
"entonces los elementos de la lista se ordenan como si las operaciones de "
"comparación se hubiesen invertido."

#: ../Doc/library/stdtypes.rst:1311
msgid ""
"This method modifies the sequence in place for economy of space when sorting "
"a large sequence.  To remind users that it operates by side effect, it does "
"not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""
"Este método modifica la lista *in situ*, para ahorrar espacio cuando se "
"ordena una secuencia muy grande. Para recordar a los usuarios que funciona "
"de esta manera, no se retorna la secuencia ordenada (puedes usar :func:"
"`sorted` para obtener de forma explicita una nueva secuencia ordenada)."

#: ../Doc/library/stdtypes.rst:1316
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""
"El método :meth:`sort` es estable. Un algoritmo de ordenación es estable si "
"garantiza que no se cambia el orden relativo que mantienen inicialmente los "
"elementos que se consideran iguales --- esto es útil para realizar "
"ordenaciones en múltiples fases (por ejemplo, ordenar por departamento y "
"después por salario)."

#: ../Doc/library/stdtypes.rst:1321
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"Para ver ejemplos de ordenación y un breve tutorial sobre el tema, véase :"
"ref:`sortinghowto`."

#: ../Doc/library/stdtypes.rst:1325
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""
"Mientras una lista está siendo ordenada, los efectos de intentar "
"modificarla, o incluso examinarla, no están definidos. La implementación en "
"C de Python hace que la lista parezca vacía durante la ordenación, y lanza "
"una excepción del tipo :exc:`ValueError` si detecta un cambio en la lista "
"durante el proceso de ordenación."

#: ../Doc/library/stdtypes.rst:1334
msgid "Tuples"
msgstr "Tuplas"

#: ../Doc/library/stdtypes.rst:1338
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or :"
"class:`dict` instance)."
msgstr ""
"Las tuplas son secuencias inmutables, usadas normalmente para almacenar "
"colecciones de datos heterogéneos (como las duplas o tuplas de dos elementos "
"producidas por la función incorporada :func:`enumerate`). También son usadas "
"en aquellos casos donde se necesite una secuencia inmutable de datos "
"homogéneos (como por ejemplo permitir el almacenamiento en un objeto de "
"tipo :class:`set` o :class:`dict`)."

#: ../Doc/library/stdtypes.rst:1346
msgid "Tuples may be constructed in a number of ways:"
msgstr "Las tuplas se pueden construir de diferentes maneras:"

#: ../Doc/library/stdtypes.rst:1348
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr ""
"Usando un par de símbolos de paréntesis, para indicar una tupla vacía: ``()``"

#: ../Doc/library/stdtypes.rst:1349
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr ""
"Usando una coma al final, para crear una tupla de un único elemento: ``a,`` "
"o ``(a,)``"

#: ../Doc/library/stdtypes.rst:1350
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "Separando los elementos por comas: ``a, b, c`` o ``(a, b, c)``"

#: ../Doc/library/stdtypes.rst:1351
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr ""
"Usando la función incorporada :func:`tuple`: ``tuple()`` o "
"``tuple(iterable)``"

#: ../Doc/library/stdtypes.rst:1353
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""
"El constructor genera una tupla cuyos elementos son los mismos y están en el "
"mismo orden que los elementos del *iterable*, donde *iterable* puede ser una "
"secuencia, un contenedor que soporta iteración, o un objeto de tipo "
"*iterator*. Si *iterable* es ya de por si una tupla, se retorna sin cambiar. "
"Por ejemplo, ``tuple('abc')`` retorna ``('a', 'b', 'c')`` y ``tuple( [1, 2, "
"3] )`` retorna ``(1, 2, 3)``. Si no se indica ningún parámetro, el "
"constructor creará una nueva tupla vacía. ``()``."

#: ../Doc/library/stdtypes.rst:1361
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses. "
"The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""
"Nótese que es la coma la que realmente construye la tupla, no los "
"paréntesis. Los paréntesis son opcionales, excepto en el caso de la tupla "
"vacía, o cuando se necesitan para evitar una ambigüedad sintáctica. Por "
"ejemplo, ``f(a, b, c)`` es una llamada a una función con tres parámetros, "
"pero ``f((a, b, c))`` es una llamada a una función con un único parámetro, "
"en este caso una tupla de tres elementos."

#: ../Doc/library/stdtypes.rst:1367
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr ""
"Las tuplas implementan todas las operaciones de secuencia :ref:`comunes "
"<typesseq-common>`."

#: ../Doc/library/stdtypes.rst:1370
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""
"Para colecciones de datos heterogéneos donde el acceso por nombre resulta "
"más claro que por índice, quizá crear una tupla con nombres (:func:"
"`collections.namedtuple`) pueden ser más apropiado."

#: ../Doc/library/stdtypes.rst:1378
msgid "Ranges"
msgstr "Rangos"

#: ../Doc/library/stdtypes.rst:1382
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` loops."
msgstr ""
"Los objetos de tipo :class:`range` representan una secuencia inmutable de "
"números y se usan habitualmente para ejecutar un bucle :keyword:`for` un "
"número determinado de veces."

#: ../Doc/library/stdtypes.rst:1389
msgid ""
"The arguments to the range constructor must be integers (either built-in :"
"class:`int` or any object that implements the :meth:`~object.__index__` "
"special method).  If the *step* argument is omitted, it defaults to ``1``. "
"If the *start* argument is omitted, it defaults to ``0``. If *step* is "
"zero, :exc:`ValueError` is raised."
msgstr ""
"Los parámetros usados por el constructor del rango deben ser números enteros "
"(o bien objetos de tipo :class:`int` o instancias de una clase que "
"implemente el método especial :meth:`~object.__index__`). Si el parámetro "
"*step* se omite, se asume el valor ``1``. Si se omite el parámetro "
"``start``, se toma como ``0``. Si *step* es cero, se lanza una excepción de "
"tipo :exc:`ValueError`."

#: ../Doc/library/stdtypes.rst:1395
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""
"Para un valor positivo de *step*, el contenido del rango ``r`` viene "
"determinado por la fórmula ``r[i] = start + step*i`` donde ``i >= 0`` y "
"``r[i] < stop``."

#: ../Doc/library/stdtypes.rst:1399
msgid ""
"For a negative *step*, the contents of the range are still determined by the "
"formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""
"Para un valor negativo de *step*, el contenido del rango sigue estando "
"determinado por la fórmula ``r[i] = start + step*i``, pero las restricciones "
"ahora son ``i >= 0`` y ``r[i] > stop``."

#: ../Doc/library/stdtypes.rst:1403
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint. "
"Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr ""
"Un objeto de tipo rango se considera vacío si ``r[0]`` no cumple con las "
"restricciones de valor. Los rangos soportan índices negativos, pero estos "
"son interpretados como índices considerados desde el final de la secuencia "
"determinada por los índices positivos."

#: ../Doc/library/stdtypes.rst:1408
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise :exc:"
"`OverflowError`."
msgstr ""
"Los rangos que contengan valores mayores que :data:`sys.maxsize` se "
"permiten, pero algunas capacidades (como la función :func:`len`) pueden "
"lanzar una excepción de tipo :exc:`OverflowError`."

#: ../Doc/library/stdtypes.rst:1412
msgid "Range examples::"
msgstr "Ejemplos de rangos::"

#: ../Doc/library/stdtypes.rst:1429
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""
"Los rangos implementan todas las operaciones :ref:`comunes <typesseq-"
"common>` de las secuencias, excepto la concatenación y la repetición (esto "
"es porque los objetos de tipo rango solamente pueden representar secuencias "
"que siguen un patrón estricto, y tanto la repetición como la concatenación "
"pueden romperlo)."

#: ../Doc/library/stdtypes.rst:1436
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr "El valor del parámetro *start* (``0`` si no se utiliza el parámetro)"

#: ../Doc/library/stdtypes.rst:1441
msgid "The value of the *stop* parameter"
msgstr "El valor del parámetro *stop*"

#: ../Doc/library/stdtypes.rst:1445
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr "El valor del parámetro *step* (``1`` si no se utiliza el parámetro)"

#: ../Doc/library/stdtypes.rst:1448
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or :"
"class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""
"La ventaja de usar un objeto de tipo :class:`range` en vez de uno de tipo :"
"class:`list` o :class:`tuple` es que con :class:`range` siempre se usa una "
"cantidad fija (y pequeña) de memoria, independientemente del rango que "
"represente (ya que solamente necesita almacenar los valores para ``start``, "
"``stop`` y ``step``, y calcula los valores intermedios a medida que los va "
"necesitando)."

#: ../Doc/library/stdtypes.rst:1454
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""
"Los objetos rango implementan la clase ABC :class:`collections.abc."
"Sequence`, y proporcionan capacidades como comprobación de inclusión, "
"búsqueda de elementos por índice, operaciones de segmentación y soporte de "
"índices negativos (véase :ref:`typesseq`):"

#: ../Doc/library/stdtypes.rst:1474
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop` "
"and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""
"La comparación entre rangos usando los operadores ``==`` y ``!=`` se realiza "
"como con las secuencias. Esto es, dos rangos se consideran iguales si "
"representan exactamente la misma secuencia de elementos. (Fíjate que, según "
"esta definición, dos rangos pueden considerarse iguales aunque tengan "
"diferentes valores para :attr:`~range.start`, :attr:`~range.stop` y :attr:"
"`~range.step`, por ejemplo ``range(0) == range(2, 1, 3)`` y ``range(0, 3, 2) "
"== range(0, 4, 2)``)."

#: ../Doc/library/stdtypes.rst:1481
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test :"
"class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr ""
"Implementa la secuencia ABC. Soporta operaciones de segmentación e índices "
"negativos. Comprueba si un entero de tipo :class:`int` está incluido en un "
"rango que se realiza en un tiempo constante, en lugar de iterar a través de "
"todos los elementos."

#: ../Doc/library/stdtypes.rst:1487
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr ""
"Define los operadores '==' y '!=' para comparar rangos en base a la "
"secuencia de valores que definen (en vez de compararse en base a la "
"identidad)."

#: ../Doc/library/stdtypes.rst:1492
msgid ""
"The :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ""
"Los atributos :attr:`~range.start`, :attr:`~range.stop` y :attr:`~range."
"step`."

#: ../Doc/library/stdtypes.rst:1498
msgid ""
"The `linspace recipe <https://code.activestate.com/recipes/579000/>`_ shows "
"how to implement a lazy version of range suitable for floating point "
"applications."
msgstr ""
"En `linspace recipe <https://code.activestate.com/recipes/579000/>`_ se "
"muestra como implementar una versión *lazy* o perezosa de rango adecuada "
"para aplicaciones de coma flotante."

#: ../Doc/library/stdtypes.rst:1510
msgid "Text Sequence Type --- :class:`str`"
msgstr "Cadenas de caracteres --- :class:`str`"

# Comprobar la definicion de cadenas
#: ../Doc/library/stdtypes.rst:1512
msgid ""
"Textual data in Python is handled with :class:`str` objects, or :dfn:"
"`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode code "
"points.  String literals are written in a variety of ways:"
msgstr ""
"La información textual se representa en Python con objetos de tipo :class:"
"`str`, normalmente llamados cadenas de caracteres o simplemente :dfn:"
"`strings`. Las cadenas de caracteres son :ref:`secuencias <typesseq>` "
"inmutables de puntos de código Unicode. Las cadenas se pueden definir de "
"diferentes maneras:"

#: ../Doc/library/stdtypes.rst:1517
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr "Comillas simples: ``'permite incluir comillas \"dobles\"'``"

#: ../Doc/library/stdtypes.rst:1518
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``"
msgstr "Comillas dobles: ``\"permite incluir comillas 'simples'\"``"

#: ../Doc/library/stdtypes.rst:1519
msgid ""
"Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double "
"quotes\"\"\"``"
msgstr ""
"Triples comillas: ya sea con comillas simples ``'''Triples comillas "
"simples'''`` o dobles ``\"\"\"Triples comillas dobles\"\"\"``"

#: ../Doc/library/stdtypes.rst:1521
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr ""
"Las cadenas definidas con comillas tripes pueden incluir varias líneas - "
"todos los espacios en blancos incluidos se incorporan a la cadena de forma "
"literal."

#: ../Doc/library/stdtypes.rst:1524
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"Cadenas literales que forman parte de una expresión y que solo estén "
"separados por espacios en blanco, se convertirán implícitamente a una única "
"cadena. Esto es, ``(\"spam \" \"eggs\") == \"spam eggs\"``."

#: ../Doc/library/stdtypes.rst:1528
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported escape sequences, and the ``r`` (\"raw\") prefix that "
"disables most escape sequence processing."
msgstr ""
"Véase :ref:`strings` para más información acerca de las diferentes formas de "
"expresar cadenas de forma literal, incluidos los caracteres de escape, y del "
"prefijo ``r`` (\"*raw*\") que deshabilita el procesamiento de la mayoría de "
"dichas secuencias de escape."

#: ../Doc/library/stdtypes.rst:1532
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr ""
"Las cadenas de caracteres también se pueden crear usando el constructor :"
"class:`str`."

#: ../Doc/library/stdtypes.rst:1535
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == s[0:1]``."
msgstr ""
"Como no hay un tipo separado para los \"caracteres\", indexar una cadena "
"produce una cadena de longitud 1. Esto es, para una cadena de caracteres no "
"vacía *s*, ``s[0] == s[0:1]``."

# fragmentos suena raro
#: ../Doc/library/stdtypes.rst:1541
msgid ""
"There is also no mutable string type, but :meth:`str.join` or :class:`io."
"StringIO` can be used to efficiently construct strings from multiple "
"fragments."
msgstr ""
"Tampoco hay una versión mutable de las cadenas de caracteres, pero el "
"método :meth:`str.join` o la clase :class:`io.StringIO` pueden usarse para "
"construir de forma eficiente una cadena de caracteres a partir de fragmentos."

#: ../Doc/library/stdtypes.rst:1545
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""
"Para facilitar la compatibilidad hacia atrás con la versión 2, el prefijo "
"``u`` se permite en las cadenas de caracteres. No tiene ningún efecto en la "
"interpretación del literal y no se puede combinar con el prefijo ``r``."

#: ../Doc/library/stdtypes.rst:1557
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"Retorna una representación en forma de :ref:`cadena de caracteres <textseq>` "
"de *object*. Si no se proporciona ningún valor, retorna una cadena vacía. Si "
"se proporciona, el comportamiento de ``str()`` depende de los valores "
"pasados en los parámetros *encoding* y *errors*, como veremos."

#: ../Doc/library/stdtypes.rst:1561
#, fuzzy
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns :meth:"
"`type(object).__str__(object) <object.__str__>`, which is the \"informal\" "
"or nicely printable string representation of *object*.  For string objects, "
"this is the string itself.  If *object* does not have a :meth:`~object."
"__str__` method, then :func:`str` falls back to returning :func:"
"`repr(object) <repr>`."
msgstr ""
"Si no se especifica ni *encoding* ni *errors*, ``str(object)`` retorna :meth:"
"`type(object).__str__(object) <object.__str__>`, que es la representación "
"\"informal\" o mas cómoda de usar, en forma de cadena de caracteres, del "
"valor de *object*. Para una cadena de caracteres, es la cadena en sí. Si "
"*object* no tiene un método :meth:`~object.__str__`, entonces :func:`str` "
"usará como reemplazo el método :meth:`repr(object) <repr>`."

#: ../Doc/library/stdtypes.rst:1573
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a :"
"term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to :meth:`bytes."
"decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes object "
"underlying the buffer object is obtained before calling :meth:`bytes."
"decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for information on "
"buffer objects."
msgstr ""
"Si se indica alguno de los dos parámetros *encoding* o *errors*, entonces "
"*object* debe ser un objeto binario o similar (:term:`bytes-like object`, es "
"decir, una instancia de :class:`bytes` o :class:`bytearray`). En este caso, "
"si *object* es de tipo :class:`bytes` o :class:`bytearray`, la llamada a "
"``str(bytes, encoding, errors)`` es equivalente a :meth:`bytes."
"decode(encoding, errors) <bytes.decode>`. Si no, el objeto de tipo *bytes* "
"que esta subyacente en el objeto *buffer* se obtiene mediante una llamada a :"
"meth:`bytes.decode`. Véase :ref:`binaryseq` y :ref:`bufferobjects` para más "
"información sobre los objetos *buffer*."

# comand-line?
#: ../Doc/library/stdtypes.rst:1582
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""
"Si se pasa un objeto de tipo :class:`bytes` a la función :func:`str` sin "
"especificar o bien el parámetro *encoding* o bien el *errors*, se vuelve al "
"caso normal donde se retorna la representación informal de la cadena de "
"caracteres (véase también la :option:`-b` de las opciones de línea de "
"órdenes de Python). Por ejemplo::"

#: ../Doc/library/stdtypes.rst:1590
msgid ""
"For more information on the ``str`` class and its methods, see :ref:"
"`textseq` and the :ref:`string-methods` section below.  To output formatted "
"strings, see the :ref:`f-strings` and :ref:`formatstrings` sections.  In "
"addition, see the :ref:`stringservices` section."
msgstr ""
"Para más información sobre la clase ``str`` y sus métodos, consulta :ref:"
"`textseq` y la sección :ref:`string-methods` a continuación. Para las "
"opciones de formateo de cadenas, lee las secciones :ref:`f-strings` y :ref:"
"`formatstrings`. También puedes consultar la sección :ref:`stringservices`."

#: ../Doc/library/stdtypes.rst:1602
msgid "String Methods"
msgstr "Métodos de las cadenas de caracteres"

#: ../Doc/library/stdtypes.rst:1607
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr ""
"Todas las cadenas de caracteres implementan las operaciones :ref:`comunes "
"<typesseq-common>` de las secuencias, junto con los métodos descritos a "
"continuación."

#: ../Doc/library/stdtypes.rst:1610
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, :ref:"
"`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""
"Las cadenas soportan dos estilos de formateo, uno proporciona un grado muy "
"completo de flexibilidad y personalización (véase :meth:`str.format`, :ref:"
"`formatstrings` y :ref:`string-formatting`) mientras que el otro se basa en "
"la función C ``printf``, que soporta un menor número de tipos y es "
"ligeramente más complicada de usar, pero es a menudo más rápida para los "
"casos que puede manejar (:ref:`old-string-formatting`)."

#: ../Doc/library/stdtypes.rst:1617
msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular "
"expression support in the :mod:`re` module)."
msgstr ""
"La sección :ref:`textservices` de la librería estándar cubre una serie de "
"módulos que proporcionan varias utilidades para trabajar con textos "
"(incluyendo las expresiones regulares en el módulo :mod:`re`)."

#: ../Doc/library/stdtypes.rst:1623
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr ""
"Retorna una copia de la cadena con el primer carácter en mayúsculas y el "
"resto en minúsculas."

# no se si titular sera lo adecuado
#: ../Doc/library/stdtypes.rst:1626
msgid ""
"The first character is now put into titlecase rather than uppercase. This "
"means that characters like digraphs will only have their first letter "
"capitalized, instead of the full character."
msgstr ""
"El primer carácter se pasa ahora a título, más que a mayúsculas. Esto "
"significa que caracteres como dígrafos solo tendrán la primera letra en "
"mayúsculas, en vez de todo el carácter."

#: ../Doc/library/stdtypes.rst:1633
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr ""
"Retorna el texto de la cadena, normalizado a minúsculas. Los textos así "
"normalizados pueden usarse para realizar búsquedas textuales independientes "
"de mayúsculas y minúsculas."

#: ../Doc/library/stdtypes.rst:1636
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; :meth:"
"`casefold` converts it to ``\"ss\"``."
msgstr ""
"El texto normalizado a minúsculas es más agresivo que el texto en minúsculas "
"normal, porque se intenta unificar todas las grafías distintas de la letras. "
"Por ejemplo, en Alemán la letra minúscula ``'ß'`` equivale a ``\"ss\"``. "
"Como ya está en minúsculas, el método :meth:`lower` no modifica ``'ß'``, "
"pero el método :meth:`casefold` lo convertirá a ``\"ss\"``."

#: ../Doc/library/stdtypes.rst:1642
#, fuzzy
msgid ""
"The casefolding algorithm is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode15.0.0/ch03.pdf>`__."
msgstr ""
"El algoritmo de normalización a minúsculas se describe en la sección 3.13 "
"del estándar Unicode."

#: ../Doc/library/stdtypes.rst:1651
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Retorna el texto de la cadena, centrado en una cadena de longitud *width*. "
"El relleno a izquierda y derecha se realiza usando el carácter definido por "
"el parámetro *fillchar* (por defecto se usa el carácter espacio ASCII). Si "
"la cadena original tiene una longitud ``len(s)`` igual o superior a *width*, "
"se retorna el texto sin modificar."

#: ../Doc/library/stdtypes.rst:1659
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Retorna el número de ocurrencias no solapadas de la cadena *sub* en el rango "
"[*start*, *end*]. Los parámetros opcionales *start* y *end* se interpretan "
"como en una expresión de segmento."

#: ../Doc/library/stdtypes.rst:1663
msgid ""
"If *sub* is empty, returns the number of empty strings between characters "
"which is the length of the string plus one."
msgstr ""

#: ../Doc/library/stdtypes.rst:1669
msgid "Return the string encoded to :class:`bytes`."
msgstr ""

#: ../Doc/library/stdtypes.rst:1671 ../Doc/library/stdtypes.rst:2810
msgid ""
"*encoding* defaults to ``'utf-8'``; see :ref:`standard-encodings` for "
"possible values."
msgstr ""

#: ../Doc/library/stdtypes.rst:1674
#, fuzzy
msgid ""
"*errors* controls how encoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, "
"``'backslashreplace'`` and any other name registered via :func:`codecs."
"register_error`. See :ref:`error-handlers` for details."
msgstr ""
"Retorna una versión codificada en forma de bytes. La codificación por "
"defecto es ``'utf-8'``. El parámetro *errors* permite especificar diferentes "
"esquemas de gestión de errores. El valor por defecto de *errors* es "
"``'strict'``, que significa que cualquier error en la codificación lanza una "
"excepción de tipo :exc:`UnicodeError`. Otros valores posibles son "
"``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` "
"y cualquier otro nombre que se haya registrado  mediante la función :func:"
"`codecs.register_error`, véase la sección :ref:`error-handlers`. Para una "
"lista de los posibles sistemas de codificación, véase la sección :ref:"
"`standard-encodings`."

#: ../Doc/library/stdtypes.rst:1681
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless an encoding error actually occurs, :ref:`devmode` is enabled or a :"
"ref:`debug build <debug-build>` is used."
msgstr ""

#: ../Doc/library/stdtypes.rst:1686 ../Doc/library/stdtypes.rst:2829
msgid "Added support for keyword arguments."
msgstr "Añadido soporte para poder usar parámetros por nombre."

#: ../Doc/library/stdtypes.rst:1689 ../Doc/library/stdtypes.rst:2832
#, fuzzy
msgid ""
"The value of the *errors* argument is now checked in :ref:`devmode` and in :"
"ref:`debug mode <debug-build>`."
msgstr ""
"El argumento *errors* ahora se verifica en modo de desarrollo y en una :ref:"
"`compilación de depuración <debug-build>`."

#: ../Doc/library/stdtypes.rst:1696
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""
"Retorna ``True`` si la cadena termina con el *suffix* especificado y "
"``False`` en caso contrario. También podemos usar *suffix* para pasar una "
"tupla de sufijos a buscar. Si especificamos el parámetro opcional *start*, "
"la comprobación empieza en esa posición. Con el parámetro opcional *stop*, "
"la comprobación termina en esa posición."

#: ../Doc/library/stdtypes.rst:1704
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current "
"column is set to zero and the string is examined character by character.  If "
"the character is a tab (``\\t``), one or more space characters are inserted "
"in the result until the current column is equal to the next tab position. "
"(The tab character itself is not copied.)  If the character is a newline "
"(``\\n``) or return (``\\r``), it is copied and the current column is reset "
"to zero.  Any other character is copied unchanged and the current column is "
"incremented by one regardless of how the character is represented when "
"printed."
msgstr ""
"Retorna una copia de la cadena, con todos los caracteres de tipo tabulador "
"reemplazados por uno o más espacios, dependiendo de la columna actual y del "
"tamaño definido para el tabulador. Las posiciones de tabulación ocurren cada "
"*tabsize* caracteres (siendo el valor por defecto de *tabsize* 8, lo que "
"produce las posiciones de tabulación 0, 8, 16,...). Para expandir la cadena, "
"la columna actual se pone a cero y se va examinando el texto carácter a "
"carácter. Si se encuentra un tabulador, (``\\t``), se insertan uno o más "
"espacios hasta que sea igual a la siguiente posición de tabulación (El "
"carácter tabulador en sí es descartado). Si el carácter en un indicador de "
"salto de línea (``\\n``) o de retorno (``\\r``), se copia y el valor de "
"columna actual se vuelve a poner a cero. Cualquier otro carácter es copiado "
"sin cambios y hace que el contador de columna se incremente en 1, sin tener "
"en cuenta como se representa gráficamente el carácter."

#: ../Doc/library/stdtypes.rst:1725
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"Retorna el menor índice de la cadena *s* donde se puede encontrar la cadena "
"*sub*, considerando solo el intervalo ``s[start:end]``. Los parámetros "
"opcionales *start* y *end* se interpretan como notación de segmento. Retorna "
"``-1`` si no se encuentra la cadena."

#: ../Doc/library/stdtypes.rst:1731
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"El método :meth:`~str.find` se debe usar solo si se necesita saber la "
"posición de la cadena *sub*. Si solo se necesita comprobar si *sub* es una "
"parte de *s*, es mejor usar el operador :keyword:`in`::"

#: ../Doc/library/stdtypes.rst:1741
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument."
msgstr ""
"Realiza una operación de formateo. La cadena de caracteres sobre la que se "
"está ejecutando este método puede contener texto literal y también marcas de "
"reemplazo de texto definidas mediante llaves ``{}``. Cada sección a "
"reemplazar contiene o bien un índice numérico que hace referencia a un "
"parámetro por posición, o el nombre de un parámetro por nombre. Retorna una "
"copia de la cadena donde se han sustituido las marcas de reemplazo por los "
"valores correspondientes pasados como parámetros."

#: ../Doc/library/stdtypes.rst:1751
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""
"Véase :ref:`formatstrings` para una descripción de las distintas opciones de "
"formateo que se pueden usar."

#: ../Doc/library/stdtypes.rst:1755
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` and subclasses) with the ``n`` type (ex: ``'{:n}'."
"format(1234)``), the function temporarily sets the ``LC_CTYPE`` locale to "
"the ``LC_NUMERIC`` locale to decode ``decimal_point`` and ``thousands_sep`` "
"fields of :c:func:`localeconv` if they are non-ASCII or longer than 1 byte, "
"and the ``LC_NUMERIC`` locale is different than the ``LC_CTYPE`` locale.  "
"This temporary change affects other threads."
msgstr ""
"Cuando se formatea un número (:class:`int`, :class:`float`, :class:"
"`complex`, :class:`decimal.Decimal` y clases derivadas) usando la ``n`` (por "
"ejemplo, ``'{:n}'.format(1234)``), la función ajusta temporalmente el valor "
"de la variable de entorno local ``LC_TYPE`` a ``LC_NUMERIC`` para "
"decodificar los campos ``decimal_point`` y ``thousands_sep`` de la función :"
"c:func:`localeconv`, si usan caracteres que no son ASCII o si ocupan más de "
"un byte, y el valor definido en ``LC_NUMERIC`` es diferente del definido en "
"``LC_CTYPE``. Estos cambios temporales pueden afectar a otros *threads*."

#: ../Doc/library/stdtypes.rst:1764
msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily "
"the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""
"Cuando se formatea un número usando la ``n``, la función puede asignar de "
"forma temporal la variable ``LC_CTYPE`` a ``LC_NUMERIC`` en algunos casos."

#: ../Doc/library/stdtypes.rst:1772
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""
"Similar a ``str.format(**mapping)``, pero se usa ``mapping`` de forma "
"directa y no se copia a un diccionario. Esto es útil si ``mapping`` es, por "
"ejemplo, una instancia de una subclase de :class:`dict`:"

#: ../Doc/library/stdtypes.rst:1788
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found."
msgstr ""
"Como :meth:`~str.find`, pero lanza una excepción de tipo :exc:`ValueError` "
"si no se encuentra la cadena a buscar."

#: ../Doc/library/stdtypes.rst:1794
msgid ""
"Return ``True`` if all characters in the string are alphanumeric and there "
"is at least one character, ``False`` otherwise.  A character ``c`` is "
"alphanumeric if one of the following returns ``True``: ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""
"Retorna ``True`` si todos los caracteres de la cadena son alfanuméricos y "
"hay, al menos, un carácter, en caso contrario, retorna ``False``. Un "
"carácter ``c`` se considera alfanumérico si alguna de las siguientes "
"funciones retorna ``True``: ``c.isalpha()``, ``c.isdecimal()``, ``c."
"isdigit()`` o ``c.isnumeric()``."

#: ../Doc/library/stdtypes.rst:1802
#, fuzzy
msgid ""
"Return ``True`` if all characters in the string are alphabetic and there is "
"at least one character, ``False`` otherwise.  Alphabetic characters are "
"those characters defined in the Unicode character database as \"Letter\", i."
"e., those with general category property being one of \"Lm\", \"Lt\", "
"\"Lu\", \"Ll\", or \"Lo\".  Note that this is different from the `Alphabetic "
"property defined in the section 4.10 'Letters, Alphabetic, and Ideographic' "
"of the Unicode Standard <https://www.unicode.org/versions/Unicode15.0.0/ch04."
"pdf>`_."
msgstr ""
"Retorna ``True`` si todos los caracteres de la cadena son alfabéticos y hay, "
"al menos, un carácter, en caso contrario, retorna ``False``. Los caracteres "
"alfabéticos son aquellos definidos en la base de datos de Unicode como "
"\"Letter\", es decir, aquellos cuya propiedad de categoría general es "
"\"Lm\", \"Lt\", \"Lu\", \"Ll\" o \"Lo\". Nótese que esta definición de "
"\"Alfabético\" es diferente de la que usa el estándar Unicode."

#: ../Doc/library/stdtypes.rst:1813
msgid ""
"Return ``True`` if the string is empty or all characters in the string are "
"ASCII, ``False`` otherwise. ASCII characters have code points in the range "
"U+0000-U+007F."
msgstr ""
"Retorna ``True`` si la cadena de caracteres está vacía, o si todos los "
"caracteres de la cadena son ASCII, en caso contrario, retorna ``False``. Los "
"caracteres ASCII son aquellos cuyos puntos de código Unicode que están en el "
"rango U+0000-U+007F."

#: ../Doc/library/stdtypes.rst:1822
msgid ""
"Return ``True`` if all characters in the string are decimal characters and "
"there is at least one character, ``False`` otherwise. Decimal characters are "
"those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC "
"DIGIT ZERO.  Formally a decimal character is a character in the Unicode "
"General Category \"Nd\"."
msgstr ""
"Retorna ``True`` si todos los caracteres de la cadena son caracteres "
"decimales y hay, al menos, un carácter, en caso contrario, retorna "
"``False``. Los caracteres decimales son aquellos que se pueden usar para "
"formar números en base 10, por ejemplo, U+0660, ARABIC-INDIC DIGIT ZERO. "
"Formalmente, un carácter decimal es un carácter en la categoría general "
"\"`Nd`\" de Unicode."

#: ../Doc/library/stdtypes.rst:1832
msgid ""
"Return ``True`` if all characters in the string are digits and there is at "
"least one character, ``False`` otherwise.  Digits include decimal characters "
"and digits that need special handling, such as the compatibility superscript "
"digits. This covers digits which cannot be used to form numbers in base 10, "
"like the Kharosthi numbers.  Formally, a digit is a character that has the "
"property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""
"Retorna ``True`` si todos los caracteres de la cadena son dígitos y hay, al "
"menos, un carácter, en caso contrario, retorna ``False``. Los dígitos "
"incluyen los caracteres decimales y dígitos que requieren un tratamiento "
"especial, como por ejemplo los usados para superíndices. Esto incluye "
"dígitos que no pueden ser usados para formar números en base 10, como los "
"números Kharosthi. Formalmente, un dígito es un carácter que tiene la "
"propiedad ``Numeric_Type`` definida como ``Digit`` o ``Decimal``."

#: ../Doc/library/stdtypes.rst:1842
msgid ""
"Return ``True`` if the string is a valid identifier according to the "
"language definition, section :ref:`identifiers`."
msgstr ""
"Retorna ``True`` si la cadena de caracteres es un identificador válido de "
"acuerdo a la especificación del lenguaje, véase :ref:`identifiers`."

#: ../Doc/library/stdtypes.rst:1845
#, fuzzy
msgid ""
":func:`keyword.iskeyword` can be used to test whether string ``s`` is a "
"reserved identifier, such as :keyword:`def` and :keyword:`class`."
msgstr ""
"Se puede usar la función :func:`keyword.iskeyword` para comprobar si la "
"cadena ``s`` es un identificador reservado, como :keyword:`def` o :keyword:"
"`class`."

#: ../Doc/library/stdtypes.rst:1848
msgid "Example: ::"
msgstr "Ejemplo: ::"

#: ../Doc/library/stdtypes.rst:1861
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Retorna ``True`` si todos los caracteres de la cadena que tengan formas en "
"mayúsculas y minúsculas [4]_ están en minúsculas y hay, al menos, un "
"carácter de ese tipo, en caso contrario, retorna ``False``."

#: ../Doc/library/stdtypes.rst:1867
msgid ""
"Return ``True`` if all characters in the string are numeric characters, and "
"there is at least one character, ``False`` otherwise. Numeric characters "
"include digit characters, and all characters that have the Unicode numeric "
"value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""
"Retorna ``True`` si todos los caracteres de la cadena son caracteres "
"numéricos y hay, al menos, un carácter, en caso contrario, retorna "
"``False``. Los caracteres numéricos incluyen los dígitos, y todos los "
"caracteres Unicode que tienen definida la propiedad de valor numérico, por "
"ejemplo U+2155, VULGAR FRACTION ONE FIFTH. Formalmente, los caracteres "
"numéricos son aquellos que la propiedad ``Numeric_Type`` definida como "
"``Digit``, ``Decimal`` o ``Numeric``."

#: ../Doc/library/stdtypes.rst:1877
msgid ""
"Return ``True`` if all characters in the string are printable or the string "
"is empty, ``False`` otherwise.  Nonprintable characters are those characters "
"defined in the Unicode character database as \"Other\" or \"Separator\", "
"excepting the ASCII space (0x20) which is considered printable.  (Note that "
"printable characters in this context are those which should not be escaped "
"when :func:`repr` is invoked on a string.  It has no bearing on the handling "
"of strings written to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""
"Retorna ``True`` si todos los caracteres de la cadena son imprimibles o si "
"la cadena está vacía, en caso contrario, retorna ``False``. Los caracteres "
"no imprimibles son aquellos definidos en la base de datos de Unicode como "
"\"*Other*\" o \"*Separator*\", con la excepción del carácter ASCII espacio "
"(0x20), que se considera imprimible. (Nótese que en este contexto, "
"imprimible son aquellos caracteres que no necesitan ser escapados cuando se "
"imprimen con la función :func:`repr`. No tiene relevancia en cadenas "
"escritas a :data:`sys.stdout` o :data:`sys.stderr`.)"

#: ../Doc/library/stdtypes.rst:1888
msgid ""
"Return ``True`` if there are only whitespace characters in the string and "
"there is at least one character, ``False`` otherwise."
msgstr ""
"Retorna ``True`` si todos los caracteres de la cadena son espacios en blanco "
"y hay, al menos, un carácter, en caso contrario, retorna ``False``."

#: ../Doc/library/stdtypes.rst:1891
msgid ""
"A character is *whitespace* if in the Unicode character database (see :mod:"
"`unicodedata`), either its general category is ``Zs`` (\"Separator, "
"space\"), or its bidirectional class is one of ``WS``, ``B``, or ``S``."
msgstr ""
"Un carácter se considera espacio en blanco si, en la base de datos de "
"Unicode (véase :mod:`unicodedata`), está clasificado en la categoría general "
"``Zs`` (\"Separador, espacio\") o la clase bidireccional es ``WS``, ``B`` o "
"``S``."

#: ../Doc/library/stdtypes.rst:1899
msgid ""
"Return ``True`` if the string is a titlecased string and there is at least "
"one character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return ``False`` "
"otherwise."
msgstr ""
"Retorna ``True`` si las palabras en la cadena tiene forma de título y hay, "
"al menos, un carácter, por ejemplo una mayúscula solo puede aparecer al "
"principio o después de un carácter que no tenga formas alternativas "
"mayúsculas-minúsculas, y las minúsculas solo después de carácter que si "
"tiene formas alternativas mayúsculas-minúsculas. En caso contrario, retorna "
"``False``."

#: ../Doc/library/stdtypes.rst:1906
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Retorna ``True`` si todos los caracteres de la cadena que tengan formas en "
"mayúsculas y minúsculas [4]_ están en mayúsculas y hay, al menos, un "
"carácter de ese tipo, en caso contrario, retorna ``False``."

#: ../Doc/library/stdtypes.rst:1924
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A :"
"exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""
"Retorna una cadena de caracteres formada por la concatenación de las cadenas "
"en el *iterable*. Se lanza una excepción de tipo :exc:`TypeError` si alguno "
"de los elementos en el *iterable* no es una cadena, incluyendo objetos de "
"tipo :class:`bytes`. Se usa como separador entre los elementos la cadena de "
"caracteres pasada como parámetro."

#: ../Doc/library/stdtypes.rst:1932
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Retorna el texto de la cadena, justificado a la izquierda en una cadena de "
"longitud *width*. El carácter de relleno a usar viene definido por el "
"parámetro *fillchar* (por defecto se usa el carácter espacio ASCII). Si la "
"cadena original tiene una longitud ``len(s)`` igual o superior a *width*, se "
"retorna el texto sin modificar."

#: ../Doc/library/stdtypes.rst:1939
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""
"Retorna una copia de la cadena de caracteres con todas las letras en "
"minúsculas [4]_."

#: ../Doc/library/stdtypes.rst:1942
#, fuzzy
msgid ""
"The lowercasing algorithm used is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode15.0.0/ch03.pdf>`__."
msgstr ""
"El algoritmo usado para la conversión a minúsculas está descrito en la "
"sección 3.13 del estándar Unicode."

#: ../Doc/library/stdtypes.rst:1949
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Retorna una copia de la cadena, eliminado determinados caracteres si se "
"encuentren al principio. El parámetro *chars* especifica el conjunto de "
"caracteres a eliminar. Si se omite o si se especifica ``None``, se eliminan "
"todos los espacios en blanco. No debe entenderse el valor de *chars* como un "
"prefijo, sino que se elimina cualquier combinación de sus caracteres::"

#: ../Doc/library/stdtypes.rst:1959
msgid ""
"See :meth:`str.removeprefix` for a method that will remove a single prefix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Véase  :meth:`str.removeprefix` para un método que removerá una única cadena "
"de prefijo en lugar de todas las ocurrencias dentro de un set de caracteres. "
"Por ejemplo::"

#: ../Doc/library/stdtypes.rst:1970
msgid ""
"This static method returns a translation table usable for :meth:`str."
"translate`."
msgstr ""
"Este método estático retorna una tabla de traducción apta para ser usada por "
"el método :meth:`str.translate`."

#: ../Doc/library/stdtypes.rst:1972
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals, "
"strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""
"Si solo se usa un parámetro, este debe ser un diccionario que mapea valores "
"de punto Unicode (enteros) o caracteres (cadenas de longitud 1) a valores "
"Unicode, cadenas (de cualquier longitud) o ``None``. Las claves se "
"convertirán a ordinales."

#: ../Doc/library/stdtypes.rst:1977
msgid ""
"If there are two arguments, they must be strings of equal length, and in the "
"resulting dictionary, each character in x will be mapped to the character at "
"the same position in y.  If there is a third argument, it must be a string, "
"whose characters will be mapped to ``None`` in the result."
msgstr ""
"Si se pasan dos parámetros, deben ser cadenas de la misma longitud, y en la "
"tabla resultante, cada carácter en *x* se mapea al carácter en la misma "
"posición en *y*. Si se añade un tercer parámetro, debe ser una cadena de "
"caracteres, los cuales se mapearán a ``None`` en la tabla resultante."

#: ../Doc/library/stdtypes.rst:1985
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"Divide la cadena en la primera ocurrencia de *sep*, y retorna una tupla de "
"tres elementos, que contiene la parte anterior al separador, el separador en "
"sí y la parte posterior al separador. Si no se encuentra el separador, "
"retorna una tupla de tres elementos, el primero contiene la cadena original "
"y los dos siguientes son cadenas vacías."

#: ../Doc/library/stdtypes.rst:1993
msgid ""
"If the string starts with the *prefix* string, return "
"``string[len(prefix):]``. Otherwise, return a copy of the original string::"
msgstr ""
"Si la cadena de caracteres empieza con la cadena *prefix*, retorna "
"``string[len(prefix):]``. De otra manera, retorna una copia de la cadena "
"original::"

#: ../Doc/library/stdtypes.rst:2007
msgid ""
"If the string ends with the *suffix* string and that *suffix* is not empty, "
"return ``string[:-len(suffix)]``. Otherwise, return a copy of the original "
"string::"
msgstr ""
"Si la cadena de caracteres termina con la cadena *suffix* y *suffix* no está "
"vacío, retorna ``string[:-len(suffix)]``. De otra manera, retorna una copia "
"de la cadena original::"

#: ../Doc/library/stdtypes.rst:2021
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If the optional argument *count* is given, only the first *count* "
"occurrences are replaced."
msgstr ""
"Retorna una copia de la cadena con todas las ocurrencias de la cadena *old* "
"sustituidas por *new*. Si se utiliza el parámetro *count*, solo se cambian "
"las primeras *count* ocurrencias."

#: ../Doc/library/stdtypes.rst:2028
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"Retorna el mayor índice dentro de la cadena *s* donde se puede encontrar la "
"cadena *sub*, estando *sub* incluida en ``s[start:end]``. Los parámetros "
"opcionales *start* y *end* se interpretan igual que en las operaciones de "
"segmentado. Retorna ``-1`` si no se encuentra *sub*."

#: ../Doc/library/stdtypes.rst:2035
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""
"Como el método :meth:`rfind`, pero lanza la excepción :exc:`ValueError` si "
"no se encuentra la cadena *sub*."

#: ../Doc/library/stdtypes.rst:2041
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Retorna el texto de la cadena, justificado a la derecha en una cadena de "
"longitud *width*. El carácter de relleno a usar viene definido por el "
"parámetro *fillchar* (por defecto se usa el carácter espacio ASCII). Si "
"*width* es menor o igual que ``len(s)``, se retorna el texto sin modificar."

#: ../Doc/library/stdtypes.rst:2048
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"Divide la cadena en la última ocurrencia de *sep*, y retorna una tupla de "
"tres elementos, conteniendo la parte anterior al separador, el separador en "
"sí y la parte posterior al separador. Si no se encuentra el separador, "
"retorna una tupla de tres elementos, los dos primeras son posiciones con "
"cadenas vacías y en la tercera la cadena original."

#: ../Doc/library/stdtypes.rst:2056
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"Retorna una lista con las palabras que componen la cadena de caracteres "
"original, usando como separador el valor de *sep*. Si se utiliza el "
"parámetro *maxsplit*, se realizan como máximo *maxsplit* divisiones, "
"retornando los que están más a la derecha. Si no se especifica *sep* o se "
"pasa con valor ``None``, se usa como separador cualquier carácter de espacio "
"en blanco. Si no contamos la diferencia de empezar las divisiones desde la "
"derecha, el comportamiento de este método :meth:`rsplit` es equivalente al "
"de :meth:`split`, que se describe con detalle más adelante."

#: ../Doc/library/stdtypes.rst:2065
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Retorna una copia de la cadena, eliminado determinados caracteres si se "
"encuentren al final. El parámetro *chars* especifica el conjunto de "
"caracteres a eliminar. Si se omite o si se especifica ``None``, se eliminan "
"todos los espacios en blanco. No debe entenderse el valor de *chars* como un "
"sufijo, sino que se elimina cualquier combinación de sus caracteres::"

#: ../Doc/library/stdtypes.rst:2075
msgid ""
"See :meth:`str.removesuffix` for a method that will remove a single suffix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Véase :meth:`str.removesuffix` para un método que removerá una única cadena "
"de sufijo en lugar de todas las ocurrencias dentro de un set de caracteres. "
"Por ejemplo::"

#: ../Doc/library/stdtypes.rst:2085
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"Retorna una lista con las palabras que componen la cadena de caracteres "
"original, usando como separador el valor de *sep*. Si se utiliza el "
"parámetro *maxsplit*, se realizan como máximo *maxsplit* divisiones (por "
"tanto, la lista resultante tendrá ``maxsplit+1`` elementos). Si no se "
"especifica *maxsplit* o se pasa con valor ``-1``, entonces no hay límite al "
"número de divisiones a realizar (se harán todas las que se puedan)."

#: ../Doc/library/stdtypes.rst:2091
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr ""
"Si se especifica *sep*, las repeticiones de caracteres delimitadores no se "
"agrupan juntos, sino que se considera que están delimitando cadenas vacías "
"(por ejemplo, ``'1,,2'.split(',')`` retorna ``['1', '', '2']``). El "
"parámetro *sep* puede contener más de un carácter (por ejemplo, ``'1<>2<>3'."
"split('<>')`` retorna ``['1', '2', '3']``). Dividir una cadena vacía con un "
"separador determinado retornará ``['']``."

#: ../Doc/library/stdtypes.rst:2097 ../Doc/library/stdtypes.rst:2113
#: ../Doc/library/stdtypes.rst:2165 ../Doc/library/stdtypes.rst:2233
#: ../Doc/library/stdtypes.rst:2301 ../Doc/library/stdtypes.rst:3148
#: ../Doc/library/stdtypes.rst:3164 ../Doc/library/stdtypes.rst:3255
#: ../Doc/library/stdtypes.rst:3271 ../Doc/library/stdtypes.rst:3296
#: ../Doc/library/stdtypes.rst:3310 ../Doc/library/stdtypes.rst:3338
#: ../Doc/library/stdtypes.rst:3352 ../Doc/library/stdtypes.rst:3370
#: ../Doc/library/stdtypes.rst:3397 ../Doc/library/stdtypes.rst:3420
#: ../Doc/library/stdtypes.rst:3447 ../Doc/library/stdtypes.rst:3489
#: ../Doc/library/stdtypes.rst:3513
msgid "For example::"
msgstr "Por ejemplo::"

#: ../Doc/library/stdtypes.rst:2106
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"Si no se especifica *sep* o es ``None``, se usa un algoritmo de división "
"diferente: secuencias consecutivas de caracteres de espacio en blanco se "
"consideran como un único separador, y el resultado no contendrá cadenas "
"vacías ni al principio ni al final de la lista, aunque la cadena original "
"tuviera espacios en blanco al principio o al final. En consecuencia, dividir "
"una cadena vacía o una cadena que solo contenga espacios en blanco usando "
"``None`` como separador siempre retornará una lista vacía ``[]``."

#: ../Doc/library/stdtypes.rst:2128
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""
"Retorna una lista con las líneas en la cadena, dividiendo por los saltos de "
"línea. Los caracteres de salto de línea en sí no se incluyen a no ser que se "
"especifique lo contrario pasando el valor ``True`` en al parámetro "
"*keepends*."

#: ../Doc/library/stdtypes.rst:2132
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr ""
"Este método considera como saltos de línea los siguientes caracteres. En "
"concreto, estos son un superconjunto de los :term:`saltos de líneas "
"universales`."

#: ../Doc/library/stdtypes.rst:2136
msgid "Representation"
msgstr "Representación"

#: ../Doc/library/stdtypes.rst:2136
msgid "Description"
msgstr "Descripción"

#: ../Doc/library/stdtypes.rst:2138
msgid "``\\n``"
msgstr "``\\n``"

#: ../Doc/library/stdtypes.rst:2138
msgid "Line Feed"
msgstr "Salto de línea"

#: ../Doc/library/stdtypes.rst:2140
msgid "``\\r``"
msgstr "``\\r``"

#: ../Doc/library/stdtypes.rst:2140
msgid "Carriage Return"
msgstr "Retorno de carro"

#: ../Doc/library/stdtypes.rst:2142
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: ../Doc/library/stdtypes.rst:2142
msgid "Carriage Return + Line Feed"
msgstr "Retorno de carro + salto de línea"

#: ../Doc/library/stdtypes.rst:2144
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` o ``\\x0b``"

#: ../Doc/library/stdtypes.rst:2144
msgid "Line Tabulation"
msgstr "Tabulación de línea"

#: ../Doc/library/stdtypes.rst:2146
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` o ``\\x0c``"

#: ../Doc/library/stdtypes.rst:2146
msgid "Form Feed"
msgstr "Avance de página"

#: ../Doc/library/stdtypes.rst:2148
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: ../Doc/library/stdtypes.rst:2148
msgid "File Separator"
msgstr "Separador de archivo"

#: ../Doc/library/stdtypes.rst:2150
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: ../Doc/library/stdtypes.rst:2150
msgid "Group Separator"
msgstr "Separador de grupo"

#: ../Doc/library/stdtypes.rst:2152
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: ../Doc/library/stdtypes.rst:2152
msgid "Record Separator"
msgstr "Separador de registro"

#: ../Doc/library/stdtypes.rst:2154
msgid "``\\x85``"
msgstr "``\\x85``"

#: ../Doc/library/stdtypes.rst:2154
msgid "Next Line (C1 Control Code)"
msgstr "Siguiente línea (Código de control C1)"

#: ../Doc/library/stdtypes.rst:2156
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: ../Doc/library/stdtypes.rst:2156
msgid "Line Separator"
msgstr "Separador de línea"

#: ../Doc/library/stdtypes.rst:2158
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: ../Doc/library/stdtypes.rst:2158
msgid "Paragraph Separator"
msgstr "Separador de párrafo"

#: ../Doc/library/stdtypes.rst:2163
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "Se añadieron ``\\v`` y ``\\f`` a la lista de separadores."

#: ../Doc/library/stdtypes.rst:2172
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"Al contrario que con :meth:`~str.split`, cuando se especifica una cadena con "
"*sep*, el método retorna una lista vacía para la cadena vacía, y un salto de "
"línea al final del texto no produce una línea extra::"

#: ../Doc/library/stdtypes.rst:2181
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "Por comparación, ``split('\\n')`` entrega::"

#: ../Doc/library/stdtypes.rst:2191
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"Retorna ``True`` si la cadena empieza por *prefix*, en caso contrario "
"retorna ``False``. El valor de *prefix* puede ser también una tupla de "
"prefijos por los que buscar. Con el parámetro opcional *start*, la "
"comprobación empieza en esa posición de la cadena. Con el parámetro opcional "
"*end*, la comprobación se detiene en esa posición de la cadena."

#: ../Doc/library/stdtypes.rst:2199
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Retorna una copia de la cadena con los caracteres indicados eliminados, "
"tanto si están al principio como al final de la cadena. El parámetro "
"opcional *chars* es una cadena que especifica el conjunto de caracteres a "
"eliminar. Si se omite o se usa ``None``, se eliminan los caracteres de "
"espacio en blanco. No debe entenderse el valor de *chars* como un prefijo o "
"sufijo, sino que se elimina cualquier combinación de sus caracteres::"

#: ../Doc/library/stdtypes.rst:2210
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from "
"the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""
"Los caracteres indicados por *chars* se eliminan de los extremos al "
"principio y al final de la cadena. Se elimina los caracteres del inicio "
"hasta que se encuentra un carácter que no esté incluido en el conjunto "
"definido por *chars*. Se procede de manera similar para los caracteres al "
"final. Por ejemplo::"

#: ../Doc/library/stdtypes.rst:2223
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa. Note that it is not necessarily true that ``s.swapcase()."
"swapcase() == s``."
msgstr ""
"Retorna una copia de la cadena con los caracteres en mayúsculas convertidos "
"a minúsculas, y viceversa. Nótese que no es necesariamente cierto que ``s."
"swapcase().swapcase() == s``."

#: ../Doc/library/stdtypes.rst:2230
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""
"Retorna una versión en forma de título de la cadena, con la primera letra de "
"cada palabra en mayúsculas y el resto en minúsculas."

#: ../Doc/library/stdtypes.rst:2238 ../Doc/library/stdtypes.rst:3457
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""
"El algoritmo usa una definición sencilla e independiente del lenguaje, "
"consistente en considerar una palabra como un grupo de letras consecutivas. "
"Esta definición funciona en varios entornos, pero implica que, por ejemplo "
"en inglés, los apóstrofos en las contracciones y en los posesivos "
"constituyen una separación entre palabras, que puede que no sea el efecto "
"deseado::"

#: ../Doc/library/stdtypes.rst:2246
msgid ""
"The :func:`string.capwords` function does not have this problem, as it "
"splits words on spaces only."
msgstr ""
"La función :func:`string.capwords` no tiene este problema, ya que solo "
"divide palabras en espacios."

#: ../Doc/library/stdtypes.rst:2249
msgid ""
"Alternatively, a workaround for apostrophes can be constructed using regular "
"expressions::"
msgstr ""
"Alternativamente, se puede solucionar parcialmente el problema de los "
"apóstrofos usando expresiones regulares::"

#: ../Doc/library/stdtypes.rst:2264
msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`__getitem__`, typically a :term:`mapping` or :term:"
"`sequence`.  When indexed by a Unicode ordinal (an integer), the table "
"object can do any of the following: return a Unicode ordinal or a string, to "
"map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""
"Retorna una copia de la cadena en la que cada carácter ha sido sustituido "
"por su equivalente definido en la tabla de traducción dada. La tabla puede "
"ser cualquier objeto que soporta el acceso mediante índices implementado en "
"método :meth:`__getitem__`, normalmente un objeto de tipo :term:"
"`mapa<mapping>` o :term:`secuencia<sequence>`. Cuando se accede como índice "
"con un código Unicode (un entero), el objeto tabla puede hacer una de las "
"siguientes cosas: retornar otro código Unicode o retornar una cadena de "
"caracteres, de forma que se usarán uno u otro como reemplazo en la cadena de "
"salida; retorna ``None`` para eliminar el carácter en la cadena de salida, o "
"lanza una excepción de tipo :exc:`LookupError`, que hará que el carácter se "
"copie igual en la cadena de salida."

#: ../Doc/library/stdtypes.rst:2273
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from character-"
"to-character mappings in different formats."
msgstr ""
"Se puede usar :meth:`str.maketrans` para crear un mapa de traducción "
"carácter a carácter de diferentes formas."

#: ../Doc/library/stdtypes.rst:2276
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr ""
"Véase también el módulo :mod:`codecs` para una aproximación más flexible al "
"mapeo de caracteres."

#: ../Doc/library/stdtypes.rst:2282
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Retorna una copia de la cadena, con todos los caracteres con formas "
"mayúsculas/minúsculas [4]_ pasados a mayúsculas. Nótese que ``s.upper()."
"isupper()`` puede ser ``False`` si ``s`` contiene caracteres que no tengan "
"las dos formas, o si la categoría Unicode del carácter o caracteres "
"resultantes no es \"Lu\" (Letra, mayúsculas), sino, por ejemplo, "
"\"Lt\" (Letra, Título)."

#: ../Doc/library/stdtypes.rst:2288
#, fuzzy
msgid ""
"The uppercasing algorithm used is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode15.0.0/ch03.pdf>`__."
msgstr ""
"El algoritmo de paso a mayúsculas es el descrito en la sección 3.13 del "
"estándar Unicode."

#: ../Doc/library/stdtypes.rst:2295
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled "
"by inserting the padding *after* the sign character rather than before. The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Retorna una copia de la cadena, rellena por la izquierda con dígitos ``'0'`` "
"de ASCII necesarios para conseguir una cadena de longitud *width*. El "
"carácter prefijo de signo (``'+'``/``'-'``) se gestiona insertando el "
"relleno *después* del carácter de signo en vez de antes. Si *width* es menor "
"o igual que ``len(s)``, se retorna la cadena original."

#: ../Doc/library/stdtypes.rst:2313
msgid "``printf``-style String Formatting"
msgstr "Formateo de cadenas al estilo ``*printf*``"

#: ../Doc/library/stdtypes.rst:2326
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals <f-"
"strings>`, the :meth:`str.format` interface, or :ref:`template strings "
"<template-strings>` may help avoid these errors.  Each of these alternatives "
"provides their own trade-offs and benefits of simplicity, flexibility, and/"
"or extensibility."
msgstr ""
"Las operaciones de formateo explicadas aquí tienen una serie de "
"peculiaridades que conducen a ciertos errores comunes (como fallar al "
"representar tuplas y diccionarios correctamente). Se pueden evitar estos "
"errores usando las nuevas :ref:`cadenas de caracteres con formato <f-"
"strings>`, el método :meth:`str.format`, o :ref:`plantillas de cadenas de "
"caracteres <template-strings>`. Cada una de estas alternativas proporcionan "
"sus propios compromisos entre facilidad de uso, flexibilidad y capacidad de "
"extensión."

#: ../Doc/library/stdtypes.rst:2334
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"in the C language."
msgstr ""
"Las cadenas de caracteres tienen una operación básica: El operador ``%`` "
"(módulo). Esta operación se conoce también como *formateo* de cadenas y "
"operador de interpolación. Dada la expresión ``formato % valores`` (donde "
"*formato* es una cadena), las especificaciones de conversión indicadas en la "
"cadena con el símbolo ``%`` son reemplazadas por cero o más elementos de "
"*valores*. El efecto es similar a usar la función del lenguaje C :c:func:"
"`sprintf`."

#: ../Doc/library/stdtypes.rst:2340
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Si *formato* tiene un único marcador, *valores* puede ser un objeto "
"sencillo, no una tupla. [5]_ En caso contrario, *valores* debe ser una tupla "
"con exactamente el mismo número de elementos que marcadores usados en la "
"cadena de formato, o un único objeto de tipo mapa (por ejemplo, un "
"diccionario)."

#: ../Doc/library/stdtypes.rst:2350 ../Doc/library/stdtypes.rst:3568
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""
"Un especificador de conversión consiste en dos o más caracteres y tiene los "
"siguientes componentes, que deben aparecer en el siguiente orden:"

#: ../Doc/library/stdtypes.rst:2353 ../Doc/library/stdtypes.rst:3571
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "El carácter ``'%'``, que identifica el inicio del marcador."

#: ../Doc/library/stdtypes.rst:2355 ../Doc/library/stdtypes.rst:3573
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""
"Una clave de mapeo (opcional), consistente en una secuencia de caracteres "
"entre paréntesis, como por ejemplo, ``(somename)``."

#: ../Doc/library/stdtypes.rst:2358 ../Doc/library/stdtypes.rst:3576
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""
"Indicador de conversión (opcional), que afecta el resultado de ciertas "
"conversiones de tipos."

#: ../Doc/library/stdtypes.rst:2361 ../Doc/library/stdtypes.rst:3579
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""
"Valor de ancho mínimo (opcional). Si se especifica un ``'*'`` (asterisco), "
"el ancho real se lee del siguiente elemento de la tupla *valores*, y el "
"objeto a convertir viene después del ancho mínimo, con un indicador de "
"precisión opcional."

#: ../Doc/library/stdtypes.rst:2365 ../Doc/library/stdtypes.rst:3583
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""
"Precisión (opcional), en la forma ``'.'`` (punto) seguido de la precisión. "
"Si se especifica un ``'*'`` (asterisco), el valor de precisión real se lee "
"del siguiente elemento de la tupla *valores*, y el valor a convertir viene "
"después de la precisión."

#: ../Doc/library/stdtypes.rst:2370 ../Doc/library/stdtypes.rst:3588
msgid "Length modifier (optional)."
msgstr "Modificador de longitud (opcional)."

#: ../Doc/library/stdtypes.rst:2372 ../Doc/library/stdtypes.rst:3590
msgid "Conversion type."
msgstr "Tipo de conversión."

#: ../Doc/library/stdtypes.rst:2374
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Cuando el operador derecho es un diccionario (o cualquier otro objeto de "
"tipo mapa), los marcadores en la cadena *deben* incluir un valor de clave "
"entre paréntesis, inmediatamente después del carácter ``'%'``. El valor de "
"la clave se usa para seleccionar el valor a formatear desde el mapa. Por "
"ejemplo::"

#: ../Doc/library/stdtypes.rst:2383 ../Doc/library/stdtypes.rst:3601
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""
"En este caso, no se puede usar el especificador ``*`` en la cadena de "
"formato (dado que requiere una lista secuencial de parámetros)."

#: ../Doc/library/stdtypes.rst:2386 ../Doc/library/stdtypes.rst:3604
msgid "The conversion flag characters are:"
msgstr "Los indicadores de conversión son:"

#: ../Doc/library/stdtypes.rst:2395 ../Doc/library/stdtypes.rst:3613
msgid "Flag"
msgstr "Flag"

#: ../Doc/library/stdtypes.rst:2397 ../Doc/library/stdtypes.rst:3615
msgid "``'#'``"
msgstr "``'#'``"

#: ../Doc/library/stdtypes.rst:2397 ../Doc/library/stdtypes.rst:3615
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr ""
"El valor a convertir usara la \"forma alternativa\" (que se definirá más "
"adelante)"

#: ../Doc/library/stdtypes.rst:2400 ../Doc/library/stdtypes.rst:3618
msgid "``'0'``"
msgstr "``'0'``"

#: ../Doc/library/stdtypes.rst:2400 ../Doc/library/stdtypes.rst:3618
msgid "The conversion will be zero padded for numeric values."
msgstr ""
"La conversión rellena con ceros por la izquierda para valores numéricos."

#: ../Doc/library/stdtypes.rst:2402 ../Doc/library/stdtypes.rst:3620
msgid "``'-'``"
msgstr "``'-'``"

# Sobreescribe no me acaba de gustar
#: ../Doc/library/stdtypes.rst:2402 ../Doc/library/stdtypes.rst:3620
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""
"El valor convertido se ajusta a la izquierda (sobreescribe la conversión "
"``'0'`` si se especifican los dos)"

#: ../Doc/library/stdtypes.rst:2405 ../Doc/library/stdtypes.rst:3623
msgid "``' '``"
msgstr "``' '``"

#: ../Doc/library/stdtypes.rst:2405 ../Doc/library/stdtypes.rst:3623
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(Un espacio) Se debe añadir un espacio en blanco antes de un número positivo "
"(o una cadena vacía) si se usa una conversión con signo."

#: ../Doc/library/stdtypes.rst:2408 ../Doc/library/stdtypes.rst:3626
msgid "``'+'``"
msgstr "``'+'``"

#: ../Doc/library/stdtypes.rst:2408 ../Doc/library/stdtypes.rst:3626
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr ""
"Un carácter signo (``'+'`` o ``'-'``) precede a la conversión (sobreescribe "
"el indicador de \"espacio\")"

#: ../Doc/library/stdtypes.rst:2412 ../Doc/library/stdtypes.rst:3630
#, python-format
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"Puede estar presente un modificador de longitud (``h``, ``l`` o ``L``), pero "
"se ignora y no es necesario para Python -- por lo que, por ejemplo, la "
"salida de ``%ld`` es idéntica a ``%d``."

#: ../Doc/library/stdtypes.rst:2415 ../Doc/library/stdtypes.rst:3633
msgid "The conversion types are:"
msgstr "Los tipos de conversión son:"

#: ../Doc/library/stdtypes.rst:2418 ../Doc/library/stdtypes.rst:3636
msgid "Conversion"
msgstr "Conversión"

#: ../Doc/library/stdtypes.rst:2420 ../Doc/library/stdtypes.rst:3638
msgid "``'d'``"
msgstr "``'d'``"

#: ../Doc/library/stdtypes.rst:2420 ../Doc/library/stdtypes.rst:2422
#: ../Doc/library/stdtypes.rst:3638 ../Doc/library/stdtypes.rst:3640
msgid "Signed integer decimal."
msgstr "Entero decimal con signo."

#: ../Doc/library/stdtypes.rst:2422 ../Doc/library/stdtypes.rst:3640
msgid "``'i'``"
msgstr "``'i'``"

#: ../Doc/library/stdtypes.rst:2424 ../Doc/library/stdtypes.rst:3642
msgid "``'o'``"
msgstr "``'o'``"

#: ../Doc/library/stdtypes.rst:2424 ../Doc/library/stdtypes.rst:3642
msgid "Signed octal value."
msgstr "Valor octal con signo."

#: ../Doc/library/stdtypes.rst:2426 ../Doc/library/stdtypes.rst:3644
msgid "``'u'``"
msgstr "``'u'``"

#: ../Doc/library/stdtypes.rst:2426 ../Doc/library/stdtypes.rst:3644
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "Obsoleto -- es idéntico a ``'d'``."

#: ../Doc/library/stdtypes.rst:2428 ../Doc/library/stdtypes.rst:3646
msgid "``'x'``"
msgstr "``'x'``"

#: ../Doc/library/stdtypes.rst:2428 ../Doc/library/stdtypes.rst:3646
msgid "Signed hexadecimal (lowercase)."
msgstr "Hexadecimal con signo (en minúsculas)."

#: ../Doc/library/stdtypes.rst:2430 ../Doc/library/stdtypes.rst:3648
msgid "``'X'``"
msgstr "``'X'``"

#: ../Doc/library/stdtypes.rst:2430 ../Doc/library/stdtypes.rst:3648
msgid "Signed hexadecimal (uppercase)."
msgstr "Hexadecimal con signo (en mayúsculas)."

#: ../Doc/library/stdtypes.rst:2432 ../Doc/library/stdtypes.rst:3650
msgid "``'e'``"
msgstr "``'e'``"

#: ../Doc/library/stdtypes.rst:2432 ../Doc/library/stdtypes.rst:3650
msgid "Floating point exponential format (lowercase)."
msgstr "Formato en coma flotante exponencial (en minúsculas)."

#: ../Doc/library/stdtypes.rst:2434 ../Doc/library/stdtypes.rst:3652
msgid "``'E'``"
msgstr "``'E'``"

#: ../Doc/library/stdtypes.rst:2434 ../Doc/library/stdtypes.rst:3652
msgid "Floating point exponential format (uppercase)."
msgstr "Formato en coma flotante exponencial (en mayúsculas)."

#: ../Doc/library/stdtypes.rst:2436 ../Doc/library/stdtypes.rst:3654
msgid "``'f'``"
msgstr "``'f'``"

#: ../Doc/library/stdtypes.rst:2436 ../Doc/library/stdtypes.rst:2438
#: ../Doc/library/stdtypes.rst:3654 ../Doc/library/stdtypes.rst:3656
msgid "Floating point decimal format."
msgstr "Formato en coma flotante decimal."

#: ../Doc/library/stdtypes.rst:2438 ../Doc/library/stdtypes.rst:3656
msgid "``'F'``"
msgstr "``'F'``"

#: ../Doc/library/stdtypes.rst:2440 ../Doc/library/stdtypes.rst:3658
msgid "``'g'``"
msgstr "``'g'``"

#: ../Doc/library/stdtypes.rst:2440 ../Doc/library/stdtypes.rst:3658
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Formato en coma flotante. Usa formato exponencial con minúsculas si el "
"exponente es menor que -4 o no es menor que la precisión, en caso contrario "
"usa el formato decimal."

#: ../Doc/library/stdtypes.rst:2444 ../Doc/library/stdtypes.rst:3662
msgid "``'G'``"
msgstr "``'G'``"

#: ../Doc/library/stdtypes.rst:2444 ../Doc/library/stdtypes.rst:3662
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Formato en coma flotante. Usa formato exponencial con mayúsculas si el "
"exponente es menor que -4 o no es menor que la precisión, en caso contrario "
"usa el formato decimal."

#: ../Doc/library/stdtypes.rst:2448 ../Doc/library/stdtypes.rst:3666
msgid "``'c'``"
msgstr "``'c'``"

#: ../Doc/library/stdtypes.rst:2448
msgid "Single character (accepts integer or single character string)."
msgstr ""
"Un único carácter (acepta números enteros o cadenas de caracteres de "
"longitud 1)."

#: ../Doc/library/stdtypes.rst:2451 ../Doc/library/stdtypes.rst:3679
msgid "``'r'``"
msgstr "``'r'``"

#: ../Doc/library/stdtypes.rst:2451
msgid "String (converts any Python object using :func:`repr`)."
msgstr ""
"Cadena de caracteres (representará cualquier objeto usando la función :func:"
"`repr`)."

#: ../Doc/library/stdtypes.rst:2454 ../Doc/library/stdtypes.rst:3673
msgid "``'s'``"
msgstr "``'s'``"

#: ../Doc/library/stdtypes.rst:2454
msgid "String (converts any Python object using :func:`str`)."
msgstr ""
"Cadena de caracteres (representará cualquier objeto usando la función :func:"
"`str`)."

#: ../Doc/library/stdtypes.rst:2457 ../Doc/library/stdtypes.rst:3676
msgid "``'a'``"
msgstr "``'a'``"

#: ../Doc/library/stdtypes.rst:2457
msgid "String (converts any Python object using :func:`ascii`)."
msgstr ""
"Cadena de caracteres (representará cualquier objeto usando la función :func:"
"`ascii`)."

#: ../Doc/library/stdtypes.rst:2460 ../Doc/library/stdtypes.rst:3682
msgid "``'%'``"
msgstr "``'%'``"

#: ../Doc/library/stdtypes.rst:2460 ../Doc/library/stdtypes.rst:3682
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr ""
"No se representa ningún argumento, obteniéndose en el resultado la cadena "
"``'%'``."

#: ../Doc/library/stdtypes.rst:2467 ../Doc/library/stdtypes.rst:3689
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr ""
"La forma alternativa hace que se inserte antes del primer dígito un prefijo "
"indicativo del formato octal (``'0o'``)"

#: ../Doc/library/stdtypes.rst:2471 ../Doc/library/stdtypes.rst:3693
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""
"La forma alternativa hace que se inserte antes del primer dígito uno de los "
"dos prefijos indicativos del formato hexadecimal ``'0x'`` o ``'0X'`` (que se "
"use uno u otro depende de que indicador de formato se haya usado, ``'x'`` o "
"``'X'``)."

#: ../Doc/library/stdtypes.rst:2475 ../Doc/library/stdtypes.rst:3697
msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr ""
"La forma alternativa hace que se incluya siempre el símbolo del punto o coma "
"decimal, incluso si no hubiera dígitos después."

#: ../Doc/library/stdtypes.rst:2478 ../Doc/library/stdtypes.rst:3700
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""
"La precisión determina el número de dígitos que vienen después del punto "
"decimal, y por defecto es 6."

#: ../Doc/library/stdtypes.rst:2482 ../Doc/library/stdtypes.rst:3704
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""
"La forma alternativa hace que se incluya siempre el símbolo del punto o coma "
"decimal, y los ceros a su derecha no se eliminan, como seria el caso en la "
"forma normal."

#: ../Doc/library/stdtypes.rst:2485 ../Doc/library/stdtypes.rst:3707
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr ""
"La precisión determina el número de dígitos significativos que vienen antes "
"y después del punto decimal, y por defecto es 6."

#: ../Doc/library/stdtypes.rst:2489 ../Doc/library/stdtypes.rst:3711
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr "Si la precisión es ``N``, la salida se trunca a ``N`` caracteres."

#: ../Doc/library/stdtypes.rst:2492 ../Doc/library/stdtypes.rst:3720
msgid "See :pep:`237`."
msgstr "Véase :pep:`237`."

#: ../Doc/library/stdtypes.rst:2494
#, python-format
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""
"Como en Python las cadenas de caracteres tiene una longitud explícita, la "
"conversión de ``%s`` no requiere que la cadena termine con ``'\\0'``."

#: ../Doc/library/stdtypes.rst:2499
#, python-format
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""
"Las conversiones ``%f`` para números con valores absolutos mayores que 1e50 "
"ya no son reemplazadas por conversiones ``%g``."

#: ../Doc/library/stdtypes.rst:2510
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"
msgstr ""
"Tipos de secuencias binarias --- :class:`bytes`, :class:`bytearray` y :class:"
"`memoryview`"

#: ../Doc/library/stdtypes.rst:2518
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and :"
"class:`bytearray`. They are supported by :class:`memoryview` which uses the :"
"ref:`buffer protocol <bufferobjects>` to access the memory of other binary "
"objects without needing to make a copy."
msgstr ""
"Los tipos básicos para trabajar con datos binarios son las clases :class:"
"`bytes` y :class:`bytearray`. Ambas pueden ser usadas por la clase :class:"
"`memoryview`, que usa el :ref:`protocolo buffer <bufferobjects>` para "
"acceder a la memoria de otros objetos binarios sin necesidad de hacer una "
"copia."

#: ../Doc/library/stdtypes.rst:2523
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ""
"El módulo :mod:`array` soporta un almacenamiento eficiente de tipos de datos "
"básicos como enteros de 32 bits o números en formato de doble precisión en "
"coma flotante IEEE754."

#: ../Doc/library/stdtypes.rst:2529
msgid "Bytes Objects"
msgstr "Objetos de tipo Bytes"

#: ../Doc/library/stdtypes.rst:2533
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""
"Los objetos *bytes* son secuencias inmutables de bytes. Como muchos de los "
"protocolos binarios más usados se basan en la codificación ASCII para texto, "
"los objetos *bytes* ofrecen varios métodos que solo son válidos cuando se "
"trabaja con datos compatibles ASCII y son, en varios aspectos, muy cercanos "
"a los cadenas de caracteres."

#: ../Doc/library/stdtypes.rst:2540
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr ""
"Para empezar, la sintaxis de los valores literales de *bytes* son "
"prácticamente iguales que para las cadenas de caracteres, con la diferencia "
"de que se añade el carácter ``b`` como prefijo:"

#: ../Doc/library/stdtypes.rst:2543
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr ""
"Comillas sencillas: ``b'Se siguen aceptando comillas \"dobles\" embebidas'``"

#: ../Doc/library/stdtypes.rst:2544
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``"
msgstr ""
"Comillas dobles: ``b\"Se siguen aceptando comillas 'simples' embebidas\"``"

#: ../Doc/library/stdtypes.rst:2545
msgid ""
"Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr ""
"Comillas triples: ``b'''3 comillas simples'''``, ``b\"\"\"3 comillas "
"dobles\"\"\"``"

#: ../Doc/library/stdtypes.rst:2547
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""
"Solo se admiten caracteres ASCII en representaciones literales de *bytes* "
"(con independencia del tipo de codificación declarado). Cualquier valor por "
"encima de 127 debe ser definido usando su secuencia de escape."

#: ../Doc/library/stdtypes.rst:2551
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""
"Al igual que con las cadenas, los literales de *bytes* pueden usar el "
"prefijo ``r`` para deshabilitar el procesado de las secuencias de escape. "
"Véase :ref:`strings` para más información acerca de los diferentes formas de "
"expresar *bytes* de forma literal, incluyendo el soporte de secuencias de "
"escape."

#: ../Doc/library/stdtypes.rst:2555
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`). This is done "
"deliberately to emphasise that while many binary formats include ASCII based "
"elements and can be usefully manipulated with some text-oriented algorithms, "
"this is not generally the case for arbitrary binary data (blindly applying "
"text processing algorithms to binary data formats that are not ASCII "
"compatible will usually lead to data corruption)."
msgstr ""
"Aunque las secuencias de bytes y sus representaciones se basen en texto "
"ASCII, los objetos *bytes* se comportan más como secuencias inmutables de "
"números enteros, donde cada elemento de la secuencia está restringido a los "
"valores de *x* tal que ``0 <= x < 256`` (si se intenta violar esta "
"restricción se lanzará una excepción de tipo :exc:`ValueError`). Esto se ha "
"hecho de forma intencionada para enfatizar que, aunque muchos formatos "
"binarios incluyen elementos basados en caracteres ASCII y pueden ser "
"manipulados mediante algunas técnicas de procesado de textos, este no es el "
"caso general para los datos binarios (aplicar algoritmos pensados para "
"proceso de textos a datos binarios que no se compatibles con ASCII "
"normalmente corromperán dichos datos)."

#: ../Doc/library/stdtypes.rst:2565
msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr ""
"Además de con literales, se pueden crear objetos de tipo *byte* de las "
"siguientes maneras:"

#: ../Doc/library/stdtypes.rst:2568
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr ""
"Un secuencia de una longitud especificada rellena con ceros: ``bytes(10)``"

#: ../Doc/library/stdtypes.rst:2569
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr "A partir de un iterable de números enteros: ``bytes(range(20))``"

#: ../Doc/library/stdtypes.rst:2570
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr ""
"Copiando datos binarios ya existentes mediante el protocolo *buffer*: "
"``bytes(obj)``"

#: ../Doc/library/stdtypes.rst:2572
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr "Véase además la función incorporada :ref:`bytes <func-bytes>`."

#: ../Doc/library/stdtypes.rst:2574
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr ""
"Como dos dígitos hexadecimales se corresponden exactamente con un byte, "
"suelen usase números hexadecimales para describir datos binarios. Por ello, "
"los objetos de tipo *byte* disponen de un método adicional para leer datos "
"en ese formato:"

#: ../Doc/library/stdtypes.rst:2580
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""
"Este método de clase de :class:`bytes` retorna un objeto binario, "
"decodificado a partir de la cadena suministrada como parámetro. La cadena de "
"caracteres debe consistir en dos dígitos hexadecimales por cada byte, "
"ignorándose los caracteres ASCII de espacio en blanco, si los hubiera."

#: ../Doc/library/stdtypes.rst:2587
msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not just "
"spaces."
msgstr ""
"El método :meth:`bytes.fromhex` ignora ahora todos los caracteres ASCII de "
"espacio en blanco, no solo el carácter espacio."

#: ../Doc/library/stdtypes.rst:2591
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr ""
"Existe una función que realiza la operación inversa, es decir, transforma un "
"objeto binario en una representación textual usando hexadecimal."

#: ../Doc/library/stdtypes.rst:2596 ../Doc/library/stdtypes.rst:2681
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr ""
"Retorna una cadena de caracteres que contiene dos dígitos hexadecimales por "
"cada byte de la instancia."

#: ../Doc/library/stdtypes.rst:2602
msgid ""
"If you want to make the hex string easier to read, you can specify a single "
"character separator *sep* parameter to include in the output. By default, "
"this separator will be included between each byte. A second optional "
"*bytes_per_sep* parameter controls the spacing. Positive values calculate "
"the separator position from the right, negative values from the left."
msgstr ""
"Si quieres que la cadena en hexadecimal sea más fácil de leer, se puede "
"especificar un único carácter separador con el parámetro *sep* para que se "
"añada a la salida. Por defecto, este separador se incluirá entre cada byte. "
"Un segundo parámetro opcional, *bytes_per_sep*, controla los espacios. "
"Valores positivos calculan la posición del separador desde la derecha, los "
"negativos lo hacen desde la izquierda."

#: ../Doc/library/stdtypes.rst:2619
msgid ""
":meth:`bytes.hex` now supports optional *sep* and *bytes_per_sep* parameters "
"to insert separators between bytes in the hex output."
msgstr ""
"El método :meth:`bytes.hex` ahora soporta los parámetros opcionales *sep* y "
"*bytes_per_sep*, que permiten insertar separadores entre los bytes de la "
"cadena de salida."

#: ../Doc/library/stdtypes.rst:2623
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes "
"object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""
"Como los objetos de tipo *bytes* son secuencias de números enteros "
"(similares a tuplas), para un objeto binario *b*, ``b[0]`` retorna un "
"entero, mientras que ``b[0:1]`` retorna un objeto de tipo *bytes* de "
"longitud 1. (Mientras que las cadenas de caracteres siempre retornan una "
"cadena de longitud 1, ya sea accediendo por índice o mediante una operación "
"de segmentado)."

#: ../Doc/library/stdtypes.rst:2628
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""
"La representación de los objetos tipo *bytes* usa el formato literal "
"(``b'...'``) ya que es, por lo general, más útil que, digamos, ``bytes([46, "
"46, 46])``. Siempre se puede convertir un objeto binario en una lista de "
"enteros usando ``list(b)``."

#: ../Doc/library/stdtypes.rst:2636
msgid "Bytearray Objects"
msgstr "Objetos de tipo *Bytearray*"

#: ../Doc/library/stdtypes.rst:2640
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ""
"Los objetos de tipo :class:`bytearray` son versiones mutables de los objetos "
"de tipo :class:`bytes`."

#: ../Doc/library/stdtypes.rst:2645
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are "
"always created by calling the constructor:"
msgstr ""
"No existe una sintaxis específica para crear objetos de tipo *bytearray*, "
"hay que crearlos siempre llamando a su constructor:"

#: ../Doc/library/stdtypes.rst:2648
msgid "Creating an empty instance: ``bytearray()``"
msgstr "Creando una secuencia vacía: ``bytearray()``"

#: ../Doc/library/stdtypes.rst:2649
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr ""
"Creando una instancia de una longitud determinada, rellena con ceros: "
"``bytearray(10)``"

#: ../Doc/library/stdtypes.rst:2650
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr "A partir de un iterable de números enteros: ``bytearray(range(20))``"

#: ../Doc/library/stdtypes.rst:2651
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr ""
"Copiando datos binarios ya existentes mediante el protocolo *buffer*: "
"``bytearray(b'Hi!')``"

#: ../Doc/library/stdtypes.rst:2653
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""
"Como los objetos *bytearray* son mutables, soportan todas las operaciones "
"aplicables a tipos :ref:`mutables <typesseq-mutable>`, además de las "
"operaciones propias de los *bytearrays* descritas en :ref:`bytes-methods`."

#: ../Doc/library/stdtypes.rst:2657
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr ""
"Véase también la función incorporada :ref:`bytearray <func-bytearray>`."

#: ../Doc/library/stdtypes.rst:2659
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""
"Como dos dígitos hexadecimales se corresponden exactamente con un byte, "
"suelen usase números hexadecimales para describir datos binarios. Por ello, "
"los objetos de tipo *bytearray* disponen de un método de clase adicional "
"para leer datos en ese formato:"

#: ../Doc/library/stdtypes.rst:2665
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""
"Este método de clase de :class:`bytearray` retorna un objeto *bytearray*, "
"decodificado a partir de la cadena suministrada como parámetro. La cadena de "
"caracteres debe consistir en dos dígitos hexadecimales por cada byte, "
"ignorándose los caracteres ASCII de espacio en blanco, si los hubiera."

#: ../Doc/library/stdtypes.rst:2672
msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not "
"just spaces."
msgstr ""
"El método :meth:`bytearray.fromhex` ignora ahora todos los caracteres ASCII "
"de espacio en blanco, no solo el carácter espacio."

#: ../Doc/library/stdtypes.rst:2676
msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr ""
"Existe una función que realiza la operación inversa, es decir, transforma un "
"objeto *bytearray* en una representación textual usando hexadecimal."

#: ../Doc/library/stdtypes.rst:2689
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`bytearray.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"De forma similar a :meth:`bytes.hex`, :meth:`bytearray.hex` soporta ahora "
"los parámetros opcionales *sep* y *bytes_per_sep* para insertar separadores "
"entre los bytes en la cadena hexadecimal de salida."

#: ../Doc/library/stdtypes.rst:2694
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""
"Como los objetos de tipo *bytearray* son secuencias de números enteros "
"(similares a listas), para un objeto *bytearray* *b*, ``b[0]`` retorna un "
"entero, mientras que ``b[0:1]`` retorna un objeto de tipo *bytearray* de "
"longitud 1. (Mientras que las cadenas de caracteres siempre retornan una "
"cadena de longitud 1, ya sea accediendo por índice o mediante una operación "
"de segmentado)."

#: ../Doc/library/stdtypes.rst:2699
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into "
"a list of integers using ``list(b)``."
msgstr ""
"La representación de los objetos tipo *bytearray* usa el formato literal "
"(``bytearray(b'...')``) ya que es, por lo general, más útil que, digamos, "
"``bytearray([46, 46, 46])``. Siempre se puede convertir un objeto "
"*bytearray* en una lista de enteros usando ``list(b)``."

#: ../Doc/library/stdtypes.rst:2708
msgid "Bytes and Bytearray Operations"
msgstr "Operaciones de *bytes* y *bytearray*"

#: ../Doc/library/stdtypes.rst:2713
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>` "
"sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""
"Ambos tipos, *bytes* y *bytearray* soportan las operaciones :ref:`comunes "
"<typesseq-common>` de las secuencias. Los operadores no funcionan solo con "
"operandos del mismo tipo, sino con cualquier :term:`objeto tipo binario "
"<bytes-like object>`. Gracias a esta flexibilidad, estos tipos pueden "
"combinarse libremente en expresiones sin que se produzcan errores. Sin "
"embargo, el tipo del valor resultante puede depender del orden de los "
"operandos."

#: ../Doc/library/stdtypes.rst:2721
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""
"Los métodos de objetos de tipo *bytes* y *bytesarray* no aceptan cadenas de "
"caracteres como parámetros, de la misma manera que los métodos de las "
"cadenas tampoco aceptan *bytes* como parámetros. Por ejemplo, debes "
"escribir::"

#: ../Doc/library/stdtypes.rst:2728
msgid "and::"
msgstr "y::"

#: ../Doc/library/stdtypes.rst:2733
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""
"Algunas operaciones de *bytes* y *bytearrays* asumen el uso de formatos "
"binarios compatibles ASCII, y por tanto deben ser evitadas cuando trabajamos "
"con datos binarios arbitrarios. Estas restricciones se explican a "
"continuación."

#: ../Doc/library/stdtypes.rst:2738
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr ""
"Usar estas operaciones basadas en ASCII para manipular datos binarios que no "
"se almacenan en un formato basado en ASCII pueden producir corrupción de "
"datos."

#: ../Doc/library/stdtypes.rst:2741
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr ""
"Los siguientes métodos de *bytes* y *bytearrays* pueden ser usados con datos "
"en formatos binarios arbitrarios."

#: ../Doc/library/stdtypes.rst:2747
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Retorna el número de secuencias no solapadas de la subsecuencia *sub* en el "
"rango [*start*, *end*]. Los parámetros opcionales *start* y *end* se "
"interpretan como en las operaciones de segmentado."

#: ../Doc/library/stdtypes.rst:2751 ../Doc/library/stdtypes.rst:2856
#: ../Doc/library/stdtypes.rst:2878 ../Doc/library/stdtypes.rst:2944
#: ../Doc/library/stdtypes.rst:2957
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr ""
"La subsecuencia a buscar puede ser cualquier :term:`objeto tipo binario "
"<bytes-like object>` o un número entero entre 0 y 255."

#: ../Doc/library/stdtypes.rst:2754
msgid ""
"If *sub* is empty, returns the number of empty slices between characters "
"which is the length of the bytes object plus one."
msgstr ""

#: ../Doc/library/stdtypes.rst:2757 ../Doc/library/stdtypes.rst:2868
#: ../Doc/library/stdtypes.rst:2881 ../Doc/library/stdtypes.rst:2947
#: ../Doc/library/stdtypes.rst:2960
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr "También acepta como subsecuencia un número entero entre 0 y 255."

#: ../Doc/library/stdtypes.rst:2764
msgid ""
"If the binary data starts with the *prefix* string, return "
"``bytes[len(prefix):]``. Otherwise, return a copy of the original binary "
"data::"
msgstr ""
"Si los datos binarios comienzan con la cadena *prefix*, retorna "
"``bytes[len(prefix):]``. De otra manera, retorna una copia de los datos "
"binarios originales::"

#: ../Doc/library/stdtypes.rst:2773
msgid "The *prefix* may be any :term:`bytes-like object`."
msgstr ""
"El argumento *prefix* puede ser cualquier :term:`objeto tipo binario <bytes-"
"like object>`."

# La traduccion de in place
#: ../Doc/library/stdtypes.rst:2777 ../Doc/library/stdtypes.rst:2799
#: ../Doc/library/stdtypes.rst:2932 ../Doc/library/stdtypes.rst:3025
#: ../Doc/library/stdtypes.rst:3039 ../Doc/library/stdtypes.rst:3070
#: ../Doc/library/stdtypes.rst:3084 ../Doc/library/stdtypes.rst:3126
#: ../Doc/library/stdtypes.rst:3196 ../Doc/library/stdtypes.rst:3214
#: ../Doc/library/stdtypes.rst:3242 ../Doc/library/stdtypes.rst:3381
#: ../Doc/library/stdtypes.rst:3436 ../Doc/library/stdtypes.rst:3479
#: ../Doc/library/stdtypes.rst:3500 ../Doc/library/stdtypes.rst:3522
#: ../Doc/library/stdtypes.rst:3724
msgid ""
"The bytearray version of this method does *not* operate in place - it always "
"produces a new object, even if no changes were made."
msgstr ""
"La versión *bytearray* de este método *no* opera in situ - siempre produce "
"un nuevo objeto, aún si no se hubiera realizado ningún cambio."

#: ../Doc/library/stdtypes.rst:2786
msgid ""
"If the binary data ends with the *suffix* string and that *suffix* is not "
"empty, return ``bytes[:-len(suffix)]``.  Otherwise, return a copy of the "
"original binary data::"
msgstr ""
"Si los datos binarios terminan con la cadena expresada en *suffix* y el "
"argumento *suffix* no está vacío, retorna ``bytes[:-len(suffix)]``. De otra "
"manera, retorna una copia de los datos binarios originales::"

#: ../Doc/library/stdtypes.rst:2795
msgid "The *suffix* may be any :term:`bytes-like object`."
msgstr ""
"El argumento *suffix* puede ser cualquier :term:`objeto tipo binario <bytes-"
"like object>`."

#: ../Doc/library/stdtypes.rst:2808
msgid "Return the bytes decoded to a :class:`str`."
msgstr ""

#: ../Doc/library/stdtypes.rst:2813
msgid ""
"*errors* controls how decoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, and any other name registered via :func:"
"`codecs.register_error`. See :ref:`error-handlers` for details."
msgstr ""

#: ../Doc/library/stdtypes.rst:2819
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless a decoding error actually occurs, :ref:`devmode` is enabled or a :ref:"
"`debug build <debug-build>` is used."
msgstr ""

#: ../Doc/library/stdtypes.rst:2825
#, fuzzy
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term:"
"`bytes-like object` directly, without needing to make a temporary :class:`!"
"bytes` or :class:`!bytearray` object."
msgstr ""
"Pasando el parámetro *encoding* a la clase :class:`str` permite decodificar "
"cualquier :term:`objeto tipo binario <bytes-like object>` directamente, sin "
"necesidad de crear una objeto temporal de tipo *bytes* o *bytearray*."

#: ../Doc/library/stdtypes.rst:2840
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Retorna ``True`` si los datos binarios acaban con el valor indicado por "
"*suffix*, en caso contrario retorna ``False``. El valor de *suffix* puede "
"ser también una tupla de sufijos para buscar. Con el parámetro opcional "
"*start*, la comparación empieza a partir de esa posición. Si se especifica "
"el parámetro opcional *end*, la comparación termina en esa posición."

#: ../Doc/library/stdtypes.rst:2845
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr ""
"El sufijo (o sufijos) a buscar puede ser cualquier :term:`objeto tipo "
"binario <bytes-like object>`."

#: ../Doc/library/stdtypes.rst:2851
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""
"Retorna el mínimo índice dentro de los datos donde se ha encontrado la "
"subsecuencia *sub*, de forma que *sub* está contenida en el segmento "
"``s[start:end]``. Los parámetros opcionales *start* y *end* se interpretan "
"como en las operaciones de segmentado. Retorna ``-1`` si no se puede "
"encontrar *sub*."

#: ../Doc/library/stdtypes.rst:2861
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"El método :meth:`~bytes.find` se debe usar solo si se necesita saber la "
"posición de *sub*. Si solo se necesita comprobar si *sub* es una parte de "
"*s*, es mejor usar el operador :keyword:`in`::"

#: ../Doc/library/stdtypes.rst:2875
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr ""
"Como :meth:`~bytes.find`, pero lanza una excepción de tipo :exc:`ValueError` "
"si no se encuentra la subsecuencia a buscar."

#: ../Doc/library/stdtypes.rst:2888
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""
"Retorna un objeto de tipo *bytes* o *bytearray* que es la concatenación de "
"las secuencias binarias en *iterable*. Si alguno de los objetos de la "
"secuencia no es un :term:`objeto tipo binario <bytes-like object>` se lanza "
"la excepción :exc:`TypeError`, incluso si son cadenas de caracteres "
"(objetos :class:`str`). El separador entre los distintos elementos es el "
"contenido del objeto *bytes* o *bytearray* usando para invocar el método."

#: ../Doc/library/stdtypes.rst:2899
msgid ""
"This static method returns a translation table usable for :meth:`bytes."
"translate` that will map each character in *from* into the character at the "
"same position in *to*; *from* and *to* must both be :term:`bytes-like "
"objects <bytes-like object>` and have the same length."
msgstr ""
"Este método estático retorna una tabla de traducción apta para ser usada por "
"el método :meth:`bytes.translate`, que mapea cada carácter en *from* en la "
"misma posición en *to*; tanto *from* como *to* deben ser :term:`objetos tipo "
"binario <bytes-like object>` y deben tener la misma longitud."

#: ../Doc/library/stdtypes.rst:2910
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed "
"by two empty bytes or bytearray objects."
msgstr ""
"Divide la secuencia en la primera ocurrencia de *sep*, y retorna una tupla "
"de tres elementos que contiene la parte antes del separador, el separador en "
"sí o una copia de tipo *bytearray* y la parte después del separador. Si no "
"se encuentra el separador, retorna una tupla de tres elementos, con la "
"primera posición ocupada por la secuencia original, y las dos posiciones "
"siguientes rellenas con objetos *bytes* o *bytearray* vacíos."

#: ../Doc/library/stdtypes.rst:2917 ../Doc/library/stdtypes.rst:2974
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr ""
"El separador a buscar puede ser cualquier :term:`objeto tipo binario <bytes-"
"like object>`."

#: ../Doc/library/stdtypes.rst:2923
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""
"Retorna una copia de la secuencia con todas las ocurrencias de *old* "
"sustituidas por *new*. Si se utiliza el parámetro *count*, solo se cambian "
"las primeras *count* ocurrencias."

#: ../Doc/library/stdtypes.rst:2927
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr ""
"La subsecuencia a buscar y su reemplazo puede ser cualquier :term:`objeto "
"tipo binario <bytes-like object>`."

#: ../Doc/library/stdtypes.rst:2939
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""
"Retorna el mayor índice dentro de la secuencia *s* donde se puede encontrar "
"*sub*, estando *sub* incluida en ``s[start:end]``. Los parámetros opcionales "
"*start* y *end* se interpretan igual que en las operaciones de segmentado. "
"Retorna ``-1`` si no se encuentra *sub*."

#: ../Doc/library/stdtypes.rst:2954
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr ""
"Como el método :meth:`~bytes.rfind`, pero lanza la excepción :exc:"
"`ValueError` si no se encuentra *sub*."

#: ../Doc/library/stdtypes.rst:2967
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing two empty bytes or bytearray objects, "
"followed by a copy of the original sequence."
msgstr ""
"Divide la secuencia en la primera ocurrencia de *sep*, y retorna una tupla "
"de tres elementos que contiene la parte antes del separador, el separador en "
"sí o una copia de tipo *bytearray* y la parte después del separador. Si no "
"se encuentra el separador, retorna una tupla de tres elementos, con las dos "
"primeras posiciones rellenas con objetos *bytes* o *bytearray* vacíos, y la "
"tercera posición ocupada por la secuencia original."

#: ../Doc/library/stdtypes.rst:2980
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Retorna ``True`` si los datos binarios empiezan con el valor indicado por "
"*prefix*, en caso contrario retorna ``False``. El valor de *prefix* puede "
"ser también una tupla de prefijos para buscar. Con el parámetro opcional "
"*start*, la comparación empieza a partir de esa posición. Si se especifica "
"el parámetro opcional *end*, la comparación termina en esa posición."

#: ../Doc/library/stdtypes.rst:2985
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr ""
"El prefijo (o prefijos) a buscar puede ser cualquier :term:`objeto tipo "
"binario <bytes-like object>`."

#: ../Doc/library/stdtypes.rst:2991
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""
"Retorna una copia del objeto *bytes* o *bytearray* donde todas las "
"ocurrencias de bytes especificados en el parámetro *delete* han sido "
"borrados, y el resto han sido mapeados a través de la tabla de traducción "
"indicada, que debe ser un objeto de tipo *bytes* con una longitud de 256 "
"elementos."

#: ../Doc/library/stdtypes.rst:2996
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation table."
msgstr ""
"Puedes usar el método :func:`bytes.maketrans` para crear la tabla de "
"traducción."

#: ../Doc/library/stdtypes.rst:2999
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr ""
"Se puede ajustar el parámetro *table* a ``None`` para conseguir una "
"traducción que solo borra caracteres::"

#: ../Doc/library/stdtypes.rst:3005
msgid "*delete* is now supported as a keyword argument."
msgstr "El parámetro *delete* se puede ahora especificar por nombre."

#: ../Doc/library/stdtypes.rst:3009
msgid ""
"The following methods on bytes and bytearray objects have default behaviours "
"that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""
"Los siguientes métodos de los objetos *bytes* y *bytearray* presentan un "
"comportamiento por defecto que asume el uso de formatos binarios compatibles "
"con ASCII, pero aun así pueden ser usados con datos binarios arbitrarios "
"usando los parámetros apropiados. Nótese que todos los métodos de "
"*bytearray* en esta sección nunca operan in situ, sino que siempre retornan "
"objetos nuevos."

#: ../Doc/library/stdtypes.rst:3018
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Retorna una copia del objeto centrado en una secuencia de longitud *width*. "
"El relleno se realiza usando el valor definido en el parámetro *fillbyte* "
"(por defecto, el carácter espacio en ASCII). Para los objetos de tipo :class:"
"`bytes`, se retorna la secuencia original intacta si *width* es menor o "
"igual que ``len(s)``."

#: ../Doc/library/stdtypes.rst:3032
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Retorna una copia del objeto justificado por la izquierda en una secuencia "
"de longitud *width*. El relleno se realiza usando el valor definido en el "
"parámetro *fillbyte* (por defecto, el carácter espacio en ASCII). Para los "
"objetos de tipo :class:`bytes`, se retorna la secuencia original intacta si "
"*width* es menor o igual que ``len(s)``."

#: ../Doc/library/stdtypes.rst:3046
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Retorna una copia de la secuencia con los caracteres iniciales especificados "
"eliminados. El parámetro *chars* es una secuencia binaria que especifica el "
"conjunto bytes a ser eliminados; el nombre hace referencia a que este método "
"se usa normalmente con secuencias de caracteres ASCII. Si no se indica o si "
"se especifica ``None``, el comportamiento por defecto será eliminar los "
"caracteres de espacio ASCII. No debe entenderse el valor de *chars* como un "
"prefijo, sino que se elimina cualquier combinación de sus caracteres::"

#: ../Doc/library/stdtypes.rst:3058
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removeprefix` for a method that will remove a "
"single prefix string rather than all of a set of characters.  For example::"
msgstr ""
"La secuencia binaria que especifica el conjunto bytes a ser eliminados puede "
"ser cualquier :term:`objeto de tipo binario<bytes-like object>`. Véase :meth:"
"`~bytes.removeprefix` para un método que removerá una única cadena de "
"prefijo en lugar de todas las ocurrencias dentro de un set de caracteres. "
"Por ejemplo::"

#: ../Doc/library/stdtypes.rst:3077
msgid ""
"Return a copy of the object right justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Retorna una copia del objeto justificado por la derecha en una secuencia de "
"longitud *width*. El relleno se realiza usando el valor definido en el "
"parámetro *fillbyte* (por defecto, el carácter espacio en ASCII). Para los "
"objetos de tipo :class:`bytes`, se retorna la secuencia original intacta si "
"*width* es menor o igual que ``len(s)``."

#: ../Doc/library/stdtypes.rst:3091
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are "
"done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for "
"splitting from the right, :meth:`rsplit` behaves like :meth:`split` which is "
"described in detail below."
msgstr ""
"Divide una secuencia binaria en subsecuencias del mismo tipo, usando como "
"separador el valor de *sep*. Si se utiliza el parámetro *maxsplit*, se "
"realizan como máximo *maxsplit* divisiones, retornando los que están más a "
"la derecha. Si no se especifica *sep* o se pasa con valor ``None``, se usa "
"como separador el carácter espacio en ASCII. Si no contamos la diferencia de "
"empezar las divisiones desde la derecha, el comportamiento de este método :"
"meth:`rsplit` es equivalente al de :meth:`split`, que se describe con "
"detalle más adelante."

#: ../Doc/library/stdtypes.rst:3102
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Retorna una copia de la cadena, eliminado determinados bytes si se "
"encuentren al final. El parámetro *chars* es una secuencia binaria que "
"especifica el conjunto de bytes a eliminar; el nombre hace referencia a que "
"este método se usa normalmente con secuencias de caracteres ASCII. Si se "
"omite o si se especifica ``None``, se eliminan los caracteres espacio en "
"ASCII. No debe entenderse el valor de *chars* como un prefijo, sino que se "
"elimina cualquier combinación de sus caracteres::"

#: ../Doc/library/stdtypes.rst:3114
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removesuffix` for a method that will remove a "
"single suffix string rather than all of a set of characters.  For example::"
msgstr ""
"La secuencia binaria que especifica el conjunto bytes a ser eliminados puede "
"ser cualquier :term:`objeto de tipo binario<bytes-like object>`. Véase :meth:"
"`~bytes.removesuffix` para un método que removerá una única cadena de sufijo "
"en lugar de todas las ocurrencias dentro de un set de caracteres. Por "
"ejemplo::"

#: ../Doc/library/stdtypes.rst:3133
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""
"Divide una secuencia binaria en subsecuencias del mismo tipo, usando como "
"separador el valor de *sep*. Si se utiliza el parámetro *maxsplit* y es un "
"número positivo, se realizan como máximo *maxsplit* divisiones (resultando "
"en una secuencia de como mucho ``maxsplit+1`` elementos). Si no se "
"especifica *maxsplit* o se pasa ``'-1``, no hay límite al número de "
"divisiones (se hacen todas las posibles divisiones)."

#: ../Doc/library/stdtypes.rst:3139
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence (for example, ``b'1<>2<>3'.split(b'<>')`` returns "
"``[b'1', b'2', b'3']``). Splitting an empty sequence with a specified "
"separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on the type of "
"object being split.  The *sep* argument may be any :term:`bytes-like object`."
msgstr ""
"Si se especifica *sep*, las repeticiones de caracteres delimitadores no se "
"agrupan juntos, sino que se considera que están delimitando cadenas vacías "
"(por ejemplo, ``b'1,,2'.split(b',')`` retorna ``[b'1', b'', b'2']``). El "
"parámetro *sep* puede contener más de un carácter (por ejemplo, ``b'1<>2<>3'."
"split(b'<>')`` retorna ``[b'1', b'2', b'3']``). Dividir una cadena vacía con "
"un separador determinado retornará ``[b'']`` o ``[bytearray(b'')]`` "
"dependiendo del tipo de objeto dividido. El parámetro *sep* puede ser "
"cualquier :term:`objeto tipo binario <bytes-like object>`."

#: ../Doc/library/stdtypes.rst:3157
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting "
"an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""
"Si no se especifica *sep* o es ``None``, se usa un algoritmo de división "
"diferente: secuencias consecutivas de caracteres de espacio en ASCII se "
"consideran como un único separador, y el resultado no contendrá cadenas "
"vacías ni al principio ni al final de la lista, aunque la cadena original "
"tuviera espacios en blanco al principio o al final. En consecuencia, dividir "
"una secuencia vacía o que solo contenga espacios en blanco usando ``None`` "
"como separador siempre retornará una lista vacía ``[]``."

#: ../Doc/library/stdtypes.rst:3178
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is not "
"a prefix or suffix; rather, all combinations of its values are stripped::"
msgstr ""
"Retorna una copia de la secuencia con los bytes indicados eliminados, tanto "
"si están al principio como al final de la cadena. El parámetro opcional "
"*chars* es una secuencia de bytes que especifica el conjunto de caracteres a "
"eliminar; el nombre hace referencia a que este método se usa normalmente con "
"secuencias de caracteres ASCII. Si se omite o se usa ``None``, se eliminan "
"los caracteres de espacio ASCII. No debe entenderse el valor de *chars* como "
"un prefijo o sufijo, sino que se elimina cualquier combinación de sus "
"valores::"

#: ../Doc/library/stdtypes.rst:3191
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr ""
"La secuencia binaria de bytes a eliminar debe ser un :term:`objeto tipo "
"binario <bytes-like object>`."

#: ../Doc/library/stdtypes.rst:3200
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII "
"compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""
"Los siguientes métodos de los objetos *bytes* y *bytearray* asumen el uso de "
"formatos binarios compatibles con ASCII, y no deben ser usados con datos "
"binarios arbitrarios. Nótese que todos los métodos de *bytearray* en esta "
"sección nunca operan in situ, sino que siempre retornan objetos nuevos."

#: ../Doc/library/stdtypes.rst:3208
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII "
"byte values are passed through unchanged."
msgstr ""
"Retorna una copia de la secuencia con cada byte interpretado como un "
"carácter ASCII, y el primer byte en mayúsculas y el resto en minúsculas. Los "
"valores que no sean ASCII no se ven modificados."

#: ../Doc/library/stdtypes.rst:3221
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by "
"one or more ASCII spaces, depending on the current column and the given tab "
"size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If "
"the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""
"Retorna una copia de la secuencia, con todos los caracteres ASCII *tab* "
"reemplazados por uno o más espacios ASCII, dependiendo de la columna actual "
"y del tamaño definido para el tabulador. Las posiciones de tabulación "
"ocurren cada *tabsize* caracteres (siendo el valor por defecto de *tabsize* "
"8, lo que produce las posiciones de tabulación 0, 8, 16,...). Para expandir "
"la secuencia, la columna actual se pone a cero y se va examinando byte a "
"byte. Si se encuentra un tabulador, (``b'\\t'``), se insertan uno o más "
"espacios hasta que sea igual a la siguiente posición de tabulación. (El "
"carácter tabulador en sí es descartado). Si el byte es un indicador de salto "
"de línea (``b'\\n'``) o de retorno (``b'\\r'``), se copia y el valor de "
"columna actual se vuelve a poner a cero. Cualquier otro carácter es copiado "
"sin cambios y hace que el contador de columna se incremente en 1, sin tener "
"en cuenta como se representa impreso el byte::"

#: ../Doc/library/stdtypes.rst:3249
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetical ASCII "
"characters or ASCII decimal digits and the sequence is not empty, ``False`` "
"otherwise. Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Retorna ``True`` si todos los bytes de la secuencia son caracteres "
"alfabéticos ASCII o caracteres decimales ASCII y la secuencia no está vacía, "
"en cualquier otro caso retorna ``False``. Los caracteres alfabéticos ASCII "
"son los bytes incluidos en la secuencia "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. Los caracteres "
"decimales ASCII son los bytes incluidos en la secuencia ``b'0123456789'``."

#: ../Doc/library/stdtypes.rst:3266
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetic ASCII characters "
"and the sequence is not empty, ``False`` otherwise.  Alphabetic ASCII "
"characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Retorna ``True`` si todos los bytes de la secuencia son caracteres "
"alfabéticos ASCII y la secuencia no está vacía, en cualquier otro caso "
"retorna ``False``. Los caracteres alfabéticos ASCII son los bytes incluidos "
"en la secuencia ``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."

#: ../Doc/library/stdtypes.rst:3282
msgid ""
"Return ``True`` if the sequence is empty or all bytes in the sequence are "
"ASCII, ``False`` otherwise. ASCII bytes are in the range 0-0x7F."
msgstr ""
"Retorna ``True`` si la secuencia está vacía o si todos los bytes de la "
"secuencia son caracteres ASCII, en cualquier otro caso retorna ``False``. "
"Los caracteres ASCII son los bytes incluidos en el rango 0-0x7F."

#: ../Doc/library/stdtypes.rst:3292
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII decimal digits and "
"the sequence is not empty, ``False`` otherwise. ASCII decimal digits are "
"those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Retorna ``True`` si todos los bytes de la secuencia son caracteres decimales "
"ASCII y la secuencia no está vacía, en cualquier otro caso retorna "
"``False``. Los caracteres decimales ASCII son los bytes incluidos en la "
"secuencia ``b'0123456789'``."

#: ../Doc/library/stdtypes.rst:3307
msgid ""
"Return ``True`` if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, ``False`` otherwise."
msgstr ""
"Retorna ``True`` si hay al menos un carácter ASCII en minúsculas, y no hay "
"ningún carácter ASCII en mayúsculas, en cualquier otro caso retorna "
"``False``."

#: ../Doc/library/stdtypes.rst:3317 ../Doc/library/stdtypes.rst:3359
#: ../Doc/library/stdtypes.rst:3375 ../Doc/library/stdtypes.rst:3425
#: ../Doc/library/stdtypes.rst:3494
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Los caracteres ASCII en minúsculas son los bytes incluidos en la secuencia "
"``b'abcdefghijklmnopqrstuvwxyz'``. Los caracteres ASCII en mayúsculas son "
"los bytes en la secuencia ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."

#: ../Doc/library/stdtypes.rst:3325
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, ``False`` otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""
"Retorna ``True`` si todos los bytes de la secuencia son caracteres ASCII de "
"espacio en blanco y la secuencia no está vacía, en cualquier otro caso "
"retorna ``False``. Los caracteres de espacio en blanco ASCII son los bytes "
"incluidos en la secuencia ``b' \\t\\n\\r\\x0b\\f'`` (espacio, tabulador, "
"nueva línea, retorno de carro, tabulador vertical y avance de página)."

#: ../Doc/library/stdtypes.rst:3334
msgid ""
"Return ``True`` if the sequence is ASCII titlecase and the sequence is not "
"empty, ``False`` otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""
"Retorna ``True`` si la secuencia ASCII está en forma de título, y la "
"secuencia no está vacía, en cualquier otro caso retorna ``False``. Véase el "
"método :meth:`bytes.title` para más detalles en la definición de \"En forma "
"de título\"."

#: ../Doc/library/stdtypes.rst:3349
msgid ""
"Return ``True`` if there is at least one uppercase alphabetic ASCII "
"character in the sequence and no lowercase ASCII characters, ``False`` "
"otherwise."
msgstr ""
"Retorna ``True`` si hay al menos un carácter ASCII en mayúsculas, y no hay "
"ningún carácter ASCII en minúsculas, en cualquier otro caso retorna "
"``False``."

#: ../Doc/library/stdtypes.rst:3367
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr ""
"Retorna una copia de la secuencia con todos los caracteres ASCII en "
"mayúsculas sustituidos por su versión correspondiente en minúsculas."

#: ../Doc/library/stdtypes.rst:3392
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""
"Retorna una lista de las líneas en la secuencia binaria, usando como "
"separadores los :term:`saltos de líneas universales`. Los caracteres usados "
"como separadores no se incluyen en la lista de resultados a no ser que se "
"pase el parámetro *keepends* a ``True``."

#: ../Doc/library/stdtypes.rst:3404
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"Al contrario que el método :meth:`~bytes.split`, cuando se especifica una "
"cadena delimitadora con el parámetro *sep*, este método retorna una lista "
"vacía para la cadena vacía, y un carácter de salto de línea al final de la "
"secuencia no resulta en una línea extra::"

#: ../Doc/library/stdtypes.rst:3417
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr ""
"Retorna una copia de la secuencia con todos los caracteres ASCII en "
"minúsculas sustituidos por su versión correspondiente en mayúsculas, y "
"viceversa."

#: ../Doc/library/stdtypes.rst:3429
msgid ""
"Unlike :func:`str.swapcase()`, it is always the case that ``bin.swapcase()."
"swapcase() == bin`` for the binary versions. Case conversions are "
"symmetrical in ASCII, even though that is not generally true for arbitrary "
"Unicode code points."
msgstr ""
"Al contrario que la función :func:`str.swapcase()`, en este caso siempre se "
"cumple que ``bin.swapcase().swapcase() == bin`` para las versiones binarias. "
"La conversión de mayúsculas a minúsculas son simétricas en ASCII, aunque "
"esto no es el caso general para códigos de punto Unicode."

#: ../Doc/library/stdtypes.rst:3443
msgid ""
"Return a titlecased version of the binary sequence where words start with an "
"uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr ""
"Retorna una versión en forma de título de la secuencia binaria, con la "
"primera letra de cada palabra en mayúsculas y el resto en minúsculas. Los "
"valores de bytes sin mayúsculas y minúsculas se dejan sin modificar."

#: ../Doc/library/stdtypes.rst:3452
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""
"Los caracteres ASCII en minúsculas son los bytes incluidos en la secuencia "
"``b'abcdefghijklmnopqrstuvwxyz'``. Los caracteres ASCII en mayúsculas son "
"los bytes en la secuencia ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. El resto de los "
"caracteres no presentan diferencias entre mayúsculas y minúsculas."

#: ../Doc/library/stdtypes.rst:3465
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""
"Se puede solucionar parcialmente el problema de los apóstrofos usando "
"expresiones regulares::"

#: ../Doc/library/stdtypes.rst:3486
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr ""
"Retorna una copia de la secuencia con todos los caracteres ASCII en "
"minúsculas sustituidos por su versión correspondiente en mayúsculas."

#: ../Doc/library/stdtypes.rst:3507
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make "
"a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'``) is "
"handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""
"Retorna una copia de la secuencia rellenada por la izquierda con los "
"caracteres ASCII ``b'0'`` necesarios para conseguir una cadena de longitud "
"*width*. El carácter prefijo de signo (``b'+'``/``b'-'``) se gestiona "
"insertando el relleno *después* del carácter de signo en vez de antes. Para "
"objetos :class:`bytes`, se retorna la secuencia original si *width* es menor "
"o igual que ``len(s)``."

#: ../Doc/library/stdtypes.rst:3529
msgid "``printf``-style Bytes Formatting"
msgstr "Usando el formateo tipo ``printf`` con bytes"

#: ../Doc/library/stdtypes.rst:3546
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""
"Las operaciones de formateo explicadas aquí tienen una serie de "
"peculiaridades que conducen a ciertos errores comunes (como fallar al "
"representar tuplas y diccionarios correctamente). Si el valor a representar "
"es una tupla o un diccionario, hay que envolverlos en una tupla."

#: ../Doc/library/stdtypes.rst:3551
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or "
"*interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with "
"zero or more elements of *values*. The effect is similar to using the :c:"
"func:`sprintf` in the C language."
msgstr ""
"Los objetos binarios (``bytes``/``bytearray``) tienen una operación "
"incorporada: el operador ``%`` (módulo). Esta operación se conoce también "
"como operador de *formateo* o de *interpolación*. Dada la expresión "
"``formato % valores`` (donde *formato* es un objeto binario), las "
"especificaciones de conversión indicadas en la cadena con el símbolo ``%`` "
"son reemplazadas por cero o más elementos de *valores*. El efecto es similar "
"a usar la función del lenguaje C :c:func:`sprintf`."

#: ../Doc/library/stdtypes.rst:3558
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format bytes object, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Si *formato* tiene un único marcador, *valores* puede ser un objeto "
"sencillo, no una tupla. [5]_ En caso contrario, *valores* debe ser una tupla "
"con exactamente el mismo número de elementos que marcadores usados en el "
"objeto binario, o un único objeto de tipo mapa (por ejemplo, un diccionario)."

#: ../Doc/library/stdtypes.rst:3592
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Cuando el argumento derecho es un diccionario (o cualquier otro objeto de "
"tipo mapa), los marcadores en el objeto binario *deben* incluir un valor de "
"clave entre paréntesis, inmediatamente después del carácter ``'%'``. El "
"valor de la clave se usa para seleccionar el valor a formatear desde el "
"mapa. Por ejemplo::"

#: ../Doc/library/stdtypes.rst:3666
msgid "Single byte (accepts integer or single byte objects)."
msgstr "Byte único (acepta números enteros o binarios de un único byte)."

#: ../Doc/library/stdtypes.rst:3669
msgid "``'b'``"
msgstr "``'b'``"

#: ../Doc/library/stdtypes.rst:3669
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or "
"has :meth:`__bytes__`)."
msgstr ""
"Bytes (cualquier objeto que siga el :ref:`protocolo búfer <bufferobjects>` o "
"implemente el método :meth:`__bytes__`)."

#: ../Doc/library/stdtypes.rst:3673
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'s'`` es un alias de ``'b'`` y solo debe ser usado para bases de código "
"Python2/3."

#: ../Doc/library/stdtypes.rst:3676
msgid ""
"Bytes (converts any Python object using ``repr(obj).encode('ascii', "
"'backslashreplace')``)."
msgstr ""
"Bytes (convierte cualquier objeto Python usando ``repr(obj)."
"encode('ascii','backslashreplace')``)."

#: ../Doc/library/stdtypes.rst:3679
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'r'`` es un alias de ``'a'`` y solo debe ser usado para bases de código "
"Python2/3."

#: ../Doc/library/stdtypes.rst:3679
msgid "\\(7)"
msgstr "\\(7)"

#: ../Doc/library/stdtypes.rst:3714
#, python-format
msgid "``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%s'`` está obsoleto, pero no se retirará durante la serie 3.x."

#: ../Doc/library/stdtypes.rst:3717
#, python-format
msgid "``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%r'`` está obsoleto, pero no se retirará durante la serie 3.x."

#: ../Doc/library/stdtypes.rst:3729
#, python-format
msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ":pep:`461` - Añadiendo % formatea a bytes y bytearray"

#: ../Doc/library/stdtypes.rst:3736
msgid "Memory Views"
msgstr "Vistas de memoria"

#: ../Doc/library/stdtypes.rst:3738
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of "
"an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""
"Los objetos de tipo :class:`memoryview` permiten al código Python acceder a "
"los datos internos de objetos que soporten el :ref:`protocolo buffer "
"<bufferobjects>` sin necesidad de hacer copias."

#: ../Doc/library/stdtypes.rst:3744
msgid ""
"Create a :class:`memoryview` that references *object*.  *object* must "
"support the buffer protocol.  Built-in objects that support the buffer "
"protocol include :class:`bytes` and :class:`bytearray`."
msgstr ""
"Crea un :class:`memoryview` que referencia *object*. La variable *object* "
"debe soportar el protocolo buffer. Los objetos incorporados que soportan el "
"protocolo buffer incluyen los :class:`bytes` y :class:`bytearray`."

#: ../Doc/library/stdtypes.rst:3748
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating *object*.  For many simple types such "
"as :class:`bytes` and :class:`bytearray`, an element is a single byte, but "
"other types such as :class:`array.array` may have bigger elements."
msgstr ""
"La clase :class:`memoryview` usa el concepto de *elemento*, que es la unidad "
"de memoria atómica gestionada por el objeto original *object*. Para muchos "
"tipos de datos simples como :class:`bytes` y :class:`bytearray`, un elemento "
"es un único byte, pero otros tipos, como la clase :class:`array.array` "
"pueden tener elementos más grandes."

#: ../Doc/library/stdtypes.rst:3753
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`, which "
"is the nested list representation of the view. If ``view.ndim = 1``, this is "
"equal to the number of elements in the view."
msgstr ""

#: ../Doc/library/stdtypes.rst:3757
msgid ""
"If ``view.ndim == 0``, ``len(view)`` now raises :exc:`TypeError` instead of "
"returning 1."
msgstr ""

#: ../Doc/library/stdtypes.rst:3760
msgid ""
"The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ""

#: ../Doc/library/stdtypes.rst:3763
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ""
"Un objeto de tipo :class:`memoryview` soporta operaciones de segmentado y "
"acceso por índices a sus datos. Un segmentado unidimensional producirá una "
"sub-vista::"

#: ../Doc/library/stdtypes.rst:3776
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is "
"also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""
"Si :class:`~memoryview.format` es uno de los especificadores de formato "
"nativos del módulo :mod:`struct`, el indexado con un número entero o una "
"tupla de números enteros también es posible, y retorna un único *elemento* "
"con el tipo adecuado. Objetos *memoryview* unidimensionales pueden ser "
"indexados con un entero o con una tupla de enteros. Los *memoryview* con "
"múltiples dimensiones pueden ser indexados con tuplas de exactamente *ndim* "
"enteros, donde *ndim* es el número de dimensiones. Vistas *memoryviews* con "
"cero dimensiones pueden ser indexados con una tupla vacía."

#: ../Doc/library/stdtypes.rst:3785
msgid "Here is an example with a non-byte format::"
msgstr "Aquí hay un ejemplo con un formato que no es un byte::"

#: ../Doc/library/stdtypes.rst:3797
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr ""
"Si el objeto usado para crear la vista es modificable, la vista *memoryview* "
"soporta asignación unidimensional mediante segmentos. Sin embargo, no se "
"permite el cambio de tamaño::"

#: ../Doc/library/stdtypes.rst:3818
#, fuzzy
msgid ""
"One-dimensional memoryviews of :term:`hashable` (read-only) types with "
"formats 'B', 'b' or 'c' are also hashable. The hash is defined as ``hash(m) "
"== hash(m.tobytes())``::"
msgstr ""
"Los objetos *memoryviews* de una única dimensión que contienen tipos de "
"datos *hashables* (de solo lectura) con formatos 'B', 'b' o 'c' son también "
"*hashables*. El *hash* se define como ``hash(m) == hash(m.tobytes())``::"

#: ../Doc/library/stdtypes.rst:3830
#, fuzzy
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now :term:`hashable`."
msgstr ""
"Los objetos *memoryviews* de una única dimensión pueden ahora ser usados con "
"operaciones de segmentado. Los objetos *memoryviews* de una única dimensión "
"con formatos 'B', 'b' o 'c' son ahora *hashables*."

#: ../Doc/library/stdtypes.rst:3834
msgid ""
"memoryview is now registered automatically with :class:`collections.abc."
"Sequence`"
msgstr ""
"los objetos *memoryview* son registrados automáticamente con la clase :class:"
"`collections.abc.Sequence`"

#: ../Doc/library/stdtypes.rst:3838
msgid "memoryviews can now be indexed with tuple of integers."
msgstr ""
"los objetos *memoryviews* se pueden ahora acceder usando como índices una "
"tupla de números enteros."

#: ../Doc/library/stdtypes.rst:3841
msgid ":class:`memoryview` has several methods:"
msgstr "La clase :class:`memoryview` tiene varios métodos:"

#: ../Doc/library/stdtypes.rst:3845
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""
"Un objeto *memoryview* y un exportador :pep:`3118` son iguales si sus formas "
"son equivalentes y todos los valores correspondientes son iguales cuando los "
"formatos respectivos de los operandos son interpretados usando la sintaxis "
"de :mod:`struct`."

#: ../Doc/library/stdtypes.rst:3849
msgid ""
"For the subset of :mod:`struct` format strings currently supported by :meth:"
"`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""
"Para el subconjunto de formatos de :mod:`struct` soportados actualmente por :"
"meth:`tolist`, ``v`` y ``w`` son iguales si ``v.tolist() == w.tolist()``::"

#: ../Doc/library/stdtypes.rst:3868
msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr ""
"Si cualquiera de las cadenas de formato no es soportada por el módulo :mod:"
"`struct`, entonces la comparación de los objetos siempre los considerará "
"diferentes (incluso si las cadenas de formato y el contenido del *buffer* "
"son idénticos)::"

#: ../Doc/library/stdtypes.rst:3884
msgid ""
"Note that, as with floating point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr ""
"Nótese que, al igual que con los números en coma flotante, ``v is w`` *no* "
"implica que ``v == w`` para objetos del tipo *memoryview*."

#: ../Doc/library/stdtypes.rst:3887
msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr ""
"Versiones previas comparaban la memoria directamente, sin considerar ni el "
"formato de los elementos ni la estructura lógica del arreglo."

#: ../Doc/library/stdtypes.rst:3893
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr ""
"Retorna los datos en el *buffer* en forma de cadena de bytes. Equivale a "
"llamar al constructor de la clase :class:`bytes` en el objeto *memoryview*::"

#: ../Doc/library/stdtypes.rst:3902
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""
"Para arreglos no contiguos el resultado es igual a la representación en "
"forma de lista aplanada, con todos los elementos convertidos a bytes. El "
"método :meth:`tobytes` soporta todos los formatos de cadenas de caracteres, "
"incluidos aquellos que no se encuentran en la sintaxis del módulo :mod:"
"`struct`."

#: ../Doc/library/stdtypes.rst:3907
msgid ""
"*order* can be {'C', 'F', 'A'}.  When *order* is 'C' or 'F', the data of the "
"original array is converted to C or Fortran order. For contiguous views, 'A' "
"returns an exact copy of the physical memory. In particular, in-memory "
"Fortran order is preserved. For non-contiguous views, the data is converted "
"to C first. *order=None* is the same as *order='C'*."
msgstr ""
"El valor de *order* puede ser {'C', 'F', 'A'}. Cuando *order* es 'C' o 'F', "
"los datos en el arreglo original se convierten al orden de C o Fortran. Para "
"vistas contiguas, 'A' retorna una copia exacta de la memoria física. En "
"particular, el orden en memoria de Fortran se mantiene inalterado. Para "
"vistas no contiguas, los datos se convierten primero a C. Definir "
"*order=None* es lo mismo que *order='C'*."

#: ../Doc/library/stdtypes.rst:3916
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr ""
"Retorna una cadena de caracteres que contiene dos dígitos hexadecimales por "
"cada byte en el *buffer*::"

#: ../Doc/library/stdtypes.rst:3925
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`memoryview.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"De forma similar a :meth:`bytes.hex`, :meth:`memoryview.hex` soporta ahora "
"los parámetros opcionales *sep* y *bytes_per_sep* para insertar separadores "
"entre los bytes en la cadena hexadecimal de salida."

#: ../Doc/library/stdtypes.rst:3932
msgid "Return the data in the buffer as a list of elements. ::"
msgstr "Retorna los datos en el *buffer* como una lista de elementos. ::"

#: ../Doc/library/stdtypes.rst:3942
msgid ""
":meth:`tolist` now supports all single character native formats in :mod:"
"`struct` module syntax as well as multi-dimensional representations."
msgstr ""
"El método :meth:`tolist` soporta ahora todos los formatos nativos de un solo "
"carácter definidos en el módulo :mod:`struct`, así como las representaciones "
"de múltiples dimensiones."

#: ../Doc/library/stdtypes.rst:3949
msgid ""
"Return a readonly version of the memoryview object.  The original memoryview "
"object is unchanged. ::"
msgstr ""
"Retorna una versión de solo lectura del objeto *memoryview*. El objeto "
"original permanece inalterado::"

#: ../Doc/library/stdtypes.rst:3968
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a :"
"class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""
"Libera el buffer subyacente expuesto por el objeto *memoryview*. Muchos "
"objetos realizan operaciones especiales cuando una vista los está "
"conteniendo (por ejemplo, un objeto :class:`bytearray` temporalmente prohíbe "
"el cambio de tamaño); la llamada a *release()* sirve para eliminar estas "
"restricciones (así como para tratar con los recursos pendientes) lo más "
"pronto posible."

#: ../Doc/library/stdtypes.rst:3974
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release()` itself which can be called "
"multiple times)::"
msgstr ""
"Después de que se ha llamado a este método, cualquier operación posterior "
"sobre la vista lanzará una excepción de tipo :class:`ValueError` (excepto "
"por el propio método :meth:`release()`, que puede ser llamado las veces que "
"se quiera)::"

#: ../Doc/library/stdtypes.rst:3985
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr ""
"El protocolo de gestión de contexto puede ser usado para obtener un efecto "
"similar, usando la sentencia ``with``::"

#: ../Doc/library/stdtypes.rst:4001
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself "
"is not copied. Supported casts are 1D -> C-:term:`contiguous` and C-"
"contiguous -> 1D."
msgstr ""
"Transforma el formato o el tamaño de un objeto *memoryview*. El parámetro "
"*shape* por defecto vale ``[byte_length//new_itemsize]``, lo que significa "
"que el resultado será unidimensional. El valor de retorno es un nuevo objeto "
"de tipo *memoryview*, pero el buffer en sí no se copia. Las transformaciones "
"pueden ser 1D -> C-:term:`contiguo` y C-contiguo -> 1D."

#: ../Doc/library/stdtypes.rst:4007
#, fuzzy
msgid ""
"The destination format is restricted to a single element native format in :"
"mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length. "
"Note that all byte lengths may depend on the operating system."
msgstr ""
"El formato de destino está restringido a un único elemento de formato nativo "
"en la sintaxis de :mod:`struct`. Uno de los formatos debe ser un formato de "
"byte ('B', 'b' o 'c'). La longitud en bytes del resultado debe coincidir con "
"la longitud original."

#: ../Doc/library/stdtypes.rst:4013
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr "Transforma de ``1D/long`` a bytes ``1D/unsigned``::"

#: ../Doc/library/stdtypes.rst:4036
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr "Transforma de ``1D/unsigned`` a bytes ``1D/char``::"

#: ../Doc/library/stdtypes.rst:4049
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr "Transforma de ``1D/bytes`` a ``3D/ints`` a caracteres ``1D/signed``::"

#: ../Doc/library/stdtypes.rst:4075
msgid "Cast 1D/unsigned long to 2D/unsigned long::"
msgstr "Transforma de *long* ``1D/unsigned`` a *long* ``2D/unsigned``::"

#: ../Doc/library/stdtypes.rst:4089
msgid "The source format is no longer restricted when casting to a byte view."
msgstr ""
"El formato de origen ya no está restringido cuando se transforma a una vista "
"de bytes."

#: ../Doc/library/stdtypes.rst:4092
msgid "There are also several readonly attributes available:"
msgstr "Hay disponibles varios atributos de solo lectura:"

#: ../Doc/library/stdtypes.rst:4096
msgid "The underlying object of the memoryview::"
msgstr "El objeto subyacente del *memoryview*::"

#: ../Doc/library/stdtypes.rst:4107
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to ``len(m)``::"
msgstr ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. Este es el "
"espacio, medido en bytes, que usará el arreglo en una representación "
"continua. No tiene que ser necesariamente igual a ``len(m)``::"

#: ../Doc/library/stdtypes.rst:4126
msgid "Multi-dimensional arrays::"
msgstr "Arreglos de múltiples dimensiones::"

#: ../Doc/library/stdtypes.rst:4143
msgid "A bool indicating whether the memory is read only."
msgstr "Un booleano que indica si la memoria es de solo lectura."

#: ../Doc/library/stdtypes.rst:4147
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""
"Una cadena de caracteres que contiene el formato (en el estilo del módulo :"
"mod:`struct`) para cada elemento de la vista. Un objeto *memoryview* se "
"puede crear a partir de un exportador con textos de formato arbitrarios, "
"pero algunos métodos (como, por ejemplo, :meth:`tolist`) están restringidos "
"a usar formatos de elementos nativos sencillos."

#: ../Doc/library/stdtypes.rst:4152
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""
"el formato ``'B'`` se gestiona ahora de acuerdo a la sintaxis descrita en el "
"módulo ``struct``. Esto significa que ``memoryview(b'abc')[0] == b'abc'[0] "
"== 97``."

#: ../Doc/library/stdtypes.rst:4158
msgid "The size in bytes of each element of the memoryview::"
msgstr "El tamaño en bytes de cada elemento del objeto *memoryview*::"

#: ../Doc/library/stdtypes.rst:4171
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr ""
"Un número entero que indica cuantas dimensiones de un arreglo multi-"
"dimensional representa la memoria."

#: ../Doc/library/stdtypes.rst:4176
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr ""
"Una tupla de números enteros, de longitud :attr:`ndim`, que indica la forma "
"de la memoria en un arreglo de *N* dimensiones."

#: ../Doc/library/stdtypes.rst:4179 ../Doc/library/stdtypes.rst:4187
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr "Una tupla vacía, en vez de ``None``, cuando ``ndim = 0``."

#: ../Doc/library/stdtypes.rst:4184
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""
"Una tupla de números enteros, de longitud :attr:`ndim`, que indica el tamaño "
"en bytes para acceder a cada dimensión del arreglo."

#: ../Doc/library/stdtypes.rst:4192
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr ""
"De uso interno para los arreglos estilo *PIL*. El valor es solo informativo."

#: ../Doc/library/stdtypes.rst:4196
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr ""
"Un booleano que indica si la memoria es :term:`contiguous` al estilo C."

#: ../Doc/library/stdtypes.rst:4202
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr ""
"Un booleano que indica si la memoria es :term:`contiguous` al estilo Fortran."

#: ../Doc/library/stdtypes.rst:4208
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr "Un booleano que indica si la memoria es :term:`contiguous`."

#: ../Doc/library/stdtypes.rst:4216
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "Conjuntos --- :class:`set`, :class:`frozenset`"

#: ../Doc/library/stdtypes.rst:4220
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""
"Un objeto de tipo :dfn:`set` es una colección no ordenada de distintos "
"objetos :term:`hashable`. Los casos de uso habituales incluyen comprobar la "
"pertenencia al conjunto de un elemento, eliminar duplicados de una secuencia "
"y realizar operaciones matemáticas como la intersección, la unión, la "
"diferencia o la diferencia simétrica. (Para otros tipos de contenedores "
"véanse las clases incorporadas :class:`dict`, :class:`list`, y :class:"
"`tuple`, así como el módulo :mod:`collections`)."

#: ../Doc/library/stdtypes.rst:4227
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"Como otras colecciones, los conjuntos soportan ``x in set``, ``len(set)`` y "
"``for x in set``. Como es una colección sin orden, los conjuntos no "
"registran ni la posición ni el orden de inserción de los elementos. Por lo "
"mismo, los conjuntos no soportan indexado, ni operaciones de segmentado, ni "
"otras capacidades propias de las secuencias."

#: ../Doc/library/stdtypes.rst:4232
msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since "
"it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type "
"is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element "
"of another set."
msgstr ""
"En la actualidad hay dos tipos de conjuntos incorporados: :class:`set` y :"
"class:`frozenset`. La clase :class:`set` es mutable, es decir, el contenido "
"del conjunto puede ser modificado con métodos como :meth:`~set.add` y :meth:"
"`~set.remove`. Como es mutable, no tiene un valor de *hash* y no pueden ser "
"usados como claves de diccionarios ni como elementos de otros conjuntos. La "
"clase :class:`frozenset` es inmutable y :term:`hashable`, es decir, que sus "
"contenidos no pueden ser modificados después de creados. Puede ser usado, "
"por tanto, como claves de diccionario o como elemento de otro conjunto."

#: ../Doc/library/stdtypes.rst:4240
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""
"Se pueden crear conjuntos no vacíos (*sets*, no *frozensets*) escribiendo "
"una lista de elementos separados por comas, entre llaves, por ejemplo "
"``{'jack', 'sjoerd'}``, además de con el constructor de la clase :class:"
"`set`."

#: ../Doc/library/stdtypes.rst:4244
msgid "The constructors for both classes work the same:"
msgstr "El constructor para ambas clases se usa de la misma forma:"

#: ../Doc/library/stdtypes.rst:4249
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"Retorna un nuevo *set* o *frozenset*, tomando los elementos a partir de "
"*iterable*. Los elementos de un conjunto tienen que tener la propiedad de "
"ser :term:`hashable`. Para representar conjuntos anidados, o conjuntos de "
"conjuntos, los conjuntos interiores tienen que ser instancias de :class:"
"`frozenset`. Si no se especifica el parámetro *iterable*, se retorna un "
"conjunto vacío."

#: ../Doc/library/stdtypes.rst:4255
msgid "Sets can be created by several means:"
msgstr "Los conjuntos (*sets*) se pueden construir de diferentes formas:"

#: ../Doc/library/stdtypes.rst:4257
msgid ""
"Use a comma-separated list of elements within braces: ``{'jack', 'sjoerd'}``"
msgstr ""
"Usando una lista de elementos separados por coma entre corchetes: ``{'jack', "
"'sjoerd'}``"

#: ../Doc/library/stdtypes.rst:4258
msgid ""
"Use a set comprehension: ``{c for c in 'abracadabra' if c not in 'abc'}``"
msgstr ""
"Usando un *set comprehention*: ``{c for c in 'abracadabra' if c not in 'abc'}"
"``"

#: ../Doc/library/stdtypes.rst:4259
msgid ""
"Use the type constructor: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"
msgstr ""
"Usando un constructor de tipo: ``set()``, ``set('foobar')``, ``set(['a', "
"'b', 'foo'])``"

#: ../Doc/library/stdtypes.rst:4261
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""
"Las instancias de :class:`set` y :class:`frozenset` proporcionan las "
"siguientes operaciones:"

#: ../Doc/library/stdtypes.rst:4266
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr ""
"Retorna el número de elementos en el conjunto *s* (cardinalidad de *s*)."

#: ../Doc/library/stdtypes.rst:4270
msgid "Test *x* for membership in *s*."
msgstr "Comprueba que el elemento *x* está incluido en *s*."

#: ../Doc/library/stdtypes.rst:4274
msgid "Test *x* for non-membership in *s*."
msgstr "Comprueba que el elemento *x* no está incluido en *s*."

#: ../Doc/library/stdtypes.rst:4278
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""
"Retorna ``True`` si el conjunto no tienen ningún elemento en común con "
"*other*. Dos conjuntos son disjuntos si y solo si su intersección es el "
"conjunto vacío."

#: ../Doc/library/stdtypes.rst:4284
msgid "Test whether every element in the set is in *other*."
msgstr ""
"Comprueba si cada elemento del conjunto también se encuentra en *other*."

#: ../Doc/library/stdtypes.rst:4288
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""
"Comprueba si el conjunto es un subconjunto propio de *other*, es decir, "
"``set <= other and set != other``."

#: ../Doc/library/stdtypes.rst:4294
msgid "Test whether every element in *other* is in the set."
msgstr "Comprueba que cada elemento de *other* está incluido en el conjunto."

#: ../Doc/library/stdtypes.rst:4298
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""
"Comprueba si el conjunto es un superconjunto propio de *other*, es decir, "
"``set >= other and set != other``."

#: ../Doc/library/stdtypes.rst:4304
msgid "Return a new set with elements from the set and all others."
msgstr ""
"Retorna un conjunto nuevo que contiene todos los elementos del conjunto y de "
"*others*."

#: ../Doc/library/stdtypes.rst:4309
msgid "Return a new set with elements common to the set and all others."
msgstr ""
"Retorna un conjunto nuevo que contiene todos los elementos que están a la "
"vez en conjunto y en *others*."

#: ../Doc/library/stdtypes.rst:4314
msgid "Return a new set with elements in the set that are not in the others."
msgstr ""
"Retorna un conjunto nuevo que contiene todos los elementos del conjunto y "
"que no están incluidos en *others*."

#: ../Doc/library/stdtypes.rst:4319
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""
"Retorna un conjunto nuevo que contiene elementos que están incluidos en el "
"conjunto o en *others*, pero no en los dos a la vez."

#: ../Doc/library/stdtypes.rst:4323
msgid "Return a shallow copy of the set."
msgstr "Retorna una copia superficial del conjunto."

#: ../Doc/library/stdtypes.rst:4326
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :"
"meth:`difference`, :meth:`symmetric_difference`, :meth:`issubset`, and :meth:"
"`issuperset` methods will accept any iterable as an argument.  In contrast, "
"their operator based counterparts require their arguments to be sets.  This "
"precludes error-prone constructions like ``set('abc') & 'cbs'`` in favor of "
"the more readable ``set('abc').intersection('cbs')``."
msgstr ""
"Hay que señalar que las versiones de las operaciones que son métodos (no los "
"operadores) como :meth:`union`, :meth:`intersection`, :meth:`difference`, :"
"meth:`symmetric_difference`, :meth:`issubset`, y :meth:`issuperset` aceptan "
"cualquier iterable como parámetro. Por el contrario, los operadores "
"requieren que los argumentos sean siempre conjuntos. Esto evita ciertas "
"construcciones propensas a errores como ``set('abc') & 'cbs'``, favoreciendo "
"el uso de formas más legibles como ``set('abc').intersection('cbs')``."

#: ../Doc/library/stdtypes.rst:4333
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""
"Ambas clases :class:`set` y :class:`frozenset` soportan comparaciones entre "
"sí. Dos conjuntos son iguales si y solo si cada elemento de cada conjunto "
"está incluido en el otro (cada uno de ellos es subconjunto del otro). Un "
"conjunto es menor que otro si y solo si el primero es un subconjunto propio "
"del segundo (es un subconjunto, pero no son iguales). Un conjunto es mayor "
"que otro si y solo si el primero es un superconjunto propio del segundo (es "
"un superconjunto, pero no son iguales)."

#: ../Doc/library/stdtypes.rst:4340
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
"Las instancias de :class:`set` se comparan con las instancias de :class:"
"`frozenset` en base a sus elementos. Por ejemplo ``set('abc') == "
"frozenset('abc')`` retorna ``True`` y lo mismo hace ``set('abc') in "
"set([frozenset('abc')])``."

#: ../Doc/library/stdtypes.rst:4344
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are "
"not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""
"Las comparaciones de subconjunto e igualdad no son tan generales que "
"permitan una función de ordenación total. Por ejemplo, dos conjuntos "
"cualesquiera que no estén vacíos y que sean disjuntos no son iguales y "
"tampoco son subconjuntos uno del otro, así que todas estas operaciones "
"retornan ``False``: ``a<b``, ``a==b`` o ``a>b``."

#: ../Doc/library/stdtypes.rst:4349
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""
"Como los conjuntos solo definen un orden parcial (relaciones de conjuntos), "
"la salida del método :meth:`list.sort` no está definida para listas de "
"conjuntos."

#: ../Doc/library/stdtypes.rst:4352
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr ""
"Los elementos de un conjunto, al igual que las claves de un diccionario, "
"deben ser :term:`hashable`."

#: ../Doc/library/stdtypes.rst:4354
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
"Las operaciones binarias que mezclan instancias de :class:`set` y :class:"
"`frozenset` retornan el tipo del primer operando. Por ejemplo: "
"``frozenset('ab') | set('bc')`` retornará una instancia de :class:"
"`frozenset`."

#: ../Doc/library/stdtypes.rst:4358
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""
"La siguiente tabla muestra las operaciones disponibles para la clase :class:"
"`set` que no son aplicables a los conjuntos inmutables :class:`frozenset`:"

#: ../Doc/library/stdtypes.rst:4364
msgid "Update the set, adding elements from all others."
msgstr ""
"Actualiza el conjunto, añadiendo los elementos que se encuentren en *others*."

#: ../Doc/library/stdtypes.rst:4369
msgid "Update the set, keeping only elements found in it and all others."
msgstr ""
"Actualiza el conjunto, manteniendo solo los elementos que se encuentren en "
"si mismo y en *others*."

#: ../Doc/library/stdtypes.rst:4374
msgid "Update the set, removing elements found in others."
msgstr ""
"Actualiza el conjunto, eliminado los elementos que se encuentren en *others*."

#: ../Doc/library/stdtypes.rst:4379
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr ""
"Actualiza el conjunto, manteniendo solo los elementos que se encuentren en "
"el conjunto o en *others*, pero no en los dos a la vez."

#: ../Doc/library/stdtypes.rst:4383
msgid "Add element *elem* to the set."
msgstr "Añade al conjunto el elemento *elem*."

#: ../Doc/library/stdtypes.rst:4387
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""
"Elimina del conjunto el elemento *elem*. Lanza la excepción :exc:`KeyError` "
"si *elem* no estaba incluido en el conjunto."

#: ../Doc/library/stdtypes.rst:4392
msgid "Remove element *elem* from the set if it is present."
msgstr "Elimina del conjunto el elemento *elem*, si estuviera incluido."

#: ../Doc/library/stdtypes.rst:4396
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr ""
"Elimina y retorna un elemento cualquiera del conjunto. Lanza la excepción :"
"exc:`KeyError` si el conjunto está vacío."

#: ../Doc/library/stdtypes.rst:4401
msgid "Remove all elements from the set."
msgstr "Elimina todos los elementos del conjunto."

#: ../Doc/library/stdtypes.rst:4404
msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""
"Hay que señalar que los métodos (no los operadores) :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, y :meth:"
"`symmetric_difference_update` aceptan cualquier iterable como parámetro."

#: ../Doc/library/stdtypes.rst:4409
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and :"
"meth:`discard` methods may be a set.  To support searching for an equivalent "
"frozenset, a temporary one is created from *elem*."
msgstr ""
"Nótese que el parámetro *elem* de los métodos :meth:`__contains__`, :meth:"
"`remove` y :meth:`discard` puede ser un conjunto. Para soportar la búsqueda "
"por un *frozenset* equivalente se crea uno temporal a partir de *elem*."

#: ../Doc/library/stdtypes.rst:4417
msgid "Mapping Types --- :class:`dict`"
msgstr "Tipos mapa --- :class:`dict`"

#: ../Doc/library/stdtypes.rst:4427
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""
"Un objeto de tipo :term:`mapping` relaciona valores (que deben ser :term:"
"`hashable`) con objetos de cualquier tipo. Los mapas son objetos mutables. "
"En este momento solo hay un tipo estándar de mapa, los :dfn:`dictionary`. "
"(Para otros tipos contenedores, véanse las clases incorporadas :class:"
"`list`, :class:`set`, y :class:`tuple`, así como el módulo :mod:"
"`collections`)."

#: ../Doc/library/stdtypes.rst:4433
#, fuzzy
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys. Values that compare equal (such as ``1``, ``1.0``, "
"and ``True``) can be used interchangeably to index the same dictionary entry."
msgstr ""
"Las claves de un diccionario pueden ser *casi* de cualquier tipo. Los "
"valores que no son :term:`hashable`, como por ejemplo valores que contengan "
"listas, diccionarios u otros tipo mutables (que son comparados por valor, no "
"por referencia) no se pueden usar como claves. Los tipos numéricos, cuando "
"se usan como claves siguen las reglas habituales de la comparación numérica: "
"si dos números se consideran iguales (como ``1`` y ``1.0``), ambos valores "
"pueden ser usados indistintamente para acceder al mismo valor. (Pero hay que "
"tener en cuenta que los ordenadores almacenan algunos números en coma "
"flotante como aproximaciones, por lo que normalmente no es recomendable "
"usarlos como claves)."

#: ../Doc/library/stdtypes.rst:4444
msgid ""
"Return a new dictionary initialized from an optional positional argument and "
"a possibly empty set of keyword arguments."
msgstr ""
"Retorna un diccionario creado a partir de un parámetro opcional por "
"posición, y por una serie de parámetros por nombre, también opcionales."

#: ../Doc/library/stdtypes.rst:4447
msgid "Dictionaries can be created by several means:"
msgstr "Los diccionarios se pueden construir de diferentes formas:"

#: ../Doc/library/stdtypes.rst:4449
msgid ""
"Use a comma-separated list of ``key: value`` pairs within braces: ``{'jack': "
"4098, 'sjoerd': 4127}`` or ``{4098: 'jack', 4127: 'sjoerd'}``"
msgstr ""
"Usando una lista separada por comas de pares ``key: value`` entre llaves: "
"``{'jack': 4098, 'sjoerd': 4127}`` o ``{4098: 'jack', 4127: 'sjoerd'}``"

#: ../Doc/library/stdtypes.rst:4451
msgid "Use a dict comprehension: ``{}``, ``{x: x ** 2 for x in range(10)}``"
msgstr ""
"Usando una comprensión de diccionario: ``{}``, ``{x: x ** 2 for x in "
"range(10)}``"

#: ../Doc/library/stdtypes.rst:4452
msgid ""
"Use the type constructor: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"
msgstr ""
"Usando un constructor de tipo: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"

#: ../Doc/library/stdtypes.rst:4455
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the "
"positional argument must be an :term:`iterable` object.  Each item in the "
"iterable must itself be an iterable with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr ""
"Si no se especifica el parámetro por posición, se crea un diccionario vacío. "
"Si se pasa un parámetro por posición y es un objeto de tipo mapa, se crea el "
"diccionario a partir de las parejas clave-valor definidos en el mapa. Si no "
"fuera un mapa, se espera que el parámetro sea un objeto :term:`iterable`. "
"Cada elemento del iterable debe ser una dupla (una tupla de dos elementos); "
"el primer componente de la dupla se usará como clave y el segundo como valor "
"a almacenar en el nuevo diccionario. Si una clave aparece más de una vez, el "
"último valor será el que se almacene en el diccionario resultante."

#: ../Doc/library/stdtypes.rst:4465
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces "
"the value from the positional argument."
msgstr ""
"Si se usan parámetros por nombre, los nombres de los parámetros y los "
"valores asociados se añaden al diccionario creado a partir del parámetro por "
"posición. Si un valor de clave ya estaba presente, el valor pasado con el "
"parámetro por nombre reemplazará el valor del parámetro por posición."

#: ../Doc/library/stdtypes.rst:4470
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""
"A modo de ejemplo, los siguientes ejemplos retornan todos el mismo "
"diccionario ``{\"one\": 1, \"two\": 2, \"three\": 3}``::"

#: ../Doc/library/stdtypes.rst:4482
msgid ""
"Providing keyword arguments as in the first example only works for keys that "
"are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""
"Si queremos definir claves con parámetros por nombre, como en el primer "
"ejemplo, entonces los valores de clave solo puede ser cadenas de texto "
"conteniendo identificadores de Python válidos. En los otros casos, se puede "
"usar cualquier valor como clave."

#: ../Doc/library/stdtypes.rst:4486
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""
"Estas son las operaciones soportados por los diccionarios (y que, por tanto, "
"deberían ser soportados por los tipos de mapa personalizados):"

#: ../Doc/library/stdtypes.rst:4491
msgid "Return a list of all the keys used in the dictionary *d*."
msgstr "Retorna una lista de todas las claves usadas en el diccionario *d*."

#: ../Doc/library/stdtypes.rst:4495
msgid "Return the number of items in the dictionary *d*."
msgstr "Retorna el número de elementos almacenados en el diccionario *d*."

#: ../Doc/library/stdtypes.rst:4499
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr ""
"Retorna el elemento dentro de *d* almacenado bajo la clave *key*. Lanza una "
"excepción de tipo :exc:`KeyError` si la clave *key* no se encuentra en el "
"diccionario *d*."

#: ../Doc/library/stdtypes.rst:4504
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, :"
"exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot be "
"an instance variable::"
msgstr ""
"Si una subclase de un diccionario define el método :meth:`__missing__` y "
"*key* no está presente, la operación ``d[key]`` llama a este método pasando "
"como parámetro el valor de *key*. La operación ``d[key]`` o bien retorna un "
"valor o lanza la excepción que sea retornada por la llamada a "
"``__missing__(key)``. Ninguna otra operación o método llama a :meth:"
"`__missing__`. Si el método :meth:`__missing__` no está definido, se lanza :"
"exc:`KeyError`. Si se define :meth:`__missing__`, debe ser de forma "
"obligatoria un método, no puede ser una variable de instancia::"

#: ../Doc/library/stdtypes.rst:4523
msgid ""
"The example above shows part of the implementation of :class:`collections."
"Counter`.  A different ``__missing__`` method is used by :class:`collections."
"defaultdict`."
msgstr ""
"El ejemplo anterior muestra parte de la implementación de la clase :class:"
"`collections.Counter`. Otro ejemplo de uso del método ``__missing__`` se "
"puede encontrar en la clase :class:`collections.defaultdict`."

#: ../Doc/library/stdtypes.rst:4529
msgid "Set ``d[key]`` to *value*."
msgstr "Asigna el valor *value* a ``d[key]``."

#: ../Doc/library/stdtypes.rst:4533
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr ""
"Elimina ``d[key]`` de *d*. Lanza una excepción :exc:`KeyError` si *key* no "
"está en el mapa."

#: ../Doc/library/stdtypes.rst:4538
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr ""
"Retorna ``True`` si *d* tiene una entrada en la clave *key*, ``False`` en "
"caso contrario."

#: ../Doc/library/stdtypes.rst:4542
msgid "Equivalent to ``not key in d``."
msgstr "Equivale a ``not key in d``."

#: ../Doc/library/stdtypes.rst:4546
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr ""
"Retorna un iterador que recorre todas las claves de un diccionario. Es una "
"forma abreviada de ``iter(d.keys())``."

#: ../Doc/library/stdtypes.rst:4551
msgid "Remove all items from the dictionary."
msgstr "Elimina todos los elementos del diccionario."

#: ../Doc/library/stdtypes.rst:4555
msgid "Return a shallow copy of the dictionary."
msgstr "Retorna una copia superficial del diccionario."

#: ../Doc/library/stdtypes.rst:4559
msgid ""
"Create a new dictionary with keys from *iterable* and values set to *value*."
msgstr ""
"Crea un nuevo diccionario con las claves obtenidos a partir del *iterable* y "
"con valor *value*."

#: ../Doc/library/stdtypes.rst:4561
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``.  All of the values refer to just a single instance, so "
"it generally doesn't make sense for *value* to be a mutable object such as "
"an empty list.  To get distinct values, use a :ref:`dict comprehension "
"<dict>` instead."
msgstr ""
"El método :meth:`fromkeys` es un método de clase que retorna un diccionario "
"nuevo. El valor de *value* por defecto es ``None``. Todos los valores harán "
"referencia a una única instancia, por lo que en general no tiene sentido que "
"*value* sea un objeto mutable, como una lista vacía. Para poder obtener "
"valores diferentes, se puede usar mejor un :ref:`diccionario por comprensión "
"<dict>`."

#: ../Doc/library/stdtypes.rst:4569
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"Retorna el elemento dentro de *d* almacenado bajo la clave *key*, si *key* "
"está en el diccionario; si no, retorna *default*. El valor de *default* por "
"defecto es ``None``, por lo que esta función nunca lanza la excepción :exc:"
"`KeyError`."

#: ../Doc/library/stdtypes.rst:4575
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr ""
"Retorna una nueva vista de los elementos del diccionario (pares ``(key, "
"value)``). Véase la :ref:`documentación de los objetos vistas <dict-views>`."

#: ../Doc/library/stdtypes.rst:4580
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr ""
"Retorna una nueva vista de las claves del diccionario. Véase la :ref:"
"`documentación de las vistas <dict-views>`."

#: ../Doc/library/stdtypes.rst:4585
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""
"Si *key* está en el diccionario, lo elimina del diccionario y retorna su "
"valor; si no está, retorna *default*. Si no se especifica valor para "
"*default* y la *key* no se encuentra en el diccionario, se lanza la "
"excepción :exc:`KeyError`."

#: ../Doc/library/stdtypes.rst:4591
msgid ""
"Remove and return a ``(key, value)`` pair from the dictionary. Pairs are "
"returned in :abbr:`LIFO (last-in, first-out)` order."
msgstr ""
"Elimina y retorna una pareja ``(key, value)`` del diccionario. Las parejas "
"se retornan en el orden :abbr:`LIFO (*last-in, first-out*: Último en entrar, "
"primero en salir)`."

#: ../Doc/library/stdtypes.rst:4594
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :meth:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""
"El método :meth:`popitem` es útil para recorrer y a la vez vaciar un "
"diccionario, un proceso usado a menudo en algoritmos de conjuntos. Si el "
"diccionario está vacío, llamar a :meth:`popitem` lanza la excepción :exc:"
"`KeyError`."

#: ../Doc/library/stdtypes.rst:4598
msgid ""
"LIFO order is now guaranteed. In prior versions, :meth:`popitem` would "
"return an arbitrary key/value pair."
msgstr ""
"El orden *LIFO* ahora está garantizado. En versiones anteriores, el método :"
"meth:`popitem` retorna una pareja clave/valor arbitraria."

#: ../Doc/library/stdtypes.rst:4604
msgid ""
"Return a reverse iterator over the keys of the dictionary. This is a "
"shortcut for ``reversed(d.keys())``."
msgstr ""
"Retorna un iterador que recorre las claves en orden inverso. Es una forma "
"abreviada de ``reversed(d.keys())``."

#: ../Doc/library/stdtypes.rst:4611
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"Si *key* está incluida en el diccionario, retorna el valor almacenado. Si "
"no, inserta con la clave *key* el valor definido en *default* y retorna "
"*default*. El valor por defecto de *default* es ``None``."

#: ../Doc/library/stdtypes.rst:4617
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""
"Actualiza el diccionario con las parejas clave/valor obtenidas de *other*, "
"escribiendo encima de las claves existentes. Retorna ``None``."

#: ../Doc/library/stdtypes.rst:4620
msgid ""
":meth:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value "
"pairs: ``d.update(red=1, blue=2)``."
msgstr ""
"El método :meth:`update` acepta tanto un diccionario como un iterable que "
"retorna parejas de claves/valor (ya sea como tuplas o como otros iterables "
"de longitud 2). Si se especifican parámetros por nombre, el diccionario se "
"actualiza con esas combinaciones de clave/valor: ``d.update(red=1, blue=2)``."

#: ../Doc/library/stdtypes.rst:4627
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr ""
"Retorna una nueva vista de los valores del diccionario. Véase la :ref:"
"`documentación sobre objetos vistas <dict-views>`."

#: ../Doc/library/stdtypes.rst:4630
msgid ""
"An equality comparison between one ``dict.values()`` view and another will "
"always return ``False``. This also applies when comparing ``dict.values()`` "
"to itself::"
msgstr ""
"Una comparación de igualdad entre una vista ``dict.values()`` y otra siempre "
"retornará ``False``. Esto también pasa cuando se compara ``dict.values()`` "
"consigo mismo::"

#: ../Doc/library/stdtypes.rst:4640
msgid ""
"Create a new dictionary with the merged keys and values of *d* and *other*, "
"which must both be dictionaries. The values of *other* take priority when "
"*d* and *other* share keys."
msgstr ""
"Crea un nuevo diccionario con las claves y valores fusionados de *d* y "
"*other*, por lo cual ambos deben ser diccionarios. Los valores de *other* "
"tienen prioridad cuando *d* y *other* tienen claves compartidas."

#: ../Doc/library/stdtypes.rst:4648
msgid ""
"Update the dictionary *d* with keys and values from *other*, which may be "
"either a :term:`mapping` or an :term:`iterable` of key/value pairs. The "
"values of *other* take priority when *d* and *other* share keys."
msgstr ""
"Actualiza el diccionario *d* con las claves y valores de *other*, el cual "
"podría ser ya sea un a :term:`mapping` o un :term:`iterable` de pares clave/"
"valor. Los valores de *other* tienen prioridad cuando *d* y *other* tienen "
"claves compartidas."

#: ../Doc/library/stdtypes.rst:4654
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs (regardless of ordering). Order comparisons ('<', '<=', '>=', "
"'>') raise :exc:`TypeError`."
msgstr ""
"Los diccionarios se consideran iguales si y solo si tienen el mismo conjunto "
"de parejas ``(key, value)`` (independiente de su orden). Los intentos de "
"comparar usando los operadores '<', '<=', '>=', '>' lanzan una excepción de "
"tipo :exc:`TypeError`."

#: ../Doc/library/stdtypes.rst:4658
msgid ""
"Dictionaries preserve insertion order.  Note that updating a key does not "
"affect the order.  Keys added after deletion are inserted at the end. ::"
msgstr ""
"Los diccionarios mantienen de forma interna el orden de inserción. "
"Actualizar una clave no modifica ese orden. Las claves que vuelven a ser "
"insertadas después de haber sido borradas se añaden al final.::"

#: ../Doc/library/stdtypes.rst:4676
msgid ""
"Dictionary order is guaranteed to be insertion order.  This behavior was an "
"implementation detail of CPython from 3.6."
msgstr ""
"Se garantiza que el orden del diccionario es el de inserción. Este "
"comportamiento era un detalle de implementación en CPython desde la versión "
"3.6."

#: ../Doc/library/stdtypes.rst:4680
msgid "Dictionaries and dictionary views are reversible. ::"
msgstr ""
"Tanto los diccionarios como las vistas basadas en diccionarios son "
"reversibles::"

#: ../Doc/library/stdtypes.rst:4692
msgid "Dictionaries are now reversible."
msgstr "Los diccionarios son ahora reversibles."

#: ../Doc/library/stdtypes.rst:4697
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a :"
"class:`dict`."
msgstr ""
"Se puede usar un objeto de tipo :class:`types.MappingProxyType` para crear "
"una vista de solo lectura de un objeto :class:`dict`."

#: ../Doc/library/stdtypes.rst:4704
msgid "Dictionary view objects"
msgstr "Objetos tipos vista de diccionario"

#: ../Doc/library/stdtypes.rst:4706
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and :meth:"
"`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view "
"reflects these changes."
msgstr ""
"Los objetos retornados por los métodos :meth:`dict.keys`, :meth:`dict."
"values` y :meth:`dict.items` son objetos tipo vista o *view*. Estos objetos "
"proporcionan una vista dinámica del contenido del diccionario, lo que "
"significa que si el diccionario cambia, las vistas reflejan estos cambios."

#: ../Doc/library/stdtypes.rst:4711
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""
"Las vistas de un diccionario pueden ser iteradas para retornar sus datos "
"respectivos, y soportan operaciones de comprobación de pertenencia:"

#: ../Doc/library/stdtypes.rst:4716
msgid "Return the number of entries in the dictionary."
msgstr "Retorna el número de entradas en un diccionario."

#: ../Doc/library/stdtypes.rst:4720
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""
"Retorna un iterador sobre las claves, valores o elementos (representados en "
"forma de tuplas ``(key, value)``) de un diccionario."

#: ../Doc/library/stdtypes.rst:4723
msgid ""
"Keys and values are iterated over in insertion order. This allows the "
"creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``.  Another way to create the same list is ``pairs = "
"[(v, k) for (k, v) in d.items()]``."
msgstr ""
"Las claves y los valores se iteran en orden de inserción. Esto permite la "
"creación de parejas ``(value, key)`` usando la función :func:`zip`: ``pairs "
"= zip(d.values(), d.keys())``. Otra forma de crear la misma lista es ``pairs "
"= [(v, k) for (k, v) in d.items()]``."

#: ../Doc/library/stdtypes.rst:4728
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise "
"a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
"Iterar sobre un diccionario a la vez que se borran o añaden entradas puede "
"lanzar una excepción de tipo :exc:`RuntimeError`, o puede provocar que no se "
"iteren sobre todas las entradas."

#: ../Doc/library/stdtypes.rst:4731
msgid "Dictionary order is guaranteed to be insertion order."
msgstr "Se garantiza que el orden de los diccionarios es el de inserción."

#: ../Doc/library/stdtypes.rst:4736
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"Retorna ``True`` si *x* está incluido en las claves, los valores o los "
"elementos del diccionario (en el último caso, *x* debe ser una tupla ``(key, "
"value)``)."

#: ../Doc/library/stdtypes.rst:4741
msgid ""
"Return a reverse iterator over the keys, values or items of the dictionary. "
"The view will be iterated in reverse order of the insertion."
msgstr ""
"Retorna un iterador inverso sobre las claves, los valores o los elementos "
"del diccionario. El orden de la vista será el inverso del orden de inserción."

#: ../Doc/library/stdtypes.rst:4744
msgid "Dictionary views are now reversible."
msgstr "Las vistas de un diccionario no son reversibles."

#: ../Doc/library/stdtypes.rst:4749
msgid ""
"Return a :class:`types.MappingProxyType` that wraps the original dictionary "
"to which the view refers."
msgstr ""
"Retorna un :class:`types.MappingProxyType` que envuelve el diccionario "
"original al que se refiere la vista."

#: ../Doc/library/stdtypes.rst:4754
#, fuzzy
msgid ""
"Keys views are set-like since their entries are unique and :term:"
"`hashable`.  If all values are hashable, so that ``(key, value)`` pairs are "
"unique and hashable, then the items view is also set-like.  (Values views "
"are not treated as set-like since the entries are generally not unique.)  "
"For set-like views, all of the operations defined for the abstract base "
"class :class:`collections.abc.Set` are available (for example, ``==``, "
"``<``, or ``^``).  While using set operators, set-like views accept any "
"iterable as the other operand, unlike sets which only accept sets as the "
"input."
msgstr ""
"Las vistas de claves son similares a conjuntos, dado que todas las claves "
"deben ser únicas y *hashables*. Si todos los valores son también "
"*hashables*, de forma que las parejas ``(key, value)`` son también únicas y "
"*hashables*, entonces la vista *items* es también similar a un conjunto. (La "
"vista *values* no son consideradas similar a un conjunto porque las valores "
"almacenados en el diccionario no tiene que ser únicos). Las vistas similares "
"a conjuntos pueden usar todas las operaciones definidas en la clase "
"abstracta :class:`collections.abc.Set` (como por ejemplo ``==``, ``<`` o "
"``^``)."

#: ../Doc/library/stdtypes.rst:4763
msgid "An example of dictionary view usage::"
msgstr "Un ejemplo de uso de una vista de diccionario::"

#: ../Doc/library/stdtypes.rst:4807
msgid "Context Manager Types"
msgstr "Tipos gestores de contexto"

#: ../Doc/library/stdtypes.rst:4814
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""
"La expresión :keyword:`with` de Python soporta el concepto de un contexto en "
"tiempo de ejecución definido mediante un gestor de contexto. Para "
"implementar esto, se permite al usuario crear clases para definir estos "
"contextos definiendo dos métodos, uno a ejecutar antes de entrar del bloque "
"de código y otro a ejecutar justo después de salir del mismo:"

#: ../Doc/library/stdtypes.rst:4822
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`!as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""
"Entra en el contexto en tiempo de ejecución, y retorna o bien este objeto u "
"otro relacionado con el contexto. El valor retornado por este método se "
"vincula al identificador que viene tras la palabra clave :keyword:`!as` "
"usada en la sentencia :keyword:`with` que define el contexto."

#: ../Doc/library/stdtypes.rst:4827
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow :func:"
"`open` to be used as the context expression in a :keyword:`with` statement."
msgstr ""
"Un ejemplo de gestor de contexto que se retorna a si mismo es un objeto de "
"tipo :term:`file object`. Los objetos de tipo ``File`` se retornan a si "
"mismo en la llamada a ``__enter__()``, lo que permite que :func:`open` sea "
"usado como gestores de contexto en una sentencia :keyword:`with`."

#: ../Doc/library/stdtypes.rst:4831
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`!with` statement."
msgstr ""
"Un ejemplo de gestor de contexto que retorna otro objeto relacionado en el "
"que define la función :func:`decimal.localcontext`. Este gestor define el "
"contexto de uso en operaciones decimales a partir de una copia del contexto "
"original, y retorna esa copia. De esta manera se puede cambiar el contexto "
"decimal dentro del cuerpo del :keyword:`with` sin afectar al código fuera "
"de :keyword:`!with`."

#: ../Doc/library/stdtypes.rst:4841
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"Sale del contexto y retorna un indicador booleano que indica si se debe "
"ignorar cualquier posible excepción que hubiera ocurrido dentro del mismo. "
"Si se produce una excepción mientras se ejecutan las sentencias definidas en "
"el cuerpo de la sentencia :keyword:`with`, los parámetros de esta función "
"contienen el tipo y valor de la excepción, así como la información relativa "
"a la traza de ejecución. Si no se produce ninguna excepción, los tres "
"parámetros valen ``None``."

#: ../Doc/library/stdtypes.rst:4846
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`!with` statement. Otherwise "
"the exception continues propagating after this method has finished "
"executing. Exceptions that occur during execution of this method will "
"replace any exception that occurred in the body of the :keyword:`!with` "
"statement."
msgstr ""
"Si este método retorna un valor ``True``, la sentencia :keyword:`with` "
"ignora la excepción y el flujo del programa continua con la primera "
"sentencia inmediatamente después de la sentencia :keyword:`!with`. En caso "
"contrario la excepción producida continua propagándose después de que este "
"método termine de ejecutarse. Cualquier excepción que pudieran producirse "
"dentro de este método reemplaza a la excepción que se hubiera producido en "
"el cuerpo del :keyword:`!with`."

#: ../Doc/library/stdtypes.rst:4853
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code to easily detect whether or not an :meth:`__exit__` "
"method has actually failed."
msgstr ""
"La excepción pasada nunca debe volver a lanzarse explícitamente; en vez de "
"eso, el método debería retornar un valor falso para indicar que el método ha "
"terminado de ejecutarse sin problemas y que no se desea suprimir la "
"excepción. Esto permite a los gestores de contexto detectar fácilmente si el "
"método :meth:`__exit__` ha podido terminar o no."

#: ../Doc/library/stdtypes.rst:4859
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"Python define varios gestores de contexto para facilitar la sincronía entre "
"hilos, asegurarse del cierre de ficheros y otros objetos similares y para "
"modificar de forma simple el contexto para las expresiones aritméticas con "
"decimales. Los tipos específicos no se tratan especialmente fuera de su "
"implementación del protocolo de administración de contexto. Véase el módulo :"
"mod:`contextlib` para algunos ejemplos."

#: ../Doc/library/stdtypes.rst:4865
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`~contextmanager.__enter__` and :meth:`~contextmanager.__exit__` methods, "
"rather than the iterator produced by an undecorated generator function."
msgstr ""
"Los :term:`generator` de Python y el decorador definidos en la clase :class:"
"`contextlib.contextmanager` permiten implementar de forma sencilla estos "
"protocolos. Si una función generadora se decora con la clase :class:"
"`contextlib.contextmanager`, retornará un gestor de contexto que incluye los "
"métodos necesarios :meth:`~contextmanager.__enter__` y :meth:"
"`~contextmanager.__exit__`, en vez del iterador que se produciría si no se "
"decora la función generadora."

#: ../Doc/library/stdtypes.rst:4872
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""
"Nótese que no hay una ranura específica para ninguno de estos métodos en la "
"estructura usada para los objetos Python en el nivel de la API de Python/C. "
"Objetos que quieran definir estos métodos deben implementarlos como métodos "
"normales de Python. Comparado con la complejidad de definir un contexto en "
"tiempo de ejecución, lo complejidad de una búsqueda simple en un diccionario "
"es mínima."

#: ../Doc/library/stdtypes.rst:4880
msgid ""
"Type Annotation Types --- :ref:`Generic Alias <types-genericalias>`, :ref:"
"`Union <types-union>`"
msgstr ""
"Tipos de anotaciones de type — :ref:`alias genérico <types-genericalias>`, :"
"ref:`Union <types-union>`"

# Hace referencia al tipo o al objeto 'type'?
#: ../Doc/library/stdtypes.rst:4885
msgid ""
"The core built-in types for :term:`type annotations <annotation>` are :ref:"
"`Generic Alias <types-genericalias>` and :ref:`Union <types-union>`."
msgstr ""
"Los tipos principales integrados para :term:`anotaciones de tipo "
"<annotation>` son :ref:`alias genérico <types-genericalias>` y :ref:`Union "
"<types-union>`."

#: ../Doc/library/stdtypes.rst:4892
msgid "Generic Alias Type"
msgstr "Tipo Alias Genérico"

#: ../Doc/library/stdtypes.rst:4898
msgid ""
"``GenericAlias`` objects are generally created by :ref:`subscripting "
"<subscriptions>` a class. They are most often used with :ref:`container "
"classes <sequence-types>`, such as :class:`list` or :class:`dict`. For "
"example, ``list[int]`` is a ``GenericAlias`` object created by subscripting "
"the ``list`` class with the argument :class:`int`. ``GenericAlias`` objects "
"are intended primarily for use with :term:`type annotations <annotation>`."
msgstr ""
"Los objetos ``GenericAlias`` generalmente se crean para :ref:`suscribir "
"<subscriptions>` a una clase. Se utilizan con mayor frecuencia con :ref:"
"`clases contenedoras <sequence-types>`, como :class:`list` o :class:`dict`. "
"Por ejemplo, ``list[int]`` es un objeto ``GenericAlias`` que se creó para "
"suscribir la clase ``list`` con el argumento :class:`int`. Los objetos "
"``GenericAlias`` están pensados principalmente para usar con :term:"
"`anotaciones de tipo <annotation>`."

#: ../Doc/library/stdtypes.rst:4908
msgid ""
"It is generally only possible to subscript a class if the class implements "
"the special method :meth:`~object.__class_getitem__`."
msgstr ""
"Generalmente solo es posible suscribir a una clase si ésta implementa el "
"método especial :meth:`~object.__class_getitem__`."

#: ../Doc/library/stdtypes.rst:4911
msgid ""
"A ``GenericAlias`` object acts as a proxy for a :term:`generic type`, "
"implementing *parameterized generics*."
msgstr ""
"El objeto ``GenericAlias`` actúa como *proxy* para :term:`tipo genérico "
"<generic type>`, implementando *parameterized generics*."

#: ../Doc/library/stdtypes.rst:4914
msgid ""
"For a container class, the argument(s) supplied to a :ref:`subscription "
"<subscriptions>` of the class may indicate the type(s) of the elements an "
"object contains. For example, ``set[bytes]`` can be used in type annotations "
"to signify a :class:`set` in which all the elements are of type :class:"
"`bytes`."
msgstr ""
"Para una clase contenedora, el argumento (o los argumentos) proporcionado(s) "
"a una :ref:`suscripción <subscriptions>` de la clase puede indicar el tipo "
"(o tipos) de los elementos que contiene un objeto. Por ejemplo, se puede "
"usar ``set[bytes]`` en anotaciones de tipo para significar un :class:`set` "
"en el que todos los elementos son del tipo :class:`bytes`."

#: ../Doc/library/stdtypes.rst:4920
msgid ""
"For a class which defines :meth:`~object.__class_getitem__` but is not a "
"container, the argument(s) supplied to a subscription of the class will "
"often indicate the return type(s) of one or more methods defined on an "
"object. For example, :mod:`regular expressions <re>` can be used on both "
"the :class:`str` data type and the :class:`bytes` data type:"
msgstr ""
"Para una clase que define el método :meth:`~object.__class_getitem__` pero "
"no es un contenedor, el argumento (o los argumentos) proporcionado(s) a una "
"suscripción de la clase a menudo indicarán el tipo (o los tipos) de retorno "
"de uno o más métodos definidos en un objeto. Por ejemplo, las :mod:"
"`expresiones regulares <re>` se pueden usar tanto para el tipo de datos :"
"class:`str` y el tipo de datos :class:`bytes`:"

#: ../Doc/library/stdtypes.rst:4926
msgid ""
"If ``x = re.search('foo', 'foo')``, ``x`` will be a :ref:`re.Match <match-"
"objects>` object where the return values of ``x.group(0)`` and ``x[0]`` will "
"both be of type :class:`str`. We can represent this kind of object in type "
"annotations with the ``GenericAlias`` ``re.Match[str]``."
msgstr ""
"Si ``x = re.search('foo', 'foo')``, ``x`` será un objeto :ref:`re.Match "
"<match-objects>` donde los valores de retorno de ``x.group(0)`` y ``x[0]`` "
"serán de tipo :class:`str`. Podemos representar este tipo de objeto en "
"anotaciones de type con el ``GenericAlias`` de ``re.Match[str]``."

#: ../Doc/library/stdtypes.rst:4932
msgid ""
"If ``y = re.search(b'bar', b'bar')``, (note the ``b`` for :class:`bytes`), "
"``y`` will also be an instance of ``re.Match``, but the return values of ``y."
"group(0)`` and ``y[0]`` will both be of type :class:`bytes`. In type "
"annotations, we would represent this variety of :ref:`re.Match <match-"
"objects>` objects with ``re.Match[bytes]``."
msgstr ""
"Si ``y = re.search(b'bar', b'bar')``, (nótese que ``b`` es para :class:"
"`bytes`), ``y`` también será una instancia de ``re.Match``, pero los valores "
"de retorno de ``y.group(0)`` y ``y[0]`` serán de tipo :class:`bytes`. En "
"anotaciones de type, representaríamos esta variedad de objetos :ref:`re."
"Match <match-objects>` con ``re.Match[bytes]``."

#: ../Doc/library/stdtypes.rst:4938
msgid ""
"``GenericAlias`` objects are instances of the class :class:`types."
"GenericAlias`, which can also be used to create ``GenericAlias`` objects "
"directly."
msgstr ""
"Los objetos ``GenericAlias`` son instancias de la clase :class:`types."
"GenericAlias`, que también se puede usar para crear directamente objetos "
"``GenericAlias``."

#: ../Doc/library/stdtypes.rst:4944
msgid ""
"Creates a ``GenericAlias`` representing a type ``T`` parameterized by types "
"*X*, *Y*, and more depending on the ``T`` used. For example, a function "
"expecting a :class:`list` containing :class:`float` elements::"
msgstr ""
"Crea un ``GenericAlias`` que representa un tipo ``T`` parametrizado por "
"tipos *X*, *Y* y más dependiendo de la ``T`` usada. Por ejemplo, una función "
"espera un :class:`list` que contenga elementos :class:`float`::"

#: ../Doc/library/stdtypes.rst:4952
msgid ""
"Another example for :term:`mapping` objects, using a :class:`dict`, which is "
"a generic type expecting two type parameters representing the key type and "
"the value type.  In this example, the function expects a ``dict`` with keys "
"of type :class:`str` and values of type :class:`int`::"
msgstr ""
"Otro ejemplo para el :term:`mapping` de objetos, usando un :class:`dict`, el "
"cual es un tipo genérico que espera dos parámetros de tipo que representan "
"el tipo de la clave y el tipo del valor. En este ejemplo, la función espera "
"un ``dict`` con claves de tipo :class:`str` y valores de tipo :class:`int`::"

#: ../Doc/library/stdtypes.rst:4960
msgid ""
"The builtin functions :func:`isinstance` and :func:`issubclass` do not "
"accept ``GenericAlias`` types for their second argument::"
msgstr ""
"Las funciones integradas :func:`isinstance` y :func:`issubclass` no aceptan "
"tipos ``GenericAlias`` como segundo argumento::"

#: ../Doc/library/stdtypes.rst:4968
msgid ""
"The Python runtime does not enforce :term:`type annotations <annotation>`. "
"This extends to generic types and their type parameters. When creating a "
"container object from a ``GenericAlias``, the elements in the container are "
"not checked against their type. For example, the following code is "
"discouraged, but will run without errors::"
msgstr ""
"Python en tiempo de ejecución no hace cumplir las :term:`anotaciones de tipo "
"<annotation>`. Esto se extiende para tipos genéricos y sus parámetros. "
"Cuando se crea un objeto contenedor desde un ``GenericAlias``, los elementos "
"del contenedor no se verifican con su tipo. Por ejemplo, el siguiente código "
"no es recomendado en lo absoluto, pero correrá sin errores::"

#: ../Doc/library/stdtypes.rst:4978
msgid ""
"Furthermore, parameterized generics erase type parameters during object "
"creation::"
msgstr ""
"Además, los genéricos parametrizados borran parámetros de type durante la "
"creación de objetos::"

#: ../Doc/library/stdtypes.rst:4989
msgid ""
"Calling :func:`repr` or :func:`str` on a generic shows the parameterized "
"type::"
msgstr ""
"Llamando a :func:`repr` o :func:`str` en un genérico se muestra el tipo "
"parametrizado::"

#: ../Doc/library/stdtypes.rst:4997
msgid ""
"The :meth:`~object.__getitem__` method of generic containers will raise an "
"exception to disallow mistakes like ``dict[str][str]``::"
msgstr ""
"El método :meth:`~object.__getitem__` de contenedores genéricos lanzarán una "
"excepción para rechazar los errores como ``dict[str][str]``::"

# Tipo u objeto 'type'?
#: ../Doc/library/stdtypes.rst:5005
msgid ""
"However, such expressions are valid when :ref:`type variables <generics>` "
"are used.  The index must have as many elements as there are type variable "
"items in the ``GenericAlias`` object's :attr:`~genericalias.__args__`. ::"
msgstr ""
"Sin embargo, estas expresiones son válidas cuando se usan :ref:`variables de "
"type <generics>`. El índice debe tener tantos elementos como los elementos "
"de variable de type en los :attr:`~genericalias.__args__` del objeto "
"``GenericAlias``::"

#: ../Doc/library/stdtypes.rst:5016
msgid "Standard Generic Classes"
msgstr "Clases genéricas estándar"

#: ../Doc/library/stdtypes.rst:5018
msgid ""
"The following standard library classes support parameterized generics. This "
"list is non-exhaustive."
msgstr ""
"Las siguientes clases de la biblioteca estándar soportan genéricos "
"parametrizados. Esta lista no es exhaustiva."

#: ../Doc/library/stdtypes.rst:5021
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: ../Doc/library/stdtypes.rst:5022
msgid ":class:`list`"
msgstr ":class:`list`"

#: ../Doc/library/stdtypes.rst:5023
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: ../Doc/library/stdtypes.rst:5024
msgid ":class:`set`"
msgstr ":class:`set`"

#: ../Doc/library/stdtypes.rst:5025
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: ../Doc/library/stdtypes.rst:5026
msgid ":class:`type`"
msgstr ":class:`type`"

#: ../Doc/library/stdtypes.rst:5027
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: ../Doc/library/stdtypes.rst:5028
msgid ":class:`collections.defaultdict`"
msgstr ":class:`collections.defaultdict`"

#: ../Doc/library/stdtypes.rst:5029
msgid ":class:`collections.OrderedDict`"
msgstr ":class:`collections.OrderedDict`"

#: ../Doc/library/stdtypes.rst:5030
msgid ":class:`collections.Counter`"
msgstr ":class:`collections.Counter`"

#: ../Doc/library/stdtypes.rst:5031
msgid ":class:`collections.ChainMap`"
msgstr ":class:`collections.ChainMap`"

#: ../Doc/library/stdtypes.rst:5032
msgid ":class:`collections.abc.Awaitable`"
msgstr ":class:`collections.abc.Awaitable`"

#: ../Doc/library/stdtypes.rst:5033
msgid ":class:`collections.abc.Coroutine`"
msgstr ":class:`collections.abc.Coroutine`"

#: ../Doc/library/stdtypes.rst:5034
msgid ":class:`collections.abc.AsyncIterable`"
msgstr ":class:`collections.abc.AsyncIterable`"

#: ../Doc/library/stdtypes.rst:5035
msgid ":class:`collections.abc.AsyncIterator`"
msgstr ":class:`collections.abc.AsyncIterator`"

#: ../Doc/library/stdtypes.rst:5036
msgid ":class:`collections.abc.AsyncGenerator`"
msgstr ":class:`collections.abc.AsyncGenerator`"

#: ../Doc/library/stdtypes.rst:5037
msgid ":class:`collections.abc.Iterable`"
msgstr ":class:`collections.abc.Iterable`"

#: ../Doc/library/stdtypes.rst:5038
msgid ":class:`collections.abc.Iterator`"
msgstr ":class:`collections.abc.Iterator`"

#: ../Doc/library/stdtypes.rst:5039
msgid ":class:`collections.abc.Generator`"
msgstr ":class:`collections.abc.Generator`"

#: ../Doc/library/stdtypes.rst:5040
msgid ":class:`collections.abc.Reversible`"
msgstr ":class:`collections.abc.Reversible`"

#: ../Doc/library/stdtypes.rst:5041
msgid ":class:`collections.abc.Container`"
msgstr ":class:`collections.abc.Container`"

#: ../Doc/library/stdtypes.rst:5042
msgid ":class:`collections.abc.Collection`"
msgstr ":class:`collections.abc.Collection`"

#: ../Doc/library/stdtypes.rst:5043
msgid ":class:`collections.abc.Callable`"
msgstr ":class:`collections.abc.Callable`"

#: ../Doc/library/stdtypes.rst:5044
msgid ":class:`collections.abc.Set`"
msgstr ":class:`collections.abc.Set`"

#: ../Doc/library/stdtypes.rst:5045
msgid ":class:`collections.abc.MutableSet`"
msgstr ":class:`collections.abc.MutableSet`"

#: ../Doc/library/stdtypes.rst:5046
msgid ":class:`collections.abc.Mapping`"
msgstr ":class:`collections.abc.Mapping`"

#: ../Doc/library/stdtypes.rst:5047
msgid ":class:`collections.abc.MutableMapping`"
msgstr ":class:`collections.abc.MutableMapping`"

#: ../Doc/library/stdtypes.rst:5048
msgid ":class:`collections.abc.Sequence`"
msgstr ":class:`collections.abc.Sequence`"

#: ../Doc/library/stdtypes.rst:5049
msgid ":class:`collections.abc.MutableSequence`"
msgstr ":class:`collections.abc.MutableSequence`"

#: ../Doc/library/stdtypes.rst:5050
msgid ":class:`collections.abc.ByteString`"
msgstr ":class:`collections.abc.ByteString`"

#: ../Doc/library/stdtypes.rst:5051
msgid ":class:`collections.abc.MappingView`"
msgstr ":class:`collections.abc.MappingView`"

#: ../Doc/library/stdtypes.rst:5052
msgid ":class:`collections.abc.KeysView`"
msgstr ":class:`collections.abc.KeysView`"

#: ../Doc/library/stdtypes.rst:5053
msgid ":class:`collections.abc.ItemsView`"
msgstr ":class:`collections.abc.ItemsView`"

#: ../Doc/library/stdtypes.rst:5054
msgid ":class:`collections.abc.ValuesView`"
msgstr ":class:`collections.abc.ValuesView`"

#: ../Doc/library/stdtypes.rst:5055
msgid ":class:`contextlib.AbstractContextManager`"
msgstr ":class:`contextlib.AbstractContextManager`"

#: ../Doc/library/stdtypes.rst:5056
msgid ":class:`contextlib.AbstractAsyncContextManager`"
msgstr ":class:`contextlib.AbstractAsyncContextManager`"

#: ../Doc/library/stdtypes.rst:5057
msgid ":class:`dataclasses.Field`"
msgstr ":class:`dataclasses.Field`"

#: ../Doc/library/stdtypes.rst:5058
msgid ":class:`functools.cached_property`"
msgstr ":class:`functools.cached_property`"

#: ../Doc/library/stdtypes.rst:5059
msgid ":class:`functools.partialmethod`"
msgstr ":class:`functools.partialmethod`"

#: ../Doc/library/stdtypes.rst:5060
msgid ":class:`os.PathLike`"
msgstr ":class:`os.PathLike`"

#: ../Doc/library/stdtypes.rst:5061
msgid ":class:`queue.LifoQueue`"
msgstr ":class:`queue.LifoQueue`"

#: ../Doc/library/stdtypes.rst:5062
msgid ":class:`queue.Queue`"
msgstr ":class:`queue.Queue`"

#: ../Doc/library/stdtypes.rst:5063
msgid ":class:`queue.PriorityQueue`"
msgstr ":class:`queue.PriorityQueue`"

#: ../Doc/library/stdtypes.rst:5064
msgid ":class:`queue.SimpleQueue`"
msgstr ":class:`queue.SimpleQueue`"

#: ../Doc/library/stdtypes.rst:5065
msgid ":ref:`re.Pattern <re-objects>`"
msgstr ":ref:`re.Pattern <re-objects>`"

#: ../Doc/library/stdtypes.rst:5066
msgid ":ref:`re.Match <match-objects>`"
msgstr ":ref:`re.Match <match-objects>`"

#: ../Doc/library/stdtypes.rst:5067
msgid ":class:`shelve.BsdDbShelf`"
msgstr ":class:`shelve.BsdDbShelf`"

#: ../Doc/library/stdtypes.rst:5068
msgid ":class:`shelve.DbfilenameShelf`"
msgstr ":class:`shelve.DbfilenameShelf`"

#: ../Doc/library/stdtypes.rst:5069
msgid ":class:`shelve.Shelf`"
msgstr ":class:`shelve.Shelf`"

#: ../Doc/library/stdtypes.rst:5070
msgid ":class:`types.MappingProxyType`"
msgstr ":class:`types.MappingProxyType`"

#: ../Doc/library/stdtypes.rst:5071
msgid ":class:`weakref.WeakKeyDictionary`"
msgstr ":class:`weakref.WeakKeyDictionary`"

#: ../Doc/library/stdtypes.rst:5072
msgid ":class:`weakref.WeakMethod`"
msgstr ":class:`weakref.WeakMethod`"

#: ../Doc/library/stdtypes.rst:5073
msgid ":class:`weakref.WeakSet`"
msgstr ":class:`weakref.WeakSet`"

#: ../Doc/library/stdtypes.rst:5074
msgid ":class:`weakref.WeakValueDictionary`"
msgstr ":class:`weakref.WeakValueDictionary`"

#: ../Doc/library/stdtypes.rst:5079
msgid "Special Attributes of ``GenericAlias`` objects"
msgstr "Atributos especiales de los objetos ``GenericAlias``"

#: ../Doc/library/stdtypes.rst:5081
msgid "All parameterized generics implement special read-only attributes."
msgstr ""
"Todos los genéricos parametrizados implementan atributos especiales de solo "
"lectura."

#: ../Doc/library/stdtypes.rst:5085
msgid "This attribute points at the non-parameterized generic class::"
msgstr "Este atributo apunta a la clase genérica no parametrizada::"

#: ../Doc/library/stdtypes.rst:5093
msgid ""
"This attribute is a :class:`tuple` (possibly of length 1) of generic types "
"passed to the original :meth:`~object.__class_getitem__` of the generic "
"class::"
msgstr ""
"Este atributo es una clase :class:`tuple` (posiblemente de longitud 1) de "
"tipos genéricos pasados al método original :meth:`~object.__class_getitem__` "
"de la clase genérica::"

#: ../Doc/library/stdtypes.rst:5103
msgid ""
"This attribute is a lazily computed tuple (possibly empty) of unique type "
"variables found in ``__args__``::"
msgstr ""
"Este atributo es una tupla (posiblemente vacía) computada perezosamente con "
"las variables de tipo únicas encontradas en ``__args__``::"

#: ../Doc/library/stdtypes.rst:5114
msgid ""
"A ``GenericAlias`` object with :class:`typing.ParamSpec` parameters may not "
"have correct ``__parameters__`` after substitution because :class:`typing."
"ParamSpec` is intended primarily for static type checking."
msgstr ""
"Un objeto ``GenericAlias`` con :class:`typing.ParamSpec` parámetros puede no "
"tener los ``__parameters__`` correctos después de la sustitución porque :"
"class:`typing.ParamSpec` está destinado principalmente a la verificación de "
"tipos estáticos."

#: ../Doc/library/stdtypes.rst:5121
msgid ""
"A boolean that is true if the alias has been unpacked using the ``*`` "
"operator (see :data:`~typing.TypeVarTuple`)."
msgstr ""
"Un booleano que es verdadero si el alias ha sido desempaquetado usando el "
"operador ``*`` (véase :data:`~typing.TypeVarTuple`)."

#: ../Doc/library/stdtypes.rst:5130
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - Type Hints"

#: ../Doc/library/stdtypes.rst:5130
msgid "Introducing Python's framework for type annotations."
msgstr "Presentación del marco de trabajo de Python para anotaciones de tipo."

#: ../Doc/library/stdtypes.rst:5135
msgid ":pep:`585` - Type Hinting Generics In Standard Collections"
msgstr ":pep:`585` - Sugerencias de tipo genéricas en colecciones estándar"

#: ../Doc/library/stdtypes.rst:5133
msgid ""
"Introducing the ability to natively parameterize standard-library classes, "
"provided they implement the special class method :meth:`~object."
"__class_getitem__`."
msgstr ""
"Introducción a la capacidad de parametrizar de forma nativa clases de la "
"biblioteca estándar, siempre que implementen el método de clase especial :"
"meth:`~object.__class_getitem__`."

#: ../Doc/library/stdtypes.rst:5138
msgid ""
":ref:`Generics`, :ref:`user-defined generics <user-defined-generics>` and :"
"class:`typing.Generic`"
msgstr ""
":ref:`Generics`, :ref:`tipos genéricos definidos por el usuario <user-"
"defined-generics>` y :class:`typing.Generic`"

#: ../Doc/library/stdtypes.rst:5138
msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr ""
"Documentación sobre cómo implementar clases genéricas que se pueden "
"parametrizar en tiempo de ejecución y que los validadores estático de tipos "
"pueden entender."

#: ../Doc/library/stdtypes.rst:5147
msgid "Union Type"
msgstr "Tipo de conversión"

#: ../Doc/library/stdtypes.rst:5153
msgid ""
"A union object holds the value of the ``|`` (bitwise or) operation on "
"multiple :ref:`type objects <bltin-type-objects>`.  These types are intended "
"primarily for :term:`type annotations <annotation>`. The union type "
"expression enables cleaner type hinting syntax compared to :data:`typing."
"Union`."
msgstr ""
"Un objeto de conversión contiene el valor de la operación ``|`` (bit a bit "
"o) en varios :ref:`objetos de tipo <bltin-type-objects>`. Estos tipos están "
"destinados principalmente a :term:`anotaciones de tipo <annotation>`. La "
"expresión de tipo de conversión permite una sintaxis de sugerencia de tipo "
"más limpia en comparación con :data:`typing.Union`."

#: ../Doc/library/stdtypes.rst:5160
msgid ""
"Defines a union object which holds types *X*, *Y*, and so forth. ``X | Y`` "
"means either X or Y.  It is equivalent to ``typing.Union[X, Y]``. For "
"example, the following function expects an argument of type :class:`int` or :"
"class:`float`::"
msgstr ""
"Define un objeto de conversión que contiene tipos *X*, *Y*, etc. ``X | Y`` "
"significa X o Y. Es equivalente a ``typing.Union[X, Y]``. Por ejemplo, la "
"siguiente función espera un argumento de tipo :class:`int` or :class:"
"`float`::"

#: ../Doc/library/stdtypes.rst:5170
msgid ""
"The ``|`` operand cannot be used at runtime to define unions where one or "
"more members is a forward reference. For example, ``int | \"Foo\"``, where "
"``\"Foo\"`` is a reference to a class not yet defined, will fail at runtime. "
"For unions which include forward references, present the whole expression as "
"a string, e.g. ``\"int | Foo\"``."
msgstr ""

#: ../Doc/library/stdtypes.rst:5178
msgid ""
"Union objects can be tested for equality with other union objects.  Details:"
msgstr ""
"Los objetos de conversión se pueden probar para determinar su igualdad con "
"otros objetos de conversión. Detalles:"

#: ../Doc/library/stdtypes.rst:5180
msgid "Unions of unions are flattened::"
msgstr "Las conversiones de conversión se aplanan::"

#: ../Doc/library/stdtypes.rst:5184
msgid "Redundant types are removed::"
msgstr "Se eliminan los tipos redundantes::"

#: ../Doc/library/stdtypes.rst:5188
msgid "When comparing unions, the order is ignored::"
msgstr "Al comparar conversiones, se ignora el orden::"

#: ../Doc/library/stdtypes.rst:5192
msgid "It is compatible with :data:`typing.Union`::"
msgstr "Es compatible con :data:`typing.Union`::"

#: ../Doc/library/stdtypes.rst:5196
msgid "Optional types can be spelled as a union with ``None``::"
msgstr "Los tipos opcionales se pueden escribir como una unión con ``None``::"

#: ../Doc/library/stdtypes.rst:5203
msgid ""
"Calls to :func:`isinstance` and :func:`issubclass` are also supported with a "
"union object::"
msgstr ""
"Las llamadas a :func:`isinstance` y :func:`issubclass` también son "
"compatibles con un objeto de conversión::"

#: ../Doc/library/stdtypes.rst:5209
#, fuzzy
msgid ""
"However, :ref:`parameterized generics <types-genericalias>` in union objects "
"cannot be checked::"
msgstr ""
"Sin embargo, los objetos de unión que contienen :ref:`genéricos "
"parametrizados <types-genericalias>` no se pueden utilizar::"

#: ../Doc/library/stdtypes.rst:5219
msgid ""
"The user-exposed type for the union object can be accessed from :data:`types."
"UnionType` and used for :func:`isinstance` checks.  An object cannot be "
"instantiated from the type::"
msgstr ""
"El tipo expuesto por el usuario para el objeto de conversión puede ser "
"accedido desde :data:`types.UnionType` y usado por chequeos :func:"
"`isinstance`. Un objeto no puede ser instancia por el tipo::"

#: ../Doc/library/stdtypes.rst:5232
msgid ""
"The :meth:`__or__` method for type objects was added to support the syntax "
"``X | Y``.  If a metaclass implements :meth:`__or__`, the Union may override "
"it::"
msgstr ""
"Se agregó el método :meth:`__or__` para objetos de tipo para admitir la "
"sintaxis ``X | Y``. Si una metaclase implementa :meth:`__or__`, la "
"Conversión puede anularlo::"

#: ../Doc/library/stdtypes.rst:5250
msgid ":pep:`604` -- PEP proposing the ``X | Y`` syntax and the Union type."
msgstr ":pep:`604` — PEP propone la sintaxis ``X | Y`` y tipo Conversión."

#: ../Doc/library/stdtypes.rst:5258
msgid "Other Built-in Types"
msgstr "Otros tipos predefinidos"

#: ../Doc/library/stdtypes.rst:5260
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""
"El intérprete soporta otros tipos de objetos variados. La mayoría de ellos "
"solo implementan una o dos operaciones."

#: ../Doc/library/stdtypes.rst:5267
msgid "Modules"
msgstr "Módulos"

#: ../Doc/library/stdtypes.rst:5269
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"La única operación especial que implementan los módulos es el acceso como "
"atributos: ``m.name``, donde *m* es un módulo y *name* accede a un nombre "
"definido en la tabla de símbolos del módulo *m*. También se puede asignar "
"valores a los atributos de un módulo (nótese que la sentencia :keyword:"
"`import` no es, estrictamente hablando, una operación del objeto de tipo "
"módulo; la sentencia ``import foo`` no requiere la existencia de un módulo "
"llamado *foo*, sino una *definición* (externa) de un módulo *foo* en alguna "
"parte)."

#: ../Doc/library/stdtypes.rst:5276
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to "
"the :attr:`~object.__dict__` attribute is not possible (you can write ``m."
"__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write "
"``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is not "
"recommended."
msgstr ""
"Un atributo especial de cada módulo es :attr:`~object.__dict__`. Es un "
"diccionario que contiene la tabla de símbolos del módulo. Cambiar el "
"diccionario cambiará por tanto el contenido de la tabla de símbolos, pero no "
"es posible realizar una asignación directa al atributo :attr:`~object."
"__dict__` (se puede realizar una asignación como ``m.__dict__['a'] = 1``, "
"que define el valor de ``m.a`` como ``1``, pero no se puede hacer ``m."
"__dict__ = {}``). No se recomienda manipular los contenidos del atributo :"
"attr:`~object.__dict__` directamente."

#: ../Doc/library/stdtypes.rst:5284
msgid ""
"Modules built into the interpreter are written like this: ``<module "
"'sys' (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"Los módulos incluidos en el intérprete se escriben así: ``<module "
"'sys' (built-in)>``. Si se cargan desde un archivo, se escriben como "
"``<module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."

#: ../Doc/library/stdtypes.rst:5292
msgid "Classes and Class Instances"
msgstr "Clases e instancias de clase"

#: ../Doc/library/stdtypes.rst:5294
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "Véase :ref:`objects` y :ref:`class` para más información."

#: ../Doc/library/stdtypes.rst:5300
msgid "Functions"
msgstr "Funciones"

#: ../Doc/library/stdtypes.rst:5302
msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr ""
"Los objetos de tipo función se crean mediante definiciones de función. La "
"única operación posible con un objeto de tipo función es llamarla: "
"``func(argument-list)``."

#: ../Doc/library/stdtypes.rst:5305
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""
"Hay dos tipos de funciones: Las funciones básicas o predefinidas y las "
"funciones definidas por el usuario. Las dos soportan la misma operación (ser "
"llamadas), pero la implementación es diferente, de ahí que se consideren de "
"distintos tipo."

#: ../Doc/library/stdtypes.rst:5309
msgid "See :ref:`function` for more information."
msgstr "Véase :ref:`function` para más información."

#: ../Doc/library/stdtypes.rst:5315
msgid "Methods"
msgstr "Métodos"

#: ../Doc/library/stdtypes.rst:5319
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types that "
"support them."
msgstr ""
"Los métodos son funciones que se llaman usando la notación de atributos. Hay "
"de dos tipos: métodos básicos o predefinidos (como el método :meth:`append` "
"en las listas) y métodos de instancia de clase. Los métodos básicos o "
"predefinidos se describen junto con los tipos que los soportan."

#: ../Doc/library/stdtypes.rst:5324
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called :dfn:"
"`instance method`) object. When called, it will add the ``self`` argument to "
"the argument list.  Bound methods have two special read-only attributes: ``m."
"__self__`` is the object on which the method operates, and ``m.__func__`` is "
"the function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-"
"n)`` is completely equivalent to calling ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)``."
msgstr ""
"Si se accede a un método (una función definida dentro de un espacio de "
"nombres de una clase) a través de una instancia, se obtiene un objeto "
"especial, un :dfn:`bound method` (también llamado :dfn:`instance method`). "
"Cuando se llama, se añade automáticamente el parámetro ``self`` a la lista "
"de parámetros. Los métodos ligados tienen dos atributos especiales de solo "
"lectura: ``m.__self__`` es el objeto sobre el que está operando el método, y "
"``m.__func__`` es la función que implementa el método. Llamar ``m(arg-1, "
"arg-2, ..., arg-n)`` es completamente equivalente a llamar ``m.__func__(m."
"__self__, arg-1, arg-2, ..., arg-n)``."

#: ../Doc/library/stdtypes.rst:5333
msgid ""
"Like function objects, bound method objects support getting arbitrary "
"attributes.  However, since method attributes are actually stored on the "
"underlying function object (``meth.__func__``), setting method attributes on "
"bound methods is disallowed.  Attempting to set an attribute on a method "
"results in an :exc:`AttributeError` being raised.  In order to set a method "
"attribute, you need to explicitly set it on the underlying function object::"
msgstr ""
"Al igual que los objetos de tipo función, los métodos ligados o de instancia "
"soportan asignación de atributos arbitrarios. Sin embargo, como los "
"atributos de los métodos se almacenan en la función subyacente (``meth."
"__func__``), definir cualquier atributo en métodos ligados está "
"desaconsejado. Intentar asignar un atributo a un método produce que se lance "
"una excepción de tipo :exc:`AttributeError`. Para poder definir un atributo "
"a un método, este debe ser definido explícitamente en la función subyacente::"

#: ../Doc/library/stdtypes.rst:5353 ../Doc/library/stdtypes.rst:5384
msgid "See :ref:`types` for more information."
msgstr "Véase :ref:`types` para más información."

#: ../Doc/library/stdtypes.rst:5361
msgid "Code Objects"
msgstr "Objetos código"

#: ../Doc/library/stdtypes.rst:5367
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`__code__` attribute. See also the :mod:`code` module."
msgstr ""
"Los objetos de tipo código son usados por la implementación del lenguaje "
"para representar código ejecutable \"pseudo-compilado\", como por ejemplo el "
"cuerpo de una función. A diferencia de los objetos de tipo función, no "
"contienen una referencia a un entorno global de ejecución. Los objetos de "
"tipo código se pueden obtener usando la función básica :func:`compile` o se "
"pueden extraer a partir de objetos de tipo función a través de su atributo :"
"attr:`__code__`. Para más detalle véase el módulo :mod:`code`."

#: ../Doc/library/stdtypes.rst:5374
msgid ""
"Accessing ``__code__`` raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"__code__\"``."
msgstr ""
"Al acceder a ``__code__`` se lanza un :ref:`evento de auditoría <auditing>` "
"``object.__getattr__`` con argumentos ``obj`` y ``\"__code__\"``."

#: ../Doc/library/stdtypes.rst:5381
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""
"Un objeto de tipo código puede ser evaluado o ejecutando pasándolo como "
"parámetros a las funciones incorporadas :func:`exec` o :func:`eval` (que "
"también aceptan código Python en forma de cadena de caracteres)."

#: ../Doc/library/stdtypes.rst:5390
msgid "Type Objects"
msgstr "Objetos Tipo"

#: ../Doc/library/stdtypes.rst:5396
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""
"Los objetos de tipo Tipo (*Type*) representan a los distintos tipos de "
"datos. El tipo de un objeto particular puede ser consultado usando la "
"función incorporada :func:`type`. Los objetos Tipo no tienen ninguna "
"operación especial. El módulo :mod:`types` define nombres para todos los "
"tipos básicos definidos en la biblioteca estándar."

#: ../Doc/library/stdtypes.rst:5401
msgid "Types are written like this: ``<class 'int'>``."
msgstr "Los tipos se escriben de la siguiente forma: ``<class 'int'>``."

#: ../Doc/library/stdtypes.rst:5407
msgid "The Null Object"
msgstr "El objeto nulo (*Null*)"

#: ../Doc/library/stdtypes.rst:5409
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""
"Todas las funciones que no definen de forma explícita un valor de retorno "
"retornan este objeto. Los objetos nulos no soportan ninguna operación "
"especial. Solo existe un único objeto nulo, llamado ``None`` (un nombre "
"predefinido o básico). La expresión ``type(None)()`` produce el mismo objeto "
"``None``, esto se conoce como *Singleton*."

#: ../Doc/library/stdtypes.rst:5413
msgid "It is written as ``None``."
msgstr "Se escribe ``None``."

#: ../Doc/library/stdtypes.rst:5420
msgid "The Ellipsis Object"
msgstr "El objeto puntos suspensivos (*Ellipsis*)"

#: ../Doc/library/stdtypes.rst:5422
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named :const:"
"`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the :const:"
"`Ellipsis` singleton."
msgstr ""
"Este objeto es usado a menudo en operaciones de segmentado (véase :ref:"
"`slicings`). No soporta ninguna operación especial. Solo existe un único "
"objeto de puntos suspensivos, llamado :const:`Ellipsis` (un nombre "
"predefinido o básico). La expresión ``type(Ellipsis)()`` produce el mismo "
"objeto :const:`Ellipsis`, esto se conoce como *Singleton*."

#: ../Doc/library/stdtypes.rst:5427
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "Se puede escribir como ``Ellipsis`` o ``...``."

#: ../Doc/library/stdtypes.rst:5433
msgid "The NotImplemented Object"
msgstr "El objeto *NotImplemented*"

#: ../Doc/library/stdtypes.rst:5435
msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one ``NotImplemented`` object. "
"``type(NotImplemented)()`` produces the singleton instance."
msgstr ""
"Este objeto se retorna en todas las operaciones binarias y comparaciones "
"cuando se intenta operar con tipos que no están soportados. Véase :ref:"
"`comparisons` para más información. Solo existe un objeto de tipo "
"``NotImplemented``. La expresión ``type(NotImplemented)()`` produce el mismo "
"objeto, esto se conoce como *Singleton*."

#: ../Doc/library/stdtypes.rst:5440
msgid "It is written as ``NotImplemented``."
msgstr "Se escribe ``NotImplemented``."

#: ../Doc/library/stdtypes.rst:5446
msgid "Internal Objects"
msgstr "Objetos internos"

#: ../Doc/library/stdtypes.rst:5448
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr ""
"Véase la sección :ref:`types` para saber más de estos objetos. Se describen "
"los objetos marco de pila, los objetos de traza de ejecución (*traceback*) y "
"los objetos de tipo segmento (*slice*)."

#: ../Doc/library/stdtypes.rst:5455
msgid "Special Attributes"
msgstr "Atributos especiales"

#: ../Doc/library/stdtypes.rst:5457
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""
"La implementación añade unos cuantos atributos de solo lectura a varios "
"tipos de objetos, cuando resulta relevante. Algunos de estos atributos son "
"reportados por la función incorporada :func:`dir`."

#: ../Doc/library/stdtypes.rst:5464
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr ""
"Un diccionario u otro tipo de mapa usado para almacenar los atributos de un "
"objeto (si son modificables)."

#: ../Doc/library/stdtypes.rst:5470
msgid "The class to which a class instance belongs."
msgstr "La clase a la que pertenece una instancia."

#: ../Doc/library/stdtypes.rst:5475
msgid "The tuple of base classes of a class object."
msgstr "La tupla de clases base de las que deriva una clase."

#: ../Doc/library/stdtypes.rst:5480
msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr ""
"El nombre de la clase, función, método, descriptor o instancia generadora."

#: ../Doc/library/stdtypes.rst:5486
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr ""
"El nombre calificado (:term:`qualified name`) de la clase, función, método, "
"descriptor o instancia generadora."

#: ../Doc/library/stdtypes.rst:5494
msgid ""
"The :ref:`type parameters <type-params>` of generic classes, functions, and :"
"ref:`type aliases <type-aliases>`."
msgstr ""

#: ../Doc/library/stdtypes.rst:5502
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr ""
"Este atributo es una tupla de las clases que serán consideradas cuando se "
"busque en las clases base para resolver un método."

#: ../Doc/library/stdtypes.rst:5508
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~class.__mro__`."
msgstr ""
"Este método puede ser reescrito por una metaclase para personalizar el orden "
"de resolución de métodos para sus instancias. Es llamado en la creación de "
"la clase, y el resultado se almacena en el atributo :attr:`~class.__mro__`."

#: ../Doc/library/stdtypes.rst:5515
msgid ""
"Each class keeps a list of weak references to its immediate subclasses.  "
"This method returns a list of all those references still alive.  The list is "
"in definition order.  Example::"
msgstr ""
"Cada clase mantiene una lista de referencias débiles a sus subclases "
"inmediatamente anteriores. Este método retorna una lista de todas las "
"referencias que todavía estén vivas. La lista está en orden de definición. "
"Por ejemplo::"

#: ../Doc/library/stdtypes.rst:5526
msgid "Integer string conversion length limitation"
msgstr "Limitación de longitud de conversión de cadena de tipo entero"

#: ../Doc/library/stdtypes.rst:5528
msgid ""
"CPython has a global limit for converting between :class:`int` and :class:"
"`str` to mitigate denial of service attacks. This limit *only* applies to "
"decimal or other non-power-of-two number bases. Hexadecimal, octal, and "
"binary conversions are unlimited. The limit can be configured."
msgstr ""
"CPython tiene un límite global para conversiones entre :class:`int` y :class:"
"`str` para mitigar los ataques de denegación de servicio. Este límite *solo* "
"se aplica a decimales u otras bases numéricas que no sean potencias de dos. "
"Las conversiones hexadecimales, octales y binarias son ilimitadas. Se puede "
"configurar el límite."

#: ../Doc/library/stdtypes.rst:5533
#, fuzzy
msgid ""
"The :class:`int` type in CPython is an arbitrary length number stored in "
"binary form (commonly known as a \"bignum\"). There exists no algorithm that "
"can convert a string to a binary integer or a binary integer to a string in "
"linear time, *unless* the base is a power of 2. Even the best known "
"algorithms for base 10 have sub-quadratic complexity. Converting a large "
"value such as ``int('1' * 500_000)`` can take over a second on a fast CPU."
msgstr ""
"El tipo :class:`int` en CPython es un número con longitud arbitrario que se "
"almacena en forma binaria (se conoce comúnmente como \"bignum\"). No existe "
"ningún algoritmo que pueda convertir una cadena de caracteres a un entero "
"binario o un entero binario a una cadena de caracteres en tiempo lineal, *a "
"menos* que la base sea una potencia de 2. Incluso los algoritmos más "
"conocidos para la base a 10 tienen una complejidad subcuadrática. Convertir "
"un valor grande como ``int('1' * 500_000)`` puede tomar más de un segundo en "
"una CPU rápida."

#: ../Doc/library/stdtypes.rst:5540
msgid ""
"Limiting conversion size offers a practical way to avoid `CVE-2020-10735 "
"<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-10735>`_."
msgstr ""
"Limitar el tamaño de la conversión ofrece una forma práctica para evitar "
"`CVE-2020-10735 <https://cve.mitre.org/cgi-bin/cvename.cgi?"
"name=CVE-2020-10735>`_."

#: ../Doc/library/stdtypes.rst:5543
msgid ""
"The limit is applied to the number of digit characters in the input or "
"output string when a non-linear conversion algorithm would be involved.  "
"Underscores and the sign are not counted towards the limit."
msgstr ""
"El límite se aplica al número de caracteres de dígitos en la cadena de "
"entrada o salida cuando estaría involucrado un algoritmo de conversión no "
"lineal. Los guiones bajos y el signo no se cuentan para el límite."

#: ../Doc/library/stdtypes.rst:5547
msgid ""
"When an operation would exceed the limit, a :exc:`ValueError` is raised:"
msgstr ""
"Cuando una operación excede el límite, se lanza una excepción :exc:"
"`ValueError`:"

#: ../Doc/library/stdtypes.rst:5569
msgid ""
"The default limit is 4300 digits as provided in :data:`sys.int_info."
"default_max_str_digits <sys.int_info>`. The lowest limit that can be "
"configured is 640 digits as provided in :data:`sys.int_info."
"str_digits_check_threshold <sys.int_info>`."
msgstr ""
"El límite predeterminado es de 4300 dígitos como se indica en :data:`sys."
"int_info.default_max_str_digits <sys.int_info>`. El límite más bajo que se "
"puede configurar es de 640 dígitos como se indica en :data:`sys.int_info."
"str_digits_check_threshold <sys.int_info>`."

#: ../Doc/library/stdtypes.rst:5574
msgid "Verification:"
msgstr "Verificación:"

#: ../Doc/library/stdtypes.rst:5589
msgid "Affected APIs"
msgstr "APIs afectadas"

#: ../Doc/library/stdtypes.rst:5591
msgid ""
"The limitation only applies to potentially slow conversions between :class:"
"`int` and :class:`str` or :class:`bytes`:"
msgstr ""
"La limitación solo se aplica a conversiones potencialmente lentas entre :"
"class:`int` y :class:`str` o :class:`bytes`:"

#: ../Doc/library/stdtypes.rst:5594
msgid "``int(string)`` with default base 10."
msgstr "``int(string)`` con base predeterminada a 10."

#: ../Doc/library/stdtypes.rst:5595
msgid "``int(string, base)`` for all bases that are not a power of 2."
msgstr ""
"``int(string, base)`` para todas las bases que no sean una potencia de 2."

#: ../Doc/library/stdtypes.rst:5596
msgid "``str(integer)``."
msgstr "``str(integer)``."

#: ../Doc/library/stdtypes.rst:5597
#, fuzzy
msgid "``repr(integer)``."
msgstr "``repr(integer)``"

#: ../Doc/library/stdtypes.rst:5598
#, python-format
msgid ""
"any other string conversion to base 10, for example ``f\"{integer}\"``, "
"``\"{}\".format(integer)``, or ``b\"%d\" % integer``."
msgstr ""
"cualquier otra conversión de cadena a base 10, por ejemplo, "
"``f\"{integer}\"``, ``\"{}\".format(integer)`` o ``b\"%d\" % integer``."

#: ../Doc/library/stdtypes.rst:5601
msgid "The limitations do not apply to functions with a linear algorithm:"
msgstr "Las limitaciones no se aplican a funciones con un algoritmo lineal:"

#: ../Doc/library/stdtypes.rst:5603
msgid "``int(string, base)`` with base 2, 4, 8, 16, or 32."
msgstr "``int(string, base)`` con base 2, 4, 8, 16 o 32."

#: ../Doc/library/stdtypes.rst:5604
msgid ":func:`int.from_bytes` and :func:`int.to_bytes`."
msgstr ":func:`int.from_bytes` y :func:`int.to_bytes`."

#: ../Doc/library/stdtypes.rst:5605
msgid ":func:`hex`, :func:`oct`, :func:`bin`."
msgstr ":func:`hex`, :func:`oct`, :func:`bin`."

#: ../Doc/library/stdtypes.rst:5606
msgid ":ref:`formatspec` for hex, octal, and binary numbers."
msgstr ":ref:`formatspec` para números hexadecimales, octales y binarios."

#: ../Doc/library/stdtypes.rst:5607
msgid ":class:`str` to :class:`float`."
msgstr ":class:`str` a :class:`float`."

#: ../Doc/library/stdtypes.rst:5608
msgid ":class:`str` to :class:`decimal.Decimal`."
msgstr ":class:`str` a :class:`decimal.Decimal`."

#: ../Doc/library/stdtypes.rst:5611
msgid "Configuring the limit"
msgstr "Configuración del límite"

#: ../Doc/library/stdtypes.rst:5613
msgid ""
"Before Python starts up you can use an environment variable or an "
"interpreter command line flag to configure the limit:"
msgstr ""
"Antes de que se inicie Python, puedes usar una variable de entorno o un "
"indicador de línea de comandos del intérprete para configurar el límite:"

#: ../Doc/library/stdtypes.rst:5616
msgid ""
":envvar:`PYTHONINTMAXSTRDIGITS`, e.g. ``PYTHONINTMAXSTRDIGITS=640 python3`` "
"to set the limit to 640 or ``PYTHONINTMAXSTRDIGITS=0 python3`` to disable "
"the limitation."
msgstr ""
":envvar:`PYTHONINTMAXSTRDIGITS`, por ejemplo, ``PYTHONINTMAXSTRDIGITS=640 "
"python3`` para configurar el límite a 640 o ``PYTHONINTMAXSTRDIGITS=0 "
"python3`` para desactivar la limitación."

#: ../Doc/library/stdtypes.rst:5619
msgid ""
":option:`-X int_max_str_digits <-X>`, e.g. ``python3 -X "
"int_max_str_digits=640``"
msgstr ""
":option:`-X int_max_str_digits <-X>`, por ejemplo, ``python3 -X "
"int_max_str_digits=640``"

#: ../Doc/library/stdtypes.rst:5621
#, fuzzy
msgid ""
":data:`sys.flags.int_max_str_digits` contains the value of :envvar:"
"`PYTHONINTMAXSTRDIGITS` or :option:`-X int_max_str_digits <-X>`. If both the "
"env var and the ``-X`` option are set, the ``-X`` option takes precedence. A "
"value of *-1* indicates that both were unset, thus a value of :data:`sys."
"int_info.default_max_str_digits` was used during initialization."
msgstr ""
":data:`sys.flags.int_max_str_digits` contiene el valor de :envvar:"
"`PYTHONINTMAXSTRDIGITS` o :option:`-X int_max_str_digits <-X>`. Si tanto la "
"variable env como la opción ``-X`` están configuradas, la opción ``-X`` "
"tiene prioridad. Un valor de *-1* indica que ambos no están configurados, "
"por lo que se usó un valor de :data:`sys.int_info.default_max_str_digits` "
"durante la inicialización."

#: ../Doc/library/stdtypes.rst:5627
msgid ""
"From code, you can inspect the current limit and set a new one using these :"
"mod:`sys` APIs:"
msgstr ""
"Desde el código, puedes inspeccionar el límite actual y configurar uno nuevo "
"al usar estas APIs de :mod:`sys`:"

#: ../Doc/library/stdtypes.rst:5630
msgid ""
":func:`sys.get_int_max_str_digits` and :func:`sys.set_int_max_str_digits` "
"are a getter and setter for the interpreter-wide limit. Subinterpreters have "
"their own limit."
msgstr ""
":func:`sys.get_int_max_str_digits` y :func:`sys.set_int_max_str_digits` son "
"un getter y un setter para el límite de todo el intérprete. Los "
"subintérpretes tienen su propio límite."

#: ../Doc/library/stdtypes.rst:5634
#, fuzzy
msgid ""
"Information about the default and minimum can be found in :data:`sys."
"int_info`:"
msgstr ""
"La información sobre el valor predeterminado y mínimo se puede encontrar en :"
"attr:`sys.int_info`:"

#: ../Doc/library/stdtypes.rst:5636
msgid ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` is the compiled-"
"in default limit."
msgstr ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` es el límite "
"predeterminado compilado."

#: ../Doc/library/stdtypes.rst:5638
msgid ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` is the lowest "
"accepted value for the limit (other than 0 which disables it)."
msgstr ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` es el valor "
"más bajo aceptado para el límite (aparte de 0, que lo desactiva)."

#: ../Doc/library/stdtypes.rst:5645
msgid ""
"Setting a low limit *can* lead to problems. While rare, code exists that "
"contains integer constants in decimal in their source that exceed the "
"minimum threshold. A consequence of setting the limit is that Python source "
"code containing decimal integer literals longer than the limit will "
"encounter an error during parsing, usually at startup time or import time or "
"even at installation time - anytime an up to date ``.pyc`` does not already "
"exist for the code. A workaround for source that contains such large "
"constants is to convert them to ``0x`` hexadecimal form as it has no limit."
msgstr ""
"Configurar un límite bajo *puede* generar problemas. Si bien es raro, existe "
"un código que contiene constantes enteras en decimal en su origen que excede "
"el umbral mínimo. Una consecuencia de configurar el límite es que el código "
"fuente de Python que contiene literales enteros decimales más grandes que el "
"límite encontrará un error durante el análisis, generalmente en el momento "
"de inicio o en el momento de importación o incluso en el momento de "
"instalación - en cualquier momento y actualizado, ``.pyc`` no existe ya para "
"el código. Una solución para la fuente que contiene constantes tan grandes "
"es convertirlas a la forma hexadecimal ``0x`` ya que no tiene límite."

#: ../Doc/library/stdtypes.rst:5654
msgid ""
"Test your application thoroughly if you use a low limit. Ensure your tests "
"run with the limit set early via the environment or flag so that it applies "
"during startup and even during any installation step that may invoke Python "
"to precompile ``.py`` sources to ``.pyc`` files."
msgstr ""
"Prueba tu aplicación minuciosamente si utilizas un límite bajo. Asegúrate de "
"que tus pruebas se ejecuten con el límite configurado temprano a través del "
"entorno o del indicador para que se aplique durante el inicio e incluso "
"durante cualquier paso de instalación que pueda invocar a Python para "
"precompilar las fuentes ``.py`` a los archivos ``.pyc``."

#: ../Doc/library/stdtypes.rst:5660
msgid "Recommended configuration"
msgstr "Configuración recomendada"

#: ../Doc/library/stdtypes.rst:5662
#, fuzzy
msgid ""
"The default :data:`sys.int_info.default_max_str_digits` is expected to be "
"reasonable for most applications. If your application requires a different "
"limit, set it from your main entry point using Python version agnostic code "
"as these APIs were added in security patch releases in versions before 3.12."
msgstr ""
"Se espera que el valor predeterminado :data:`sys.int_info."
"default_max_str_digits` sea razonable para la mayoría de las aplicaciones. "
"Si tu aplicación requiere un límite diferente, configúralo desde el punto de "
"entrada principal utilizando el código independiente de la versión de "
"Python, ya que estas APIs se agregaron en versiones de parches de seguridad "
"en versiones anteriores a la 3.11."

#: ../Doc/library/stdtypes.rst:5667
msgid "Example::"
msgstr "Por ejemplo::"

#: ../Doc/library/stdtypes.rst:5679
msgid "If you need to disable it entirely, set it to ``0``."
msgstr "Si necesitas deshabilitarlo por completo, configúralo en ``0``."

#: ../Doc/library/stdtypes.rst:5683
msgid "Footnotes"
msgstr "Notas al pie"

#: ../Doc/library/stdtypes.rst:5684
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""
"Se puede consultar información adicional sobre estos métodos especiales en "
"el manual de referencia de Python (:ref:`customization`)."

#: ../Doc/library/stdtypes.rst:5687
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr ""
"En consecuencia, la lista ``[1, 2]`` se considera igual que ``[1.0, 2.0]``, "
"y de forma similar para las tuplas."

#: ../Doc/library/stdtypes.rst:5690
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""
"Deben haberlo hecho, ya que el analizador no puede decir el tipo de "
"operandos."

#: ../Doc/library/stdtypes.rst:5692
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Los caracteres con versiones mayúsculas/minúsculas son aquellos cuya "
"categoría general corresponde con \"Lu\" (Letra, Mayúscula), \"Ll\" (Letra, "
"minúscula) o \"Lt\" (Letra, *titlecase*)."

#: ../Doc/library/stdtypes.rst:5695
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""
"Para formatear solo una tupla se debe, por tanto, usar una tupla conteniendo "
"un único elemento, que sería la tupla a ser formateada."

#: ../Doc/library/stdtypes.rst:13
#, fuzzy
msgid "built-in"
msgstr "Tipos integrados"

#: ../Doc/library/stdtypes.rst:13 ../Doc/library/stdtypes.rst:315
#: ../Doc/library/stdtypes.rst:392 ../Doc/library/stdtypes.rst:948
#: ../Doc/library/stdtypes.rst:1115 ../Doc/library/stdtypes.rst:1137
#: ../Doc/library/stdtypes.rst:1152 ../Doc/library/stdtypes.rst:4419
#: ../Doc/library/stdtypes.rst:5392
#, fuzzy
msgid "types"
msgstr "Tuplas"

#: ../Doc/library/stdtypes.rst:34 ../Doc/library/stdtypes.rst:1152
#: ../Doc/library/stdtypes.rst:4419
msgid "statement"
msgstr ""

#: ../Doc/library/stdtypes.rst:34
msgid "if"
msgstr ""

#: ../Doc/library/stdtypes.rst:34
msgid "while"
msgstr ""

#: ../Doc/library/stdtypes.rst:34
msgid "truth"
msgstr ""

#: ../Doc/library/stdtypes.rst:34
msgid "value"
msgstr ""

#: ../Doc/library/stdtypes.rst:34 ../Doc/library/stdtypes.rst:80
#: ../Doc/library/stdtypes.rst:207 ../Doc/library/stdtypes.rst:815
#, fuzzy
msgid "Boolean"
msgstr "Valores booleanos"

#: ../Doc/library/stdtypes.rst:34 ../Doc/library/stdtypes.rst:80
#: ../Doc/library/stdtypes.rst:392
#, fuzzy
msgid "operations"
msgstr "Operación"

#: ../Doc/library/stdtypes.rst:34
msgid "false"
msgstr ""

#: ../Doc/library/stdtypes.rst:44
#, fuzzy
msgid "true"
msgstr "Tuplas"

#: ../Doc/library/stdtypes.rst:51
#, fuzzy
msgid "None (Built-in object)"
msgstr "Otros tipos predefinidos"

#: ../Doc/library/stdtypes.rst:51
msgid "False (Built-in object)"
msgstr ""

#: ../Doc/library/stdtypes.rst:63 ../Doc/library/stdtypes.rst:97
#: ../Doc/library/stdtypes.rst:122 ../Doc/library/stdtypes.rst:194
#: ../Doc/library/stdtypes.rst:245 ../Doc/library/stdtypes.rst:392
#: ../Doc/library/stdtypes.rst:948
#, fuzzy
msgid "operator"
msgstr "Operación"

#: ../Doc/library/stdtypes.rst:63 ../Doc/library/stdtypes.rst:97
msgid "or"
msgstr ""

#: ../Doc/library/stdtypes.rst:63 ../Doc/library/stdtypes.rst:97
#, fuzzy
msgid "and"
msgstr "y::"

#: ../Doc/library/stdtypes.rst:63 ../Doc/library/stdtypes.rst:815
msgid "False"
msgstr ""

#: ../Doc/library/stdtypes.rst:63 ../Doc/library/stdtypes.rst:815
#, fuzzy
msgid "True"
msgstr "Tuplas"

#: ../Doc/library/stdtypes.rst:97
#, fuzzy
msgid "not"
msgstr "Notas"

#: ../Doc/library/stdtypes.rst:122
#, fuzzy
msgid "chaining"
msgstr "Significado"

#: ../Doc/library/stdtypes.rst:122
#, fuzzy
msgid "comparisons"
msgstr "Comparaciones"

#: ../Doc/library/stdtypes.rst:122
#, fuzzy
msgid "comparison"
msgstr "Comparaciones"

#: ../Doc/library/stdtypes.rst:122
msgid "=="
msgstr ""

#: ../Doc/library/stdtypes.rst:122
msgid "< (less)"
msgstr ""

#: ../Doc/library/stdtypes.rst:122
msgid "<="
msgstr ""

#: ../Doc/library/stdtypes.rst:122
msgid "> (greater)"
msgstr ""

#: ../Doc/library/stdtypes.rst:122
msgid ">="
msgstr ""

#: ../Doc/library/stdtypes.rst:122
msgid "!="
msgstr ""

#: ../Doc/library/stdtypes.rst:122
msgid "is"
msgstr ""

#: ../Doc/library/stdtypes.rst:122
#, fuzzy
msgid "is not"
msgstr "``is not``"

#: ../Doc/library/stdtypes.rst:162 ../Doc/library/stdtypes.rst:207
#: ../Doc/library/stdtypes.rst:932 ../Doc/library/stdtypes.rst:1115
#: ../Doc/library/stdtypes.rst:1137 ../Doc/library/stdtypes.rst:1257
#: ../Doc/library/stdtypes.rst:1336 ../Doc/library/stdtypes.rst:1380
#: ../Doc/library/stdtypes.rst:1502 ../Doc/library/stdtypes.rst:1538
#: ../Doc/library/stdtypes.rst:2512 ../Doc/library/stdtypes.rst:2531
#: ../Doc/library/stdtypes.rst:2638 ../Doc/library/stdtypes.rst:4218
#: ../Doc/library/stdtypes.rst:4419 ../Doc/library/stdtypes.rst:4894
#: ../Doc/library/stdtypes.rst:5149 ../Doc/library/stdtypes.rst:5317
#: ../Doc/library/stdtypes.rst:5356
#, fuzzy
msgid "object"
msgstr "Objetos Tipo"

#: ../Doc/library/stdtypes.rst:162 ../Doc/library/stdtypes.rst:207
#: ../Doc/library/stdtypes.rst:228 ../Doc/library/stdtypes.rst:315
#: ../Doc/library/stdtypes.rst:334
msgid "numeric"
msgstr ""

#: ../Doc/library/stdtypes.rst:162
#, fuzzy
msgid "objects"
msgstr "Objetos Tipo"

#: ../Doc/library/stdtypes.rst:162
#, fuzzy
msgid "comparing"
msgstr "Comparaciones"

#: ../Doc/library/stdtypes.rst:172
msgid "__eq__() (instance method)"
msgstr ""

#: ../Doc/library/stdtypes.rst:172
msgid "__ne__() (instance method)"
msgstr ""

#: ../Doc/library/stdtypes.rst:172
msgid "__lt__() (instance method)"
msgstr ""

#: ../Doc/library/stdtypes.rst:172
msgid "__le__() (instance method)"
msgstr ""

#: ../Doc/library/stdtypes.rst:172
msgid "__gt__() (instance method)"
msgstr ""

#: ../Doc/library/stdtypes.rst:172
msgid "__ge__() (instance method)"
msgstr ""

#: ../Doc/library/stdtypes.rst:194 ../Doc/library/stdtypes.rst:948
msgid "in"
msgstr ""

#: ../Doc/library/stdtypes.rst:194 ../Doc/library/stdtypes.rst:948
#, fuzzy
msgid "not in"
msgstr "``x not in s``"

#: ../Doc/library/stdtypes.rst:207 ../Doc/library/stdtypes.rst:228
#: ../Doc/library/stdtypes.rst:392
msgid "integer"
msgstr ""

#: ../Doc/library/stdtypes.rst:207 ../Doc/library/stdtypes.rst:228
#, fuzzy
msgid "floating point"
msgstr "Formato en coma flotante decimal."

#: ../Doc/library/stdtypes.rst:207 ../Doc/library/stdtypes.rst:228
msgid "complex number"
msgstr ""

#: ../Doc/library/stdtypes.rst:207
msgid "C"
msgstr ""

#: ../Doc/library/stdtypes.rst:207
msgid "language"
msgstr ""

#: ../Doc/library/stdtypes.rst:228
msgid "literals"
msgstr ""

#: ../Doc/library/stdtypes.rst:228
msgid "hexadecimal"
msgstr ""

#: ../Doc/library/stdtypes.rst:228
msgid "octal"
msgstr ""

#: ../Doc/library/stdtypes.rst:228
msgid "binary"
msgstr ""

#: ../Doc/library/stdtypes.rst:245
msgid "arithmetic"
msgstr ""

#: ../Doc/library/stdtypes.rst:245 ../Doc/library/stdtypes.rst:948
#: ../Doc/library/stdtypes.rst:1115 ../Doc/library/stdtypes.rst:4419
#: ../Doc/library/stdtypes.rst:5363 ../Doc/library/stdtypes.rst:5377
#: ../Doc/library/stdtypes.rst:5392
#, fuzzy
msgid "built-in function"
msgstr "Tipos integrados"

#: ../Doc/library/stdtypes.rst:245
msgid "int"
msgstr ""

#: ../Doc/library/stdtypes.rst:245
#, fuzzy
msgid "float"
msgstr "Flag"

#: ../Doc/library/stdtypes.rst:245
#, fuzzy
msgid "complex"
msgstr ":func:`complex`"

#: ../Doc/library/stdtypes.rst:245 ../Doc/library/stdtypes.rst:2388
#: ../Doc/library/stdtypes.rst:3606
msgid "+ (plus)"
msgstr ""

#: ../Doc/library/stdtypes.rst:245
#, fuzzy
msgid "unary operator"
msgstr "Separador de grupo"

#: ../Doc/library/stdtypes.rst:245
#, fuzzy
msgid "binary operator"
msgstr "Separador de grupo"

#: ../Doc/library/stdtypes.rst:245 ../Doc/library/stdtypes.rst:2388
#: ../Doc/library/stdtypes.rst:3606
msgid "- (minus)"
msgstr ""

#: ../Doc/library/stdtypes.rst:245 ../Doc/library/stdtypes.rst:2345
#: ../Doc/library/stdtypes.rst:3563
msgid "* (asterisk)"
msgstr ""

#: ../Doc/library/stdtypes.rst:245
msgid "/ (slash)"
msgstr ""

#: ../Doc/library/stdtypes.rst:245
msgid "//"
msgstr ""

#: ../Doc/library/stdtypes.rst:245 ../Doc/library/stdtypes.rst:2315
#: ../Doc/library/stdtypes.rst:3531
msgid "% (percent)"
msgstr ""

#: ../Doc/library/stdtypes.rst:245
msgid "**"
msgstr ""

#: ../Doc/library/stdtypes.rst:315 ../Doc/library/stdtypes.rst:392
#: ../Doc/library/stdtypes.rst:948 ../Doc/library/stdtypes.rst:1152
#: ../Doc/library/stdtypes.rst:4419
#, fuzzy
msgid "operations on"
msgstr "Operación"

#: ../Doc/library/stdtypes.rst:315
#, fuzzy
msgid "conjugate() (complex number method)"
msgstr "conjugado del número complejo *c*"

#: ../Doc/library/stdtypes.rst:334 ../Doc/library/stdtypes.rst:1604
#: ../Doc/library/stdtypes.rst:2512 ../Doc/library/stdtypes.rst:5392
#, fuzzy
msgid "module"
msgstr "Módulos"

#: ../Doc/library/stdtypes.rst:334
msgid "math"
msgstr ""

#: ../Doc/library/stdtypes.rst:334
msgid "floor() (in module math)"
msgstr ""

#: ../Doc/library/stdtypes.rst:334
msgid "ceil() (in module math)"
msgstr ""

#: ../Doc/library/stdtypes.rst:334
msgid "trunc() (in module math)"
msgstr ""

#: ../Doc/library/stdtypes.rst:334
#, fuzzy
msgid "conversions"
msgstr "Conversión"

#: ../Doc/library/stdtypes.rst:392
msgid "bitwise"
msgstr ""

#: ../Doc/library/stdtypes.rst:392
msgid "shifting"
msgstr ""

#: ../Doc/library/stdtypes.rst:392
#, fuzzy
msgid "masking"
msgstr "Significado"

#: ../Doc/library/stdtypes.rst:392
msgid "| (vertical bar)"
msgstr ""

#: ../Doc/library/stdtypes.rst:392
msgid "^ (caret)"
msgstr ""

#: ../Doc/library/stdtypes.rst:392
msgid "& (ampersand)"
msgstr ""

#: ../Doc/library/stdtypes.rst:392
msgid "<<"
msgstr ""

#: ../Doc/library/stdtypes.rst:392
msgid ">>"
msgstr ""

#: ../Doc/library/stdtypes.rst:392
msgid "~ (tilde)"
msgstr ""

#: ../Doc/library/stdtypes.rst:815
#, fuzzy
msgid "values"
msgstr "Valores booleanos"

#: ../Doc/library/stdtypes.rst:845
#, fuzzy
msgid "iterator protocol"
msgstr "Tipos de iteradores"

#: ../Doc/library/stdtypes.rst:845 ../Doc/library/stdtypes.rst:4809
msgid "protocol"
msgstr ""

#: ../Doc/library/stdtypes.rst:845
#, fuzzy
msgid "iterator"
msgstr "Tipos de iteradores"

#: ../Doc/library/stdtypes.rst:845 ../Doc/library/stdtypes.rst:932
#: ../Doc/library/stdtypes.rst:948 ../Doc/library/stdtypes.rst:1115
#: ../Doc/library/stdtypes.rst:1137 ../Doc/library/stdtypes.rst:1152
msgid "sequence"
msgstr ""

#: ../Doc/library/stdtypes.rst:845
#, fuzzy
msgid "iteration"
msgstr "Operación"

#: ../Doc/library/stdtypes.rst:845
msgid "container"
msgstr ""

#: ../Doc/library/stdtypes.rst:845
#, fuzzy
msgid "iteration over"
msgstr "Operación"

#: ../Doc/library/stdtypes.rst:948 ../Doc/library/stdtypes.rst:4419
msgid "len"
msgstr ""

#: ../Doc/library/stdtypes.rst:948
#, fuzzy
msgid "min"
msgstr "Significado"

#: ../Doc/library/stdtypes.rst:948
msgid "max"
msgstr ""

#: ../Doc/library/stdtypes.rst:948
#, fuzzy
msgid "concatenation"
msgstr "Operación"

#: ../Doc/library/stdtypes.rst:948
#, fuzzy
msgid "operation"
msgstr "Operación"

#: ../Doc/library/stdtypes.rst:948
#, fuzzy
msgid "repetition"
msgstr "Representación"

#: ../Doc/library/stdtypes.rst:948 ../Doc/library/stdtypes.rst:1152
#, fuzzy
msgid "subscript"
msgstr "Descripción"

#: ../Doc/library/stdtypes.rst:948 ../Doc/library/stdtypes.rst:1152
msgid "slice"
msgstr ""

#: ../Doc/library/stdtypes.rst:948
msgid "count() (sequence method)"
msgstr ""

#: ../Doc/library/stdtypes.rst:948
msgid "index() (sequence method)"
msgstr ""

#: ../Doc/library/stdtypes.rst:1004
msgid "loop"
msgstr ""

#: ../Doc/library/stdtypes.rst:1004
#, fuzzy
msgid "over mutable sequence"
msgstr "Tipos de secuencia mutables"

#: ../Doc/library/stdtypes.rst:1004
#, fuzzy
msgid "mutable sequence"
msgstr "Tipos de secuencia mutables"

#: ../Doc/library/stdtypes.rst:1004
msgid "loop over"
msgstr ""

#: ../Doc/library/stdtypes.rst:1115
msgid "immutable"
msgstr ""

#: ../Doc/library/stdtypes.rst:1115 ../Doc/library/stdtypes.rst:1336
#, fuzzy
msgid "tuple"
msgstr "Tuplas"

#: ../Doc/library/stdtypes.rst:1115
msgid "hash"
msgstr ""

#: ../Doc/library/stdtypes.rst:1137
msgid "mutable"
msgstr ""

#: ../Doc/library/stdtypes.rst:1137 ../Doc/library/stdtypes.rst:1152
#: ../Doc/library/stdtypes.rst:1257
#, fuzzy
msgid "list"
msgstr "Listas"

#: ../Doc/library/stdtypes.rst:1137 ../Doc/library/stdtypes.rst:2512
#: ../Doc/library/stdtypes.rst:2638 ../Doc/library/stdtypes.rst:2710
#: ../Doc/library/stdtypes.rst:3531
#, fuzzy
msgid "bytearray"
msgstr "Objetos de tipo *Bytearray*"

#: ../Doc/library/stdtypes.rst:1152 ../Doc/library/stdtypes.rst:4419
#: ../Doc/library/stdtypes.rst:5149 ../Doc/library/stdtypes.rst:5392
#, fuzzy
msgid "type"
msgstr "Tuplas"

#: ../Doc/library/stdtypes.rst:1152
msgid "assignment"
msgstr ""

#: ../Doc/library/stdtypes.rst:1152 ../Doc/library/stdtypes.rst:4419
msgid "del"
msgstr ""

#: ../Doc/library/stdtypes.rst:1152
msgid "append() (sequence method)"
msgstr ""

#: ../Doc/library/stdtypes.rst:1152
msgid "clear() (sequence method)"
msgstr ""

#: ../Doc/library/stdtypes.rst:1152
msgid "copy() (sequence method)"
msgstr ""

#: ../Doc/library/stdtypes.rst:1152
msgid "extend() (sequence method)"
msgstr ""

#: ../Doc/library/stdtypes.rst:1152
msgid "insert() (sequence method)"
msgstr ""

#: ../Doc/library/stdtypes.rst:1152
msgid "pop() (sequence method)"
msgstr ""

#: ../Doc/library/stdtypes.rst:1152
msgid "remove() (sequence method)"
msgstr ""

#: ../Doc/library/stdtypes.rst:1152
msgid "reverse() (sequence method)"
msgstr ""

#: ../Doc/library/stdtypes.rst:1380
#, fuzzy
msgid "range"
msgstr "Rangos"

#: ../Doc/library/stdtypes.rst:1502 ../Doc/library/stdtypes.rst:1551
#: ../Doc/library/stdtypes.rst:1596 ../Doc/library/stdtypes.rst:2315
#, fuzzy
msgid "string"
msgstr "Métodos de las cadenas de caracteres"

#: ../Doc/library/stdtypes.rst:1502
#, fuzzy
msgid "text sequence type"
msgstr "Tipos de secuencia mutables"

#: ../Doc/library/stdtypes.rst:1502 ../Doc/library/stdtypes.rst:1551
#: ../Doc/library/stdtypes.rst:1569
#, fuzzy
msgid "str (built-in class)"
msgstr "Otros tipos predefinidos"

#: ../Doc/library/stdtypes.rst:1502
msgid "(see also string)"
msgstr ""

#: ../Doc/library/stdtypes.rst:1538
msgid "io.StringIO"
msgstr ""

#: ../Doc/library/stdtypes.rst:1569 ../Doc/library/stdtypes.rst:2504
msgid "buffer protocol"
msgstr ""

#: ../Doc/library/stdtypes.rst:1569 ../Doc/library/stdtypes.rst:2512
#: ../Doc/library/stdtypes.rst:2531 ../Doc/library/stdtypes.rst:2710
#: ../Doc/library/stdtypes.rst:3531
#, fuzzy
msgid "bytes"
msgstr "Notas"

#: ../Doc/library/stdtypes.rst:1596 ../Doc/library/stdtypes.rst:2710
#, fuzzy
msgid "methods"
msgstr "Métodos"

#: ../Doc/library/stdtypes.rst:1604
msgid "re"
msgstr ""

#: ../Doc/library/stdtypes.rst:2123 ../Doc/library/stdtypes.rst:3385
msgid "universal newlines"
msgstr ""

#: ../Doc/library/stdtypes.rst:2123
#, fuzzy
msgid "str.splitlines method"
msgstr "Métodos de las cadenas de caracteres"

#: ../Doc/library/stdtypes.rst:2315
msgid "formatting, string (%)"
msgstr ""

#: ../Doc/library/stdtypes.rst:2315
msgid "interpolation, string (%)"
msgstr ""

#: ../Doc/library/stdtypes.rst:2315
msgid "formatting, printf"
msgstr ""

#: ../Doc/library/stdtypes.rst:2315
msgid "interpolation, printf"
msgstr ""

#: ../Doc/library/stdtypes.rst:2315 ../Doc/library/stdtypes.rst:3531
#, fuzzy
msgid "printf-style formatting"
msgstr "Usando el formateo tipo ``printf`` con bytes"

#: ../Doc/library/stdtypes.rst:2315 ../Doc/library/stdtypes.rst:3531
#, fuzzy
msgid "sprintf-style formatting"
msgstr "Usando el formateo tipo ``printf`` con bytes"

#: ../Doc/library/stdtypes.rst:2345 ../Doc/library/stdtypes.rst:3563
msgid "() (parentheses)"
msgstr ""

#: ../Doc/library/stdtypes.rst:2345 ../Doc/library/stdtypes.rst:2388
#: ../Doc/library/stdtypes.rst:3563 ../Doc/library/stdtypes.rst:3606
#, fuzzy
msgid "in printf-style formatting"
msgstr "Usando el formateo tipo ``printf`` con bytes"

#: ../Doc/library/stdtypes.rst:2345 ../Doc/library/stdtypes.rst:3563
msgid ". (dot)"
msgstr ""

#: ../Doc/library/stdtypes.rst:2388 ../Doc/library/stdtypes.rst:3606
msgid "# (hash)"
msgstr ""

#: ../Doc/library/stdtypes.rst:2388 ../Doc/library/stdtypes.rst:3606
msgid "space"
msgstr ""

#: ../Doc/library/stdtypes.rst:2504
#, fuzzy
msgid "binary sequence types"
msgstr "Tipos de secuencia inmutables"

#: ../Doc/library/stdtypes.rst:2512
#, fuzzy
msgid "memoryview"
msgstr "Vistas de memoria"

#: ../Doc/library/stdtypes.rst:2512
msgid "array"
msgstr ""

#: ../Doc/library/stdtypes.rst:3385
msgid "bytes.splitlines method"
msgstr ""

#: ../Doc/library/stdtypes.rst:3385
msgid "bytearray.splitlines method"
msgstr ""

#: ../Doc/library/stdtypes.rst:3531
#, fuzzy
msgid "formatting"
msgstr "Operación"

#: ../Doc/library/stdtypes.rst:3531
msgid "bytes (%)"
msgstr ""

#: ../Doc/library/stdtypes.rst:3531
#, fuzzy
msgid "bytearray (%)"
msgstr "Objetos de tipo *Bytearray*"

#: ../Doc/library/stdtypes.rst:3531
#, fuzzy
msgid "interpolation"
msgstr "Tabulación de línea"

#: ../Doc/library/stdtypes.rst:4218
msgid "set"
msgstr ""

#: ../Doc/library/stdtypes.rst:4419
#, fuzzy
msgid "mapping"
msgstr "Significado"

#: ../Doc/library/stdtypes.rst:4419
#, fuzzy
msgid "dictionary"
msgstr "Objetos tipos vista de diccionario"

#: ../Doc/library/stdtypes.rst:4502
msgid "__missing__()"
msgstr ""

#: ../Doc/library/stdtypes.rst:4809
#, fuzzy
msgid "context manager"
msgstr "Tipos gestores de contexto"

#: ../Doc/library/stdtypes.rst:4809
#, fuzzy
msgid "context management protocol"
msgstr "Tipos gestores de contexto"

#: ../Doc/library/stdtypes.rst:4809
#, fuzzy
msgid "context management"
msgstr "Tipos gestores de contexto"

#: ../Doc/library/stdtypes.rst:4882
#, fuzzy
msgid "annotation"
msgstr "Operación"

#: ../Doc/library/stdtypes.rst:4882
msgid "type annotation; type hint"
msgstr ""

#: ../Doc/library/stdtypes.rst:4894
#, fuzzy
msgid "GenericAlias"
msgstr "Tipo Alias Genérico"

#: ../Doc/library/stdtypes.rst:4894
msgid "Generic"
msgstr ""

#: ../Doc/library/stdtypes.rst:4894
#, fuzzy
msgid "Alias"
msgstr "Listas"

#: ../Doc/library/stdtypes.rst:5149
#, fuzzy
msgid "Union"
msgstr "Funciones"

#: ../Doc/library/stdtypes.rst:5149
#, fuzzy
msgid "union"
msgstr "Funciones"

#: ../Doc/library/stdtypes.rst:5317
#, fuzzy
msgid "method"
msgstr "Métodos"

#: ../Doc/library/stdtypes.rst:5356
msgid "code"
msgstr ""

#: ../Doc/library/stdtypes.rst:5356
#, fuzzy
msgid "code object"
msgstr "Objetos código"

#: ../Doc/library/stdtypes.rst:5363
msgid "compile"
msgstr ""

#: ../Doc/library/stdtypes.rst:5363
msgid "__code__ (function object attribute)"
msgstr ""

#: ../Doc/library/stdtypes.rst:5377
msgid "exec"
msgstr ""

#: ../Doc/library/stdtypes.rst:5377
#, fuzzy
msgid "eval"
msgstr "igual que"

#: ../Doc/library/stdtypes.rst:5416
msgid "..."
msgstr ""

#: ../Doc/library/stdtypes.rst:5416
msgid "ellipsis literal"
msgstr ""

#~ msgid "if *x* is false, then *y*, else *x*"
#~ msgstr "si *x* es falso, entonces *y*, si no, *x*"

#~ msgid ""
#~ "By default, the *errors* argument is not checked for best performances, "
#~ "but only used at the first encoding error. Enable the :ref:`Python "
#~ "Development Mode <devmode>`, or use a :ref:`debug build <debug-build>` to "
#~ "check *errors*."
#~ msgstr ""
#~ "Por defecto, el argumento *errors* no se verifica para mejor rendimiento, "
#~ "solo se usa con el primer error de codificación encontrado. Se puede "
#~ "habilitar el :ref:`modo de desarrollo de Python <devmode>`, o utilizar "
#~ "una :ref:`compilación de depuración <debug-build>` para verificar "
#~ "*errors*."

#~ msgid "Support for keyword arguments added."
#~ msgstr "Añade soporte para el uso de parámetros por nombre."

# Hay que ver si estas referencias se han traducido
#~ msgid ""
#~ "Return a string decoded from the given bytes.  Default encoding is "
#~ "``'utf-8'``. *errors* may be given to set a different error handling "
#~ "scheme.  The default for *errors* is ``'strict'``, meaning that encoding "
#~ "errors raise a :exc:`UnicodeError`.  Other possible values are "
#~ "``'ignore'``, ``'replace'`` and any other name registered via :func:"
#~ "`codecs.register_error`, see section :ref:`error-handlers`. For a list of "
#~ "possible encodings, see section :ref:`standard-encodings`."
#~ msgstr ""
#~ "Retorna una cadena de caracteres decodificada a partir de la secuencia de "
#~ "bytes. La codificación por defecto es ``'utf-8'``. El parámetro *errors* "
#~ "puede definir diferentes estrategias de gestión de errores. El valor por "
#~ "defecto de *errors* es ``'strict'``, que hace que cualquier error de la "
#~ "decodificación lanza una excepción de tipo :exc:`UnicodeError`. Otros "
#~ "valores posibles son ``'ignore'``, ``'replace'`` y cualquier otro nombre "
#~ "definido mediante la función :func:`codecs.register_error`, véase la "
#~ "sección :ref:`error-handlers`. Para un listado de todos los valores de "
#~ "codificación posibles, véase :ref:`standard-encodings`."

#~ msgid ""
#~ "By default, the *errors* argument is not checked for best performances, "
#~ "but only used at the first decoding error. Enable the :ref:`Python "
#~ "Development Mode <devmode>`, or use a :ref:`debug build <debug-build>` to "
#~ "check *errors*."
#~ msgstr ""
#~ "Por defecto, el argumento *errors* no se verifica para mejor rendimiento, "
#~ "solo se usa con el primer error de codificación encontrado. Se puede "
#~ "habilitar el :ref:`modo de desarrollo de Python <devmode>`, o utilizar "
#~ "una :ref:`compilación de depuración <debug-build>` para verificar "
#~ "*errors*."

#~ msgid ""
#~ "``len(view)`` is equal to the length of :class:`~memoryview.tolist`. If "
#~ "``view.ndim = 0``, the length is 1. If ``view.ndim = 1``, the length is "
#~ "equal to the number of elements in the view. For higher dimensions, the "
#~ "length is equal to the length of the nested list representation of the "
#~ "view. The :class:`~memoryview.itemsize` attribute will give you the "
#~ "number of bytes in a single element."
#~ msgstr ""
#~ "El resultado de ``len(view)`` es igual a la longitud de :class:"
#~ "`~memoryview.tolist`. Si ``view.ndim = 0``, la longitud es 1. Si ``view."
#~ "ndim = 1``, la longitud es igual al número de elementos en la vista. Para "
#~ "dimensiones superiores, la longitud es igual a la de la representación "
#~ "como lista anidada de la vista. El atributo :class:`~memoryview.itemsize` "
#~ "contiene el número de bytes que ocupa un único elemento."

#~ msgid ""
#~ "Boolean values are the two constant objects ``False`` and ``True``.  They "
#~ "are used to represent truth values (although other values can also be "
#~ "considered false or true).  In numeric contexts (for example when used as "
#~ "the argument to an arithmetic operator), they behave like the integers 0 "
#~ "and 1, respectively. The built-in function :func:`bool` can be used to "
#~ "convert any value to a Boolean, if the value can be interpreted as a "
#~ "truth value (see section :ref:`truth` above)."
#~ msgstr ""
#~ "Los valores booleanos o lógicos son los dos objetos constantes ``False`` "
#~ "y ``True``. Se usan para representar valores de verdad (aunque otros "
#~ "valores pueden ser considerados también como verdaderos o falsos). En "
#~ "contextos numéricos (por ejemplo, cuando se usan como argumentos de una "
#~ "operación aritmética) se comportan como los números enteros 0 y 1, "
#~ "respectivamente. Se puede usar la función incorporada :func:`bool` para "
#~ "convertir valores de cualquiera tipo a Booleanos, si dicho valor puede "
#~ "ser interpretado como valores verdaderos/falsos (véase la sección :ref:"
#~ "`truth` anterior)."

#~ msgid "They are written as ``False`` and ``True``, respectively."
#~ msgstr "Se escriben ``False`` y ``True``, respectivamente."
