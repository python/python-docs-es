# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2021-12-03 13:30+0100\n"
"Last-Translator: Cristián Maureira-Fredes <cmaureirafredes@gmail.com>\n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.0\n"

#: ../Doc/library/logging.config.rst:2
msgid ":mod:`logging.config` --- Logging configuration"
msgstr ":mod:`logging.config` --- Configuración de registro"

#: ../Doc/library/logging.config.rst:10
msgid "**Source code:** :source:`Lib/logging/config.py`"
msgstr "**Código fuente:** :source:`Lib/logging/config.py`"

#: ../Doc/library/logging.config.rst:14
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr ""
"Esta página solo contiene información de referencia. Para tutoriales, por "
"favor consulte"

#: ../Doc/library/logging.config.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Tutorial Básico <logging-basic-tutorial>`"

#: ../Doc/library/logging.config.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Tutorial Avanzado <logging-advanced-tutorial>`"

#: ../Doc/library/logging.config.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`Guía de registro *Logging* <logging-cookbook>`"

#: ../Doc/library/logging.config.rst:23
msgid "This section describes the API for configuring the logging module."
msgstr "Esta sección describe la API para configurar el módulo de registro."

#: ../Doc/library/logging.config.rst:28
msgid "Configuration functions"
msgstr "Funciones de configuración"

#: ../Doc/library/logging.config.rst:30
msgid ""
"The following functions configure the logging module. They are located in "
"the :mod:`logging.config` module.  Their use is optional --- you can "
"configure the logging module using these functions or by making calls to the "
"main API (defined in :mod:`logging` itself) and defining handlers which are "
"declared either in :mod:`logging` or :mod:`logging.handlers`."
msgstr ""
"Las siguientes funciones configuran el módulo de registro. Se encuentran en "
"el módulo :mod:`logging.config`.  Su uso es opcional --- puede configurar el "
"módulo de registro utilizando estas funciones o realizando llamadas a la API "
"principal (definida en :mod:`logging`) y definiendo los gestores que se "
"declaran en :mod:`logging` o :mod:`logging.handlers`."

#: ../Doc/library/logging.config.rst:38
msgid ""
"Takes the logging configuration from a dictionary.  The contents of this "
"dictionary are described in :ref:`logging-config-dictschema` below."
msgstr ""
"Toma la configuración de registro de un diccionario.  Los contenidos de este "
"diccionario se describen en :ref:`logging-config-dictschema` a continuación."

#: ../Doc/library/logging.config.rst:42
msgid ""
"If an error is encountered during configuration, this function will raise a :"
"exc:`ValueError`, :exc:`TypeError`, :exc:`AttributeError` or :exc:"
"`ImportError` with a suitably descriptive message.  The following is a "
"(possibly incomplete) list of conditions which will raise an error:"
msgstr ""
"Si se encuentra un error durante la configuración, esta función lanzará un :"
"exc:`ValueError`, :exc:`TypeError`, :exc:`AttributeError` o :exc:"
"`ImportError` con un mensaje descriptivo adecuado.  La siguiente es una "
"lista (posiblemente incompleta) de condiciones que lanzarán un error:"

#: ../Doc/library/logging.config.rst:48
msgid ""
"A ``level`` which is not a string or which is a string not corresponding to "
"an actual logging level."
msgstr ""
"Un ``level`` que no es una cadena o que es una cadena que no corresponde a "
"un nivel de registro real."

#: ../Doc/library/logging.config.rst:50
msgid "A ``propagate`` value which is not a boolean."
msgstr "Un valor de ``propagate`` que no es booleano."

#: ../Doc/library/logging.config.rst:51
msgid "An id which does not have a corresponding destination."
msgstr "Una identificación que no tiene un destino correspondiente."

#: ../Doc/library/logging.config.rst:52
msgid "A non-existent handler id found during an incremental call."
msgstr ""
"Una identificación de gestor inexistente encontrada durante una llamada "
"incremental."

#: ../Doc/library/logging.config.rst:53
msgid "An invalid logger name."
msgstr "Un nombre de registrador no válido."

#: ../Doc/library/logging.config.rst:54
msgid "Inability to resolve to an internal or external object."
msgstr "Incapacidad para resolver un objeto interno o externo."

#: ../Doc/library/logging.config.rst:56
msgid ""
"Parsing is performed by the :class:`DictConfigurator` class, whose "
"constructor is passed the dictionary used for configuration, and has a :meth:"
"`configure` method.  The :mod:`logging.config` module has a callable "
"attribute :attr:`dictConfigClass` which is initially set to :class:"
"`DictConfigurator`. You can replace the value of :attr:`dictConfigClass` "
"with a suitable implementation of your own."
msgstr ""
"El análisis se realiza mediante la clase :class:`DictConfigurator`, a cuyo "
"constructor se le pasa el diccionario utilizado para la configuración, y "
"tiene un método :meth:`configure`.  El módulo :mod:`logging.config` tiene un "
"atributo invocable :attr:`dictConfigClass` que se establece inicialmente en :"
"class:`DictConfigurator`. Puede reemplazar el valor de :attr:"
"`dictConfigClass` con una implementación adecuada propia."

#: ../Doc/library/logging.config.rst:64
msgid ""
":func:`dictConfig` calls :attr:`dictConfigClass` passing the specified "
"dictionary, and then calls the :meth:`configure` method on the returned "
"object to put the configuration into effect::"
msgstr ""
":func:`dictConfig` llama :attr:`dictConfigClass` pasando el diccionario "
"especificado, y luego llama al método :meth:`configure` en el objeto "
"retornado para que la configuración surta efecto::"

#: ../Doc/library/logging.config.rst:71
msgid ""
"For example, a subclass of :class:`DictConfigurator` could call "
"``DictConfigurator.__init__()`` in its own :meth:`__init__()`, then set up "
"custom prefixes which would be usable in the subsequent :meth:`configure` "
"call. :attr:`dictConfigClass` would be bound to this new subclass, and then :"
"func:`dictConfig` could be called exactly as in the default, uncustomized "
"state."
msgstr ""
"Por ejemplo, una subclase de :class:`DictConfigurator` podría llamar a "
"``DictConfigurator.__ init__()`` en su mismo :meth:`__init__()`, luego "
"configurar prefijos personalizados que serían utilizables en la siguiente "
"llamada :meth:`configure`. :attr:`dictConfigClass` estaría vinculado a esta "
"nueva subclase, y luego :func:`dictConfig` podría llamarse exactamente como "
"en el estado predeterminado, no personalizado."

#: ../Doc/library/logging.config.rst:82
msgid ""
"Reads the logging configuration from a :mod:`configparser`\\-format file. "
"The format of the file should be as described in :ref:`logging-config-"
"fileformat`. This function can be called several times from an application, "
"allowing an end user to select from various pre-canned configurations (if "
"the developer provides a mechanism to present the choices and load the "
"chosen configuration)."
msgstr ""
"Lee la configuración de registro desde un archivo de formato de :mod:"
"`configparser`. El formato del archivo debe ser como se describe en :ref:"
"`logging-config-fileformat`. Esta función se puede invocar varias veces "
"desde una aplicación, lo que permite al usuario final seleccionar entre "
"varias configuraciones predeterminadas (si el desarrollador proporciona un "
"mecanismo para presentar las opciones y cargar la configuración elegida)."

#: ../Doc/library/logging.config.rst:90
msgid ""
"It will raise :exc:`FileNotFoundError` if the file doesn't exist and :exc:"
"`RuntimeError` if the file is invalid or empty."
msgstr ""

#: ../Doc/library/logging.config.rst
msgid "Parameters"
msgstr "Parámetros"

#: ../Doc/library/logging.config.rst:94
msgid ""
"A filename, or a file-like object, or an instance derived from :class:"
"`~configparser.RawConfigParser`. If a ``RawConfigParser``-derived instance "
"is passed, it is used as is. Otherwise, a :class:`~configparser."
"Configparser` is instantiated, and the configuration read by it from the "
"object passed in ``fname``. If that has a :meth:`readline` method, it is "
"assumed to be a file-like object and read using :meth:`~configparser."
"ConfigParser.read_file`; otherwise, it is assumed to be a filename and "
"passed to :meth:`~configparser.ConfigParser.read`."
msgstr ""
"Un nombre de archivo, o un objeto similar a un archivo, o una instancia "
"derivada de :class:`~configparser.RawConfigParser`. Si se pasa una instancia "
"derivada de ``RawConfigParser``, se usa tal cual. De lo contrario, se "
"instancia :class:`~configparser.Configparser`, y la configuración leída "
"desde el objeto pasado en ``fname``. Si eso tiene un método :meth:"
"`readline`, se supone que es un objeto similar a un archivo y se lee usando :"
"meth:`~configparser.ConfigParser.read_file`; de lo contrario, se supone que "
"es un nombre de archivo y se pasa a :meth:`~configparser.ConfigParser.read`."

#: ../Doc/library/logging.config.rst:106
msgid ""
"Defaults to be passed to the ConfigParser can be specified in this argument."
msgstr ""
"Los valores predeterminados para pasar al ConfigParser se pueden especificar "
"en este argumento."

#: ../Doc/library/logging.config.rst:109
#, fuzzy
msgid ""
"If specified as ``False``, loggers which exist when this call is made are "
"left enabled. The default is ``True`` because this enables old behaviour in "
"a backward-compatible way. This behaviour is to disable any existing non-"
"root loggers unless they or their ancestors are explicitly named in the "
"logging configuration."
msgstr ""
"existen cuando se realiza esta llamada se dejan habilitados. El valor "
"predeterminado es ``True`` porque esto permite un comportamiento antiguo de "
"una manera compatible con versiones anteriores. Este comportamiento consiste "
"en deshabilitar cualquier registrador que no sea raíz existente a menos que "
"ellos o sus antepasados se mencionen explícitamente en la configuración de "
"registro."

#: ../Doc/library/logging.config.rst:118
msgid "The encoding used to open file when *fname* is filename."
msgstr ""
"La codificación que se usa para abrir archivos cuando *fname* es nombre del "
"archivo."

#: ../Doc/library/logging.config.rst:120
msgid ""
"An instance of a subclass of :class:`~configparser.RawConfigParser` is   now "
"accepted as a value for ``fname``. This facilitates:"
msgstr ""
"Una instancia de una subclase de :class:`~configparser.RawConfigParser`  "
"ahora se acepta como un valor para ``fname``. Esto facilita:"

#: ../Doc/library/logging.config.rst:124
msgid ""
"Use of a configuration file where logging configuration is just part of the "
"overall application configuration."
msgstr ""
"Uso de un archivo de configuración donde la configuración de registro es "
"solo parte de la configuración general de la aplicación."

#: ../Doc/library/logging.config.rst:126
msgid ""
"Use of a configuration read from a file, and then modified by the using "
"application (e.g. based on command-line parameters or other aspects of the "
"runtime environment) before being passed to ``fileConfig``."
msgstr ""
"Uso de una configuración leída de un archivo, y luego modificada por la "
"aplicación que lo usa (por ejemplo, basada en parámetros de línea de "
"comandos u otros aspectos del entorno de ejecución) antes de pasar a "
"``fileConfig``."

#: ../Doc/library/logging.config.rst:130
msgid "The *encoding* parameter is added."
msgstr "El parámetro *codificación* se añade."

#: ../Doc/library/logging.config.rst:133
msgid ""
"An exception will be thrown if the provided file doesn't exist or is invalid "
"or empty."
msgstr ""

#: ../Doc/library/logging.config.rst:139
msgid ""
"Starts up a socket server on the specified port, and listens for new "
"configurations. If no port is specified, the module's default :const:"
"`DEFAULT_LOGGING_CONFIG_PORT` is used. Logging configurations will be sent "
"as a file suitable for processing by :func:`dictConfig` or :func:"
"`fileConfig`. Returns a :class:`~threading.Thread` instance on which you can "
"call :meth:`~threading.Thread.start` to start the server, and which you can :"
"meth:`~threading.Thread.join` when appropriate. To stop the server, call :"
"func:`stopListening`."
msgstr ""
"Inicia un servidor de socket en el puerto especificado y escucha nuevas "
"configuraciones. Si no se especifica ningún puerto, se usa el valor "
"predeterminado del módulo :const:`DEFAULT_LOGGING_CONFIG_PORT`. Las "
"configuraciones de registro se enviarán como un archivo adecuado para su "
"procesamiento por :func:`dictConfig` o :func:`fileConfig`. Retorna una "
"instancia de :class:`~threading.Thread` en la que puede llamar :meth:"
"`~threading.Thread.start` para iniciar el servidor, y que puede :meth:"
"`~threading.Thread.join` cuando corresponda . Para detener el servidor, "
"llame a :func:`stopListening`."

#: ../Doc/library/logging.config.rst:148
msgid ""
"The ``verify`` argument, if specified, should be a callable which should "
"verify whether bytes received across the socket are valid and should be "
"processed. This could be done by encrypting and/or signing what is sent "
"across the socket, such that the ``verify`` callable can perform signature "
"verification and/or decryption. The ``verify`` callable is called with a "
"single argument - the bytes received across the socket - and should return "
"the bytes to be processed, or ``None`` to indicate that the bytes should be "
"discarded. The returned bytes could be the same as the passed in bytes (e.g. "
"when only verification is done), or they could be completely different "
"(perhaps if decryption were performed)."
msgstr ""
"El argumento ``verify``, si se especifica, debe ser invocable, lo que "
"debería verificar si los bytes recibidos en el socket son válidos y deben "
"procesarse. Esto podría hacerse encriptando y / o firmando lo que se envía a "
"través del socket, de modo que el ``verify`` invocable pueda realizar la "
"verificación o descifrado de la firma. El llamado invocable ``verify`` se "
"llama con un solo argumento (los bytes recibidos a través del socket) y debe "
"retornar los bytes a procesar, o ``None`` para indicar que los bytes deben "
"descartarse. Los bytes retornados podrían ser los mismos que los pasados en "
"bytes (por ejemplo, cuando solo se realiza la verificación), o podrían ser "
"completamente diferentes (tal vez si se realizó el descifrado)."

#: ../Doc/library/logging.config.rst:159
msgid ""
"To send a configuration to the socket, read in the configuration file and "
"send it to the socket as a sequence of bytes preceded by a four-byte length "
"string packed in binary using ``struct.pack('>L', n)``."
msgstr ""
"Para enviar una configuración al socket, lea el archivo de configuración y "
"envíelo al socket como una secuencia de bytes precedida por una cadena de "
"longitud de cuatro bytes empaquetada en binario usando ``struct.pack('>L', "
"n)``."

#: ../Doc/library/logging.config.rst:167
msgid ""
"Because portions of the configuration are passed through :func:`eval`, use "
"of this function may open its users to a security risk. While the function "
"only binds to a socket on ``localhost``, and so does not accept connections "
"from remote machines, there are scenarios where untrusted code could be run "
"under the account of the process which calls :func:`listen`. Specifically, "
"if the process calling :func:`listen` runs on a multi-user machine where "
"users cannot trust each other, then a malicious user could arrange to run "
"essentially arbitrary code in a victim user's process, simply by connecting "
"to the victim's :func:`listen` socket and sending a configuration which runs "
"whatever code the attacker wants to have executed in the victim's process. "
"This is especially easy to do if the default port is used, but not hard even "
"if a different port is used. To avoid the risk of this happening, use the "
"``verify`` argument to :func:`listen` to prevent unrecognised configurations "
"from being applied."
msgstr ""
"Debido a que partes de la configuración se pasan a través de :func:`eval`, "
"el uso de esta función puede abrir a sus usuarios a un riesgo de seguridad. "
"Si bien la función solo se une a un socket en ``localhost`` y, por lo tanto, "
"no acepta conexiones de máquinas remotas, hay escenarios en los que se puede "
"ejecutar código no confiable bajo la cuenta del proceso que llama :func:"
"`listen`. Específicamente, si el proceso que llama :func:`listen` se ejecuta "
"en una máquina multiusuario donde los usuarios no pueden confiar el uno en "
"el otro, entonces un usuario malintencionado podría hacer arreglos para "
"ejecutar código esencialmente arbitrario en el proceso del usuario víctima, "
"simplemente conectándose al socket :func:`listen` de la víctima y enviando "
"una configuración que ejecuta cualquier código que el atacante quiera "
"ejecutar en el proceso de la víctima. Esto es especialmente fácil de hacer "
"si se usa el puerto predeterminado, pero no es difícil incluso si se usa un "
"puerto diferente. Para evitar el riesgo de que esto suceda, use el argumento "
"``verify`` para :func:`listen` para escuchar y evitar que se apliquen "
"configuraciones no reconocidas."

#: ../Doc/library/logging.config.rst:183
msgid "The ``verify`` argument was added."
msgstr "Se agregó el argumento ``verify``."

#: ../Doc/library/logging.config.rst:188
msgid ""
"If you want to send configurations to the listener which don't disable "
"existing loggers, you will need to use a JSON format for the configuration, "
"which will use :func:`dictConfig` for configuration. This method allows you "
"to specify ``disable_existing_loggers`` as ``False`` in the configuration "
"you send."
msgstr ""
"Si desea enviar configuraciones al oyente que no deshabiliten los "
"registradores existentes, deberá usar un formato JSON para la configuración, "
"que utilizará :func:`dictConfig` para la configuración. Este método le "
"permite especificar ``disable_existing_loggers`` como ``False`` en la "
"configuración que envía."

#: ../Doc/library/logging.config.rst:197
msgid ""
"Stops the listening server which was created with a call to :func:`listen`. "
"This is typically called before calling :meth:`join` on the return value "
"from :func:`listen`."
msgstr ""
"Detiene el servidor de escucha que se creó con una llamada a :func:`listen`. "
"Esto normalmente se llama antes de llamar :meth:`join` en el valor de "
"retorno de :func:`listen`."

#: ../Doc/library/logging.config.rst:203
msgid "Security considerations"
msgstr "Consideraciones de seguridad"

#: ../Doc/library/logging.config.rst:205
msgid ""
"The logging configuration functionality tries to offer convenience, and in "
"part this is done by offering the ability to convert text in configuration "
"files into Python objects used in logging configuration - for example, as "
"described in :ref:`logging-config-dict-userdef`. However, these same "
"mechanisms (importing callables from user-defined modules and calling them "
"with parameters from the configuration) could be used to invoke any code you "
"like, and for this reason you should treat configuration files from "
"untrusted sources with *extreme caution* and satisfy yourself that nothing "
"bad can happen if you load them, before actually loading them."
msgstr ""

#: ../Doc/library/logging.config.rst:219
msgid "Configuration dictionary schema"
msgstr "Esquema del diccionario de configuración"

#: ../Doc/library/logging.config.rst:221
msgid ""
"Describing a logging configuration requires listing the various objects to "
"create and the connections between them; for example, you may create a "
"handler named 'console' and then say that the logger named 'startup' will "
"send its messages to the 'console' handler. These objects aren't limited to "
"those provided by the :mod:`logging` module because you might write your own "
"formatter or handler class. The parameters to these classes may also need to "
"include external objects such as ``sys.stderr``.  The syntax for describing "
"these objects and connections is defined in :ref:`logging-config-dict-"
"connections` below."
msgstr ""
"La descripción de una configuración de registro requiere una lista de los "
"diversos objetos para crear y las conexiones entre ellos; por ejemplo, puede "
"crear un gestor llamado 'consola' y luego decir que el registrador llamado "
"'inicio' enviará sus mensajes al gestor 'consola'. Estos objetos no se "
"limitan a los proporcionados por el módulo :mod:`logging` porque podría "
"escribir su propia clase de formateador o gestor. Los parámetros de estas "
"clases también pueden necesitar incluir objetos externos como ``sys."
"stderr``. La sintaxis para describir estos objetos y conexiones se define "
"en :ref:`logging-config-dict-connections` a continuación."

#: ../Doc/library/logging.config.rst:233
msgid "Dictionary Schema Details"
msgstr "Detalles del esquema del diccionario"

#: ../Doc/library/logging.config.rst:235
msgid ""
"The dictionary passed to :func:`dictConfig` must contain the following keys:"
msgstr ""
"El diccionario pasado a :func:`dictConfig` debe contener las siguientes "
"claves:"

#: ../Doc/library/logging.config.rst:238
msgid ""
"*version* - to be set to an integer value representing the schema version.  "
"The only valid value at present is 1, but having this key allows the schema "
"to evolve while still preserving backwards compatibility."
msgstr ""
"*version* - se establece en un valor entero que representa la versión del "
"esquema. El único valor válido en este momento es 1, pero tener esta clave "
"permite que el esquema evolucione sin perder la compatibilidad con versiones "
"anteriores."

#: ../Doc/library/logging.config.rst:243
msgid ""
"All other keys are optional, but if present they will be interpreted as "
"described below.  In all cases below where a 'configuring dict' is "
"mentioned, it will be checked for the special ``'()'`` key to see if a "
"custom instantiation is required.  If so, the mechanism described in :ref:"
"`logging-config-dict-userdef` below is used to create an instance; "
"otherwise, the context is used to determine what to instantiate."
msgstr ""
"Todas las demás claves son opcionales, pero si están presentes se "
"interpretarán como se describe a continuación. En todos los casos a "
"continuación, donde se menciona un 'dict de configuración', se verificará la "
"clave especial ``'()'`` para ver si se requiere una instanciación "
"personalizada. Si es así, el mecanismo descrito en :ref:`logging-config-dict-"
"userdef` a continuación se usa para crear una instancia; de lo contrario, el "
"contexto se usa para determinar qué instanciar."

#: ../Doc/library/logging.config.rst:252
msgid ""
"*formatters* - the corresponding value will be a dict in which each key is a "
"formatter id and each value is a dict describing how to configure the "
"corresponding :class:`~logging.Formatter` instance."
msgstr ""
"*formatters* - el valor correspondiente será un diccionario en el que cada "
"clave es una identificación de formateador y cada valor es un diccionario "
"que describe cómo configurar la instancia correspondiente :class:`~logging."
"Formatter`."

#: ../Doc/library/logging.config.rst:256
msgid ""
"The configuring dict is searched for the following optional keys which "
"correspond to the arguments passed to create a :class:`~logging.Formatter` "
"object:"
msgstr ""
"Se busca el diccionario de configuración por las siguientes claves "
"opcionales que corresponden a los argumentos pasados para crear un objeto :"
"class:`~logging.Formatter`:"

#: ../Doc/library/logging.config.rst:260
msgid "``format``"
msgstr "``format``"

#: ../Doc/library/logging.config.rst:261
msgid "``datefmt``"
msgstr "``datefmt``"

#: ../Doc/library/logging.config.rst:262
msgid "``style``"
msgstr "``style``"

#: ../Doc/library/logging.config.rst:263
msgid "``validate`` (since version >=3.8)"
msgstr "``validate`` (desde la versión >=3.8)"

#: ../Doc/library/logging.config.rst:264
#, fuzzy
msgid "``defaults`` (since version >=3.12)"
msgstr "``validate`` (desde la versión >=3.8)"

#: ../Doc/library/logging.config.rst:266
msgid ""
"An optional ``class`` key indicates the name of the formatter's class (as a "
"dotted module and class name).  The instantiation arguments are as for :"
"class:`~logging.Formatter`, thus this key is most useful for instantiating a "
"customised subclass of :class:`~logging.Formatter`.  For example, the "
"alternative class might present exception tracebacks in an expanded or "
"condensed format.  If your formatter requires different or extra "
"configuration keys, you should use :ref:`logging-config-dict-userdef`."
msgstr ""
"Una clave opcional ``class`` indica el nombre de la de clase del formateador "
"(como un módulo punteado y nombre de clase).  Por su parte los argumentos de "
"instanciación son :class:`~logging.Formatter`, de este modo esta clave es "
"más útil para instanciar una subclase personalizada de :class:`~logging."
"Formatter`.  Por ejemplo, la clase alternativa presentaría excepciones "
"rastreadas en un formato amplio o resumido.  Si tu formateador necesita "
"claves de configuración diferentes o extra debes usar :ref:`logging-config-"
"dict-userdef`."

#: ../Doc/library/logging.config.rst:275
msgid ""
"*filters* - the corresponding value will be a dict in which each key is a "
"filter id and each value is a dict describing how to configure the "
"corresponding Filter instance."
msgstr ""
"*filters* - el valor correspondiente será un diccionario en el que cada "
"clave es una identificación de filtro y cada valor es un diccionario que "
"describe cómo configurar la instancia de filtro correspondiente."

#: ../Doc/library/logging.config.rst:279
msgid ""
"The configuring dict is searched for the key ``name`` (defaulting to the "
"empty string) and this is used to construct a :class:`logging.Filter` "
"instance."
msgstr ""
"El diccionario de configuración busca la clave ``name`` (por defecto en la "
"cadena vacía) y esto se utiliza para construir una instancia de :class:"
"`logging.Filter`."

#: ../Doc/library/logging.config.rst:283
msgid ""
"*handlers* - the corresponding value will be a dict in which each key is a "
"handler id and each value is a dict describing how to configure the "
"corresponding Handler instance."
msgstr ""
"*handlers* - el valor correspondiente será un diccionario en el que cada "
"clave es una identificación de gestor y cada valor es un diccionario que "
"describe cómo configurar la instancia del gestor correspondiente."

#: ../Doc/library/logging.config.rst:287 ../Doc/library/logging.config.rst:332
msgid "The configuring dict is searched for the following keys:"
msgstr "El diccionario de configuración busca las siguientes claves:"

#: ../Doc/library/logging.config.rst:289
msgid ""
"``class`` (mandatory).  This is the fully qualified name of the handler "
"class."
msgstr ""
"``clase`` (obligatorio).  Este es el nombre completo de la clase de gestor."

#: ../Doc/library/logging.config.rst:292
msgid "``level`` (optional).  The level of the handler."
msgstr "``level`` (opcional).  El nivel del gestor."

#: ../Doc/library/logging.config.rst:294
msgid "``formatter`` (optional).  The id of the formatter for this handler."
msgstr ""
"``formatter`` (opcional).  La identificación del formateador para este "
"gestor."

#: ../Doc/library/logging.config.rst:297
msgid "``filters`` (optional).  A list of ids of the filters for this handler."
msgstr ""
"``filters`` (opcional).  Una lista de identificadores de los filtros para "
"este gestor."

#: ../Doc/library/logging.config.rst:300 ../Doc/library/logging.config.rst:341
msgid "``filters`` can take filter instances in addition to ids."
msgstr ""

#: ../Doc/library/logging.config.rst:303
msgid ""
"All *other* keys are passed through as keyword arguments to the handler's "
"constructor.  For example, given the snippet:"
msgstr ""
"Todas las claves *other* se pasan como argumentos de palabras clave al "
"constructor del gestor. Por ejemplo, dado el fragmento:"

#: ../Doc/library/logging.config.rst:322
msgid ""
"the handler with id ``console`` is instantiated as a :class:`logging."
"StreamHandler`, using ``sys.stdout`` as the underlying stream.  The handler "
"with id ``file`` is instantiated as a :class:`logging.handlers."
"RotatingFileHandler` with the keyword arguments ``filename='logconfig.log', "
"maxBytes=1024, backupCount=3``."
msgstr ""
"el gestor con id ``console`` se instancia como :class:`logging."
"StreamHandler`, usando ``sys.stdout`` como la secuencia subyacente.  El "
"gestor con la identificación ``file`` se instancia como :class:`logging."
"handlers.RotatingFileHandler` con los argumentos de la palabra clave "
"``filename='logconfig.log', maxBytes=1024, backupCount=3``."

#: ../Doc/library/logging.config.rst:328
msgid ""
"*loggers* - the corresponding value will be a dict in which each key is a "
"logger name and each value is a dict describing how to configure the "
"corresponding Logger instance."
msgstr ""
"*loggers* - el valor correspondiente será un diccionario en el que cada "
"clave es un nombre de *logger* y cada valor es un diccionario que describe "
"cómo configurar la instancia de *Logger* correspondiente."

#: ../Doc/library/logging.config.rst:334
msgid "``level`` (optional).  The level of the logger."
msgstr "``level`` (opcional). El nivel del registrador."

#: ../Doc/library/logging.config.rst:336
msgid "``propagate`` (optional).  The propagation setting of the logger."
msgstr ""
"``propagate`` (opcional).  La configuración de propagación del registrador."

#: ../Doc/library/logging.config.rst:338
msgid "``filters`` (optional).  A list of ids of the filters for this logger."
msgstr ""
"``filters`` (opcional). Una lista de identificadores de los filtros para "
"este registrador."

#: ../Doc/library/logging.config.rst:344
msgid ""
"``handlers`` (optional).  A list of ids of the handlers for this logger."
msgstr ""
"``handlers`` (opcional).  Una lista de identificadores de los gestores para "
"este registrador."

#: ../Doc/library/logging.config.rst:347
msgid ""
"The specified loggers will be configured according to the level, "
"propagation, filters and handlers specified."
msgstr ""
"Los registradores especificados se configurarán de acuerdo con el nivel, la "
"propagación, los filtros y los gestores especificados."

#: ../Doc/library/logging.config.rst:350
msgid ""
"*root* - this will be the configuration for the root logger. Processing of "
"the configuration will be as for any logger, except that the ``propagate`` "
"setting will not be applicable."
msgstr ""
"*root* - Esta será la configuración para el registrador raíz. El "
"procesamiento de la configuración será como para cualquier registrador, "
"excepto que la configuración de ``propagate`` no será aplicable."

#: ../Doc/library/logging.config.rst:354
msgid ""
"*incremental* - whether the configuration is to be interpreted as "
"incremental to the existing configuration.  This value defaults to "
"``False``, which means that the specified configuration replaces the "
"existing configuration with the same semantics as used by the existing :func:"
"`fileConfig` API."
msgstr ""
"*incremental* - si la configuración debe interpretarse como incremental a la "
"configuración existente. Este valor predeterminado es ``False``, lo que "
"significa que la configuración especificada reemplaza la configuración "
"existente con la misma semántica que la utilizada por la API existente :func:"
"`fileConfig`."

#: ../Doc/library/logging.config.rst:360
msgid ""
"If the specified value is ``True``, the configuration is processed as "
"described in the section on :ref:`logging-config-dict-incremental`."
msgstr ""
"Si el valor especificado es ``True``, la configuración se procesa como se "
"describe en la sección sobre :ref:`logging-config-dict-incremental`."

#: ../Doc/library/logging.config.rst:363
msgid ""
"*disable_existing_loggers* - whether any existing non-root loggers are to be "
"disabled. This setting mirrors the parameter of the same name in :func:"
"`fileConfig`. If absent, this parameter defaults to ``True``. This value is "
"ignored if *incremental* is ``True``."
msgstr ""
"*disable_existing_loggers* - si se debe deshabilitar cualquier registrador "
"que no sea raíz existente. Esta configuración refleja el parámetro del mismo "
"nombre en :func:`fileConfig`. Si está ausente, este parámetro tiene el valor "
"predeterminado ``True``. Este valor se ignora si *incremental* es ``True``."

#: ../Doc/library/logging.config.rst:371
msgid "Incremental Configuration"
msgstr "Configuración incremental"

#: ../Doc/library/logging.config.rst:373
msgid ""
"It is difficult to provide complete flexibility for incremental "
"configuration.  For example, because objects such as filters and formatters "
"are anonymous, once a configuration is set up, it is not possible to refer "
"to such anonymous objects when augmenting a configuration."
msgstr ""
"Es difícil proporcionar flexibilidad completa para la configuración "
"incremental. Por ejemplo, debido a que los objetos como los filtros y "
"formateadores son anónimos, una vez que se configura una configuración, no "
"es posible hacer referencia a dichos objetos anónimos al aumentar una "
"configuración."

#: ../Doc/library/logging.config.rst:379
msgid ""
"Furthermore, there is not a compelling case for arbitrarily altering the "
"object graph of loggers, handlers, filters, formatters at run-time, once a "
"configuration is set up; the verbosity of loggers and handlers can be "
"controlled just by setting levels (and, in the case of loggers, propagation "
"flags).  Changing the object graph arbitrarily in a safe way is problematic "
"in a multi-threaded environment; while not impossible, the benefits are not "
"worth the complexity it adds to the implementation."
msgstr ""
"Además, no hay un caso convincente para alterar arbitrariamente el gráfico "
"de objetos de registradores, gestores, filtros, formateadores en tiempo de "
"ejecución, una vez que se configura una configuración; la verbosidad de los "
"registradores y gestores se puede controlar simplemente estableciendo "
"niveles (y, en el caso de los registradores, flags de propagación). Cambiar "
"el gráfico de objetos de manera arbitraria y segura es problemático en un "
"entorno de subprocesos múltiples; Si bien no es imposible, los beneficios no "
"valen la complejidad que agrega a la implementación."

#: ../Doc/library/logging.config.rst:388
msgid ""
"Thus, when the ``incremental`` key of a configuration dict is present and is "
"``True``, the system will completely ignore any ``formatters`` and "
"``filters`` entries, and process only the ``level`` settings in the "
"``handlers`` entries, and the ``level`` and ``propagate`` settings in the "
"``loggers`` and ``root`` entries."
msgstr ""
"Por lo tanto, cuando la tecla ``incremental`` de un diccionario de "
"configuración está presente y es ``True``, el sistema ignorará por completo "
"cualquier entrada de ``formatters`` y ``filters``, y procesará solo el "
"``level`` configuraciones en las entradas de ``handlers``, y las "
"configuraciones de ``level`` y ``propagate`` en las entradas de ``loggers`` "
"y ``root``."

#: ../Doc/library/logging.config.rst:394
msgid ""
"Using a value in the configuration dict lets configurations to be sent over "
"the wire as pickled dicts to a socket listener. Thus, the logging verbosity "
"of a long-running application can be altered over time with no need to stop "
"and restart the application."
msgstr ""
"El uso de un valor en la configuración diccionario permite que las "
"configuraciones se envíen a través del cable como dictados en vinagre a un "
"escucha de socket. Por lo tanto, la verbosidad de registro de una aplicación "
"de larga ejecución puede modificarse con el tiempo sin necesidad de detener "
"y reiniciar la aplicación."

#: ../Doc/library/logging.config.rst:402
msgid "Object connections"
msgstr "Conexiones de objeto"

#: ../Doc/library/logging.config.rst:404
msgid ""
"The schema describes a set of logging objects - loggers, handlers, "
"formatters, filters - which are connected to each other in an object graph.  "
"Thus, the schema needs to represent connections between the objects.  For "
"example, say that, once configured, a particular logger has attached to it a "
"particular handler.  For the purposes of this discussion, we can say that "
"the logger represents the source, and the handler the destination, of a "
"connection between the two.  Of course in the configured objects this is "
"represented by the logger holding a reference to the handler.  In the "
"configuration dict, this is done by giving each destination object an id "
"which identifies it unambiguously, and then using the id in the source "
"object's configuration to indicate that a connection exists between the "
"source and the destination object with that id."
msgstr ""
"El esquema describe un conjunto de objetos de registro (registradores, "
"gestores, formateadores, filtros) que están conectados entre sí en un "
"gráfico de objetos. Por lo tanto, el esquema necesita representar conexiones "
"entre los objetos. Por ejemplo, supongamos que, una vez configurado, un "
"registrador particular le ha adjuntado un gestor particular. A los fines de "
"esta discusión, podemos decir que el registrador representa la fuente y el "
"gestor el destino de una conexión entre los dos. Por supuesto, en los "
"objetos configurados esto está representado por el registrador que tiene una "
"referencia al gestor. En la configuración dict, esto se hace dando a cada "
"objeto de destino una identificación que lo identifica inequívocamente, y "
"luego utilizando la identificación en la configuración del objeto de origen "
"para indicar que existe una conexión entre el origen y el objeto de destino "
"con esa identificación."

#: ../Doc/library/logging.config.rst:418
msgid "So, for example, consider the following YAML snippet:"
msgstr "Entonces, por ejemplo, considere el siguiente fragmento de YAML:"

#: ../Doc/library/logging.config.rst:439
msgid ""
"(Note: YAML used here because it's a little more readable than the "
"equivalent Python source form for the dictionary.)"
msgstr ""
"(Nota: YAML se usa aquí porque es un poco más legible que el formulario "
"fuente Python equivalente para el diccionario.)"

#: ../Doc/library/logging.config.rst:442
msgid ""
"The ids for loggers are the logger names which would be used "
"programmatically to obtain a reference to those loggers, e.g. ``foo.bar."
"baz``.  The ids for Formatters and Filters can be any string value (such as "
"``brief``, ``precise`` above) and they are transient, in that they are only "
"meaningful for processing the configuration dictionary and used to determine "
"connections between objects, and are not persisted anywhere when the "
"configuration call is complete."
msgstr ""
"Los identificadores para los registradores son los nombres de los "
"registradores que se utilizarían mediante programación para obtener una "
"referencia a esos registradores, por ejemplo ``foo.bar.baz``.  Los "
"identificadores para Formateadores y Filtros pueden ser cualquier valor de "
"cadena (como ``breve``, ``preciso`` arriba) y son transitorios, ya que solo "
"son significativos para procesar el diccionario de configuración y se "
"utilizan para determinar conexiones entre objetos , y no persisten en "
"ninguna parte cuando se completa la llamada de configuración."

#: ../Doc/library/logging.config.rst:450
msgid ""
"The above snippet indicates that logger named ``foo.bar.baz`` should have "
"two handlers attached to it, which are described by the handler ids ``h1`` "
"and ``h2``. The formatter for ``h1`` is that described by id ``brief``, and "
"the formatter for ``h2`` is that described by id ``precise``."
msgstr ""
"El fragmento anterior indica que el registrador llamado ``foo.bar.baz`` debe "
"tener dos gestores adjuntos, que se describen mediante los identificadores "
"de gestor ``h1`` y ``h2``. El formateador para ``h1`` es el descrito por "
"identificador ``brief``, y el formateador para ``h2`` es el descrito por "
"identificador ``precise``."

#: ../Doc/library/logging.config.rst:460
msgid "User-defined objects"
msgstr "Objetos definidos por el usuario"

#: ../Doc/library/logging.config.rst:462
msgid ""
"The schema supports user-defined objects for handlers, filters and "
"formatters.  (Loggers do not need to have different types for different "
"instances, so there is no support in this configuration schema for user-"
"defined logger classes.)"
msgstr ""
"El esquema admite objetos definidos por el usuario para gestores, filtros y "
"formateadores.  (Los registradores no necesitan tener diferentes tipos para "
"diferentes instancias, por lo que no hay soporte en este esquema de "
"configuración para las clases de registrador definidas por el usuario)."

#: ../Doc/library/logging.config.rst:467
msgid ""
"Objects to be configured are described by dictionaries which detail their "
"configuration.  In some places, the logging system will be able to infer "
"from the context how an object is to be instantiated, but when a user-"
"defined object is to be instantiated, the system will not know how to do "
"this.  In order to provide complete flexibility for user-defined object "
"instantiation, the user needs to provide a 'factory' - a callable which is "
"called with a configuration dictionary and which returns the instantiated "
"object. This is signalled by an absolute import path to the factory being "
"made available under the special key ``'()'``.  Here's a concrete example:"
msgstr ""
"Los objetos a configurar son descritos por diccionarios que detallan su "
"configuración. En algunos lugares, el sistema de registro podrá inferir del "
"contexto cómo se va a instanciar un objeto, pero cuando se va a instanciar "
"un objeto definido por el usuario, el sistema no sabrá cómo hacerlo. Con el "
"fin de proporcionar una flexibilidad completa para la creación de instancias "
"de objetos definidos por el usuario, el usuario debe proporcionar una "
"'fábrica', una llamada que se llama con un diccionario de configuración y "
"que retorna el objeto instanciado. Esto se indica mediante una ruta de "
"importación absoluta a la fábrica disponible bajo la tecla especial "
"``'()'``. Aquí hay un ejemplo concreto:"

#: ../Doc/library/logging.config.rst:493
msgid ""
"The above YAML snippet defines three formatters.  The first, with id "
"``brief``, is a standard :class:`logging.Formatter` instance with the "
"specified format string.  The second, with id ``default``, has a longer "
"format and also defines the time format explicitly, and will result in a :"
"class:`logging.Formatter` initialized with those two format strings.  Shown "
"in Python source form, the ``brief`` and ``default`` formatters have "
"configuration sub-dictionaries::"
msgstr ""
"El fragmento de YAML anterior define tres formateadores. El primero, con "
"identificador ``breve``, es una instancia estándar :class:`logging."
"Formatter` con la cadena de formato especificada. El segundo, con "
"identificador ``predeterminado``, tiene un formato más largo y también "
"define el formato de hora explícitamente, y dará como resultado :class:"
"`logging.Formatter` inicializado con esas dos cadenas de formato. En forma "
"de fuente Python, los formateadores ``breve`` y ``predeterminado`` tienen "
"sub-diccionarios de configuración::"

#: ../Doc/library/logging.config.rst:505
msgid "and::"
msgstr "y::"

#: ../Doc/library/logging.config.rst:512
msgid ""
"respectively, and as these dictionaries do not contain the special key "
"``'()'``, the instantiation is inferred from the context: as a result, "
"standard :class:`logging.Formatter` instances are created.  The "
"configuration sub-dictionary for the third formatter, with id ``custom``, "
"is::"
msgstr ""
"respectivamente, y como estos diccionarios no contienen la clave especial "
"``'()'``, la instanciación se infiere del contexto: como resultado, se crean "
"las instancias estándar :class:`logging.Formatter`.  El sub-diccionario de "
"configuración para el tercer formateador, con identificador ``custom``, es::"

#: ../Doc/library/logging.config.rst:525
msgid ""
"and this contains the special key ``'()'``, which means that user-defined "
"instantiation is wanted.  In this case, the specified factory callable will "
"be used. If it is an actual callable it will be used directly - otherwise, "
"if you specify a string (as in the example) the actual callable will be "
"located using normal import mechanisms. The callable will be called with the "
"**remaining** items in the configuration sub-dictionary as keyword "
"arguments.  In the above example, the formatter with id ``custom`` will be "
"assumed to be returned by the call::"
msgstr ""
"y esto contiene la clave especial ``'()'``, lo que significa que se desea la "
"creación de instancias definida por el usuario.  En este caso, se utilizará "
"la llamada especificada de fábrica especificada. Si es una llamada real, se "
"usará directamente; de lo contrario, si especifica una cadena (como en el "
"ejemplo), la llamada real se ubicará utilizando mecanismos de importación "
"normales. Se llamará al invocable con los elementos **restantes** en el sub-"
"diccionario de configuración como argumentos de palabras clave.  En el "
"ejemplo anterior, se supondrá que el formateador con identificador "
"``custom`` será retornado por la llamada::"

#: ../Doc/library/logging.config.rst:537
msgid ""
"The values for keys such as ``bar``, ``spam`` and ``answer`` in the above "
"example should not be configuration dictionaries or references such as "
"``cfg://foo`` or ``ext://bar``, because they will not be processed by the "
"configuration machinery, but passed to the callable as-is."
msgstr ""

#: ../Doc/library/logging.config.rst:542
msgid ""
"The key ``'()'`` has been used as the special key because it is not a valid "
"keyword parameter name, and so will not clash with the names of the keyword "
"arguments used in the call.  The ``'()'`` also serves as a mnemonic that the "
"corresponding value is a callable."
msgstr ""
"La clave ``'()'`` se ha utilizado como clave especial porque no es un nombre "
"de parámetro de palabra clave válido, por lo que no entrará en conflicto con "
"los nombres de los argumentos de palabras clave utilizados en la llamada. El "
"``'()'`` también sirve como mnemónico de que el valor correspondiente es "
"invocable."

#: ../Doc/library/logging.config.rst:547
msgid ""
"The ``filters`` member of ``handlers`` and ``loggers`` can take filter "
"instances in addition to ids."
msgstr ""
"Los miembros ``filter`` de ``handlers`` y ``loggers`` pueden tomar "
"instancias de filtro en adición a identificadores."

#: ../Doc/library/logging.config.rst:551
msgid ""
"You can also specify a special key ``'.'`` whose value is a dictionary is a "
"mapping of attribute names to values. If found, the specified attributes "
"will be set on the user-defined object before it is returned. Thus, with the "
"following configuration::"
msgstr ""
"Puedes especificar también una clave especial ``'.'`` cuyo valor es un "
"diccionario, con un mapeo de los nombres de atributo y sus valores. Si se "
"encuentran, los atributos especificados serán configurados en el objeto "
"definido por el usuario antes de ser retornado. En consecuencia, con la "
"configuración siguiente::"

#: ../Doc/library/logging.config.rst:567
msgid ""
"the returned formatter will have attribute ``foo`` set to ``'bar'`` and "
"attribute ``baz`` set to ``'bozz'``."
msgstr ""
"el formateador retornado tendrá el atributo ``foo`` establecido en ``'bar'`` "
"y el atributo ``baz`` establecido en ``'bozz'``."

#: ../Doc/library/logging.config.rst:570
msgid ""
"The values for attributes such as ``foo`` and ``baz`` in the above example "
"should not be configuration dictionaries or references such as ``cfg://foo`` "
"or ``ext://bar``, because they will not be processed by the configuration "
"machinery, but set as attribute values as-is."
msgstr ""

#: ../Doc/library/logging.config.rst:579
#, fuzzy
msgid "Handler configuration order"
msgstr "Configuración incremental"

#: ../Doc/library/logging.config.rst:581
msgid ""
"Handlers are configured in alphabetical order of their keys, and a "
"configured handler replaces the configuration dictionary in (a working copy "
"of) the ``handlers`` dictionary in the schema. If you use a construct such "
"as ``cfg://handlers.foo``, then initially ``handlers['foo']`` points to the "
"configuration dictionary for the handler named ``foo``, and later (once that "
"handler has been configured) it points to the configured handler instance. "
"Thus, ``cfg://handlers.foo`` could resolve to either a dictionary or a "
"handler instance. In general, it is wise to name handlers in a way such that "
"dependent handlers are configured _after_ any handlers they depend on; that "
"allows something like ``cfg://handlers.foo`` to be used in configuring a "
"handler that depends on handler ``foo``. If that dependent handler were "
"named ``bar``, problems would result, because the configuration of ``bar`` "
"would be attempted before that of ``foo``, and ``foo`` would not yet have "
"been configured. However, if the dependent handler were named ``foobar``, it "
"would be configured after ``foo``, with the result that ``cfg://handlers."
"foo`` would resolve to configured handler ``foo``, and not its configuration "
"dictionary."
msgstr ""

#: ../Doc/library/logging.config.rst:602
msgid "Access to external objects"
msgstr "Acceso a objetos externos"

#: ../Doc/library/logging.config.rst:604
msgid ""
"There are times where a configuration needs to refer to objects external to "
"the configuration, for example ``sys.stderr``.  If the configuration dict is "
"constructed using Python code, this is straightforward, but a problem arises "
"when the configuration is provided via a text file (e.g. JSON, YAML).  In a "
"text file, there is no standard way to distinguish ``sys.stderr`` from the "
"literal string ``'sys.stderr'``.  To facilitate this distinction, the "
"configuration system looks for certain special prefixes in string values and "
"treat them specially.  For example, if the literal string ``'ext://sys."
"stderr'`` is provided as a value in the configuration, then the ``ext://`` "
"will be stripped off and the remainder of the value processed using normal "
"import mechanisms."
msgstr ""
"Hay momentos en que una configuración debe referirse a objetos externos a la "
"configuración, por ejemplo, ``sys.stderr``. Si el diccionario de "
"configuración se construye utilizando el código Python, esto es sencillo, "
"pero surge un problema cuando la configuración se proporciona a través de un "
"archivo de texto (por ejemplo, JSON, YAML). En un archivo de texto, no hay "
"una forma estándar de distinguir ``sys.stderr`` de la cadena literal ``'sys."
"stderr'``. Para facilitar esta distinción, el sistema de configuración busca "
"ciertos prefijos especiales en valores de cadena y los trata especialmente. "
"Por ejemplo, si la cadena literal ``'ext://sys.stderr'`` se proporciona como "
"un valor en la configuración, entonces la ``ext://`` se eliminará y se "
"procesará el resto del valor utilizando mecanismos normales de importación."

#: ../Doc/library/logging.config.rst:617
msgid ""
"The handling of such prefixes is done in a way analogous to protocol "
"handling: there is a generic mechanism to look for prefixes which match the "
"regular expression ``^(?P<prefix>[a-z]+)://(?P<suffix>.*)$`` whereby, if the "
"``prefix`` is recognised, the ``suffix`` is processed in a prefix-dependent "
"manner and the result of the processing replaces the string value.  If the "
"prefix is not recognised, then the string value will be left as-is."
msgstr ""
"El manejo de dichos prefijos se realiza de manera análoga al manejo del "
"protocolo: existe un mecanismo genérico para buscar prefijos que coincidan "
"con la expresión regular ``^(?P<prefix>[a-z]+)://(?P<suffix>.*)$`` por el "
"cual, si se reconoce el ``prefix``, el ``suffix`` se procesa de manera "
"dependiente del prefijo y el resultado del procesamiento reemplaza el valor "
"de la cadena. Si no se reconoce el prefijo, el valor de la cadena se dejará "
"tal cual."

#: ../Doc/library/logging.config.rst:629
msgid "Access to internal objects"
msgstr "Acceso a objetos internos"

#: ../Doc/library/logging.config.rst:631
msgid ""
"As well as external objects, there is sometimes also a need to refer to "
"objects in the configuration.  This will be done implicitly by the "
"configuration system for things that it knows about.  For example, the "
"string value ``'DEBUG'`` for a ``level`` in a logger or handler will "
"automatically be converted to the value ``logging.DEBUG``, and the "
"``handlers``, ``filters`` and ``formatter`` entries will take an object id "
"and resolve to the appropriate destination object."
msgstr ""
"Además de los objetos externos, a veces también es necesario hacer "
"referencia a los objetos en la configuración. El sistema de configuración "
"hará esto implícitamente para las cosas que conoce. Por ejemplo, el valor de "
"cadena ``'DEBUG'`` para un ``level`` en un registrador o gestor se "
"convertirá automáticamente al valor ``logging.DEBUG``, y las entradas "
"``handlers``, ``filters`` y ``formatter`` tomarán una identificación de "
"objeto y se resuelven en el objeto de destino apropiado."

#: ../Doc/library/logging.config.rst:639
msgid ""
"However, a more generic mechanism is needed for user-defined objects which "
"are not known to the :mod:`logging` module.  For example, consider :class:"
"`logging.handlers.MemoryHandler`, which takes a ``target`` argument which is "
"another handler to delegate to. Since the system already knows about this "
"class, then in the configuration, the given ``target`` just needs to be the "
"object id of the relevant target handler, and the system will resolve to the "
"handler from the id.  If, however, a user defines a ``my.package.MyHandler`` "
"which has an ``alternate`` handler, the configuration system would not know "
"that the ``alternate`` referred to a handler.  To cater for this, a generic "
"resolution system allows the user to specify:"
msgstr ""
"Sin embargo, se necesita un mecanismo más genérico para los objetos "
"definidos por el usuario que no conoce el módulo :mod:`logging`.  Por "
"ejemplo, considere :class:`logging.handlers.MemoryHandler`, que toma un "
"argumento ``target`` que es otro gestor para delegar. Dado que el sistema ya "
"conoce esta clase, entonces en la configuración, el ``target`` dado solo "
"necesita ser la identificación del objeto del gestor de destino relevante, y "
"el sistema resolverá el gestor desde la identificación.  Sin embargo, si un "
"usuario define un ``my.package.MyHandler`` que tiene un gestor "
"``alternate``, el sistema de configuración no sabría que el ``alternate`` se "
"refería a un gestor.  Para atender esto, un sistema de resolución genérico "
"permite al usuario especificar:"

#: ../Doc/library/logging.config.rst:661
msgid ""
"The literal string ``'cfg://handlers.file'`` will be resolved in an "
"analogous way to strings with the ``ext://`` prefix, but looking in the "
"configuration itself rather than the import namespace.  The mechanism allows "
"access by dot or by index, in a similar way to that provided by ``str."
"format``.  Thus, given the following snippet:"
msgstr ""
"La cadena literal ``'cfg://handlers.file'`` se resolverá de manera análoga a "
"las cadenas con el prefijo ``ext://``, pero buscando en la configuración "
"misma en lugar del espacio de nombres de importación. El mecanismo permite "
"el acceso por punto o por índice, de manera similar a la proporcionada por "
"``str.format``. Por lo tanto, dado el siguiente fragmento:"

#: ../Doc/library/logging.config.rst:679
msgid ""
"in the configuration, the string ``'cfg://handlers'`` would resolve to the "
"dict with key ``handlers``, the string ``'cfg://handlers.email`` would "
"resolve to the dict with key ``email`` in the ``handlers`` dict, and so on.  "
"The string ``'cfg://handlers.email.toaddrs[1]`` would resolve to "
"``'dev_team@domain.tld'`` and the string ``'cfg://handlers.email."
"toaddrs[0]'`` would resolve to the value ``'support_team@domain.tld'``. The "
"``subject`` value could be accessed using either ``'cfg://handlers.email."
"subject'`` or, equivalently, ``'cfg://handlers.email[subject]'``.  The "
"latter form only needs to be used if the key contains spaces or non-"
"alphanumeric characters.  If an index value consists only of decimal digits, "
"access will be attempted using the corresponding integer value, falling back "
"to the string value if needed."
msgstr ""
"en la configuración, la cadena ``'cfg://handlers'`` resolvería al "
"diccionario con clave ``handlers``, la cadena ``'cfg://handlers.email`` "
"resolvería al diccionario con clave ``email`` en el diccionario "
"``handlers``, y así sucesivamente.  La cadena ``'cfg: //handlers.email."
"toaddrs [1]`` resolvería a ``'dev_team.domain.tld'`` y la cadena ``'cfg://"
"handlers.email.toaddrs[0]`` resolvería el valor ``'support_team@domain."
"tld'``. Se puede acceder al valor de ``subject`` usando ``'cfg://handlers."
"email.subject'`` o, de manera equivalente, ``'cfg://handlers."
"email[subject]'``.  La última forma solo debe usarse si la clave contiene "
"espacios o caracteres no alfanuméricos.  Si un valor de índice consta solo "
"de dígitos decimales, se intentará acceder utilizando el valor entero "
"correspondiente, volviendo al valor de cadena si es necesario."

#: ../Doc/library/logging.config.rst:693
msgid ""
"Given a string ``cfg://handlers.myhandler.mykey.123``, this will resolve to "
"``config_dict['handlers']['myhandler']['mykey']['123']``. If the string is "
"specified as ``cfg://handlers.myhandler.mykey[123]``, the system will "
"attempt to retrieve the value from ``config_dict['handlers']['myhandler']"
"['mykey'][123]``, and fall back to ``config_dict['handlers']['myhandler']"
"['mykey']['123']`` if that fails."
msgstr ""
"Dada una cadena ``cfg://handlers.myhandler.mykey.123``, esto se resolverá en "
"``config_dict['handlers']['myhandler']['mykey']['123']``. Si la cadena se "
"especifica como ``cfg: //handlers.myhandler.mykey[123]``, el sistema "
"intentará recuperar el valor de ``config_dict['handlers']['myhandler']"
"['mykey'][123]``, y vuelva a ``config_dict['handlers']['myhandler']['mykey']"
"['123']`` si eso falla."

#: ../Doc/library/logging.config.rst:705
msgid "Import resolution and custom importers"
msgstr "Resolución de importación e importadores personalizados"

#: ../Doc/library/logging.config.rst:707
msgid ""
"Import resolution, by default, uses the builtin :func:`__import__` function "
"to do its importing. You may want to replace this with your own importing "
"mechanism: if so, you can replace the :attr:`importer` attribute of the :"
"class:`DictConfigurator` or its superclass, the :class:`BaseConfigurator` "
"class. However, you need to be careful because of the way functions are "
"accessed from classes via descriptors. If you are using a Python callable to "
"do your imports, and you want to define it at class level rather than "
"instance level, you need to wrap it with :func:`staticmethod`. For example::"
msgstr ""
"La resolución de importación, por defecto, utiliza la función incorporada :"
"func:`__import__` para importar. Es posible que desee reemplazar esto con su "
"propio mecanismo de importación: si es así, puede reemplazar el atributo :"
"attr:`importer` de :class:`DictConfigurator` o su superclase, la clase :"
"class:`BaseConfigurator`. Sin embargo, debe tener cuidado debido a la forma "
"en que se accede a las funciones desde las clases a través de descriptores. "
"Si está utilizando un Python invocable para realizar sus importaciones, y lo "
"desea definir a nivel de clase en lugar de a nivel de instancia, debe "
"envolverlo con :func:`staticmethod`. Por ejemplo::"

#: ../Doc/library/logging.config.rst:722
msgid ""
"You don't need to wrap with :func:`staticmethod` if you're setting the "
"import callable on a configurator *instance*."
msgstr ""
"No necesita envolver con :func:`staticmethod` si está configurando la "
"importación invocable en un configurador *instance*."

#: ../Doc/library/logging.config.rst:728
msgid "Configuring QueueHandler and QueueListener"
msgstr ""

#: ../Doc/library/logging.config.rst:730
msgid ""
"If you want to configure a :class:`~logging.handlers.QueueHandler`, noting "
"that this is normally used in conjunction with a :class:`~logging.handlers."
"QueueListener`, you can configure both together. After the configuration, "
"the ``QueueListener`` instance will be available as the :attr:`~logging."
"handlers.QueueHandler.listener` attribute of the created handler, and that "
"in turn will be available to you using :func:`~logging.getHandlerByName` and "
"passing the name you have used for the ``QueueHandler`` in your "
"configuration. The dictionary schema for configuring the pair is shown in "
"the example YAML snippet below."
msgstr ""

#: ../Doc/library/logging.config.rst:751
msgid "The ``queue`` and ``listener`` keys are optional."
msgstr ""

#: ../Doc/library/logging.config.rst:753
msgid ""
"If the ``queue`` key is present, the corresponding value can be one of the "
"following:"
msgstr ""

#: ../Doc/library/logging.config.rst:755
msgid ""
"An actual instance of :class:`queue.Queue` or a subclass thereof. This is of "
"course only possible if you are constructing or modifying the configuration "
"dictionary in code."
msgstr ""

#: ../Doc/library/logging.config.rst:759
msgid ""
"A string that resolves to a callable which, when called with no arguments, "
"returns the :class:`queue.Queue` instance to use. That callable could be a :"
"class:`queue.Queue` subclass or a function which returns a suitable queue "
"instance, such as ``my.module.queue_factory()``."
msgstr ""

#: ../Doc/library/logging.config.rst:764
msgid ""
"A dict with a ``'()'`` key which is constructed in the usual way as "
"discussed in :ref:`logging-config-dict-userdef`. The result of this "
"construction should be a :class:`queue.Queue` instance."
msgstr ""

#: ../Doc/library/logging.config.rst:768
msgid ""
"If the  ``queue`` key is absent, a standard unbounded :class:`queue.Queue` "
"instance is created and used."
msgstr ""

#: ../Doc/library/logging.config.rst:771
msgid ""
"If the ``listener`` key is present, the corresponding value can be one of "
"the following:"
msgstr ""

#: ../Doc/library/logging.config.rst:773
msgid ""
"A subclass of :class:`logging.handlers.QueueListener`. This is of course "
"only possible if you are constructing or modifying the configuration "
"dictionary in code."
msgstr ""

#: ../Doc/library/logging.config.rst:777
msgid ""
"A string which resolves to a class which is a subclass of ``QueueListener``, "
"such as ``'my.package.CustomListener'``."
msgstr ""

#: ../Doc/library/logging.config.rst:780
msgid ""
"A dict with a ``'()'`` key which is constructed in the usual way as "
"discussed in :ref:`logging-config-dict-userdef`. The result of this "
"construction should be a callable with the same signature as the "
"``QueueListener`` initializer."
msgstr ""

#: ../Doc/library/logging.config.rst:784
msgid ""
"If the ``listener`` key is absent, :class:`logging.handlers.QueueListener` "
"is used."
msgstr ""

#: ../Doc/library/logging.config.rst:786
msgid ""
"The values under the ``handlers`` key are the names of other handlers in the "
"configuration (not shown in the above snippet) which will be passed to the "
"queue listener."
msgstr ""

#: ../Doc/library/logging.config.rst:790
msgid ""
"Any custom queue handler and listener classes will need to be defined with "
"the same initialization signatures as :class:`~logging.handlers."
"QueueHandler` and :class:`~logging.handlers.QueueListener`."
msgstr ""

#: ../Doc/library/logging.config.rst:799
msgid "Configuration file format"
msgstr "Formato de archivo de configuración"

#: ../Doc/library/logging.config.rst:801
msgid ""
"The configuration file format understood by :func:`fileConfig` is based on :"
"mod:`configparser` functionality. The file must contain sections called "
"``[loggers]``, ``[handlers]`` and ``[formatters]`` which identify by name "
"the entities of each type which are defined in the file. For each such "
"entity, there is a separate section which identifies how that entity is "
"configured.  Thus, for a logger named ``log01`` in the ``[loggers]`` "
"section, the relevant configuration details are held in a section "
"``[logger_log01]``. Similarly, a handler called ``hand01`` in the "
"``[handlers]`` section will have its configuration held in a section called "
"``[handler_hand01]``, while a formatter called ``form01`` in the "
"``[formatters]`` section will have its configuration specified in a section "
"called ``[formatter_form01]``. The root logger configuration must be "
"specified in a section called ``[logger_root]``."
msgstr ""
"El formato del archivo de configuración que entiende :func:`fileConfig` se "
"basa en la funcionalidad :mod:`configparser`. El archivo debe contener "
"secciones llamadas ``[loggers]``, ``[handlers]`` y ``[formatters]`` que "
"identifican por nombre las entidades de cada tipo que se definen en el "
"archivo. Para cada una de esas entidades, hay una sección separada que "
"identifica cómo se configura esa entidad. Por lo tanto, para un registrador "
"llamado ``log01`` en la sección ``[loggers]``, los detalles de configuración "
"relevantes se encuentran en una sección ``[logger_log01]``. Del mismo modo, "
"un gestor llamado ``hand01`` en la sección ``[handlers]`` tendrá su "
"configuración en una sección llamada ``[handler_hand01]``, mientras que un "
"formateador llamado ``form01`` en el ``[formatters]`` sección tendrá su "
"configuración especificada en una sección llamada ``[formatter_form01]``. La "
"configuración del registrador raíz debe especificarse en una sección llamada "
"``[logger_root]``."

#: ../Doc/library/logging.config.rst:816
msgid ""
"The :func:`fileConfig` API is older than the :func:`dictConfig` API and does "
"not provide functionality to cover certain aspects of logging. For example, "
"you cannot configure :class:`~logging.Filter` objects, which provide for "
"filtering of messages beyond simple integer levels, using :func:"
"`fileConfig`. If you need to have instances of :class:`~logging.Filter` in "
"your logging configuration, you will need to use :func:`dictConfig`. Note "
"that future enhancements to configuration functionality will be added to :"
"func:`dictConfig`, so it's worth considering transitioning to this newer API "
"when it's convenient to do so."
msgstr ""
"La API :func:`fileConfig` es más antigua que la API :func:`dictConfig` y no "
"proporciona funcionalidad para cubrir ciertos aspectos del registro. Por "
"ejemplo, no puede configurar objetos :class:`~logging.Filter`, que permiten "
"el filtrado de mensajes más allá de niveles enteros simples, usando :func:"
"`fileConfig`. Si necesita tener instancias de :class:`~logging.Filter` en su "
"configuración de registro, deberá usar :func:`dictConfig`. Tenga en cuenta "
"que las mejoras futuras a la funcionalidad de configuración se agregarán a :"
"func:`dictConfig`, por lo que vale la pena considerar la transición a esta "
"API más nueva cuando sea conveniente hacerlo."

#: ../Doc/library/logging.config.rst:826
msgid "Examples of these sections in the file are given below."
msgstr "A continuación se dan ejemplos de estas secciones en el archivo."

#: ../Doc/library/logging.config.rst:839
msgid ""
"The root logger must specify a level and a list of handlers. An example of a "
"root logger section is given below."
msgstr ""
"El registrador raíz debe especificar un nivel y una lista de gestores. A "
"continuación se muestra un ejemplo de una sección de registrador raíz."

#: ../Doc/library/logging.config.rst:848
msgid ""
"The ``level`` entry can be one of ``DEBUG, INFO, WARNING, ERROR, CRITICAL`` "
"or ``NOTSET``. For the root logger only, ``NOTSET`` means that all messages "
"will be logged. Level values are :ref:`evaluated <func-eval>` in the context "
"of the ``logging`` package's namespace."
msgstr ""
"La entrada ``level`` puede ser una de ``DEBUG, INFO, WARNING, ERROR, "
"CRITICAL`` o ``NOTSET``. Solo para el registrador raíz, ``NOTSET`` significa "
"que todos los mensajes se registrarán. Los valores de nivel son :func:"
"`evaluados <func-eval>` en el contexto del espacio de nombres del paquete "
"``logging``."

#: ../Doc/library/logging.config.rst:853
msgid ""
"The ``handlers`` entry is a comma-separated list of handler names, which "
"must appear in the ``[handlers]`` section. These names must appear in the "
"``[handlers]`` section and have corresponding sections in the configuration "
"file."
msgstr ""
"La entrada ``handlers`` es una lista separada por comas de nombres de "
"gestores, que debe aparecer en la sección ``[handlers]``. Estos nombres "
"deben aparecer en la sección ``[handlers]`` y tener las secciones "
"correspondientes en el archivo de configuración."

#: ../Doc/library/logging.config.rst:858
msgid ""
"For loggers other than the root logger, some additional information is "
"required. This is illustrated by the following example."
msgstr ""
"Para los registradores que no sean el registrador raíz, se requiere "
"información adicional. Esto se ilustra en el siguiente ejemplo."

#: ../Doc/library/logging.config.rst:869
msgid ""
"The ``level`` and ``handlers`` entries are interpreted as for the root "
"logger, except that if a non-root logger's level is specified as ``NOTSET``, "
"the system consults loggers higher up the hierarchy to determine the "
"effective level of the logger. The ``propagate`` entry is set to 1 to "
"indicate that messages must propagate to handlers higher up the logger "
"hierarchy from this logger, or 0 to indicate that messages are **not** "
"propagated to handlers up the hierarchy. The ``qualname`` entry is the "
"hierarchical channel name of the logger, that is to say the name used by the "
"application to get the logger."
msgstr ""
"Las entradas ``level`` y ``handlers`` se interpretan como para el "
"registrador raíz, excepto que si el nivel de un registrador que no sea raíz "
"se especifica como ``NOTSET``, el sistema consulta a los registradores más "
"arriba en la jerarquía para determinar el nivel efectivo del registrador. La "
"entrada ``propagate`` se establece en 1 para indicar que los mensajes deben "
"propagarse a los gestores que están más arriba en la jerarquía del "
"registrador, o 0 para indicar que los mensajes **no** se propagan a los "
"gestores en la jerarquía superior. La entrada ``qualname`` es el nombre "
"jerárquico del canal del registrador, es decir, el nombre utilizado por la "
"aplicación para obtener el registrador."

#: ../Doc/library/logging.config.rst:878
msgid ""
"Sections which specify handler configuration are exemplified by the "
"following."
msgstr ""
"Las secciones que especifican la configuración del gestor se ejemplifican a "
"continuación."

#: ../Doc/library/logging.config.rst:888
msgid ""
"The ``class`` entry indicates the handler's class (as determined by :func:"
"`eval` in the ``logging`` package's namespace). The ``level`` is interpreted "
"as for loggers, and ``NOTSET`` is taken to mean 'log everything'."
msgstr ""
"La entrada ``class`` indica la clase del gestor (según lo determinado por :"
"func:`eval` en el espacio de nombres del paquete ``logging``). El ``level`` "
"se interpreta como para los registradores, y ``NOTSET`` se entiende como "
"'registrar todo'."

#: ../Doc/library/logging.config.rst:892
msgid ""
"The ``formatter`` entry indicates the key name of the formatter for this "
"handler. If blank, a default formatter (``logging._defaultFormatter``) is "
"used. If a name is specified, it must appear in the ``[formatters]`` section "
"and have a corresponding section in the configuration file."
msgstr ""
"La entrada ``formatter`` indica el nombre clave del formateador para este "
"gestor. Si está en blanco, se utiliza un formateador predeterminado "
"(``logging._defaultFormatter``). Si se especifica un nombre, debe aparecer "
"en la sección ``[formatters]`` y tener una sección correspondiente en el "
"archivo de configuración."

#: ../Doc/library/logging.config.rst:897
msgid ""
"The ``args`` entry, when :ref:`evaluated <func-eval>` in the context of the "
"``logging`` package's namespace, is the list of arguments to the constructor "
"for the handler class. Refer to the constructors for the relevant handlers, "
"or to the examples below, to see how typical entries are constructed. If not "
"provided, it defaults to ``()``."
msgstr ""
"La entrada ``args``, cuando es :func:`evaluada <func-eval>` en el contexto "
"del espacio de nombres del paquete ``logging``, es la lista de argumentos "
"para el constructor de la clase gestor. Consulte los constructores de los "
"gestores relevantes, o los ejemplos a continuación, para ver cómo se "
"construyen las entradas típicas. Si no se proporciona, el valor "
"predeterminado es ``()``."

#: ../Doc/library/logging.config.rst:903
msgid ""
"The optional ``kwargs`` entry, when :ref:`evaluated <func-eval>` in the "
"context of the ``logging`` package's namespace, is the keyword argument dict "
"to the constructor for the handler class. If not provided, it defaults to "
"``{}``."
msgstr ""
"La entrada opcional ``kwargs``, cuando es :func:`evaluada <func-eval>` en el "
"contexto del espacio de nombres del paquete ``logging``, es el diccionario "
"generado a partir de los argumentos de palabra clave  para el constructor de "
"la clase gestor. Si no se proporciona, el valor predeterminado es ``{}``."

#: ../Doc/library/logging.config.rst:960
msgid ""
"Sections which specify formatter configuration are typified by the following."
msgstr ""
"Las secciones que especifican la configuración del formateador se "
"caracterizan por lo siguiente."

#: ../Doc/library/logging.config.rst:972
msgid ""
"The arguments for the formatter configuration are the same as the keys in "
"the dictionary schema :ref:`formatters section <logging-config-dictschema-"
"formatters>`."
msgstr ""
"Los argumentos para la configuración del formateador son los mismos que las "
"claves en el esquema del diccionario :ref:`formatters section <logging-"
"config-dictschema-formatters>`."

#: ../Doc/library/logging.config.rst:976
#, fuzzy
msgid ""
"The ``defaults`` entry, when :ref:`evaluated <func-eval>` in the context of "
"the ``logging`` package's namespace, is a dictionary of default values for "
"custom formatting fields. If not provided, it defaults to ``None``."
msgstr ""
"La entrada opcional ``kwargs``, cuando es :func:`evaluada <func-eval>` en el "
"contexto del espacio de nombres del paquete ``logging``, es el diccionario "
"generado a partir de los argumentos de palabra clave  para el constructor de "
"la clase gestor. Si no se proporciona, el valor predeterminado es ``{}``."

#: ../Doc/library/logging.config.rst:983
msgid ""
"Due to the use of :func:`eval` as described above, there are potential "
"security risks which result from using the :func:`listen` to send and "
"receive configurations via sockets. The risks are limited to where multiple "
"users with no mutual trust run code on the same machine; see the :func:"
"`listen` documentation for more information."
msgstr ""
"Debido al uso de :func:`eval` como se describió anteriormente, existen "
"riesgos potenciales de seguridad que resultan del uso de :func:`listen` para "
"enviar y recibir configuraciones a través de sockets. Los riesgos se limitan "
"a donde múltiples usuarios sin confianza mutua ejecutan código en la misma "
"máquina; consulte la documentación de :func:`listen` para obtener más "
"información."

#: ../Doc/library/logging.config.rst:992
msgid "Module :mod:`logging`"
msgstr "Módulo :mod:`logging`"

#: ../Doc/library/logging.config.rst:992
msgid "API reference for the logging module."
msgstr "Referencia de API para el módulo de registro."

#: ../Doc/library/logging.config.rst:994
msgid "Module :mod:`logging.handlers`"
msgstr "Módulo :mod:`logging.handlers`"

#: ../Doc/library/logging.config.rst:995
msgid "Useful handlers included with the logging module."
msgstr "Gestores útiles incluidos con el módulo de registro."

#~ msgid ""
#~ "If specified as ``False``, loggers which                                 "
#~ "exist when this call is made are left                                 "
#~ "enabled. The default is ``True`` because "
#~ "this                                 enables old behaviour in "
#~ "a                                 backward-compatible way. This behaviour "
#~ "is to                                 disable any existing non-root "
#~ "loggers unless                                 they or their ancestors "
#~ "are explicitly named                                 in the logging "
#~ "configuration.  :param encoding: The encoding used to open file when "
#~ "*fname* is filename."
#~ msgstr ""
#~ "Si se especifican como ``False``, los "
#~ "registradores                                 que existen cuando se hace "
#~ "esta llamada                                 se deshabilitan. El valor "
#~ "por defecto es ``True`` porque esto "
#~ "habilita                                 comportamientos "
#~ "antiguos                                  de una manera compatible con "
#~ "versiones anteriores. Este comportamiento consiste "
#~ "en                                 deshabilitar cualquier registrador que "
#~ "no sea raíz a menos que                                  ellos o sus "
#~ "antecesores sean explícitamente nombrados                                 "
#~ "en la configuración del registro.  :param encoding: La codificación que "
#~ "se usa para abrir archivos cuando *fname* es nombre del archivo."

#~ msgid "If specified as ``False``, loggers which"
#~ msgstr "Si se especifican como ``False``, los registradores que"

#~ msgid "param encoding"
#~ msgstr "param codificación"
