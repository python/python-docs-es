# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-05 12:54+0200\n"
"PO-Revision-Date: 2020-11-01 15:25+0100\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: Francisco Jesús Sevilla García <fjsevilla.dev@gmail.com>\n"
"Language: es_ES\n"
"X-Generator: Poedit 2.4.1\n"

#: ../Doc/library/decimal.rst:2
msgid ":mod:`decimal` --- Decimal fixed point and floating point arithmetic"
msgstr ":mod:`decimal` --- Aritmética decimal de coma fija y coma flotante"

#: ../Doc/library/decimal.rst:15
msgid "**Source code:** :source:`Lib/decimal.py`"
msgstr "**Código fuente:** :source:`Lib/decimal.py`"

#: ../Doc/library/decimal.rst:33
msgid ""
"The :mod:`decimal` module provides support for fast correctly-rounded "
"decimal floating point arithmetic. It offers several advantages over the :"
"class:`float` datatype:"
msgstr ""
"El módulo :mod:`decimal` proporciona soporte para aritmética decimal de coma "
"flotante rápida y con redondeo matemáticamente correcto. Ofrece varias "
"ventajas en comparación con el tipo de dato :class:`float`:"

#: ../Doc/library/decimal.rst:37
msgid ""
"Decimal \"is based on a floating-point model which was designed with people "
"in mind, and necessarily has a paramount guiding principle -- computers must "
"provide an arithmetic that works in the same way as the arithmetic that "
"people learn at school.\" -- excerpt from the decimal arithmetic "
"specification."
msgstr ""
"Decimal \"se basa en un modelo de coma flotante que se diseñó pensando en "
"las personas, y necesariamente tiene un principio rector supremo: las "
"computadoras deben proporcionar una aritmética que funcione de la misma "
"manera que la aritmética que las personas aprenden en la escuela.\" -- "
"extracto (traducido) de la especificación de la aritmética decimal."

#: ../Doc/library/decimal.rst:42
msgid ""
"Decimal numbers can be represented exactly.  In contrast, numbers like :"
"const:`1.1` and :const:`2.2` do not have exact representations in binary "
"floating point. End users typically would not expect ``1.1 + 2.2`` to "
"display as :const:`3.3000000000000003` as it does with binary floating point."
msgstr ""
"Los números decimales se pueden representar de forma exacta en coma flotante "
"decimal. En cambio, números como :const:`1.1` y :const:`2.2` no tienen "
"representaciones exactas en coma flotante binaria. Los usuarios finales "
"normalmente no esperaran que ``1.1 + 2.2`` se muestre como :const:"
"`3.3000000000000003`, como ocurre al usar la representación binaria en coma "
"flotante."

#: ../Doc/library/decimal.rst:47
msgid ""
"The exactness carries over into arithmetic.  In decimal floating point, "
"``0.1 + 0.1 + 0.1 - 0.3`` is exactly equal to zero.  In binary floating "
"point, the result is :const:`5.5511151231257827e-017`.  While near to zero, "
"the differences prevent reliable equality testing and differences can "
"accumulate. For this reason, decimal is preferred in accounting applications "
"which have strict equality invariants."
msgstr ""
"La exactitud se traslada a la aritmética. En coma flotante decimal, ``0.1 + "
"0.1 + 0.1 - 0.3`` es exactamente igual a cero. En coma flotante binaria, el "
"resultado es :const:`5.5511151231257827e-017`. Aunque cercanas a cero, las "
"diferencias impiden pruebas de igualdad confiables y las diferencias pueden "
"acumularse. Por estas razones, se recomienda el uso de decimal en "
"aplicaciones de contabilidad con estrictas restricciones de confiabilidad."

#: ../Doc/library/decimal.rst:54
msgid ""
"The decimal module incorporates a notion of significant places so that "
"``1.30 + 1.20`` is :const:`2.50`.  The trailing zero is kept to indicate "
"significance. This is the customary presentation for monetary applications. "
"For multiplication, the \"schoolbook\" approach uses all the figures in the "
"multiplicands.  For instance, ``1.3 * 1.2`` gives :const:`1.56` while ``1.30 "
"* 1.20`` gives :const:`1.5600`."
msgstr ""
"El módulo decimal incorpora una noción de dígitos significativos, de modo "
"que ``1.30 + 1.20`` es :const:`2.50`. El cero final se mantiene para indicar "
"el número de dígitos significativos. Esta es la representación habitual en "
"aplicaciones monetarias. Para la multiplicación, el método de \"libro escolar"
"\" utilizado usa todas las cifras de los multiplicandos. Por ejemplo, ``1.3 "
"* 1.2`` es igual a :const:`1.56`, mientras que ``1.30 * 1.20`` es igual a :"
"const:`1.5600`."

#: ../Doc/library/decimal.rst:61
msgid ""
"Unlike hardware based binary floating point, the decimal module has a user "
"alterable precision (defaulting to 28 places) which can be as large as "
"needed for a given problem:"
msgstr ""
"A diferencia del punto flotante binario basado en hardware, el módulo "
"decimal tiene una precisión modificable por el usuario (por defecto es de 28 "
"dígitos decimales) que puede ser tan grande como sea necesario para un "
"problema dado:"

#: ../Doc/library/decimal.rst:73
msgid ""
"Both binary and decimal floating point are implemented in terms of published "
"standards.  While the built-in float type exposes only a modest portion of "
"its capabilities, the decimal module exposes all required parts of the "
"standard. When needed, the programmer has full control over rounding and "
"signal handling. This includes an option to enforce exact arithmetic by "
"using exceptions to block any inexact operations."
msgstr ""
"Tanto la representación en coma flotante binaria como la decimal se "
"implementan de acuerdo a estándares publicados. Mientras que el tipo float "
"expone solo una pequeña parte de sus capacidades, el módulo decimal expone "
"todos los componentes requeridos del estándar. Cuando es necesario, el "
"desarrollador tiene control total sobre el redondeo y la gestión de las "
"señales. Esto incluye la capacidad de forzar la aritmética exacta, "
"utilizando excepciones para bloquear cualquier operación inexacta."

#: ../Doc/library/decimal.rst:80
msgid ""
"The decimal module was designed to support \"without prejudice, both exact "
"unrounded decimal arithmetic (sometimes called fixed-point arithmetic) and "
"rounded floating-point arithmetic.\"  -- excerpt from the decimal arithmetic "
"specification."
msgstr ""
"El módulo decimal fue diseñado para admitir \"indiscriminadamente, tanto "
"aritmética decimal exacta sin redondeo (a veces llamada aritmética de coma "
"fija) como la aritmética de coma flotante con redondeo.\" -- extracto "
"(traducido) de la especificación de la aritmética decimal."

#: ../Doc/library/decimal.rst:85
msgid ""
"The module design is centered around three concepts:  the decimal number, "
"the context for arithmetic, and signals."
msgstr ""
"El módulo está diseñado en torno a tres conceptos: el número decimal, el "
"contexto aritmético y las señales."

#: ../Doc/library/decimal.rst:88
msgid ""
"A decimal number is immutable.  It has a sign, coefficient digits, and an "
"exponent.  To preserve significance, the coefficient digits do not truncate "
"trailing zeros.  Decimals also include special values such as :const:"
"`Infinity`, :const:`-Infinity`, and :const:`NaN`.  The standard also "
"differentiates :const:`-0` from :const:`+0`."
msgstr ""
"Un número decimal es inmutable. Tiene un signo, un coeficiente y un "
"exponente. Para conservar el número de dígitos significativos, los ceros "
"iniciales no se truncan. Los números decimales también incluyen valores "
"especiales como :const:`Infinity`, :const:`-Infinity` y :const:`NaN`. El "
"estándar también marca la diferencia entre :const:`-0` y :const:`+0`."

#: ../Doc/library/decimal.rst:94
msgid ""
"The context for arithmetic is an environment specifying precision, rounding "
"rules, limits on exponents, flags indicating the results of operations, and "
"trap enablers which determine whether signals are treated as exceptions.  "
"Rounding options include :const:`ROUND_CEILING`, :const:`ROUND_DOWN`, :const:"
"`ROUND_FLOOR`, :const:`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, :const:"
"`ROUND_HALF_UP`, :const:`ROUND_UP`, and :const:`ROUND_05UP`."
msgstr ""
"El contexto aritmético es un entorno que permite especificar una precisión, "
"reglas de redondeo, límites en los exponentes, flags que indican el "
"resultado de las operaciones y habilitadores de trampas que especifican si "
"las señales (reportadas durante operaciones ilegales) son tratadas o no como "
"excepciones de Python. Las opciones de redondeo incluyen :const:"
"`ROUND_CEILING`, :const:`ROUND_DOWN`, :const:`ROUND_FLOOR`, :const:"
"`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, :const:`ROUND_HALF_UP`, :const:"
"`ROUND_UP` y :const:`ROUND_05UP`."

#: ../Doc/library/decimal.rst:101
msgid ""
"Signals are groups of exceptional conditions arising during the course of "
"computation.  Depending on the needs of the application, signals may be "
"ignored, considered as informational, or treated as exceptions. The signals "
"in the decimal module are: :const:`Clamped`, :const:`InvalidOperation`, :"
"const:`DivisionByZero`, :const:`Inexact`, :const:`Rounded`, :const:"
"`Subnormal`, :const:`Overflow`, :const:`Underflow` and :const:"
"`FloatOperation`."
msgstr ""
"Las señales son grupos de condiciones excepcionales que ocurren durante el "
"cálculo. Dependiendo de las necesidades de la aplicación, las señales pueden "
"ignorarse, tratarse como información o tratarse como excepciones. Las "
"señales existentes en el módulo decimal son :const:`Clamped`, :const:"
"`InvalidOperation`, :const:`DivisionByZero`, :const:`Inexact`, :const:"
"`Rounded`, :const:`Subnormal`, :const:`Overflow`, :const:`Underflow` y :"
"const:`FloatOperation`."

#: ../Doc/library/decimal.rst:108
msgid ""
"For each signal there is a flag and a trap enabler.  When a signal is "
"encountered, its flag is set to one, then, if the trap enabler is set to "
"one, an exception is raised.  Flags are sticky, so the user needs to reset "
"them before monitoring a calculation."
msgstr ""
"Por cada señal hay un flag y un habilitador de trampa. Cuando ocurre una "
"operación ilegal, su flag se establece en uno, luego, si su habilitador de "
"trampa está establecido en uno, se lanza una excepción. La configuración de "
"los flags es persistente, por lo que el usuario debe restablecerlos antes de "
"comenzar un cálculo que desee monitorear."

#: ../Doc/library/decimal.rst:116
msgid ""
"IBM's General Decimal Arithmetic Specification, `The General Decimal "
"Arithmetic Specification <http://speleotrove.com/decimal/decarith.html>`_."
msgstr ""
"Especificación general de la aritmética decimal de IBM, `The General Decimal "
"Arithmetic Specification <http://speleotrove.com/decimal/decarith.html>`_."

#: ../Doc/library/decimal.rst:125
msgid "Quick-start Tutorial"
msgstr "Tutorial de inicio rápido"

#: ../Doc/library/decimal.rst:127
msgid ""
"The usual start to using decimals is importing the module, viewing the "
"current context with :func:`getcontext` and, if necessary, setting new "
"values for precision, rounding, or enabled traps::"
msgstr ""
"El punto de partida habitual para usar decimales es importar el módulo, ver "
"el contexto actual con :func:`getcontext` y, si es necesario, establecer "
"nuevos valores para la precisión, el redondeo o trampas de señales "
"habilitadas::"

#: ../Doc/library/decimal.rst:139
msgid ""
"Decimal instances can be constructed from integers, strings, floats, or "
"tuples. Construction from an integer or a float performs an exact conversion "
"of the value of that integer or float.  Decimal numbers include special "
"values such as :const:`NaN` which stands for \"Not a number\", positive and "
"negative :const:`Infinity`, and :const:`-0`::"
msgstr ""
"Las instancias de la clase Decimal se pueden construir a partir de números "
"enteros, cadenas de caracteres, flotantes o tuplas. La construcción a partir "
"de un número entero o flotante realiza una conversión exacta del valor de "
"ese número. Los números decimales incluyen valores especiales como :const:"
"`NaN`, que significa \"No es un número\", :const:`Infinity` positivo y "
"negativo o :const:`-0`::"

#: ../Doc/library/decimal.rst:163
msgid ""
"If the :exc:`FloatOperation` signal is trapped, accidental mixing of "
"decimals and floats in constructors or ordering comparisons raises an "
"exception::"
msgstr ""
"Si la señal :exc:`FloatOperation` es atrapada, la mezcla accidental de "
"decimales y flotantes en constructores o comparaciones de orden lanzará una "
"excepción::"

#: ../Doc/library/decimal.rst:182
msgid ""
"The significance of a new Decimal is determined solely by the number of "
"digits input.  Context precision and rounding only come into play during "
"arithmetic operations."
msgstr ""
"La significación de un nuevo objeto Decimal es determinada únicamente por el "
"número de dígitos ingresados. La precisión y el redondeo establecidos en el "
"contexto solo entran en juego durante las operaciones aritméticas."

#: ../Doc/library/decimal.rst:199
msgid ""
"If the internal limits of the C version are exceeded, constructing a decimal "
"raises :class:`InvalidOperation`::"
msgstr ""
"Se lanza una excepción :class:`InvalidOperation` si durante la construcción "
"de un objeto Decimal se exceden los límites internos de la versión de C::"

#: ../Doc/library/decimal.rst:209
msgid ""
"Decimals interact well with much of the rest of Python.  Here is a small "
"decimal floating point flying circus:"
msgstr ""
"Los objetos Decimal interactúan bien con gran parte del resto de Python. "
"Aquí hay un pequeño circo volador de punto flotante decimal:"

#: ../Doc/library/decimal.rst:241
msgid "And some mathematical functions are also available to Decimal:"
msgstr ""
"Y algunas funciones matemáticas también están disponibles para Decimal:"

#: ../Doc/library/decimal.rst:253
msgid ""
"The :meth:`quantize` method rounds a number to a fixed exponent.  This "
"method is useful for monetary applications that often round results to a "
"fixed number of places:"
msgstr ""
"El método :meth:`quantize` redondea un número a un exponente fijo. Este "
"método es útil para aplicaciones monetarias, que a menudo redondean los "
"resultados a un número fijo de dígitos significativos:"

#: ../Doc/library/decimal.rst:262
msgid ""
"As shown above, the :func:`getcontext` function accesses the current context "
"and allows the settings to be changed.  This approach meets the needs of "
"most applications."
msgstr ""
"Como se muestra arriba, la función :func:`getcontext` accede al contexto "
"actual y permite cambiar la configuración. Este enfoque satisface las "
"necesidades de la mayoría de las aplicaciones."

#: ../Doc/library/decimal.rst:266
msgid ""
"For more advanced work, it may be useful to create alternate contexts using "
"the Context() constructor.  To make an alternate active, use the :func:"
"`setcontext` function."
msgstr ""
"Para trabajos más avanzados, puede resultar útil crear contextos "
"alternativos utilizando el constructor Context(). Para activar un contexto "
"alternativo, usa la función :func:`setcontext`."

#: ../Doc/library/decimal.rst:270
msgid ""
"In accordance with the standard, the :mod:`decimal` module provides two "
"ready to use standard contexts, :const:`BasicContext` and :const:"
"`ExtendedContext`. The former is especially useful for debugging because "
"many of the traps are enabled:"
msgstr ""
"De acuerdo con el estándar, el módulo :mod:`decimal` proporciona dos "
"contextos estándar listos para usar, :const:`BasicContext` y :const:"
"`ExtendedContext`. El primero es particularmente útil para la depuración, ya "
"que muchas de las trampas de señales están habilitadas por defecto:"

#: ../Doc/library/decimal.rst:299
msgid ""
"Contexts also have signal flags for monitoring exceptional conditions "
"encountered during computations.  The flags remain set until explicitly "
"cleared, so it is best to clear the flags before each set of monitored "
"computations by using the :meth:`clear_flags` method. ::"
msgstr ""
"Los objetos Context también tienen flags de señalización para detectar "
"condiciones excepcionales detectadas durante los cálculos. Estos flags "
"permanecen habilitados hasta que se restablecen explícitamente. Por esta "
"razón, suele ser buena idea restablecerlos mediante el método :meth:"
"`clear_flags` antes de proceder con cada conjunto de cálculos "
"monitorizados. ::"

#: ../Doc/library/decimal.rst:312
msgid ""
"The *flags* entry shows that the rational approximation to :const:`Pi` was "
"rounded (digits beyond the context precision were thrown away) and that the "
"result is inexact (some of the discarded digits were non-zero)."
msgstr ""
"La entrada *flags* muestra que la aproximación racional de :const:`Pi` fue "
"redondeada (los dígitos más allá de la precisión especificada por el "
"contexto se descartaron) y que el resultado es inexacto (algunos de los "
"dígitos descartados no eran cero)."

#: ../Doc/library/decimal.rst:316
msgid ""
"Individual traps are set using the dictionary in the :attr:`traps` field of "
"a context:"
msgstr ""
"Las trampas de señales se habilitan a través del diccionario expuesto por el "
"atributo :attr:`traps` del objeto Context:"

#: ../Doc/library/decimal.rst:331
msgid ""
"Most programs adjust the current context only once, at the beginning of the "
"program.  And, in many applications, data is converted to :class:`Decimal` "
"with a single cast inside a loop.  With context set and decimals created, "
"the bulk of the program manipulates the data no differently than with other "
"Python numeric types."
msgstr ""
"La mayoría de los programas ajustan el contexto actual una sola vez, al "
"comienzo del programa. Y, en muchas aplicaciones, los datos se convierten a :"
"class:`Decimal` mediante una única conversión dentro de un bucle. Con el "
"contexto establecido y los decimales creados, la mayor parte del programa "
"manipula los datos de la misma forma que con otros tipos numéricos de Python."

#: ../Doc/library/decimal.rst:343
msgid "Decimal objects"
msgstr "Objetos Decimal"

#: ../Doc/library/decimal.rst:348
msgid "Construct a new :class:`Decimal` object based from *value*."
msgstr "Construye un nuevo objeto :class:`Decimal` basado en *value*."

#: ../Doc/library/decimal.rst:350
msgid ""
"*value* can be an integer, string, tuple, :class:`float`, or another :class:"
"`Decimal` object. If no *value* is given, returns ``Decimal('0')``.  If "
"*value* is a string, it should conform to the decimal numeric string syntax "
"after leading and trailing whitespace characters, as well as underscores "
"throughout, are removed::"
msgstr ""
"*value* puede ser un entero, una cadena de caracteres, una tupla, un :class:"
"`float` u otro objeto :class:`Decimal`. Si no se proporciona *value*, "
"retorna ``Decimal('0')``. Si *value* es una cadena, debe ajustarse a la "
"sintaxis de cadena numérica decimal después de que los espacios en blanco "
"iniciales y finales, así como los guiones bajos, sean eliminados::"

#: ../Doc/library/decimal.rst:366
msgid ""
"Other Unicode decimal digits are also permitted where ``digit`` appears "
"above.  These include decimal digits from various other alphabets (for "
"example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits "
"``'\\uff10'`` through ``'\\uff19'``."
msgstr ""
"También se permiten otros dígitos decimales Unicode en aquellos lugares en "
"los que arriba aparece ``digit``. Estos incluyen dígitos decimales de otros "
"alfabetos (por ejemplo, dígitos del alfabeto árabe-índico y devanāgarī) "
"junto con los dígitos de ancho completo desde ``'\\uff10'`` a ``'\\uff19'``."

#: ../Doc/library/decimal.rst:371
msgid ""
"If *value* is a :class:`tuple`, it should have three components, a sign (:"
"const:`0` for positive or :const:`1` for negative), a :class:`tuple` of "
"digits, and an integer exponent. For example, ``Decimal((0, (1, 4, 1, 4), "
"-3))`` returns ``Decimal('1.414')``."
msgstr ""
"Si *value* es un objeto :class:`tuple`, debe tener tres componentes, un "
"signo (:const:`0` para positivo o :const:`1` para negativo), un objeto :"
"class:`tuple` con los dígitos y un exponente entero. Por ejemplo, "
"``Decimal((0, (1, 4, 1, 4), -3))`` retorna ``Decimal('1.414')``."

#: ../Doc/library/decimal.rst:376
msgid ""
"If *value* is a :class:`float`, the binary floating point value is "
"losslessly converted to its exact decimal equivalent.  This conversion can "
"often require 53 or more digits of precision.  For example, "
"``Decimal(float('1.1'))`` converts to "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``."
msgstr ""
"Si *value* es un :class:`float`, el valor binario de coma flotante se "
"convierte sin pérdidas a su equivalente decimal exacto. Esta conversión a "
"menudo puede requerir 53 o más dígitos de precisión. Por ejemplo, "
"``Decimal(float('1.1'))`` se convierte en "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``."

#: ../Doc/library/decimal.rst:382
msgid ""
"The *context* precision does not affect how many digits are stored. That is "
"determined exclusively by the number of digits in *value*. For example, "
"``Decimal('3.00000')`` records all five zeros even if the context precision "
"is only three."
msgstr ""
"La precisión de *context* no afecta a la cantidad de dígitos almacenados. "
"Eso está determinado exclusivamente por el número de dígitos en *value*. Por "
"ejemplo, ``Decimal('3.00000')`` registra los cinco ceros incluso si la "
"precisión del contexto es solo tres."

#: ../Doc/library/decimal.rst:387
msgid ""
"The purpose of the *context* argument is determining what to do if *value* "
"is a malformed string.  If the context traps :const:`InvalidOperation`, an "
"exception is raised; otherwise, the constructor returns a new Decimal with "
"the value of :const:`NaN`."
msgstr ""
"El propósito del argumento *context* es determinar qué hacer si *value* es "
"una cadena de caracteres mal formada. Si el contexto atrapa la señal :const:"
"`InvalidOperation`, se genera una excepción; de lo contrario, el constructor "
"retorna un nuevo decimal con el valor :const:`NaN`."

#: ../Doc/library/decimal.rst:392
msgid "Once constructed, :class:`Decimal` objects are immutable."
msgstr "Una vez construidos, los objetos :class:`Decimal` son inmutables."

#: ../Doc/library/decimal.rst:394
msgid ""
"The argument to the constructor is now permitted to be a :class:`float` "
"instance."
msgstr ""
"Ahora se permite que el argumento del constructor sea una instancia :class:"
"`float`."

#: ../Doc/library/decimal.rst:398
msgid ""
":class:`float` arguments raise an exception if the :exc:`FloatOperation` "
"trap is set. By default the trap is off."
msgstr ""
"Los argumentos :class:`float` ahora generan una excepción si se establece la "
"trampa :exc:`FloatOperation`. Por defecto, la trampa está desactivada."

#: ../Doc/library/decimal.rst:402
msgid ""
"Underscores are allowed for grouping, as with integral and floating-point "
"literals in code."
msgstr ""
"Se permiten guiones bajos para la agrupación, como ocurre en el código con "
"los literales enteros y de punto flotante."

#: ../Doc/library/decimal.rst:406
msgid ""
"Decimal floating point objects share many properties with the other built-in "
"numeric types such as :class:`float` and :class:`int`.  All of the usual "
"math operations and special methods apply.  Likewise, decimal objects can be "
"copied, pickled, printed, used as dictionary keys, used as set elements, "
"compared, sorted, and coerced to another type (such as :class:`float` or :"
"class:`int`)."
msgstr ""
"Los objetos de coma flotante decimal comparten muchas propiedades con los "
"otros tipos numéricos integrados, como :class:`float` e :class:`int`. Se "
"aplican todas las operaciones matemáticas habituales y los métodos "
"especiales. Asimismo, los objetos decimales se pueden copiar, serializar con "
"pickle, imprimir, usar como claves de un diccionario o como elementos de un "
"conjunto, comparar, ordenar y convertir a otros tipos (como :class:`float` "
"o :class:`int`)."

#: ../Doc/library/decimal.rst:413
msgid ""
"There are some small differences between arithmetic on Decimal objects and "
"arithmetic on integers and floats.  When the remainder operator ``%`` is "
"applied to Decimal objects, the sign of the result is the sign of the "
"*dividend* rather than the sign of the divisor::"
msgstr ""
"Hay algunas pequeñas diferencias entre la aritmética en objetos decimales y "
"la aritmética en enteros y flotantes. Cuando el operador de resto ``%`` se "
"aplica a objetos Decimal, el signo del resultado es el signo del *dividendo* "
"en lugar del signo del divisor::"

#: ../Doc/library/decimal.rst:423
msgid ""
"The integer division operator ``//`` behaves analogously, returning the "
"integer part of the true quotient (truncating towards zero) rather than its "
"floor, so as to preserve the usual identity ``x == (x // y) * y + x % y``::"
msgstr ""
"El operador de división entera ``//`` se comporta de manera análoga, "
"retornando la parte entera del cociente verdadero (truncando hacia cero) en "
"lugar del resultado de aplicarle la función suelo. Esto se hace con la "
"finalidad de preservar la identidad habitual ``x == (x // y) * y + x % y``::"

#: ../Doc/library/decimal.rst:432
msgid ""
"The ``%`` and ``//`` operators implement the ``remainder`` and ``divide-"
"integer`` operations (respectively) as described in the specification."
msgstr ""
"Los operadores ``%`` y ``//`` implementan las operaciones ``remainder`` y "
"``divide-integer`` (respectivamente) como se describe en la especificación."

#: ../Doc/library/decimal.rst:436
msgid ""
"Decimal objects cannot generally be combined with floats or instances of :"
"class:`fractions.Fraction` in arithmetic operations: an attempt to add a :"
"class:`Decimal` to a :class:`float`, for example, will raise a :exc:"
"`TypeError`.  However, it is possible to use Python's comparison operators "
"to compare a :class:`Decimal` instance ``x`` with another number ``y``.  "
"This avoids confusing results when doing equality comparisons between "
"numbers of different types."
msgstr ""
"Los objetos de la clase Decimal generalmente no se pueden combinar con "
"flotantes o instancias de :class:`fractions.Fraction` en operaciones "
"aritméticas: un intento de agregar un objeto :class:`Decimal` a un :class:"
"`float`, por ejemplo, lanzará una excepción :exc:`TypeError`. Sin embargo, "
"es posible usar los operadores de comparación de Python para comparar una "
"instancia de :class:`Decimal` ``x`` con otro número ``y``. Esto evita "
"resultados confusos al hacer comparaciones de igualdad entre números de "
"diferentes tipos."

#: ../Doc/library/decimal.rst:444
msgid ""
"Mixed-type comparisons between :class:`Decimal` instances and other numeric "
"types are now fully supported."
msgstr ""
"Las comparaciones de tipo mixto entre instancias de :class:`Decimal` y otros "
"tipos numéricos ahora son totalmente compatibles."

#: ../Doc/library/decimal.rst:448
msgid ""
"In addition to the standard numeric properties, decimal floating point "
"objects also have a number of specialized methods:"
msgstr ""
"Además de las propiedades numéricas estándar, los objetos de coma flotante "
"decimal también tienen varios métodos especializados:"

#: ../Doc/library/decimal.rst:454
msgid ""
"Return the adjusted exponent after shifting out the coefficient's rightmost "
"digits until only the lead digit remains: ``Decimal('321e+5').adjusted()`` "
"returns seven.  Used for determining the position of the most significant "
"digit with respect to the decimal point."
msgstr ""
"Retorna el exponente ajustado después de desplazar los dígitos del extremo "
"derecho del coeficiente hasta que solo quede el dígito principal: "
"``Decimal('321e+5').adjusted()`` retorna siete. Se utiliza para determinar "
"la posición del dígito más significativo con respecto al punto decimal."

#: ../Doc/library/decimal.rst:461
msgid ""
"Return a pair ``(n, d)`` of integers that represent the given :class:"
"`Decimal` instance as a fraction, in lowest terms and with a positive "
"denominator::"
msgstr ""
"Retorna un par de enteros ``(n, d)`` que representan la instancia de :class:"
"`Decimal` proporcionada como una fracción irreducible y con un denominador "
"positivo::"

#: ../Doc/library/decimal.rst:468
msgid ""
"The conversion is exact.  Raise OverflowError on infinities and ValueError "
"on NaNs."
msgstr ""
"La conversión es exacta. Lanza una excepción OverflowError si se "
"proporcionan valores infinitos y ValueError con valores NaN."

#: ../Doc/library/decimal.rst:475
msgid ""
"Return a :term:`named tuple` representation of the number: "
"``DecimalTuple(sign, digits, exponent)``."
msgstr ""
"Retorna una representación en forma de :term:`named tuple` del número: "
"``DecimalTuple(sign, digits, exponent)``."

#: ../Doc/library/decimal.rst:481
msgid ""
"Return the canonical encoding of the argument.  Currently, the encoding of "
"a :class:`Decimal` instance is always canonical, so this operation returns "
"its argument unchanged."
msgstr ""
"Retorna la codificación canónica del argumento. Actualmente, la codificación "
"de una instancia de :class:`Decimal` es siempre canónica, por lo que esta "
"operación retorna su argumento sin cambios."

#: ../Doc/library/decimal.rst:487
msgid ""
"Compare the values of two Decimal instances.  :meth:`compare` returns a "
"Decimal instance, and if either operand is a NaN then the result is a NaN::"
msgstr ""
"Compara los valores de dos instancias de Decimal. El método :meth:`compare` "
"retorna una instancia de Decimal, y si alguno de los operandos es un NaN, el "
"resultado es un NaN::"

#: ../Doc/library/decimal.rst:498
msgid ""
"This operation is identical to the :meth:`compare` method, except that all "
"NaNs signal.  That is, if neither operand is a signaling NaN then any quiet "
"NaN operand is treated as though it were a signaling NaN."
msgstr ""
"Esta operación es idéntica al método :meth:`compare`, excepto que todos los "
"valores NaN generan una señal. Es decir, si ninguno de los operandos es un "
"NaN señalizador, cualquier operando de NaN silencioso se trata como si fuera "
"un NaN señalizador."

#: ../Doc/library/decimal.rst:504
msgid ""
"Compare two operands using their abstract representation rather than their "
"numerical value.  Similar to the :meth:`compare` method, but the result "
"gives a total ordering on :class:`Decimal` instances.  Two :class:`Decimal` "
"instances with the same numeric value but different representations compare "
"unequal in this ordering:"
msgstr ""
"Compara dos operandos utilizando su representación abstracta en lugar de su "
"valor numérico. Similar al método :meth:`compare`, pero el resultado "
"proporciona un ordenamiento total en las instancias de :class:`Decimal`. Dos "
"instancias de :class:`Decimal` con el mismo valor numérico, pero diferentes "
"representaciones, se comparan como desiguales usando este orden:"

#: ../Doc/library/decimal.rst:513
msgid ""
"Quiet and signaling NaNs are also included in the total ordering.  The "
"result of this function is ``Decimal('0')`` if both operands have the same "
"representation, ``Decimal('-1')`` if the first operand is lower in the total "
"order than the second, and ``Decimal('1')`` if the first operand is higher "
"in the total order than the second operand.  See the specification for "
"details of the total order."
msgstr ""
"Los NaN silenciosos y señalizadores también se incluyen en el ordenamiento "
"total. El resultado de esta función es ``Decimal('0')`` si ambos operandos "
"tienen la misma representación, ``Decimal('-1')`` si el primer operando es "
"menor en el orden total que el segundo y ``Decimal('1')`` si el primer "
"operando es mayor en el orden total que el segundo operando. Consulta las "
"especificaciones para obtener detalles sobre el ordenamiento total."

#: ../Doc/library/decimal.rst:520 ../Doc/library/decimal.rst:531
#: ../Doc/library/decimal.rst:559 ../Doc/library/decimal.rst:834
msgid ""
"This operation is unaffected by context and is quiet: no flags are changed "
"and no rounding is performed.  As an exception, the C version may raise "
"InvalidOperation if the second operand cannot be converted exactly."
msgstr ""
"Esta operación no se ve afectada por el contexto y es silenciosa: no se "
"cambian los flags y no se realiza ningún redondeo. Como excepción, la "
"versión de C puede lanzar InvalidOperation si el segundo operando no se "
"puede convertir exactamente."

#: ../Doc/library/decimal.rst:526
msgid ""
"Compare two operands using their abstract representation rather than their "
"value as in :meth:`compare_total`, but ignoring the sign of each operand. "
"``x.compare_total_mag(y)`` is equivalent to ``x.copy_abs().compare_total(y."
"copy_abs())``."
msgstr ""
"Compara dos operandos usando su representación abstracta en lugar de su "
"valor, como en :meth:`compare_total`, pero ignorando el signo de cada "
"operando. ``x.compare_total_mag(y)`` es equivalente a ``x.copy_abs()."
"compare_total(y.copy_abs())``."

#: ../Doc/library/decimal.rst:537
msgid ""
"Just returns self, this method is only to comply with the Decimal "
"Specification."
msgstr ""
"Simplemente retorna self (el propio objeto al que pertenece el método "
"invocado). Este método existe solo para cumplir con la Especificación "
"decimal."

#: ../Doc/library/decimal.rst:542
msgid ""
"Return the absolute value of the argument.  This operation is unaffected by "
"the context and is quiet: no flags are changed and no rounding is performed."
msgstr ""
"Retorna el valor absoluto del argumento. Esta operación no se ve afectada "
"por el contexto y es silenciosa: no se modifican los flags y no se realiza "
"ningún redondeo."

#: ../Doc/library/decimal.rst:548
msgid ""
"Return the negation of the argument.  This operation is unaffected by the "
"context and is quiet: no flags are changed and no rounding is performed."
msgstr ""
"Retorna la negación del argumento. Esta operación no se ve afectada por el "
"contexto y es silenciosa: no se cambian los flags y no se realiza ningún "
"redondeo."

#: ../Doc/library/decimal.rst:553
msgid ""
"Return a copy of the first operand with the sign set to be the same as the "
"sign of the second operand.  For example:"
msgstr ""
"Retorna una copia del primer operando pero con el signo establecido para que "
"sea el mismo que el del segundo operando. Por ejemplo:"

#: ../Doc/library/decimal.rst:565
msgid ""
"Return the value of the (natural) exponential function ``e**x`` at the given "
"number.  The result is correctly rounded using the :const:`ROUND_HALF_EVEN` "
"rounding mode."
msgstr ""
"Retorna el valor de la función exponencial (natural) ``e**x`` en el número "
"dado. El resultado es correctamente redondeado utilizando el modo de "
"redondeo :const:`ROUND_HALF_EVEN`."

#: ../Doc/library/decimal.rst:576
msgid "Classmethod that converts a float to a decimal number, exactly."
msgstr ""
"Método de clase que convierte un flotante en un número decimal, de forma "
"exacta."

#: ../Doc/library/decimal.rst:578
msgid ""
"Note `Decimal.from_float(0.1)` is not the same as `Decimal('0.1')`. Since "
"0.1 is not exactly representable in binary floating point, the value is "
"stored as the nearest representable value which is `0x1.999999999999ap-4`.  "
"That equivalent value in decimal is "
"`0.1000000000000000055511151231257827021181583404541015625`."
msgstr ""
"Nota que `Decimal.from_float (0.1)` no es lo mismo que `Decimal('0.1')`. "
"Dado que 0.1 no es exactamente representable en coma flotante binaria, el "
"valor se almacena como el valor representable más cercano, que es "
"`0x1.999999999999ap-4`. Ese valor equivalente en decimal es "
"`0.1000000000000000055511151231257827021181583404541015625`."

#: ../Doc/library/decimal.rst:584
msgid ""
"From Python 3.2 onwards, a :class:`Decimal` instance can also be constructed "
"directly from a :class:`float`."
msgstr ""
"Desde Python 3.2 en adelante, una instancia de :class:`Decimal` también se "
"puede construir directamente desde una instancia de :class:`float`."

#: ../Doc/library/decimal.rst:602
msgid ""
"Fused multiply-add.  Return self*other+third with no rounding of the "
"intermediate product self*other."
msgstr ""
"Fusión de la multiplicación y la suma. Retorna self*other+third sin redondeo "
"del producto intermedio self*other."

#: ../Doc/library/decimal.rst:610
msgid ""
"Return :const:`True` if the argument is canonical and :const:`False` "
"otherwise.  Currently, a :class:`Decimal` instance is always canonical, so "
"this operation always returns :const:`True`."
msgstr ""
"Retorna :const:`True` si el argumento es canónico y :const:`False` en caso "
"contrario. Actualmente, una instancia de :class:`Decimal` es siempre "
"canónica, por lo que esta operación siempre retorna :const:`True`."

#: ../Doc/library/decimal.rst:616
msgid ""
"Return :const:`True` if the argument is a finite number, and :const:`False` "
"if the argument is an infinity or a NaN."
msgstr ""
"Retorna :const:`True` si el argumento es un número finito y :const:`False` "
"si el argumento es un valor infinito o un NaN."

#: ../Doc/library/decimal.rst:621
msgid ""
"Return :const:`True` if the argument is either positive or negative infinity "
"and :const:`False` otherwise."
msgstr ""
"Retorna :const:`True` si el argumento es un valor infinito positivo o "
"negativo y :const:`False` en caso contrario."

#: ../Doc/library/decimal.rst:626
msgid ""
"Return :const:`True` if the argument is a (quiet or signaling) NaN and :"
"const:`False` otherwise."
msgstr ""
"Retorna :const:`True` si el argumento es un NaN (silencioso o señalizador) "
"y :const:`False` en caso contrario."

#: ../Doc/library/decimal.rst:631
msgid ""
"Return :const:`True` if the argument is a *normal* finite number.  Return :"
"const:`False` if the argument is zero, subnormal, infinite or a NaN."
msgstr ""
"Retorna :const:`True` si el argumento es un número finito *normal*. Retorna :"
"const:`False` si el argumento es cero, subnormal, infinito o un NaN."

#: ../Doc/library/decimal.rst:636
msgid ""
"Return :const:`True` if the argument is a quiet NaN, and :const:`False` "
"otherwise."
msgstr ""
"Retorna :const:`True` si el argumento es un NaN silencioso y :const:`False` "
"en caso contrario."

#: ../Doc/library/decimal.rst:641
msgid ""
"Return :const:`True` if the argument has a negative sign and :const:`False` "
"otherwise.  Note that zeros and NaNs can both carry signs."
msgstr ""
"Retorna :const:`True` si el argumento tiene signo negativo y :const:`False` "
"en caso contrario. Ten en cuenta que tanto los ceros como los NaN pueden "
"tener signo."

#: ../Doc/library/decimal.rst:646
msgid ""
"Return :const:`True` if the argument is a signaling NaN and :const:`False` "
"otherwise."
msgstr ""
"Retorna :const:`True` si el argumento es un NaN señalizador y :const:`False` "
"en caso contrario."

#: ../Doc/library/decimal.rst:651
msgid ""
"Return :const:`True` if the argument is subnormal, and :const:`False` "
"otherwise."
msgstr ""
"Retorna :const:`True` si el argumento es subnormal y :const:`False` en caso "
"contrario."

#: ../Doc/library/decimal.rst:656
msgid ""
"Return :const:`True` if the argument is a (positive or negative) zero and :"
"const:`False` otherwise."
msgstr ""
"Retorna :const:`True` si el argumento es un cero (positivo o negativo) y :"
"const:`False` en caso contrario."

#: ../Doc/library/decimal.rst:661
msgid ""
"Return the natural (base e) logarithm of the operand.  The result is "
"correctly rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""
"Retorna el logaritmo natural (base e) del operando. El resultado es "
"correctamente redondeado utilizando el modo de redondeo :const:"
"`ROUND_HALF_EVEN`."

#: ../Doc/library/decimal.rst:666
msgid ""
"Return the base ten logarithm of the operand.  The result is correctly "
"rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""
"Retorna el logaritmo en base diez del operando. El resultado es "
"correctamente redondeado utilizando el modo de redondeo :const:"
"`ROUND_HALF_EVEN`."

#: ../Doc/library/decimal.rst:671
msgid ""
"For a nonzero number, return the adjusted exponent of its operand as a :"
"class:`Decimal` instance.  If the operand is a zero then ``Decimal('-"
"Infinity')`` is returned and the :const:`DivisionByZero` flag is raised.  If "
"the operand is an infinity then ``Decimal('Infinity')`` is returned."
msgstr ""
"Para un número distinto de cero, retorna el exponente ajustado de su "
"operando como una instancia de :class:`Decimal`. Si el operando es cero, se "
"retorna ``Decimal('-Infinity')`` y se activa el flag :const:"
"`DivisionByZero`. Si el operando es infinito, se retorna "
"``Decimal('Infinity')``."

#: ../Doc/library/decimal.rst:679
msgid ""
":meth:`logical_and` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"``and`` of the two operands."
msgstr ""
":meth:`logic_and` es una operación lógica que toma dos *operandos lógicos* "
"(consultar :ref:`logical_operands_label`). El resultado es el ``and`` dígito "
"por dígito de los dos operandos."

#: ../Doc/library/decimal.rst:685
msgid ""
":meth:`logical_invert` is a logical operation.  The result is the digit-wise "
"inversion of the operand."
msgstr ""
":meth:`logic_invert` es una operación lógica. El resultado es la inversión "
"dígito a dígito del operando."

#: ../Doc/library/decimal.rst:690
msgid ""
":meth:`logical_or` is a logical operation which takes two *logical operands* "
"(see :ref:`logical_operands_label`).  The result is the digit-wise ``or`` of "
"the two operands."
msgstr ""
":meth:`logical_or` es una operación lógica que toma dos *operandos lógicos* "
"(consultar :ref:`logical_operands_label`). El resultado es un ``or`` dígito "
"a dígito de los dos operandos."

#: ../Doc/library/decimal.rst:696
msgid ""
":meth:`logical_xor` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"exclusive or of the two operands."
msgstr ""
":meth:`logic_xor` es una operación lógica que toma dos *operandos lógicos* "
"(consultar :ref:`logical_operands_label`). El resultado es la disyunción "
"exclusiva (\"exclusive or\") dígito a dígito de ambos operandos."

#: ../Doc/library/decimal.rst:702
msgid ""
"Like ``max(self, other)`` except that the context rounding rule is applied "
"before returning and that :const:`NaN` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"Como ``max(self, other)``, excepto que la regla de redondeo del contexto se "
"aplica antes de retornar y que los valores :const:`NaN` generan una señal o "
"son ignorados (dependiendo del contexto y de si son señalizadores o "
"silenciosos)."

#: ../Doc/library/decimal.rst:709
msgid ""
"Similar to the :meth:`.max` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ""
"Similar al método :meth:`.max`, pero la comparación se realiza utilizando "
"los valores absolutos de los operandos."

#: ../Doc/library/decimal.rst:714
msgid ""
"Like ``min(self, other)`` except that the context rounding rule is applied "
"before returning and that :const:`NaN` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"Como ``min(self, other)``, excepto que la regla de redondeo del contexto se "
"aplica antes de retornar y que los valores :const:`NaN` generan una señal o "
"se ignoran (según el contexto y si son señalizadores o no)."

#: ../Doc/library/decimal.rst:721
msgid ""
"Similar to the :meth:`.min` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ""
"Similar al método :meth:`.min`, pero la comparación se realiza utilizando "
"los valores absolutos de los operandos."

#: ../Doc/library/decimal.rst:726
msgid ""
"Return the largest number representable in the given context (or in the "
"current thread's context if no context is given) that is smaller than the "
"given operand."
msgstr ""
"Retorna el número más grande representable en el contexto proporcionado (o "
"en el contexto del hilo actual si no se proporciona un contexto) que sea más "
"pequeño que el operando proporcionado."

#: ../Doc/library/decimal.rst:732
msgid ""
"Return the smallest number representable in the given context (or in the "
"current thread's context if no context is given) that is larger than the "
"given operand."
msgstr ""
"Retorna el número más pequeño representable en el contexto proporcionado (o "
"en el contexto del hilo actual si no se proporciona ningún contexto) que sea "
"más grande que el operando proporcionado."

#: ../Doc/library/decimal.rst:738
msgid ""
"If the two operands are unequal, return the number closest to the first "
"operand in the direction of the second operand.  If both operands are "
"numerically equal, return a copy of the first operand with the sign set to "
"be the same as the sign of the second operand."
msgstr ""
"Si los dos operandos no son iguales, retorna el número más cercano al primer "
"operando en la dirección del segundo operando. Si ambos operandos son "
"numéricamente iguales, retorna una copia del primer operando con el signo "
"establecido para que sea el mismo que el signo del segundo operando."

#: ../Doc/library/decimal.rst:745
msgid ""
"Normalize the number by stripping the rightmost trailing zeros and "
"converting any result equal to :const:`Decimal('0')` to :const:"
"`Decimal('0e0')`. Used for producing canonical values for attributes of an "
"equivalence class. For example, ``Decimal('32.100')`` and "
"``Decimal('0.321000e+2')`` both normalize to the equivalent value "
"``Decimal('32.1')``."
msgstr ""
"Normaliza el número, eliminando los ceros finales situados más a la derecha "
"y convirtiendo cualquier resultado igual a :const:`Decimal('0')` en :const:"
"`Decimal('0e0')`. Se utiliza para producir valores canónicos para atributos "
"de una clase de equivalencia. Por ejemplo, ``Decimal('32 .100')`` y "
"``Decimal('0.321000e+2')`` se normalizan ambos al valor equivalente "
"``Decimal('32 .1')``."

#: ../Doc/library/decimal.rst:754
msgid ""
"Return a string describing the *class* of the operand.  The returned value "
"is one of the following ten strings."
msgstr ""
"Retorna una cadena de caracteres que describe la *clase* del operando. El "
"valor retornado es una de las siguientes diez cadenas de caracteres:"

#: ../Doc/library/decimal.rst:757
msgid "``\"-Infinity\"``, indicating that the operand is negative infinity."
msgstr "``\"-Infinity\"``, que indica que el operando es un infinito negativo."

#: ../Doc/library/decimal.rst:758
msgid ""
"``\"-Normal\"``, indicating that the operand is a negative normal number."
msgstr ""
"``\"-Normal\"``, que indica que el operando es un número normal negativo."

#: ../Doc/library/decimal.rst:759
msgid ""
"``\"-Subnormal\"``, indicating that the operand is negative and subnormal."
msgstr ""
"``\"-Subnormal\"``, que indica que el operando es negativo y subnormal."

#: ../Doc/library/decimal.rst:760
msgid "``\"-Zero\"``, indicating that the operand is a negative zero."
msgstr "``\"-Zero\"``, que indica que el operando es un cero negativo."

#: ../Doc/library/decimal.rst:761
msgid "``\"+Zero\"``, indicating that the operand is a positive zero."
msgstr "``\"+Zero\"``, que indica que el operando es un cero positivo."

#: ../Doc/library/decimal.rst:762
msgid ""
"``\"+Subnormal\"``, indicating that the operand is positive and subnormal."
msgstr "``\"+Subnormal\"``,que indica que el operando es positivo y subnormal."

#: ../Doc/library/decimal.rst:763
msgid ""
"``\"+Normal\"``, indicating that the operand is a positive normal number."
msgstr ""
"``\"+Normal\"``, que indica que el operando es un número normal positivo."

#: ../Doc/library/decimal.rst:764
msgid "``\"+Infinity\"``, indicating that the operand is positive infinity."
msgstr "``\"+Infinity\"``, que indica que el operando es un infinito positivo."

#: ../Doc/library/decimal.rst:765
msgid "``\"NaN\"``, indicating that the operand is a quiet NaN (Not a Number)."
msgstr ""
"``\"NaN\"``, que indica que el operando es un NaN (no es un número) "
"silencioso."

#: ../Doc/library/decimal.rst:766
msgid "``\"sNaN\"``, indicating that the operand is a signaling NaN."
msgstr ""
"``\"sNaN\"``, que indica que el operando es un NaN (no es un número) "
"señalizador."

#: ../Doc/library/decimal.rst:770
msgid ""
"Return a value equal to the first operand after rounding and having the "
"exponent of the second operand."
msgstr ""
"Retorna un valor igual al primer operando después de ser redondeado y de "
"asignarle el exponente del segundo operando."

#: ../Doc/library/decimal.rst:776
msgid ""
"Unlike other operations, if the length of the coefficient after the quantize "
"operation would be greater than precision, then an :const:`InvalidOperation` "
"is signaled. This guarantees that, unless there is an error condition, the "
"quantized exponent is always equal to that of the right-hand operand."
msgstr ""
"A diferencia de otras operaciones, se genera una señal :const:"
"`InvalidOperation` si la longitud del coeficiente después de la operación "
"quantize es mayor que la precisión. Esto garantiza que, a menos que exista "
"una condición de error, el exponente cuantificado sea siempre igual al del "
"operando de la derecha."

#: ../Doc/library/decimal.rst:782
msgid ""
"Also unlike other operations, quantize never signals Underflow, even if the "
"result is subnormal and inexact."
msgstr ""
"Además, a diferencia de otras operaciones, quantize nunca genera una señal "
"Underflow, incluso si el resultado es subnormal e inexacto."

#: ../Doc/library/decimal.rst:785
msgid ""
"If the exponent of the second operand is larger than that of the first then "
"rounding may be necessary.  In this case, the rounding mode is determined by "
"the ``rounding`` argument if given, else by the given ``context`` argument; "
"if neither argument is given the rounding mode of the current thread's "
"context is used."
msgstr ""
"Si el exponente del segundo operando es mayor que el del primero, puede ser "
"necesario redondear. En este caso, el modo de redondeo está determinado por "
"el argumento ``rounding``, si se proporciona, o por el argumento ``context`` "
"en caso contrario. Si no se proporciona ninguno de estos dos argumentos, se "
"utiliza el modo de redondeo establecido en el contexto del hilo actual."

#: ../Doc/library/decimal.rst:791
msgid ""
"An error is returned whenever the resulting exponent is greater than :attr:"
"`Emax` or less than :attr:`Etiny`."
msgstr ""
"Se retorna un error siempre que el exponente resultante sea mayor que :attr:"
"`Emax` o menor que :attr:`Etiny`."

#: ../Doc/library/decimal.rst:796
msgid ""
"Return ``Decimal(10)``, the radix (base) in which the :class:`Decimal` class "
"does all its arithmetic.  Included for compatibility with the specification."
msgstr ""
"Retorna ``Decimal(10)``, que es la raíz (base) en la que la clase :class:"
"`Decimal` hace toda su aritmética. Este método está incluido solo por "
"compatibilidad con la especificación."

#: ../Doc/library/decimal.rst:802
#, python-format
msgid ""
"Return the remainder from dividing *self* by *other*.  This differs from "
"``self % other`` in that the sign of the remainder is chosen so as to "
"minimize its absolute value.  More precisely, the return value is ``self - n "
"* other`` where ``n`` is the integer nearest to the exact value of ``self / "
"other``, and if two integers are equally near then the even one is chosen."
msgstr ""
"Retorna el resto de dividir *self* entre *other*. Esto difiere de la "
"operación ``self%other``, en la que el signo del resto se elige para "
"minimizar su valor absoluto. Más precisamente, el valor de retorno es ``self "
"- n * other``, donde ``n`` es el número entero más cercano al valor exacto "
"de ``self / other``. Si dos enteros están igualmente cerca, entonces el "
"valor par es el elegido."

#: ../Doc/library/decimal.rst:809
msgid "If the result is zero then its sign will be the sign of *self*."
msgstr "Si el resultado es cero, entonces su signo será el signo de *self*."

#: ../Doc/library/decimal.rst:820
msgid ""
"Return the result of rotating the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to rotate.  If the second operand is "
"positive then rotation is to the left; otherwise rotation is to the right. "
"The coefficient of the first operand is padded on the left with zeros to "
"length precision if necessary.  The sign and exponent of the first operand "
"are unchanged."
msgstr ""
"Retorna el resultado de rotar los dígitos del primer operando en una "
"cantidad especificada por el segundo operando. El segundo operando debe ser "
"un número entero en el rango comprendido desde -precisión hasta precisión. "
"El valor absoluto del segundo operando da el número de lugares a rotar. Si "
"el segundo operando es positivo, la rotación es hacia la izquierda; de lo "
"contrario, la rotación es hacia la derecha. El coeficiente del primer "
"operando se rellena con ceros a la izquierda para satisfacer la precisión de "
"longitud si es necesario. El signo y el exponente del primer operando no se "
"modifican."

#: ../Doc/library/decimal.rst:831
msgid ""
"Test whether self and other have the same exponent or whether both are :"
"const:`NaN`."
msgstr ""
"Comprueba si self y other tienen el mismo exponente o si ambos son :const:"
"`NaN`."

#: ../Doc/library/decimal.rst:840
msgid ""
"Return the first operand with exponent adjusted by the second. Equivalently, "
"return the first operand multiplied by ``10**other``.  The second operand "
"must be an integer."
msgstr ""
"Retorna el primer operando con su exponente ajustado por el segundo. De "
"manera equivalente, retorna el primer operando multiplicado por "
"``10**other``. El segundo operando debe ser un número entero."

#: ../Doc/library/decimal.rst:846
msgid ""
"Return the result of shifting the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to shift.  If the second operand is "
"positive then the shift is to the left; otherwise the shift is to the "
"right.  Digits shifted into the coefficient are zeros.  The sign and "
"exponent of the first operand are unchanged."
msgstr ""
"Retorna el resultado de cambiar los dígitos del primer operando en una "
"cantidad especificada por el segundo operando. El segundo operando debe ser "
"un número entero en el rango comprendido desde -precisión hasta precisión. "
"El valor absoluto del segundo operando da el número de lugares a desplazar. "
"Si el segundo operando es positivo, el desplazamiento es hacia la izquierda; "
"de lo contrario, el desplazamiento es hacia la derecha. Los dígitos "
"desplazados en el coeficiente son ceros. El signo y el exponente del primer "
"operando no se modifican."

#: ../Doc/library/decimal.rst:856
msgid "Return the square root of the argument to full precision."
msgstr "Retorna la raíz cuadrada del argumento con precisión total."

#: ../Doc/library/decimal.rst:861 ../Doc/library/decimal.rst:1440
msgid ""
"Convert to a string, using engineering notation if an exponent is needed."
msgstr ""
"Convierte a una cadena de caracteres, usando notación de ingeniería si se "
"necesita un exponente."

#: ../Doc/library/decimal.rst:863 ../Doc/library/decimal.rst:1442
msgid ""
"Engineering notation has an exponent which is a multiple of 3.  This can "
"leave up to 3 digits to the left of the decimal place and may require the "
"addition of either one or two trailing zeros."
msgstr ""
"La notación de ingeniería tiene como exponente un múltiplo de 3. Esto puede "
"dejar hasta 3 dígitos a la izquierda del punto decimal y puede requerir la "
"adición de uno o dos ceros finales."

#: ../Doc/library/decimal.rst:867
msgid ""
"For example, this converts ``Decimal('123E+1')`` to ``Decimal('1.23E+3')``."
msgstr ""
"Por ejemplo, este método convierte ``Decimal('123E+1')`` en ``Decimal('1.23E"
"+3')``."

#: ../Doc/library/decimal.rst:871
msgid ""
"Identical to the :meth:`to_integral_value` method.  The ``to_integral`` name "
"has been kept for compatibility with older versions."
msgstr ""
"Idéntico al método :meth:`to_integral_value`. El nombre ``to_integral`` se "
"ha mantenido por compatibilidad con versiones anteriores."

#: ../Doc/library/decimal.rst:876
msgid ""
"Round to the nearest integer, signaling :const:`Inexact` or :const:`Rounded` "
"as appropriate if rounding occurs.  The rounding mode is determined by the "
"``rounding`` parameter if given, else by the given ``context``.  If neither "
"parameter is given then the rounding mode of the current context is used."
msgstr ""
"Redondea al entero más cercano, generando la señal :const:`Inexact` o :const:"
"`Rounded`, según corresponda, si se produce un redondeo. El modo de redondeo "
"está determinado por el parámetro ``rounding`` si es proporcionado, o por el "
"establecido en el ``context`` proporcionado en caso contrario. Si no se "
"proporciona ninguno de estos dos parámetros, se utiliza el modo de redondeo "
"establecido en el contexto actual."

#: ../Doc/library/decimal.rst:884
msgid ""
"Round to the nearest integer without signaling :const:`Inexact` or :const:"
"`Rounded`.  If given, applies *rounding*; otherwise, uses the rounding "
"method in either the supplied *context* or the current context."
msgstr ""
"Redondea al entero más cercano sin generar la señal :const:`Inexact` o :"
"const:`Rounded`. Si se proporciona, se aplica el método de redondeo "
"especificado por *rounding*; en caso contrario, se utiliza el método de "
"redondeo del *context* proporcionado o el del contexto actual."

#: ../Doc/library/decimal.rst:892
msgid "Logical operands"
msgstr "Operandos lógicos"

#: ../Doc/library/decimal.rst:894
msgid ""
"The :meth:`logical_and`, :meth:`logical_invert`, :meth:`logical_or`, and :"
"meth:`logical_xor` methods expect their arguments to be *logical operands*.  "
"A *logical operand* is a :class:`Decimal` instance whose exponent and sign "
"are both zero, and whose digits are all either :const:`0` or :const:`1`."
msgstr ""
"Los métodos :meth:`logical_and`, :meth:`logical_invert`, :meth:`logical_or` "
"y :meth:`logical_xor` esperan que sus argumentos sean *operandos lógicos*. "
"Un *operando lógico* es una instancia de :class:`Decimal` cuyo exponente y "
"signo son ambos cero, y cuyos dígitos son todos :const:`0` o :const:`1`."

#: ../Doc/library/decimal.rst:906
msgid "Context objects"
msgstr "Objetos Context"

#: ../Doc/library/decimal.rst:908
msgid ""
"Contexts are environments for arithmetic operations.  They govern precision, "
"set rules for rounding, determine which signals are treated as exceptions, "
"and limit the range for exponents."
msgstr ""
"Los contextos son entornos para operaciones aritméticas. Gobiernan la "
"precisión, establecen reglas para el redondeo, determinan qué señales se "
"tratan como excepciones y limitan el rango para los exponentes."

#: ../Doc/library/decimal.rst:912
msgid ""
"Each thread has its own current context which is accessed or changed using "
"the :func:`getcontext` and :func:`setcontext` functions:"
msgstr ""
"Cada hilo tiene su propio contexto actual, al que se accede o se reemplaza "
"usando las funciones :func:`getcontext` y :func:`setcontext` respectivamente:"

#: ../Doc/library/decimal.rst:918
msgid "Return the current context for the active thread."
msgstr "Retorna el contexto actual del hilo activo."

#: ../Doc/library/decimal.rst:923
msgid "Set the current context for the active thread to *c*."
msgstr "Establece *c* como contexto actual para el hilo activo."

#: ../Doc/library/decimal.rst:925
msgid ""
"You can also use the :keyword:`with` statement and the :func:`localcontext` "
"function to temporarily change the active context."
msgstr ""
"También puedes usar la declaración :keyword:`with` y la función :func:"
"`localcontext` para cambiar temporalmente el contexto activo."

#: ../Doc/library/decimal.rst:930
msgid ""
"Return a context manager that will set the current context for the active "
"thread to a copy of *ctx* on entry to the with-statement and restore the "
"previous context when exiting the with-statement. If no context is "
"specified, a copy of the current context is used."
msgstr ""
"Retorna un gestor de contexto que establecerá el contexto actual para el "
"hilo activo en una copia de *ctx* al ingresar en la declaración with y "
"restaurará el contexto anterior al salir de la misma. Si no se especifica "
"ningún contexto, se utiliza una copia del contexto actual."

#: ../Doc/library/decimal.rst:935
msgid ""
"For example, the following code sets the current decimal precision to 42 "
"places, performs a calculation, and then automatically restores the previous "
"context::"
msgstr ""
"Por ejemplo, el siguiente código establece la precisión decimal actual en 42 "
"lugares, realiza un cálculo y luego restaura automáticamente el contexto "
"anterior::"

#: ../Doc/library/decimal.rst:945
msgid ""
"New contexts can also be created using the :class:`Context` constructor "
"described below. In addition, the module provides three pre-made contexts:"
msgstr ""
"También se pueden crear nuevos contextos utilizando el constructor de la "
"clase :class:`Context` que se describe a continuación. Además, el módulo "
"proporciona tres contextos prediseñados:"

#: ../Doc/library/decimal.rst:951
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_UP`.  All flags are cleared.  All traps are enabled (treated as "
"exceptions) except :const:`Inexact`, :const:`Rounded`, and :const:"
"`Subnormal`."
msgstr ""
"Este es un contexto estándar definido por la Especificación general de la "
"aritmética decimal. La precisión se establece en nueve. El redondeo se "
"establece en :const:`ROUND_HALF_UP`. Se restablecen todos los flags. Todas "
"las trampas están habilitadas (las señales son tratadas como excepciones) "
"excepto :const:`Inexact`, :const:`Rounded` y :const:`Subnormal`."

#: ../Doc/library/decimal.rst:957
msgid ""
"Because many of the traps are enabled, this context is useful for debugging."
msgstr ""
"Debido a que la mayoría de las trampas están habilitadas, este contexto es "
"especialmente útil para la depuración."

#: ../Doc/library/decimal.rst:962
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_EVEN`.  All flags are cleared.  No traps are enabled (so that "
"exceptions are not raised during computations)."
msgstr ""
"Este es un contexto estándar definido por la Especificación general de la "
"aritmética decimal. La precisión se establece en nueve. El redondeo se "
"establece en :const:`ROUND_HALF_EVEN`. Se restablecen todos los flags. No se "
"habilitan trampas (para que no se generen excepciones durante los cálculos)."

#: ../Doc/library/decimal.rst:967
msgid ""
"Because the traps are disabled, this context is useful for applications that "
"prefer to have result value of :const:`NaN` or :const:`Infinity` instead of "
"raising exceptions.  This allows an application to complete a run in the "
"presence of conditions that would otherwise halt the program."
msgstr ""
"Debido a que las trampas están deshabilitadas, este contexto es útil para "
"aplicaciones que prefieren tener un valor :const:`NaN` o :const:`Infinity` "
"como resultado en lugar de lanzar excepciones. Esto permite que una "
"aplicación complete una ejecución en presencia de condiciones que, de otra "
"manera, detendrían el programa."

#: ../Doc/library/decimal.rst:975
msgid ""
"This context is used by the :class:`Context` constructor as a prototype for "
"new contexts.  Changing a field (such a precision) has the effect of "
"changing the default for new contexts created by the :class:`Context` "
"constructor."
msgstr ""
"Este contexto es utilizado por el constructor de la clase :class:`Context` "
"como un prototipo para nuevos contextos. Cambiar un campo (como la "
"precisión) tiene el efecto de cambiar el valor predeterminado para los "
"nuevos contextos creados por el constructor de :class:`Context`."

#: ../Doc/library/decimal.rst:979
msgid ""
"This context is most useful in multi-threaded environments.  Changing one of "
"the fields before threads are started has the effect of setting system-wide "
"defaults.  Changing the fields after threads have started is not recommended "
"as it would require thread synchronization to prevent race conditions."
msgstr ""
"Este contexto es más útil en entornos con múltiples hilos. Cambiar uno de "
"los campos antes de que se inicien los hilos tiene el efecto de establecer "
"valores predeterminados en todo el sistema. No se recomienda cambiar los "
"campos después de que se hayan iniciado los hilos, ya que requeriría el uso "
"de mecanismos de sincronización para evitar condiciones de carrera entre los "
"hilos."

#: ../Doc/library/decimal.rst:984
msgid ""
"In single threaded environments, it is preferable to not use this context at "
"all.  Instead, simply create contexts explicitly as described below."
msgstr ""
"En entornos de un solo hilo, es preferible no utilizar este contexto en "
"absoluto. En su lugar, simplemente crea contextos explícitamente como se "
"describe a continuación."

#: ../Doc/library/decimal.rst:987
msgid ""
"The default values are :attr:`prec`\\ =\\ :const:`28`, :attr:`rounding`\\ ="
"\\ :const:`ROUND_HALF_EVEN`, and enabled traps for :class:`Overflow`, :class:"
"`InvalidOperation`, and :class:`DivisionByZero`."
msgstr ""
"Los valores predeterminados son :attr:`prec`\\ =\\ :const:`28`, :attr:"
"`rounding`\\ =\\ :const:`ROUND_HALF_EVEN` y trampas habilitadas para :class:"
"`Overflow`, :class:`InvalidOperation` y :class:`DivisionByZero`."

#: ../Doc/library/decimal.rst:992
msgid ""
"In addition to the three supplied contexts, new contexts can be created with "
"the :class:`Context` constructor."
msgstr ""
"Además de los tres contextos proporcionados, se pueden crear nuevos "
"contextos mediante el constructor de la clase :class:`Context`."

#: ../Doc/library/decimal.rst:998
msgid ""
"Creates a new context.  If a field is not specified or is :const:`None`, the "
"default values are copied from the :const:`DefaultContext`.  If the *flags* "
"field is not specified or is :const:`None`, all flags are cleared."
msgstr ""
"Crea un nuevo contexto. Si no se especifica un campo, o es :const:`None`, "
"los valores predeterminados se copian de :const:`DefaultContext`. Si el "
"campo *flags* no está especificado, o es :const:`None`, se restablecen todas "
"los flags."

#: ../Doc/library/decimal.rst:1002
msgid ""
"*prec* is an integer in the range [:const:`1`, :const:`MAX_PREC`] that sets "
"the precision for arithmetic operations in the context."
msgstr ""
"*prec* es un número entero en el rango [:const:`1`, :const:`MAX_PREC`] que "
"establece la precisión para las operaciones aritméticas en el contexto."

#: ../Doc/library/decimal.rst:1005
msgid ""
"The *rounding* option is one of the constants listed in the section "
"`Rounding Modes`_."
msgstr ""
"La opción *rounding* es una de las constantes enumeradas en la sección "
"`Rounding Modes`_."

#: ../Doc/library/decimal.rst:1008
msgid ""
"The *traps* and *flags* fields list any signals to be set. Generally, new "
"contexts should only set traps and leave the flags clear."
msgstr ""
"Los campos *traps* y *flags* enumeran las señales que se deben establecer. "
"Generalmente, los nuevos contextos solo deben establecer trampas y dejar los "
"flags sin establecer."

#: ../Doc/library/decimal.rst:1011
msgid ""
"The *Emin* and *Emax* fields are integers specifying the outer limits "
"allowable for exponents. *Emin* must be in the range [:const:`MIN_EMIN`, :"
"const:`0`], *Emax* in the range [:const:`0`, :const:`MAX_EMAX`]."
msgstr ""
"Los campos *Emin* y *Emax* son números enteros que especifican los límites "
"externos permitidos para los exponentes. *Emin* debe estar en el rango [:"
"const:`MIN_EMIN`, :const:`0`] y *Emax* en el rango [:const:`0`, :const:"
"`MAX_EMAX`]."

#: ../Doc/library/decimal.rst:1015
msgid ""
"The *capitals* field is either :const:`0` or :const:`1` (the default). If "
"set to :const:`1`, exponents are printed with a capital :const:`E`; "
"otherwise, a lowercase :const:`e` is used: :const:`Decimal('6.02e+23')`."
msgstr ""
"El campo *capitals* es :const:`0` o :const:`1` (por defecto). Si se "
"establece en :const:`1`, los exponentes se imprimen usando una :const:`E` "
"mayúscula; de lo contrario, se usa una :const:`e` minúscula: :const:"
"`Decimal('6.02e+23')`."

#: ../Doc/library/decimal.rst:1019
msgid ""
"The *clamp* field is either :const:`0` (the default) or :const:`1`. If set "
"to :const:`1`, the exponent ``e`` of a :class:`Decimal` instance "
"representable in this context is strictly limited to the range ``Emin - prec "
"+ 1 <= e <= Emax - prec + 1``.  If *clamp* is :const:`0` then a weaker "
"condition holds: the adjusted exponent of the :class:`Decimal` instance is "
"at most ``Emax``.  When *clamp* is :const:`1`, a large normal number will, "
"where possible, have its exponent reduced and a corresponding number of "
"zeros added to its coefficient, in order to fit the exponent constraints; "
"this preserves the value of the number but loses information about "
"significant trailing zeros.  For example::"
msgstr ""
"El campo *clamp* es :const:`0` (por defecto) o :const:`1`. Si se establece "
"en :const:`1`, el exponente ``e`` representable en este contexto de una "
"instancia de :class:`Decimal` está estrictamente limitado al rango ``Emin - "
"prec + 1 <= e <= Emax - prec + 1``. Si *clamp* es :const:`0`, entonces se "
"cumple una condición más laxa: el exponente ajustado de la instancia de :"
"class:`Decimal` es como máximo ``Emax``. Cuando *clamp* es :const:`1`, "
"cuando sea posible, se reducirá el exponente de un número normal grande y se "
"agregarán el número correspondiente de ceros a su coeficiente, a fin de que "
"se ajuste a las restricciones del exponente; esto conserva el valor del "
"número pero conlleva una pérdida de información causada por los ceros "
"finales significativos. Por ejemplo::"

#: ../Doc/library/decimal.rst:1034
msgid ""
"A *clamp* value of :const:`1` allows compatibility with the fixed-width "
"decimal interchange formats specified in IEEE 754."
msgstr ""
"Un valor *clamp* de :const:`1` permite la compatibilidad con los formatos de "
"intercambio decimal de ancho fijo especificados en IEEE 754."

#: ../Doc/library/decimal.rst:1037
msgid ""
"The :class:`Context` class defines several general purpose methods as well "
"as a large number of methods for doing arithmetic directly in a given "
"context. In addition, for each of the :class:`Decimal` methods described "
"above (with the exception of the :meth:`adjusted` and :meth:`as_tuple` "
"methods) there is a corresponding :class:`Context` method.  For example, for "
"a :class:`Context` instance ``C`` and :class:`Decimal` instance ``x``, ``C."
"exp(x)`` is equivalent to ``x.exp(context=C)``.  Each :class:`Context` "
"method accepts a Python integer (an instance of :class:`int`) anywhere that "
"a Decimal instance is accepted."
msgstr ""
"La clase :class:`Context` define varios métodos de propósito general, así "
"como una gran cantidad de métodos para hacer aritmética directamente en un "
"contexto dado. Además, para cada uno de los métodos de la clase :class:"
"`Decimal` descritos anteriormente (con la excepción de los métodos :meth:"
"`adjusted` y :meth:`as_tuple`) hay un método correspondiente en la clase :"
"class:`Context`. Por ejemplo, para una instancia de :class:`Context` ``C`` y "
"una instancia de :class:`Decimal` ``x``, ``C.exp(x)`` es equivalente a ``x."
"exp(context=C)``. Cada método :class:`Context` acepta también un entero de "
"Python (una instancia de :class:`int`) en cualquier lugar donde se acepte "
"una instancia de Decimal."

#: ../Doc/library/decimal.rst:1050
msgid "Resets all of the flags to :const:`0`."
msgstr "Restablece todos los flags a :const:`0`."

#: ../Doc/library/decimal.rst:1054
msgid "Resets all of the traps to :const:`0`."
msgstr "Restablece todas las trampas a :const:`0`."

#: ../Doc/library/decimal.rst:1060
msgid "Return a duplicate of the context."
msgstr "Retorna un duplicado del contexto."

#: ../Doc/library/decimal.rst:1064
msgid "Return a copy of the Decimal instance num."
msgstr "Retorna una copia de la instancia de Decimal num."

#: ../Doc/library/decimal.rst:1068
msgid ""
"Creates a new Decimal instance from *num* but using *self* as context. "
"Unlike the :class:`Decimal` constructor, the context precision, rounding "
"method, flags, and traps are applied to the conversion."
msgstr ""
"Crea una nueva instancia de Decimal a partir de *num* pero usando *self* "
"como contexto. A diferencia del constructor de :class:`Decimal`, la "
"precisión del contexto, el método de redondeo, los flags y las trampas se "
"aplican a la conversión."

#: ../Doc/library/decimal.rst:1072
msgid ""
"This is useful because constants are often given to a greater precision than "
"is needed by the application.  Another benefit is that rounding immediately "
"eliminates unintended effects from digits beyond the current precision. In "
"the following example, using unrounded inputs means that adding zero to a "
"sum can change the result:"
msgstr ""
"Esto es útil porque las constantes a menudo se proporcionan con una "
"precisión mayor que la que necesita la aplicación. Otro beneficio es que el "
"redondeo elimina inmediatamente los efectos no deseados de los dígitos más "
"allá de la precisión actual. En el siguiente ejemplo, usar entradas no "
"redondeadas significa que agregar cero a una suma puede cambiar el resultado:"

#: ../Doc/library/decimal.rst:1086
msgid ""
"This method implements the to-number operation of the IBM specification. If "
"the argument is a string, no leading or trailing whitespace or underscores "
"are permitted."
msgstr ""
"Este método implementa la operación to-number de la especificación de IBM. "
"Si el argumento es una cadena de caracteres, no se permiten espacios en "
"blanco ni guiones bajos, ni al principio ni al final."

#: ../Doc/library/decimal.rst:1092
msgid ""
"Creates a new Decimal instance from a float *f* but rounding using *self* as "
"the context.  Unlike the :meth:`Decimal.from_float` class method, the "
"context precision, rounding method, flags, and traps are applied to the "
"conversion."
msgstr ""
"Crea una nueva instancia de Decimal a partir de un flotante *f*, pero "
"redondeando usando *self* como contexto. A diferencia del método de clase :"
"meth:`Decimal.from_float`, la precisión del contexto, el método de redondeo, "
"los flags y las trampas se aplican a la conversión."

#: ../Doc/library/decimal.rst:1112
msgid ""
"Returns a value equal to ``Emin - prec + 1`` which is the minimum exponent "
"value for subnormal results.  When underflow occurs, the exponent is set to :"
"const:`Etiny`."
msgstr ""
"Retorna un valor igual a ``Emin - prec + 1`` que es el valor mínimo del "
"exponente para resultados subnormales. Cuando ocurre un desbordamiento "
"numérico negativo (\"underflow\"), el exponente se establece en :const:"
"`Etiny`."

#: ../Doc/library/decimal.rst:1118
msgid "Returns a value equal to ``Emax - prec + 1``."
msgstr "Retorna un valor igual a ``Emax - prec + 1``."

#: ../Doc/library/decimal.rst:1120
msgid ""
"The usual approach to working with decimals is to create :class:`Decimal` "
"instances and then apply arithmetic operations which take place within the "
"current context for the active thread.  An alternative approach is to use "
"context methods for calculating within a specific context.  The methods are "
"similar to those for the :class:`Decimal` class and are only briefly "
"recounted here."
msgstr ""
"El enfoque habitual para trabajar con decimales es crear instancias de la "
"clase :class:`Decimal` y luego aplicar operaciones aritméticas que tienen "
"lugar dentro del contexto actual para el hilo activo. Un enfoque alternativo "
"es utilizar métodos de contexto para calcular dentro de un contexto "
"específico. Los métodos son similares a los de la clase :class:`Decimal` y "
"aquí solo se relatan brevemente."

#: ../Doc/library/decimal.rst:1130
msgid "Returns the absolute value of *x*."
msgstr "Retorna el valor absoluto de *x*."

#: ../Doc/library/decimal.rst:1135
msgid "Return the sum of *x* and *y*."
msgstr "Retorna la suma de *x* e *y*."

#: ../Doc/library/decimal.rst:1140
msgid "Returns the same Decimal object *x*."
msgstr "Retorna el mismo objeto Decimal *x*."

#: ../Doc/library/decimal.rst:1145
msgid "Compares *x* and *y* numerically."
msgstr "Compara *x* e *y* numéricamente."

#: ../Doc/library/decimal.rst:1150
msgid "Compares the values of the two operands numerically."
msgstr "Compara los valores de los dos operandos numéricamente."

#: ../Doc/library/decimal.rst:1155
msgid "Compares two operands using their abstract representation."
msgstr "Compara los dos operandos utilizando su representación abstracta."

#: ../Doc/library/decimal.rst:1160
msgid ""
"Compares two operands using their abstract representation, ignoring sign."
msgstr ""
"Compara los dos operandos utilizando su representación abstracta, ignorando "
"el signo."

#: ../Doc/library/decimal.rst:1165
msgid "Returns a copy of *x* with the sign set to 0."
msgstr "Retorna una copia de *x* con el signo establecido en 0."

#: ../Doc/library/decimal.rst:1170
msgid "Returns a copy of *x* with the sign inverted."
msgstr "Retorna una copia de *x* con el signo invertido."

#: ../Doc/library/decimal.rst:1175
msgid "Copies the sign from *y* to *x*."
msgstr "Copia el signo de *y* en *x*."

#: ../Doc/library/decimal.rst:1180
msgid "Return *x* divided by *y*."
msgstr "Retorna *x* dividido entre *y*."

#: ../Doc/library/decimal.rst:1185
msgid "Return *x* divided by *y*, truncated to an integer."
msgstr ""
"Retorna *x* dividido entre *y*, truncando el resultado a un número entero."

#: ../Doc/library/decimal.rst:1190
msgid "Divides two numbers and returns the integer part of the result."
msgstr "Divide dos números y retorna la parte entera del resultado."

#: ../Doc/library/decimal.rst:1195
msgid "Returns `e ** x`."
msgstr "Retorna `e ** x`."

#: ../Doc/library/decimal.rst:1200
msgid "Returns *x* multiplied by *y*, plus *z*."
msgstr "Retorna *x* multiplicado por *y*, más *z*."

#: ../Doc/library/decimal.rst:1205
msgid "Returns ``True`` if *x* is canonical; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` si *x* está en forma canónica, en caso contrario retorna "
"``False``."

#: ../Doc/library/decimal.rst:1210
msgid "Returns ``True`` if *x* is finite; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` si *x* es un valor finito, en caso contrario retorna "
"``False``."

#: ../Doc/library/decimal.rst:1215
msgid "Returns ``True`` if *x* is infinite; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` si *x* es un valor infinito, en caso contrario retorna "
"``False``."

#: ../Doc/library/decimal.rst:1220
msgid "Returns ``True`` if *x* is a qNaN or sNaN; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` si *x* es un valor qNaN o sNaN , en caso contrario retorna "
"``False``."

#: ../Doc/library/decimal.rst:1225
msgid ""
"Returns ``True`` if *x* is a normal number; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` si *x* es un número normal, en caso contrario retorna "
"``False``."

#: ../Doc/library/decimal.rst:1230
msgid "Returns ``True`` if *x* is a quiet NaN; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` si *x* es un NaN silencioso, en caso contrario retorna "
"``False``."

#: ../Doc/library/decimal.rst:1235
msgid "Returns ``True`` if *x* is negative; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` si *x* es un valor negativo, en caso contrario retorna "
"``False``."

#: ../Doc/library/decimal.rst:1240
msgid ""
"Returns ``True`` if *x* is a signaling NaN; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` si *x* es un NaN señalizador, en caso contrario retorna "
"``False``."

#: ../Doc/library/decimal.rst:1245
msgid "Returns ``True`` if *x* is subnormal; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` si *x* es un número subnormal, en caso contrario retorna "
"``False``."

#: ../Doc/library/decimal.rst:1250
msgid "Returns ``True`` if *x* is a zero; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` si *x* es un cero, en caso contrario retorna ``False``."

#: ../Doc/library/decimal.rst:1255
msgid "Returns the natural (base e) logarithm of *x*."
msgstr "Retorna el logaritmo natural (base e) de *x*."

#: ../Doc/library/decimal.rst:1260
msgid "Returns the base 10 logarithm of *x*."
msgstr "Retorna el logaritmo en base 10 de *x*."

#: ../Doc/library/decimal.rst:1265
msgid "Returns the exponent of the magnitude of the operand's MSD."
msgstr ""
"Retorna el exponente de la magnitud del MSD (\"dígito más significativo\") "
"del operando."

#: ../Doc/library/decimal.rst:1270
msgid "Applies the logical operation *and* between each operand's digits."
msgstr "Aplica la operación lógica *and* entre los dígitos de cada operando."

#: ../Doc/library/decimal.rst:1275
msgid "Invert all the digits in *x*."
msgstr "Invierte todos los dígitos en *x*."

#: ../Doc/library/decimal.rst:1280
msgid "Applies the logical operation *or* between each operand's digits."
msgstr "Aplica la operación lógica *or* entre los dígitos de cada operando."

#: ../Doc/library/decimal.rst:1285
msgid "Applies the logical operation *xor* between each operand's digits."
msgstr "Aplica la operación lógica *xor* entre los dígitos de cada operando."

#: ../Doc/library/decimal.rst:1290
msgid "Compares two values numerically and returns the maximum."
msgstr "Compara dos valores numéricamente y retorna el mayor de ellos."

#: ../Doc/library/decimal.rst:1295 ../Doc/library/decimal.rst:1305
msgid "Compares the values numerically with their sign ignored."
msgstr "Compara los valores numéricamente ignorando sus signos."

#: ../Doc/library/decimal.rst:1300
msgid "Compares two values numerically and returns the minimum."
msgstr "Compara dos valores numéricamente y retorna el menor de ellos."

#: ../Doc/library/decimal.rst:1310
msgid "Minus corresponds to the unary prefix minus operator in Python."
msgstr "Se corresponde con el operador unario de resta (prefijo) de Python."

#: ../Doc/library/decimal.rst:1315
msgid "Return the product of *x* and *y*."
msgstr "Retorna el producto de *x* por *y*."

#: ../Doc/library/decimal.rst:1320
msgid "Returns the largest representable number smaller than *x*."
msgstr "Retorna el número más grande representable menor que *x*."

#: ../Doc/library/decimal.rst:1325
msgid "Returns the smallest representable number larger than *x*."
msgstr "Retorna el número más pequeño representable mayor que *x*."

#: ../Doc/library/decimal.rst:1330
msgid "Returns the number closest to *x*, in direction towards *y*."
msgstr "Retorna el número más cercano a *x*, en la dirección de *y*."

#: ../Doc/library/decimal.rst:1335
msgid "Reduces *x* to its simplest form."
msgstr "Reduce *x* a su forma más simple."

#: ../Doc/library/decimal.rst:1340
msgid "Returns an indication of the class of *x*."
msgstr "Retorna una cadena de caracteres indicando la clase de *x*."

#: ../Doc/library/decimal.rst:1345
msgid ""
"Plus corresponds to the unary prefix plus operator in Python.  This "
"operation applies the context precision and rounding, so it is *not* an "
"identity operation."
msgstr ""
"Se corresponde con el operador unario de suma (prefijo) de Python. Esta "
"operación aplica la precisión y el redondeo establecidos en el contexto, por "
"lo que *no* es una operación de identidad."

#: ../Doc/library/decimal.rst:1352
msgid "Return ``x`` to the power of ``y``, reduced modulo ``modulo`` if given."
msgstr ""
"Retorna ``x`` elevado a la potencia ``y``, reconduciendo al módulo "
"``modulo`` si se proporciona."

#: ../Doc/library/decimal.rst:1354
msgid ""
"With two arguments, compute ``x**y``.  If ``x`` is negative then ``y`` must "
"be integral.  The result will be inexact unless ``y`` is integral and the "
"result is finite and can be expressed exactly in 'precision' digits. The "
"rounding mode of the context is used. Results are always correctly-rounded "
"in the Python version."
msgstr ""
"Con dos argumentos, calcula ``x**y``. Si ``x`` es negativo, entonces ``y`` "
"debe ser un entero. El resultado será inexacto, a menos que ``y`` sea un "
"entero y el resultado sea finito y pueda expresarse exactamente con los "
"dígitos de la 'precisión' establecida. Se utiliza el modo de redondeo "
"establecido en el contexto. Los resultados siempre se redondean "
"correctamente en la versión de Python."

#: ../Doc/library/decimal.rst:1360
msgid ""
"``Decimal(0) ** Decimal(0)`` results in ``InvalidOperation``, and if "
"``InvalidOperation`` is not trapped, then results in ``Decimal('NaN')``."
msgstr ""

#: ../Doc/library/decimal.rst:1363
msgid ""
"The C module computes :meth:`power` in terms of the correctly-rounded :meth:"
"`exp` and :meth:`ln` functions. The result is well-defined but only \"almost "
"always correctly-rounded\"."
msgstr ""
"El módulo C calcula :meth:`power` en términos de las funciones :meth:`exp` "
"y :meth:`ln` redondeadas correctamente. El resultado está bien definido pero "
"sólo \"casi siempre correctamente redondeado\"."

#: ../Doc/library/decimal.rst:1368
msgid ""
"With three arguments, compute ``(x**y) % modulo``.  For the three argument "
"form, the following restrictions on the arguments hold:"
msgstr ""
"Con tres argumentos, calcula ``(x**y) % modulo``. Para la forma de tres "
"argumentos, se mantienen las siguientes restricciones sobre los argumentos:"

#: ../Doc/library/decimal.rst:1371
msgid "all three arguments must be integral"
msgstr "los tres argumentos deben ser enteros"

#: ../Doc/library/decimal.rst:1372
msgid "``y`` must be nonnegative"
msgstr "``y`` debe ser un valor no negativo"

#: ../Doc/library/decimal.rst:1373
msgid "at least one of ``x`` or ``y`` must be nonzero"
msgstr "al menos uno, ``x`` o ``y`` , no debe ser cero"

#: ../Doc/library/decimal.rst:1374
msgid "``modulo`` must be nonzero and have at most 'precision' digits"
msgstr ""
"``modulo`` no debe ser cero y tener como mínimo los dígitos de la 'precisión'"

#: ../Doc/library/decimal.rst:1376
msgid ""
"The value resulting from ``Context.power(x, y, modulo)`` is equal to the "
"value that would be obtained by computing ``(x**y) % modulo`` with unbounded "
"precision, but is computed more efficiently.  The exponent of the result is "
"zero, regardless of the exponents of ``x``, ``y`` and ``modulo``.  The "
"result is always exact."
msgstr ""
"El valor resultante de ``Context.power(x, y, modulo)`` es igual al valor que "
"se obtendría calculando ``(x**y) % modulo`` con precisión ilimitada, la "
"diferencia es que se calcula de manera más eficiente . El exponente del "
"resultado es cero, independientemente de los exponentes de ``x``, ``y`` y  "
"``modulo``. El resultado siempre es exacto."

#: ../Doc/library/decimal.rst:1386
msgid "Returns a value equal to *x* (rounded), having the exponent of *y*."
msgstr ""
"Retorna un valor igual a *x* (redondeado), pero que tiene el exponente de "
"*y*."

#: ../Doc/library/decimal.rst:1391
msgid "Just returns 10, as this is Decimal, :)"
msgstr "Simplemente retorna 10, ya que es Decimal, :)"

#: ../Doc/library/decimal.rst:1396
msgid "Returns the remainder from integer division."
msgstr "Retorna el resto de la división entera."

#: ../Doc/library/decimal.rst:1398
msgid ""
"The sign of the result, if non-zero, is the same as that of the original "
"dividend."
msgstr ""
"El signo del resultado, si no es cero, es el mismo que el del dividendo "
"original."

#: ../Doc/library/decimal.rst:1404
msgid ""
"Returns ``x - y * n``, where *n* is the integer nearest the exact value of "
"``x / y`` (if the result is 0 then its sign will be the sign of *x*)."
msgstr ""
"Retorna ``x - y * n``, donde *n* es el número entero más cercano al valor "
"exacto de ``x / y`` (si el resultado es 0, entonces su signo será el signo "
"de *x*)."

#: ../Doc/library/decimal.rst:1410
msgid "Returns a rotated copy of *x*, *y* times."
msgstr "Retorna una copia de *x* rotada *y* veces."

#: ../Doc/library/decimal.rst:1415
msgid "Returns ``True`` if the two operands have the same exponent."
msgstr "Retorna ``True`` si los dos operandos tienen el mismo exponente."

#: ../Doc/library/decimal.rst:1420
msgid "Returns the first operand after adding the second value its exp."
msgstr ""
"Retorna el primer operando después de agregar el segundo valor a su "
"exponente."

#: ../Doc/library/decimal.rst:1425
msgid "Returns a shifted copy of *x*, *y* times."
msgstr "Retorna una copia de *x* desplazada *y* veces."

#: ../Doc/library/decimal.rst:1430
msgid "Square root of a non-negative number to context precision."
msgstr ""
"Retorna la raíz cuadrada de un número no negativo para la precisión del "
"contexto."

#: ../Doc/library/decimal.rst:1435
msgid "Return the difference between *x* and *y*."
msgstr "Retorna la diferencia entre *x* e *y*."

#: ../Doc/library/decimal.rst:1449
msgid "Rounds to an integer."
msgstr "Redondea a un entero."

#: ../Doc/library/decimal.rst:1454
msgid "Converts a number to a string using scientific notation."
msgstr ""
"Convierte un número en una cadena de caracteres usando notación científica."

#: ../Doc/library/decimal.rst:1461
msgid "Constants"
msgstr "Constantes"

#: ../Doc/library/decimal.rst:1463
msgid ""
"The constants in this section are only relevant for the C module. They are "
"also included in the pure Python version for compatibility."
msgstr ""
"Las constantes detalladas en esta sección solo son relevantes para el módulo "
"de C. Se incluyen también en la versión pura de Python por compatibilidad."

#: ../Doc/library/decimal.rst:1467
msgid "32-bit"
msgstr "32-bit"

#: ../Doc/library/decimal.rst:1467
msgid "64-bit"
msgstr "64-bit"

#: ../Doc/library/decimal.rst:1469 ../Doc/library/decimal.rst:1471
msgid ":const:`425000000`"
msgstr ":const:`425000000`"

#: ../Doc/library/decimal.rst:1469 ../Doc/library/decimal.rst:1471
msgid ":const:`999999999999999999`"
msgstr ":const:`999999999999999999`"

#: ../Doc/library/decimal.rst:1473
msgid ":const:`-425000000`"
msgstr ":const:`-425000000`"

#: ../Doc/library/decimal.rst:1473
msgid ":const:`-999999999999999999`"
msgstr ":const:`-999999999999999999`"

#: ../Doc/library/decimal.rst:1475
msgid ":const:`-849999999`"
msgstr ":const:`-849999999`"

#: ../Doc/library/decimal.rst:1475
msgid ":const:`-1999999999999999997`"
msgstr ":const:`-1999999999999999997`"

#: ../Doc/library/decimal.rst:1481
msgid ""
"The value is ``True``.  Deprecated, because Python now always has threads."
msgstr ""
"El valor es ``True``. Está obsoleta, debido ha que Python ahora siempre "
"tiene soporte para hilos."

#: ../Doc/library/decimal.rst:1487
msgid ""
"The default value is ``True``. If Python is compiled ``--without-decimal-"
"contextvar``, the C version uses a thread-local rather than a coroutine-"
"local context and the value is ``False``.  This is slightly faster in some "
"nested context scenarios."
msgstr ""
"El valor predeterminado es ``True``. Si Python se compila con la opción ``--"
"without-decimal-contextvar``, la versión de C usa un contexto de hilos "
"locales en lugar de un contexto de corrutinas locales y el valor de la "
"constante es ``False``. Esto es algo más rápido en algunos escenarios de "
"contexto anidado."

#: ../Doc/library/decimal.rst:1488
msgid "backported to 3.7 and 3.8"
msgstr "retro-portado a las versiones 3.7 y 3.8"

#: ../Doc/library/decimal.rst:1495
msgid "Rounding modes"
msgstr "Modos de redondeo"

#: ../Doc/library/decimal.rst:1499
msgid "Round towards :const:`Infinity`."
msgstr "Redondear hacia :const:`Infinity`."

#: ../Doc/library/decimal.rst:1503
msgid "Round towards zero."
msgstr "Redondear hacia cero."

#: ../Doc/library/decimal.rst:1507
msgid "Round towards :const:`-Infinity`."
msgstr "Redondear hacia :const:`-Infinity`."

#: ../Doc/library/decimal.rst:1511
msgid "Round to nearest with ties going towards zero."
msgstr "Redondear al valor contiguo más cercano, con empates hacia cero."

#: ../Doc/library/decimal.rst:1515
msgid "Round to nearest with ties going to nearest even integer."
msgstr ""
"Redondear al valor contiguo más cercano, con empates al entero par contiguo."

#: ../Doc/library/decimal.rst:1519
msgid "Round to nearest with ties going away from zero."
msgstr ""
"Redondear al valor contiguo más cercano, con empates alejándose de cero."

#: ../Doc/library/decimal.rst:1523
msgid "Round away from zero."
msgstr "Redondear alejándose de cero."

#: ../Doc/library/decimal.rst:1527
msgid ""
"Round away from zero if last digit after rounding towards zero would have "
"been 0 or 5; otherwise round towards zero."
msgstr ""
"Si el último dígito después de redondear hacia cero es 0 ó 5, redondear "
"alejándose de cero, en caso contrario, redondear hacia cero."

#: ../Doc/library/decimal.rst:1534
msgid "Signals"
msgstr "Señales"

#: ../Doc/library/decimal.rst:1536
msgid ""
"Signals represent conditions that arise during computation. Each corresponds "
"to one context flag and one context trap enabler."
msgstr ""
"Las señales representan condiciones que surgen durante el cálculo. Cada una "
"se corresponde con un solo flag de contexto y un habilitador de trampas de "
"contexto."

#: ../Doc/library/decimal.rst:1539
msgid ""
"The context flag is set whenever the condition is encountered. After the "
"computation, flags may be checked for informational purposes (for instance, "
"to determine whether a computation was exact). After checking the flags, be "
"sure to clear all flags before starting the next computation."
msgstr ""
"El flag de contexto se establece siempre que se encuentra la condición. "
"Después del cálculo, los flags pueden comprobarse con fines informativos "
"(por ejemplo, para determinar si un cálculo fue exacto). Después de "
"verificar los flags, asegúrate de borrarlos antes de comenzar con el "
"siguiente cálculo."

#: ../Doc/library/decimal.rst:1544
msgid ""
"If the context's trap enabler is set for the signal, then the condition "
"causes a Python exception to be raised.  For example, if the :class:"
"`DivisionByZero` trap is set, then a :exc:`DivisionByZero` exception is "
"raised upon encountering the condition."
msgstr ""
"Si el habilitador de trampas del contexto está configurado para la señal, "
"entonces la condición hace que se lance una excepción de Python. Por "
"ejemplo, si se establece la trampa :class:`DivisionByZero`, se genera una "
"excepción :exc:`DivisionByZero` al encontrar la condición."

#: ../Doc/library/decimal.rst:1552
msgid "Altered an exponent to fit representation constraints."
msgstr "Cambia un exponente para ajustar las restricciones de representación."

#: ../Doc/library/decimal.rst:1554
msgid ""
"Typically, clamping occurs when an exponent falls outside the context's :"
"attr:`Emin` and :attr:`Emax` limits.  If possible, the exponent is reduced "
"to fit by adding zeros to the coefficient."
msgstr ""
"Normalmente, la restricción ocurre cuando un exponente cae fuera de los "
"límites :attr:`Emin` y :attr:`Emax` del contexto. Si es posible, el "
"exponente se reduce para ajustar agregando ceros al coeficiente."

#: ../Doc/library/decimal.rst:1561
msgid "Base class for other signals and a subclass of :exc:`ArithmeticError`."
msgstr ""
"Clase base para otras señales. Es una subclase de :exc:`ArithmeticError`."

#: ../Doc/library/decimal.rst:1566
msgid "Signals the division of a non-infinite number by zero."
msgstr "Señala la división de un número no infinito entre cero."

#: ../Doc/library/decimal.rst:1568
msgid ""
"Can occur with division, modulo division, or when raising a number to a "
"negative power.  If this signal is not trapped, returns :const:`Infinity` "
"or :const:`-Infinity` with the sign determined by the inputs to the "
"calculation."
msgstr ""
"Puede ocurrir en la división, en la división modular o al elevar un número a "
"una potencia negativa. Si esta señal no es atrapada, se retorna :const:"
"`Infinity` o :const:`-Infinity`, con el signo determinado por las entradas "
"del cálculo."

#: ../Doc/library/decimal.rst:1575
msgid "Indicates that rounding occurred and the result is not exact."
msgstr "Indica que se produjo un redondeo y el resultado no es exacto."

#: ../Doc/library/decimal.rst:1577
msgid ""
"Signals when non-zero digits were discarded during rounding. The rounded "
"result is returned.  The signal flag or trap is used to detect when results "
"are inexact."
msgstr ""
"Señala que se descartaron dígitos distintos de cero durante el redondeo. Se "
"retorna el resultado redondeado. El flag o la trampa de señal se utiliza "
"para detectar cuando los resultados son inexactos."

#: ../Doc/library/decimal.rst:1584
msgid "An invalid operation was performed."
msgstr "Señala que se realizó una operación no válida."

#: ../Doc/library/decimal.rst:1586
msgid ""
"Indicates that an operation was requested that does not make sense. If not "
"trapped, returns :const:`NaN`.  Possible causes include::"
msgstr ""
"Indica que se solicitó una operación que no tiene lógica. Si esta señal no "
"está atrapada, se retorna :const:`NaN`. Las posibles causas incluyen::"

#: ../Doc/library/decimal.rst:1602
msgid "Numerical overflow."
msgstr "Desbordamiento numérico."

#: ../Doc/library/decimal.rst:1604
msgid ""
"Indicates the exponent is larger than :attr:`Emax` after rounding has "
"occurred.  If not trapped, the result depends on the rounding mode, either "
"pulling inward to the largest representable finite number or rounding "
"outward to :const:`Infinity`.  In either case, :class:`Inexact` and :class:"
"`Rounded` are also signaled."
msgstr ""
"Indica que el exponente es mayor que :attr:`max` después de que se haya "
"producido el redondeo. Si no está atrapada, el resultado depende del modo de "
"redondeo, ya sea tirando hacia adentro hasta el mayor número finito "
"representable o redondeando hacia afuera a :const:`Infinity`. En cualquier "
"caso, también se activan las señales :class:`Inexact` y :class:`Rounded`."

#: ../Doc/library/decimal.rst:1613
msgid "Rounding occurred though possibly no information was lost."
msgstr ""
"Se produjo un redondeo, aunque posiblemente no hubo pérdida de información."

#: ../Doc/library/decimal.rst:1615
msgid ""
"Signaled whenever rounding discards digits; even if those digits are zero "
"(such as rounding :const:`5.00` to :const:`5.0`).  If not trapped, returns "
"the result unchanged.  This signal is used to detect loss of significant "
"digits."
msgstr ""
"Señal lanzada cada vez que el redondeo descarta dígitos; incluso si esos "
"dígitos son cero (como al redondear :const:`5.00` a :const:`5.0`). Si no "
"está atrapada, se retorna el resultado sin cambios. Esta señal se utiliza "
"para detectar la pérdida de dígitos significativos."

#: ../Doc/library/decimal.rst:1623
msgid "Exponent was lower than :attr:`Emin` prior to rounding."
msgstr "El exponente antes del redondeo era menor que :attr:`Emin`."

#: ../Doc/library/decimal.rst:1625
msgid ""
"Occurs when an operation result is subnormal (the exponent is too small). If "
"not trapped, returns the result unchanged."
msgstr ""
"Ocurre cuando el resultado de una operación es subnormal (el exponente es "
"demasiado pequeño). Si no está atrapada, se retorna el resultado sin cambios."

#: ../Doc/library/decimal.rst:1631
msgid "Numerical underflow with result rounded to zero."
msgstr "Desbordamiento numérico negativo con resultado redondeado a cero."

#: ../Doc/library/decimal.rst:1633
msgid ""
"Occurs when a subnormal result is pushed to zero by rounding. :class:"
"`Inexact` and :class:`Subnormal` are also signaled."
msgstr ""
"Ocurre cuando un resultado subnormal se lleva a cero mediante redondeo. :"
"class:`Inexact` y :class:`Subnormal` también se señalan."

#: ../Doc/library/decimal.rst:1639
msgid "Enable stricter semantics for mixing floats and Decimals."
msgstr ""
"Habilita una semántica más estricta para mezclar flotantes y objetos Decimal."

#: ../Doc/library/decimal.rst:1641
msgid ""
"If the signal is not trapped (default), mixing floats and Decimals is "
"permitted in the :class:`~decimal.Decimal` constructor, :meth:`~decimal."
"Context.create_decimal` and all comparison operators. Both conversion and "
"comparisons are exact. Any occurrence of a mixed operation is silently "
"recorded by setting :exc:`FloatOperation` in the context flags. Explicit "
"conversions with :meth:`~decimal.Decimal.from_float` or :meth:`~decimal."
"Context.create_decimal_from_float` do not set the flag."
msgstr ""
"Si la señal no está atrapada (predeterminado), se permite mezclar flotantes "
"y objetos Decimal en el constructor de :class:`~decimal.Decimal`, en el "
"método :meth:`~decimal.Context.create_decimal` y en todos los operadores de "
"comparación. Tanto la conversión como las comparaciones son exactas. "
"Cualquier ocurrencia de una operación mixta se registra silenciosamente "
"estableciendo :exc:`FloatOperation` a los flags del contexto. Las "
"conversiones explícitas usando :meth:`~decimal.Decimal.from_float` o :meth:"
"`~decimal.Context.create_decimal_from_float` no establecen el flag."

#: ../Doc/library/decimal.rst:1649
msgid ""
"Otherwise (the signal is trapped), only equality comparisons and explicit "
"conversions are silent. All other mixed operations raise :exc:"
"`FloatOperation`."
msgstr ""
"En caso contrario (la señal está atrapada), solo las comparaciones de "
"igualdad y las conversiones explícitas permanecen silenciadas. Todas las "
"demás operaciones mixtas lanzan una excepción :exc:`FloatOperation`."

#: ../Doc/library/decimal.rst:1653
msgid "The following table summarizes the hierarchy of signals::"
msgstr "La siguiente tabla resume la jerarquía de señales::"

#: ../Doc/library/decimal.rst:1674
msgid "Floating Point Notes"
msgstr "Notas sobre la representación en coma flotante"

#: ../Doc/library/decimal.rst:1678
msgid "Mitigating round-off error with increased precision"
msgstr "Mitigación del error de redondeo usando mayor precisión"

#: ../Doc/library/decimal.rst:1680
msgid ""
"The use of decimal floating point eliminates decimal representation error "
"(making it possible to represent :const:`0.1` exactly); however, some "
"operations can still incur round-off error when non-zero digits exceed the "
"fixed precision."
msgstr ""
"El uso de la coma flotante decimal elimina el error de representación "
"decimal (haciendo posible representar :const:`0.1` de forma exacta). Sin "
"embargo, algunas operaciones aún pueden incurrir en errores de redondeo "
"cuando los dígitos distintos de cero exceden la precisión fija."

#: ../Doc/library/decimal.rst:1684
msgid ""
"The effects of round-off error can be amplified by the addition or "
"subtraction of nearly offsetting quantities resulting in loss of "
"significance.  Knuth provides two instructive examples where rounded "
"floating point arithmetic with insufficient precision causes the breakdown "
"of the associative and distributive properties of addition:"
msgstr ""
"Los efectos del error de redondeo pueden amplificarse mediante la suma o "
"resta de cantidades casi compensadas, lo que da como resultado una pérdida "
"de significación. Knuth proporciona dos ejemplos instructivos en los que la "
"aritmética de coma flotante redondeada con precisión insuficiente provoca la "
"ruptura de las propiedades asociativas y distributivas de la suma:"

#: ../Doc/library/decimal.rst:1708
msgid ""
"The :mod:`decimal` module makes it possible to restore the identities by "
"expanding the precision sufficiently to avoid loss of significance:"
msgstr ""
"El módulo :mod:`decimal` permite restaurar las identidades ampliando la "
"precisión lo suficiente para evitar la pérdida de significación:"

#: ../Doc/library/decimal.rst:1728
msgid "Special values"
msgstr "Valores especiales"

#: ../Doc/library/decimal.rst:1730
msgid ""
"The number system for the :mod:`decimal` module provides special values "
"including :const:`NaN`, :const:`sNaN`, :const:`-Infinity`, :const:"
"`Infinity`, and two zeros, :const:`+0` and :const:`-0`."
msgstr ""
"El sistema numérico para el módulo :mod:`decimal` proporciona valores "
"especiales que incluyen: :const:`NaN`, :const:`sNaN`, :const:`-Infinity`, :"
"const:`Infinity`, y dos ceros, :const:`+0` y :const:`-0`."

#: ../Doc/library/decimal.rst:1734
msgid ""
"Infinities can be constructed directly with:  ``Decimal('Infinity')``. Also, "
"they can arise from dividing by zero when the :exc:`DivisionByZero` signal "
"is not trapped.  Likewise, when the :exc:`Overflow` signal is not trapped, "
"infinity can result from rounding beyond the limits of the largest "
"representable number."
msgstr ""
"Los infinitos se pueden construir directamente con ``Decimal('Infinity')``. "
"Además, pueden surgir al dividir entre cero cuando la señal :exc:"
"`DivisionByZero` no es interceptada. Asimismo, cuando la señal :exc:"
"`Overflow` no es interceptada, un infinito puede resultar del redondeo más "
"allá de los límites del mayor número representable."

#: ../Doc/library/decimal.rst:1739
msgid ""
"The infinities are signed (affine) and can be used in arithmetic operations "
"where they get treated as very large, indeterminate numbers.  For instance, "
"adding a constant to infinity gives another infinite result."
msgstr ""
"Los infinitos tienen signo (afín) y se pueden usar en operaciones "
"aritméticas donde se tratan como números muy grandes e indeterminados. Por "
"ejemplo, adicionar una constante a infinito resulta en otro infinito."

#: ../Doc/library/decimal.rst:1743
msgid ""
"Some operations are indeterminate and return :const:`NaN`, or if the :exc:"
"`InvalidOperation` signal is trapped, raise an exception.  For example, "
"``0/0`` returns :const:`NaN` which means \"not a number\".  This variety of :"
"const:`NaN` is quiet and, once created, will flow through other computations "
"always resulting in another :const:`NaN`.  This behavior can be useful for a "
"series of computations that occasionally have missing inputs --- it allows "
"the calculation to proceed while flagging specific results as invalid."
msgstr ""
"Algunas operaciones son indeterminadas y retornan :const:`NaN`, o lanzan una "
"excepción si la señal :exc:`InvalidOperation` es atrapada. Por ejemplo, "
"``0/0`` retorna :const:`NaN` que significa \"no es un número\". Esta "
"variedad de :const:`NaN` es silenciosa y, una vez creada, fluirá a través de "
"otros cálculos dando siempre como resultado otro :const:`NaN`. Este "
"comportamiento puede ser útil para una serie de cálculos a los que "
"ocasionalmente les faltan entradas, permitiendo que el cálculo continúe "
"mientras se marcan resultados específicos como no válidos."

#: ../Doc/library/decimal.rst:1751
msgid ""
"A variant is :const:`sNaN` which signals rather than remaining quiet after "
"every operation.  This is a useful return value when an invalid result needs "
"to interrupt a calculation for special handling."
msgstr ""
"Una variante es :const:`sNaN`, que emite una señal en lugar de permanecer en "
"silencio después de cada operación. Este es un valor de retorno útil cuando "
"un resultado no válido requiere interrumpir un cálculo para un manejo "
"especial."

#: ../Doc/library/decimal.rst:1755
msgid ""
"The behavior of Python's comparison operators can be a little surprising "
"where a :const:`NaN` is involved.  A test for equality where one of the "
"operands is a quiet or signaling :const:`NaN` always returns :const:`False` "
"(even when doing ``Decimal('NaN')==Decimal('NaN')``), while a test for "
"inequality always returns :const:`True`.  An attempt to compare two Decimals "
"using any of the ``<``, ``<=``, ``>`` or ``>=`` operators will raise the :"
"exc:`InvalidOperation` signal if either operand is a :const:`NaN`, and "
"return :const:`False` if this signal is not trapped.  Note that the General "
"Decimal Arithmetic specification does not specify the behavior of direct "
"comparisons; these rules for comparisons involving a :const:`NaN` were taken "
"from the IEEE 854 standard (see Table 3 in section 5.7).  To ensure strict "
"standards-compliance, use the :meth:`compare` and :meth:`compare-signal` "
"methods instead."
msgstr ""
"El comportamiento de los operadores de comparación de Python puede ser un "
"poco sorprendente cuando está involucrado un valor :const:`NaN`. Una prueba "
"de igualdad donde uno de los operandos es un :const:`NaN` silencioso o "
"señalizador siempre retorna :const:`False` (incluso cuando se hace "
"``Decimal('NaN')==Decimal('NaN')``), mientras que una prueba de desigualdad "
"siempre retorna :const:`True`. Un intento de comparar dos objetos Decimal "
"usando cualquiera de los operadores ``<``, ``<=``, ``>`` o ``>=`` lanzará la "
"señal :exc:`InvalidOperation` si alguno de los operandos es :const:`NaN`, y "
"retornará :const:`False` si esta señal no es capturada. Ten en cuenta que la "
"Especificación general de la aritmética decimal no especifica el "
"comportamiento de las comparaciones directas. Estas reglas para las "
"comparaciones que involucran a :const:`NaN` se tomaron del estándar IEEE 854 "
"(consulta la Tabla 3 en la sección 5.7). Utiliza en su lugar los métodos :"
"meth:`compare` y :meth:`compare-signal` para garantizar el cumplimiento "
"estricto de los estándares."

#: ../Doc/library/decimal.rst:1768
msgid ""
"The signed zeros can result from calculations that underflow. They keep the "
"sign that would have resulted if the calculation had been carried out to "
"greater precision.  Since their magnitude is zero, both positive and "
"negative zeros are treated as equal and their sign is informational."
msgstr ""
"Los ceros con signo pueden resultar de cálculos que desbordan la precisión "
"establecida. Mantienen el signo que habría resultado si el cálculo se "
"hubiera realizado con mayor precisión. Dado que su magnitud es cero, los "
"ceros positivos y negativos se tratan como iguales y su signo es solo "
"informativo."

#: ../Doc/library/decimal.rst:1773
msgid ""
"In addition to the two signed zeros which are distinct yet equal, there are "
"various representations of zero with differing precisions yet equivalent in "
"value.  This takes a bit of getting used to.  For an eye accustomed to "
"normalized floating point representations, it is not immediately obvious "
"that the following calculation returns a value equal to zero:"
msgstr ""
"Además de los dos ceros con signo, que son distintos pero iguales, hay "
"varias representaciones del cero con diferente precisión pero equivalentes "
"en valor. Esto requiere de algo de tiempo para acostumbrarse. Para un ojo "
"habituado a las representaciones normalizadas de coma flotante, no es "
"inmediatamente obvio que el siguiente cálculo retorne un valor igual a cero:"

#: ../Doc/library/decimal.rst:1788
msgid "Working with threads"
msgstr "Trabajando con hilos"

#: ../Doc/library/decimal.rst:1790
msgid ""
"The :func:`getcontext` function accesses a different :class:`Context` object "
"for each thread.  Having separate thread contexts means that threads may "
"make changes (such as ``getcontext().prec=10``) without interfering with "
"other threads."
msgstr ""
"La función :func:`getcontext` accede a un objeto :class:`Context` diferente "
"para cada hilo. Tener contextos de hilo separados significa que los hilos "
"pueden realizar cambios (como ``getcontext().prec=10``) sin interferir con "
"otros hilos."

#: ../Doc/library/decimal.rst:1794
msgid ""
"Likewise, the :func:`setcontext` function automatically assigns its target "
"to the current thread."
msgstr ""
"Asimismo, la función :func:`setcontext` asigna automáticamente su objetivo "
"al hilo actual."

#: ../Doc/library/decimal.rst:1797
msgid ""
"If :func:`setcontext` has not been called before :func:`getcontext`, then :"
"func:`getcontext` will automatically create a new context for use in the "
"current thread."
msgstr ""
"Si :func:`setcontext` no ha sido invocada antes de :func:`getcontext`, "
"entonces :func:`getcontext` creará automáticamente un nuevo contexto para "
"usar en el hilo actual."

#: ../Doc/library/decimal.rst:1801
msgid ""
"The new context is copied from a prototype context called *DefaultContext*. "
"To control the defaults so that each thread will use the same values "
"throughout the application, directly modify the *DefaultContext* object. "
"This should be done *before* any threads are started so that there won't be "
"a race condition between threads calling :func:`getcontext`. For example::"
msgstr ""
"El nuevo contexto es copiado a partir de un contexto prototipo llamado "
"*DefaultContext*. Modifica directamente el objeto *DefaultContext* para "
"controlar los valores predeterminados, de modo que cada hilo utilice los "
"mismos valores en toda la aplicación. Esto debe hacerse *antes* de que se "
"inicien los hilos, para evitar que tenga lugar una condición de carrera "
"entre los mismos al invocar a :func:`getcontext`. Por ejemplo::"

#: ../Doc/library/decimal.rst:1826
msgid "Recipes"
msgstr "Casos prácticos"

#: ../Doc/library/decimal.rst:1828
msgid ""
"Here are a few recipes that serve as utility functions and that demonstrate "
"ways to work with the :class:`Decimal` class::"
msgstr ""
"A continuación hay algunos casos prácticos que sirven como funciones de "
"utilidad y que muestran formas de trabajar con la clase :class:`Decimal`::"

#: ../Doc/library/decimal.rst:1983
msgid "Decimal FAQ"
msgstr "Preguntas frecuentes sobre Decimal"

#: ../Doc/library/decimal.rst:1985
msgid ""
"Q. It is cumbersome to type ``decimal.Decimal('1234.5')``.  Is there a way "
"to minimize typing when using the interactive interpreter?"
msgstr ""
"P. Es engorroso escribir ``decimal.Decimal('1234.5')``. ¿Hay alguna forma de "
"minimizar la escritura cuando se usa el intérprete interactivo?"

#: ../Doc/library/decimal.rst:1988
msgid "A. Some users abbreviate the constructor to just a single letter:"
msgstr "R. Algunos usuarios abrevian el constructor a una sola letra:"

#: ../Doc/library/decimal.rst:1994
msgid ""
"Q. In a fixed-point application with two decimal places, some inputs have "
"many places and need to be rounded.  Others are not supposed to have excess "
"digits and need to be validated.  What methods should be used?"
msgstr ""
"P. En una aplicación de coma fija con dos decimales, algunas entradas tienen "
"muchos dígitos decimales y deben redondearse. En cambio, otras no tienen "
"dígitos en exceso y deben ser validadas. ¿Qué métodos deben utilizarse?"

#: ../Doc/library/decimal.rst:1998
msgid ""
"A. The :meth:`quantize` method rounds to a fixed number of decimal places. "
"If the :const:`Inexact` trap is set, it is also useful for validation:"
msgstr ""
"R. El método :meth:`quantize` redondea a un número fijo de decimales. Si se "
"establece la trampa :const:`Inexact`, también es útil para la validación:"

#: ../Doc/library/decimal.rst:2016
msgid ""
"Q. Once I have valid two place inputs, how do I maintain that invariant "
"throughout an application?"
msgstr ""
"P. Si tengo entradas validadas con dos dígitos decimales, ¿cómo mantengo eso "
"invariante en una aplicación?"

#: ../Doc/library/decimal.rst:2019
msgid ""
"A. Some operations like addition, subtraction, and multiplication by an "
"integer will automatically preserve fixed point.  Others operations, like "
"division and non-integer multiplication, will change the number of decimal "
"places and need to be followed-up with a :meth:`quantize` step:"
msgstr ""
"R. Algunas operaciones como la suma, la resta y la multiplicación por un "
"número entero conservarán automáticamente el punto fijo. Otras operaciones, "
"como la división y la multiplicación de números no enteros, cambiarán el "
"número de lugares decimales y deberá aplicarse :meth:`quantize` después de "
"ellas:"

#: ../Doc/library/decimal.rst:2037
msgid ""
"In developing fixed-point applications, it is convenient to define functions "
"to handle the :meth:`quantize` step:"
msgstr ""
"Al desarrollar aplicaciones de coma fija, es conveniente definir funciones "
"para gestionar el paso :meth:`quantize`:"

#: ../Doc/library/decimal.rst:2050
msgid ""
"Q. There are many ways to express the same value.  The numbers :const:"
"`200`, :const:`200.000`, :const:`2E2`, and :const:`.02E+4` all have the same "
"value at various precisions. Is there a way to transform them to a single "
"recognizable canonical value?"
msgstr ""
"P. Hay muchas formas de expresar un mismo valor. Los números :const:`200`, :"
"const:`200.000`, :const:`2E2` y :const:`.02E+4` tienen todos el mismo valor "
"pero con varias precisiones. ¿Hay alguna manera de transformarlos en un "
"único valor canónico reconocible?"

#: ../Doc/library/decimal.rst:2055
msgid ""
"A. The :meth:`normalize` method maps all equivalent values to a single "
"representative:"
msgstr ""
"R. El método :meth:`normalize` mapea todos los valores equivalentes a un "
"solo representante:"

#: ../Doc/library/decimal.rst:2062
msgid ""
"Q. Some decimal values always print with exponential notation.  Is there a "
"way to get a non-exponential representation?"
msgstr ""
"P. Algunos valores decimales siempre se imprimen usando notación "
"exponencial. ¿Hay alguna forma de obtener una representación no exponencial?"

#: ../Doc/library/decimal.rst:2065
msgid ""
"A. For some values, exponential notation is the only way to express the "
"number of significant places in the coefficient.  For example, expressing :"
"const:`5.0E+3` as :const:`5000` keeps the value constant but cannot show the "
"original's two-place significance."
msgstr ""
"R. Para algunos valores, la notación exponencial es la única forma de "
"expresar el número de lugares significativos que tiene el coeficiente. Por "
"ejemplo, expresar :const:`5.0E+3` como :const:`5000` mantiene el valor "
"constante, pero no puede mostrar la significación de dos lugares que tiene "
"el original."

#: ../Doc/library/decimal.rst:2070
msgid ""
"If an application does not care about tracking significance, it is easy to "
"remove the exponent and trailing zeroes, losing significance, but keeping "
"the value unchanged:"
msgstr ""
"Si una aplicación no necesita preocuparse por el seguimiento de "
"significación, es fácil eliminar el exponente y los ceros finales, perdiendo "
"significación, pero manteniendo el valor sin cambios:"

#: ../Doc/library/decimal.rst:2080
msgid "Q. Is there a way to convert a regular float to a :class:`Decimal`?"
msgstr ""
"P. ¿Hay alguna forma de convertir un flotante regular en un :class:`Decimal`?"

#: ../Doc/library/decimal.rst:2082
msgid ""
"A. Yes, any binary floating point number can be exactly expressed as a "
"Decimal though an exact conversion may take more precision than intuition "
"would suggest:"
msgstr ""
"R. Sí, cualquier número de coma flotante binario se puede expresar "
"exactamente mediante un Decimal, aunque una conversión exacta puede requerir "
"más precisión de la que sugiere la intuición:"

#: ../Doc/library/decimal.rst:2091
msgid ""
"Q. Within a complex calculation, how can I make sure that I haven't gotten a "
"spurious result because of insufficient precision or rounding anomalies."
msgstr ""
"P. Dentro de un cálculo complejo, ¿cómo puedo asegurarme de que no he "
"obtenido un resultado adulterado debido a una precisión insuficiente o "
"anomalías de redondeo?"

#: ../Doc/library/decimal.rst:2094
msgid ""
"A. The decimal module makes it easy to test results.  A best practice is to "
"re-run calculations using greater precision and with various rounding modes. "
"Widely differing results indicate insufficient precision, rounding mode "
"issues, ill-conditioned inputs, or a numerically unstable algorithm."
msgstr ""
"R. El módulo decimal facilita la comprobación de resultados. Una buena "
"práctica es volver a ejecutar los cálculos con mayor precisión y con varios "
"modos de redondeo. La obtención de resultados muy dispares indica una "
"precisión insuficiente, problemas relacionados con el modo de redondeo, "
"entradas mal acondicionadas o un algoritmo numéricamente inestable."

#: ../Doc/library/decimal.rst:2099
msgid ""
"Q. I noticed that context precision is applied to the results of operations "
"but not to the inputs.  Is there anything to watch out for when mixing "
"values of different precisions?"
msgstr ""
"P. Noté que la precisión del contexto se aplica a los resultados de las "
"operaciones pero no a las entradas. ¿Hay algo a tener en cuenta al mezclar "
"valores con distintas precisiones?"

#: ../Doc/library/decimal.rst:2103
msgid ""
"A. Yes.  The principle is that all values are considered to be exact and so "
"is the arithmetic on those values.  Only the results are rounded.  The "
"advantage for inputs is that \"what you type is what you get\".  A "
"disadvantage is that the results can look odd if you forget that the inputs "
"haven't been rounded:"
msgstr ""
"R. Sí. El principio es que todos los valores se consideran exactos y también "
"lo es la aritmética de esos valores. Solo se redondean los resultados. La "
"ventaja para las entradas es que \"lo que escribes es lo que obtienes\". Una "
"desventaja es que los resultados pueden parecer extraños si olvidas que las "
"entradas no se han redondeado:"

#: ../Doc/library/decimal.rst:2116
msgid ""
"The solution is either to increase precision or to force rounding of inputs "
"using the unary plus operation:"
msgstr ""
"La solución es aumentar la precisión o forzar el redondeo de las entradas "
"utilizando la operación unaria más:"

#: ../Doc/library/decimal.rst:2125
msgid ""
"Alternatively, inputs can be rounded upon creation using the :meth:`Context."
"create_decimal` method:"
msgstr ""
"Alternativamente, las entradas se pueden redondear en el momento que se "
"crean usando el método :meth:`Context.create_decimal`:"

#: ../Doc/library/decimal.rst:2131
msgid "Q. Is the CPython implementation fast for large numbers?"
msgstr "P. ¿La implementación de CPython es rápida para números grandes?"

#: ../Doc/library/decimal.rst:2133
msgid ""
"A. Yes.  In the CPython and PyPy3 implementations, the C/CFFI versions of "
"the decimal module integrate the high speed `libmpdec <https://www.bytereef."
"org/mpdecimal/doc/libmpdec/index.html>`_ library for arbitrary precision "
"correctly-rounded decimal floating point arithmetic [#]_. ``libmpdec`` uses "
"`Karatsuba multiplication <https://en.wikipedia.org/wiki/"
"Karatsuba_algorithm>`_ for medium-sized numbers and the `Number Theoretic "
"Transform <https://en.wikipedia.org/wiki/"
"Discrete_Fourier_transform_(general)#Number-theoretic_transform>`_ for very "
"large numbers."
msgstr ""
"R. Sí. En las implementaciones de CPython y PyPy3, las versiones C/CFFI del "
"módulo decimal integran la biblioteca de alta velocidad `libmpdec <https://"
"www.bytereef.org/mpdecimal/doc/libmpdec/index.html>`_ para aritmética de "
"precisión arbitraria de coma flotante decimal correctamente redondeada [#]_. "
"``libmpdec`` usa la `multiplicación de Karatsuba <https://es.wikipedia.org/"
"wiki/Algoritmo_de_Karatsuba>`_ para números de tamaño mediano y la "
"transformada teórico-numérica (`Number Theoretic Transform <https://en."
"wikipedia.org/wiki/Discrete_Fourier_transform_(general)#Number-"
"theoretic_transform>`_) para números muy grandes."

#: ../Doc/library/decimal.rst:2143
msgid ""
"The context must be adapted for exact arbitrary precision arithmetic. :attr:"
"`Emin` and :attr:`Emax` should always be set to the maximum values, :attr:"
"`clamp` should always be 0 (the default).  Setting :attr:`prec` requires "
"some care."
msgstr ""
"El contexto debe adaptarse para una aritmética de precisión arbitraria "
"exacta. :attr:`Emin` y :attr:`Emax` siempre deben establecerse en sus "
"valores máximos, :attr:`clamp` siempre debe ser 0 (el valor predeterminado). "
"Establecer :attr:`prec` requiere cierto cuidado."

#: ../Doc/library/decimal.rst:2147
msgid ""
"The easiest approach for trying out bignum arithmetic is to use the maximum "
"value for :attr:`prec` as well [#]_::"
msgstr ""
"El enfoque más fácil para probar la aritmética bignum es usar también el "
"valor máximo para :attr:`prec` [#]_::"

#: ../Doc/library/decimal.rst:2156
msgid ""
"For inexact results, :attr:`MAX_PREC` is far too large on 64-bit platforms "
"and the available memory will be insufficient::"
msgstr ""
"Para resultados inexactos, :attr:`MAX_PREC` es demasiado grande en "
"plataformas de 64 bits y la memoria disponible será insuficiente::"

#: ../Doc/library/decimal.rst:2164
msgid ""
"On systems with overallocation (e.g. Linux), a more sophisticated approach "
"is to adjust :attr:`prec` to the amount of available RAM.  Suppose that you "
"have 8GB of RAM and expect 10 simultaneous operands using a maximum of 500MB "
"each::"
msgstr ""
"En sistemas con sobreasignación (por ejemplo, Linux), un enfoque más "
"sofisticado es establecer :attr:`prec` a la cantidad de RAM disponible. "
"Supongamos que tenemos 8GB de RAM y esperamos 10 operandos simultáneos "
"usando un máximo de 500 MB cada uno::"

#: ../Doc/library/decimal.rst:2188
msgid ""
"In general (and especially on systems without overallocation), it is "
"recommended to estimate even tighter bounds and set the :attr:`Inexact` trap "
"if all calculations are expected to be exact."
msgstr ""
"En general (y especialmente en sistemas sin sobreasignación), se recomienda "
"estimar límites aún más estrictos y establecer la trampa :attr:`Inexact` si "
"se espera que todos los cálculos sean exactos."

#: ../Doc/library/decimal.rst:2197
msgid ""
"This approach now works for all exact results except for non-integer powers."
msgstr ""
"Este enfoque ahora funciona para todos los resultados exactos excepto para "
"las potencias no enteras. También retro-portado a 3.7 y 3.8."
