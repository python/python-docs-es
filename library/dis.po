# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2021-11-05 23:34+0800\n"
"Last-Translator: Rodrigo Tobar <rtobarc@gmail.com>\n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.0\n"

#: ../Doc/library/dis.rst:2
msgid ":mod:`dis` --- Disassembler for Python bytecode"
msgstr ":mod:`dis` --- Desensamblador para bytecode de Python"

#: ../Doc/library/dis.rst:7
msgid "**Source code:** :source:`Lib/dis.py`"
msgstr "**Código fuente:** :source:`Lib/dis.py`"

#: ../Doc/library/dis.rst:17
msgid ""
"The :mod:`dis` module supports the analysis of CPython :term:`bytecode` by "
"disassembling it. The CPython bytecode which this module takes as an input "
"is defined in the file :file:`Include/opcode.h` and used by the compiler and "
"the interpreter."
msgstr ""
"El módulo :mod:`dis` admite el análisis de CPython :term:`bytecode` al "
"desarmarlo. El bytecode de CPython que este módulo toma como entrada se "
"define en el archivo :file:`Include/opcode.h` y lo utilizan el compilador y "
"el intérprete."

#: ../Doc/library/dis.rst:24
msgid ""
"Bytecode is an implementation detail of the CPython interpreter.  No "
"guarantees are made that bytecode will not be added, removed, or changed "
"between versions of Python.  Use of this module should not be considered to "
"work across Python VMs or Python releases."
msgstr ""
"Bytecode es un detalle de implementación del intérprete CPython. No se "
"garantiza que el bytecode no se agregará, eliminará ni cambiará entre las "
"versiones de Python. El uso de este módulo no debe considerarse para "
"trabajar en diferentes máquinas virtuales Python o versiones de Python."

#: ../Doc/library/dis.rst:29
msgid ""
"Use 2 bytes for each instruction. Previously the number of bytes varied by "
"instruction."
msgstr ""
"Use 2 bytes para cada instrucción. Anteriormente, el número de bytes variaba "
"según la instrucción."

#: ../Doc/library/dis.rst:33
msgid ""
"The argument of jump, exception handling and loop instructions is now the "
"instruction offset rather than the byte offset."
msgstr ""
"El argumento de las instrucciones de salto, manejo de excepciones y bucle "
"ahora es el desplazamiento de instrucción en lugar del desplazamiento de "
"byte."

#: ../Doc/library/dis.rst:37
#, fuzzy
msgid ""
"Some instructions are accompanied by one or more inline cache entries, which "
"take the form of :opcode:`CACHE` instructions. These instructions are hidden "
"by default, but can be shown by passing ``show_caches=True`` to any :mod:"
"`dis` utility. Furthermore, the interpreter now adapts the bytecode to "
"specialize it for different runtime conditions. The adaptive bytecode can be "
"shown by passing ``adaptive=True``."
msgstr ""
"Algunas instrucciones van acompañadas de una o más entradas de caché en "
"línea, que adoptan la forma de instrucciones :opcode:`CACHE`. Estas "
"instrucciones están ocultas de forma predeterminada, pero se pueden mostrar "
"pasando ``show_caches=True`` a cualquier utilidad :mod:`dis`."

#: ../Doc/library/dis.rst:46
#, fuzzy
msgid "Example: Given the function :func:`!myfunc`::"
msgstr "Ejemplo: dada la función :func:`myfunc`::"

#: ../Doc/library/dis.rst:51
#, fuzzy
msgid ""
"the following command can be used to display the disassembly of :func:`!"
"myfunc`:"
msgstr ""
"el siguiente comando se puede utilizar para mostrar el desmontaje de :func:"
"`myfunc`:"

#: ../Doc/library/dis.rst:64
msgid "(The \"2\" is a line number)."
msgstr "(El \"2\" es un número de línea)."

#: ../Doc/library/dis.rst:67
msgid "Bytecode analysis"
msgstr "Análisis de bytecode"

#: ../Doc/library/dis.rst:71
msgid ""
"The bytecode analysis API allows pieces of Python code to be wrapped in a :"
"class:`Bytecode` object that provides easy access to details of the compiled "
"code."
msgstr ""
"La API de análisis de bytecode permite que partes del código Python se "
"envuelvan en un objeto :class:`Bytecode` que proporciona un fácil acceso a "
"los detalles del código compilado."

#: ../Doc/library/dis.rst:78
msgid ""
"Analyse the bytecode corresponding to a function, generator, asynchronous "
"generator, coroutine, method, string of source code, or a code object (as "
"returned by :func:`compile`)."
msgstr ""
"Analiza el bytecode correspondiente a una función, generador, generador "
"asíncrono, corutina, método, cadena de código fuente o un objeto de código "
"(como lo retorna :func:`compile`)."

#: ../Doc/library/dis.rst:82
msgid ""
"This is a convenience wrapper around many of the functions listed below, "
"most notably :func:`get_instructions`, as iterating over a :class:`Bytecode` "
"instance yields the bytecode operations as :class:`Instruction` instances."
msgstr ""
"Este es un contenedor conveniente para muchas de las funciones enumeradas a "
"continuación, en particular :func:`get_instructions`, ya que iterar sobre "
"una instancia de :class:`Bytecode` produce las operaciones de bytecode como "
"instancias de :class:`Instruction`."

#: ../Doc/library/dis.rst:86 ../Doc/library/dis.rst:274
msgid ""
"If *first_line* is not ``None``, it indicates the line number that should be "
"reported for the first source line in the disassembled code.  Otherwise, the "
"source line information (if any) is taken directly from the disassembled "
"code object."
msgstr ""
"Si *first_line* no es ``None``, indica el número de línea que se debe "
"informar para la primera línea de origen en el código desmontado. De lo "
"contrario, la información de la línea de origen (si la hay) se toma "
"directamente del objeto de código desmontado."

#: ../Doc/library/dis.rst:91
msgid ""
"If *current_offset* is not ``None``, it refers to an instruction offset in "
"the disassembled code. Setting this means :meth:`.dis` will display a "
"\"current instruction\" marker against the specified opcode."
msgstr ""
"Si *current_offset* no es ``None``, se refiere a un desplazamiento de "
"instrucción en el código desmontado. Establecer esto significa :meth:`.dis` "
"mostrará un marcador de \"instrucción actual\" contra el código de operación "
"especificado."

#: ../Doc/library/dis.rst:95
msgid ""
"If *show_caches* is ``True``, :meth:`.dis` will display inline cache entries "
"used by the interpreter to specialize the bytecode."
msgstr ""

#: ../Doc/library/dis.rst:98
msgid ""
"If *adaptive* is ``True``, :meth:`.dis` will display specialized bytecode "
"that may be different from the original bytecode."
msgstr ""

#: ../Doc/library/dis.rst:103
msgid ""
"Construct a :class:`Bytecode` instance from the given traceback, setting "
"*current_offset* to the instruction responsible for the exception."
msgstr ""
"Construye una instancia de :class:`Bytecode` a partir del *traceback* dado, "
"estableciendo *current_offset* en la instrucción responsable de la excepción."

#: ../Doc/library/dis.rst:108
msgid "The compiled code object."
msgstr "El objeto de código compilado."

#: ../Doc/library/dis.rst:112
msgid "The first source line of the code object (if available)"
msgstr "La primera línea de origen del objeto de código (si está disponible)"

#: ../Doc/library/dis.rst:116
msgid ""
"Return a formatted view of the bytecode operations (the same as printed by :"
"func:`dis.dis`, but returned as a multi-line string)."
msgstr ""
"Retorna una vista formateada de las operaciones de bytecode (lo mismo que "
"impreso por :func:`dis.dis`, pero retornado como una cadena de caracteres "
"multilínea)."

#: ../Doc/library/dis.rst:121
msgid ""
"Return a formatted multi-line string with detailed information about the "
"code object, like :func:`code_info`."
msgstr ""
"Retorna una cadena de caracteres multilínea formateada con información "
"detallada sobre el objeto de código, como :func:`code_info`."

#: ../Doc/library/dis.rst:124 ../Doc/library/dis.rst:164
#: ../Doc/library/dis.rst:216
msgid "This can now handle coroutine and asynchronous generator objects."
msgstr ""
"Esto ahora puede manejar objetos generadores asíncronos y de corutinas."

#: ../Doc/library/dis.rst:127 ../Doc/library/dis.rst:219
#: ../Doc/library/dis.rst:235 ../Doc/library/dis.rst:262
#: ../Doc/library/dis.rst:283
#, fuzzy
msgid "Added the *show_caches* and *adaptive* parameters."
msgstr "Se agregó el parámetro ``show_caches``."

#: ../Doc/library/dis.rst:130
msgid "Example:"
msgstr "Ejemplo:"

#: ../Doc/library/dis.rst:146
msgid "Analysis functions"
msgstr "Funciones de análisis"

#: ../Doc/library/dis.rst:148
msgid ""
"The :mod:`dis` module also defines the following analysis functions that "
"convert the input directly to the desired output. They can be useful if only "
"a single operation is being performed, so the intermediate analysis object "
"isn't useful:"
msgstr ""
"El módulo :mod:`dis` también define las siguientes funciones de análisis que "
"convierten la entrada directamente en la salida deseada. Pueden ser útiles "
"si solo se realiza una sola operación, por lo que el objeto de análisis "
"intermedio no es útil:"

#: ../Doc/library/dis.rst:154
msgid ""
"Return a formatted multi-line string with detailed code object information "
"for the supplied function, generator, asynchronous generator, coroutine, "
"method, source code string or code object."
msgstr ""
"Retorna una cadena de caracteres multilínea formateada con información "
"detallada del objeto de código para la función, generador, generador "
"asíncrono, corutina, método, cadena de código fuente u objeto de código "
"suministrados."

#: ../Doc/library/dis.rst:158
msgid ""
"Note that the exact contents of code info strings are highly implementation "
"dependent and they may change arbitrarily across Python VMs or Python "
"releases."
msgstr ""
"Tenga en cuenta que el contenido exacto de las cadenas de información de "
"código depende en gran medida de la implementación y puede cambiar "
"arbitrariamente en las diferentes máquinas virtuales Python o las versiones "
"de Python."

#: ../Doc/library/dis.rst:170
msgid ""
"Print detailed code object information for the supplied function, method, "
"source code string or code object to *file* (or ``sys.stdout`` if *file* is "
"not specified)."
msgstr ""
"Imprime información detallada del objeto de código para la función, método, "
"cadena de código fuente u objeto de código suministrado en *file* (o ``sys."
"stdout`` si *file* no está especificado)."

#: ../Doc/library/dis.rst:174
msgid ""
"This is a convenient shorthand for ``print(code_info(x), file=file)``, "
"intended for interactive exploration at the interpreter prompt."
msgstr ""
"Esta es una abreviatura conveniente para ``print(code_info(x), file=file)``, "
"destinado a la exploración interactiva en el indicador del intérprete "
"(*prompt*)."

#: ../Doc/library/dis.rst:179 ../Doc/library/dis.rst:210
#: ../Doc/library/dis.rst:232 ../Doc/library/dis.rst:259
msgid "Added *file* parameter."
msgstr "Agrega un parámetro *file*."

#: ../Doc/library/dis.rst:185
#, fuzzy
msgid ""
"Disassemble the *x* object.  *x* can denote either a module, a class, a "
"method, a function, a generator, an asynchronous generator, a coroutine, a "
"code object, a string of source code or a byte sequence of raw bytecode. For "
"a module, it disassembles all functions. For a class, it disassembles all "
"methods (including class and static methods). For a code object or sequence "
"of raw bytecode, it prints one line per bytecode instruction. It also "
"recursively disassembles nested code objects. These can include generator "
"expressions, nested functions, the bodies of nested classes, and the code "
"objects used for :ref:`annotation scopes <annotation-scopes>`. Strings are "
"first compiled to code objects with the :func:`compile` built-in function "
"before being disassembled.  If no object is provided, this function "
"disassembles the last traceback."
msgstr ""
"Desmontar el objeto *x*. *x* puede denotar un módulo, una clase, un método, "
"una función, un generador, un generador asíncrono, una corutina, un objeto "
"de código, una cadena de código fuente o una secuencia de bytes de código de "
"bytes sin procesar. Para un módulo, desmonta todas las funciones. Para una "
"clase, desmonta todos los métodos (incluidos los métodos de clase y "
"estáticos). Para un objeto de código o secuencia de bytecode sin procesar, "
"imprime una línea por instrucción de bytecode. También desmonta "
"recursivamente objetos de código anidados (el código de comprensiones, "
"expresiones generadoras y funciones anidadas, y el código utilizado para "
"construir clases anidadas). Las cadenas de caracteres se compilan primero en "
"objetos de código con la función incorporada :func:`compile` antes de "
"desmontarse. Si no se proporciona ningún objeto, esta función desmonta el "
"último rastreo."

#: ../Doc/library/dis.rst:198 ../Doc/library/dis.rst:229
#: ../Doc/library/dis.rst:256
msgid ""
"The disassembly is written as text to the supplied *file* argument if "
"provided and to ``sys.stdout`` otherwise."
msgstr ""
"El desensamblaje se escribe como texto en el argumento *file* proporcionado "
"si se proporciona y, de lo contrario, ``sys.stdout``."

#: ../Doc/library/dis.rst:201
msgid ""
"The maximal depth of recursion is limited by *depth* unless it is ``None``. "
"``depth=0`` means no recursion."
msgstr ""
"La profundidad máxima de recursión está limitada por *depth* a menos que sea "
"``None``. ``depth=0`` significa que no hay recursión."

#: ../Doc/library/dis.rst:204
msgid ""
"If *show_caches* is ``True``, this function will display inline cache "
"entries used by the interpreter to specialize the bytecode."
msgstr ""

#: ../Doc/library/dis.rst:207
msgid ""
"If *adaptive* is ``True``, this function will display specialized bytecode "
"that may be different from the original bytecode."
msgstr ""

#: ../Doc/library/dis.rst:213
msgid "Implemented recursive disassembling and added *depth* parameter."
msgstr "Desensamblaje recursivo implementado y parámetro agregado *depth*."

#: ../Doc/library/dis.rst:225
msgid ""
"Disassemble the top-of-stack function of a traceback, using the last "
"traceback if none was passed.  The instruction causing the exception is "
"indicated."
msgstr ""
"Desmonta la función de inicio de pila de un rastreo, utilizando el último "
"rastreo si no se pasó ninguno. Se indica la instrucción que causa la "
"excepción."

#: ../Doc/library/dis.rst:242
msgid ""
"Disassemble a code object, indicating the last instruction if *lasti* was "
"provided.  The output is divided in the following columns:"
msgstr ""
"Desmonta un objeto de código, que indica la última instrucción si se "
"proporcionó *lasti*. La salida se divide en las siguientes columnas:"

#: ../Doc/library/dis.rst:245
msgid "the line number, for the first instruction of each line"
msgstr "el número de línea, para la primera instrucción de cada línea"

#: ../Doc/library/dis.rst:246
msgid "the current instruction, indicated as ``-->``,"
msgstr "la instrucción actual, indicada como ``-->``,"

#: ../Doc/library/dis.rst:247
msgid "a labelled instruction, indicated with ``>>``,"
msgstr "una instrucción etiquetada, indicada con ``>>``,"

#: ../Doc/library/dis.rst:248
msgid "the address of the instruction,"
msgstr "la dirección de la instrucción,"

#: ../Doc/library/dis.rst:249
msgid "the operation code name,"
msgstr "el nombre del código de operación,"

#: ../Doc/library/dis.rst:250
msgid "operation parameters, and"
msgstr "parámetros de operación, y"

#: ../Doc/library/dis.rst:251
msgid "interpretation of the parameters in parentheses."
msgstr "interpretación de los parámetros entre paréntesis."

#: ../Doc/library/dis.rst:253
msgid ""
"The parameter interpretation recognizes local and global variable names, "
"constant values, branch targets, and compare operators."
msgstr ""
"La interpretación de parámetros reconoce nombres de variables locales y "
"globales, valores constantes, objetivos de ramificación y operadores de "
"comparación."

#: ../Doc/library/dis.rst:268
msgid ""
"Return an iterator over the instructions in the supplied function, method, "
"source code string or code object."
msgstr ""
"Retorna un iterador sobre las instrucciones en la función, método, cadena de "
"código fuente u objeto de código suministrado."

#: ../Doc/library/dis.rst:271
msgid ""
"The iterator generates a series of :class:`Instruction` named tuples giving "
"the details of each operation in the supplied code."
msgstr ""
"El iterador genera una serie de tuplas con nombre :class:`Instruction` que "
"dan los detalles de cada operación en el código suministrado."

#: ../Doc/library/dis.rst:279
msgid ""
"The *show_caches* and *adaptive* parameters work as they do in :func:`dis`."
msgstr ""

#: ../Doc/library/dis.rst:289
msgid ""
"This generator function uses the ``co_lines`` method of the code object "
"*code* to find the offsets which are starts of lines in the source code.  "
"They are generated as ``(offset, lineno)`` pairs."
msgstr ""
"Esta función generadora utiliza el método ``co_lines`` del objeto de código "
"*code* para encontrar las compensaciones que son los comienzos de las líneas "
"en el código fuente. Se generan como pares ``(offset, lineno)``."

#: ../Doc/library/dis.rst:293
msgid "Line numbers can be decreasing. Before, they were always increasing."
msgstr ""
"Los números de línea pueden estar disminuyendo. Antes, siempre estaban "
"aumentando."

#: ../Doc/library/dis.rst:296
msgid ""
"The :pep:`626` ``co_lines`` method is used instead of the ``co_firstlineno`` "
"and ``co_lnotab`` attributes of the code object."
msgstr ""
"Se utiliza el método :pep:`626` ``co_lines`` en lugar de los atributos "
"``co_firstlineno`` y ``co_lnotab`` del objeto de código."

#: ../Doc/library/dis.rst:303
msgid ""
"Detect all offsets in the raw compiled bytecode string *code* which are jump "
"targets, and return a list of these offsets."
msgstr ""
"Detecta todos los desplazamientos en la cadena de caracteres de código de "
"byte compilada *code* que son objetivos de salto y retorna una lista de "
"estos desplazamientos."

#: ../Doc/library/dis.rst:309
msgid "Compute the stack effect of *opcode* with argument *oparg*."
msgstr "Calcula el efecto de pila de *opcode* con el argumento *oparg*."

#: ../Doc/library/dis.rst:311
msgid ""
"If the code has a jump target and *jump* is ``True``, :func:`~stack_effect` "
"will return the stack effect of jumping.  If *jump* is ``False``, it will "
"return the stack effect of not jumping. And if *jump* is ``None`` (default), "
"it will return the maximal stack effect of both cases."
msgstr ""
"Si el código tiene un objetivo de salto y *jump* es ``True``, :func:"
"`~stack_effect` retornará el efecto de pila del salto. Si *jump* es "
"``False``, retornará el efecto de acumulación de no saltar. Y si *jump* es "
"``None`` (predeterminado), retornará el efecto de acumulación máxima de "
"ambos casos."

#: ../Doc/library/dis.rst:318
msgid "Added *jump* parameter."
msgstr "Agrega un parámetro *jump*."

#: ../Doc/library/dis.rst:325
msgid "Python Bytecode Instructions"
msgstr "Instrucciones bytecode de Python"

#: ../Doc/library/dis.rst:327
msgid ""
"The :func:`get_instructions` function and :class:`Bytecode` class provide "
"details of bytecode instructions as :class:`Instruction` instances:"
msgstr ""
"La función :func:`get_instructions` y clase :class:`Bytecode` proporcionan "
"detalles de las instrucciones bytecode como instancias :class:`Instruction`:"

#: ../Doc/library/dis.rst:332
msgid "Details for a bytecode operation"
msgstr "Detalles para una operación de bytecode"

#: ../Doc/library/dis.rst:336
msgid ""
"numeric code for operation, corresponding to the opcode values listed below "
"and the bytecode values in the :ref:`opcode_collections`."
msgstr ""
"código numérico para la operación, correspondiente a los valores del opcode "
"listados a continuación y los valores de bytecode en :ref:"
"`opcode_collections`."

#: ../Doc/library/dis.rst:342
msgid "human readable name for operation"
msgstr "nombre legible por humanos para la operación"

#: ../Doc/library/dis.rst:347
msgid "numeric argument to operation (if any), otherwise ``None``"
msgstr ""
"argumento numérico para la operación (si existe), de lo contrario ``None``"

#: ../Doc/library/dis.rst:352
msgid "resolved arg value (if any), otherwise ``None``"
msgstr "valor de argumento resuelto (si lo hay); de lo contrario, ``None``"

#: ../Doc/library/dis.rst:357
msgid ""
"human readable description of operation argument (if any), otherwise an "
"empty string."
msgstr ""
"descripción legible por humanos del argumento de la operación (si lo hay); "
"de lo contrario, una cadena vacía."

#: ../Doc/library/dis.rst:363
msgid "start index of operation within bytecode sequence"
msgstr "índice de inicio de operación dentro de la secuencia de bytecode"

#: ../Doc/library/dis.rst:368
msgid "line started by this opcode (if any), otherwise ``None``"
msgstr ""
"línea iniciada por este código de operación (si existe), de lo contrario "
"``None``"

#: ../Doc/library/dis.rst:373
msgid "``True`` if other code jumps to here, otherwise ``False``"
msgstr "``True`` si otro código salta aquí, de lo contrario, ``False``"

#: ../Doc/library/dis.rst:378
msgid ""
":class:`dis.Positions` object holding the start and end locations that are "
"covered by this instruction."
msgstr ""
"Objeto :class:`dis.Positions` que contiene las ubicaciones de inicio y "
"finalización cubiertas por esta instrucción."

#: ../Doc/library/dis.rst:385
msgid "Field ``positions`` is added."
msgstr "Se agrega el campo ``positions``."

#: ../Doc/library/dis.rst:390
msgid ""
"In case the information is not available, some fields might be ``None``."
msgstr ""
"En caso de que la información no esté disponible, algunos campos pueden ser "
"``None``."

#: ../Doc/library/dis.rst:400
msgid ""
"The Python compiler currently generates the following bytecode instructions."
msgstr ""
"El compilador de Python actualmente genera las siguientes instrucciones de "
"bytecode."

#: ../Doc/library/dis.rst:403
msgid "**General instructions**"
msgstr "**Instrucciones generales**"

#: ../Doc/library/dis.rst:405
msgid ""
"In the following, We will refer to the interpreter stack as ``STACK`` and "
"describe operations on it as if it was a Python list. The top of the stack "
"corresponds to ``STACK[-1]`` in this language."
msgstr ""

#: ../Doc/library/dis.rst:411
msgid ""
"Do nothing code.  Used as a placeholder by the bytecode optimizer, and to "
"generate line tracing events."
msgstr ""
"Código que no hace nada. Utilizado como marcador de posición por el "
"optimizador de bytecode y para generar eventos de seguimiento de línea."

#: ../Doc/library/dis.rst:417
#, fuzzy
msgid "Removes the top-of-stack item::"
msgstr "Elimina el elemento de la parte superior de la pila (TOS)."

#: ../Doc/library/dis.rst:424
msgid ""
"Removes the top two values from the stack. Equivalent to ``POP_TOP``; "
"``POP_TOP``. Used to clean up at the end of loops, hence the name."
msgstr ""

#: ../Doc/library/dis.rst:433
#, fuzzy
msgid ""
"Push the i-th item to the top of the stack without removing it from its "
"original location::"
msgstr ""
"Empuje el elemento *i*-th a la parte superior de la pila. El elemento no se "
"elimina de su ubicación original."

#: ../Doc/library/dis.rst:444
msgid "Swap the top of the stack with the i-th element::"
msgstr ""

#: ../Doc/library/dis.rst:453
msgid ""
"Rather than being an actual instruction, this opcode is used to mark extra "
"space for the interpreter to cache useful data directly in the bytecode "
"itself. It is automatically hidden by all ``dis`` utilities, but can be "
"viewed with ``show_caches=True``."
msgstr ""
"En lugar de ser una instrucción real, este código de operación se usa para "
"marcar espacio adicional para que el intérprete almacene en caché datos "
"útiles directamente en el bytecode. Todas las utilidades ``dis`` lo ocultan "
"automáticamente, pero se puede ver con ``show_caches=True``."

#: ../Doc/library/dis.rst:458
msgid ""
"Logically, this space is part of the preceding instruction. Many opcodes "
"expect to be followed by an exact number of caches, and will instruct the "
"interpreter to skip over them at runtime."
msgstr ""
"Lógicamente, este espacio forma parte de la instrucción anterior. Muchos "
"códigos de operación esperan ser seguidos por un número exacto de cachés y "
"le indicarán al intérprete que los omita en tiempo de ejecución."

#: ../Doc/library/dis.rst:462
msgid ""
"Populated caches can look like arbitrary instructions, so great care should "
"be taken when reading or modifying raw, adaptive bytecode containing "
"quickened data."
msgstr ""
"Los cachés poblados pueden parecer instrucciones arbitrarias, por lo que se "
"debe tener mucho cuidado al leer o modificar el bytecode adaptativo sin "
"procesar que contiene datos acelerados."

#: ../Doc/library/dis.rst:469
msgid "**Unary operations**"
msgstr "**Operaciones unarias**"

#: ../Doc/library/dis.rst:471
msgid ""
"Unary operations take the top of the stack, apply the operation, and push "
"the result back on the stack."
msgstr ""
"Las operaciones unarias toman la parte superior de la pila, aplican la "
"operación y retornan el resultado a la pila."

#: ../Doc/library/dis.rst:477
#, fuzzy
msgid "Implements ``STACK[-1] = -STACK[-1]``."
msgstr "Implementa ``TOS = -TOS``."

#: ../Doc/library/dis.rst:482
#, fuzzy
msgid "Implements ``STACK[-1] = not STACK[-1]``."
msgstr "Implementa ``TOS = not TOS``."

#: ../Doc/library/dis.rst:487
#, fuzzy
msgid "Implements ``STACK[-1] = ~STACK[-1]``."
msgstr "Implementa ``TOS = ~TOS``."

#: ../Doc/library/dis.rst:492
#, fuzzy
msgid "Implements ``STACK[-1] = iter(STACK[-1])``."
msgstr "Implementa ``TOS = iter(TOS)``."

#: ../Doc/library/dis.rst:497
#, fuzzy
msgid ""
"If ``STACK[-1]`` is a :term:`generator iterator` or :term:`coroutine` object "
"it is left as is.  Otherwise, implements ``STACK[-1] = iter(STACK[-1])``."
msgstr ""
"Si ``TOS`` es un :term:`iterador generador <generator iterator>` o un "
"objeto :term:`corutina <coroutine>` se deja como está. De lo contrario, "
"implementa ``TOS = iter(TOS)``."

#: ../Doc/library/dis.rst:503
msgid "**Binary and in-place operations**"
msgstr "**Operaciones binarias e in situ**"

#: ../Doc/library/dis.rst:505
#, fuzzy
msgid ""
"Binary operations remove the top two items from the stack (``STACK[-1]`` and "
"``STACK[-2]``). They perform the operation, then put the result back on the "
"stack."
msgstr ""
"Las operaciones binarias eliminan el elemento superior de la pila (TOS) y el "
"segundo elemento de la pila superior (TOS1) de la pila. Realizan la "
"operación y retornan el resultado a la pila."

#: ../Doc/library/dis.rst:508
#, fuzzy
msgid ""
"In-place operations are like binary operations, but the operation is done in-"
"place when ``STACK[-2]`` supports it, and the resulting ``STACK[-1]`` may be "
"(but does not have to be) the original ``STACK[-2]``."
msgstr ""
"Las operaciones en el lugar son como operaciones binarias, ya que eliminan "
"TOS y TOS1, y retornan el resultado a la pila, pero la operación se realiza "
"en el lugar cuando TOS1 lo admite, y el TOS resultante puede ser (pero no "
"tiene ser) el TOS1 original."

#: ../Doc/library/dis.rst:515
#, fuzzy
msgid ""
"Implements the binary and in-place operators (depending on the value of "
"*op*)::"
msgstr "Implementa los operadores binarios e in situ (según el valor de *op*)."

#: ../Doc/library/dis.rst:527 ../Doc/library/dis.rst:536
#: ../Doc/library/dis.rst:546 ../Doc/library/dis.rst:554
#: ../Doc/library/dis.rst:566 ../Doc/library/dis.rst:654
#: ../Doc/library/dis.rst:664 ../Doc/library/dis.rst:674
#: ../Doc/library/dis.rst:894 ../Doc/library/dis.rst:905
#: ../Doc/library/dis.rst:1005 ../Doc/library/dis.rst:1017
#: ../Doc/library/dis.rst:1029
msgid "Implements::"
msgstr ""

#: ../Doc/library/dis.rst:577
msgid "**Coroutine opcodes**"
msgstr "**Opcodes de corutinas**"

#: ../Doc/library/dis.rst:581
#, fuzzy
msgid ""
"Implements ``STACK[-1] = get_awaitable(STACK[-1])``, where "
"``get_awaitable(o)`` returns ``o`` if ``o`` is a coroutine object or a "
"generator object with the :data:`~inspect.CO_ITERABLE_COROUTINE` flag, or "
"resolves ``o.__await__``."
msgstr ""
"Implementa ``TOS = get_awaitable(TOS)``, donde ``get_awaitable(o)`` retorna "
"``o`` si ``o`` es un objeto de corutina o un objeto generador con el "
"indicador CO_ITERABLE_COROUTINE, o resuelve ``o.__await__``."

#: ../Doc/library/dis.rst:586
msgid ""
"If the ``where`` operand is nonzero, it indicates where the instruction "
"occurs:"
msgstr ""
"Si el operando ``where`` es distinto de cero, indica dónde ocurre la "
"instrucción:"

#: ../Doc/library/dis.rst:589
#, fuzzy
msgid "``1``: After a call to ``__aenter__``"
msgstr "``1`` Después de una llamada a ``__aenter__``"

#: ../Doc/library/dis.rst:590
#, fuzzy
msgid "``2``: After a call to ``__aexit__``"
msgstr "``2`` Después de una llamada a ``__aexit__``"

#: ../Doc/library/dis.rst:594
msgid "Previously, this instruction did not have an oparg."
msgstr "Anteriormente, esta instrucción no tenía un oparg."

#: ../Doc/library/dis.rst:600
#, fuzzy
msgid "Implements ``STACK[-1] = STACK[-1].__aiter__()``."
msgstr "Implementa ``TOS = TOS.__aiter__()``."

#: ../Doc/library/dis.rst:603
msgid "Returning awaitable objects from ``__aiter__`` is no longer supported."
msgstr "Ya no se admite el retorno de objetos *awaitable* de ``__aiter__``."

#: ../Doc/library/dis.rst:610
#, fuzzy
msgid ""
"Implement ``STACK.append(get_awaitable(STACK[-1].__anext__()))`` to the "
"stack. See ``GET_AWAITABLE`` for details about ``get_awaitable``."
msgstr ""
"Agrega ``get_awaitable(TOS.__anext__())`` a la pila. Consulte "
"``GET_AWAITABLE`` para obtener detalles sobre ``get_awaitable``."

#: ../Doc/library/dis.rst:618
msgid ""
"Terminates an :keyword:`async for` loop.  Handles an exception raised when "
"awaiting a next item. The stack contains the async iterable in ``STACK[-2]`` "
"and the raised exception in ``STACK[-1]``. Both are popped. If the exception "
"is not :exc:`StopAsyncIteration`, it is re-raised."
msgstr ""

#: ../Doc/library/dis.rst:625 ../Doc/library/dis.rst:730
#: ../Doc/library/dis.rst:741
msgid ""
"Exception representation on the stack now consist of one, not three, items."
msgstr ""
"La representación de excepciones en la pila ahora consta de uno, no de tres "
"elementos."

#: ../Doc/library/dis.rst:631
msgid ""
"Handles an exception raised during a :meth:`~generator.throw` or :meth:"
"`~generator.close` call through the current frame.  If ``STACK[-1]`` is an "
"instance of :exc:`StopIteration`, pop three values from the stack and push "
"its ``value`` member.  Otherwise, re-raise ``STACK[-1]``."
msgstr ""

#: ../Doc/library/dis.rst:641
#, fuzzy
msgid ""
"Resolves ``__aenter__`` and ``__aexit__`` from ``STACK[-1]``. Pushes "
"``__aexit__`` and result of ``__aenter__()`` to the stack::"
msgstr ""
"Resuelve ``__aenter__`` y ``__aexit__`` del objeto en la parte superior de "
"la pila. Apila ``__aexit__`` y el resultado de ``__aenter__()`` a la pila."

#: ../Doc/library/dis.rst:650
msgid "**Miscellaneous opcodes**"
msgstr "**Opcodes misceláneos**"

#: ../Doc/library/dis.rst:659
#, fuzzy
msgid "Used to implement set comprehensions."
msgstr ""
"Llama a ``set.add(TOS1[-i], TOS)``. Se utiliza para implementar "
"comprensiones de conjuntos."

#: ../Doc/library/dis.rst:669
#, fuzzy
msgid "Used to implement list comprehensions."
msgstr ""
"Llama a ``list.append(TOS1[-i], TOS)``. Se utiliza para implementar listas "
"por comprensión."

#: ../Doc/library/dis.rst:680
#, fuzzy
msgid "Used to implement dict comprehensions."
msgstr ""
"Llama a ``set.add(TOS1[-i], TOS)``. Se utiliza para implementar "
"comprensiones de conjuntos."

#: ../Doc/library/dis.rst:683
#, fuzzy
msgid ""
"Map value is ``STACK[-1]`` and map key is ``STACK[-2]``. Before, those were "
"reversed."
msgstr ""
"El valor del mapa es TOS y la clave del mapa es TOS1. Antes, esos fueron "
"revertidos."

#: ../Doc/library/dis.rst:687
msgid ""
"For all of the :opcode:`SET_ADD`, :opcode:`LIST_APPEND` and :opcode:"
"`MAP_ADD` instructions, while the added value or key/value pair is popped "
"off, the container object remains on the stack so that it is available for "
"further iterations of the loop."
msgstr ""
"Para todas las instrucciones :opcode:`SET_ADD`, :opcode:`LIST_APPEND` y :"
"opcode:`MAP_ADD`, mientras el valor agregado o el par clave/valor aparece, "
"el objeto contenedor permanece en la pila para que quede disponible para "
"futuras iteraciones del bucle."

#: ../Doc/library/dis.rst:695
#, fuzzy
msgid "Returns with ``STACK[-1]`` to the caller of the function."
msgstr "Retorna con TOS a quien llama la función."

#: ../Doc/library/dis.rst:700
#, fuzzy
msgid "Returns with ``co_consts[consti]`` to the caller of the function."
msgstr "Retorna con TOS a quien llama la función."

#: ../Doc/library/dis.rst:707
#, fuzzy
msgid "Yields ``STACK.pop()`` from a :term:`generator`."
msgstr "Desapila TOS y lo genera (*yield*) de un :term:`generator`."

#: ../Doc/library/dis.rst:709
msgid "oparg set to be the stack depth."
msgstr ""

#: ../Doc/library/dis.rst:712
msgid ""
"oparg set to be the exception block depth, for efficient closing of "
"generators."
msgstr ""

#: ../Doc/library/dis.rst:718
msgid ""
"Checks whether ``__annotations__`` is defined in ``locals()``, if not it is "
"set up to an empty ``dict``. This opcode is only emitted if a class or "
"module body contains :term:`variable annotations <variable annotation>` "
"statically."
msgstr ""
"Comprueba si ``__anotaciones__`` está definido en ``locals()``, si no está "
"configurado como un ``dict`` vacío. Este código de operación solo se emite "
"si el cuerpo de una clase o módulo contiene :term:`anotaciones de variables "
"<variable annotation>` estáticamente."

#: ../Doc/library/dis.rst:728
msgid ""
"Pops a value from the stack, which is used to restore the exception state."
msgstr ""
"Extrae un valor de la pila, que se utiliza para restaurar el estado de "
"excepción."

#: ../Doc/library/dis.rst:735
msgid ""
"Re-raises the exception currently on top of the stack. If oparg is non-zero, "
"pops an additional value from the stack which is used to set ``f_lasti`` of "
"the current frame."
msgstr ""
"Vuelve a generar la excepción que se encuentra actualmente en la parte "
"superior de la pila. Si oparg no es cero, extrae un valor adicional de la "
"pila que se usa para establecer ``f_lasti`` del marco actual."

#: ../Doc/library/dis.rst:746
msgid ""
"Pops a value from the stack. Pushes the current exception to the top of the "
"stack. Pushes the value originally popped back to the stack. Used in "
"exception handlers."
msgstr ""
"Extrae un valor de la pila. Agrega la excepción actual a la parte superior "
"de la pila. Agrega el valor que apareció originalmente de vuelta a la pila. "
"Se utiliza en los controladores de excepciones."

#: ../Doc/library/dis.rst:754
#, fuzzy
msgid ""
"Performs exception matching for ``except``. Tests whether the ``STACK[-2]`` "
"is an exception matching ``STACK[-1]``. Pops ``STACK[-1]`` and pushes the "
"boolean result of the test."
msgstr ""
"Realiza coincidencias de excepciones para ``except``. Comprueba si TOS1 es "
"una excepción que coincide con TOS. Aparece TOS y agrega el resultado "
"booleano de la prueba."

#: ../Doc/library/dis.rst:762
#, fuzzy
msgid ""
"Performs exception matching for ``except*``. Applies ``split(STACK[-1])`` on "
"the exception group representing ``STACK[-2]``."
msgstr ""
"Realiza coincidencias de excepciones para ``except*``. Aplica ``split(TOS)`` "
"en el grupo de excepción que representa TOS1."

#: ../Doc/library/dis.rst:765
msgid ""
"In case of a match, pops two items from the stack and pushes the non-"
"matching subgroup (``None`` in case of full match) followed by the matching "
"subgroup. When there is no match, pops one item (the match type) and pushes "
"``None``."
msgstr ""
"En caso de coincidencia, extrae dos elementos de la pila y agrega el "
"subgrupo que no coincide (``None`` en caso de coincidencia total) seguido "
"del subgrupo coincidente. Cuando no hay ninguna coincidencia, muestra un "
"elemento (el tipo de coincidencia) y presiona ``None``."

#: ../Doc/library/dis.rst:774
msgid ""
"Calls the function in position 4 on the stack with arguments (type, val, tb) "
"representing the exception at the top of the stack. Used to implement the "
"call ``context_manager.__exit__(*exc_info())`` when an exception has "
"occurred in a :keyword:`with` statement."
msgstr ""
"Llama a la función en la posición 4 de la pila con argumentos (tipo, val, "
"tb) que representan la excepción en la parte superior de la pila. Se utiliza "
"para implementar la llamada ``context_manager.__exit__(*exc_info())`` cuando "
"se ha producido una excepción en una sentencia :keyword:`with`."

#: ../Doc/library/dis.rst:781
msgid ""
"The ``__exit__`` function is in position 4 of the stack rather than 7. "
"Exception representation on the stack now consist of one, not three, items."
msgstr ""
"La función ``__exit__`` está en la posición 4 de la pila en lugar de la 7. "
"La representación de excepciones en la pila ahora consta de uno, no de tres, "
"elementos."

#: ../Doc/library/dis.rst:788
msgid ""
"Pushes :exc:`AssertionError` onto the stack.  Used by the :keyword:`assert` "
"statement."
msgstr ""
"Inserta :exc:`AssertionError` en la pila. Utilizado por la declaración :"
"keyword:`assert`."

#: ../Doc/library/dis.rst:796
#, fuzzy
msgid ""
"Pushes :func:`!builtins.__build_class__` onto the stack.  It is later called "
"to construct a class."
msgstr ""
"Agrega :func:`builtins.__build_class__` a la pila. Más tarde se llama para "
"construir una clase."

#: ../Doc/library/dis.rst:802
msgid ""
"This opcode performs several operations before a with block starts.  First, "
"it loads :meth:`~object.__exit__` from the context manager and pushes it "
"onto the stack for later use by :opcode:`WITH_EXCEPT_START`.  Then, :meth:"
"`~object.__enter__` is called. Finally, the result of calling the "
"``__enter__()`` method is pushed onto the stack."
msgstr ""
"Este código de operación realiza varias operaciones antes de que comience un "
"bloque with. Primero, carga :meth:`~object.__exit__` desde el administrador "
"de contexto y lo agrega a la pila para que :opcode:`WITH_EXCEPT_START` lo "
"use más tarde. Entonces, se llama :meth:`~object.__enter__`. Finalmente, el "
"resultado de llamar al método ``__enter__()`` se agrega en la pila."

#: ../Doc/library/dis.rst:813
msgid "Perform ``STACK.append(len(STACK[-1]))``."
msgstr ""

#: ../Doc/library/dis.rst:820
#, fuzzy
msgid ""
"If ``STACK[-1]`` is an instance of :class:`collections.abc.Mapping` (or, "
"more technically: if it has the :c:macro:`Py_TPFLAGS_MAPPING` flag set in "
"its :c:member:`~PyTypeObject.tp_flags`), push ``True`` onto the stack.  "
"Otherwise, push ``False``."
msgstr ""
"Si TOS es una instancia de :class:`collections.abc.Mapping` (o, más "
"técnicamente, si tiene el indicador :const:`Py_TPFLAGS_MAPPING`  establecido "
"en su :c:member:`~PyTypeObject.tp_flags`), apila ``True`` en la pila. De lo "
"contrario apila ``False``."

#: ../Doc/library/dis.rst:830
#, fuzzy
msgid ""
"If ``STACK[-1]`` is an instance of :class:`collections.abc.Sequence` and is "
"*not* an instance of :class:`str`/:class:`bytes`/:class:`bytearray` (or, "
"more technically: if it has the :c:macro:`Py_TPFLAGS_SEQUENCE` flag set in "
"its :c:member:`~PyTypeObject.tp_flags`), push ``True`` onto the stack.  "
"Otherwise, push ``False``."
msgstr ""
"Si TOS es una instancia de :class:`collections.abc.Sequence` y *no* es una "
"instancia de :class:`str`/:class:`bytes`/:class:`bytearray` (o, más "
"técnicamente, si tiene el indicador :const:`Py_TPFLAGS_SEQUENCE`  "
"establecido en su :c:member:`~PyTypeObject.tp_flags`), apila ``True`` en la "
"pila. De lo contrario apila ``False``."

#: ../Doc/library/dis.rst:840
#, fuzzy
msgid ""
"``STACK[-1]`` is a tuple of mapping keys, and ``STACK[-2]`` is the match "
"subject. If ``STACK[-2]`` contains all of the keys in ``STACK[-1]``, push a :"
"class:`tuple` containing the corresponding values. Otherwise, push ``None``."
msgstr ""
"TOS es una tupla de claves de mapeo y TOS1 es el sujeto de coincidencia. Si "
"TOS1 contiene todas las claves en TOS, agrega un :class:`tuple` que contenga "
"los valores correspondientes. De lo contrario, agrega ``None``."

#: ../Doc/library/dis.rst:846 ../Doc/library/dis.rst:1467
msgid ""
"Previously, this instruction also pushed a boolean value indicating success "
"(``True``) or failure (``False``)."
msgstr ""
"Anteriormente, esta instrucción también generaba un valor booleano que "
"indicaba éxito (``True``) o falla (``False``)."

#: ../Doc/library/dis.rst:853
#, fuzzy
msgid ""
"Implements ``name = STACK.pop()``. *namei* is the index of *name* in the "
"attribute :attr:`!co_names` of the :ref:`code object <code-objects>`. The "
"compiler tries to use :opcode:`STORE_FAST` or :opcode:`STORE_GLOBAL` if "
"possible."
msgstr ""
"Implementa ``name = TOS``. *namei* es el índice de *name* en el atributo :"
"attr:`co_names` del objeto de código. El compilador intenta usar :opcode:"
"`STORE_FAST` o :opcode:`STORE_GLOBAL` si es posible."

#: ../Doc/library/dis.rst:860
#, fuzzy
msgid ""
"Implements ``del name``, where *namei* is the index into :attr:`!co_names` "
"attribute of the :ref:`code object <code-objects>`."
msgstr ""
"Implementa ``del name``, donde *namei* es el índice en atributo :attr:"
"`co_names` del objeto de código."

#: ../Doc/library/dis.rst:866
#, fuzzy
msgid ""
"Unpacks ``STACK[-1]`` into *count* individual values, which are put onto the "
"stack right-to-left. Require there to be exactly *count* values.::"
msgstr ""
"Descomprime TOS en *count* valores individuales, que se colocan en la pila "
"de derecha a izquierda."

#: ../Doc/library/dis.rst:875
#, fuzzy
msgid ""
"Implements assignment with a starred target: Unpacks an iterable in "
"``STACK[-1]`` into individual values, where the total number of values can "
"be smaller than the number of items in the iterable: one of the new values "
"will be a list of all leftover items."
msgstr ""
"Implementa la asignación con un objetivo destacado: desempaqueta un iterable "
"en TOS en valores individuales, donde el número total de valores puede ser "
"menor que el número de elementos en el iterable: uno de los nuevos valores "
"será una lista de todos los elementos sobrantes."

#: ../Doc/library/dis.rst:880
msgid "The number of values before and after the list value is limited to 255."
msgstr ""

#: ../Doc/library/dis.rst:882
msgid ""
"The number of values before the list value is encoded in the argument of the "
"opcode. The number of values after the list if any is encoded using an "
"``EXTENDED_ARG``. As a consequence, the argument can be seen as a two bytes "
"values where the low byte of *counts* is the number of values before the "
"list value, the high byte of *counts* the number of values after it."
msgstr ""

#: ../Doc/library/dis.rst:888
msgid ""
"The extracted values are put onto the stack right-to-left, i.e. ``a, *b, c = "
"d`` will be stored after execution as ``STACK.extend((a, b, c))``."
msgstr ""

#: ../Doc/library/dis.rst:900
#, fuzzy
msgid ""
"where *namei* is the index of name in :attr:`!co_names` of the :ref:`code "
"object <code-objects>`."
msgstr ""
"Implementa ``del name``, donde *namei* es el índice en atributo :attr:"
"`co_names` del objeto de código."

#: ../Doc/library/dis.rst:910
#, fuzzy
msgid ""
"where *namei* is the index of name into :attr:`!co_names` of the :ref:`code "
"object <code-objects>`."
msgstr ""
"Implementa ``del name``, donde *namei* es el índice en atributo :attr:"
"`co_names` del objeto de código."

#: ../Doc/library/dis.rst:916
msgid "Works as :opcode:`STORE_NAME`, but stores the name as a global."
msgstr ""
"Funciona como :opcode:`STORE_NAME`, pero almacena el nombre como global."

#: ../Doc/library/dis.rst:921
msgid "Works as :opcode:`DELETE_NAME`, but deletes a global name."
msgstr "Funciona como :opcode:`DELETE_NAME`, pero elimina un nombre global."

#: ../Doc/library/dis.rst:926
msgid "Pushes ``co_consts[consti]`` onto the stack."
msgstr "Apila ``co_consts[consti]`` en la pila."

#: ../Doc/library/dis.rst:931
#, fuzzy
msgid ""
"Pushes the value associated with ``co_names[namei]`` onto the stack. The "
"name is looked up within the locals, then the globals, then the builtins."
msgstr "Apila el valor asociado con ``co_names [namei]`` en la pila."

#: ../Doc/library/dis.rst:937
msgid ""
"Pushes a reference to the locals dictionary onto the stack.  This is used to "
"prepare namespace dictionaries for :opcode:`LOAD_FROM_DICT_OR_DEREF` and :"
"opcode:`LOAD_FROM_DICT_OR_GLOBALS`."
msgstr ""

#: ../Doc/library/dis.rst:946
msgid ""
"Pops a mapping off the stack and looks up the value for ``co_names[namei]``. "
"If the name is not found there, looks it up in the globals and then the "
"builtins, similar to :opcode:`LOAD_GLOBAL`. This is used for loading global "
"variables in :ref:`annotation scopes <annotation-scopes>` within class "
"bodies."
msgstr ""

#: ../Doc/library/dis.rst:957
#, fuzzy
msgid ""
"Creates a tuple consuming *count* items from the stack, and pushes the "
"resulting tuple onto the stack.::"
msgstr ""
"Crea una tupla que consume elementos *count* de la pila, y apila la tupla "
"resultante a la pila."

#: ../Doc/library/dis.rst:967
msgid "Works as :opcode:`BUILD_TUPLE`, but creates a list."
msgstr "Funciona como :opcode:`BUILD_TUPLE`, pero crea una lista."

#: ../Doc/library/dis.rst:972
msgid "Works as :opcode:`BUILD_TUPLE`, but creates a set."
msgstr "Funciona como :opcode:`BUILD_TUPLE`, pero crea un conjunto."

#: ../Doc/library/dis.rst:977
#, fuzzy
msgid ""
"Pushes a new dictionary object onto the stack.  Pops ``2 * count`` items so "
"that the dictionary holds *count* entries: ``{..., STACK[-4]: STACK[-3], "
"STACK[-2]: STACK[-1]}``."
msgstr ""
"Apila un nuevo objeto de diccionario en la pila. Desapila ``2 * count`` "
"elementos para que el diccionario contenga *count* entradas: ``{..., TOS3: "
"TOS2, TOS1: TOS}``."

#: ../Doc/library/dis.rst:981
msgid ""
"The dictionary is created from stack items instead of creating an empty "
"dictionary pre-sized to hold *count* items."
msgstr ""
"El diccionario se crea a partir de elementos de la pila en lugar de crear un "
"diccionario vacío dimensionado previamente para contener *count* elementos."

#: ../Doc/library/dis.rst:988
#, fuzzy
msgid ""
"The version of :opcode:`BUILD_MAP` specialized for constant keys. Pops the "
"top element on the stack which contains a tuple of keys, then starting from "
"``STACK[-2]``, pops *count* values to form values in the built dictionary."
msgstr ""
"La versión de :opcode:`BUILD_MAP` especializada para claves constantes. "
"Desapila el elemento superior en la pila que contiene una tupla de claves, "
"luego, a partir de ``TOS1``, muestra los valores *count* para formar valores "
"en el diccionario incorporado."

#: ../Doc/library/dis.rst:997
msgid ""
"Concatenates *count* strings from the stack and pushes the resulting string "
"onto the stack."
msgstr ""
"Concatena *count* cadenas de caracteres de la pila y empuja la cadena de "
"caracteres resultante en la pila."

#: ../Doc/library/dis.rst:1010
msgid "Used to build lists."
msgstr ""

#: ../Doc/library/dis.rst:1022
msgid "Used to build sets."
msgstr ""

#: ../Doc/library/dis.rst:1034
msgid "Used to build dicts."
msgstr ""

#: ../Doc/library/dis.rst:1041
msgid "Like :opcode:`DICT_UPDATE` but raises an exception for duplicate keys."
msgstr ""
"Como :opcode:`DICT_UPDATE` pero lanza una excepción para claves duplicadas."

#: ../Doc/library/dis.rst:1048
msgid ""
"If the low bit of ``namei`` is not set, this replaces ``STACK[-1]`` with "
"``getattr(STACK[-1], co_names[namei>>1])``."
msgstr ""

#: ../Doc/library/dis.rst:1051
#, fuzzy
msgid ""
"If the low bit of ``namei`` is set, this will attempt to load a method named "
"``co_names[namei>>1]`` from the ``STACK[-1]`` object. ``STACK[-1]`` is "
"popped. This bytecode distinguishes two cases: if ``STACK[-1]`` has a method "
"with the correct name, the bytecode pushes the unbound method and "
"``STACK[-1]``. ``STACK[-1]`` will be used as the first argument (``self``) "
"by :opcode:`CALL` when calling the unbound method. Otherwise, ``NULL`` and "
"the object returned by the attribute lookup are pushed."
msgstr ""
"Carga un método denominado ``co_names[namei]`` desde el objeto TOS. TOS es "
"retirado. Este código de bytes distingue dos casos: si TOS tiene un método "
"con el nombre correcto, el código de bytes agrega el método independiente y "
"TOS. :opcode:`CALL` utilizará TOS como primer argumento (``self``) al llamar "
"al método independiente. De lo contrario, se agregan ``NULL`` y el objeto "
"devuelto por la búsqueda de atributos."

#: ../Doc/library/dis.rst:1059
#, fuzzy
msgid ""
"If the low bit of ``namei`` is set, then a ``NULL`` or ``self`` is pushed to "
"the stack before the attribute or unbound method respectively."
msgstr ""
"Si se establece el bit bajo de ``namei``, se agrega un ``NULL`` a la pila "
"antes de la variable global."

#: ../Doc/library/dis.rst:1066
msgid ""
"This opcode implements :func:`super` (e.g. ``super().method()`` and "
"``super().attr``). It works the same as :opcode:`LOAD_ATTR`, except that "
"``namei`` is shifted left by 2 bits instead of 1, and instead of expecting a "
"single receiver on the stack, it expects three objects (from top of stack "
"down): ``self`` (the first argument to the current method), ``cls`` (the "
"class within which the current method was defined), and the global ``super``."
msgstr ""

#: ../Doc/library/dis.rst:1073
msgid ""
"The low bit of ``namei`` signals to attempt a method load, as with :opcode:"
"`LOAD_ATTR`."
msgstr ""

#: ../Doc/library/dis.rst:1076
msgid ""
"The second-low bit of ``namei``, if set, means that this was a two-argument "
"call to :func:`super` (unset means zero-argument)."
msgstr ""

#: ../Doc/library/dis.rst:1084
msgid ""
"Performs a Boolean operation.  The operation name can be found in "
"``cmp_op[opname]``."
msgstr ""
"Realiza una operación booleana. El nombre de la operación se puede encontrar "
"en ``cmp_op[opname]``."

#: ../Doc/library/dis.rst:1090
msgid "Performs ``is`` comparison, or ``is not`` if ``invert`` is 1."
msgstr "Realiza una comparación ``is`` o ``is not`` si ``invert`` es 1."

#: ../Doc/library/dis.rst:1097
msgid "Performs ``in`` comparison, or ``not in`` if ``invert`` is 1."
msgstr "Realiza una comparación ``in`` o ``not in`` si ``invert`` es 1."

#: ../Doc/library/dis.rst:1104
#, fuzzy
msgid ""
"Imports the module ``co_names[namei]``.  ``STACK[-1]`` and ``STACK[-2]`` are "
"popped and provide the *fromlist* and *level* arguments of :func:"
"`__import__`. The module object is pushed onto the stack.  The current "
"namespace is not affected: for a proper import statement, a subsequent :"
"opcode:`STORE_FAST` instruction modifies the namespace."
msgstr ""
"Importa el módulo ``co_names[namei]``. TOS y TOS1 aparecen y proporcionan "
"los argumentos *fromlist* y *level* de :func:`__import__`. El objeto del "
"módulo se empuja a la pila. El espacio de nombres actual no se ve afectado: "
"para una instrucción de importación adecuada, una instrucción posterior :"
"opcode:`STORE_FAST` modifica el espacio de nombres."

#: ../Doc/library/dis.rst:1112
#, fuzzy
msgid ""
"Loads the attribute ``co_names[namei]`` from the module found in "
"``STACK[-1]``. The resulting object is pushed onto the stack, to be "
"subsequently stored by a :opcode:`STORE_FAST` instruction."
msgstr ""
"Carga el atributo ``co_names[namei]`` del módulo que se encuentra en TOS. El "
"objeto resultante se apila en la pila, para luego ser almacenado por la "
"instrucción :opcode:`STORE_FAST`."

#: ../Doc/library/dis.rst:1119
msgid "Increments bytecode counter by *delta*."
msgstr "Incrementa el contador de bytecode en *delta*."

#: ../Doc/library/dis.rst:1124
msgid "Decrements bytecode counter by *delta*. Checks for interrupts."
msgstr ""
"Decrementa el contador de bytecode en *delta*. Comprueba si hay "
"interrupciones."

#: ../Doc/library/dis.rst:1131
msgid "Decrements bytecode counter by *delta*. Does not check for interrupts."
msgstr ""
"Decrementa el contador de bytecode en *delta*. No busca interrupciones."

#: ../Doc/library/dis.rst:1138
#, fuzzy
msgid ""
"If ``STACK[-1]`` is true, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""
"Si TOS es verdadero, incrementa el contador de bytecode en *delta*. TOS es "
"retirado."

#: ../Doc/library/dis.rst:1141 ../Doc/library/dis.rst:1154
msgid ""
"The oparg is now a relative delta rather than an absolute target. This "
"opcode is a pseudo-instruction, replaced in final bytecode by the directed "
"versions (forward/backward)."
msgstr ""

#: ../Doc/library/dis.rst:1146 ../Doc/library/dis.rst:1159
#: ../Doc/library/dis.rst:1172 ../Doc/library/dis.rst:1186
msgid "This is no longer a pseudo-instruction."
msgstr ""

#: ../Doc/library/dis.rst:1151
#, fuzzy
msgid ""
"If ``STACK[-1]`` is false, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""
"Si TOS es falso, incrementa el contador de bytecode en *delta*. TOS es "
"retirado."

#: ../Doc/library/dis.rst:1164
#, fuzzy
msgid ""
"If ``STACK[-1]`` is not ``None``, increments the bytecode counter by "
"*delta*. ``STACK[-1]`` is popped."
msgstr ""
"Si TOS no es ``None``, incrementa el contador de bytecode en *delta*. TOS es "
"retirado."

#: ../Doc/library/dis.rst:1167 ../Doc/library/dis.rst:1181
msgid ""
"This opcode is a pseudo-instruction, replaced in final bytecode by the "
"directed versions (forward/backward)."
msgstr ""

#: ../Doc/library/dis.rst:1178
#, fuzzy
msgid ""
"If ``STACK[-1]`` is ``None``, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""
"Si TOS es ``None``, incrementa el contador de bytecode en *delta*. TOS es "
"retirado."

#: ../Doc/library/dis.rst:1191
#, fuzzy
msgid ""
"``STACK[-1]`` is an :term:`iterator`.  Call its :meth:`~iterator.__next__` "
"method. If this yields a new value, push it on the stack (leaving the "
"iterator below it).  If the iterator indicates it is exhausted then the byte "
"code counter is incremented by *delta*."
msgstr ""
"TOS es un :term:`iterador`. Llama a su método :meth:`~iterator.__next__`. Si "
"esto produce un nuevo valor, lo apila en la pila (dejando el iterador debajo "
"de él). Si el iterador indica que está agotado, se abre TOS y el contador de "
"código de bytes se incrementa en *delta*."

#: ../Doc/library/dis.rst:1196
msgid "Up until 3.11 the iterator was popped when it was exhausted."
msgstr ""

#: ../Doc/library/dis.rst:1201
msgid "Loads the global named ``co_names[namei>>1]`` onto the stack."
msgstr "Carga el ``co_names[namei>>1]`` global llamado en la pila."

#: ../Doc/library/dis.rst:1203
msgid ""
"If the low bit of ``namei`` is set, then a ``NULL`` is pushed to the stack "
"before the global variable."
msgstr ""
"Si se establece el bit bajo de ``namei``, se agrega un ``NULL`` a la pila "
"antes de la variable global."

#: ../Doc/library/dis.rst:1209
msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack."
msgstr "Apila una referencia al local ``co_varnames[var_num]`` sobre la pila."

#: ../Doc/library/dis.rst:1211
msgid ""
"This opcode is now only used in situations where the local variable is "
"guaranteed to be initialized. It cannot raise :exc:`UnboundLocalError`."
msgstr ""

#: ../Doc/library/dis.rst:1217
#, fuzzy
msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack, "
"raising an :exc:`UnboundLocalError` if the local variable has not been "
"initialized."
msgstr "Apila una referencia al local ``co_varnames[var_num]`` sobre la pila."

#: ../Doc/library/dis.rst:1225
msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack (or "
"pushes ``NULL`` onto the stack if the local variable has not been "
"initialized) and sets ``co_varnames[var_num]`` to ``NULL``."
msgstr ""

#: ../Doc/library/dis.rst:1233
#, fuzzy
msgid "Stores ``STACK.pop()`` into the local ``co_varnames[var_num]``."
msgstr "Almacena TOS en el local ``co_varnames[var_num]``."

#: ../Doc/library/dis.rst:1238
msgid "Deletes local ``co_varnames[var_num]``."
msgstr "Elimina la ``co_varnames[var_num]`` local."

#: ../Doc/library/dis.rst:1243
#, fuzzy
msgid ""
"Creates a new cell in slot ``i``.  If that slot is nonempty then that value "
"is stored into the new cell."
msgstr ""
"Crea una nueva celda en la ranura ``i``. Si esa ranura está vacía, ese valor "
"se almacena en la nueva celda."

#: ../Doc/library/dis.rst:1251
msgid ""
"Pushes a reference to the cell contained in slot ``i`` of the \"fast "
"locals\" storage.  The name of the variable is ``co_fastlocalnames[i]``."
msgstr ""
"Inserta una referencia a la celda contenida en la ranura ``i`` del "
"almacenamiento \"locales rápidos\". El nombre de la variable es "
"``co_fastlocalnames[i]``."

#: ../Doc/library/dis.rst:1254
msgid ""
"Note that ``LOAD_CLOSURE`` is effectively an alias for ``LOAD_FAST``. It "
"exists to keep bytecode a little more readable."
msgstr ""
"Tenga en cuenta que ``LOAD_CLOSURE`` es efectivamente un alias para "
"``LOAD_FAST``. Existe para mantener el bytecode un poco más legible."

#: ../Doc/library/dis.rst:1257 ../Doc/library/dis.rst:1266
#: ../Doc/library/dis.rst:1288 ../Doc/library/dis.rst:1299
msgid "``i`` is no longer offset by the length of ``co_varnames``."
msgstr "``i`` ya no se compensa con la longitud de ``co_varnames``."

#: ../Doc/library/dis.rst:1263
msgid ""
"Loads the cell contained in slot ``i`` of the \"fast locals\" storage. "
"Pushes a reference to the object the cell contains on the stack."
msgstr ""
"Carga la celda contenida en el slot ``i`` del almacenamiento \"fast "
"locals\". Agrega una referencia al objeto que contiene la celda en la pila."

#: ../Doc/library/dis.rst:1272
msgid ""
"Pops a mapping off the stack and looks up the name associated with slot "
"``i`` of the \"fast locals\" storage in this mapping. If the name is not "
"found there, loads it from the cell contained in slot ``i``, similar to :"
"opcode:`LOAD_DEREF`. This is used for loading free variables in class bodies "
"(which previously used :opcode:`!LOAD_CLASSDEREF`) and in :ref:`annotation "
"scopes <annotation-scopes>` within class bodies."
msgstr ""

#: ../Doc/library/dis.rst:1285
#, fuzzy
msgid ""
"Stores ``STACK.pop()`` into the cell contained in slot ``i`` of the \"fast "
"locals\" storage."
msgstr ""
"Almacena TOS en la celda contenida en la ranura ``i`` del almacenamiento "
"\"locales rápidos\"."

#: ../Doc/library/dis.rst:1294
msgid ""
"Empties the cell contained in slot ``i`` of the \"fast locals\" storage. "
"Used by the :keyword:`del` statement."
msgstr ""
"Vacía la celda contenida en la ranura ``i`` del almacenamiento de \"locales "
"rápidos\". Utilizado por la instrucción :keyword:`del`."

#: ../Doc/library/dis.rst:1305
msgid ""
"Copies the ``n`` free variables from the closure into the frame. Removes the "
"need for special code on the caller's side when calling closures."
msgstr ""
"Copia las variables libres ``n`` del cierre al marco. Elimina la necesidad "
"de un código especial en el lado del que llama al llamar clausuras."

#: ../Doc/library/dis.rst:1314
msgid ""
"Raises an exception using one of the 3 forms of the ``raise`` statement, "
"depending on the value of *argc*:"
msgstr ""
"Provoca una excepción utilizando una de las 3 formas de la declaración "
"``raise``, dependiendo del valor de *argc*:"

#: ../Doc/library/dis.rst:1317
msgid "0: ``raise`` (re-raise previous exception)"
msgstr "0: ``raise`` (vuelve a lanzar la excepción anterior)"

#: ../Doc/library/dis.rst:1318
#, fuzzy
msgid ""
"1: ``raise STACK[-1]`` (raise exception instance or type at ``STACK[-1]``)"
msgstr "1: ``raise TOS`` (lanza instancia de excepción o un tipo en ``TOS``)"

#: ../Doc/library/dis.rst:1319
#, fuzzy
msgid ""
"2: ``raise STACK[-2] from STACK[-1]`` (raise exception instance or type at "
"``STACK[-2]`` with ``__cause__`` set to ``STACK[-1]``)"
msgstr ""
"2: ``raise TOS1 desde TOS`` (lanza una instancia de excepción o tipo en "
"``TOS1`` con ``__cause__`` establecida en ``TOS``)"

#: ../Doc/library/dis.rst:1325
msgid ""
"Calls a callable object with the number of arguments specified by ``argc``, "
"including the named arguments specified by the preceding :opcode:`KW_NAMES`, "
"if any. On the stack are (in ascending order), either:"
msgstr ""
"Llama a un objeto invocable con la cantidad de argumentos especificados por "
"``argc``, incluidos los argumentos con nombre especificados por el :opcode:"
"`KW_NAMES` anterior, si los hay. En la pila están (en orden ascendente), ya "
"sea:"

#: ../Doc/library/dis.rst:1330
msgid "NULL"
msgstr "NULL"

#: ../Doc/library/dis.rst:1331 ../Doc/library/dis.rst:1337
msgid "The callable"
msgstr "El llamable"

#: ../Doc/library/dis.rst:1332
msgid "The positional arguments"
msgstr "Los argumentos posicionales"

#: ../Doc/library/dis.rst:1333 ../Doc/library/dis.rst:1340
msgid "The named arguments"
msgstr "Los argumentos nombrados"

#: ../Doc/library/dis.rst:1335
msgid "or:"
msgstr "o:"

#: ../Doc/library/dis.rst:1338
msgid "``self``"
msgstr "``self``"

#: ../Doc/library/dis.rst:1339
msgid "The remaining positional arguments"
msgstr "Los argumentos posicionales restantes"

#: ../Doc/library/dis.rst:1342
msgid ""
"``argc`` is the total of the positional and named arguments, excluding "
"``self`` when a ``NULL`` is not present."
msgstr ""
"``argc`` es el total de los argumentos posicionales y con nombre, excluyendo "
"``self`` cuando ``NULL`` no está presente."

#: ../Doc/library/dis.rst:1345
msgid ""
"``CALL`` pops all arguments and the callable object off the stack, calls the "
"callable object with those arguments, and pushes the return value returned "
"by the callable object."
msgstr ""
"``CALL`` extrae todos los argumentos y el objeto invocable de la pila, llama "
"al objeto invocable con esos argumentos y agrega el valor retornado por el "
"objeto invocable."

#: ../Doc/library/dis.rst:1354
msgid ""
"Calls a callable object with variable set of positional and keyword "
"arguments.  If the lowest bit of *flags* is set, the top of the stack "
"contains a mapping object containing additional keyword arguments. Before "
"the callable is called, the mapping object and iterable object are each "
"\"unpacked\" and their contents passed in as keyword and positional "
"arguments respectively. ``CALL_FUNCTION_EX`` pops all arguments and the "
"callable object off the stack, calls the callable object with those "
"arguments, and pushes the return value returned by the callable object."
msgstr ""
"Llama a un objeto invocable con un conjunto variable de argumentos "
"posicionales y de palabras clave. Si se establece el bit más bajo de "
"*flags*, la parte superior de la pila contiene un objeto de mapeo que "
"contiene argumentos de palabras clave adicionales. Antes de que se llame al "
"invocable, el objeto de mapeo y el objeto iterable se \"desempaquetan\" y su "
"contenido se pasa como palabra clave y argumentos posicionales, "
"respectivamente. ``CALL_FUNCTION_EX`` saca todos los argumentos y el objeto "
"invocable de la pila, llama al objeto invocable con esos argumentos y empuja "
"el valor de retorno retornado por el objeto invocable."

#: ../Doc/library/dis.rst:1369
msgid ""
"Pushes a ``NULL`` to the stack. Used in the call sequence to match the "
"``NULL`` pushed by :opcode:`LOAD_METHOD` for non-method calls."
msgstr ""
"Agrega un ``NULL`` a la pila. Se usa en la secuencia de llamadas para hacer "
"coincidir el ``NULL`` enviado por :opcode:`LOAD_METHOD` para llamadas que no "
"son de método."

#: ../Doc/library/dis.rst:1378
#, fuzzy
msgid ""
"Prefixes :opcode:`CALL`. Stores a reference to ``co_consts[consti]`` into an "
"internal variable for use by :opcode:`CALL`. ``co_consts[consti]`` must be a "
"tuple of strings."
msgstr ""
"Prefijos :opcode:`PRECALL`. Almacena una referencia a ``co_consts[consti]`` "
"en una variable interna para uso de :opcode:`CALL`. ``co_consts[consti]`` "
"debe ser una tupla de cadenas."

#: ../Doc/library/dis.rst:1387
msgid ""
"Pushes a new function object on the stack.  From bottom to top, the consumed "
"stack must consist of values if the argument carries a specified flag value"
msgstr ""
"Apila un nuevo objeto de función en la pila. De abajo hacia arriba, la pila "
"consumida debe constar de valores si el argumento lleva un valor de marca "
"especificado"

#: ../Doc/library/dis.rst:1390
msgid ""
"``0x01`` a tuple of default values for positional-only and positional-or-"
"keyword parameters in positional order"
msgstr ""
"``0x01``, una tupla de valores predeterminados para solo parámetros "
"posicionales y posicionales o de palabras clave en orden posicional"

#: ../Doc/library/dis.rst:1392
msgid "``0x02`` a dictionary of keyword-only parameters' default values"
msgstr ""
"``0x02`` un diccionario de valores predeterminados de solo palabras clave"

#: ../Doc/library/dis.rst:1393
msgid "``0x04`` a tuple of strings containing parameters' annotations"
msgstr ""
"``0x04`` una tupla de cadenas de caracteres que contiene anotaciones de "
"parámetros"

#: ../Doc/library/dis.rst:1394
msgid "``0x08`` a tuple containing cells for free variables, making a closure"
msgstr ""
"``0x08`` una tupla que contiene celdas para variables libres, haciendo un "
"cierre (*closure*)"

#: ../Doc/library/dis.rst:1395
#, fuzzy
msgid "the code associated with the function (at ``STACK[-1]``)"
msgstr "el código asociado con la función (en TOS1)"

#: ../Doc/library/dis.rst:1397
msgid "Flag value ``0x04`` is a tuple of strings instead of dictionary"
msgstr ""
"El valor indicador ``0x04`` es una tupla de cadena de caracteres en vez de "
"un diccionario"

#: ../Doc/library/dis.rst:1400
msgid "Qualified name at ``STACK[-1]`` was removed."
msgstr ""

#: ../Doc/library/dis.rst:1408
msgid ""
"Pushes a slice object on the stack.  *argc* must be 2 or 3.  If it is 2, "
"implements::"
msgstr ""

#: ../Doc/library/dis.rst:1414
msgid "if it is 3, implements::"
msgstr ""

#: ../Doc/library/dis.rst:1421
msgid "See the :func:`slice` built-in function for more information."
msgstr ""

#: ../Doc/library/dis.rst:1426
msgid ""
"Prefixes any opcode which has an argument too big to fit into the default "
"one byte. *ext* holds an additional byte which act as higher bits in the "
"argument. For each opcode, at most three prefixal ``EXTENDED_ARG`` are "
"allowed, forming an argument from two-byte to four-byte."
msgstr ""
"Prefija cualquier código de operación que tenga un argumento demasiado "
"grande para caber en el byte predeterminado. *ext* contiene un byte "
"adicional que actúa como bits más altos en el argumento. Para cada opcode, "
"como máximo se permiten tres prefijos ``EXTENDED_ARG``, formando un "
"argumento de dos bytes a cuatro bytes."

#: ../Doc/library/dis.rst:1434
msgid ""
"Used for implementing formatted literal strings (f-strings).  Pops an "
"optional *fmt_spec* from the stack, then a required *value*. *flags* is "
"interpreted as follows:"
msgstr ""
"Se utiliza para implementar cadenas literales formateadas (cadenas de "
"caracteres f). Desapila un *fmt_spec* opcional de la pila, luego un *value* "
"requerido. *flags* se interpreta de la siguiente manera:"

#: ../Doc/library/dis.rst:1438
msgid "``(flags & 0x03) == 0x00``: *value* is formatted as-is."
msgstr "``(flags & 0x03) == 0x00``: *value* es formateado como está."

#: ../Doc/library/dis.rst:1439
msgid ""
"``(flags & 0x03) == 0x01``: call :func:`str` on *value* before formatting it."
msgstr ""
"``(flags & 0x03) == 0x01``: llama :func:`str` sobre *value* antes de "
"formatearlo."

#: ../Doc/library/dis.rst:1441
msgid ""
"``(flags & 0x03) == 0x02``: call :func:`repr` on *value* before formatting "
"it."
msgstr ""
"``(flags & 0x03) == 0x02``: llama :func:`repr` sobre *value* antes de "
"formatearlo."

#: ../Doc/library/dis.rst:1443
msgid ""
"``(flags & 0x03) == 0x03``: call :func:`ascii` on *value* before formatting "
"it."
msgstr ""
"``(flags & 0x03) == 0x03``: llama :func:`ascii` sobre *value* antes de "
"formatearlo."

#: ../Doc/library/dis.rst:1445
msgid ""
"``(flags & 0x04) == 0x04``: pop *fmt_spec* from the stack and use it, else "
"use an empty *fmt_spec*."
msgstr ""
"``(flags & 0x04) == 0x04``: desapila *fmt_spec* de la pila y lo usa, de lo "
"contrario usa un *fmt_spec* vacío."

#: ../Doc/library/dis.rst:1448
msgid ""
"Formatting is performed using :c:func:`PyObject_Format`.  The result is "
"pushed on the stack."
msgstr ""
"El formateo se realiza usando :c:func:`PyObject_Format`. El resultado se "
"apila en la pila."

#: ../Doc/library/dis.rst:1456
#, fuzzy
msgid ""
"``STACK[-1]`` is a tuple of keyword attribute names, ``STACK[-2]`` is the "
"class being matched against, and ``STACK[-3]`` is the match subject.  "
"*count* is the number of positional sub-patterns."
msgstr ""
"TOS es una tupla de nombres de atributos clave, TOS1 es la clase contra la "
"cual se hace la coincidencia, y TOS2 es el sujeto de la coincidencia. "
"*count* es el número de sub-patrones posicionales."

#: ../Doc/library/dis.rst:1460
#, fuzzy
msgid ""
"Pop ``STACK[-1]``, ``STACK[-2]``, and ``STACK[-3]``. If ``STACK[-3]`` is an "
"instance of ``STACK[-2]`` and has the positional and keyword attributes "
"required by *count* and ``STACK[-1]``, push a tuple of extracted attributes. "
"Otherwise, push ``None``."
msgstr ""
"Retira TOS, TOS1 y TOS2. Si TOS2 es una instancia de TOS1 y tiene los "
"atributos posicionales y de palabra clave requeridos por *count* y TOS, "
"agrega una tupla de atributos extraídos. De lo contrario, agrega ``None``."

#: ../Doc/library/dis.rst:1474
msgid "A no-op. Performs internal tracing, debugging and optimization checks."
msgstr ""
"Un no-op. Realiza comprobaciones internas de seguimiento, depuración y "
"optimización."

#: ../Doc/library/dis.rst:1476
msgid "The ``where`` operand marks where the ``RESUME`` occurs:"
msgstr "El operando ``where`` marca dónde ocurre el ``RESUME``:"

#: ../Doc/library/dis.rst:1478
msgid ""
"``0`` The start of a function, which is neither a generator, coroutine nor "
"an async generator"
msgstr ""

#: ../Doc/library/dis.rst:1480
msgid "``1`` After a ``yield`` expression"
msgstr "``1`` Después de una expresión ``yield``"

#: ../Doc/library/dis.rst:1481
msgid "``2`` After a ``yield from`` expression"
msgstr "``2`` Después de una expresión ``yield from``"

#: ../Doc/library/dis.rst:1482
msgid "``3`` After an ``await`` expression"
msgstr "``3`` Después de una expresión ``await``"

#: ../Doc/library/dis.rst:1489
#, fuzzy
msgid ""
"Create a generator, coroutine, or async generator from the current frame. "
"Used as first opcode of in code object for the above mentioned callables. "
"Clear the current frame and return the newly created generator."
msgstr ""
"Crea un generador, corrutina o generador asíncrono a partir del marco "
"actual. Borra el marco actual y retorna el generador recién creado."

#: ../Doc/library/dis.rst:1498
msgid ""
"Equivalent to ``STACK[-1] = STACK[-2].send(STACK[-1])``. Used in ``yield "
"from`` and ``await`` statements."
msgstr ""

#: ../Doc/library/dis.rst:1501
msgid ""
"If the call raises :exc:`StopIteration`, pop both items, push the "
"exception's ``value`` attribute, and increment the bytecode counter by "
"*delta*."
msgstr ""

#: ../Doc/library/dis.rst:1510
#, fuzzy
msgid ""
"This is not really an opcode.  It identifies the dividing line between "
"opcodes in the range [0,255] which don't use their argument and those that "
"do (``< HAVE_ARGUMENT`` and ``>= HAVE_ARGUMENT``, respectively)."
msgstr ""
"Esto no es realmente un opcode. Identifica la línea divisoria entre los "
"opcode que no usan su argumento y los que lo hacen (``< HAVE_ARGUMENT`` y "
"``>= HAVE_ARGUMENT``, respectivamente)."

#: ../Doc/library/dis.rst:1514
msgid ""
"If your application uses pseudo instructions, use the :data:`hasarg` "
"collection instead."
msgstr ""

#: ../Doc/library/dis.rst:1517
msgid ""
"Now every instruction has an argument, but opcodes ``< HAVE_ARGUMENT`` "
"ignore it. Before, only opcodes ``>= HAVE_ARGUMENT`` had an argument."
msgstr ""
"Ahora cada instrucción tiene un argumento, pero los códigos de operación "
"``<HAVE_ARGUMENT`` la ignoran. Antes, solo los códigos de operación ``> = "
"HAVE_ARGUMENT`` tenían un argumento."

#: ../Doc/library/dis.rst:1521
msgid ""
"Pseudo instructions were added to the :mod:`dis` module, and for them it is "
"not true that comparison with ``HAVE_ARGUMENT`` indicates whether they use "
"their arg."
msgstr ""

#: ../Doc/library/dis.rst:1529
msgid ""
"Calls an intrinsic function with one argument. Passes ``STACK[-1]`` as the "
"argument and sets ``STACK[-1]`` to the result. Used to implement "
"functionality that is necessary but not performance critical."
msgstr ""

#: ../Doc/library/dis.rst:1533 ../Doc/library/dis.rst:1583
msgid "The operand determines which intrinsic function is called:"
msgstr ""

#: ../Doc/library/dis.rst:1536 ../Doc/library/dis.rst:1586
msgid "Operand"
msgstr ""

#: ../Doc/library/dis.rst:1536 ../Doc/library/dis.rst:1586
msgid "Description"
msgstr ""

#: ../Doc/library/dis.rst:1538
msgid "``INTRINSIC_1_INVALID``"
msgstr ""

#: ../Doc/library/dis.rst:1538 ../Doc/library/dis.rst:1588
msgid "Not valid"
msgstr ""

#: ../Doc/library/dis.rst:1540
msgid "``INTRINSIC_PRINT``"
msgstr ""

#: ../Doc/library/dis.rst:1540
msgid "Prints the argument to standard out. Used in the REPL."
msgstr ""

#: ../Doc/library/dis.rst:1543
msgid "``INTRINSIC_IMPORT_STAR``"
msgstr ""

#: ../Doc/library/dis.rst:1543
msgid "Performs ``import *`` for the named module."
msgstr ""

#: ../Doc/library/dis.rst:1546
msgid "``INTRINSIC_STOPITERATION_ERROR``"
msgstr ""

#: ../Doc/library/dis.rst:1546
msgid "Extracts the return value from a ``StopIteration`` exception."
msgstr ""

#: ../Doc/library/dis.rst:1549
msgid "``INTRINSIC_ASYNC_GEN_WRAP``"
msgstr ""

#: ../Doc/library/dis.rst:1549
msgid "Wraps an aync generator value"
msgstr ""

#: ../Doc/library/dis.rst:1551
msgid "``INTRINSIC_UNARY_POSITIVE``"
msgstr ""

#: ../Doc/library/dis.rst:1551
msgid "Performs the unary ``+`` operation"
msgstr ""

#: ../Doc/library/dis.rst:1554
msgid "``INTRINSIC_LIST_TO_TUPLE``"
msgstr ""

#: ../Doc/library/dis.rst:1554
msgid "Converts a list to a tuple"
msgstr ""

#: ../Doc/library/dis.rst:1556
msgid "``INTRINSIC_TYPEVAR``"
msgstr ""

#: ../Doc/library/dis.rst:1556
msgid "Creates a :class:`typing.TypeVar`"
msgstr ""

#: ../Doc/library/dis.rst:1558
msgid "``INTRINSIC_PARAMSPEC``"
msgstr ""

#: ../Doc/library/dis.rst:1558
msgid "Creates a :class:`typing.ParamSpec`"
msgstr ""

#: ../Doc/library/dis.rst:1561
msgid "``INTRINSIC_TYPEVARTUPLE``"
msgstr ""

#: ../Doc/library/dis.rst:1561
msgid "Creates a :class:`typing.TypeVarTuple`"
msgstr ""

#: ../Doc/library/dis.rst:1564
msgid "``INTRINSIC_SUBSCRIPT_GENERIC``"
msgstr ""

#: ../Doc/library/dis.rst:1564
msgid "Returns :class:`typing.Generic` subscripted with the argument"
msgstr ""

#: ../Doc/library/dis.rst:1567
msgid "``INTRINSIC_TYPEALIAS``"
msgstr ""

#: ../Doc/library/dis.rst:1567
msgid ""
"Creates a :class:`typing.TypeAliasType`; used in the :keyword:`type` "
"statement. The argument is a tuple of the type alias's name, type "
"parameters, and value."
msgstr ""

#: ../Doc/library/dis.rst:1579
msgid ""
"Calls an intrinsic function with two arguments. Passes ``STACK[-2]``, "
"``STACK[-1]`` as the arguments and sets ``STACK[-1]`` to the result. Used to "
"implement functionality that is necessary but not performance critical."
msgstr ""

#: ../Doc/library/dis.rst:1588
msgid "``INTRINSIC_2_INVALID``"
msgstr ""

#: ../Doc/library/dis.rst:1590
msgid "``INTRINSIC_PREP_RERAISE_STAR``"
msgstr ""

#: ../Doc/library/dis.rst:1590
msgid "Calculates the :exc:`ExceptionGroup` to raise from a ``try-except*``."
msgstr ""

#: ../Doc/library/dis.rst:1594
msgid "``INTRINSIC_TYPEVAR_WITH_BOUND``"
msgstr ""

#: ../Doc/library/dis.rst:1594
msgid "Creates a :class:`typing.TypeVar` with a bound."
msgstr ""

#: ../Doc/library/dis.rst:1597
msgid "``INTRINSIC_TYPEVAR_WITH_CONSTRAINTS``"
msgstr ""

#: ../Doc/library/dis.rst:1597
msgid "Creates a :class:`typing.TypeVar` with constraints."
msgstr ""

#: ../Doc/library/dis.rst:1601
msgid "``INTRINSIC_SET_FUNCTION_TYPE_PARAMS``"
msgstr ""

#: ../Doc/library/dis.rst:1601
msgid "Sets the ``__type_params__`` attribute of a function."
msgstr ""

#: ../Doc/library/dis.rst:1608
#, fuzzy
msgid "**Pseudo-instructions**"
msgstr "**Instrucciones generales**"

#: ../Doc/library/dis.rst:1610
msgid ""
"These opcodes do not appear in Python bytecode. They are used by the "
"compiler but are replaced by real opcodes or removed before bytecode is "
"generated."
msgstr ""

#: ../Doc/library/dis.rst:1615
msgid ""
"Set up an exception handler for the following code block. If an exception "
"occurs, the value stack level is restored to its current state and control "
"is transferred to the exception handler at ``target``."
msgstr ""

#: ../Doc/library/dis.rst:1622
msgid ""
"Like ``SETUP_FINALLY``, but in case of an exception also pushes the last "
"instruction (``lasti``) to the stack so that ``RERAISE`` can restore it. If "
"an exception occurs, the value stack level and the last instruction on the "
"frame are restored to their current state, and control is transferred to the "
"exception handler at ``target``."
msgstr ""

#: ../Doc/library/dis.rst:1631
msgid ""
"Like ``SETUP_CLEANUP``, but in case of an exception one more item is popped "
"from the stack before control is transferred to the exception handler at "
"``target``."
msgstr ""

#: ../Doc/library/dis.rst:1635
msgid ""
"This variant is used in :keyword:`with` and :keyword:`async with` "
"constructs, which push the return value of the context manager's :meth:"
"`~object.__enter__` or :meth:`~object.__aenter__` to the stack."
msgstr ""

#: ../Doc/library/dis.rst:1642
msgid ""
"Marks the end of the code block associated with the last ``SETUP_FINALLY``, "
"``SETUP_CLEANUP`` or ``SETUP_WITH``."
msgstr ""

#: ../Doc/library/dis.rst:1648
msgid ""
"Undirected relative jump instructions which are replaced by their directed "
"(forward/backward) counterparts by the assembler."
msgstr ""

#: ../Doc/library/dis.rst:1653
msgid ""
"Optimized unbound method lookup. Emitted as a ``LOAD_ATTR`` opcode with a "
"flag set in the arg."
msgstr ""

#: ../Doc/library/dis.rst:1660
msgid "Opcode collections"
msgstr "Colecciones opcode"

#: ../Doc/library/dis.rst:1662
msgid ""
"These collections are provided for automatic introspection of bytecode "
"instructions:"
msgstr ""
"Estas colecciones se proporcionan para la introspección automática de "
"instrucciones de bytecode:"

#: ../Doc/library/dis.rst:1665
msgid ""
"The collections now contain pseudo instructions as well. These are opcodes "
"with values ``>= MIN_PSEUDO_OPCODE``."
msgstr ""

#: ../Doc/library/dis.rst:1671
msgid "Sequence of operation names, indexable using the bytecode."
msgstr "Secuencia de nombres de operaciones, indexable utilizando el bytecode."

#: ../Doc/library/dis.rst:1676
msgid "Dictionary mapping operation names to bytecodes."
msgstr "Nombres de operaciones de mapeo de diccionario a bytecodes."

#: ../Doc/library/dis.rst:1681
msgid "Sequence of all compare operation names."
msgstr "Secuencia de todos los nombres de operaciones de comparación."

#: ../Doc/library/dis.rst:1686
#, fuzzy
msgid "Sequence of bytecodes that use their argument."
msgstr "Secuencia de bytecodes que acceden a una constante."

#: ../Doc/library/dis.rst:1693
msgid "Sequence of bytecodes that access a constant."
msgstr "Secuencia de bytecodes que acceden a una constante."

#: ../Doc/library/dis.rst:1698
#, fuzzy
msgid ""
"Sequence of bytecodes that access a free variable. 'free' in this context "
"refers to names in the current scope that are referenced by inner scopes or "
"names in outer scopes that are referenced from this scope.  It does *not* "
"include references to global or builtin scopes."
msgstr ""
"Secuencia de bytecodes que acceden a una variable libre (tenga en cuenta que "
"'libre' en este contexto se refiere a nombres en el alcance actual a los que "
"hacen referencia los ámbitos internos o los nombres en los ámbitos externos "
"a los que se hace referencia desde este ámbito. **No** incluye referencias a "
"ámbitos globales o integrados)."

#: ../Doc/library/dis.rst:1706
msgid "Sequence of bytecodes that access an attribute by name."
msgstr "Secuencia de bytecodes que acceden a un atributo por nombre."

#: ../Doc/library/dis.rst:1711
msgid "Sequence of bytecodes that have a relative jump target."
msgstr "Secuencia de bytecodes que tienen un objetivo de salto relativo."

#: ../Doc/library/dis.rst:1716
msgid "Sequence of bytecodes that have an absolute jump target."
msgstr "Secuencia de bytecodes que tienen un objetivo de salto absoluto."

#: ../Doc/library/dis.rst:1721
msgid "Sequence of bytecodes that access a local variable."
msgstr "Secuencia de códigos de bytes que acceden a una variable local."

#: ../Doc/library/dis.rst:1726
msgid "Sequence of bytecodes of Boolean operations."
msgstr "Secuencia de bytecodes de operaciones booleanas."

#: ../Doc/library/dis.rst:1730
#, fuzzy
msgid "Sequence of bytecodes that set an exception handler."
msgstr "Secuencia de bytecodes que acceden a una constante."

#: ../Doc/library/dis.rst:1406
msgid "built-in function"
msgstr ""

#: ../Doc/library/dis.rst:1406
msgid "slice"
msgstr ""

#~ msgid "Swap TOS with the item at position *i*."
#~ msgstr "Intercambie TOS con el artículo en la posición *i*."

#~ msgid "Implements ``TOS = +TOS``."
#~ msgstr "Implementa ``TOS = +TOS``."

#~ msgid "Implements ``TOS = TOS1[TOS]``."
#~ msgstr "Implementa ``TOS = TOS1[TOS]``."

#~ msgid "Implements ``TOS1[TOS] = TOS2``."
#~ msgstr "Implementa ``TOS1[TOS] = TOS2``."

#~ msgid "Implements ``del TOS1[TOS]``."
#~ msgstr "Implementa ``del TOS1[TOS]``."

#~ msgid ""
#~ "Terminates an :keyword:`async for` loop.  Handles an exception raised "
#~ "when awaiting a next item.  If TOS is :exc:`StopAsyncIteration` pop 3 "
#~ "values from the stack and restore the exception state using the second of "
#~ "them.  Otherwise re-raise the exception using the value from the stack.  "
#~ "An exception handler block is removed from the block stack."
#~ msgstr ""
#~ "Termina un bucle :keyword:`async for`. Maneja una excepción generada "
#~ "cuando se espera un elemento siguiente. Si TOS es :exc:"
#~ "`StopAsyncIteration`, extraiga 3 valores de la pila y restaure el estado "
#~ "de excepción utilizando el segundo de ellos. De lo contrario, vuelva a "
#~ "generar la excepción utilizando el valor de la pila. Un bloque del "
#~ "controlador de excepciones se elimina de la pila de bloques."

#~ msgid ""
#~ "Implements the expression statement for the interactive mode.  TOS is "
#~ "removed from the stack and printed.  In non-interactive mode, an "
#~ "expression statement is terminated with :opcode:`POP_TOP`."
#~ msgstr ""
#~ "Implementa la declaración de expresión para el modo interactivo. TOS se "
#~ "elimina de la pila y se imprime. En modo no interactivo, una declaración "
#~ "de expresión termina con :opcode:`POP_TOP`."

#~ msgid ""
#~ "Calls ``dict.__setitem__(TOS1[-i], TOS1, TOS)``.  Used to implement dict "
#~ "comprehensions."
#~ msgstr ""
#~ "Llama a ``dict.__setitem__(TOS1[-i], TOS1, TOS)``. Se utiliza para "
#~ "implementar comprensiones de diccionarios."

#~ msgid ""
#~ "Loads all symbols not starting with ``'_'`` directly from the module TOS "
#~ "to the local namespace. The module is popped after loading all names. "
#~ "This opcode implements ``from module import *``."
#~ msgstr ""
#~ "Carga todos los símbolos que no comienzan con ``'_'`` directamente desde "
#~ "el TOS del módulo al espacio de nombres local. El módulo se desapila "
#~ "después de cargar todos los nombres. Este opcode implementa ``from module "
#~ "import *``."

#~ msgid ""
#~ "Combines the raised and reraised exceptions list from TOS, into an "
#~ "exception group to propagate from a try-except* block. Uses the original "
#~ "exception group from TOS1 to reconstruct the structure of reraised "
#~ "exceptions. Pops two items from the stack and pushes the exception to "
#~ "reraise or ``None`` if there isn't one."
#~ msgstr ""
#~ "Combina la lista de excepciones generadas y re-elevadas de TOS en un "
#~ "grupo de excepciones para propagar desde un bloque try-except*. Utiliza "
#~ "el grupo de excepción original de TOS1 para reconstruir la estructura de "
#~ "las excepciones replanteadas. Saca dos elementos de la pila y agrega la "
#~ "excepción a relanzar o ``None`` si no hay una."

#~ msgid "Push ``len(TOS)`` onto the stack."
#~ msgstr "Apila ``len(TOS)`` en la pila."

#~ msgid ""
#~ "The low byte of *counts* is the number of values before the list value, "
#~ "the high byte of *counts* the number of values after it.  The resulting "
#~ "values are put onto the stack right-to-left."
#~ msgstr ""
#~ "El byte bajo de *count* es el número de valores antes del valor de la "
#~ "lista, el byte alto de *count* es el número de valores después de él. Los "
#~ "valores resultantes se colocan en la pila de derecha a izquierda."

#~ msgid ""
#~ "Implements ``TOS.name = TOS1``, where *namei* is the index of name in :"
#~ "attr:`co_names`."
#~ msgstr ""
#~ "Implementa ``TOS.name = TOS1``, donde *namei* es el índice del nombre en :"
#~ "attr:`co_names`."

#~ msgid ""
#~ "Implements ``del TOS.name``, using *namei* as index into :attr:`co_names`."
#~ msgstr ""
#~ "Implementa ``del TOS.name``, usando *namei* como índice en :attr:"
#~ "`co_names`."

#~ msgid ""
#~ "Pops a list from the stack and pushes a tuple containing the same values."
#~ msgstr ""
#~ "Saca una lista de la pila y empuja una tupla que contiene los mismos "
#~ "valores."

#~ msgid "Calls ``list.extend(TOS1[-i], TOS)``.  Used to build lists."
#~ msgstr ""
#~ "Llama a ``list.extend(TOS1[-i], TOS)``. Se utiliza para crear listas."

#~ msgid "Calls ``set.update(TOS1[-i], TOS)``.  Used to build sets."
#~ msgstr ""
#~ "Llama a ``set.update(TOS1[-i], TOS)``. Se usa para construir decorados."

#~ msgid "Calls ``dict.update(TOS1[-i], TOS)``.  Used to build dicts."
#~ msgstr ""
#~ "Llama a ``dict.update(TOS1[-i], TOS)``. Se usa para construir dictados."

#~ msgid "Replaces TOS with ``getattr(TOS, co_names[namei])``."
#~ msgstr "Reemplaza TOS con ``getattr(TOS, co_names[namei])``."

#~ msgid ""
#~ "If TOS is true, decrements the bytecode counter by *delta*.  TOS is "
#~ "popped."
#~ msgstr ""
#~ "Si TOS es verdadero, decrementa el contador de bytecode en *delta*. TOS "
#~ "es retirado."

#~ msgid ""
#~ "If TOS is false, decrements the bytecode counter by *delta*.  TOS is "
#~ "popped."
#~ msgstr ""
#~ "Si TOS es falso, decrementa el contador de bytecode en *delta*. TOS es "
#~ "retirado."

#~ msgid ""
#~ "If TOS is not ``None``, decrements the bytecode counter by *delta*.  TOS "
#~ "is popped."
#~ msgstr ""
#~ "Si TOS no es ``None``, decrementa el contador de bytecode en *delta*. TOS "
#~ "es retirado."

#~ msgid ""
#~ "If TOS is ``None``, decrements the bytecode counter by *delta*.  TOS is "
#~ "popped."
#~ msgstr ""
#~ "Si TOS es ``None``, decrementa el contador de bytecode en *delta*. TOS es "
#~ "retirado."

#~ msgid ""
#~ "If TOS is true, increments the bytecode counter by *delta* and leaves TOS "
#~ "on the stack.  Otherwise (TOS is false), TOS is popped."
#~ msgstr ""
#~ "Si TOS es verdadero, incrementa el contador de bytecode en *delta* y deja "
#~ "TOS en la pila. De lo contrario (TOS es falso), TOS es retirado."

#~ msgid "The oparg is now a relative delta rather than an absolute target."
#~ msgstr ""
#~ "El oparg es ahora un delta relativo en lugar de un objetivo absoluto."

#~ msgid ""
#~ "If TOS is false, increments the bytecode counter by *delta* and leaves "
#~ "TOS on the stack.  Otherwise (TOS is true), TOS is popped."
#~ msgstr ""
#~ "Si TOS es falso, incrementa el contador de bytecode en *delta* y deja TOS "
#~ "en la pila. De lo contrario (TOS es verdadero), TOS es retirado."

#~ msgid ""
#~ "Much like :opcode:`LOAD_DEREF` but first checks the locals dictionary "
#~ "before consulting the cell.  This is used for loading free variables in "
#~ "class bodies."
#~ msgstr ""
#~ "Al igual que :opcode:`LOAD_DEREF` pero primero verifica el diccionario "
#~ "local antes de consultar la celda. Esto se usa para cargar variables "
#~ "libres en los cuerpos de clase."

#~ msgid ""
#~ "Prefixes :opcode:`CALL`. Logically this is a no op. It exists to enable "
#~ "effective specialization of calls. ``argc`` is the number of arguments as "
#~ "described in :opcode:`CALL`."
#~ msgstr ""
#~ "Prefijos :opcode:`CALL`. Lógicamente esto es un no op. Existe para "
#~ "permitir una especialización efectiva de las llamadas. ``argc`` es el "
#~ "número de argumentos como se describe en :opcode:`CALL`."

#~ msgid "the :term:`qualified name` of the function (at TOS)"
#~ msgstr "el :term:`nombre calificado` de la función (en TOS)"

#~ msgid ""
#~ "Pushes a slice object on the stack.  *argc* must be 2 or 3.  If it is 2, "
#~ "``slice(TOS1, TOS)`` is pushed; if it is 3, ``slice(TOS2, TOS1, TOS)`` is "
#~ "pushed. See the :func:`slice` built-in function for more information."
#~ msgstr ""
#~ "Apila un objeto de rebanada en la pila. *argc* debe ser 2 o 3. Si es 2, "
#~ "se apila ``slice(TOS1, TOS)``; si es 3, se apila ``slice(TOS2, TOS1, "
#~ "TOS)``. Consulte la función incorporada :func:`slice` para obtener más "
#~ "información."

#~ msgid "``0`` The start of a function"
#~ msgstr "``0`` El comienzo de una función"

#~ msgid ""
#~ "Sends ``None`` to the sub-generator of this generator. Used in ``yield "
#~ "from`` and ``await`` statements."
#~ msgstr ""
#~ "Envía ``None`` al subgenerador de este generador. Se utiliza en "
#~ "sentencias ``yield from`` y ``await``."

#~ msgid ""
#~ "Wraps the value on top of the stack in an "
#~ "``async_generator_wrapped_value``. Used to yield in async generators."
#~ msgstr ""
#~ "Envuelve el valor en la parte superior de la pila en un "
#~ "``async_generator_wrapped_value``. Se utiliza para producir en "
#~ "generadores asíncronos."
