# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To:\n"
"POT-Creation-Date: 2020-05-05 12:54+0200\n"
"PO-Revision-Date: 2020-06-01 08:26-0400\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: @Jighdan\n"
"Language: es\n"
"X-Generator: Poedit 2.3.1\n"
"X-Poedit-Bookmarks: -1,121,-1,-1,-1,-1,-1,-1,-1,-1\n"

#: ../Doc/reference/import.rst:6
msgid "The import system"
msgstr "El sistema de importación"

#: ../Doc/reference/import.rst:10
msgid ""
"Python code in one :term:`module` gains access to the code in another module "
"by the process of :term:`importing` it.  The :keyword:`import` statement is "
"the most common way of invoking the import machinery, but it is not the only "
"way.  Functions such as :func:`importlib.import_module` and built-in :func:"
"`__import__` can also be used to invoke the import machinery."
msgstr ""
"El código Python en un :term:`módulo <module>` obtiene acceso al código en "
"otro módulo por el proceso de :term:`importarlo <importing>`.  La "
"instrucción :keyword:`import` es la forma más común de invocar la maquinaria "
"de importación, pero no es la única manera.  Funciones como :func:`importlib."
"import_module` y built-in :func:`__import__` también se pueden utilizar para "
"invocar la maquinaria de importación."

#: ../Doc/reference/import.rst:16
msgid ""
"The :keyword:`import` statement combines two operations; it searches for the "
"named module, then it binds the results of that search to a name in the "
"local scope.  The search operation of the :keyword:`!import` statement is "
"defined as a call to the :func:`__import__` function, with the appropriate "
"arguments. The return value of :func:`__import__` is used to perform the "
"name binding operation of the :keyword:`!import` statement.  See the :"
"keyword:`!import` statement for the exact details of that name binding "
"operation."
msgstr ""
"La instrucción :keyword:`import` combina dos operaciones; busca el módulo "
"con nombre y, a continuación, enlaza los resultados de esa búsqueda a un "
"nombre en el ámbito local.  La operación de búsqueda de la instrucción :"
"keyword:`!import` se define como una llamada a la función :func:"
"`__import__`, con los argumentos adecuados. El valor retornado de :func:"
"`__import__` se utiliza para realizar la operación de enlace de nombre de la "
"instrucción :keyword:`!import`.  Consulte la instrucción :keyword:`!import` "
"para obtener los detalles exactos de esa operación de enlace de nombres."

#: ../Doc/reference/import.rst:25
msgid ""
"A direct call to :func:`__import__` performs only the module search and, if "
"found, the module creation operation.  While certain side-effects may occur, "
"such as the importing of parent packages, and the updating of various caches "
"(including :data:`sys.modules`), only the :keyword:`import` statement "
"performs a name binding operation."
msgstr ""
"Una llamada directa a :func:`__import__` realiza solo la búsqueda del módulo "
"y, si se encuentra, la operación de creación del módulo.  Aunque pueden "
"producirse ciertos efectos secundarios, como la importación de paquetes "
"primarios y la actualización de varias memorias caché (incluidas :data:`sys."
"modules`), solo la instrucción :keyword:`import` realiza una operación de "
"enlace de nombres."

#: ../Doc/reference/import.rst:31
msgid ""
"When an :keyword:`import` statement is executed, the standard builtin :func:"
"`__import__` function is called. Other mechanisms for invoking the import "
"system (such as :func:`importlib.import_module`) may choose to bypass :func:"
"`__import__` and use their own solutions to implement import semantics."
msgstr ""
"Cuando se ejecuta una instrucción :keyword:`import`, se llama a la función "
"estándar incorporada :func:`__import__`. Otros mecanismos para invocar el "
"sistema de importación (como :func:`importlib.import_module`) pueden optar "
"por omitir :func:`__import__` y utilizar sus propias soluciones para "
"implementar la semántica de importación."

#: ../Doc/reference/import.rst:36
msgid ""
"When a module is first imported, Python searches for the module and if "
"found, it creates a module object [#fnmo]_, initializing it.  If the named "
"module cannot be found, a :exc:`ModuleNotFoundError` is raised.  Python "
"implements various strategies to search for the named module when the import "
"machinery is invoked.  These strategies can be modified and extended by "
"using various hooks described in the sections below."
msgstr ""
"Cuando se importa un módulo por primera vez, Python busca el módulo y, si se "
"encuentra, crea un objeto de módulo [#fnmo]_, inicializándolo.  Si no se "
"encuentra el módulo con nombre, se genera un :exc:`ModuleNotFoundError`.  "
"Python implementa varias estrategias para buscar el módulo con nombre cuando "
"se invoca la maquinaria de importación.  Estas estrategias se pueden "
"modificar y ampliar mediante el uso de varios ganchos descritos en las "
"secciones siguientes."

#: ../Doc/reference/import.rst:43
msgid ""
"The import system has been updated to fully implement the second phase of :"
"pep:`302`. There is no longer any implicit import machinery - the full "
"import system is exposed through :data:`sys.meta_path`. In addition, native "
"namespace package support has been implemented (see :pep:`420`)."
msgstr ""
"El sistema de importación se ha actualizado para aplicar plenamente la "
"segunda fase de :pep:`302`. Ya no hay ninguna maquinaria de importación "
"implícita: todo el sistema de importación se expone a través de :data:`sys."
"meta_path`. Además, se ha implementado la compatibilidad con paquetes de "
"espacio de nombres nativos (consulte :pep:`420`)."

#: ../Doc/reference/import.rst:51
msgid ":mod:`importlib`"
msgstr ":mod:`importlib`"

#: ../Doc/reference/import.rst:53
msgid ""
"The :mod:`importlib` module provides a rich API for interacting with the "
"import system.  For example :func:`importlib.import_module` provides a "
"recommended, simpler API than built-in :func:`__import__` for invoking the "
"import machinery.  Refer to the :mod:`importlib` library documentation for "
"additional detail."
msgstr ""
"El módulo :mod:`importlib` proporciona una API enriquecida para interactuar "
"con el sistema de importación.  Por ejemplo :func:`importlib.import_module` "
"proporciona una API recomendada y más sencilla que la integrada :func:"
"`__import__` para invocar la maquinaria de importación.  Consulte la "
"documentación de la biblioteca :mod:`importlib` para obtener más detalles."

#: ../Doc/reference/import.rst:62
msgid "Packages"
msgstr "Paquetes"

#: ../Doc/reference/import.rst:67
msgid ""
"Python has only one type of module object, and all modules are of this type, "
"regardless of whether the module is implemented in Python, C, or something "
"else.  To help organize modules and provide a naming hierarchy, Python has a "
"concept of :term:`packages <package>`."
msgstr ""
"Python sólo tiene un tipo de objeto módulo, y todos los módulos son de este "
"tipo, independientemente de si el módulo está implementado en Python, C, o "
"en cualquier otro lenguage.  Para ayudar a organizar los módulos y "
"proporcionar una jerarquía de nombres, Python tiene un concepto de :term:"
"`paquete <package>`."

#: ../Doc/reference/import.rst:72
msgid ""
"You can think of packages as the directories on a file system and modules as "
"files within directories, but don't take this analogy too literally since "
"packages and modules need not originate from the file system.  For the "
"purposes of this documentation, we'll use this convenient analogy of "
"directories and files.  Like file system directories, packages are organized "
"hierarchically, and packages may themselves contain subpackages, as well as "
"regular modules."
msgstr ""
"Puedes pensar en los paquetes como los directorios de un sistema de archivos "
"y en los módulos como archivos dentro de los directorios, pero no te tomes "
"esta analogía demasiado literalmente, ya que los paquetes y los módulos no "
"tienen por qué originarse en el sistema de archivos.  Para los propósitos de "
"esta documentación, usaremos esta conveniente analogía de directorios y "
"archivos.  Al igual que los directorios del sistema de archivos, los "
"paquetes están organizados jerárquicamente, y los paquetes pueden contener "
"subpaquetes, así como módulos regulares."

#: ../Doc/reference/import.rst:80
msgid ""
"It's important to keep in mind that all packages are modules, but not all "
"modules are packages.  Or put another way, packages are just a special kind "
"of module.  Specifically, any module that contains a ``__path__`` attribute "
"is considered a package."
msgstr ""
"Es importante tener en cuenta que todos los paquetes son módulos, pero no "
"todos los módulos son paquetes.  O dicho de otro modo, los paquetes son sólo "
"un tipo especial de módulo.  Específicamente, cualquier módulo que contenga "
"un atributo ``__path__`` se considera un paquete."

#: ../Doc/reference/import.rst:85
msgid ""
"All modules have a name.  Subpackage names are separated from their parent "
"package name by dots, akin to Python's standard attribute access syntax.  "
"Thus you might have a module called :mod:`sys` and a package called :mod:"
"`email`, which in turn has a subpackage called :mod:`email.mime` and a "
"module within that subpackage called :mod:`email.mime.text`."
msgstr ""
"Todos los módulos tienen un nombre.  Los nombres de los subpaquetes se "
"separan del nombre del paquete padre por puntos, similar a la sintaxis de "
"acceso a atributos estándar de Python.  Así, puedes tener un módulo llamado :"
"mod:`sys` y un paquete llamado :mod:`email`, que a su vez tiene un "
"subpaquete llamado :mod:`email.mime` y un módulo dentro de ese subpaquete "
"llamado :mod:`email.mime.text`."

#: ../Doc/reference/import.rst:93
msgid "Regular packages"
msgstr "Paquetes regulares"

#: ../Doc/reference/import.rst:98
msgid ""
"Python defines two types of packages, :term:`regular packages <regular "
"package>` and :term:`namespace packages <namespace package>`.  Regular "
"packages are traditional packages as they existed in Python 3.2 and earlier. "
"A regular package is typically implemented as a directory containing an "
"``__init__.py`` file.  When a regular package is imported, this ``__init__."
"py`` file is implicitly executed, and the objects it defines are bound to "
"names in the package's namespace.  The ``__init__.py`` file can contain the "
"same Python code that any other module can contain, and Python will add some "
"additional attributes to the module when it is imported."
msgstr ""
"Python define dos tipos de paquetes, :term:`paquetes regulares <regular "
"package>` y :term:`paquetes de espacio de nombres <namespace package>`.  Los "
"paquetes regulares son los paquetes tradicionales tal y como existían en "
"Python 3.2 y anteriores. Un paquete regular se implementa típicamente como "
"un directorio que contiene un archivo ``init__.py``.  Cuando se importa un "
"paquete regular, este archivo ``__init__.py`` se ejecuta implícitamente, y "
"los objetos que define están vinculados a nombres en el espacio de nombres "
"del paquete.  El archivo ``__init__.py`` puede contener el mismo código "
"Python que puede contener cualquier otro módulo, y Python añadirá algunos "
"atributos adicionales al módulo cuando se importe."

#: ../Doc/reference/import.rst:108
msgid ""
"For example, the following file system layout defines a top level ``parent`` "
"package with three subpackages::"
msgstr ""
"Por ejemplo, la siguiente disposición del sistema de archivos define un "
"paquete ``parent`` de nivel superior con tres subpaquetes::"

#: ../Doc/reference/import.rst:120
msgid ""
"Importing ``parent.one`` will implicitly execute ``parent/__init__.py`` and "
"``parent/one/__init__.py``.  Subsequent imports of ``parent.two`` or "
"``parent.three`` will execute ``parent/two/__init__.py`` and ``parent/three/"
"__init__.py`` respectively."
msgstr ""
"Importando ``parent.one`` se ejecutará implícitamente ``parent/__init__.py`` "
"y ``parent/one/__init__.py``.  La importación posterior de ``parent.two`` o "
"``parent.three`` ejecutará ``parent/two/__init__.py`` y ``parent/three/"
"__init__.py`` respectivamente."

#: ../Doc/reference/import.rst:127
msgid "Namespace packages"
msgstr "Paquetes de espacio de nombres"

#: ../Doc/reference/import.rst:133
msgid ""
"A namespace package is a composite of various :term:`portions <portion>`, "
"where each portion contributes a subpackage to the parent package.  Portions "
"may reside in different locations on the file system.  Portions may also be "
"found in zip files, on the network, or anywhere else that Python searches "
"during import.  Namespace packages may or may not correspond directly to "
"objects on the file system; they may be virtual modules that have no "
"concrete representation."
msgstr ""
"Un paquete de espacio de nombres es un compuesto de varias :term:`porciones "
"<portion>`, donde cada porción contribuye con un subpaquete al paquete "
"padre.  Las porciones pueden residir en diferentes lugares del sistema de "
"archivos.  Las porciones también pueden encontrarse en archivos zip, en la "
"red, o en cualquier otro lugar que Python busque durante la importación.  "
"Los paquetes de espacios de nombres pueden corresponder o no directamente a "
"objetos del sistema de archivos; pueden ser módulos virtuales que no tienen "
"una representación concreta."

#: ../Doc/reference/import.rst:141
msgid ""
"Namespace packages do not use an ordinary list for their ``__path__`` "
"attribute. They instead use a custom iterable type which will automatically "
"perform a new search for package portions on the next import attempt within "
"that package if the path of their parent package (or :data:`sys.path` for a "
"top level package) changes."
msgstr ""
"Los paquetes de espacios de nombres no usan una lista ordinaria para su "
"atributo ``__path__``. En su lugar utilizan un tipo iterable personalizado "
"que realizará automáticamente una nueva búsqueda de porciones de paquete en "
"el siguiente intento de importación dentro de ese paquete si la ruta de su "
"paquete padre (o :data:`sys.path`` para un paquete de nivel superior) cambia."

#: ../Doc/reference/import.rst:147
msgid ""
"With namespace packages, there is no ``parent/__init__.py`` file.  In fact, "
"there may be multiple ``parent`` directories found during import search, "
"where each one is provided by a different portion.  Thus ``parent/one`` may "
"not be physically located next to ``parent/two``.  In this case, Python will "
"create a namespace package for the top-level ``parent`` package whenever it "
"or one of its subpackages is imported."
msgstr ""
"Con los paquetes de espacio de nombres, no hay ningún archivo ``parent/"
"__init__.py``.  De hecho, puede haber varios directorios ``padre`` "
"encontrados durante la búsqueda de importación, donde cada uno de ellos es "
"proporcionado por una parte diferente.  Por lo tanto, ``padre/one`` no puede "
"estar físicamente situado junto a ``padre/two``.  En este caso, Python "
"creará un paquete de espacio de nombres para el paquete ``parent`` de nivel "
"superior siempre que se importe él o uno de sus subpaquetes."

#: ../Doc/reference/import.rst:154
msgid "See also :pep:`420` for the namespace package specification."
msgstr ""
"Consulte también :pep:`420` para conocer la especificación del paquete de "
"espacio de nombres."

#: ../Doc/reference/import.rst:158
msgid "Searching"
msgstr "Buscando"

#: ../Doc/reference/import.rst:160
msgid ""
"To begin the search, Python needs the :term:`fully qualified <qualified "
"name>` name of the module (or package, but for the purposes of this "
"discussion, the difference is immaterial) being imported.  This name may "
"come from various arguments to the :keyword:`import` statement, or from the "
"parameters to the :func:`importlib.import_module` or :func:`__import__` "
"functions."
msgstr ""
"Para comenzar la búsqueda, Python necesita el nombre :term:`totalmente "
"calificado <qualified name>` del módulo (o paquete, pero para los fines de "
"esta discusión, la diferencia es irrelevante) que se está importando.  Este "
"nombre puede provenir de varios argumentos a la instrucción :keyword:"
"`import`, o de los parámetros de las funciones :func:`importlib."
"import_module` o :func:`__import__`."

#: ../Doc/reference/import.rst:166
msgid ""
"This name will be used in various phases of the import search, and it may be "
"the dotted path to a submodule, e.g. ``foo.bar.baz``.  In this case, Python "
"first tries to import ``foo``, then ``foo.bar``, and finally ``foo.bar."
"baz``. If any of the intermediate imports fail, a :exc:`ModuleNotFoundError` "
"is raised."
msgstr ""
"Este nombre se utilizará en varias fases de la búsqueda de importación, y "
"puede ser la ruta de acceso punteada a un submódulo, por ejemplo, ``foo.bar."
"baz``.  En este caso, Python primero intenta importar ``foo``, luego ``foo."
"bar``, y finalmente ``foo.bar.baz``. Si se produce un error en cualquiera de "
"las importaciones intermedias, se genera un :exc:`ModuleNotFoundError`."

#: ../Doc/reference/import.rst:173
msgid "The module cache"
msgstr "La caché del módulo"

#: ../Doc/reference/import.rst:178
msgid ""
"The first place checked during import search is :data:`sys.modules`.  This "
"mapping serves as a cache of all modules that have been previously imported, "
"including the intermediate paths.  So if ``foo.bar.baz`` was previously "
"imported, :data:`sys.modules` will contain entries for ``foo``, ``foo.bar``, "
"and ``foo.bar.baz``.  Each key will have as its value the corresponding "
"module object."
msgstr ""
"El primer lugar comprobado durante la búsqueda de importación es :data:`sys."
"modules`.  Esta asignación sirve como caché de todos los módulos que se han "
"importado previamente, incluidas las rutas intermedias.  Por lo tanto, si "
"``foo.bar.baz`` se importó previamente, :data:`sys.modules` contendrá "
"entradas para ``foo``, ``foo.bar``, y ``foo.bar.baz``.  Cada clave tendrá "
"como valor el objeto de módulo correspondiente."

#: ../Doc/reference/import.rst:185
msgid ""
"During import, the module name is looked up in :data:`sys.modules` and if "
"present, the associated value is the module satisfying the import, and the "
"process completes.  However, if the value is ``None``, then a :exc:"
"`ModuleNotFoundError` is raised.  If the module name is missing, Python will "
"continue searching for the module."
msgstr ""
"Durante la importación, el nombre del módulo se busca en :data:`sys.modules` "
"y si está presente, el valor asociado es el módulo que satisface la "
"importación y el proceso se completa.  Sin embargo, si el valor es ``None``, "
"se genera un :exc:`ModuleNotFoundError`.  Si falta el nombre del módulo, "
"Python continuará buscando el módulo."

#: ../Doc/reference/import.rst:191
msgid ""
":data:`sys.modules` is writable.  Deleting a key may not destroy the "
"associated module (as other modules may hold references to it), but it will "
"invalidate the cache entry for the named module, causing Python to search "
"anew for the named module upon its next import. The key can also be assigned "
"to ``None``, forcing the next import of the module to result in a :exc:"
"`ModuleNotFoundError`."
msgstr ""
":data:`sys.modules` se puede escribir.  La eliminación de una clave no puede "
"destruir el módulo asociado (ya que otros módulos pueden contener "
"referencias a él), pero invalidará la entrada de caché para el módulo con "
"nombre, lo que hará que Python busque de nuevo el módulo con nombre en su "
"próxima importación. La clave también se puede asignar a ``None``, lo que "
"obliga a la siguiente importación del módulo a dar como resultado un :exc:"
"`ModuleNotFoundError`."

#: ../Doc/reference/import.rst:198
msgid ""
"Beware though, as if you keep a reference to the module object, invalidate "
"its cache entry in :data:`sys.modules`, and then re-import the named module, "
"the two module objects will *not* be the same. By contrast, :func:`importlib."
"reload` will reuse the *same* module object, and simply reinitialise the "
"module contents by rerunning the module's code."
msgstr ""
"Tenga cuidado, sin embargo, como si mantiene una referencia al objeto "
"module, invalide su entrada de caché en :data:`sys.modules` y, a "
"continuación, vuelva a importar el módulo con nombre, los dos objetos de "
"módulo *no* serán los mismos. Por el contrario, :func:`importlib.reload` "
"reutilizará el objeto de módulo *same* y simplemente reinicializará el "
"contenido del módulo volviendo a ejecutar el código del módulo."

#: ../Doc/reference/import.rst:206
msgid "Finders and loaders"
msgstr "Buscadores y cargadores"

#: ../Doc/reference/import.rst:213
msgid ""
"If the named module is not found in :data:`sys.modules`, then Python's "
"import protocol is invoked to find and load the module.  This protocol "
"consists of two conceptual objects, :term:`finders <finder>` and :term:"
"`loaders <loader>`. A finder's job is to determine whether it can find the "
"named module using whatever strategy it knows about. Objects that implement "
"both of these interfaces are referred to as :term:`importers <importer>` - "
"they return themselves when they find that they can load the requested "
"module."
msgstr ""
"Si el módulo con nombre no se encuentra en :data:`sys.modules`, se invoca el "
"protocolo de importación de Python para buscar y cargar el módulo.  Este "
"protocolo consta de dos objetos conceptuales, :term:`buscadores <finder>` y :"
"term:`cargadores <loader>`. El trabajo de un buscador es determinar si puede "
"encontrar el módulo con nombre utilizando cualquier estrategia que conozca. "
"Los objetos que implementan ambas interfaces se conocen como :term:"
"`importadores <importer>` se retornan a sí mismos cuando descubren que "
"pueden cargar el módulo solicitado."

#: ../Doc/reference/import.rst:221
msgid ""
"Python includes a number of default finders and importers.  The first one "
"knows how to locate built-in modules, and the second knows how to locate "
"frozen modules.  A third default finder searches an :term:`import path` for "
"modules.  The :term:`import path` is a list of locations that may name file "
"system paths or zip files.  It can also be extended to search for any "
"locatable resource, such as those identified by URLs."
msgstr ""
"Python incluye una serie de buscadores e importadores predeterminados.  El "
"primero sabe cómo localizar módulos integrados, y el segundo sabe cómo "
"localizar módulos congelados.  Un tercer buscador predeterminado busca "
"módulos en :term:`import path`.  El :term:`import path` es una lista de "
"ubicaciones que pueden nombrar rutas del sistema de archivos o archivos "
"zip.  También se puede ampliar para buscar cualquier recurso localizable, "
"como los identificados por las direcciones URL."

#: ../Doc/reference/import.rst:228
msgid ""
"The import machinery is extensible, so new finders can be added to extend "
"the range and scope of module searching."
msgstr ""
"La maquinaria de importación es extensible, por lo que se pueden añadir "
"nuevos buscadores para ampliar el alcance y el alcance de la búsqueda de "
"módulos."

#: ../Doc/reference/import.rst:231
msgid ""
"Finders do not actually load modules.  If they can find the named module, "
"they return a :dfn:`module spec`, an encapsulation of the module's import-"
"related information, which the import machinery then uses when loading the "
"module."
msgstr ""
"En realidad, los buscadores no cargan módulos.  Si pueden encontrar el "
"módulo con nombre, retornan un :dfn:`module spec`, una encapsulación de la "
"información relacionada con la importación del módulo, que la maquinaria de "
"importación utiliza al cargar el módulo."

#: ../Doc/reference/import.rst:235
msgid ""
"The following sections describe the protocol for finders and loaders in more "
"detail, including how you can create and register new ones to extend the "
"import machinery."
msgstr ""
"En las secciones siguientes se describe el protocolo para buscadores y "
"cargadores con más detalle, incluido cómo puede crear y registrar otros "
"nuevos para ampliar la maquinaria de importación."

#: ../Doc/reference/import.rst:239
msgid ""
"In previous versions of Python, finders returned :term:`loaders <loader>` "
"directly, whereas now they return module specs which *contain* loaders. "
"Loaders are still used during import but have fewer responsibilities."
msgstr ""
"En versiones anteriores de Python, los buscadores retornaban :term:"
"`cargadores <loader>` directamente, mientras que ahora retornen "
"especificaciones de módulo que *contienen* cargadores. Los cargadores "
"todavía se utilizan durante la importación, pero tienen menos "
"responsabilidades."

#: ../Doc/reference/import.rst:245
msgid "Import hooks"
msgstr "Ganchos de importación"

#: ../Doc/reference/import.rst:255
msgid ""
"The import machinery is designed to be extensible; the primary mechanism for "
"this are the *import hooks*.  There are two types of import hooks: *meta "
"hooks* and *import path hooks*."
msgstr ""
"La maquinaria de importación está diseñada para ser extensible; el mecanismo "
"principal para esto son los *ganchos de importación* (import hooks).  Hay "
"dos tipos de ganchos de importación: *meta hooks* (meta ganchos) y *import "
"path hooks* (ganchos de ruta de acceso de importación)."

#: ../Doc/reference/import.rst:259
msgid ""
"Meta hooks are called at the start of import processing, before any other "
"import processing has occurred, other than :data:`sys.modules` cache look "
"up. This allows meta hooks to override :data:`sys.path` processing, frozen "
"modules, or even built-in modules.  Meta hooks are registered by adding new "
"finder objects to :data:`sys.meta_path`, as described below."
msgstr ""
"Los meta ganchos se llaman al inicio del procesamiento de importación, antes "
"de que se haya producido cualquier otro procesamiento de importación, que no "
"sea búsqueda de caché de :data:`sys.modules`. Esto permite que los "
"metaganchos reemplacen el procesamiento de :data:`sys.path`, módulos "
"congelados o incluso módulos integrados.  Los meta ganchos se registran "
"agregando nuevos objetos de buscador a :data:`sys.meta_path`, como se "
"describe a continuación."

#: ../Doc/reference/import.rst:265
msgid ""
"Import path hooks are called as part of :data:`sys.path` (or ``package."
"__path__``) processing, at the point where their associated path item is "
"encountered.  Import path hooks are registered by adding new callables to :"
"data:`sys.path_hooks` as described below."
msgstr ""
"Los ganchos de ruta de acceso de importación se invocan como parte del "
"procesamiento :data:`sys.path` (o ``package.__path__``), en el punto donde "
"se encuentra su elemento de ruta de acceso asociado. Los ganchos de ruta de "
"acceso de importación se registran agregando nuevos invocables a :data:`sys."
"path_hooks` como se describe a continuación."

#: ../Doc/reference/import.rst:272
msgid "The meta path"
msgstr "La meta ruta (*path*)"

#: ../Doc/reference/import.rst:278
msgid ""
"When the named module is not found in :data:`sys.modules`, Python next "
"searches :data:`sys.meta_path`, which contains a list of meta path finder "
"objects.  These finders are queried in order to see if they know how to "
"handle the named module.  Meta path finders must implement a method called :"
"meth:`~importlib.abc.MetaPathFinder.find_spec()` which takes three "
"arguments: a name, an import path, and (optionally) a target module.  The "
"meta path finder can use any strategy it wants to determine whether it can "
"handle the named module or not."
msgstr ""
"Cuando el módulo con nombre no se encuentra en :data:`sys.modules`, Python "
"busca a continuación :data:`sys.meta_path`, que contiene una lista de "
"objetos buscadores de metarutas.  Estos buscadores se consultan para ver si "
"saben cómo manejar el módulo nombrado.  Los buscadores de rutas de meta "
"deben implementar un método llamado :meth:`~importlib.abc.MetaPathFinder."
"find_spec()` que toma tres argumentos: un nombre, una ruta de importación y "
"(opcionalmente) un módulo de destino.  El buscador de metarutas puede usar "
"cualquier estrategia que desee para determinar si puede manejar el módulo "
"con nombre o no."

#: ../Doc/reference/import.rst:287
msgid ""
"If the meta path finder knows how to handle the named module, it returns a "
"spec object.  If it cannot handle the named module, it returns ``None``.  "
"If :data:`sys.meta_path` processing reaches the end of its list without "
"returning a spec, then a :exc:`ModuleNotFoundError` is raised.  Any other "
"exceptions raised are simply propagated up, aborting the import process."
msgstr ""
"Si el buscador de metarutas sabe cómo controlar el módulo con nombre, "
"retorna un objeto de especificación.  Si no puede controlar el módulo con "
"nombre, retorna ``None``.  Si el procesamiento de :data:`sys.meta_path` "
"llega al final de su lista sin retornar una especificación, se genera un :"
"exc:`ModuleNotFoundError`.  Cualquier otra excepción provocada simplemente "
"se propaga hacia arriba, anulando el proceso de importación."

#: ../Doc/reference/import.rst:293
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec()` method of meta path "
"finders is called with two or three arguments.  The first is the fully "
"qualified name of the module being imported, for example ``foo.bar.baz``. "
"The second argument is the path entries to use for the module search.  For "
"top-level modules, the second argument is ``None``, but for submodules or "
"subpackages, the second argument is the value of the parent package's "
"``__path__`` attribute. If the appropriate ``__path__`` attribute cannot be "
"accessed, a :exc:`ModuleNotFoundError` is raised.  The third argument is an "
"existing module object that will be the target of loading later. The import "
"system passes in a target module only during reload."
msgstr ""
"El método de los buscadores de metarutas de :meth:`~importlib.abc."
"metapathFinder.find_spec()` se llama con dos o tres argumentos.  El primero "
"es el nombre completo del módulo que se está importando, por ejemplo ``foo."
"bar.baz``. El segundo argumento son las entradas de ruta de acceso que se "
"utilizarán para la búsqueda de módulos.  Para los módulos de nivel superior, "
"el segundo argumento es ``None``, pero para submódulos o subpaquetes, el "
"segundo argumento es el valor del atributo ``__path__`` del paquete "
"primario. Si no se puede tener acceso al atributo ``__path__`` adecuado, se "
"genera un :exc:`ModuleNotFoundError`.  El tercer argumento es un objeto de "
"módulo existente que será el destino de la carga más adelante. El sistema de "
"importación pasa un módulo de destino solo durante la recarga."

#: ../Doc/reference/import.rst:304
msgid ""
"The meta path may be traversed multiple times for a single import request. "
"For example, assuming none of the modules involved has already been cached, "
"importing ``foo.bar.baz`` will first perform a top level import, calling "
"``mpf.find_spec(\"foo\", None, None)`` on each meta path finder (``mpf``). "
"After ``foo`` has been imported, ``foo.bar`` will be imported by traversing "
"the meta path a second time, calling ``mpf.find_spec(\"foo.bar\", foo."
"__path__, None)``. Once ``foo.bar`` has been imported, the final traversal "
"will call ``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)``."
msgstr ""
"La metaruta se puede recorrer varias veces para una sola solicitud de "
"importación. Por ejemplo, suponiendo que ninguno de los módulos implicados "
"ya se haya almacenado en caché, la importación de ``foo.bar.baz`` realizará "
"primero una importación de nivel superior, llamando a ``mpf.find_spec(\"foo"
"\", None, None)`` en cada buscador de metarutas (``mpf``). Después de "
"importar ``foo`` , ``foo.bar`` se importará atravesando la meta ruta por "
"segunda vez, llamando a ``mpf.find_spec(\"foo.bar\", foo.__path__, None)``. "
"Una vez importado ``foo.bar``, el recorrido final llamará a ``mpf."
"find_spec(\"foo.bar.baz\", foo.bar.__path__, None)``."

#: ../Doc/reference/import.rst:314
msgid ""
"Some meta path finders only support top level imports. These importers will "
"always return ``None`` when anything other than ``None`` is passed as the "
"second argument."
msgstr ""
"Algunos buscadores de metarutas solo admiten importaciones de nivel "
"superior. Estos importadores siempre retornarán ``None`` cuando se pase algo "
"distinto de ``None`` como segundo argumento."

#: ../Doc/reference/import.rst:318
msgid ""
"Python's default :data:`sys.meta_path` has three meta path finders, one that "
"knows how to import built-in modules, one that knows how to import frozen "
"modules, and one that knows how to import modules from an :term:`import "
"path` (i.e. the :term:`path based finder`)."
msgstr ""
"El valor predeterminado de Python :data:`sys.meta_path` tiene tres "
"buscadores de metarutas, uno que sabe cómo importar módulos integrados, uno "
"que sabe cómo importar módulos congelados y otro que sabe cómo importar "
"módulos desde un :term:`import path` (es decir, el :term:`path based "
"finder`)."

#: ../Doc/reference/import.rst:323
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec` method of meta path "
"finders replaced :meth:`~importlib.abc.MetaPathFinder.find_module`, which is "
"now deprecated.  While it will continue to work without change, the import "
"machinery will try it only if the finder does not implement ``find_spec()``."
msgstr ""
"El método :meth:`~importlib.abc.MetaPathFinder.find_spec` de los buscadores "
"de metarutas de la ruta de acceso reemplazó :meth:`~importlib.abc."
"MetaPathFinder.find_module`, que ahora está en desuso. Aunque seguirá "
"funcionando sin cambios, la maquinaria de importación sólo lo intentará si "
"el buscador no implementa ``find_spec()``."

#: ../Doc/reference/import.rst:332
msgid "Loading"
msgstr "Cargando"

#: ../Doc/reference/import.rst:334
msgid ""
"If and when a module spec is found, the import machinery will use it (and "
"the loader it contains) when loading the module.  Here is an approximation "
"of what happens during the loading portion of import::"
msgstr ""
"Si se encuentra una especificación de módulo, la maquinaria de importación "
"la utilizará (y el cargador que contiene) al cargar el módulo.  Aquí está "
"una aproximación de lo que sucede durante la porción de carga de la "
"importación:"

#: ../Doc/reference/import.rst:368
msgid "Note the following details:"
msgstr "Tenga en cuenta los siguientes detalles:"

#: ../Doc/reference/import.rst:370
msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, import will have already returned it."
msgstr ""
"Si hay un objeto de módulo existente con el nombre dado en :data:`sys."
"modules`, la importación ya lo habrá retornado."

#: ../Doc/reference/import.rst:373
msgid ""
"The module will exist in :data:`sys.modules` before the loader executes the "
"module code.  This is crucial because the module code may (directly or "
"indirectly) import itself; adding it to :data:`sys.modules` beforehand "
"prevents unbounded recursion in the worst case and multiple loading in the "
"best."
msgstr ""
"El módulo existirá en :data:`sys.modules` antes de que el cargador ejecute "
"el código del módulo.  Esto es crucial porque el código del módulo puede "
"(directa o indirectamente) importarse a sí mismo; agregándolo a :data:`sys."
"modules` de antemano evita la recursividad sin límites en el peor de los "
"casos y la carga múltiple en el mejor."

#: ../Doc/reference/import.rst:379
msgid ""
"If loading fails, the failing module -- and only the failing module -- gets "
"removed from :data:`sys.modules`.  Any module already in the :data:`sys."
"modules` cache, and any module that was successfully loaded as a side-"
"effect, must remain in the cache.  This contrasts with reloading where even "
"the failing module is left in :data:`sys.modules`."
msgstr ""
"Si se produce un error en la carga, el módulo con errores -- y solo el "
"módulo con errores -- se elimina de :data:`sys.modules`.  Cualquier módulo "
"que ya esté en la caché de :data:`sys.modules` y cualquier módulo que se "
"haya cargado correctamente como efecto secundario, debe permanecer en la "
"memoria caché.  Esto contrasta con la recarga donde incluso el módulo que "
"falla se deja en :data:`sys.modules`."

#: ../Doc/reference/import.rst:385
msgid ""
"After the module is created but before execution, the import machinery sets "
"the import-related module attributes (\"_init_module_attrs\" in the pseudo-"
"code example above), as summarized in a :ref:`later section <import-mod-"
"attrs>`."
msgstr ""
"Después de crear el módulo pero antes de la ejecución, la maquinaria de "
"importación establece los atributos del módulo relacionados con la "
"importación (\"_init_module_attrs\" en el ejemplo de pseudocódigo anterior), "
"como se resume en una :ref:`sección posterior <import-mod-attrs>`."

#: ../Doc/reference/import.rst:390
msgid ""
"Module execution is the key moment of loading in which the module's "
"namespace gets populated.  Execution is entirely delegated to the loader, "
"which gets to decide what gets populated and how."
msgstr ""
"La ejecución del módulo es el momento clave de la carga en el que se rellena "
"el espacio de nombres del módulo.  La ejecución se delega por completo en el "
"cargador, lo que llega a decidir qué se rellena y cómo."

#: ../Doc/reference/import.rst:394
msgid ""
"The module created during loading and passed to exec_module() may not be the "
"one returned at the end of import [#fnlo]_."
msgstr ""
"El módulo creado durante la carga y pasado a exec_module() puede no ser el "
"que se retorna al final de la importación [#fnlo]_."

#: ../Doc/reference/import.rst:397
msgid ""
"The import system has taken over the boilerplate responsibilities of "
"loaders.  These were previously performed by the :meth:`importlib.abc.Loader."
"load_module` method."
msgstr ""
"El sistema de importación se ha hecho cargo de las responsabilidades "
"reutilizables de los cargadores.  Estos fueron realizados previamente por el "
"método :meth:`importlib.abc.Loader.load_module`."

#: ../Doc/reference/import.rst:403
msgid "Loaders"
msgstr "Cargadores"

#: ../Doc/reference/import.rst:405
msgid ""
"Module loaders provide the critical function of loading: module execution. "
"The import machinery calls the :meth:`importlib.abc.Loader.exec_module` "
"method with a single argument, the module object to execute.  Any value "
"returned from :meth:`~importlib.abc.Loader.exec_module` is ignored."
msgstr ""
"Los cargadores de módulos proporcionan la función crítica de carga: "
"ejecución del módulo. La maquinaria de importación llama al método :meth:"
"`importlib.abc.Loader.exec_module` con un único argumento, el objeto module "
"que se va a ejecutar.  Se omite cualquier valor retornado de :meth:"
"`~importlib.abc.Loader.exec_module`."

#: ../Doc/reference/import.rst:410
msgid "Loaders must satisfy the following requirements:"
msgstr "Los cargadores deben cumplir los siguientes requisitos:"

#: ../Doc/reference/import.rst:412
msgid ""
"If the module is a Python module (as opposed to a built-in module or a "
"dynamically loaded extension), the loader should execute the module's code "
"in the module's global name space (``module.__dict__``)."
msgstr ""
"Si el módulo es un módulo Python (a diferencia de un módulo integrado o una "
"extensión cargada dinámicamente), el cargador debe ejecutar el código del "
"módulo en el espacio de nombres global del módulo (``module.__dict__``)."

#: ../Doc/reference/import.rst:416
msgid ""
"If the loader cannot execute the module, it should raise an :exc:"
"`ImportError`, although any other exception raised during :meth:`~importlib."
"abc.Loader.exec_module` will be propagated."
msgstr ""
"Si el cargador no puede ejecutar el módulo, debe generar un :exc:"
"`ImportError`, aunque se propagará cualquier otra excepción provocada "
"durante :meth:`~importlib.abc.Loader.exec_module`."

#: ../Doc/reference/import.rst:420
msgid ""
"In many cases, the finder and loader can be the same object; in such cases "
"the :meth:`~importlib.abc.MetaPathFinder.find_spec` method would just return "
"a spec with the loader set to ``self``."
msgstr ""
"En muchos casos, el buscador y el cargador pueden ser el mismo objeto; en "
"tales casos, el método :meth:`~importlib.abc.MetaPathFinder.find_spec` "
"simplemente retornaría una especificación con el cargador establecido en "
"``self``."

#: ../Doc/reference/import.rst:424
msgid ""
"Module loaders may opt in to creating the module object during loading by "
"implementing a :meth:`~importlib.abc.Loader.create_module` method. It takes "
"one argument, the module spec, and returns the new module object to use "
"during loading.  ``create_module()`` does not need to set any attributes on "
"the module object.  If the method returns ``None``, the import machinery "
"will create the new module itself."
msgstr ""
"Los cargadores de módulos pueden optar por crear el objeto de módulo durante "
"la carga mediante la implementación de un método :meth:`~importlib.abc."
"Loader.create_module`. Toma un argumento, el module spec, y retorna el nuevo "
"objeto de módulo que se usará durante la carga.  ``create_module()`` no "
"necesita establecer ningún atributo en el objeto module.  Si el método "
"retorna ``None``, la maquinaria de importación creará el nuevo módulo en sí."

#: ../Doc/reference/import.rst:431
msgid "The :meth:`~importlib.abc.Loader.create_module` method of loaders."
msgstr "El método de cargadores :meth:`~importlib.abc.Loader.create_module`."

#: ../Doc/reference/import.rst:434
msgid ""
"The :meth:`~importlib.abc.Loader.load_module` method was replaced by :meth:"
"`~importlib.abc.Loader.exec_module` and the import machinery assumed all the "
"boilerplate responsibilities of loading."
msgstr ""
"El método :meth:`~importlib.abc.Loader.load_module` fue reemplazado por :"
"meth:`~importlib.abc.Loader.exec_module` y la maquinaria de importación "
"asumió todas las responsabilidades reutilizables de la carga."

#: ../Doc/reference/import.rst:439
msgid ""
"For compatibility with existing loaders, the import machinery will use the "
"``load_module()`` method of loaders if it exists and the loader does not "
"also implement ``exec_module()``.  However, ``load_module()`` has been "
"deprecated and loaders should implement ``exec_module()`` instead."
msgstr ""
"Para la compatibilidad con los cargadores existentes, la maquinaria de "
"importación utilizará el método de cargadores ``load_module()`` si existe y "
"el cargador no implementa también ``exec_module()``.  Sin embargo, "
"``load_module()`` ha quedado obsoleto y los cargadores deben implementar "
"``exec_module()`` en su lugar."

#: ../Doc/reference/import.rst:444
msgid ""
"The ``load_module()`` method must implement all the boilerplate loading "
"functionality described above in addition to executing the module.  All the "
"same constraints apply, with some additional clarification:"
msgstr ""
"El método ``load_module()`` debe implementar toda la funcionalidad de carga "
"reutilizable descrita anteriormente, además de ejecutar el módulo.  Se "
"aplican todas las mismas restricciones, con algunas aclaraciones adicionales:"

#: ../Doc/reference/import.rst:448
msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, the loader must use that existing module. (Otherwise, :func:"
"`importlib.reload` will not work correctly.)  If the named module does not "
"exist in :data:`sys.modules`, the loader must create a new module object and "
"add it to :data:`sys.modules`."
msgstr ""
"Si hay un objeto de módulo existente con el nombre dado en :data:`sys."
"modules`, el cargador debe utilizar ese módulo existente. (De lo contrario, :"
"func:`importlib.reload` no funcionará correctamente.)  Si el módulo con "
"nombre no existe en :data:`sys.modules`, el cargador debe crear un nuevo "
"objeto de módulo y agregarlo a :data:`sys.modules`."

#: ../Doc/reference/import.rst:454
msgid ""
"The module *must* exist in :data:`sys.modules` before the loader executes "
"the module code, to prevent unbounded recursion or multiple loading."
msgstr ""
"El módulo *debe* existir en :data:`sys.modules` antes de que el cargador "
"ejecute el código del módulo, para evitar la recursividad sin límites o la "
"carga múltiple."

#: ../Doc/reference/import.rst:458
msgid ""
"If loading fails, the loader must remove any modules it has inserted into :"
"data:`sys.modules`, but it must remove **only** the failing module(s), and "
"only if the loader itself has loaded the module(s) explicitly."
msgstr ""
"Si se produce un error en la carga, el cargador debe quitar los módulos que "
"ha insertado en :data:`sys.modules`, pero debe quitar **solo** los módulos "
"con errores, y solo si el propio cargador ha cargado los módulos "
"explícitamente."

#: ../Doc/reference/import.rst:463
msgid ""
"A :exc:`DeprecationWarning` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"A :exc:`DeprecationWarning` se genera cuando se define ``exec_module()`` "
"pero ``create_module()`` no lo es."

#: ../Doc/reference/import.rst:467
msgid ""
"An :exc:`ImportError` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"Un :exc:`ImportError` se genera cuando ``exec_module()`` está definido, pero "
"``create_module()`` no lo es."

#: ../Doc/reference/import.rst:472
msgid "Submodules"
msgstr "Sub-modulos"

#: ../Doc/reference/import.rst:474
msgid ""
"When a submodule is loaded using any mechanism (e.g. ``importlib`` APIs, the "
"``import`` or ``import-from`` statements, or built-in ``__import__()``) a "
"binding is placed in the parent module's namespace to the submodule object. "
"For example, if package ``spam`` has a submodule ``foo``, after importing "
"``spam.foo``, ``spam`` will have an attribute ``foo`` which is bound to the "
"submodule.  Let's say you have the following directory structure::"
msgstr ""
"Cuando se carga un submódulo mediante cualquier mecanismo (por ejemplo, API "
"``importlib``, las instrucciones ``import`` o ``import-from``, o "
"``__import__()``) integradas, se coloca un enlace en el espacio de nombres "
"del módulo primario al objeto submodule. Por ejemplo, si el paquete ``spam`` "
"tiene un submódulo ``foo``, después de importar ``spam.foo``, ``spam`` "
"tendrá un atributo ``foo`` que está enlazado al submódulo.  Supongamos que "
"tiene la siguiente estructura de directorios:"

#: ../Doc/reference/import.rst:486
msgid "and ``spam/__init__.py`` has the following lines in it::"
msgstr "y ``spam/__init__.py`` tiene las siguientes líneas::"

#: ../Doc/reference/import.rst:491
msgid ""
"then executing the following puts a name binding to ``foo`` and ``bar`` in "
"the ``spam`` module::"
msgstr ""
"a continuación, la ejecución de lo siguiente pone un nombre vinculante para "
"``foo`` y ``bar`` en el módulo ``spam``::"

#: ../Doc/reference/import.rst:500
msgid ""
"Given Python's familiar name binding rules this might seem surprising, but "
"it's actually a fundamental feature of the import system.  The invariant "
"holding is that if you have ``sys.modules['spam']`` and ``sys.modules['spam."
"foo']`` (as you would after the above import), the latter must appear as the "
"``foo`` attribute of the former."
msgstr ""
"Dadas las reglas de enlace de nombres familiares de Python, esto puede "
"parecer sorprendente, pero en realidad es una característica fundamental del "
"sistema de importación.  La retención invariable es que si tiene ``sys."
"modules[`spam`]`` y ``sys.modules[`spam.foo`]`` (como lo haría después de la "
"importación anterior), este último debe aparecer como el atributo ``foo`` de "
"la primera."

#: ../Doc/reference/import.rst:507
msgid "Module spec"
msgstr "Especificaciones del módulo"

#: ../Doc/reference/import.rst:509
msgid ""
"The import machinery uses a variety of information about each module during "
"import, especially before loading.  Most of the information is common to all "
"modules.  The purpose of a module's spec is to encapsulate this import-"
"related information on a per-module basis."
msgstr ""
"La maquinaria de importación utiliza una variedad de información sobre cada "
"módulo durante la importación, especialmente antes de la carga.  La mayor "
"parte de la información es común a todos los módulos.  El propósito de las "
"especificaciones de un módulo es encapsular esta información relacionada con "
"la importación por módulo."

#: ../Doc/reference/import.rst:514
msgid ""
"Using a spec during import allows state to be transferred between import "
"system components, e.g. between the finder that creates the module spec and "
"the loader that executes it.  Most importantly, it allows the import "
"machinery to perform the boilerplate operations of loading, whereas without "
"a module spec the loader had that responsibility."
msgstr ""
"El uso de una especificación durante la importación permite transferir el "
"estado entre los componentes del sistema de importación, por ejemplo, entre "
"el buscador que crea la especificación del módulo y el cargador que la "
"ejecuta.  Lo más importante es que permite a la maquinaria de importación "
"realizar las operaciones de caldera de carga, mientras que sin una "
"especificación de módulo el cargador tenía esa responsabilidad."

#: ../Doc/reference/import.rst:520
msgid ""
"The module's spec is exposed as the ``__spec__`` attribute on a module "
"object. See :class:`~importlib.machinery.ModuleSpec` for details on the "
"contents of the module spec."
msgstr ""
"La especificación del módulo se expone como el atributo ``__spec__`` en un "
"objeto de módulo. Consulte :class:`~importlib.machinery.ModuleSpec` para "
"obtener más información sobre el contenido de la especificación del módulo."

#: ../Doc/reference/import.rst:529
msgid "Import-related module attributes"
msgstr "Atributos de módulo relacionados con la importación"

#: ../Doc/reference/import.rst:531
msgid ""
"The import machinery fills in these attributes on each module object during "
"loading, based on the module's spec, before the loader executes the module."
msgstr ""
"La máquina de importación rellena estos atributos en cada objeto de módulo "
"durante la carga, en función de las especificaciones del módulo, antes de "
"que el cargador ejecute el módulo."

#: ../Doc/reference/import.rst:537
msgid ""
"The ``__name__`` attribute must be set to the fully-qualified name of the "
"module.  This name is used to uniquely identify the module in the import "
"system."
msgstr ""
"El atributo ``__name__`` debe establecerse en el nombre completo del "
"módulo.  Este nombre se utiliza para identificar de forma única el módulo en "
"el sistema de importación."

#: ../Doc/reference/import.rst:543
msgid ""
"The ``__loader__`` attribute must be set to the loader object that the "
"import machinery used when loading the module.  This is mostly for "
"introspection, but can be used for additional loader-specific functionality, "
"for example getting data associated with a loader."
msgstr ""
"El atributo ``__loader__`` debe establecerse en el objeto de cargador que "
"utilizó la máquina de importación al cargar el módulo.  Esto es "
"principalmente para la introspección, pero se puede utilizar para la "
"funcionalidad específica del cargador adicional, por ejemplo, obtener datos "
"asociados con un cargador."

#: ../Doc/reference/import.rst:550
msgid ""
"The module's ``__package__`` attribute must be set.  Its value must be a "
"string, but it can be the same value as its ``__name__``.  When the module "
"is a package, its ``__package__`` value should be set to its ``__name__``.  "
"When the module is not a package, ``__package__`` should be set to the empty "
"string for top-level modules, or for submodules, to the parent package's "
"name.  See :pep:`366` for further details."
msgstr ""
"Se debe establecer el atributo ``__package__`` del módulo.  Su valor debe "
"ser una cadena, pero puede ser el mismo valor que su ``__name__``.  Cuando "
"el módulo es un paquete, su valor ``__package__`` debe establecerse en su "
"``__name__``.  Cuando el módulo no es un paquete, ``__package__`` debe "
"establecerse en la cadena vacía para los módulos de nivel superior, o para "
"los submódulos, en el nombre del paquete primario.  Consulte :pep:`366` para "
"obtener más detalles."

#: ../Doc/reference/import.rst:558
msgid ""
"This attribute is used instead of ``__name__`` to calculate explicit "
"relative imports for main modules, as defined in :pep:`366`. It is expected "
"to have the same value as ``__spec__.parent``."
msgstr ""
"Este atributo se utiliza en lugar de ``__name__`` para calcular "
"importaciones relativas explícitas para los módulos principales, tal como se "
"define en :pep:`366`. Se espera que tenga el mismo valor que ``__spec__."
"parent``."

#: ../Doc/reference/import.rst:562
msgid ""
"The value of ``__package__`` is expected to be the same as ``__spec__."
"parent``."
msgstr ""
"Se espera que el valor de ``__package__`` sea el mismo que ``__spec__."
"parent``."

#: ../Doc/reference/import.rst:568
msgid ""
"The ``__spec__`` attribute must be set to the module spec that was used when "
"importing the module. Setting ``__spec__`` appropriately applies equally to :"
"ref:`modules initialized during interpreter startup <programs>`.  The one "
"exception is ``__main__``, where ``__spec__`` is :ref:`set to None in some "
"cases <main_spec>`."
msgstr ""
"El atributo ``__spec__`` debe establecerse en la especificación de módulo "
"que se utilizó al importar el módulo. Establecer ``__spec__`` se aplica "
"correctamente por igual a :ref:`módulos inicializados durante el inicio del "
"intérprete <programs>`.  La única excepción es ``__main__``, donde "
"``__spec__`` es :ref:`establecido None en algunos casos <main_spec>`."

#: ../Doc/reference/import.rst:574
msgid ""
"When ``__package__`` is not defined, ``__spec__.parent`` is used as a "
"fallback."
msgstr ""
"Cuando ``__package__`` no está definido, ``__spec__.parent`` se utiliza como "
"reserva."

#: ../Doc/reference/import.rst:579
msgid ""
"``__spec__.parent`` is used as a fallback when ``__package__`` is not "
"defined."
msgstr ""
"``__spec__.parent`` se utiliza como reserva cuando ``__package__``` no está "
"definido."

#: ../Doc/reference/import.rst:585
msgid ""
"If the module is a package (either regular or namespace), the module "
"object's ``__path__`` attribute must be set.  The value must be iterable, "
"but may be empty if ``__path__`` has no further significance. If "
"``__path__`` is not empty, it must produce strings when iterated over. More "
"details on the semantics of ``__path__`` are given :ref:`below <package-path-"
"rules>`."
msgstr ""
"Si el módulo es un paquete (normal o espacio de nombres), se debe establecer "
"el atributo ``__path__`` del objeto de módulo.  El valor debe ser iterable, "
"pero puede estar vacío si ``__path__`` no tiene más importancia. Si "
"``__path__`` no está vacío, debe producir cadenas cuando se itera. Más "
"detalles sobre la semántica de ``__path__`` se dan :ref:`below <package-path-"
"rules>`."

#: ../Doc/reference/import.rst:592
msgid "Non-package modules should not have a ``__path__`` attribute."
msgstr ""
"Los módulos que no son de paquete no deben tener un atributo ``__path__``."

#: ../Doc/reference/import.rst:597
msgid ""
"``__file__`` is optional. If set, this attribute's value must be a string.  "
"The import system may opt to leave ``__file__`` unset if it has no semantic "
"meaning (e.g. a module loaded from a database)."
msgstr ""
"``__file__`` es opcional. Si se establece, el valor de este atributo debe "
"ser una cadena.  El sistema de importación puede optar por dejar "
"``__file__`` sin establecer si no tiene un significado semántico (por "
"ejemplo, un módulo cargado desde una base de datos)."

#: ../Doc/reference/import.rst:601
msgid ""
"If ``__file__`` is set, it may also be appropriate to set the ``__cached__`` "
"attribute which is the path to any compiled version of the code (e.g. byte-"
"compiled file). The file does not need to exist to set this attribute; the "
"path can simply point to where the compiled file would exist (see :pep:"
"`3147`)."
msgstr ""
"Si se establece ``__file__``, también puede ser apropiado establecer el "
"atributo ``__cached__``, que es la ruta de acceso a cualquier versión "
"compilada del código (por ejemplo, archivo compilado por bytes). No es "
"necesario que exista el archivo para establecer este atributo; la ruta de "
"acceso puede simplemente apuntar a donde existiría el archivo compilado "
"(consulte :pep:`3147`)."

#: ../Doc/reference/import.rst:607
msgid ""
"It is also appropriate to set ``__cached__`` when ``__file__`` is not set.  "
"However, that scenario is quite atypical.  Ultimately, the loader is what "
"makes use of ``__file__`` and/or ``__cached__``.  So if a loader can load "
"from a cached module but otherwise does not load from a file, that atypical "
"scenario may be appropriate."
msgstr ""
"También es apropiado establecer ``__cached__`` cuando ``__file__`` no está "
"establecido.  Sin embargo, ese escenario es bastante atípico.  En última "
"instancia, el cargador es lo que hace uso de ``__file__`` y/o "
"``__cached__``.  Por lo tanto, si un cargador puede cargar desde un módulo "
"almacenado en caché pero no se carga desde un archivo, ese escenario atípico "
"puede ser adecuado."

#: ../Doc/reference/import.rst:616
msgid "module.__path__"
msgstr "module.__path__"

#: ../Doc/reference/import.rst:618
msgid ""
"By definition, if a module has a ``__path__`` attribute, it is a package."
msgstr ""
"Por definición, si un módulo tiene un atributo ``__path__``, es un paquete."

#: ../Doc/reference/import.rst:620
msgid ""
"A package's ``__path__`` attribute is used during imports of its "
"subpackages. Within the import machinery, it functions much the same as :"
"data:`sys.path`, i.e. providing a list of locations to search for modules "
"during import. However, ``__path__`` is typically much more constrained "
"than :data:`sys.path`."
msgstr ""
"El atributo ``__path__`` de un paquete se utiliza durante las importaciones "
"de sus subpaquetes. Dentro de la maquinaria de importación, funciona de la "
"misma manera que :data:`sys.path`, es decir, proporcionando una lista de "
"ubicaciones para buscar módulos durante la importación. Sin embargo, "
"``__path__`` suele estar mucho más restringido que :data:`sys.path`."

#: ../Doc/reference/import.rst:626
msgid ""
"``__path__`` must be an iterable of strings, but it may be empty. The same "
"rules used for :data:`sys.path` also apply to a package's ``__path__``, and :"
"data:`sys.path_hooks` (described below) are consulted when traversing a "
"package's ``__path__``."
msgstr ""
"``__path__`` debe ser un iterable de cadenas, pero puede estar vacío. Las "
"mismas reglas utilizadas para :data:`sys.path` también se aplican a la "
"``__path__`` de un paquete, y :data:`sys.path_hooks` (descrito a "
"continuación) se consultan al recorrer el ``__path__`` de un paquete."

#: ../Doc/reference/import.rst:631
msgid ""
"A package's ``__init__.py`` file may set or alter the package's ``__path__`` "
"attribute, and this was typically the way namespace packages were "
"implemented prior to :pep:`420`.  With the adoption of :pep:`420`, namespace "
"packages no longer need to supply ``__init__.py`` files containing only "
"``__path__`` manipulation code; the import machinery automatically sets "
"``__path__`` correctly for the namespace package."
msgstr ""
"El archivo ``__init__.py`` de un paquete puede establecer o modificar el "
"atributo ``__path__`` del paquete, y esta era normalmente la forma en que "
"los paquetes de espacio de nombres se implementaban antes de :pep:`420`.  "
"Con la adopción de :pep:`420`, los paquetes de espacio de nombres ya no "
"necesitan proporcionar archivos ``__init__.py`` que contienen solo el código "
"de manipulación ``__path__``; la máquina de importación establece "
"automáticamente ``__path__`` correctamente para el paquete de espacio de "
"nombres."

#: ../Doc/reference/import.rst:639
msgid "Module reprs"
msgstr "Representación (*Reprs*) de módulos"

#: ../Doc/reference/import.rst:641
msgid ""
"By default, all modules have a usable repr, however depending on the "
"attributes set above, and in the module's spec, you can more explicitly "
"control the repr of module objects."
msgstr ""
"De forma predeterminada, todos los módulos tienen un repr utilizable, sin "
"embargo, dependiendo de los atributos establecidos anteriormente, y en las "
"especificaciones del módulo, puede controlar más explícitamente el repr de "
"los objetos de módulo."

#: ../Doc/reference/import.rst:645
msgid ""
"If the module has a spec (``__spec__``), the import machinery will try to "
"generate a repr from it.  If that fails or there is no spec, the import "
"system will craft a default repr using whatever information is available on "
"the module.  It will try to use the ``module.__name__``, ``module."
"__file__``, and ``module.__loader__`` as input into the repr, with defaults "
"for whatever information is missing."
msgstr ""
"Si el módulo tiene una especificación (``__spec__``), la maquinaria de "
"importación intentará generar un repr a partir de él.  Si eso falla o no hay "
"ninguna especificación, el sistema de importación creará un repr "
"predeterminado usando cualquier información disponible en el módulo.  "
"Intentará utilizar el ``module.__name__``, ``module.__file__`` y ``module."
"__loader__`` como entrada en el repr, con valores predeterminados para "
"cualquier información que falte."

#: ../Doc/reference/import.rst:652
msgid "Here are the exact rules used:"
msgstr "Aquí están las reglas exactas utilizadas:"

#: ../Doc/reference/import.rst:654
msgid ""
"If the module has a ``__spec__`` attribute, the information in the spec is "
"used to generate the repr.  The \"name\", \"loader\", \"origin\", and "
"\"has_location\" attributes are consulted."
msgstr ""
"Si el módulo tiene un atributo ``__spec__``, la información de la "
"especificación se utiliza para generar el repr.  Se consultan los atributos "
"\"name\", \"loader\", \"origin\" y \"has_location\"."

#: ../Doc/reference/import.rst:658
msgid ""
"If the module has a ``__file__`` attribute, this is used as part of the "
"module's repr."
msgstr ""
"Si el módulo tiene un atributo ``__file__``, se utiliza como parte del repr "
"del módulo."

#: ../Doc/reference/import.rst:661
msgid ""
"If the module has no ``__file__`` but does have a ``__loader__`` that is not "
"``None``, then the loader's repr is used as part of the module's repr."
msgstr ""
"Si el módulo no tiene ``__file__`` pero tiene un ``__loader__`` que no es "
"``None``, entonces el repr del cargador se utiliza como parte del repr del "
"módulo."

#: ../Doc/reference/import.rst:664
msgid "Otherwise, just use the module's ``__name__`` in the repr."
msgstr ""
"De lo contrario, sólo tiene que utilizar el ``__name__`` del módulo en el "
"repr."

#: ../Doc/reference/import.rst:666
msgid ""
"Use of :meth:`loader.module_repr() <importlib.abc.Loader.module_repr>` has "
"been deprecated and the module spec is now used by the import machinery to "
"generate a module repr."
msgstr ""
"El uso de :meth:`loader.module_repr() <importlib.abc.Loader.module_repr>` ha "
"quedado obsoleto y la máquina de importación utiliza ahora la especificación "
"del módulo para generar un repr de módulo."

#: ../Doc/reference/import.rst:671
msgid ""
"For backward compatibility with Python 3.3, the module repr will be "
"generated by calling the loader's :meth:`~importlib.abc.Loader.module_repr` "
"method, if defined, before trying either approach described above.  However, "
"the method is deprecated."
msgstr ""
"Para la compatibilidad con versiones anteriores de Python 3.3, el repr del "
"módulo se generará llamando al método :meth:`~importlib.abc.Loader."
"module_repr` del cargador, si se define, antes de probar cualquiera de los "
"enfoques descritos anteriormente.  Sin embargo, el método está en desuso."

#: ../Doc/reference/import.rst:679
msgid "Cached bytecode invalidation"
msgstr "Invalidación del código de bytes en caché"

#: ../Doc/reference/import.rst:681
msgid ""
"Before Python loads cached bytecode from ``.pyc`` file, it checks whether "
"the cache is up-to-date with the source ``.py`` file. By default, Python "
"does this by storing the source's last-modified timestamp and size in the "
"cache file when writing it. At runtime, the import system then validates the "
"cache file by checking the stored metadata in the cache file against the "
"source's metadata."
msgstr ""
"Antes de que Python cargue el código de bytes almacenado en caché desde el "
"archivo ``.pyc``, comprueba si la memoria caché está actualizada con el "
"archivo de origen ``.py``. De forma predeterminada, Python lo hace "
"almacenando la última marca de tiempo y el tamaño modificados del origen en "
"el archivo de caché al escribirlo. En tiempo de ejecución, el sistema de "
"importación valida el archivo de caché comprobando los metadatos almacenados "
"en el archivo de caché con los metadatos del origen."

#: ../Doc/reference/import.rst:688
msgid ""
"Python also supports \"hash-based\" cache files, which store a hash of the "
"source file's contents rather than its metadata. There are two variants of "
"hash-based ``.pyc`` files: checked and unchecked. For checked hash-based ``."
"pyc`` files, Python validates the cache file by hashing the source file and "
"comparing the resulting hash with the hash in the cache file. If a checked "
"hash-based cache file is found to be invalid, Python regenerates it and "
"writes a new checked hash-based cache file. For unchecked hash-based ``."
"pyc`` files, Python simply assumes the cache file is valid if it exists. "
"Hash-based ``.pyc`` files validation behavior may be overridden with the :"
"option:`--check-hash-based-pycs` flag."
msgstr ""
"Python también admite archivos de caché \"basados en hash\", que almacenan "
"un hash del contenido del archivo de origen en lugar de sus metadatos. Hay "
"dos variantes de archivos ``.pyc` basados en hash: marcados y desmarcados. "
"Para los archivos ``.pyc`` marcados basados en hash, Python valida el "
"archivo de caché mediante el hash del archivo de origen y la comparación del "
"hash resultante con el hash en el archivo de caché. Si se encuentra que un "
"archivo de caché basado en hash comprobado no es válido, Python lo regenera "
"y escribe un nuevo archivo de caché basado en hash comprobado. Para los "
"archivos ``.pyc`` sin marcar en hash, Python simplemente asume que el "
"archivo de caché es válido si existe. El comportamiento de validación de "
"archivos basado en hash ``.pyc`` se puede invalidar con el indicador :option:"
"`--check-hash-based-pycs`."

#: ../Doc/reference/import.rst:699
msgid ""
"Added hash-based ``.pyc`` files. Previously, Python only supported timestamp-"
"based invalidation of bytecode caches."
msgstr ""
"Se han añadido archivos ``.pyc`` basados en hash. Anteriormente, Python solo "
"admitía la invalidación basada en la marca de tiempo de la caché del código "
"de bytes."

#: ../Doc/reference/import.rst:705
msgid "The Path Based Finder"
msgstr "El buscador basado en rutas"

#: ../Doc/reference/import.rst:710
msgid ""
"As mentioned previously, Python comes with several default meta path "
"finders. One of these, called the :term:`path based finder` (:class:"
"`~importlib.machinery.PathFinder`), searches an :term:`import path`, which "
"contains a list of :term:`path entries <path entry>`.  Each path entry names "
"a location to search for modules."
msgstr ""
"Como se mencionó anteriormente, Python viene con varios buscadores de meta "
"rutas predeterminados. Uno de ellos, llamado el buscador :term:`path based "
"finder` (:class:`~importlib.machinery.PathFinder`), busca una :term:`import "
"path`, que contiene una lista de :term:`entradas de ruta <path entry>`. Cada "
"entrada de ruta de acceso nombra una ubicación para buscar módulos."

#: ../Doc/reference/import.rst:716
msgid ""
"The path based finder itself doesn't know how to import anything. Instead, "
"it traverses the individual path entries, associating each of them with a "
"path entry finder that knows how to handle that particular kind of path."
msgstr ""
"El buscador basado en rutas en sí no sabe cómo importar nada. En su lugar, "
"atraviesa las entradas de ruta individuales, asociando cada una de ellas con "
"un buscador de entrada de ruta que sabe cómo manejar ese tipo particular de "
"ruta de acceso."

#: ../Doc/reference/import.rst:720
msgid ""
"The default set of path entry finders implement all the semantics for "
"finding modules on the file system, handling special file types such as "
"Python source code (``.py`` files), Python byte code (``.pyc`` files) and "
"shared libraries (e.g. ``.so`` files). When supported by the :mod:"
"`zipimport` module in the standard library, the default path entry finders "
"also handle loading all of these file types (other than shared libraries) "
"from zipfiles."
msgstr ""
"El conjunto predeterminado de buscadores de entradas de ruta implementa toda "
"la semántica para encontrar módulos en el sistema de archivos, controlando "
"tipos de archivos especiales como el código fuente de Python (archivos ```."
"py``), el código de bytes de Python (archivos ``.pyc``) y las bibliotecas "
"compartidas (por ejemplo, archivos ``.so```). Cuando es compatible con el "
"módulo :mod:`zipimport` en la biblioteca estándar, los buscadores de "
"entradas de ruta de acceso predeterminados también controlan la carga de "
"todos estos tipos de archivo (excepto las bibliotecas compartidas) desde "
"zipfiles."

#: ../Doc/reference/import.rst:727
msgid ""
"Path entries need not be limited to file system locations.  They can refer "
"to URLs, database queries, or any other location that can be specified as a "
"string."
msgstr ""
"Las entradas de ruta de acceso no deben limitarse a las ubicaciones del "
"sistema de archivos.  Pueden hacer referencia a direcciones URL, consultas "
"de base de datos o cualquier otra ubicación que se pueda especificar como "
"una cadena."

#: ../Doc/reference/import.rst:731
msgid ""
"The path based finder provides additional hooks and protocols so that you "
"can extend and customize the types of searchable path entries.  For example, "
"if you wanted to support path entries as network URLs, you could write a "
"hook that implements HTTP semantics to find modules on the web.  This hook "
"(a callable) would return a :term:`path entry finder` supporting the "
"protocol described below, which was then used to get a loader for the module "
"from the web."
msgstr ""
"El buscador basado en rutas proporciona enlaces y protocolos adicionales "
"para que pueda ampliar y personalizar los tipos de entradas de ruta de "
"acceso que se pueden buscar.  Por ejemplo, si desea admitir entradas de ruta "
"de acceso como direcciones URL de red, podría escribir un enlace que "
"implemente la semántica HTTP para buscar módulos en la web.  Este gancho (un "
"al que se puede llamar) retornaría un :term:`path entry finder` compatible "
"con el protocolo descrito a continuación, que luego se utilizó para obtener "
"un cargador para el módulo de la web."

#: ../Doc/reference/import.rst:739
msgid ""
"A word of warning: this section and the previous both use the term *finder*, "
"distinguishing between them by using the terms :term:`meta path finder` and :"
"term:`path entry finder`.  These two types of finders are very similar, "
"support similar protocols, and function in similar ways during the import "
"process, but it's important to keep in mind that they are subtly different. "
"In particular, meta path finders operate at the beginning of the import "
"process, as keyed off the :data:`sys.meta_path` traversal."
msgstr ""
"Una palabra de advertencia: esta sección y la anterior utilizan el término "
"*finder*, distinguiendo entre ellos utilizando los términos :term:`meta path "
"finder` y :term:`path entry finder`.  Estos dos tipos de buscadores son muy "
"similares, admiten protocolos similares y funcionan de maneras similares "
"durante el proceso de importación, pero es importante tener en cuenta que "
"son sutilmente diferentes. En particular, los buscadores de meta path operan "
"al principio del proceso de importación, como se indica en el recorrido :"
"data:`sys.meta_path`."

#: ../Doc/reference/import.rst:747
msgid ""
"By contrast, path entry finders are in a sense an implementation detail of "
"the path based finder, and in fact, if the path based finder were to be "
"removed from :data:`sys.meta_path`, none of the path entry finder semantics "
"would be invoked."
msgstr ""
"Por el contrario, los buscadores de entradas de ruta son en cierto sentido "
"un detalle de implementación del buscador basado en rutas y, de hecho, si el "
"buscador basado en rutas se eliminara de :data:`sys.meta_path`, no se "
"invocaría ninguna semántica del buscador de entradas de ruta."

#: ../Doc/reference/import.rst:754
msgid "Path entry finders"
msgstr "Buscadores de entradas de ruta"

#: ../Doc/reference/import.rst:762
msgid ""
"The :term:`path based finder` is responsible for finding and loading Python "
"modules and packages whose location is specified with a string :term:`path "
"entry`.  Most path entries name locations in the file system, but they need "
"not be limited to this."
msgstr ""
"El :term:`path based finder` es responsable de encontrar y cargar módulos y "
"paquetes de Python cuya ubicación se especifica con una cadena :term:`path "
"entry`.  La mayoría de las ubicaciones de nombres de entradas de ruta de "
"acceso en el sistema de archivos, pero no es necesario limitarlas a esto."

#: ../Doc/reference/import.rst:767
msgid ""
"As a meta path finder, the :term:`path based finder` implements the :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` protocol previously described, "
"however it exposes additional hooks that can be used to customize how "
"modules are found and loaded from the :term:`import path`."
msgstr ""
"Como buscador de meta rutas, el buscador :term:`path based finder` "
"implementa el protocolo :meth:`~importlib.abc.MetaPathFinder.find_spec` "
"descrito anteriormente, sin embargo, expone enlaces adicionales que se "
"pueden usar para personalizar cómo se encuentran y cargan los módulos desde "
"la ruta :term:`import path`."

#: ../Doc/reference/import.rst:772
msgid ""
"Three variables are used by the :term:`path based finder`, :data:`sys."
"path`, :data:`sys.path_hooks` and :data:`sys.path_importer_cache`.  The "
"``__path__`` attributes on package objects are also used.  These provide "
"additional ways that the import machinery can be customized."
msgstr ""
"Tres variables son usadas por :term:`path based finder`, :data:`sys.path`, :"
"data:`sys.path_hooks` y :data:`sys.path_importer_cache`.  También se "
"utilizan los atributos ``__path__`` en los objetos de paquete.  Estos "
"proporcionan formas adicionales de personalizar la maquinaria de importación."

#: ../Doc/reference/import.rst:777
msgid ""
":data:`sys.path` contains a list of strings providing search locations for "
"modules and packages.  It is initialized from the :data:`PYTHONPATH` "
"environment variable and various other installation- and implementation-"
"specific defaults.  Entries in :data:`sys.path` can name directories on the "
"file system, zip files, and potentially other \"locations\" (see the :mod:"
"`site` module) that should be searched for modules, such as URLs, or "
"database queries.  Only strings and bytes should be present on :data:`sys."
"path`; all other data types are ignored.  The encoding of bytes entries is "
"determined by the individual :term:`path entry finders <path entry finder>`."
msgstr ""
":data:`sys.path` contiene una lista de cadenas que proporcionan ubicaciones "
"de búsqueda para módulos y paquetes.  Se inicializa a partir de la variable "
"de entorno :data:`PYTHONPATH` y varios otros valores predeterminados "
"específicos de la instalación e implementación.  Las entradas de :data:`sys."
"path` pueden nombrar directorios en el sistema de archivos, archivos zip y "
"potencialmente otras \"ubicaciones\" (consulte el módulo :mod:`site`) que se "
"deben buscar para módulos, como direcciones URL o consultas de base de "
"datos.  Solo las cadenas y bytes deben estar presentes en :data:`sys.path`; "
"todos los demás tipos de datos se omiten.  La codificación de las entradas "
"de bytes viene determinada por los :term:`buscadores de entrada de ruta "
"<path entry finder>`."

#: ../Doc/reference/import.rst:788
msgid ""
"The :term:`path based finder` is a :term:`meta path finder`, so the import "
"machinery begins the :term:`import path` search by calling the path based "
"finder's :meth:`~importlib.machinery.PathFinder.find_spec` method as "
"described previously.  When the ``path`` argument to :meth:`~importlib."
"machinery.PathFinder.find_spec` is given, it will be a list of string paths "
"to traverse - typically a package's ``__path__`` attribute for an import "
"within that package.  If the ``path`` argument is ``None``, this indicates a "
"top level import and :data:`sys.path` is used."
msgstr ""
"El buscador :term:`path based finder` es un :term:`meta path finder`, por lo "
"que la maquinaria de importación comienza la búsqueda :term:`import path` "
"llamando al método :meth:`~importlib.machinery.PathFinder.find_spec` basado "
"en la ruta de acceso, tal como se describió anteriormente.  Cuando se "
"proporciona el argumento ``path`` a :meth:`~importlib.machinery.PathFinder."
"find_spec`, será una lista de rutas de acceso de cadena para recorrer - "
"normalmente el atributo ``__path__`` de un paquete para una importación "
"dentro de ese paquete.  Si el argumento ``path`` es ``None``, esto indica "
"una importación de nivel superior y se utiliza :data:`sys.path`."

#: ../Doc/reference/import.rst:797
msgid ""
"The path based finder iterates over every entry in the search path, and for "
"each of these, looks for an appropriate :term:`path entry finder` (:class:"
"`~importlib.abc.PathEntryFinder`) for the path entry.  Because this can be "
"an expensive operation (e.g. there may be `stat()` call overheads for this "
"search), the path based finder maintains a cache mapping path entries to "
"path entry finders.  This cache is maintained in :data:`sys."
"path_importer_cache` (despite the name, this cache actually stores finder "
"objects rather than being limited to :term:`importer` objects). In this way, "
"the expensive search for a particular :term:`path entry` location's :term:"
"`path entry finder` need only be done once.  User code is free to remove "
"cache entries from :data:`sys.path_importer_cache` forcing the path based "
"finder to perform the path entry search again [#fnpic]_."
msgstr ""
"El buscador basado en rutas de acceso recorre en iteración cada entrada de "
"la ruta de búsqueda y, para cada una de ellas, busca un :term:`path entry "
"finder` adecuado (:class:`~importlib.abc.PathEntryFinder`) para la entrada "
"de ruta de acceso.  Dado que esto puede ser una operación costosa (por "
"ejemplo, puede haber sobrecargas de llamadas `stat()` para esta búsqueda), "
"el buscador basado en rutas mantiene una ruta de acceso de asignación de "
"caché entradas a los buscadores de entrada de ruta.  Esta memoria caché se "
"mantiene en :data:`sys.path_importer_cache` (a pesar del nombre, esta caché "
"almacena realmente objetos de buscador en lugar de limitarse a objetos :term:"
"`importer`). De esta manera, la costosa búsqueda de una ubicación en "
"particular :term:`path entry` :term:`path entry finder` solo debe hacerse "
"una vez.  El código de usuario es libre de eliminar las entradas de caché "
"de :data:`sys.path_importer_cache` obligando al buscador basado en ruta de "
"acceso a realizar de nuevo la búsqueda de entrada de ruta [#fnpic]_."

#: ../Doc/reference/import.rst:810
msgid ""
"If the path entry is not present in the cache, the path based finder "
"iterates over every callable in :data:`sys.path_hooks`.  Each of the :term:"
"`path entry hooks <path entry hook>` in this list is called with a single "
"argument, the path entry to be searched.  This callable may either return a :"
"term:`path entry finder` that can handle the path entry, or it may raise :"
"exc:`ImportError`.  An :exc:`ImportError` is used by the path based finder "
"to signal that the hook cannot find a :term:`path entry finder` for that :"
"term:`path entry`.  The exception is ignored and :term:`import path` "
"iteration continues.  The hook should expect either a string or bytes "
"object; the encoding of bytes objects is up to the hook (e.g. it may be a "
"file system encoding, UTF-8, or something else), and if the hook cannot "
"decode the argument, it should raise :exc:`ImportError`."
msgstr ""
"Si la entrada de ruta de acceso no está presente en la memoria caché, el "
"buscador basado en rutas de acceso recorre en iteración cada llamada que se "
"puede llamar en :data:`sys.path_hooks`.  Cada uno de los enlaces de :term:"
"`ganchos de rutas de entrada <path entry hook>` en esta lista se llama con "
"un solo argumento, la entrada de ruta de acceso que se va a buscar.  Esta "
"invocable puede retornar un :term:`path entry finder` que puede controlar la "
"entrada de ruta de acceso, o puede generar :exc:`ImportError`.  Un :exc:"
"`ImportError` es utilizado por el buscador basado en ruta para indicar que "
"el gancho no puede encontrar un :term:`path entry finder` para eso :term:"
"`entrada de ruta`.  Se omite la excepción y la iteración :term:`import path` "
"continúa.  El enlace debe esperar un objeto de rutas o bytes; la "
"codificación de objetos bytes está hasta el enlace (por ejemplo, puede ser "
"una codificación del sistema de archivos, UTF-8, o algo más), y si el gancho "
"no puede decodificar el argumento, debe generar :exc:`ImportError`."

#: ../Doc/reference/import.rst:824
msgid ""
"If :data:`sys.path_hooks` iteration ends with no :term:`path entry finder` "
"being returned, then the path based finder's :meth:`~importlib.machinery."
"PathFinder.find_spec` method will store ``None`` in :data:`sys."
"path_importer_cache` (to indicate that there is no finder for this path "
"entry) and return ``None``, indicating that this :term:`meta path finder` "
"could not find the module."
msgstr ""
"Si la iteración :data:`sys.path_hooks` termina sin que se retorne ningún "
"valor :term:`path entry finder`, a continuación, el método de búsqueda "
"basado en la ruta de acceso :meth:`~importlib.machinery.PathFinder."
"find_spec` almacenará ``None`` en :data:`sys.path_importer_cache` (para "
"indicar que no hay ningún buscador para esta entrada de ruta) y retornará "
"``None``, lo que indica que este :term:`meta path finder` no pudo encontrar "
"el módulo."

#: ../Doc/reference/import.rst:831
msgid ""
"If a :term:`path entry finder` *is* returned by one of the :term:`path entry "
"hook` callables on :data:`sys.path_hooks`, then the following protocol is "
"used to ask the finder for a module spec, which is then used when loading "
"the module."
msgstr ""
"Si un :term:`path entry finder` *is* retornado por uno de los :term:`path "
"entry hook` invocables en :data:`sys.path_hooks`, entonces el siguiente "
"protocolo se utiliza para pedir al buscador una especificación de módulo, "
"que luego se utiliza al cargar el módulo."

#: ../Doc/reference/import.rst:836
msgid ""
"The current working directory -- denoted by an empty string -- is handled "
"slightly differently from other entries on :data:`sys.path`. First, if the "
"current working directory is found to not exist, no value is stored in :data:"
"`sys.path_importer_cache`. Second, the value for the current working "
"directory is looked up fresh for each module lookup. Third, the path used "
"for :data:`sys.path_importer_cache` and returned by :meth:`importlib."
"machinery.PathFinder.find_spec` will be the actual current working directory "
"and not the empty string."
msgstr ""
"El directorio de trabajo actual, denotado por una cadena vacía, se controla "
"de forma ligeramente diferente de otras entradas de :data:`sys.path`. En "
"primer lugar, si se encuentra que el directorio de trabajo actual no existe, "
"no se almacena ningún valor en :data:`sys.path_importer_cache`. En segundo "
"lugar, el valor del directorio de trabajo actual se busca actualizado para "
"cada búsqueda de módulo. En tercer lugar, la ruta de acceso utilizada para :"
"data:`sys.path_importer_cache` y retornada por :meth:`importlib.machinery."
"PathFinder.find_spec` será el directorio de trabajo actual real y no la "
"cadena vacía."

#: ../Doc/reference/import.rst:846
msgid "Path entry finder protocol"
msgstr "Buscadores de entradas de ruta"

#: ../Doc/reference/import.rst:848
msgid ""
"In order to support imports of modules and initialized packages and also to "
"contribute portions to namespace packages, path entry finders must implement "
"the :meth:`~importlib.abc.PathEntryFinder.find_spec` method."
msgstr ""
"Para admitir las importaciones de módulos y paquetes inicializados y también "
"para contribuir con partes a paquetes de espacio de nombres, los buscadores "
"de entradas de ruta de acceso deben implementar el método :meth:`importlib."
"abc.PathEntryFinder.find_spec`."

#: ../Doc/reference/import.rst:852
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` takes two arguments: the "
"fully qualified name of the module being imported, and the (optional) target "
"module.  ``find_spec()`` returns a fully populated spec for the module. This "
"spec will always have \"loader\" set (with one exception)."
msgstr ""
":meth:`importlib.abc.PathEntryFinder.find_spec`` toma dos argumentos: el "
"nombre completo del módulo que se va a importar y el módulo de destino "
"(opcional).  ``find_spec()`` retorna una especificación completamente "
"poblada para el módulo. Esta especificación siempre tendrá \"cargador\" "
"establecido (con una excepción)."

#: ../Doc/reference/import.rst:857
msgid ""
"To indicate to the import machinery that the spec represents a namespace :"
"term:`portion`, the path entry finder sets \"loader\" on the spec to "
"``None`` and \"submodule_search_locations\" to a list containing the portion."
msgstr ""
"Para indicar a la máquina de importación que la especificación representa un "
"espacio de nombres :term:`portion`, el buscador de entradas de ruta "
"establece \"loader\" en la especificación en ``None`` y "
"\"submodule_search_locations\" en una lista que contiene la parte."

#: ../Doc/reference/import.rst:862
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` replaced :meth:`~importlib."
"abc.PathEntryFinder.find_loader` and :meth:`~importlib.abc.PathEntryFinder."
"find_module`, both of which are now deprecated, but will be used if "
"``find_spec()`` is not defined."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` reemplazó a :meth:"
"`~importlib.abc.PathEntryFinder.find_loader` y :meth:`~importlib.abc."
"PathEntryFinder.find_module`, los cuales ahora están en desuso, pero se "
"utilizarán si ``find_spec()`` no está definido."

#: ../Doc/reference/import.rst:868
msgid ""
"Older path entry finders may implement one of these two deprecated methods "
"instead of ``find_spec()``.  The methods are still respected for the sake of "
"backward compatibility.  However, if ``find_spec()`` is implemented on the "
"path entry finder, the legacy methods are ignored."
msgstr ""
"Los buscadores de entradas de ruta más antiguos pueden implementar uno de "
"estos dos métodos en desuso en lugar de ``find_spec()``.  Los métodos "
"todavía se respetan en aras de la compatibilidad con versiones anteriores.  "
"Sin embargo, si ``find_spec()`` se implementa en el buscador de entrada de "
"ruta, se omiten los métodos heredados."

#: ../Doc/reference/import.rst:873
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_loader` takes one argument, the "
"fully qualified name of the module being imported.  ``find_loader()`` "
"returns a 2-tuple where the first item is the loader and the second item is "
"a namespace :term:`portion`.  When the first item (i.e. the loader) is "
"``None``, this means that while the path entry finder does not have a loader "
"for the named module, it knows that the path entry contributes to a "
"namespace portion for the named module.  This will almost always be the case "
"where Python is asked to import a namespace package that has no physical "
"presence on the file system.  When a path entry finder returns ``None`` for "
"the loader, the second item of the 2-tuple return value must be a sequence, "
"although it can be empty."
msgstr ""
":meth:`importlib.abc.PathEntryFinder.find_loader` toma un argumento, el "
"nombre completo del módulo que se va a importar.  ``find_loader()`` retorna "
"una tupla de 2 donde el primer elemento es el cargador y el segundo elemento "
"es un espacio de nombres :term:`portion`.  Cuando el primer elemento (es "
"decir, el cargador) es ``None``, esto significa que mientras que el buscador "
"de entrada de ruta de acceso no tiene un cargador para el módulo con nombre, "
"sabe que la entrada de ruta de acceso contribuye a una parte del espacio de "
"nombres para el módulo con nombre.  Esto casi siempre será el caso donde se "
"le pide a Python que importe un paquete de espacio de nombres que no tiene "
"presencia física en el sistema de archivos.  Cuando un buscador de entradas "
"de ruta retorna ``None`` para el cargador, el segundo elemento del valor "
"retornado de 2 tuplas debe ser una secuencia, aunque puede estar vacío."

#: ../Doc/reference/import.rst:885
msgid ""
"If ``find_loader()`` returns a non-``None`` loader value, the portion is "
"ignored and the loader is returned from the path based finder, terminating "
"the search through the path entries."
msgstr ""
"Si ``find_loader()`` retorna un valor de cargador que no es ``None``, la "
"parte se omite y el cargador se retorna desde el buscador basado en rutas, "
"terminando la búsqueda a través de las entradas de ruta de acceso."

#: ../Doc/reference/import.rst:889
msgid ""
"For backwards compatibility with other implementations of the import "
"protocol, many path entry finders also support the same, traditional "
"``find_module()`` method that meta path finders support. However path entry "
"finder ``find_module()`` methods are never called with a ``path`` argument "
"(they are expected to record the appropriate path information from the "
"initial call to the path hook)."
msgstr ""
"Para la compatibilidad con versiones anteriores con otras implementaciones "
"del protocolo de importación, muchos buscadores de entradas de ruta de "
"acceso también admiten el mismo método tradicional ``find_module()`` que "
"admiten los buscadores de rutas de acceso meta. Sin embargo, nunca se llama "
"a los métodos del buscador de entradas de ruta ``find_module()`` con un "
"argumento ``path`` (se espera que registren la información de ruta adecuada "
"desde la llamada inicial al enlace de ruta)."

#: ../Doc/reference/import.rst:896
msgid ""
"The ``find_module()`` method on path entry finders is deprecated, as it does "
"not allow the path entry finder to contribute portions to namespace "
"packages.  If both ``find_loader()`` and ``find_module()`` exist on a path "
"entry finder, the import system will always call ``find_loader()`` in "
"preference to ``find_module()``."
msgstr ""
"El método ``find_module()`` en los buscadores de entrada de ruta está en "
"desuso, ya que no permite que el buscador de entradas de ruta de acceso "
"aporte partes a paquetes de espacio de nombres.  Si existen tanto "
"``find_loader()`` como ``find_module()`` en un buscador de entrada de ruta, "
"el sistema de importación siempre llamará a ``find_loader()`` en lugar de "
"``find_module()``."

#: ../Doc/reference/import.rst:904
msgid "Replacing the standard import system"
msgstr "Reemplazando el sistema de importación estándar"

#: ../Doc/reference/import.rst:906
msgid ""
"The most reliable mechanism for replacing the entire import system is to "
"delete the default contents of :data:`sys.meta_path`, replacing them "
"entirely with a custom meta path hook."
msgstr ""
"El mecanismo más confiable para reemplazar todo el sistema de importación es "
"eliminar el contenido predeterminado de :data:`sys.meta_path`, "
"sustituyéndolos por completo por un enlace de meta path personalizado."

#: ../Doc/reference/import.rst:910
msgid ""
"If it is acceptable to only alter the behaviour of import statements without "
"affecting other APIs that access the import system, then replacing the "
"builtin :func:`__import__` function may be sufficient. This technique may "
"also be employed at the module level to only alter the behaviour of import "
"statements within that module."
msgstr ""
"Si es aceptable alterar únicamente el comportamiento de las declaraciones de "
"importación sin afectar a otras API que acceden al sistema de importación, "
"puede ser suficiente reemplazar la función incorporada :func:`__import__`. "
"Esta técnica también puede emplearse a nivel de módulo para alterar "
"únicamente el comportamiento de las declaraciones de importación dentro de "
"ese módulo."

#: ../Doc/reference/import.rst:916
msgid ""
"To selectively prevent the import of some modules from a hook early on the "
"meta path (rather than disabling the standard import system entirely), it is "
"sufficient to raise :exc:`ModuleNotFoundError` directly from :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` instead of returning ``None``. The "
"latter indicates that the meta path search should continue, while raising an "
"exception terminates it immediately."
msgstr ""
"Para evitar selectivamente la importación de algunos módulos de un enlace al "
"principio de la meta path (en lugar de deshabilitar completamente el sistema "
"de importación estándar), es suficiente elevar :exc:`ModuleNotFoundError` "
"directamente desde :meth:`~importlib.abc.MetaPathFinder.find_spec` en lugar "
"de retornar ``None``. Este último indica que la búsqueda de meta path debe "
"continuar, mientras que la generación de una excepción termina "
"inmediatamente."

#: ../Doc/reference/import.rst:926
msgid "Package Relative Imports"
msgstr "Paquete Importaciones relativas"

#: ../Doc/reference/import.rst:928
msgid ""
"Relative imports use leading dots. A single leading dot indicates a relative "
"import, starting with the current package. Two or more leading dots indicate "
"a relative import to the parent(s) of the current package, one level per dot "
"after the first. For example, given the following package layout::"
msgstr ""
"Las importaciones relativas utilizan puntos iniciales. Un único punto "
"inicial indica una importación relativa, empezando por el paquete actual. "
"Dos o más puntos iniciales indican una importación relativa a los elementos "
"primarios del paquete actual, un nivel por punto después del primero. Por "
"ejemplo, dado el siguiente diseño de paquete::"

#: ../Doc/reference/import.rst:944
msgid ""
"In either ``subpackage1/moduleX.py`` or ``subpackage1/__init__.py``, the "
"following are valid relative imports::"
msgstr ""
"En ``subpackage1/moduleX.py`` o ``subpackage1/__init__.py``, las siguientes "
"son importaciones relativas válidas::"

#: ../Doc/reference/import.rst:954
msgid ""
"Absolute imports may use either the ``import <>`` or ``from <> import <>`` "
"syntax, but relative imports may only use the second form; the reason for "
"this is that::"
msgstr ""
"Las importaciones absolutas pueden utilizar la sintaxis ``import <>`` o "
"``from <> import <>``, pero las importaciones relativas solo pueden usar el "
"segundo formulario; la razón de esto es que:"

#: ../Doc/reference/import.rst:960
msgid ""
"should expose ``XXX.YYY.ZZZ`` as a usable expression, but .moduleY is not a "
"valid expression."
msgstr ""
"debe exponer ``XXX. Yyy. ZZZ`` como una expresión utilizable, pero .moduleY "
"no es una expresión válida."

#: ../Doc/reference/import.rst:965
msgid "Special considerations for __main__"
msgstr "Consideraciones especiales para __main__"

#: ../Doc/reference/import.rst:967
msgid ""
"The :mod:`__main__` module is a special case relative to Python's import "
"system.  As noted :ref:`elsewhere <programs>`, the ``__main__`` module is "
"directly initialized at interpreter startup, much like :mod:`sys` and :mod:"
"`builtins`.  However, unlike those two, it doesn't strictly qualify as a "
"built-in module.  This is because the manner in which ``__main__`` is "
"initialized depends on the flags and other options with which the "
"interpreter is invoked."
msgstr ""
"El módulo :mod:`__main__` es un caso especial relativo al sistema de "
"importación de Python.  Como se señaló :ref:`elsewhere <programs>`, el "
"módulo ``__main__`` se inicializa directamente al inicio del intérprete, al "
"igual que :mod:`sys` y :mod:`builtins`.  Sin embargo, a diferencia de esos "
"dos, no califica estrictamente como un módulo integrado.  Esto se debe a que "
"la forma en que se inicializa ``__main__`` depende de las marcas y otras "
"opciones con las que se invoca el intérprete.</programs>"

#: ../Doc/reference/import.rst:978
msgid "__main__.__spec__"
msgstr "__main__.__spec__"

#: ../Doc/reference/import.rst:980
msgid ""
"Depending on how :mod:`__main__` is initialized, ``__main__.__spec__`` gets "
"set appropriately or to ``None``."
msgstr ""
"Dependiendo de cómo se inicializa :mod:`__main__`, ``__main__.__spec__`` se "
"establece correctamente o en ``None``."

#: ../Doc/reference/import.rst:983
msgid ""
"When Python is started with the :option:`-m` option, ``__spec__`` is set to "
"the module spec of the corresponding module or package. ``__spec__`` is also "
"populated when the ``__main__`` module is loaded as part of executing a "
"directory, zipfile or other :data:`sys.path` entry."
msgstr ""
"Cuando Python se inicia con la opción :option:`-m`, ``__spec__`` se "
"establece en la especificación de módulo del módulo o paquete "
"correspondiente. ``__spec__`` también se rellena cuando el módulo "
"``__main__`` se carga como parte de la ejecución de un directorio, zipfile u "
"otro :data:`sys.path` entrada."

#: ../Doc/reference/import.rst:988
msgid ""
"In :ref:`the remaining cases <using-on-interface-options>` ``__main__."
"__spec__`` is set to ``None``, as the code used to populate the :mod:"
"`__main__` does not correspond directly with an importable module:"
msgstr ""
"En :ref:`los casos restantes <using-on-interface-options>` ``__main__."
"__spec__`` se establece en ``None``, ya que el código utilizado para "
"rellenar el :mod:`__main__` no se corresponde directamente con un módulo "
"importable:</using-on-interface-options>"

#: ../Doc/reference/import.rst:992
msgid "interactive prompt"
msgstr "mensaje interactivo"

#: ../Doc/reference/import.rst:993
msgid ":option:`-c` option"
msgstr "opción :option:`-c`"

#: ../Doc/reference/import.rst:994
msgid "running from stdin"
msgstr "ejecutando desde stdin"

#: ../Doc/reference/import.rst:995
msgid "running directly from a source or bytecode file"
msgstr ""
"que se ejecuta directamente desde un archivo de código fuente o de código de "
"bytes"

#: ../Doc/reference/import.rst:997
msgid ""
"Note that ``__main__.__spec__`` is always ``None`` in the last case, *even "
"if* the file could technically be imported directly as a module instead. Use "
"the :option:`-m` switch if valid module metadata is desired in :mod:"
"`__main__`."
msgstr ""
"Tenga en cuenta que ``__main__.__spec__`` siempre es ``None`` en el último "
"caso, *incluso si* el archivo técnicamente podría importarse directamente "
"como un módulo en su lugar. Utilice el modificador :option:`-m` si se desean "
"metadatos de módulo válidos en :mod:`__main__`."

#: ../Doc/reference/import.rst:1002
msgid ""
"Note also that even when ``__main__`` corresponds with an importable module "
"and ``__main__.__spec__`` is set accordingly, they're still considered "
"*distinct* modules. This is due to the fact that blocks guarded by ``if "
"__name__ == \"__main__\":`` checks only execute when the module is used to "
"populate the ``__main__`` namespace, and not during normal import."
msgstr ""
"Tenga en cuenta también que incluso cuando ``__main__`` corresponde a un "
"módulo importable y ``__main__.__spec__`` se establece en consecuencia, "
"todavía se consideran módulos *distinct*. Esto se debe al hecho de que los "
"bloques protegidos por las comprobaciones ``if __name__ == \"__main__\":`` "
"solo se ejecutan cuando el módulo se utiliza para rellenar el espacio de "
"nombres ``__main__``, y no durante la importación normal."

#: ../Doc/reference/import.rst:1010
msgid "Open issues"
msgstr "Problemas sin resolver"

#: ../Doc/reference/import.rst:1012
msgid "XXX It would be really nice to have a diagram."
msgstr "XXX Sería muy agradable tener un diagrama."

#: ../Doc/reference/import.rst:1014
msgid ""
"XXX * (import_machinery.rst) how about a section devoted just to the "
"attributes of modules and packages, perhaps expanding upon or supplanting "
"the related entries in the data model reference page?"
msgstr ""
"XXX * (import_machinery.rst) ¿qué tal una sección dedicada sólo a los "
"atributos de módulos y paquetes, tal vez ampliando o suplantando las "
"entradas relacionadas en la página de referencia del modelo de datos?"

#: ../Doc/reference/import.rst:1018
msgid ""
"XXX runpy, pkgutil, et al in the library manual should all get \"See Also\" "
"links at the top pointing to the new import system section."
msgstr ""
"XXX runpy, pkgutil, et al en el manual de la biblioteca deben obtener "
"enlaces \"Ver también\" en la parte superior que apuntan a la nueva sección "
"del sistema de importación."

#: ../Doc/reference/import.rst:1021
msgid ""
"XXX Add more explanation regarding the different ways in which ``__main__`` "
"is initialized?"
msgstr ""
"XXX Añadir más explicación con respecto a las diferentes formas en que "
"``__main__`` se inicializa?"

#: ../Doc/reference/import.rst:1024
msgid ""
"XXX Add more info on ``__main__`` quirks/pitfalls (i.e. copy from :pep:"
"`395`)."
msgstr ""
"XXX Añadir más información sobre las peculiaridades/trampas ``__main__`` (es "
"decir, copia de :pep:`395`)."

#: ../Doc/reference/import.rst:1029
msgid "References"
msgstr "Referencias"

#: ../Doc/reference/import.rst:1031
msgid ""
"The import machinery has evolved considerably since Python's early days.  "
"The original `specification for packages <https://www.python.org/doc/essays/"
"packages/>`_ is still available to read, although some details have changed "
"since the writing of that document."
msgstr ""
"La maquinaria de importación ha evolucionado considerablemente desde los "
"primeros días de Python.  La `especificación original para paquetes <https://"
"www.python.org/doc/essays/packages/>`_ todavía está disponible para leer, "
"aunque algunos detalles han cambiado desde la escritura de ese documento."

#: ../Doc/reference/import.rst:1036
msgid ""
"The original specification for :data:`sys.meta_path` was :pep:`302`, with "
"subsequent extension in :pep:`420`."
msgstr ""
"La especificación original de :data:`sys.meta_path` era :pep:`302`, con "
"posterior extensión en :pep:`420`."

#: ../Doc/reference/import.rst:1039
msgid ""
":pep:`420` introduced :term:`namespace packages <namespace package>` for "
"Python 3.3.  :pep:`420` also introduced the :meth:`find_loader` protocol as "
"an alternative to :meth:`find_module`."
msgstr ""
":pep:`420` introdujo :term:`paquetes de espacio de nombres <namespace "
"package>` para Python 3.3.  :pep:`420` también introdujo el protocolo :meth:"
"`find_loader` como alternativa a :meth:`find_module`."

#: ../Doc/reference/import.rst:1043
msgid ""
":pep:`366` describes the addition of the ``__package__`` attribute for "
"explicit relative imports in main modules."
msgstr ""
":pep:`366` describe la adición del atributo ``__package__`` para las "
"importaciones relativas explícitas en los módulos principales."

#: ../Doc/reference/import.rst:1046
msgid ""
":pep:`328` introduced absolute and explicit relative imports and initially "
"proposed ``__name__`` for semantics :pep:`366` would eventually specify for "
"``__package__``."
msgstr ""
":pep:`328` introdujo importaciones relativas absolutas y explícitas e "
"inicialmente propuestas ``__name__`` para la semántica :pep:`366` "
"eventualmente especificaría para ``__package__``."

#: ../Doc/reference/import.rst:1050
msgid ":pep:`338` defines executing modules as scripts."
msgstr ":pep:`338` define la ejecución de módulos como scripts."

#: ../Doc/reference/import.rst:1052
msgid ""
":pep:`451` adds the encapsulation of per-module import state in spec "
"objects.  It also off-loads most of the boilerplate responsibilities of "
"loaders back onto the import machinery. These changes allow the deprecation "
"of several APIs in the import system and also addition of new methods to "
"finders and loaders."
msgstr ""
":pep:`451` agrega la encapsulación del estado de importación por módulo en "
"los objetos de especificación. También descargara la mayoría de las "
"responsabilidades de los cargadores en la maquinaria de importación.  Estos "
"cambios permiten el desuso de varias API en el sistema de importación y "
"también la adición de nuevos métodos a los buscadores y cargadores."

#: ../Doc/reference/import.rst:1059
msgid "Footnotes"
msgstr "Notas al Pie de Pagina"

#: ../Doc/reference/import.rst:1060
msgid "See :class:`types.ModuleType`."
msgstr "Véase :class:`types. ModuleType`."

#: ../Doc/reference/import.rst:1062
msgid ""
"The importlib implementation avoids using the return value directly. "
"Instead, it gets the module object by looking the module name up in :data:"
"`sys.modules`.  The indirect effect of this is that an imported module may "
"replace itself in :data:`sys.modules`.  This is implementation-specific "
"behavior that is not guaranteed to work in other Python implementations."
msgstr ""
"La implementación de importlib evita usar el valor retornado directamente. "
"En su lugar, obtiene el objeto module buscando el nombre del módulo en :data:"
"`sys.modules`.  El efecto indirecto de esto es que un módulo importado puede "
"sustituirse a sí mismo en :data:`sys.modules`.  Este es un comportamiento "
"específico de la implementación que no se garantiza que funcione en otras "
"implementaciones de Python."

#: ../Doc/reference/import.rst:1069
msgid ""
"In legacy code, it is possible to find instances of :class:`imp."
"NullImporter` in the :data:`sys.path_importer_cache`.  It is recommended "
"that code be changed to use ``None`` instead.  See :ref:`portingpythoncode` "
"for more details."
msgstr ""
"En el código heredado, es posible encontrar instancias de :class:`imp. "
"NullImporter` en el :data:`sys.path_importer_cache`.  Se recomienda cambiar "
"el código para usar ``None`` en su lugar.  Consulte :ref:`portingpythoncode` "
"para obtener más detalles."
