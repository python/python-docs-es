# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-05 12:54+0200\n"
"PO-Revision-Date: 2020-12-06 14:19+0100\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Last-Translator: Álvaro Mondéjar Rubio <mondejar1994@gmail.com>\n"
"Language: es\n"
"X-Generator: Poedit 2.4.2\n"

#: ../Doc/reference/expressions.rst:6
msgid "Expressions"
msgstr "Expresiones"

#: ../Doc/reference/expressions.rst:10
msgid ""
"This chapter explains the meaning of the elements of expressions in Python."
msgstr ""
"Este capítulo explica el significado de los elementos de expresiones en "
"Python."

#: ../Doc/reference/expressions.rst:12
msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF notation "
"will be used to describe syntax, not lexical analysis.  When (one "
"alternative of) a syntax rule has the form"
msgstr ""
"**Notas de Sintaxis:** En este y los siguientes capítulos será usada "
"notación BNF extendida para describir sintaxis, no análisis léxico. Cuando "
"(una alternativa de) una regla de sintaxis tiene la forma"

#: ../Doc/reference/expressions.rst:19
msgid ""
"and no semantics are given, the semantics of this form of ``name`` are the "
"same as for ``othername``."
msgstr ""
"y no han sido dadas semánticas, las semánticas de esta forma de ``name`` son "
"las mismas que para ``othername``."

#: ../Doc/reference/expressions.rst:26
msgid "Arithmetic conversions"
msgstr "Conversiones aritméticas"

#: ../Doc/reference/expressions.rst:30
msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common type\", this means that the "
"operator implementation for built-in types works as follows:"
msgstr ""
"Cuando una descripción de un operador aritmético a continuación usa la frase "
"\"los argumentos numéricos son convertidos a un tipo común\", esto significa "
"que la implementación de operador para tipos incorporados funciona de la "
"siguiente forma:"

#: ../Doc/reference/expressions.rst:34
msgid ""
"If either argument is a complex number, the other is converted to complex;"
msgstr ""
"Si cualquiera de los argumentos es un número complejo, el otro es convertido "
"a complejo;"

#: ../Doc/reference/expressions.rst:36
msgid ""
"otherwise, if either argument is a floating point number, the other is "
"converted to floating point;"
msgstr ""
"de otra forma, si cualquier de los argumentos es un número de punto "
"flotante, el otro es convertido a punto flotante;"

#: ../Doc/reference/expressions.rst:39
msgid "otherwise, both must be integers and no conversion is necessary."
msgstr "de otra forma, ambos deben ser enteros y no se necesita conversión."

#: ../Doc/reference/expressions.rst:41
msgid ""
"Some additional rules apply for certain operators (e.g., a string as a left "
"argument to the '%' operator).  Extensions must define their own conversion "
"behavior."
msgstr ""
"Algunas reglas adicionales aplican para ciertos operadores (ej., una cadena "
"de caracteres como argumento a la izquierda del operador '%'). Las "
"extensiones deben definir su comportamiento de conversión."

#: ../Doc/reference/expressions.rst:49
msgid "Atoms"
msgstr "Átomos"

#: ../Doc/reference/expressions.rst:53
msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are "
"identifiers or literals.  Forms enclosed in parentheses, brackets or braces "
"are also categorized syntactically as atoms.  The syntax for atoms is:"
msgstr ""
"Los átomos son los elementos más básicos de las expresiones. Los átomos más "
"simples son identificadores o literales. Las formas encerradas en "
"paréntesis, corchetes o llaves son también sintácticamente categorizadas "
"como átomos. La sintaxis para átomos es:"

#: ../Doc/reference/expressions.rst:66
msgid "Identifiers (Names)"
msgstr "Identificadores (Nombres)"

#: ../Doc/reference/expressions.rst:70
msgid ""
"An identifier occurring as an atom is a name.  See section :ref:"
"`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""
"Un identificador encontrándose como un átomo es un nombre. Vea la sección :"
"ref:`identifiers` para la definición léxica y la sección :ref:`naming` para "
"documentación de nombrar y vincular."

#: ../Doc/reference/expressions.rst:76
msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a :exc:"
"`NameError` exception."
msgstr ""
"Cuando el nombre es vinculado a un objeto, la evaluación del átomo produce "
"ese objeto. Cuando un nombre no es vinculado, un intento de evaluarlo genera "
"una excepción :exc:`NameError`."

#: ../Doc/reference/expressions.rst:84
msgid ""
"**Private name mangling:** When an identifier that textually occurs in a "
"class definition begins with two or more underscore characters and does not "
"end in two or more underscores, it is considered a :dfn:`private name` of "
"that class. Private names are transformed to a longer form before code is "
"generated for them.  The transformation inserts the class name, with leading "
"underscores removed and a single underscore inserted, in front of the name.  "
"For example, the identifier ``__spam`` occurring in a class named ``Ham`` "
"will be transformed to ``_Ham__spam``.  This transformation is independent "
"of the syntactical context in which the identifier is used.  If the "
"transformed name is extremely long (longer than 255 characters), "
"implementation defined truncation may happen. If the class name consists "
"only of underscores, no transformation is done."
msgstr ""
"**Alteración de nombre privado:** Cuando un identificador que ocurre "
"textualmente en una definición de clase comienza con dos o más caracteres de "
"guión bajo y no termina en dos o más guiones bajos, es considerado un :dfn:"
"`private name` de esa clase. Los nombres privados son transformados a una "
"forma más larga antes de que sea generado código para ellos. La "
"transformación inserta el nombre de clase, con los guiones bajos iniciales "
"eliminados y un solo guión bajo insertado, delante del nombre. Por ejemplo, "
"el identificador ``__spam`` que se encuentra en una clase denominada ``Ham`` "
"será transformado a ``_Ham__spam``. Esta transformación es independiente del "
"contexto sintáctico en el cual es usado el identificador. Si el nombre "
"transformado es extremadamente largo (más largo que 255 caracteres), puede "
"ocurrir el truncamiento definido por la implementación. Si el nombre de "
"clase consiste únicamente de guiones bajos, no se realiza transformación."

#: ../Doc/reference/expressions.rst:100
msgid "Literals"
msgstr "Literales"

#: ../Doc/reference/expressions.rst:104
msgid "Python supports string and bytes literals and various numeric literals:"
msgstr ""
"Python soporta literales de cadenas de caracteres y bytes y varios literales "
"numéricos:"

#: ../Doc/reference/expressions.rst:110
msgid ""
"Evaluation of a literal yields an object of the given type (string, bytes, "
"integer, floating point number, complex number) with the given value.  The "
"value may be approximated in the case of floating point and imaginary "
"(complex) literals.  See section :ref:`literals` for details."
msgstr ""
"La evaluación de un literal produce un objeto del tipo dado (cadena de "
"caracteres, bytes, entero, número de punto flotante, número complejo) con el "
"valor dado. El valor puede ser aproximado en el caso de literales de número "
"de punto flotante e imaginarios (complejos). Vea la sección :ref:`literals` "
"para más detalles."

#: ../Doc/reference/expressions.rst:119
msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of literals "
"with the same value (either the same occurrence in the program text or a "
"different occurrence) may obtain the same object or a different object with "
"the same value."
msgstr ""
"Todos los literales corresponden a tipos de datos inmutables y, por lo "
"tanto, la identidad del objeto es menos importante que su valor. Múltiples "
"evaluaciones de literales con el mismo valor (ya sea la misma ocurrencia en "
"el texto del programa o una ocurrencia diferente) pueden obtener el mismo "
"objeto o un objeto diferente con el mismo valor."

#: ../Doc/reference/expressions.rst:129
msgid "Parenthesized forms"
msgstr "Formas entre paréntesis"

#: ../Doc/reference/expressions.rst:135
msgid ""
"A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr ""
"Una forma entre paréntesis es una lista de expresiones opcionales encerradas "
"entre paréntesis:"

#: ../Doc/reference/expressions.rst:140
msgid ""
"A parenthesized expression list yields whatever that expression list yields: "
"if the list contains at least one comma, it yields a tuple; otherwise, it "
"yields the single expression that makes up the expression list."
msgstr ""
"Una expresión entre paréntesis produce lo que la lista de expresión produce: "
"si la lista contiene al menos una coma, produce una tupla; en caso "
"contrario, produce la única expresión que que forma la lista de expresiones."

#: ../Doc/reference/expressions.rst:146
msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples are "
"immutable, the same rules as for literals apply (i.e., two occurrences of "
"the empty tuple may or may not yield the same object)."
msgstr ""
"Un par de paréntesis vacío producen un objeto de tupla vacío. Debido a que "
"las tuplas son inmutables, se aplican las mismas reglas que aplican para "
"literales (ej., dos ocurrencias de una tupla vacía puede o no producir el "
"mismo objeto)."

#: ../Doc/reference/expressions.rst:154
msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of the "
"comma operator.  The exception is the empty tuple, for which parentheses "
"*are* required --- allowing unparenthesized \"nothing\" in expressions would "
"cause ambiguities and allow common typos to pass uncaught."
msgstr ""
"Note que las tuplas no son formadas por los paréntesis, sino más bien "
"mediante el uso del operador de coma. La excepción es la tupla vacía, para "
"la cual los paréntesis *son* requeridos -- permitir \"nada\" sin paréntesis "
"en expresiones causaría ambigüedades y permitiría que errores tipográficos "
"comunes pasaran sin ser detectados."

#: ../Doc/reference/expressions.rst:163
msgid "Displays for lists, sets and dictionaries"
msgstr "Despliegues para listas, conjuntos y diccionarios"

#: ../Doc/reference/expressions.rst:165
msgid ""
"For constructing a list, a set or a dictionary Python provides special "
"syntax called \"displays\", each of them in two flavors:"
msgstr ""
"Para construir una lista, un conjunto o un diccionario, Python provee "
"sintaxis especial denominada \"despliegue\", cada una de ellas en dos "
"sabores:"

#: ../Doc/reference/expressions.rst:168
msgid "either the container contents are listed explicitly, or"
msgstr "los contenidos del contenedor son listados explícitamente o"

#: ../Doc/reference/expressions.rst:170
msgid ""
"they are computed via a set of looping and filtering instructions, called a :"
"dfn:`comprehension`."
msgstr ""
"son calculados mediante un conjunto de instrucciones de bucle y filtrado, "
"denominadas una :dfn:`comprehension`."

#: ../Doc/reference/expressions.rst:178
msgid "Common syntax elements for comprehensions are:"
msgstr "Los elementos comunes de sintaxis para las comprensiones son:"

#: ../Doc/reference/expressions.rst:186
msgid ""
"The comprehension consists of a single expression followed by at least one :"
"keyword:`!for` clause and zero or more :keyword:`!for` or :keyword:`!if` "
"clauses. In this case, the elements of the new container are those that "
"would be produced by considering each of the :keyword:`!for` or :keyword:`!"
"if` clauses a block, nesting from left to right, and evaluating the "
"expression to produce an element each time the innermost block is reached."
msgstr ""
"La comprensión consiste en una única expresión seguida por al menos una "
"cláusula :keyword:`!for` y cero o más cláusulas :keyword:`!for` o :keyword:`!"
"if`. En este caso, los elementos del nuevo contenedor son aquellos que "
"serían producidos mediante considerar cada una de las cláusulas :keyword:`!"
"for` o :keyword:`!if` un bloque, anidado de izquierda a derecha y evaluando "
"la expresión para producir un elemento cada vez que se alcanza el bloque más "
"interno."

#: ../Doc/reference/expressions.rst:193
msgid ""
"However, aside from the iterable expression in the leftmost :keyword:`!for` "
"clause, the comprehension is executed in a separate implicitly nested scope. "
"This ensures that names assigned to in the target list don't \"leak\" into "
"the enclosing scope."
msgstr ""
"Sin embargo, aparte de la expresión iterable en la cláusula :keyword:`!for` "
"más a la izquierda, la comprensión es ejecutada en un alcance separado "
"implícitamente anidado. Esto asegura que los nombres asignados a en la lista "
"objetiva no se \"filtren\" en el alcance adjunto."

#: ../Doc/reference/expressions.rst:197
msgid ""
"The iterable expression in the leftmost :keyword:`!for` clause is evaluated "
"directly in the enclosing scope and then passed as an argument to the "
"implicitly nested scope. Subsequent :keyword:`!for` clauses and any filter "
"condition in the leftmost :keyword:`!for` clause cannot be evaluated in the "
"enclosing scope as they may depend on the values obtained from the leftmost "
"iterable. For example: ``[x*y for x in range(10) for y in range(x, x+10)]``."
msgstr ""
"La expresión iterable en la cláusula más a la izquierda :keyword:`!for` es "
"evaluada directamente en el alcance anidado y luego pasada como un argumento "
"al alcance implícitamente anidado. Subsecuentes cláusulas :keyword:`!for` y "
"cualquier condición de filtro en la cláusula :keyword:`!for` más a la "
"izquierda no pueden ser evaluadas en el alcance adjunto ya que pueden "
"depender de los valores obtenidos del iterable de más a la izquierda. Por "
"ejemplo, ``[x*y for x in range(10) for y in range(x, x+10)]``."

#: ../Doc/reference/expressions.rst:204
msgid ""
"To ensure the comprehension always results in a container of the appropriate "
"type, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly nested scope."
msgstr ""
"Para asegurar que la comprensión siempre resulta en un contenedor del tipo "
"apropiado, las expresiones ``yield`` y ``yield from`` están prohibidas en el "
"alcance implícitamente anidado."

#: ../Doc/reference/expressions.rst:211
msgid ""
"Since Python 3.6, in an :keyword:`async def` function, an :keyword:`!async "
"for` clause may be used to iterate over a :term:`asynchronous iterator`. A "
"comprehension in an :keyword:`!async def` function may consist of either a :"
"keyword:`!for` or :keyword:`!async for` clause following the leading "
"expression, may contain additional :keyword:`!for` or :keyword:`!async for` "
"clauses, and may also use :keyword:`await` expressions. If a comprehension "
"contains either :keyword:`!async for` clauses or :keyword:`!await` "
"expressions it is called an :dfn:`asynchronous comprehension`.  An "
"asynchronous comprehension may suspend the execution of the coroutine "
"function in which it appears. See also :pep:`530`."
msgstr ""
"A partir de Python 3.6, en una función :keyword:`async def`, una cláusula :"
"keyword:`!async for` puede ser usada para iterar sobre un :term:"
"`asynchronous iterator`. Una comprensión en una función :keyword:`!async "
"def` puede consistir en una cláusula :keyword:`!for` o :keyword:`!async for` "
"siguiendo la expresión inicial, puede contener cláusulas adicionales :"
"keyword:`!for` o :keyword:`!async for` y también pueden usar expresiones :"
"keyword:`await`. Si una comprensión contiene cláusulas :keyword:`!async for` "
"o expresiones :keyword:`!await` es denominada una :dfn:`asynchronous "
"comprehension`. Una comprensión asincrónica puede suspender la ejecución de "
"la función de corrutina en la cual aparece. Vea también :pep:`530`."

#: ../Doc/reference/expressions.rst:223
msgid "Asynchronous comprehensions were introduced."
msgstr "Fueron introducidas las comprensiones asincrónicas."

#: ../Doc/reference/expressions.rst:226 ../Doc/reference/expressions.rst:397
msgid "``yield`` and ``yield from`` prohibited in the implicitly nested scope."
msgstr ""
"Prohibidas ``yield`` y ``yield from`` en el alcance implícitamente anidado."

#: ../Doc/reference/expressions.rst:233
msgid "List displays"
msgstr "Despliegues de lista"

#: ../Doc/reference/expressions.rst:243
msgid ""
"A list display is a possibly empty series of expressions enclosed in square "
"brackets:"
msgstr ""
"Un despliegue de lista es una serie de expresiones posiblemente vacía "
"encerrada entre corchetes:"

#: ../Doc/reference/expressions.rst:249
msgid ""
"A list display yields a new list object, the contents being specified by "
"either a list of expressions or a comprehension.  When a comma-separated "
"list of expressions is supplied, its elements are evaluated from left to "
"right and placed into the list object in that order.  When a comprehension "
"is supplied, the list is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"Un despliegue de lista produce un nuevo objeto lista, el contenido se "
"especifica por una lista de expresiones o una comprensión. Cuando se "
"proporciona una lista de expresiones, sus elementos son evaluados desde la "
"izquierda a la derecha y colocados en el objeto lista en ese orden. Cuando "
"se proporciona una comprensión, la lista es construida desde los elementos "
"resultantes de la comprensión."

#: ../Doc/reference/expressions.rst:259
msgid "Set displays"
msgstr "Despliegues de conjuntos"

#: ../Doc/reference/expressions.rst:267
msgid ""
"A set display is denoted by curly braces and distinguishable from dictionary "
"displays by the lack of colons separating keys and values:"
msgstr ""
"Un despliegue de conjunto se denota mediante llaves y se distinguen de los "
"despliegues de diccionarios por la ausencia de caracteres de doble punto "
"separando claves y valores:"

#: ../Doc/reference/expressions.rst:273
msgid ""
"A set display yields a new mutable set object, the contents being specified "
"by either a sequence of expressions or a comprehension.  When a comma-"
"separated list of expressions is supplied, its elements are evaluated from "
"left to right and added to the set object.  When a comprehension is "
"supplied, the set is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"Un despliegue de conjunto produce un nuevo objeto conjunto mutable, el "
"contenido se especifica mediante una secuencia de expresiones o una "
"comprensión. Cuando se proporciona una lista de expresiones separadas por "
"comas, sus elementos son evaluados desde la izquierda a la derecha y "
"añadidos al objeto de conjunto. Cuando se proporciona una comprensión, el "
"conjunto es construido de los elementos resultantes de la comprensión."

#: ../Doc/reference/expressions.rst:279
msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs an "
"empty dictionary."
msgstr ""
"Un conjunto vacío no puede ser construido con ``{}``; este literal construye "
"un diccionario vacío."

#: ../Doc/reference/expressions.rst:286
msgid "Dictionary displays"
msgstr "Despliegues de diccionario"

#: ../Doc/reference/expressions.rst:296
msgid ""
"A dictionary display is a possibly empty series of key/datum pairs enclosed "
"in curly braces:"
msgstr ""
"Un despliegue de diccionario es una serie posiblemente vacía de pares clave/"
"datos encerrados entre llaves:"

#: ../Doc/reference/expressions.rst:305
msgid "A dictionary display yields a new dictionary object."
msgstr "Un despliegue de diccionario produce un nuevo objeto diccionario."

#: ../Doc/reference/expressions.rst:307
msgid ""
"If a comma-separated sequence of key/datum pairs is given, they are "
"evaluated from left to right to define the entries of the dictionary: each "
"key object is used as a key into the dictionary to store the corresponding "
"datum.  This means that you can specify the same key multiple times in the "
"key/datum list, and the final dictionary's value for that key will be the "
"last one given."
msgstr ""
"Si es dada una secuencia separada por comas de pares clave/datos, son "
"evaluadas desde la izquierda a la derecha para definir las entradas del "
"diccionario: cada objeto clave es usado como una clave dentro del "
"diccionario para almacenar el dato correspondiente. Esto significa que "
"puedes especificar la misma clave múltiples veces en la lista clave/datos y "
"el valor final del diccionario para esa clave será la última dada."

#: ../Doc/reference/expressions.rst:317
msgid ""
"A double asterisk ``**`` denotes :dfn:`dictionary unpacking`. Its operand "
"must be a :term:`mapping`.  Each mapping item is added to the new "
"dictionary.  Later values replace values already set by earlier key/datum "
"pairs and earlier dictionary unpackings."
msgstr ""
"Un doble asterisco ``**`` denota :dfn:`dictionary unpacking`. Su operando "
"debe ser un :term:`mapping`. Cada elemento de mapeo es añadido al nuevo "
"diccionario. Valores más tardíos remplazan los valores ya establecidos para "
"los pares clave/dato y para los desempaquetados de diccionario anteriores."

#: ../Doc/reference/expressions.rst:322
msgid "Unpacking into dictionary displays, originally proposed by :pep:`448`."
msgstr ""
"Desempaquetar en despliegues de diccionarios, originalmente propuesto por :"
"pep:`448`."

#: ../Doc/reference/expressions.rst:325
msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs two "
"expressions separated with a colon followed by the usual \"for\" and \"if\" "
"clauses. When the comprehension is run, the resulting key and value elements "
"are inserted in the new dictionary in the order they are produced."
msgstr ""
"Una comprensión de diccionario, en contraste a las compresiones de lista y "
"conjunto, necesita dos expresiones separadas con un caracter de doble punto "
"seguido por las cláusulas usuales \"for\" e \"if\". Cuando la comprensión se "
"ejecuta, los elementos resultantes clave y valor son insertados en el nuevo "
"diccionario en el orden que son producidos."

#: ../Doc/reference/expressions.rst:333
msgid ""
"Restrictions on the types of the key values are listed earlier in section :"
"ref:`types`.  (To summarize, the key type should be :term:`hashable`, which "
"excludes all mutable objects.)  Clashes between duplicate keys are not "
"detected; the last datum (textually rightmost in the display) stored for a "
"given key value prevails."
msgstr ""
"Las restricciones de los tipos de los valores de clave son listados "
"anteriormente en la sección :ref:`types`. (Para resumir, el tipo de la clave "
"debe ser :term:`hashable`, el cual excluye todos los objetos mutables.) No "
"se detectan choques entre claves duplicadas; el último dato (textualmente el "
"más a la derecha en el despliegue) almacenado para una clave dada prevalece."

#: ../Doc/reference/expressions.rst:339
msgid ""
"Prior to Python 3.8, in dict comprehensions, the evaluation order of key and "
"value was not well-defined.  In CPython, the value was evaluated before the "
"key.  Starting with 3.8, the key is evaluated before the value, as proposed "
"by :pep:`572`."
msgstr ""
"Antes de Python 3.8, en las comprensiones de diccionarios, el orden de "
"evaluación de clave y valor no fue bien definido. En CPython, el valor fue "
"evaluado antes de la clave. A partir de 3.8, la clave es evaluada antes que "
"el valor, como fue propuesto por :pep:`572`."

#: ../Doc/reference/expressions.rst:349
msgid "Generator expressions"
msgstr "Expresiones de generador"

#: ../Doc/reference/expressions.rst:356
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr ""
"Una expresión de generador es una notación compacta de generador en "
"paréntesis:"

#: ../Doc/reference/expressions.rst:361
msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr ""
"Una expresión de generador produce un nuevo objeto generador. Su sintaxis es "
"la misma que para las comprensiones, excepto que es encerrado en paréntesis "
"en lugar de corchetes o llaves."

#: ../Doc/reference/expressions.rst:365
msgid ""
"Variables used in the generator expression are evaluated lazily when the :"
"meth:`~generator.__next__` method is called for the generator object (in the "
"same fashion as normal generators).  However, the iterable expression in the "
"leftmost :keyword:`!for` clause is immediately evaluated, so that an error "
"produced by it will be emitted at the point where the generator expression "
"is defined, rather than at the point where the first value is retrieved. "
"Subsequent :keyword:`!for` clauses and any filter condition in the leftmost :"
"keyword:`!for` clause cannot be evaluated in the enclosing scope as they may "
"depend on the values obtained from the leftmost iterable. For example: "
"``(x*y for x in range(10) for y in range(x, x+10))``."
msgstr ""
"Las variables usadas en la expresión de generador son evaluadas "
"perezosamente cuando se ejecuta el método :meth:`~generator.__next__` para "
"el objeto generador (de la misma forma que los generadores normales). Sin "
"embargo, la expresión iterable en la cláusula :keyword:`!for` más a la "
"izquierda es inmediatamente evaluada, de forma que un error producido por "
"ella será emitido en el punto en el que se define la expresión de generador, "
"en lugar de en el punto donde se obtiene el primer valor. Subsecuentes "
"cláusulas :keyword:`!for` y cualquier condición en la cláusula :keyword:`!"
"for` más a la izquierda no pueden ser evaluadas en el alcance adjunto, ya "
"que puede depender de los valores obtenidos por el iterable de más a la "
"izquierda. Por ejemplo: ``(x*y for x in range(10) for y in range(x, x+10))``."

#: ../Doc/reference/expressions.rst:376
msgid ""
"The parentheses can be omitted on calls with only one argument.  See "
"section :ref:`calls` for details."
msgstr ""
"Los paréntesis pueden ser omitidos en ejecuciones con un solo argumento. Vea "
"la sección :ref:`calls` para más detalles."

#: ../Doc/reference/expressions.rst:379
msgid ""
"To avoid interfering with the expected operation of the generator expression "
"itself, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly defined generator."
msgstr ""
"Para evitar interferir con la operación esperada de la expresión misma del "
"generador, las expresiones ``yield`` y ``yield from`` están prohibidas en el "
"generador definido implícitamente."

#: ../Doc/reference/expressions.rst:383
msgid ""
"If a generator expression contains either :keyword:`!async for` clauses or :"
"keyword:`await` expressions it is called an :dfn:`asynchronous generator "
"expression`.  An asynchronous generator expression returns a new "
"asynchronous generator object, which is an asynchronous iterator (see :ref:"
"`async-iterators`)."
msgstr ""
"Si una expresión de generador contiene cláusulas :keyword:`!async for` o "
"expresiones :keyword:`await`, se ejecuta una :dfn:`asynchronous generator "
"expression`. Una expresión de generador asincrónica retorna un nuevo objeto "
"de generador asincrónico, el cual es un iterador asincrónico (ver :ref:"
"`async-iterators`)."

#: ../Doc/reference/expressions.rst:389
msgid "Asynchronous generator expressions were introduced."
msgstr "Las expresiones de generador asincrónico fueron introducidas."

#: ../Doc/reference/expressions.rst:392
msgid ""
"Prior to Python 3.7, asynchronous generator expressions could only appear "
"in :keyword:`async def` coroutines.  Starting with 3.7, any function can use "
"asynchronous generator expressions."
msgstr ""
"Antes de Python 3.7, las expresiones de generador asincrónico podrían "
"aparecer sólo en corrutinas :keyword:`async def`. Desde 3.7, cualquier "
"función puede usar expresiones de generador asincrónico."

#: ../Doc/reference/expressions.rst:404
msgid "Yield expressions"
msgstr "Expresiones yield"

#: ../Doc/reference/expressions.rst:416
msgid ""
"The yield expression is used when defining a :term:`generator` function or "
"an :term:`asynchronous generator` function and thus can only be used in the "
"body of a function definition.  Using a yield expression in a function's "
"body causes that function to be a generator, and using it in an :keyword:"
"`async def` function's body causes that coroutine function to be an "
"asynchronous generator. For example::"
msgstr ""
"La expresión yield se usa al definir una función :term:`generator` o una "
"función :term:`asynchronous generator` y, por lo tanto, solo se puede usar "
"en el cuerpo de una definición de función. Usar una expresión yield en el "
"cuerpo de una función hace que esa función sea un generador y usarla en el "
"cuerpo de una función :keyword:`async def` hace que la función de corrutina "
"sea un generador asincrónico. Por ejemplo::"

#: ../Doc/reference/expressions.rst:429
msgid ""
"Due to their side effects on the containing scope, ``yield`` expressions are "
"not permitted as part of the implicitly defined scopes used to implement "
"comprehensions and generator expressions."
msgstr ""
"Debido a sus efectos secundarios sobre el alcance contenedor, las "
"expresiones ``yield`` no están permitidas como parte de los alcances "
"implícitamente definidos usados para implementar comprensiones y expresiones "
"de generador."

#: ../Doc/reference/expressions.rst:433
msgid ""
"Yield expressions prohibited in the implicitly nested scopes used to "
"implement comprehensions and generator expressions."
msgstr ""
"Expresiones yield prohibidas en los ámbitos anidados implícitamente "
"utilizados para implementar comprensiones y expresiones de generador."

#: ../Doc/reference/expressions.rst:437
msgid ""
"Generator functions are described below, while asynchronous generator "
"functions are described separately in section :ref:`asynchronous-generator-"
"functions`."
msgstr ""
"Las funciones generadoras son descritas a continuación, mientras que las "
"funciones generadoras asincrónicas son descritas separadamente en la "
"sección :ref:`asynchronous-generator-functions`."

#: ../Doc/reference/expressions.rst:441
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of the generator "
"function. The execution starts when one of the generator's methods is "
"called.  At that time, the execution proceeds to the first yield expression, "
"where it is suspended again, returning the value of :token:`expression_list` "
"to the generator's caller.  By suspended, we mean that all local state is "
"retained, including the current bindings of local variables, the instruction "
"pointer, the internal evaluation stack, and the state of any exception "
"handling.  When the execution is resumed by calling one of the generator's "
"methods, the function can proceed exactly as if the yield expression were "
"just another external call.  The value of the yield expression after "
"resuming depends on the method which resumed the execution.  If :meth:"
"`~generator.__next__` is used (typically via either a :keyword:`for` or the :"
"func:`next` builtin) then the result is :const:`None`.  Otherwise, if :meth:"
"`~generator.send` is used, then the result will be the value passed in to "
"that method."
msgstr ""
"Cuando una función generadora es invocada, retorna un iterador conocido como "
"un generador. Este generador controla la ejecución de la función generadora. "
"La ejecución empieza cuando uno de los métodos del generador es invocado. En "
"ese momento, la ejecución procede a la primera expresión yield, donde es "
"suspendida de nuevo, retornando el valor de :token:`expression_list` al "
"invocador del generador. Por suspendido, nos referimos a que se retiene todo "
"el estado local, incluyendo los enlaces actuales de variables locales, el "
"puntero de instrucción, la pila de evaluación interna y el estado de "
"cualquier manejo de excepción. Cuando la ejecución se reanuda al invocar uno "
"de los métodos del generador, la función puede proceder como si la expresión "
"yield fuera sólo otra invocación externa. El valor de la expresión yield "
"después de la reanudación depende del método que ha reanudado la ejecución. "
"Si se usa :meth:`~generator.__next__` (típicamente mediante un :keyword:"
"`for` o la función incorporada :func:`next`) entonces el resultado es :const:"
"`None`. De otra forma, si se usa :meth:`~generator.send`, entonces el "
"resultado será el valor pasado a ese método."

#: ../Doc/reference/expressions.rst:460
msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where the execution should continue after it yields; "
"the control is always transferred to the generator's caller."
msgstr ""
"Todo este hace a las funciones generadores similar a las corrutinas; "
"producen múltiples veces, tienen más de un punto de entrada y su ejecución "
"puede ser suspendida. La única diferencia es que una función generadora no "
"puede controlar si la ejecución debe continuar después de producir; el "
"control siempre es transferido al invocador del generador."

#: ../Doc/reference/expressions.rst:466
msgid ""
"Yield expressions are allowed anywhere in a :keyword:`try` construct.  If "
"the generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), the generator-iterator's :"
"meth:`~generator.close` method will be called, allowing any pending :keyword:"
"`finally` clauses to execute."
msgstr ""
"Las expresiones yield están permitidas en cualquier lugar en un constructo :"
"keyword:`try`. Si el generador no es reanudado antes de finalizar "
"(alcanzando un recuento de referencia cero o colectando basura), el método "
"generador-iterador :meth:`~generator.close` será invocado, permitiendo la "
"ejecución de cualquier cláusula :keyword:`finally` pendiente."

#: ../Doc/reference/expressions.rst:475
msgid ""
"When ``yield from <expr>`` is used, it treats the supplied expression as a "
"subiterator. All values produced by that subiterator are passed directly to "
"the caller of the current generator's methods. Any values passed in with :"
"meth:`~generator.send` and any exceptions passed in with :meth:`~generator."
"throw` are passed to the underlying iterator if it has the appropriate "
"methods.  If this is not the case, then :meth:`~generator.send` will raise :"
"exc:`AttributeError` or :exc:`TypeError`, while :meth:`~generator.throw` "
"will just raise the passed in exception immediately."
msgstr ""
"Cuando se usa ``yield from <expr>``, esto trata a la expresión provista como "
"un subiterador. Todos los valores producidos por ese subiterador son pasados "
"directamente al invocador de los métodos del generador actual. Cualquiera de "
"los valores pasados con :meth:`~generator.send` y cualquiera de las "
"excepciones pasadas con :meth:`~generator.throw` son pasados al iterador "
"subyacente si tiene los métodos apropiados. Si este no es el caso, entonces :"
"meth:`~generator.send` generará :exc:`AttributeError` o :exc:`TypeError`, "
"mientras :meth:`~generator.throw` sólo generará inmediatamente la excepción "
"pasada."

#: ../Doc/reference/expressions.rst:484
msgid ""
"When the underlying iterator is complete, the :attr:`~StopIteration.value` "
"attribute of the raised :exc:`StopIteration` instance becomes the value of "
"the yield expression. It can be either set explicitly when raising :exc:"
"`StopIteration`, or automatically when the subiterator is a generator (by "
"returning a value from the subgenerator)."
msgstr ""
"Cuando el iterador subyacente está completo, el atributo :attr:"
"`~StopIteration.value` de la instancia :exc:`StopIteration` generada se "
"convierte en el valor de la expresión yield. Puede ser establecido "
"explícitamente al generar :exc:`StopIteration` o automáticamente cuando el "
"subiterador es un generador (retornando un valor del subgenerador)."

#: ../Doc/reference/expressions.rst:490
msgid "Added ``yield from <expr>`` to delegate control flow to a subiterator."
msgstr ""
"Añadido ``yield from <expr>`` para delegar el control de flujo a un "
"subiterador."

#: ../Doc/reference/expressions.rst:493
msgid ""
"The parentheses may be omitted when the yield expression is the sole "
"expression on the right hand side of an assignment statement."
msgstr ""
"Los paréntesis pueden ser omitidos cuando la expresión yield es la única "
"expresión en el lado derecho de una sentencia de asignación."

#: ../Doc/reference/expressions.rst:499
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - Generadores Simples"

#: ../Doc/reference/expressions.rst:499
msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr ""
"La propuesta para añadir generadores y la sentencia :keyword:`yield` a "
"Python."

#: ../Doc/reference/expressions.rst:503
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`342` - Corrutinas mediante Generadores Mejorados"

#: ../Doc/reference/expressions.rst:502
msgid ""
"The proposal to enhance the API and syntax of generators, making them usable "
"as simple coroutines."
msgstr ""
"La propuesta para mejorar la API y la sintaxis de generadores, haciéndolos "
"utilizables como corrutinas simples."

#: ../Doc/reference/expressions.rst:507
msgid ":pep:`380` - Syntax for Delegating to a Subgenerator"
msgstr ":pep:`380` - Sintaxis para Delegar a un Subgenerador"

#: ../Doc/reference/expressions.rst:506
msgid ""
"The proposal to introduce the :token:`yield_from` syntax, making delegation "
"to subgenerators easy."
msgstr ""
"La propuesta para introducir la sintaxis :token:`yield_from`, facilitando la "
"delegación a subgeneradores."

#: ../Doc/reference/expressions.rst:510
msgid ":pep:`525` - Asynchronous Generators"
msgstr ":pep:`525`- Generadores Asincrónicos"

#: ../Doc/reference/expressions.rst:510
msgid ""
"The proposal that expanded on :pep:`492` by adding generator capabilities to "
"coroutine functions."
msgstr ""
"La propuesta que expandió :pep:`492` añadiendo capacidades de generador a "
"las funciones corrutina."

#: ../Doc/reference/expressions.rst:517
msgid "Generator-iterator methods"
msgstr "Métodos generador-iterador"

#: ../Doc/reference/expressions.rst:519
msgid ""
"This subsection describes the methods of a generator iterator.  They can be "
"used to control the execution of a generator function."
msgstr ""
"Esta subsección describe los métodos de un generador iterador. Estos pueden "
"ser usados para controlar la ejecución de una función generadora."

#: ../Doc/reference/expressions.rst:522
msgid ""
"Note that calling any of the generator methods below when the generator is "
"already executing raises a :exc:`ValueError` exception."
msgstr ""
"Tenga en cuenta que invocar cualquiera de los métodos de generador "
"siguientes cuando el generador está todavía en ejecución genera una "
"excepción :exc:`ValueError`."

#: ../Doc/reference/expressions.rst:530
msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed yield expression.  When a generator function is resumed with a :"
"meth:`~generator.__next__` method, the current yield expression always "
"evaluates to :const:`None`.  The execution then continues to the next yield "
"expression, where the generator is suspended again, and the value of the :"
"token:`expression_list` is returned to :meth:`__next__`'s caller.  If the "
"generator exits without yielding another value, a :exc:`StopIteration` "
"exception is raised."
msgstr ""
"Comienza la ejecución de una función generadora o la reanuda en la última "
"expresión yield ejecutada. Cuando una función generadora es reanudada con un "
"método :meth:`~generator.__next__`, la expresión yield actual siempre evalúa "
"a :const:`None`. La ejecución entonces continúa a la siguiente expresión "
"yield, donde el generador se suspende de nuevo y el valor de :token:"
"`expression_list` se retorna al invocador de :meth:`__next__`. Si el "
"generador termina sin producir otro valor, se genera una excepción :exc:"
"`StopIteration`."

#: ../Doc/reference/expressions.rst:539
msgid ""
"This method is normally called implicitly, e.g. by a :keyword:`for` loop, or "
"by the built-in :func:`next` function."
msgstr ""
"Este método es normalmente invocado implícitamente, por ejemplo, por un "
"bucle :keyword:`for` o por la función incorporada :func:`next`."

#: ../Doc/reference/expressions.rst:545
msgid ""
"Resumes the execution and \"sends\" a value into the generator function.  "
"The *value* argument becomes the result of the current yield expression.  "
"The :meth:`send` method returns the next value yielded by the generator, or "
"raises :exc:`StopIteration` if the generator exits without yielding another "
"value.  When :meth:`send` is called to start the generator, it must be "
"called with :const:`None` as the argument, because there is no yield "
"expression that could receive the value."
msgstr ""
"Reanuda la ejecución y \"envía\" un valor dentro de la función generadora. "
"El argumento *value* se convierte en el resultado de la expresión yield "
"actual. El método :meth:`send` retorna el siguiente valor producido por el "
"generador o genera :exc:`StopIteration` si el generador termina sin producir "
"otro valor. Cuando se ejecuta :meth:`send` para comenzar el generador, debe "
"ser invocado con :const:`None` como el argumento, debido a que no hay "
"expresión yield que pueda recibir el valor."

#: ../Doc/reference/expressions.rst:556
msgid ""
"Raises an exception of type ``type`` at the point where the generator was "
"paused, and returns the next value yielded by the generator function.  If "
"the generator exits without yielding another value, a :exc:`StopIteration` "
"exception is raised.  If the generator function does not catch the passed-in "
"exception, or raises a different exception, then that exception propagates "
"to the caller."
msgstr ""
"Genera una excepción de tipo ``type`` en el punto donde el generador fue "
"pausado y retorna el siguiente valor producido por la función generadora. Si "
"el generador termina sin producir otro valor se genera una excepción :exc:"
"`StopIteration`. Si la función generadora no caza la excepción pasada o "
"genera una excepción diferente, entonces se propaga esa excepción al "
"invocador."

#: ../Doc/reference/expressions.rst:567
msgid ""
"Raises a :exc:`GeneratorExit` at the point where the generator function was "
"paused.  If the generator function then exits gracefully, is already closed, "
"or raises :exc:`GeneratorExit` (by not catching the exception), close "
"returns to its caller.  If the generator yields a value, a :exc:"
"`RuntimeError` is raised.  If the generator raises any other exception, it "
"is propagated to the caller.  :meth:`close` does nothing if the generator "
"has already exited due to an exception or normal exit."
msgstr ""
"Genera :exc:`GeneratorExit` en el punto donde la función generadora fue "
"pausada. Si la función generadora termina sin errores, está ya cerrada o "
"genera :exc:`GeneratorExit` (sin cazar la excepción), close retorna a su "
"invocador. Si el generador produce un valor, se genera un :exc:"
"`RuntimeError`. Si el generador genera cualquier otra excepción, es "
"propagado al invocador. :meth:`close` no hace nada si el generador ya fue "
"terminado debido a una excepción o una salida normal."

#: ../Doc/reference/expressions.rst:578
msgid "Examples"
msgstr "Ejemplos"

#: ../Doc/reference/expressions.rst:580
msgid ""
"Here is a simple example that demonstrates the behavior of generators and "
"generator functions::"
msgstr ""
"Aquí hay un ejemplo simple que demuestra el comportamiento de generadores y "
"funciones generadoras:"

#: ../Doc/reference/expressions.rst:607
msgid ""
"For examples using ``yield from``, see :ref:`pep-380` in \"What's New in "
"Python.\""
msgstr ""
"Para ejemplos usando ``yield from``, ver :ref:`pep-380` en \"Qué es nuevo en "
"Python.\""

#: ../Doc/reference/expressions.rst:613
msgid "Asynchronous generator functions"
msgstr "Funciones generadoras asincrónicas"

#: ../Doc/reference/expressions.rst:615
msgid ""
"The presence of a yield expression in a function or method defined using :"
"keyword:`async def` further defines the function as an :term:`asynchronous "
"generator` function."
msgstr ""
"La presencia de una expresión yield en una función o método definido usando :"
"keyword:`async def` adicionalmente define la función como una función :term:"
"`asynchronous generator`."

#: ../Doc/reference/expressions.rst:619
msgid ""
"When an asynchronous generator function is called, it returns an "
"asynchronous iterator known as an asynchronous generator object. That object "
"then controls the execution of the generator function. An asynchronous "
"generator object is typically used in an :keyword:`async for` statement in a "
"coroutine function analogously to how a generator object would be used in a :"
"keyword:`for` statement."
msgstr ""
"Cuando se invoca una función generadora asincrónica, retorna un iterador "
"asincrónico conocido como un objeto generador asincrónico. Este objeto "
"entonces controla la ejecución de la función generadora. Un objeto generador "
"asincrónico se usa típicamente en una sentencia :keyword:`async for` en una "
"función corrutina análogamente a como sería usado un objeto generador en una "
"sentencia :keyword:`for`."

#: ../Doc/reference/expressions.rst:626
msgid ""
"Calling one of the asynchronous generator's methods returns an :term:"
"`awaitable` object, and the execution starts when this object is awaited on. "
"At that time, the execution proceeds to the first yield expression, where it "
"is suspended again, returning the value of :token:`expression_list` to the "
"awaiting coroutine. As with a generator, suspension means that all local "
"state is retained, including the current bindings of local variables, the "
"instruction pointer, the internal evaluation stack, and the state of any "
"exception handling.  When the execution is resumed by awaiting on the next "
"object returned by the asynchronous generator's methods, the function can "
"proceed exactly as if the yield expression were just another external call. "
"The value of the yield expression after resuming depends on the method which "
"resumed the execution.  If :meth:`~agen.__anext__` is used then the result "
"is :const:`None`. Otherwise, if :meth:`~agen.asend` is used, then the result "
"will be the value passed in to that method."
msgstr ""
"Invocar uno de los métodos de un generador asincrónico retorna un objeto :"
"term:`awaitable` y la ejecución comienza cuando este objeto es esperado. En "
"ese momento, la ejecución avanza a la primera expresión yield, donde es "
"suspendida de nuevo, retornando el valor de :token:`expression_list` a la "
"corrutina en espera. Como con un generador, la suspensión significa que todo "
"el estado local es retenido, incluyendo los enlaces actuales de variables "
"locales, el puntero de instrucción, la pila de evaluación interna y el "
"estado de cualquier manejo de excepción. Cuando se reanuda la ejecución al "
"espera al siguiente objeto retornado por los métodos del generador "
"asincrónico, la función puede avanzar exactamente igual que si la expresión "
"yield fuera otra invocación externa. El valor de la expresión yield después "
"de la reanudación dependen del método que ha resumido la ejecución. Si se "
"usa :meth:`~agen.__anext__` entonces el resultado es :const:`None`. De otra "
"forma, si se usa :meth:`~agen.asend`, entonces el resultado será el valor "
"pasado a ese método."

#: ../Doc/reference/expressions.rst:642
msgid ""
"In an asynchronous generator function, yield expressions are allowed "
"anywhere in a :keyword:`try` construct. However, if an asynchronous "
"generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), then a yield expression "
"within a :keyword:`!try` construct could result in a failure to execute "
"pending :keyword:`finally` clauses.  In this case, it is the responsibility "
"of the event loop or scheduler running the asynchronous generator to call "
"the asynchronous generator-iterator's :meth:`~agen.aclose` method and run "
"the resulting coroutine object, thus allowing any pending :keyword:`!"
"finally` clauses to execute."
msgstr ""
"En una función generadora asincrónica, las expresiones yield están "
"permitidas en cualquier lugar de un constructo :keyword:`try`. Sin embargo, "
"si un generador asincrónico no es reanudado antes de finalizar (alcanzando "
"un contador de referencia cero o recogiendo basura), entonces una expresión "
"yield dentro de un constructo :keyword:`!try` podría fallar al ejecutar "
"cláusulas :keyword:`finally` pendientes. En este caso, es responsabilidad "
"del bucle de eventos o del planificador ejecutando el generador asincrónico "
"invocar el método :meth:`~agen.aclose` del generador-iterador asincrónico y "
"ejecutar el objeto corrutina resultante, permitiendo así la ejecución de "
"cualquier cláusula :keyword:`!finally` pendiente."

#: ../Doc/reference/expressions.rst:653
msgid ""
"To take care of finalization, an event loop should define a *finalizer* "
"function which takes an asynchronous generator-iterator and presumably "
"calls :meth:`~agen.aclose` and executes the coroutine. This  *finalizer* may "
"be registered by calling :func:`sys.set_asyncgen_hooks`. When first iterated "
"over, an asynchronous generator-iterator will store the registered "
"*finalizer* to be called upon finalization. For a reference example of a "
"*finalizer* method see the implementation of ``asyncio.Loop."
"shutdown_asyncgens`` in :source:`Lib/asyncio/base_events.py`."
msgstr ""
"Para encargarse de la finalización, un bucle de eventos debe definir una "
"función *finalizadora* la cual toma un generador-iterador asincrónico y "
"presumiblemente invoca :meth:`~agen.aclose` y ejecuta la corrutina. Este "
"*finalizador* puede ser registrado invocando :func:`sys.set_asyncgen_hooks`. "
"Cuando es iterada por primera vez, un generador-iterador asincrónico "
"almacenará el *finalizador* registrado para ser invocado en la finalización. "
"Para un ejemplo de referencia de un método *finalizador* vea la "
"implementación de ``asyncio.Loop.shutdown_asyncgens`` en :source:`Lib/"
"asyncio/base_events.py`."

#: ../Doc/reference/expressions.rst:662
msgid ""
"The expression ``yield from <expr>`` is a syntax error when used in an "
"asynchronous generator function."
msgstr ""
"La expresión ``yield from <expr>`` es un error de sintaxis cuando es usada "
"en una función generadora asincrónica."

#: ../Doc/reference/expressions.rst:669
msgid "Asynchronous generator-iterator methods"
msgstr "Métodos asincrónicos de generador-iterador"

#: ../Doc/reference/expressions.rst:671
msgid ""
"This subsection describes the methods of an asynchronous generator iterator, "
"which are used to control the execution of a generator function."
msgstr ""
"Esta subsección describe los métodos de un generador iterador asincrónico, "
"los cuales son usados para controlar la ejecución de una función generadora."

#: ../Doc/reference/expressions.rst:679
msgid ""
"Returns an awaitable which when run starts to execute the asynchronous "
"generator or resumes it at the last executed yield expression.  When an "
"asynchronous generator function is resumed with an :meth:`~agen.__anext__` "
"method, the current yield expression always evaluates to :const:`None` in "
"the returned awaitable, which when run will continue to the next yield "
"expression. The value of the :token:`expression_list` of the yield "
"expression is the value of the :exc:`StopIteration` exception raised by the "
"completing coroutine.  If the asynchronous generator exits without yielding "
"another value, the awaitable instead raises a :exc:`StopAsyncIteration` "
"exception, signalling that the asynchronous iteration has completed."
msgstr ""
"Retorna un esperable el cual, cuando corre, comienza a ejecutar el generador "
"asincrónico o lo reanuda en la última expresión yield ejecutada. Cuando se "
"reanuda una función generadora asincrónica con un método :meth:`~agen."
"__anext__`, la expresión yield actual siempre evalúa a :const:`None` en el "
"esperable retornado, el cual cuando corre continuará a la siguiente "
"expresión yield. El valor de :token:`expression_list` de la expresión yield "
"es el valor de la excepción :exc:`StopIteration` generada por la corrutina "
"completa. Si el generador asincrónico termina sin producir otro valor, el "
"esperable en su lugar genera una excepción :exc:`StopAsyncIteration`, "
"señalando que la iteración asincrónica se ha completado."

#: ../Doc/reference/expressions.rst:691
msgid ""
"This method is normally called implicitly by a :keyword:`async for` loop."
msgstr ""
"Este método es invocado normalmente de forma implícita por un bucle :keyword:"
"`async for`."

#: ../Doc/reference/expressions.rst:696
msgid ""
"Returns an awaitable which when run resumes the execution of the "
"asynchronous generator. As with the :meth:`~generator.send()` method for a "
"generator, this \"sends\" a value into the asynchronous generator function, "
"and the *value* argument becomes the result of the current yield expression. "
"The awaitable returned by the :meth:`asend` method will return the next "
"value yielded by the generator as the value of the raised :exc:"
"`StopIteration`, or raises :exc:`StopAsyncIteration` if the asynchronous "
"generator exits without yielding another value.  When :meth:`asend` is "
"called to start the asynchronous generator, it must be called with :const:"
"`None` as the argument, because there is no yield expression that could "
"receive the value."
msgstr ""
"Retorna un esperable el cual cuando corre reanuda la ejecución del generador "
"asincrónico. Como el método :meth:`~generator.send()` para un generador, "
"este \"envía\" un valor a la función generadora asincrónica y el argumento "
"*value* se convierte en el resultado de la expresión yield actual. El "
"esperable retornado por el método :meth:`asend` retornará el siguiente valor "
"producido por el generador como el valor de la :exc:`StopIteration` generada "
"o genera :exc:`StopAsyncIteration` si el generador asincrónico termina sin "
"producir otro valor. Cuando se invoca :meth:`asend` para empezar el "
"generador asincrónico, debe ser invocado con :const:`None` como argumento, "
"porque no hay expresión yield que pueda recibir el valor."

#: ../Doc/reference/expressions.rst:711
msgid ""
"Returns an awaitable that raises an exception of type ``type`` at the point "
"where the asynchronous generator was paused, and returns the next value "
"yielded by the generator function as the value of the raised :exc:"
"`StopIteration` exception.  If the asynchronous generator exits without "
"yielding another value, a :exc:`StopAsyncIteration` exception is raised by "
"the awaitable. If the generator function does not catch the passed-in "
"exception, or raises a different exception, then when the awaitable is run "
"that exception propagates to the caller of the awaitable."
msgstr ""
"Retorna un esperable que genera una excepción de tipo ``type`` en el punto "
"donde el generador asincrónico fue pausado y retorna el siguiente valor "
"producido por la función generadora como el valor de la excepción :exc:"
"`StopIteration` generada. Si el generador asincrónico termina sin producir "
"otro valor, el esperable genera una excepción :exc:`StopAsyncIteration`. Si "
"la función generadora no caza la excepción pasada o genera una excepción "
"diferente, entonces cuando se ejecuta el esperable esa excepción se propaga "
"al invocador del esperable."

#: ../Doc/reference/expressions.rst:726
msgid ""
"Returns an awaitable that when run will throw a :exc:`GeneratorExit` into "
"the asynchronous generator function at the point where it was paused. If the "
"asynchronous generator function then exits gracefully, is already closed, or "
"raises :exc:`GeneratorExit` (by not catching the exception), then the "
"returned awaitable will raise a :exc:`StopIteration` exception. Any further "
"awaitables returned by subsequent calls to the asynchronous generator will "
"raise a :exc:`StopAsyncIteration` exception.  If the asynchronous generator "
"yields a value, a :exc:`RuntimeError` is raised by the awaitable.  If the "
"asynchronous generator raises any other exception, it is propagated to the "
"caller of the awaitable.  If the asynchronous generator has already exited "
"due to an exception or normal exit, then further calls to :meth:`aclose` "
"will return an awaitable that does nothing."
msgstr ""
"Retorna un esperable que cuando corre lanza un :exc:`GeneratorExit` a la "
"función generadora asincrónica en el punto donde fue pausada. Si la función "
"generadora asincrónica termina exitosamente, ya está cerrada o genera  :exc:"
"`GeneratorExit` (sin cazar la excepción), el esperable retornado generará "
"una excepción :exc:`StopIteration`. Otros esperables retornados por "
"subsecuentes invocaciones al generador asincrónico generarán una excepción :"
"exc:`StopAsyncIteration`. Si el generador asincrónico produce un valor, el "
"esperable genera un :exc:`RuntimeError`. Si el generador asincrónico genera "
"cualquier otra excepción, esta es propagada al invocador del esperable. Si "
"el generador asincrónico ha terminado debido a una excepción o una "
"terminación normal, entonces futuras invocaciones a :meth:`aclose` "
"retornarán un esperable que no hace nada."

#: ../Doc/reference/expressions.rst:742
msgid "Primaries"
msgstr "Primarios"

#: ../Doc/reference/expressions.rst:746
msgid ""
"Primaries represent the most tightly bound operations of the language. Their "
"syntax is:"
msgstr ""
"Los primarios representan las operaciones más fuertemente ligadas al "
"lenguaje. Su sintaxis es:"

#: ../Doc/reference/expressions.rst:756
msgid "Attribute references"
msgstr "Referencias de atributos"

#: ../Doc/reference/expressions.rst:762
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr ""
"Una referencia de atributo es un primario seguido de un punto y un nombre:"

#: ../Doc/reference/expressions.rst:772
msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, which most objects do.  This object is then asked to produce the "
"attribute whose name is the identifier.  This production can be customized "
"by overriding the :meth:`__getattr__` method.  If this attribute is not "
"available, the exception :exc:`AttributeError` is raised.  Otherwise, the "
"type and value of the object produced is determined by the object.  Multiple "
"evaluations of the same attribute reference may yield different objects."
msgstr ""
"El primario debe evaluar a un objeto de un tipo que soporte referencias de "
"atributos, lo cual la mayoría de los objetos soportan. Luego se le pide a "
"este objeto que produzca el atributo cuyo nombre es el identificador. Esta "
"producción puede ser personalizada sobrescribiendo el método :meth:"
"`__getattr__`. Si este atributo no es esperable, se genera la excepción :exc:"
"`AtributeError`. De otra forma, el tipo y el valor del objeto producido es "
"determinado por el objeto. Múltiples evaluaciones la misma referencia de "
"atributo pueden producir diferentes objetos."

#: ../Doc/reference/expressions.rst:784
msgid "Subscriptions"
msgstr "Suscripciones"

#: ../Doc/reference/expressions.rst:799
msgid ""
"A subscription selects an item of a sequence (string, tuple or list) or "
"mapping (dictionary) object:"
msgstr ""
"Una subscripción selecciona un elemento de una objeto secuencia (cadena de "
"caracteres, tupla o lista) o mapeo (diccionario):"

#: ../Doc/reference/expressions.rst:805
msgid ""
"The primary must evaluate to an object that supports subscription (lists or "
"dictionaries for example).  User-defined objects can support subscription by "
"defining a :meth:`__getitem__` method."
msgstr ""
"El primario debe evaluar a un objeto que soporta subscripción (listas o "
"diccionarios por ejemplo). Los objetos definidos por usuarios pueden "
"soportar subscripción definiendo un método :meth:`__getitem__`."

#: ../Doc/reference/expressions.rst:809
msgid ""
"For built-in objects, there are two types of objects that support "
"subscription:"
msgstr ""
"Para objetos incorporados, hay dos tipos de objetos que soportan "
"subscripción:"

#: ../Doc/reference/expressions.rst:811
msgid ""
"If the primary is a mapping, the expression list must evaluate to an object "
"whose value is one of the keys of the mapping, and the subscription selects "
"the value in the mapping that corresponds to that key.  (The expression list "
"is a tuple except if it has exactly one item.)"
msgstr ""
"Si el primario es un mapeo, la expresión de lista debe evaluar a un objeto "
"cuyo valor es una de las claves del mapeo y la subscripción selecciona el "
"valor en el mapeo que corresponda a esa clave. (La expresión de lista es una "
"tupla excepto si tiene exactamente un elemento.)"

#: ../Doc/reference/expressions.rst:816
msgid ""
"If the primary is a sequence, the expression list must evaluate to an "
"integer or a slice (as discussed in the following section)."
msgstr ""
"Si el primario es una secuencia, la expresión de lista debe evaluar a un "
"entero o a un segmento (como es discutido en la siguiente sección)."

#: ../Doc/reference/expressions.rst:819
msgid ""
"The formal syntax makes no special provision for negative indices in "
"sequences; however, built-in sequences all provide a :meth:`__getitem__` "
"method that interprets negative indices by adding the length of the sequence "
"to the index (so that ``x[-1]`` selects the last item of ``x``).  The "
"resulting value must be a nonnegative integer less than the number of items "
"in the sequence, and the subscription selects the item whose index is that "
"value (counting from zero). Since the support for negative indices and "
"slicing occurs in the object's :meth:`__getitem__` method, subclasses "
"overriding this method will need to explicitly add that support."
msgstr ""
"La sintaxis formal no hace ninguna provisión especial para índices negativos "
"en secuencias; sin embargo, todas las secuencias incorporadas proveen un "
"método :meth:`__getitem__` que interpreta índices negativos añadiendo al "
"largo de la secuencia al índice (así es que ``x[-1]`` selecciona el último "
"elemento de ``x``). El valor resultante debe ser un entero no negativo menor "
"que el número de elementos en la secuencia y la subscripción selecciona el "
"elemento cuyo índice es ese valor (contando desde cero). Ya que el soporte "
"para índices negativos y el troceado ocurre en el método del objeto :meth:"
"`__getitem__`, las subclases que sobrescriben este método necesitarán añadir "
"explícitamente ese soporte."

#: ../Doc/reference/expressions.rst:833
msgid ""
"A string's items are characters.  A character is not a separate data type "
"but a string of exactly one character."
msgstr ""
"Los elementos de una cadena de caracteres son caracteres. Un caracter no es "
"un tipo de datos separado sino una cadena de exactamente un caracter."

#: ../Doc/reference/expressions.rst:840
msgid "Slicings"
msgstr "Segmentos"

#: ../Doc/reference/expressions.rst:854
msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""
"Un segmento selecciona un rango de elementos en una objeto secuencia (ej., "
"una cadena de caracteres, tupla o lista). Los segmentos pueden ser usados "
"como expresiones o como objetivos en asignaciones o sentencias :keyword:"
"`del`. La sintaxis para un segmento:"

#: ../Doc/reference/expressions.rst:867
msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an "
"expression list also looks like a slice list, so any subscription can be "
"interpreted as a slicing.  Rather than further complicating the syntax, this "
"is disambiguated by defining that in this case the interpretation as a "
"subscription takes priority over the interpretation as a slicing (this is "
"the case if the slice list contains no proper slice)."
msgstr ""
"Hay ambigüedad en la sintaxis formal aquí: todo lo que parezca una expresión "
"de lista también parece una segmento de lista, así que cualquier "
"subscripción puede ser interpretada como un segmento. En lugar de complicar "
"aún más la sintaxis, esta es desambiguada definiendo que en este caso la "
"interpretación como una subscripción toma prioridad sobre la interpretación "
"como un segmento (este es el caso si el segmento de lista no contiene un "
"segmento adecuado)."

#: ../Doc/reference/expressions.rst:879
msgid ""
"The semantics for a slicing are as follows.  The primary is indexed (using "
"the same :meth:`__getitem__` method as normal subscription) with a key that "
"is constructed from the slice list, as follows.  If the slice list contains "
"at least one comma, the key is a tuple containing the conversion of the "
"slice items; otherwise, the conversion of the lone slice item is the key.  "
"The conversion of a slice item that is an expression is that expression.  "
"The conversion of a proper slice is a slice object (see section :ref:"
"`types`) whose :attr:`~slice.start`, :attr:`~slice.stop` and :attr:`~slice."
"step` attributes are the values of the expressions given as lower bound, "
"upper bound and stride, respectively, substituting ``None`` for missing "
"expressions."
msgstr ""
"Las semánticas para un segmento son las siguientes. El primario es indexado "
"(usando el mismo método :meth:`__getitem__` de una subscripción normal) con "
"una clave que se construye del segmento de lista, tal como sigue. Si el "
"segmento de lista contiene al menos una coma, la clave es una tupla que "
"contiene la conversión de los elementos del segmento; de otra forma, la "
"conversión del segmento de lista solitario es la clave. La conversión de un "
"elemento de segmento que es una expresión es esa expresión. La conversión de "
"un segmento apropiado es un objeto segmento (ver sección :ref:`types`) cuyos "
"atributos :attr:`~slice.start`, :attr:`~slice.stop` y :attr:`~slice.step` "
"son los valores de las expresiones dadas como límite inferior, límite "
"superior y paso, respectivamente, substituyendo ``None`` para las "
"expresiones faltantes."

#: ../Doc/reference/expressions.rst:903
msgid "Calls"
msgstr "Invocaciones"

#: ../Doc/reference/expressions.rst:905
msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly "
"empty series of :term:`arguments <argument>`:"
msgstr ""
"Una invocación invoca un objeto invocable (ej., una :term:`function`) con "
"una serie posiblemente vacía de :term:`argumentos <argument>`:"

#: ../Doc/reference/expressions.rst:922
msgid ""
"An optional trailing comma may be present after the positional and keyword "
"arguments but does not affect the semantics."
msgstr ""
"Una coma final opcional puede estar presente después de los argumentos "
"posicionales y de palabra clave pero no afecta a las semánticas."

#: ../Doc/reference/expressions.rst:928
msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods of "
"class instances, and all objects having a :meth:`__call__` method are "
"callable).  All argument expressions are evaluated before the call is "
"attempted.  Please refer to section :ref:`function` for the syntax of "
"formal :term:`parameter` lists."
msgstr ""
"La clave primaria debe evaluar a un objeto invocable (funciones definidas "
"por el usuario, funciones incorporadas, métodos de objetos incorporados, "
"métodos de instancias de clases y todos los objetos que tienen un método :"
"meth:`__call__` son invocables). Todas las expresiones de argumento son "
"evaluadas antes de que la invocación sea intentada. Por favor, refiera a la "
"sección :ref:`function` para la sintaxis formal de listas de :term:"
"`parameter`."

#: ../Doc/reference/expressions.rst:936
msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for the "
"formal parameters.  If there are N positional arguments, they are placed in "
"the first N slots.  Next, for each keyword argument, the identifier is used "
"to determine the corresponding slot (if the identifier is the same as the "
"first formal parameter name, the first slot is used, and so on).  If the "
"slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, "
"the value of the argument is placed in the slot, filling it (even if the "
"expression is ``None``, it fills the slot).  When all arguments have been "
"processed, the slots that are still unfilled are filled with the "
"corresponding default value from the function definition.  (Default values "
"are calculated, once, when the function is defined; thus, a mutable object "
"such as a list or dictionary used as default value will be shared by all "
"calls that don't specify an argument value for the corresponding slot; this "
"should usually be avoided.)  If there are any unfilled slots for which no "
"default value is specified, a :exc:`TypeError` exception is raised.  "
"Otherwise, the list of filled slots is used as the argument list for the "
"call."
msgstr ""
"Si hay argumentos de palabra clave, primero se convierten en argumentos "
"posicionales, como se indica a continuación.  En primer lugar, se crea una "
"lista de ranuras sin rellenar para los parámetros formales.  Si hay N "
"argumentos posicionales, se colocan en las primeras N ranuras. A "
"continuación, para cada argumento de palabra clave, el identificador se "
"utiliza para determinar la ranura correspondiente (si el identificador es el "
"mismo que el primer nombre de parámetro formal, se utiliza la primera "
"ranura, etc.). Si la ranura ya está llena, se genera una excepción :exc:"
"`TypeError`. De lo contrario, el valor del argumento se coloca en la ranura, "
"llenándolo (incluso si la expresión es ``None``, esta llena la ranura). "
"Cuando se han procesado todos los argumentos, las ranuras que aún no han "
"sido rellenadas se rellenan con el valor predeterminado correspondiente de "
"la definición de función. (Los valores predeterminados son calculados una "
"vez, cuando se define la función; por lo tanto, un objeto mutable como una "
"lista o diccionario utilizado como valor predeterminado será compartido por "
"todas las llamadas que no especifican un valor de argumento para la ranura "
"correspondiente; esto normalmente debe ser evitado.) Si hay ranuras sin "
"rellenar para las que no se especifica ningún valor predeterminado, se "
"genera una excepción :exc:`TypeError`. De lo contrario, la lista de ranuras "
"rellenas se utiliza como la lista de argumentos para la llamada."

#: ../Doc/reference/expressions.rst:956
msgid ""
"An implementation may provide built-in functions whose positional parameters "
"do not have names, even if they are 'named' for the purpose of "
"documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use :c:func:"
"`PyArg_ParseTuple` to parse their arguments."
msgstr ""
"Una implementación puede proveer funciones incorporadas cuyos argumentos "
"posicionales no tienen nombres, incluso si son \"nombrados\" a efectos de "
"documentación y los cuales por consiguiente no pueden ser suplidos por "
"palabras clave. En CPython, este es el caso para funciones implementadas en "
"C que usan :c:func:`PyArg_ParseTuple` para analizar sus argumentos."

#: ../Doc/reference/expressions.rst:962
msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or an "
"empty tuple if there were no excess positional arguments)."
msgstr ""
"Si hay más argumentos posicionales que ranuras formales de parámetros, se "
"genera una excepción :exc:`TypeError`, a no ser que un parámetro formal "
"usando la sintaxis ``*identifier`` se encuentre presente; en este caso, ese "
"parámetro formal recibe una tupla conteniendo los argumentos posicionales "
"sobrantes (o una tupla vacía su no hay argumentos posicionales sobrantes)."

#: ../Doc/reference/expressions.rst:968
msgid ""
"If any keyword argument does not correspond to a formal parameter name, a :"
"exc:`TypeError` exception is raised, unless a formal parameter using the "
"syntax ``**identifier`` is present; in this case, that formal parameter "
"receives a dictionary containing the excess keyword arguments (using the "
"keywords as keys and the argument values as corresponding values), or a "
"(new) empty dictionary if there were no excess keyword arguments."
msgstr ""
"Si un argumento de palabra clave no corresponde a un nombre de parámetro "
"formal, se genera una excepción :exc:`TypeError`, a no ser que un parámetro "
"formal usando la sintaxis ``**identifier`` esté presente; en este caso, ese "
"parámetro formal recibe un diccionario que contiene los argumentos de "
"palabra clave sobrantes (usando las palabras clave como claves y los valores "
"de argumento como sus valores correspondientes), o un (nuevo) diccionario "
"vacío si no hay argumentos de palabra clave sobrantes."

#: ../Doc/reference/expressions.rst:979
msgid ""
"If the syntax ``*expression`` appears in the function call, ``expression`` "
"must evaluate to an :term:`iterable`.  Elements from these iterables are "
"treated as if they were additional positional arguments.  For the call "
"``f(x1, x2, *y, x3, x4)``, if *y* evaluates to a sequence *y1*, ..., *yM*, "
"this is equivalent to a call with M+4 positional arguments *x1*, *x2*, "
"*y1*, ..., *yM*, *x3*, *x4*."
msgstr ""
"Si la sintaxis ``*expression`` aparece en la invocación de función, "
"``expression`` debe evaluar a un :term:`iterable`. Elementos de esos "
"iterables son tratados como si fueran argumentos posicionales adicionales. "
"Para la invocación ``f(x1, x2, *y, x3, x4)``, si *y* evalúa a una secuencia "
"*y1*, ..., *yM*, equivale a una invocación con M+4 argumentos posicionales "
"*x1*, *x2*, *y1*, ..., *yM*, *x3*, *x4*."

#: ../Doc/reference/expressions.rst:986
msgid ""
"A consequence of this is that although the ``*expression`` syntax may appear "
"*after* explicit keyword arguments, it is processed *before* the keyword "
"arguments (and any ``**expression`` arguments -- see below).  So::"
msgstr ""
"Una consecuencia de esto es que aunque la sintaxis ``*expression`` puede "
"aparecer *después* de argumentos de palabra clave explícitos, es procesada "
"*antes* de los argumentos de palabra clave (y cualquiera de los argumentos "
"``*expression`` -- ver abajo). Así que::"

#: ../Doc/reference/expressions.rst:1002
msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax to "
"be used in the same call, so in practice this confusion does not arise."
msgstr ""
"Es inusual usar en la misma invocación tanto argumentos de palabra clave "
"como la sintaxis ``*expression``, así que en la práctica no surge esta "
"confusión."

#: ../Doc/reference/expressions.rst:1008
msgid ""
"If the syntax ``**expression`` appears in the function call, ``expression`` "
"must evaluate to a :term:`mapping`, the contents of which are treated as "
"additional keyword arguments.  If a keyword is already present (as an "
"explicit keyword argument, or from another unpacking), a :exc:`TypeError` "
"exception is raised."
msgstr ""
"Si la sintaxis ``*expression`` aparece en la invocación de función, "
"``expression`` debe evaluar a un :term:`mapping`, los contenidos del mismo "
"son tratados como argumentos de palabra clave adicionales. Si una palabra "
"clave está ya presente (como un argumento de palabra clave explícito o desde "
"otro desempaquetado), se genera una excepción :exc:`TypeError`."

#: ../Doc/reference/expressions.rst:1014
msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names."
msgstr ""
"No pueden ser usados parámetros formales usando la sintaxis ``*identifier`` "
"o ``**identifier`` como ranuras de argumentos posicionales o como nombres de "
"argumentos de palabra clave."

#: ../Doc/reference/expressions.rst:1017
msgid ""
"Function calls accept any number of ``*`` and ``**`` unpackings, positional "
"arguments may follow iterable unpackings (``*``), and keyword arguments may "
"follow dictionary unpackings (``**``). Originally proposed by :pep:`448`."
msgstr ""
"Las invocaciones de función aceptan cualquier número de desempaquetados "
"``*`` y ``**``, los argumentos posicionales pueden seguir a desempaquetados "
"de iterable (``*``) y los argumentos de palabra clave pueden seguir a "
"desempaquetados de diccionario (``*``). Originalmente propuesto por :pep:"
"`448`."

#: ../Doc/reference/expressions.rst:1023
msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the callable "
"object."
msgstr ""
"Una invocación siempre retorna algún valor, posiblemente ``None``, a no ser "
"que genere una excepción. Cómo se calcula este valor depende del tipo del "
"objeto invocable."

#: ../Doc/reference/expressions.rst:1027
msgid "If it is---"
msgstr "Si es---"

#: ../Doc/reference/expressions.rst:1040
msgid "a user-defined function:"
msgstr "una función definida por el usuario:"

#: ../Doc/reference/expressions.rst:1036
msgid ""
"The code block for the function is executed, passing it the argument list.  "
"The first thing the code block will do is bind the formal parameters to the "
"arguments; this is described in section :ref:`function`.  When the code "
"block executes a :keyword:`return` statement, this specifies the return "
"value of the function call."
msgstr ""
"Se ejecuta el bloque de código para la función, pasándole la lista de "
"argumentos. Lo primero que hace el bloque de código es enlazar los "
"parámetros formales a los argumentos; esto es descrito en la sección :ref:"
"`function`. Cuando el bloque de código ejecuta una sentencia :keyword:"
"`return`, esto especifica el valor de retorno de la invocación de función."

#: ../Doc/reference/expressions.rst:1054
msgid "a built-in function or method:"
msgstr "una función o método incorporado:"

#: ../Doc/reference/expressions.rst:1053
msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr ""
"El resultado depende del intérprete; ver :ref:`built-in-funcs` para las "
"descripciones de funciones y métodos incorporados."

#: ../Doc/reference/expressions.rst:1061
msgid "a class object:"
msgstr "un objeto de clase:"

#: ../Doc/reference/expressions.rst:1061
msgid "A new instance of that class is returned."
msgstr "Se retorna una nueva instancia de esa clase."

#: ../Doc/reference/expressions.rst:1071
msgid "a class instance method:"
msgstr "un método de una instancia de clase:"

#: ../Doc/reference/expressions.rst:1069
msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance becomes "
"the first argument."
msgstr ""
"Se invoca la función definida por el usuario correspondiente, con una lista "
"de argumentos con un largo uno mayor que la lista de argumentos de la "
"invocación: la instancia se convierte en el primer argumento."

#: ../Doc/reference/expressions.rst:1080
msgid "a class instance:"
msgstr "una instancia de clase:"

#: ../Doc/reference/expressions.rst:1078
msgid ""
"The class must define a :meth:`__call__` method; the effect is then the same "
"as if that method was called."
msgstr ""
"La clase debe definir un método :meth:`__call__`; el efecto es entonces el "
"mismo que si ese método fuera invocado."

#: ../Doc/reference/expressions.rst:1086 ../Doc/reference/expressions.rst:1834
msgid "Await expression"
msgstr "Expresión await"

#: ../Doc/reference/expressions.rst:1088
msgid ""
"Suspend the execution of :term:`coroutine` on an :term:`awaitable` object. "
"Can only be used inside a :term:`coroutine function`."
msgstr ""
"Suspende la ejecución de :term:`coroutine` o un objeto :term:`awaitable`. "
"Puede ser usado sólo dentro de una :term:`coroutine function`."

#: ../Doc/reference/expressions.rst:1100
msgid "The power operator"
msgstr "El operador de potencia"

#: ../Doc/reference/expressions.rst:1106
msgid ""
"The power operator binds more tightly than unary operators on its left; it "
"binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""
"El operador de potencia se vincula más estrechamente que los operadores "
"unarios a su izquierda; se vincula con menos fuerza que los operadores "
"unarios a su derecha. La sintaxis es:"

#: ../Doc/reference/expressions.rst:1112
msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""
"Por lo tanto, en una secuencia sin paréntesis de operadores unarios y de "
"potencia, los operadores son evaluados desde la derecha a la izquierda (este "
"no se constriñe al orden de evaluación para los operandos): ``-1**2`` "
"resulta en ``-1``."

#: ../Doc/reference/expressions.rst:1116
msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument raised "
"to the power of its right argument.  The numeric arguments are first "
"converted to a common type, and the result is of that type."
msgstr ""
"El operador de potencia tiene las mismas semánticas que la función "
"incorporada :func:`pow` cuando se invoca con dos argumentos: este produce su "
"argumento de la izquierda elevado a la potencia de su argumento de la "
"derecha. Los argumentos numéricos se convierten primero en un tipo común y "
"el resultado es de ese tipo."

#: ../Doc/reference/expressions.rst:1121
msgid ""
"For int operands, the result has the same type as the operands unless the "
"second argument is negative; in that case, all arguments are converted to "
"float and a float result is delivered. For example, ``10**2`` returns "
"``100``, but ``10**-2`` returns ``0.01``."
msgstr ""
"Para operandos int, el resultado tiene el mismo tipo que los operandos a no "
"ser que el segundo argumento sea negativo; en ese caso, todos los argumentos "
"son convertidos a float y se entrega un resultado float. Por ejemplo, "
"``10**2`` retorna ``100``, pero ``10**-2`` retorna ``0.01``."

#: ../Doc/reference/expressions.rst:1126
msgid ""
"Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. "
"Raising a negative number to a fractional power results in a :class:"
"`complex` number. (In earlier versions it raised a :exc:`ValueError`.)"
msgstr ""
"Elevar ``0.0`` a una potencia negativa resulta en un :exc:"
"`ZeroDivisionError`. Elevar un número negativo a una potencia fraccional "
"resulta en un número :class:`complex`. (En versiones anteriores se genera "
"un :exc:`ValueError`.)"

#: ../Doc/reference/expressions.rst:1134
msgid "Unary arithmetic and bitwise operations"
msgstr "Aritmética unaria y operaciones bit a bit"

#: ../Doc/reference/expressions.rst:1140
msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr ""
"Toda la aritmética unaria y las operaciones bit a bit tienen la misma "
"prioridad:"

#: ../Doc/reference/expressions.rst:1151
msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric argument."
msgstr ""
"El operador unario ``-`` (menos) produce la negación de su argumento "
"numérico."

#: ../Doc/reference/expressions.rst:1158
msgid "The unary ``+`` (plus) operator yields its numeric argument unchanged."
msgstr ""
"El operador unario ``+`` (más) produce su argumento numérico sin cambios."

#: ../Doc/reference/expressions.rst:1164
msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its "
"integer argument.  The bitwise inversion of ``x`` is defined as ``-(x+1)``.  "
"It only applies to integral numbers."
msgstr ""
"El operador unario ``~`` (invertir) produce la inversión bit a bit de su "
"argumento entero. La inversión bit a bit de ``x`` se define como ``-(x+1)``. "
"Sólo aplica a números integrales."

#: ../Doc/reference/expressions.rst:1170
msgid ""
"In all three cases, if the argument does not have the proper type, a :exc:"
"`TypeError` exception is raised."
msgstr ""
"En todos los tres casos, si el argumento no tiene el tipo apropiado, se "
"genera una excepción :exc:`TypeError`."

#: ../Doc/reference/expressions.rst:1177
msgid "Binary arithmetic operations"
msgstr "Operaciones aritméticas binarias"

#: ../Doc/reference/expressions.rst:1181
msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric types.  "
"Apart from the power operator, there are only two levels, one for "
"multiplicative operators and one for additive operators:"
msgstr ""
"Las operaciones aritméticas binarias tienen los niveles convencionales de "
"prioridad. Tenga en cuenta que algunas de esas operaciones también aplican a "
"ciertos tipos no numéricos. Aparte del operador de potencia, hay sólo dos "
"niveles, uno para operadores multiplicativos y uno para aditivos:"

#: ../Doc/reference/expressions.rst:1196
msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments.  "
"The arguments must either both be numbers, or one argument must be an "
"integer and the other must be a sequence. In the former case, the numbers "
"are converted to a common type and then multiplied together.  In the latter "
"case, sequence repetition is performed; a negative repetition factor yields "
"an empty sequence."
msgstr ""
"El operador ``*`` (multiplicación) produce el producto de sus argumentos. "
"Los argumentos pueden ser ambos números, o un argumento debe ser un entero y "
"el otro debe ser una secuencia. En el primer caso, los números se convierten "
"a un tipo común y luego son multiplicados. En el segundo caso, se realiza "
"una repetición de secuencia; un factor de repetición negativo produce una "
"secuencia vacía."

#: ../Doc/reference/expressions.rst:1206
msgid ""
"The ``@`` (at) operator is intended to be used for matrix multiplication.  "
"No builtin Python types implement this operator."
msgstr ""
"El operador ``@`` (en) está destinado a ser usado para multiplicación de "
"matrices. Ningún tipo incorporado en Python implementa este operador."

#: ../Doc/reference/expressions.rst:1217
msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted to a "
"common type. Division of integers yields a float, while floor division of "
"integers results in an integer; the result is that of mathematical division "
"with the 'floor' function applied to the result.  Division by zero raises "
"the :exc:`ZeroDivisionError` exception."
msgstr ""
"Los operadores ``/`` (división) y ``//`` (división de redondeo) producen el "
"cociente de sus argumentos. Los argumentos numéricos son primero convertidos "
"a un tipo común. La división de enteros producen un número de punto "
"flotante, mientras que la división redondeada de enteros resulta en un "
"entero; el resultado es aquel de una división matemática con la función "
"'floor' aplicada al resultado. Dividir entre 0 genera la excepción :exc:"
"`ZeroDivisionError`."

#: ../Doc/reference/expressions.rst:1228
msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the "
"first argument by the second.  The numeric arguments are first converted to "
"a common type.  A zero right argument raises the :exc:`ZeroDivisionError` "
"exception.  The arguments may be floating point numbers, e.g., ``3.14%0.7`` "
"equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo "
"operator always yields a result with the same sign as its second operand (or "
"zero); the absolute value of the result is strictly smaller than the "
"absolute value of the second operand [#]_."
msgstr ""
"El operador ``%`` (módulo) produce el resto de la división del primer "
"argumento entre el segundo. Los argumentos numéricos son primero convertidos "
"a un tipo común. Un argumento a la derecha cero genera la excepción :exc:"
"`ZeroDivisionError`. Los argumentos pueden ser números de punto flotante, "
"ej., ``3.14%0.7`` es igual a ``0.34`` (ya que ``3.14`` es igual a ``4*0.7 + "
"0.34``.) El operador módulo siempre produce un resultado con el mismo signo "
"que su segundo operando (o cero); el valor absoluto del resultado es "
"estrictamente más pequeño que el valor absoluto del segundo operando [#]_."

#: ../Doc/reference/expressions.rst:1237
msgid ""
"The floor division and modulo operators are connected by the following "
"identity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x//"
"y, x%y)``. [#]_."
msgstr ""
"Los operadores de división de redondeo y módulo están conectados por la "
"siguiente identidad: ``x == (x//y)*y + (x%y)``. La división de redondeo y el "
"módulo también están conectadas por la función incorporada :func:`divmod`: "
"``divmod(x, y) == (x//y, x%y)``. [#]_."

#: ../Doc/reference/expressions.rst:1242
msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string objects to perform old-style string "
"formatting (also known as interpolation).  The syntax for string formatting "
"is described in the Python Library Reference, section :ref:`old-string-"
"formatting`."
msgstr ""
"Adicionalmente a realizar la operación módulo en números, el operador ``%`` "
"también está sobrecargado por objetos cadena de caracteres para realizar "
"formateo de cadenas al estilo antiguo (también conocido como interpolación). "
"La sintaxis para el formateo de cadenas está descrita en la Referencia de la "
"Biblioteca de Python, sección :ref:`old-string-formatting`."

#: ../Doc/reference/expressions.rst:1247
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are not defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr ""
"El operador de división de redondeo, el operador módulo y la función :func:"
"`divmod` no están definidas para números complejos. En su lugar, convierta a "
"un número de punto flotante usando la función :func:`abs` si es apropiado."

#: ../Doc/reference/expressions.rst:1256
msgid ""
"The ``+`` (addition) operator yields the sum of its arguments.  The "
"arguments must either both be numbers or both be sequences of the same "
"type.  In the former case, the numbers are converted to a common type and "
"then added together. In the latter case, the sequences are concatenated."
msgstr ""
"El operador ``+`` (adición) produce la suma de sus argumentos. Los "
"argumentos deben ser ambos números o ambos secuencias del mismo tipo. En el "
"primer caso, los números son convertidos a un tipo común y luego sumados. En "
"el segundo caso, las secuencias son concatenadas."

#: ../Doc/reference/expressions.rst:1266
msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments.  "
"The numeric arguments are first converted to a common type."
msgstr ""
"El operador ``-`` (resta) produce la diferencia de sus argumentos. Los "
"argumentos numéricos son primero convertidos a un tipo común."

#: ../Doc/reference/expressions.rst:1273
msgid "Shifting operations"
msgstr "Operaciones de desplazamiento"

#: ../Doc/reference/expressions.rst:1280
msgid ""
"The shifting operations have lower priority than the arithmetic operations:"
msgstr ""
"Las operaciones de desplazamiento tienen menos prioridad que las operaciones "
"aritméticas:"

#: ../Doc/reference/expressions.rst:1285
msgid ""
"These operators accept integers as arguments.  They shift the first argument "
"to the left or right by the number of bits given by the second argument."
msgstr ""
"Estos operadores aceptan enteros como argumentos. Ellos desplazan el primer "
"argumento a la izquierda o derecha el número de dígitos dados por el segundo "
"argumento."

#: ../Doc/reference/expressions.rst:1290
msgid ""
"A right shift by *n* bits is defined as floor division by ``pow(2,n)``.  A "
"left shift by *n* bits is defined as multiplication with ``pow(2,n)``."
msgstr ""
"Un desplazamiento de *n* bits hacia la derecha está definido como una "
"división de redondeo entre ``pow(2,n)``. Un desplazamiento de *n* bits hacia "
"la izquierda está definido como una multiplicación por ``pow(2,n)``."

#: ../Doc/reference/expressions.rst:1297
msgid "Binary bitwise operations"
msgstr "Operaciones bit a bit binarias"

#: ../Doc/reference/expressions.rst:1301
msgid "Each of the three bitwise operations has a different priority level:"
msgstr ""
"Cada una de las tres operaciones de bits binarias tienen diferente nivel de "
"prioridad:"

#: ../Doc/reference/expressions.rst:1312
msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be "
"integers."
msgstr ""
"El operador ``&`` produce el AND bit a bit de sus argumentos, los cuales "
"deben ser enteros."

#: ../Doc/reference/expressions.rst:1320
msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, "
"which must be integers."
msgstr ""
"El operador ``^`` produce el XOR (OR exclusivo) bit a bit de sus argumentos, "
"los cuales deben ser enteros."

#: ../Doc/reference/expressions.rst:1328
msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which "
"must be integers."
msgstr ""
"El operador ``|`` produce el OR (inclusivo) bit a bit de sus argumentos, los "
"cuales deben ser enteros."

#: ../Doc/reference/expressions.rst:1335
msgid "Comparisons"
msgstr "Comparaciones"

#: ../Doc/reference/expressions.rst:1347
msgid ""
"Unlike C, all comparison operations in Python have the same priority, which "
"is lower than that of any arithmetic, shifting or bitwise operation.  Also "
"unlike C, expressions like ``a < b < c`` have the interpretation that is "
"conventional in mathematics:"
msgstr ""
"A diferencia de C, todas las operaciones de comparación en Python tienen la "
"misma prioridad, la cual es menor que la de cualquier operación aritmética, "
"de desplazamiento o bit a bit. También, a diferencia de C, expresiones como "
"``a < b < c`` tienen la interpretación convencional en matemáticas:"

#: ../Doc/reference/expressions.rst:1357
msgid "Comparisons yield boolean values: ``True`` or ``False``."
msgstr "Comparaciones producen valores booleanos: `` True`` o ``False``."

#: ../Doc/reference/expressions.rst:1361
msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent "
"to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in "
"both cases ``z`` is not evaluated at all when ``x < y`` is found to be "
"false)."
msgstr ""
"Las comparaciones pueden ser encadenadas arbitrariamente, ej., ``x < y <= "
"z`` es equivalente a ``x < y and y <= z``, excepto que ``y`` es evaluado "
"sólo una vez (pero en ambos casos ``z`` no es evaluado para nada cuando ``x "
"< y`` se encuentra que es falso)."

#: ../Doc/reference/expressions.rst:1365
msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, "
"*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN "
"z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except that "
"each expression is evaluated at most once."
msgstr ""
"Formalmente, si *a*, *b*, *c*, ..., *y*, *z* son expresiones y *op1*, "
"*op2*, ..., *opN* son operadores de comparación, entonces ``a op1 b op2 "
"c ... y opN z`` es equivalente a ``a op1 b and b op2 c and ... y opN z``, "
"excepto que cada expresión es evaluada como mucho una vez."

#: ../Doc/reference/expressions.rst:1370
msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a* "
"and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps not "
"pretty)."
msgstr ""
"Tenga en cuenta que ``a op1 b op2 c`` no implica ningún tipo de comparación "
"entre *a* y *c*, por lo que, por ejemplo, ``x < y > z`` es perfectamente "
"legal (aunque quizás no es bonito)."

#: ../Doc/reference/expressions.rst:1375
msgid "Value comparisons"
msgstr "Comparaciones de valor"

#: ../Doc/reference/expressions.rst:1377
msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the "
"values of two objects.  The objects do not need to have the same type."
msgstr ""
"Los operadores ``<``, ``>``, ``==``, ``>=``, ``<=``, y ``!=`` comparan los "
"valores de dos objetos. Los objetos no necesitan ser del mismo tipo."

#: ../Doc/reference/expressions.rst:1380
msgid ""
"Chapter :ref:`objects` states that objects have a value (in addition to type "
"and identity).  The value of an object is a rather abstract notion in "
"Python: For example, there is no canonical access method for an object's "
"value.  Also, there is no requirement that the value of an object should be "
"constructed in a particular way, e.g. comprised of all its data attributes. "
"Comparison operators implement a particular notion of what the value of an "
"object is.  One can think of them as defining the value of an object "
"indirectly, by means of their comparison implementation."
msgstr ""
"El capítulo :ref:`objects` afirma que los objetos tienen un valor (en "
"adición al tipo e identidad). El valor de un objeto es una noción bastante "
"abstracta en Python: Por ejemplo, no existe un método de acceso canónico "
"para el valor de un objeto. Además, no se requiere que el valor de un objeto "
"deba ser construido de una forma particular, ej. compuesto de todos sus "
"atributos de datos. Los operadores de comparación implementan una noción "
"particular de lo que es el valor de un objeto. Uno puede pensar en ellos "
"definiendo el valor de un objeto indirectamente, mediante su implementación "
"de comparación."

#: ../Doc/reference/expressions.rst:1389
msgid ""
"Because all types are (direct or indirect) subtypes of :class:`object`, they "
"inherit the default comparison behavior from :class:`object`.  Types can "
"customize their comparison behavior by implementing :dfn:`rich comparison "
"methods` like :meth:`__lt__`, described in :ref:`customization`."
msgstr ""
"Debido a que todos los tipos son subtipos (directos o indirectos) de :class:"
"`object`, ellos heredan el comportamiento de comparación predeterminado "
"desde :class:`object`. Los tipos pueden personalizar su comportamiento de "
"comparación implementando :dfn:`rich comparison methods` como :meth:"
"`__lt__`, descritos en :ref:`customization`."

#: ../Doc/reference/expressions.rst:1395
msgid ""
"The default behavior for equality comparison (``==`` and ``!=``) is based on "
"the identity of the objects.  Hence, equality comparison of instances with "
"the same identity results in equality, and equality comparison of instances "
"with different identities results in inequality.  A motivation for this "
"default behavior is the desire that all objects should be reflexive (i.e. "
"``x is y`` implies ``x == y``)."
msgstr ""
"El comportamiento predeterminado para comparación de igualdad (``==`` y ``!"
"=``) se basa en la identidad de los objetos. Por lo tanto, la comparación de "
"instancias con la misma identidad resulta en igualdad, y la comparación de "
"igualdad de instancias con diferentes entidades resulta en desigualdad. Una "
"motivación para este comportamiento predeterminado es el deseo de que todos "
"los objetos sean reflexivos (ej. ``x is y`` implica ``x == y``)."

#: ../Doc/reference/expressions.rst:1402
msgid ""
"A default order comparison (``<``, ``>``, ``<=``, and ``>=``) is not "
"provided; an attempt raises :exc:`TypeError`.  A motivation for this default "
"behavior is the lack of a similar invariant as for equality."
msgstr ""
"No se provee un orden de comparación por defecto (``<``, ``>``, ``<=``, and "
"``>=``); un intento genera :exc:`TypeError`. Una motivación para este "
"comportamiento predeterminado es la falta de una invariante similar como "
"para la igualdad."

#: ../Doc/reference/expressions.rst:1406
msgid ""
"The behavior of the default equality comparison, that instances with "
"different identities are always unequal, may be in contrast to what types "
"will need that have a sensible definition of object value and value-based "
"equality.  Such types will need to customize their comparison behavior, and "
"in fact, a number of built-in types have done that."
msgstr ""
"El comportamiento de la comparación de igualdad predeterminado, que "
"instancias con diferentes identidades siempre son desiguales, puede estar en "
"contraste a que los tipos que necesitarán que tengan una definición sensata "
"de valor de objeto e igualdad basada en el valor. Tales tipos necesitarán "
"personalizar su comportamiento de comparación y, de hecho, un número de "
"tipos incorporados lo han realizado."

#: ../Doc/reference/expressions.rst:1412
msgid ""
"The following list describes the comparison behavior of the most important "
"built-in types."
msgstr ""
"La siguiente lista describe el comportamiento de comparación de los tipos "
"incorporados más importantes."

#: ../Doc/reference/expressions.rst:1415
msgid ""
"Numbers of built-in numeric types (:ref:`typesnumeric`) and of the standard "
"library types :class:`fractions.Fraction` and :class:`decimal.Decimal` can "
"be compared within and across their types, with the restriction that complex "
"numbers do not support order comparison.  Within the limits of the types "
"involved, they compare mathematically (algorithmically) correct without loss "
"of precision."
msgstr ""
"Números de tipos numéricos incorporadas (:ref:`typesnumeric`) y tipos de la "
"biblioteca estándar :class:`fractions.Fraction` y :class:`decimal.Decimal` "
"pueden ser comparados consigo mismos y entre sus tipos, con la restricción "
"de que números complejos no soportan orden de comparación. Dentro de los "
"límites de los tipos involucrados, se comparan matemáticamente "
"(algorítmicamente) correctos sin pérdida de precisión."

#: ../Doc/reference/expressions.rst:1422
msgid ""
"The not-a-number values ``float('NaN')`` and ``decimal.Decimal('NaN')`` are "
"special.  Any ordered comparison of a number to a not-a-number value is "
"false. A counter-intuitive implication is that not-a-number values are not "
"equal to themselves.  For example, if ``x = float('NaN')``, ``3 < x``, ``x < "
"3`` and ``x == x`` are all false, while ``x != x`` is true.  This behavior "
"is compliant with IEEE 754."
msgstr ""
"Los valores no-un-número ``float('NaN')`` y ``decimal.Decimal('NaN')`` son "
"especiales. Cualquier comparación ordenada de un número a un no-un-número es "
"falsa. Una implicación contraintuitiva es que los valores no-un-número son "
"son iguales a sí mismos. Por ejemplo, si ``x = float('NaN')``, ``3 < x``, "
"``x < 3`` y ``x == x`` son todos falso, mientras ``x != x`` es verdadero. "
"Este comportamiento cumple con IEEE 754."

#: ../Doc/reference/expressions.rst:1429
msgid ""
"``None`` and ``NotImplemented`` are singletons.  :PEP:`8` advises that "
"comparisons for singletons should always be done with ``is`` or ``is not``, "
"never the equality operators."
msgstr ""
"``None`` y ``NotImplemented`` son singletons. :PEP:`8` avisa que las "
"comparaciones para singletons deben ser realizadas siempre con ``is`` o ``is "
"not``, nunca los operadores de igualdad."

#: ../Doc/reference/expressions.rst:1433
msgid ""
"Binary sequences (instances of :class:`bytes` or :class:`bytearray`) can be "
"compared within and across their types.  They compare lexicographically "
"using the numeric values of their elements."
msgstr ""
"Las secuencias binarias (instancias de :class:`bytes` o :class:`bytearray`) "
"pueden ser comparadas entre sí y con otros tipos. Ellas comparan "
"lexicográficamente utilizando los valores numéricos de sus elementos."

#: ../Doc/reference/expressions.rst:1437
msgid ""
"Strings (instances of :class:`str`) compare lexicographically using the "
"numerical Unicode code points (the result of the built-in function :func:"
"`ord`) of their characters. [#]_"
msgstr ""
"Las cadenas de caracteres (instancias de :class:`str`) comparan "
"lexicográficamente usando los puntos de códigos numéricos Unicode (el "
"resultado de la función incorporada :func:`ord`) o sus caracteres. [#]_"

#: ../Doc/reference/expressions.rst:1441
msgid "Strings and binary sequences cannot be directly compared."
msgstr ""
"Las cadenas de caracteres y las secuencias binarias no pueden ser comparadas "
"directamente."

#: ../Doc/reference/expressions.rst:1443
msgid ""
"Sequences (instances of :class:`tuple`, :class:`list`, or :class:`range`) "
"can be compared only within each of their types, with the restriction that "
"ranges do not support order comparison.  Equality comparison across these "
"types results in inequality, and ordering comparison across these types "
"raises :exc:`TypeError`."
msgstr ""
"Las secuencias (instancias de :class:`tuple`, :class:`list`, o :class:"
"`range`) pueden ser comparadas sólo entre cada uno de sus tipos, con la "
"restricción de que los rangos no soportan comparación de orden. Comparación "
"de igualdad entre esos tipos resulta en desigualdad y la comparación de "
"orden entre esos tipos genera :exc:`TypeError`."

#: ../Doc/reference/expressions.rst:1449
msgid ""
"Sequences compare lexicographically using comparison of corresponding "
"elements.  The built-in containers typically assume identical objects are "
"equal to themselves.  That lets them bypass equality tests for identical "
"objects to improve performance and to maintain their internal invariants."
msgstr ""
"Las secuencias comparan lexicográficamente usando comparación de sus "
"correspondientes elementos. Los contenedores incorporados asumen que los "
"objetos idénticos son iguales a sí mismos. Eso les permite omitir las "
"pruebas de igualdad para objetos idénticos para mejorar el rendimiento y "
"mantener sus invariantes internos."

#: ../Doc/reference/expressions.rst:1454
msgid ""
"Lexicographical comparison between built-in collections works as follows:"
msgstr ""
"La comparación lexicográfica entre colecciones incorporadas funciona de la "
"siguiente forma:"

#: ../Doc/reference/expressions.rst:1456
msgid ""
"For two collections to compare equal, they must be of the same type, have "
"the same length, and each pair of corresponding elements must compare equal "
"(for example, ``[1,2] == (1,2)`` is false because the type is not the same)."
msgstr ""
"Para que dos colecciones sean comparadas iguales, ellas deben ser del mismo "
"tipo, tener el mismo largo, y cada para de elementos correspondientes deben "
"comparar iguales (por ejemplo, ``[1,2] == (1,2)`` es falso debido a que el "
"tipo no es el mismo)."

#: ../Doc/reference/expressions.rst:1461
msgid ""
"Collections that support order comparison are ordered the same as their "
"first unequal elements (for example, ``[1,2,x] <= [1,2,y]`` has the same "
"value as ``x <= y``).  If a corresponding element does not exist, the "
"shorter collection is ordered first (for example, ``[1,2] < [1,2,3]`` is "
"true)."
msgstr ""
"Las colecciones que soportan comparación de orden son ordenadas igual que "
"sus primeros elementos desiguales (por ejemplo, ``[1,2,x] <= [1,2,y]`` tiene "
"el mismo valor que ``x <= y``). Si un elemento correspondiente no existe, la "
"colección más corta es ordenada primero (por ejemplo, ``[1,2] < [1,2,3]`` es "
"verdadero)."

#: ../Doc/reference/expressions.rst:1467
msgid ""
"Mappings (instances of :class:`dict`) compare equal if and only if they have "
"equal `(key, value)` pairs. Equality comparison of the keys and values "
"enforces reflexivity."
msgstr ""
"Los mapeos (instancias de :class:`dict`) comparan igual si y sólo si tienen "
"pares `(clave, valor)` iguales. La comparación de igualdad de claves y "
"valores refuerza la reflexibilidad."

#: ../Doc/reference/expressions.rst:1471
msgid ""
"Order comparisons (``<``, ``>``, ``<=``, and ``>=``) raise :exc:`TypeError`."
msgstr ""
"Comparaciones de orden (``<``, ``>``, ``<=``, and ``>=``) generan :exc:"
"`TypeError`."

#: ../Doc/reference/expressions.rst:1473
msgid ""
"Sets (instances of :class:`set` or :class:`frozenset`) can be compared "
"within and across their types."
msgstr ""
"Conjuntos (instancias de :class:`set` o :class:`frozenset`) pueden ser "
"comparadas entre sí y entre sus tipos."

#: ../Doc/reference/expressions.rst:1476
msgid ""
"They define order comparison operators to mean subset and superset tests.  "
"Those relations do not define total orderings (for example, the two sets "
"``{1,2}`` and ``{2,3}`` are not equal, nor subsets of one another, nor "
"supersets of one another).  Accordingly, sets are not appropriate arguments "
"for functions which depend on total ordering (for example, :func:`min`, :"
"func:`max`, and :func:`sorted` produce undefined results given a list of "
"sets as inputs)."
msgstr ""
"Ellas definen operadores de comparación de orden con la intención de "
"comprobar subconjuntos y superconjuntos. Tales relaciones no definen "
"ordenaciones completas (por ejemplo, los dos conjuntos ``{1,2}`` y ``{2,3}`` "
"no son iguales, ni subconjuntos ni superconjuntos uno de otro). Acordemente, "
"los conjuntos no son argumentos apropiados para funciones que dependen de "
"ordenación completa (por ejemplo, :func:`min`, :func:`max` y :func:`sorted` "
"producen resultados indefinidos dados una lista de conjuntos como entradas)."

#: ../Doc/reference/expressions.rst:1484
msgid "Comparison of sets enforces reflexivity of its elements."
msgstr ""
"La comparación de conjuntos refuerza la reflexibilidad de sus elementos."

#: ../Doc/reference/expressions.rst:1486
msgid ""
"Most other built-in types have no comparison methods implemented, so they "
"inherit the default comparison behavior."
msgstr ""
"La mayoría de los otros tipos incorporados no tienen métodos de comparación "
"implementados, por lo que ellos heredan el comportamiento de comparación "
"predeterminado."

#: ../Doc/reference/expressions.rst:1489
msgid ""
"User-defined classes that customize their comparison behavior should follow "
"some consistency rules, if possible:"
msgstr ""
"Las clases definidas por el usuario que personalizan su comportamiento de "
"comparación deben seguir algunas reglas de consistencia, si es posible:"

#: ../Doc/reference/expressions.rst:1492
msgid ""
"Equality comparison should be reflexive. In other words, identical objects "
"should compare equal:"
msgstr ""
"La comparación de igualdad debe ser reflexiva. En otras palabras, los "
"objetos idénticos deben comparar iguales:"

#: ../Doc/reference/expressions.rst:1495
msgid "``x is y`` implies ``x == y``"
msgstr "``x is y`` implica ``x == y``"

#: ../Doc/reference/expressions.rst:1497
msgid ""
"Comparison should be symmetric. In other words, the following expressions "
"should have the same result:"
msgstr ""
"La comparación debe ser simétrica. En otras palabras, las siguientes "
"expresiones deben tener el mismo resultado:"

#: ../Doc/reference/expressions.rst:1500
msgid "``x == y`` and ``y == x``"
msgstr "``x == y`` y ``y == x``"

#: ../Doc/reference/expressions.rst:1502
msgid "``x != y`` and ``y != x``"
msgstr "``x != y`` y ``y != x``"

#: ../Doc/reference/expressions.rst:1504
msgid "``x < y`` and ``y > x``"
msgstr "``x < y`` y ``y > x``"

#: ../Doc/reference/expressions.rst:1506
msgid "``x <= y`` and ``y >= x``"
msgstr "``x <= y`` y ``y >= x``"

#: ../Doc/reference/expressions.rst:1508
msgid ""
"Comparison should be transitive. The following (non-exhaustive) examples "
"illustrate that:"
msgstr ""
"La comparación debe ser transitiva. Los siguientes ejemplos (no exhaustivos) "
"ilustran esto:"

#: ../Doc/reference/expressions.rst:1511
msgid "``x > y and y > z`` implies ``x > z``"
msgstr "``x > y and y > z`` implica ``x > z``"

#: ../Doc/reference/expressions.rst:1513
msgid "``x < y and y <= z`` implies ``x < z``"
msgstr "``x < y and y <= z`` implica ``x < z``"

#: ../Doc/reference/expressions.rst:1515
msgid ""
"Inverse comparison should result in the boolean negation. In other words, "
"the following expressions should have the same result:"
msgstr ""
"La comparación inversa debe resultar en la negación booleana. En otras "
"palabras, las siguientes expresiones deben tener el mismo resultado:"

#: ../Doc/reference/expressions.rst:1518
msgid "``x == y`` and ``not x != y``"
msgstr "``x == y`` y ``not x != y``"

#: ../Doc/reference/expressions.rst:1520
msgid "``x < y`` and ``not x >= y`` (for total ordering)"
msgstr "``x < y`` y ``not x >= y`` (para ordenación completa)"

#: ../Doc/reference/expressions.rst:1522
msgid "``x > y`` and ``not x <= y`` (for total ordering)"
msgstr "``x > y`` y ``not x <= y`` (para ordenación completa)"

#: ../Doc/reference/expressions.rst:1524
msgid ""
"The last two expressions apply to totally ordered collections (e.g. to "
"sequences, but not to sets or mappings). See also the :func:`~functools."
"total_ordering` decorator."
msgstr ""
"Las últimas dos expresiones aplican a colecciones completamente ordenadas "
"(ej. a secuencias, pero no a conjuntos o mapeos). Vea también el decorador :"
"func:`~functools.total_ordering`."

#: ../Doc/reference/expressions.rst:1528
msgid ""
"The :func:`hash` result should be consistent with equality. Objects that are "
"equal should either have the same hash value, or be marked as unhashable."
msgstr ""
"La función :func:`hash` debe ser consistente con la igualdad. Los objetos "
"que son iguales deben tener el mismo valor de hash o ser marcados como "
"inhashables."

#: ../Doc/reference/expressions.rst:1532
msgid ""
"Python does not enforce these consistency rules. In fact, the not-a-number "
"values are an example for not following these rules."
msgstr ""
"Python no fuerza a cumplir esas reglas de coherencia. De hecho, los valores "
"no-un-número son u ejemplo para no seguir esas reglas."

#: ../Doc/reference/expressions.rst:1541
msgid "Membership test operations"
msgstr "Operaciones de prueba de membresía"

#: ../Doc/reference/expressions.rst:1543
msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x "
"in s`` evaluates to ``True`` if *x* is a member of *s*, and ``False`` "
"otherwise. ``x not in s`` returns the negation of ``x in s``.  All built-in "
"sequences and set types support this as well as dictionary, for which :"
"keyword:`!in` tests whether the dictionary has a given key. For container "
"types such as list, tuple, set, frozenset, dict, or collections.deque, the "
"expression ``x in y`` is equivalent to ``any(x is e or x == e for e in y)``."
msgstr ""
"Los operadores :keyword:`in` y :keyword:`not in` comprueban membresía. ``x "
"in s`` evalúa a ``True`` si *x* es un miembro de *s* y ``False`` en caso "
"contrario. ``x not in s`` retorna la negación de ``x in s``. Todas las "
"secuencias incorporadas y tipos conjuntos soportan esto, así como "
"diccionarios, para los cuales :keyword:`!in` comprueba si un diccionario "
"tiene una clave dada. Para tipos contenedores como list, tuple, set, "
"frozenset, dict o collections.deque, la expresión ``x in y`` es equivalente "
"a ``any(x is e or x == e for e in y)``."

#: ../Doc/reference/expressions.rst:1551
msgid ""
"For the string and bytes types, ``x in y`` is ``True`` if and only if *x* is "
"a substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty "
"strings are always considered to be a substring of any other string, so ``"
"\"\" in \"abc\"`` will return ``True``."
msgstr ""
"Para los tipos cadenas de caracteres y bytes, ``x in y`` es ``True`` si y "
"sólo si *x* es una subcadena de *y*. Una comprobación equivalente es ``y."
"find(x) != -1``. Las cadenas de caracteres vacías siempre son consideradas "
"como subcadenas de cualquier otra cadena de caracteres, por lo que ``\"\" in "
"\"abc\"`` retornará ``True``."

#: ../Doc/reference/expressions.rst:1556
msgid ""
"For user-defined classes which define the :meth:`__contains__` method, ``x "
"in y`` returns ``True`` if ``y.__contains__(x)`` returns a true value, and "
"``False`` otherwise."
msgstr ""
"Para clases definidas por el usuario las cuales definen el método :meth:"
"`__contains__`, ``x in y`` retorna ``True`` si ``y.__contains__(x)`` retorna "
"un valor verdadero y ``False`` si no."

#: ../Doc/reference/expressions.rst:1560
msgid ""
"For user-defined classes which do not define :meth:`__contains__` but do "
"define :meth:`__iter__`, ``x in y`` is ``True`` if some value ``z``, for "
"which the expression ``x is z or x == z`` is true, is produced while "
"iterating over ``y``. If an exception is raised during the iteration, it is "
"as if :keyword:`in` raised that exception."
msgstr ""
"Para clases definidas por el usuario las cuales no definen :meth:"
"`__contains__` pero definen :meth:`__iter__`, ``x in y`` es ``True`` si "
"algún valor ``z``, para el cual la expresión ``x is z or x == z`` es "
"verdadera, es producido iterando sobre ``y``. Si una excepción es generada "
"durante la iteración, es como si :keyword:`in` hubiera generado esa "
"excepción."

#: ../Doc/reference/expressions.rst:1566
msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines :meth:"
"`__getitem__`, ``x in y`` is ``True`` if and only if there is a non-negative "
"integer index *i* such that ``x is y[i] or x == y[i]``, and no lower integer "
"index raises the :exc:`IndexError` exception.  (If any other exception is "
"raised, it is as if :keyword:`in` raised that exception)."
msgstr ""
"Por último, se intenta el protocolo de iteración al estilo antiguo: si una "
"clase define :meth:`__getitem__`, ``x in y`` es ``True`` si y sólo si hay un "
"índice entero no negativo *i* tal que ``x is y[i] or x == y[i]`` y ningún "
"entero menor genera la excepción :exc:`IndexError`. (Si cualquier otra "
"excepción es generada, es como si :keyword:`in` hubiera generado esa "
"excepción)."

#: ../Doc/reference/expressions.rst:1578
msgid ""
"The operator :keyword:`not in` is defined to have the inverse truth value "
"of :keyword:`in`."
msgstr ""
"El operador :keyword:`not in` es definido para tener el valor de veracidad "
"inverso de :keyword:`in`."

#: ../Doc/reference/expressions.rst:1591
msgid "Identity comparisons"
msgstr "Comparaciones de identidad"

#: ../Doc/reference/expressions.rst:1593
msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for an object's "
"identity: ``x is y`` is true if and only if *x* and *y* are the same "
"object.  An Object's identity is determined using the :meth:`id` function.  "
"``x is not y`` yields the inverse truth value. [#]_"
msgstr ""
"Los operadores :keyword:`is` y :keyword:`is not` comprueban la identidad de "
"un objeto. ``x is y`` es verdadero si y sólo si *x* e *y* son el mismo "
"objeto. La identidad de un Objeto se determina usando la función :meth:`id`. "
"``x is not y`` produce el valor de veracidad inverso. [#]_"

#: ../Doc/reference/expressions.rst:1605
msgid "Boolean operations"
msgstr "Operaciones booleanas"

#: ../Doc/reference/expressions.rst:1616
msgid ""
"In the context of Boolean operations, and also when expressions are used by "
"control flow statements, the following values are interpreted as false: "
"``False``, ``None``, numeric zero of all types, and empty strings and "
"containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  User-defined "
"objects can customize their truth value by providing a :meth:`__bool__` "
"method."
msgstr ""
"En el contexto de las operaciones booleanas y también cuando sentencias de "
"control de flujo usan expresiones, los siguientes valores se interpretan "
"como falsos: ``False``, ``None``, ceros numéricos de todos los tipos y "
"cadenas de caracteres y contenedores vacíos (incluyendo cadenas de "
"caracteres, tuplas, diccionarios, conjuntos y conjuntos congelados). Todos "
"los otros valores son interpretados como verdaderos. Los objetos definidos "
"por el usuario pueden personalizar su valor de veracidad proveyendo un "
"método :meth:`__bool__`."

#: ../Doc/reference/expressions.rst:1625
msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr ""
"El operador :keyword:`not` produce ``True`` si su argumento es falso, "
"``False`` si no."

#: ../Doc/reference/expressions.rst:1630
msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"La expresión ``x and y`` primero evalúa *x*; si *x* es falso, se retorna su "
"valor; de otra forma, *y* es evaluado y se retorna el valor resultante."

#: ../Doc/reference/expressions.rst:1635
msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value is "
"returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"La expresión ``x or y`` primero evalúa *x*; si *x* es verdadero, se retorna "
"su valor; de otra forma, *y* es evaluado y se retorna el valor resultante."

#: ../Doc/reference/expressions.rst:1638
msgid ""
"Note that neither :keyword:`and` nor :keyword:`or` restrict the value and "
"type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument.  This is sometimes useful, e.g., if ``s`` is a string "
"that should be replaced by a default value if it is empty, the expression "
"``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to "
"create a new value, it returns a boolean value regardless of the type of its "
"argument (for example, ``not 'foo'`` produces ``False`` rather than ``''``.)"
msgstr ""
"Tenga en cuenta que ni :keyword:`and` ni :keyword:`or` restringen el valor y "
"el tipo que retornan a ``False`` y ``True``, sino retornan el último "
"argumento evaluado. Esto es útil a veces, ej., si ``s`` es una cadena de "
"caracteres que debe ser remplazada por un valor predeterminado si está "
"vacía, la expresión ``s or 'foo'`` produce el valor deseado. Debido a que :"
"keyword:`not` tiene que crear un nuevo valor, retorna un valor booleano "
"indiferentemente del tipo de su argumento (por ejemplo, ``not 'foo'`` "
"produce ``False`` en lugar de ``''``.)"

#: ../Doc/reference/expressions.rst:1648
msgid "Assignment expressions"
msgstr "Expresiones de asignación"

#: ../Doc/reference/expressions.rst:1655
msgid "See :pep:`572` for more details about assignment expressions."
msgstr "Vea :pep:`572` para más detalles sobre las expresiones de asignación."

#: ../Doc/reference/expressions.rst:1661
msgid "Conditional expressions"
msgstr "Expresiones condicionales"

#: ../Doc/reference/expressions.rst:1674
msgid ""
"Conditional expressions (sometimes called a \"ternary operator\") have the "
"lowest priority of all Python operations."
msgstr ""
"Las expresiones condicionales (a veces denominadas un \"operador ternario\") "
"tienen la prioridad más baja que todas las operaciones de Python."

#: ../Doc/reference/expressions.rst:1677
msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* rather "
"than *x*. If *C* is true, *x* is evaluated and its value is returned; "
"otherwise, *y* is evaluated and its value is returned."
msgstr ""
"La expresión ``x if C else y`` primero evalúa la condición, *C* en lugar de "
"*x*. Si *C* es verdadero, *x* es evaluado y se retorna su valor; en caso "
"contrario, *y* es evaluado y se retorna su valor."

#: ../Doc/reference/expressions.rst:1681
msgid "See :pep:`308` for more details about conditional expressions."
msgstr "Vea :pep:`308` para más detalles sobre expresiones condicionales."

#: ../Doc/reference/expressions.rst:1688
msgid "Lambdas"
msgstr "Lambdas"

#: ../Doc/reference/expressions.rst:1700
msgid ""
"Lambda expressions (sometimes called lambda forms) are used to create "
"anonymous functions. The expression ``lambda parameters: expression`` yields "
"a function object.  The unnamed object behaves like a function object "
"defined with:"
msgstr ""
"Las expresiones lambda (a veces denominadas formas lambda) son usadas para "
"crear funciones anónimas. La expresión ``lambda parameters: expression`` "
"produce un objeto de función. El objeto sin nombre se comporta como un "
"objeto función con:"

#: ../Doc/reference/expressions.rst:1709
msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that "
"functions created with lambda expressions cannot contain statements or "
"annotations."
msgstr ""
"Vea la sección :ref:`function` para la sintaxis de listas de parámetros. "
"Tenga en cuenta que las funciones creadas con expresiones lambda no pueden "
"contener sentencias ni anotaciones."

#: ../Doc/reference/expressions.rst:1717
msgid "Expression lists"
msgstr "Listas de expresiones"

#: ../Doc/reference/expressions.rst:1731
msgid ""
"Except when part of a list or set display, an expression list containing at "
"least one comma yields a tuple.  The length of the tuple is the number of "
"expressions in the list.  The expressions are evaluated from left to right."
msgstr ""
"Excepto cuando son parte de un despliegue de lista o conjunto, una lista de "
"expresión conteniendo al menos una coma produce una tupla. El largo de la "
"tupla es el número de expresiones en la lista. Las expresiones son evaluadas "
"de izquierda a derecha."

#: ../Doc/reference/expressions.rst:1740
msgid ""
"An asterisk ``*`` denotes :dfn:`iterable unpacking`.  Its operand must be "
"an :term:`iterable`.  The iterable is expanded into a sequence of items, "
"which are included in the new tuple, list, or set, at the site of the "
"unpacking."
msgstr ""
"Un asterisco ``*`` denota :dfn:`iterable unpacking`. Su operando deben ser "
"un :term:`iterable`. El iterable es expandido en una secuencia de elementos, "
"los cuales son incluidos en la nueva tupla, lista o conjunto en el lugar del "
"desempaquetado."

#: ../Doc/reference/expressions.rst:1745
msgid ""
"Iterable unpacking in expression lists, originally proposed by :pep:`448`."
msgstr ""
"Desempaquetado iterable en listas de expresiones, originalmente propuesto "
"por :pep:`488`."

#: ../Doc/reference/expressions.rst:1750
msgid ""
"The trailing comma is required only to create a single tuple (a.k.a. a "
"*singleton*); it is optional in all other cases.  A single expression "
"without a trailing comma doesn't create a tuple, but rather yields the value "
"of that expression. (To create an empty tuple, use an empty pair of "
"parentheses: ``()``.)"
msgstr ""
"La coma final sólo es requerida para crear una tupla única (también "
"denominada un *singleton*); es opcional en todos los otros casos. Una única "
"expresión sin una coma final no crea una tupla, si no produce el valor de "
"esa expresion. (Para crear una tupla vacía, usa un par de paréntesis vacío: "
"``()``.)"

#: ../Doc/reference/expressions.rst:1760
msgid "Evaluation order"
msgstr "Orden de evaluación"

#: ../Doc/reference/expressions.rst:1764
msgid ""
"Python evaluates expressions from left to right.  Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the left-"
"hand side."
msgstr ""
"Python evalúa las expresiones de izquierda a derecha. Note que mientras se "
"evalúa una asignación, la parte derecha es evaluada antes que la parte "
"izquierda."

#: ../Doc/reference/expressions.rst:1767
msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr ""
"En las siguientes líneas, las expresiones serán evaluadas en el orden "
"aritmético de sus sufijos::"

#: ../Doc/reference/expressions.rst:1781
msgid "Operator precedence"
msgstr "Prioridad de operador"

#: ../Doc/reference/expressions.rst:1786
msgid ""
"The following table summarizes the operator precedence in Python, from "
"lowest precedence (least binding) to highest precedence (most binding).  "
"Operators in the same box have the same precedence.  Unless the syntax is "
"explicitly given, operators are binary.  Operators in the same box group "
"left to right (except for exponentiation, which groups from right to left)."
msgstr ""
"La siguiente tabla resume la prioridad de operador en Python, desde la "
"prioridad más baja (menos vinculante) a la prioridad más alta (más "
"vinculante). Operadores en la misma caja tienen la misma prioridad. A no ser "
"que la sintaxis sea dada explícitamente, los operadores son binarios. Los "
"operadores en la misma caja, de izquierda a derecha (excepto para "
"exponenciación, cuyos grupos de derecha a izquierda)."

#: ../Doc/reference/expressions.rst:1792
msgid ""
"Note that comparisons, membership tests, and identity tests, all have the "
"same precedence and have a left-to-right chaining feature as described in "
"the :ref:`comparisons` section."
msgstr ""
"Tenga en cuenta que las comparaciones, comprobaciones de membresía y las "
"comprobaciones de identidad tienen la misma prioridad y una característica "
"de encadenado de izquierda a derecha como son descritas en la sección :ref:"
"`comparisons`."

#: ../Doc/reference/expressions.rst:1798
msgid "Operator"
msgstr "Operador"

#: ../Doc/reference/expressions.rst:1798
msgid "Description"
msgstr "Descripción"

#: ../Doc/reference/expressions.rst:1800
msgid "``:=``"
msgstr "``:=``"

#: ../Doc/reference/expressions.rst:1800
msgid "Assignment expression"
msgstr "Expresión de asignación"

#: ../Doc/reference/expressions.rst:1802
msgid ":keyword:`lambda`"
msgstr ":keyword:`lambda`"

#: ../Doc/reference/expressions.rst:1802
msgid "Lambda expression"
msgstr "Expresión lambda"

#: ../Doc/reference/expressions.rst:1804
msgid ":keyword:`if <if_expr>` -- :keyword:`!else`"
msgstr ":keyword:`if <if_expr>` -- :keyword:`!else`"

#: ../Doc/reference/expressions.rst:1804
msgid "Conditional expression"
msgstr "Expresión condicional"

#: ../Doc/reference/expressions.rst:1806
msgid ":keyword:`or`"
msgstr ":keyword:`or`"

#: ../Doc/reference/expressions.rst:1806
msgid "Boolean OR"
msgstr "Booleano OR"

#: ../Doc/reference/expressions.rst:1808
msgid ":keyword:`and`"
msgstr ":keyword:`and`"

#: ../Doc/reference/expressions.rst:1808
msgid "Boolean AND"
msgstr "Booleano AND"

#: ../Doc/reference/expressions.rst:1810
msgid ":keyword:`not` ``x``"
msgstr ":keyword:`not` ``x``"

#: ../Doc/reference/expressions.rst:1810
msgid "Boolean NOT"
msgstr "Booleano NOT"

#: ../Doc/reference/expressions.rst:1812
msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"
msgstr ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"

#: ../Doc/reference/expressions.rst:1812
msgid "Comparisons, including membership tests and identity tests"
msgstr "Comparaciones, incluyendo comprobaciones de membresía y de identidad"

#: ../Doc/reference/expressions.rst:1816
msgid "``|``"
msgstr "``|``"

#: ../Doc/reference/expressions.rst:1816
msgid "Bitwise OR"
msgstr "OR bit a bit"

#: ../Doc/reference/expressions.rst:1818
msgid "``^``"
msgstr "``^``"

#: ../Doc/reference/expressions.rst:1818
msgid "Bitwise XOR"
msgstr "XOR bit a bit"

#: ../Doc/reference/expressions.rst:1820
msgid "``&``"
msgstr "``&``"

#: ../Doc/reference/expressions.rst:1820
msgid "Bitwise AND"
msgstr "AND bit a bit"

#: ../Doc/reference/expressions.rst:1822
msgid "``<<``, ``>>``"
msgstr "``<<``, ``>>``"

#: ../Doc/reference/expressions.rst:1822
msgid "Shifts"
msgstr "Desplazamientos"

#: ../Doc/reference/expressions.rst:1824
msgid "``+``, ``-``"
msgstr "``+``, ``-``"

#: ../Doc/reference/expressions.rst:1824
msgid "Addition and subtraction"
msgstr "Adición y sustracción"

#: ../Doc/reference/expressions.rst:1826
msgid "``*``, ``@``, ``/``, ``//``, ``%``"
msgstr "``*``, ``@``, ``/``, ``//``, ``%``"

#: ../Doc/reference/expressions.rst:1826
msgid ""
"Multiplication, matrix multiplication, division, floor division, remainder "
"[#]_"
msgstr ""
"Multiplicación, multiplicación de matrices, división, división de redondeo, "
"resto [#]_"

#: ../Doc/reference/expressions.rst:1830
msgid "``+x``, ``-x``, ``~x``"
msgstr "``+x``, ``-x``, ``~x``"

#: ../Doc/reference/expressions.rst:1830
msgid "Positive, negative, bitwise NOT"
msgstr "NOT positivo, negativo, bit a bit"

#: ../Doc/reference/expressions.rst:1832
msgid "``**``"
msgstr "``**``"

#: ../Doc/reference/expressions.rst:1832
msgid "Exponentiation [#]_"
msgstr "Exponenciación [#]_"

#: ../Doc/reference/expressions.rst:1834
msgid ":keyword:`await` ``x``"
msgstr ":keyword:`await` ``x``"

#: ../Doc/reference/expressions.rst:1836
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"

#: ../Doc/reference/expressions.rst:1836
msgid "Subscription, slicing, call, attribute reference"
msgstr "Subscripción, segmentación, invocación, referencia de atributo"

#: ../Doc/reference/expressions.rst:1839
msgid "``(expressions...)``,"
msgstr "``(expressions...)``,"

#: ../Doc/reference/expressions.rst:1841
msgid "``[expressions...]``, ``{key: value...}``, ``{expressions...}``"
msgstr "``[expressions...]``, ``{key: value...}``, ``{expressions...}``"

#: ../Doc/reference/expressions.rst:1839
msgid ""
"Binding or parenthesized expression, list display, dictionary display, set "
"display"
msgstr ""
"Expresión de enlace o entre paréntesis, despliegues de lista, diccionario y "
"conjunto"

#: ../Doc/reference/expressions.rst:1848
msgid "Footnotes"
msgstr "Notas al pie"

#: ../Doc/reference/expressions.rst:1849
#, python-format
msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be "
"true numerically due to roundoff.  For example, and assuming a platform on "
"which a Python float is an IEEE 754 double-precision number, in order that "
"``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is "
"``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  The "
"function :func:`math.fmod` returns a result whose sign matches the sign of "
"the first argument instead, and so returns ``-1e-100`` in this case. Which "
"approach is more appropriate depends on the application."
msgstr ""
"Mientras ``abs(x%y) < abs(y)`` es matemáticamente verdadero, para números de "
"punto flotante puede no ser verdadero numéricamente debido al redondeo. Por "
"ejemplo, y asumiendo una plataforma en la cual un número de punto flotante "
"de Python es un número de doble precisión IEEE 754, a fin de que ``-1e-100 % "
"1e100`` tenga el mismo signo que ``1e100``, el resultado calculado es "
"``-1e-100 + 1e100``, el cual es numéricamente exactamente igual a ``1e100``. "
"La función :func:`math.fmod` retorna un resultado cuyo signo concuerda con "
"el signo del primer argumento en su lugar, y por ello retorna ``-1e-100`` en "
"este caso. La aproximación más apropiada depende de su aplicación."

#: ../Doc/reference/expressions.rst:1858
msgid ""
"If x is very close to an exact integer multiple of y, it's possible for ``x//"
"y`` to be one larger than ``(x-x%y)//y`` due to rounding.  In such cases, "
"Python returns the latter result, in order to preserve that ``divmod(x,y)[0] "
"* y + x % y`` be very close to ``x``."
msgstr ""
"Si x está muy cerca de un entero exacto múltiple de y, es posible para ``x//"
"y`` que sea uno mayor que ``(x-x%y)//y`` debido al redondeo. En tales casos, "
"Python retorna el último resultado, a fin de preservar que ``divmod(x,y)[0] "
"* y + x % y`` sea muy cercano a ``x``."

#: ../Doc/reference/expressions.rst:1863
msgid ""
"The Unicode standard distinguishes between :dfn:`code points` (e.g. U+0041) "
"and :dfn:`abstract characters` (e.g. \"LATIN CAPITAL LETTER A\"). While most "
"abstract characters in Unicode are only represented using one code point, "
"there is a number of abstract characters that can in addition be represented "
"using a sequence of more than one code point.  For example, the abstract "
"character \"LATIN CAPITAL LETTER C WITH CEDILLA\" can be represented as a "
"single :dfn:`precomposed character` at code position U+00C7, or as a "
"sequence of a :dfn:`base character` at code position U+0043 (LATIN CAPITAL "
"LETTER C), followed by a :dfn:`combining character` at code position U+0327 "
"(COMBINING CEDILLA)."
msgstr ""
"El estándar Unicode distingue entre :dfn:`code points` (ej. U+0041) y :dfn:"
"`abstract characters` (ej. \"LETRA MAYÚSCULA LATINA A\"). Mientras la "
"mayoría de caracteres abstractos en Unicode sólo son representados usando un "
"punto de código, hay un número de caracteres abstractos que pueden "
"adicionalmente ser representados usado una secuencia de más de un punto de "
"código. Por ejemplo, el caracter abstracto \"LETRA MAYÚSCULA C LATINA CON "
"CEDILLA\" puede ser representado como un único :dfn:`precomposed character` "
"en la posición de código U+00C7, o como una secuencia de un :dfn:`base "
"character` en la posición de código U+0043 (LETRA MAYÚSCULA C LATINA), "
"seguida de un :dfn:`combining character` en la posición de código U+0327 "
"(CEDILLA COMBINADA)."

#: ../Doc/reference/expressions.rst:1874
msgid ""
"The comparison operators on strings compare at the level of Unicode code "
"points. This may be counter-intuitive to humans.  For example, ``\"\\u00C7\" "
"== \"\\u0043\\u0327\"`` is ``False``, even though both strings represent the "
"same abstract character \"LATIN CAPITAL LETTER C WITH CEDILLA\"."
msgstr ""
"Los operadores de comparación comparan en cadenas de caracteres al nivel de "
"puntos de código Unicode. Esto puede ser contraintuitivo para humanos. Por "
"ejemplo, ``\"\\u00C7\" == \"\\u0043\\u0327\"`` es ``False``, incluso aunque "
"ambas cadenas presenten el mismo caracter abstracto \"LETRA MAYÚSCULA C "
"LATINA CON CEDILLA\"."

#: ../Doc/reference/expressions.rst:1879
msgid ""
"To compare strings at the level of abstract characters (that is, in a way "
"intuitive to humans), use :func:`unicodedata.normalize`."
msgstr ""
"Para comparar cadenas al nivel de caracteres abstractos (esto es, de una "
"forma intuitiva para humanos), usa :func:`unicodedata.normalize`."

#: ../Doc/reference/expressions.rst:1882
msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature of "
"descriptors, you may notice seemingly unusual behaviour in certain uses of "
"the :keyword:`is` operator, like those involving comparisons between "
"instance methods, or constants.  Check their documentation for more info."
msgstr ""
"Debido a la recolección automática de basura, listas libres y a la "
"naturaleza dinámica de los descriptores, puede notar un comportamiento "
"aparentemente inusual en ciertos usos del operador :keyword:`is`, como "
"aquellos involucrando comparaciones entre métodos de instancia, o "
"constantes. Compruebe su documentación para más información."

#: ../Doc/reference/expressions.rst:1887
msgid ""
"The ``%`` operator is also used for string formatting; the same precedence "
"applies."
msgstr ""
"El operador ``%`` también es usado para formateo de cadenas; aplica la misma "
"prioridad."

#: ../Doc/reference/expressions.rst:1890
msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or bitwise "
"unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr ""
"El operador de potencia ``**`` vincula con menos fuerza que un operador "
"unario aritmético uno bit a bit en su derecha, esto significa que ``2**-1`` "
"is ``0.5``."
