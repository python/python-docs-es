# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-05 12:54+0200\n"
"PO-Revision-Date: 2020-12-04 13:39+0100\n"
"Last-Translator: Elena He <mikan1985@gmail.com>\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Language: es\n"
"X-Generator: Poedit 2.4.2\n"

#: ../Doc/reference/simple_stmts.rst:6
msgid "Simple statements"
msgstr "Declaraciones simples"

#: ../Doc/reference/simple_stmts.rst:10
msgid ""
"A simple statement is comprised within a single logical line. Several simple "
"statements may occur on a single line separated by semicolons.  The syntax "
"for simple statements is:"
msgstr ""
"Una declaración simple se compone dentro de una sola línea lógica. Pueden "
"producirse varias declaraciones simples en una sola línea separada por punto "
"y coma.  La sintaxis de las declaraciones simples es:"

#: ../Doc/reference/simple_stmts.rst:36
msgid "Expression statements"
msgstr "Declaraciones de tipo expresión"

#: ../Doc/reference/simple_stmts.rst:43
msgid ""
"Expression statements are used (mostly interactively) to compute and write a "
"value, or (usually) to call a procedure (a function that returns no "
"meaningful result; in Python, procedures return the value ``None``).  Other "
"uses of expression statements are allowed and occasionally useful.  The "
"syntax for an expression statement is:"
msgstr ""
"Las declaraciones de tipo expresión son usadas (en su mayoría "
"interactivamente) para computar y escribir un valor, o (usualmente) para "
"llamar a un método (una función que no retorna un resultado significativo;  "
"en Python, los métodos retornan el valor ``None``). Otros usos de las "
"declaraciones de tipo expresión son permitidas y ocasionalmente útiles. La "
"sintaxis para una declaración de tipo expresión es:"

#: ../Doc/reference/simple_stmts.rst:52
msgid ""
"An expression statement evaluates the expression list (which may be a single "
"expression)."
msgstr ""
"Una declaración de tipo expresión evalúa la lista de expresiones (que puede "
"ser una única expresión)."

#: ../Doc/reference/simple_stmts.rst:64
msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string is "
"written to standard output on a line by itself (except if the result is "
"``None``, so that procedure calls do not cause any output.)"
msgstr ""
"En modo interactivo, si el valor no es ``None``, es convertido a cadena de "
"caracteres usando la función built-in :func:`repr` y la cadena resultante es "
"escrita en la salida estándar en una línea por si sola (excepto si el "
"resultado es ``None``, entonces el procedimiento llamado no produce ninguna "
"salida.)"

#: ../Doc/reference/simple_stmts.rst:72
msgid "Assignment statements"
msgstr "Declaraciones de asignación"

#: ../Doc/reference/simple_stmts.rst:82
msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr ""
"Las declaraciones de asignación son usadas para (volver a) unir nombres a "
"valores y para modificar atributos o elementos de objetos mutables:"

#: ../Doc/reference/simple_stmts.rst:96
msgid ""
"(See section :ref:`primaries` for the syntax definitions for *attributeref*, "
"*subscription*, and *slicing*.)"
msgstr ""
"(Ver sección :ref:`primaries` para las definiciones de sintaxis para  "
"*attributeref*, *subscription*, y *slicing*.)"

#: ../Doc/reference/simple_stmts.rst:99
msgid ""
"An assignment statement evaluates the expression list (remember that this "
"can be a single expression or a comma-separated list, the latter yielding a "
"tuple) and assigns the single resulting object to each of the target lists, "
"from left to right."
msgstr ""
"Una declaración de asignación evalúa la lista de expresiones (recuerda que "
"ésta puede ser una única expresión o una lista separada por comas, la última "
"produce una tupla) y asigna el único objeto resultante a cada una de las "
"listas de objetivos, de izquierda a derecha."

#: ../Doc/reference/simple_stmts.rst:108
msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute reference, "
"subscription or slicing), the mutable object must ultimately perform the "
"assignment and decide about its validity, and may raise an exception if the "
"assignment is unacceptable.  The rules observed by various types and the "
"exceptions raised are given with the definition of the object types (see "
"section :ref:`types`)."
msgstr ""
"Las asignaciones son definidas recursivamente dependiendo de la forma del "
"objetivo (lista). Cuando el objetivo es parte de un objeto mutable (una "
"referencia a un atributo, una subscripción o un segmento), el objeto mutable "
"finalmente debe realizar la asignación y decidir sobre su validez, y puede "
"lanzar una excepción si la asignación no es aceptable. Las reglas observadas "
"por varios tipos y las excepciones lanzadas se dan con la definición de los "
"tipos de objeto (ver sección :ref:`types`)."

#: ../Doc/reference/simple_stmts.rst:121
msgid ""
"Assignment of an object to a target list, optionally enclosed in parentheses "
"or square brackets, is recursively defined as follows."
msgstr ""
"La asignación de un objeto a una lista de destino, opcionalmente entre "
"paréntesis o corchetes, se define de forma recursiva de la siguiente manera."

#: ../Doc/reference/simple_stmts.rst:124
msgid ""
"If the target list is a single target with no trailing comma, optionally in "
"parentheses, the object is assigned to that target."
msgstr ""
"Si la lista de destino es un único objeto sin terminar en coma, "
"opcionalmente entre paréntesis, el objeto es asignado a ese objetivo."

#: ../Doc/reference/simple_stmts.rst:127 ../Doc/reference/simple_stmts.rst:139
msgid ""
"Else: The object must be an iterable with the same number of items as there "
"are targets in the target list, and the items are assigned, from left to "
"right, to the corresponding targets."
msgstr ""
"Sino: el objeto debe ser iterable con el mismo número de elementos que los "
"elementos en la lista de objetivos, y los elementos son asignados a sus "
"respectivos objetivos de izquierda a derecha."

#: ../Doc/reference/simple_stmts.rst:131
msgid ""
"If the target list contains one target prefixed with an asterisk, called a "
"\"starred\" target: The object must be an iterable with at least as many "
"items as there are targets in the target list, minus one.  The first items "
"of the iterable are assigned, from left to right, to the targets before the "
"starred target.  The final items of the iterable are assigned to the targets "
"after the starred target.  A list of the remaining items in the iterable is "
"then assigned to the starred target (the list can be empty)."
msgstr ""
"Si la lista de objetivos contiene un objetivo prefijado con un asterisco, "
"llamado objetivo “destacado”: El objeto debe ser iterable con al menos "
"tantos elementos como objetivos en la lista de objetivos, menos uno. Los "
"primeros elementos del iterable se asignan, de izquierda a derecha, a los "
"objetivos antes del objetivo destacado. Los elementos finales del iterable "
"se asignan a los objetivos después del objetivo destacado. Luego se asigna "
"una lista de los elementos restantes en el iterable al objetivo destacado "
"(la lista puede estar vacía)."

#: ../Doc/reference/simple_stmts.rst:143
msgid ""
"Assignment of an object to a single target is recursively defined as follows."
msgstr ""
"La asignación de un objeto a un único objetivo se define a continuación de "
"manera recursiva."

#: ../Doc/reference/simple_stmts.rst:145
msgid "If the target is an identifier (name):"
msgstr "Si el objetivo es un identificador (nombre):"

#: ../Doc/reference/simple_stmts.rst:147
msgid ""
"If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` "
"statement in the current code block: the name is bound to the object in the "
"current local namespace."
msgstr ""
"Si el nombre no ocurre en una declaración :keyword:`global` o :keyword:"
"`nonlocal` en el actual bloque de código: el nombre es unido al objeto del "
"actual espacio de nombres local."

#: ../Doc/reference/simple_stmts.rst:151
msgid ""
"Otherwise: the name is bound to the object in the global namespace or the "
"outer namespace determined by :keyword:`nonlocal`, respectively."
msgstr ""
"Por otra parte: el nombre es unido al objeto en el nombre de espacio global "
"o el nombre de espacio exterior determinado por :keyword:`nonlocal`, "
"respectivamente."

#: ../Doc/reference/simple_stmts.rst:156
msgid ""
"The name is rebound if it was already bound.  This may cause the reference "
"count for the object previously bound to the name to reach zero, causing the "
"object to be deallocated and its destructor (if it has one) to be called."
msgstr ""
"El nombre se vuelve a unir si ya ha estado unido. Esto puede hacer que el "
"recuento de referencia para el objeto previamente vinculado al nombre llegue "
"a cero, provocando que el objeto se desasigne y se llame a su destructor (si "
"tiene uno)."

#: ../Doc/reference/simple_stmts.rst:162
msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given attribute; "
"if it cannot perform the assignment, it raises an exception (usually but not "
"necessarily :exc:`AttributeError`)."
msgstr ""
"Si el destino es una referencia de atributo: se evalúa la expresión primaria "
"en la referencia. Debe producir un objeto con atributos asignables; si este "
"no es el caso, una excepción :exc:`TypeError` es lanzada.  Luego se le pide "
"a ese objeto que asigne el objeto asignado al atributo dado; si no puede "
"realizar la tarea, lanza una excepción (generalmente pero no necesariamente :"
"exc:`AttributeError`)."

#: ../Doc/reference/simple_stmts.rst:171
msgid ""
"Note: If the object is a class instance and the attribute reference occurs "
"on both sides of the assignment operator, the right-hand side expression, "
"``a.x`` can access either an instance attribute or (if no instance attribute "
"exists) a class attribute.  The left-hand side target ``a.x`` is always set "
"as an instance attribute, creating it if necessary.  Thus, the two "
"occurrences of ``a.x`` do not necessarily refer to the same attribute: if "
"the right-hand side expression refers to a class attribute, the left-hand "
"side creates a new instance attribute as the target of the assignment::"
msgstr ""
"Nota: Si el objeto es una instancia de clase y la referencia de atributo "
"ocurre en ambos lados del operador de asignación, la expresión del lado "
"derecho, ``a.x`` puede acceder a un atributo de instancia o (si no existe un "
"atributo de instancia) a una clase atributo. El objetivo del lado izquierdo "
"``a.x`` siempre se establece como un atributo de instancia, creándolo si es "
"necesario. Por lo tanto, las dos ocurrencias de ``a.x`` no necesariamente se "
"refieren al mismo atributo: si la expresión del lado derecho se refiere a un "
"atributo de clase, el lado izquierdo crea un nuevo atributo de instancia "
"como el objetivo de la asignación::"

#: ../Doc/reference/simple_stmts.rst:185
msgid ""
"This description does not necessarily apply to descriptor attributes, such "
"as properties created with :func:`property`."
msgstr ""
"Esta descripción no se aplica necesariamente a los atributos del descriptor, "
"como las propiedades creadas con :func:`property`."

#: ../Doc/reference/simple_stmts.rst:192
msgid ""
"If the target is a subscription: The primary expression in the reference is "
"evaluated.  It should yield either a mutable sequence object (such as a "
"list) or a mapping object (such as a dictionary).  Next, the subscript "
"expression is evaluated."
msgstr ""
"Si el objetivo es una suscripción: se evalúa la expresión primaria en la "
"referencia. Debe producir un objeto de secuencia mutable (como una lista) o "
"un objeto de mapeo (como un diccionario). A continuación, se evalúa la "
"expresión del subíndice."

#: ../Doc/reference/simple_stmts.rst:201
msgid ""
"If the primary is a mutable sequence object (such as a list), the subscript "
"must yield an integer.  If it is negative, the sequence's length is added to "
"it.  The resulting value must be a nonnegative integer less than the "
"sequence's length, and the sequence is asked to assign the assigned object "
"to its item with that index.  If the index is out of range, :exc:"
"`IndexError` is raised (assignment to a subscripted sequence cannot add new "
"items to a list)."
msgstr ""
"Si el primario es un objeto de secuencia mutable (como una lista), el "
"subíndice debe producir un número entero. Si es negativo, se le suma la "
"longitud de la secuencia. El valor resultante debe ser un número entero no "
"negativo menor que la longitud de la secuencia, y se le pide a la secuencia "
"que asigne el objeto asignado a su elemento con ese índice. Si el índice "
"está fuera de rango, :exc:`IndexError` se lanza (la asignación a una "
"secuencia suscrita no puede agregar nuevos elementos a una lista)."

#: ../Doc/reference/simple_stmts.rst:212
msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping is "
"then asked to create a key/datum pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with "
"the same key value, or insert a new key/value pair (if no key with the same "
"value existed)."
msgstr ""
"Si el principal es un objeto de mapeo (como un diccionario), el subíndice "
"debe tener un tipo compatible con el tipo de clave del mapeo, y luego se le "
"pide al mapeo que cree un par clave / dato que mapee el subíndice al objeto "
"asignado. Esto puede reemplazar un par clave / valor existente con el mismo "
"valor clave o insertar un nuevo par clave / valor (si no existía ninguna "
"clave con el mismo valor)."

#: ../Doc/reference/simple_stmts.rst:218
msgid ""
"For user-defined objects, the :meth:`__setitem__` method is called with "
"appropriate arguments."
msgstr ""
"Para objetos definidos por el usuario, se llama al método :meth:"
"`__setitem__` con los argumentos apropiados."

#: ../Doc/reference/simple_stmts.rst:223
msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  The "
"assigned object should be a sequence object of the same type.  Next, the "
"lower and upper bound expressions are evaluated, insofar they are present; "
"defaults are zero and the sequence's length.  The bounds should evaluate to "
"integers. If either bound is negative, the sequence's length is added to "
"it.  The resulting bounds are clipped to lie between zero and the sequence's "
"length, inclusive.  Finally, the sequence object is asked to replace the "
"slice with the items of the assigned sequence.  The length of the slice may "
"be different from the length of the assigned sequence, thus changing the "
"length of the target sequence, if the target sequence allows it."
msgstr ""
"Si el destino es un rebanado (*slicing*): la expresión principal de la "
"referencia es evaluada. Debería producir un objeto de secuencia mutable "
"(como una lista). El objeto asignado debe ser un objeto de secuencia del "
"mismo tipo. A continuación, se evalúan las expresiones de límite superior e "
"inferior, en la medida en que estén presentes; los valores predeterminados "
"son cero y la longitud de la secuencia. Los límites deben evaluarse a "
"números enteros. Si alguno de los límites es negativo, se le suma la "
"longitud de la secuencia. Los límites resultantes se recortan para que se "
"encuentren entre cero y la longitud de la secuencia, inclusive. Finalmente, "
"se solicita al objeto de secuencia que reemplace el segmento con los "
"elementos de la secuencia asignada. La longitud del corte puede ser "
"diferente de la longitud de la secuencia asignada, cambiando así la longitud "
"de la secuencia objetivo, si la secuencia objetivo lo permite."

#: ../Doc/reference/simple_stmts.rst:237
msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr ""
"En la implementación actual, se considera que la sintaxis de los objetivos "
"es la misma que la de las expresiones y se rechaza la sintaxis no válida "
"durante la fase de generación del código, lo que genera mensajes de error "
"menos detallados."

#: ../Doc/reference/simple_stmts.rst:241
msgid ""
"Although the definition of assignment implies that overlaps between the left-"
"hand side and the right-hand side are 'simultaneous' (for example ``a, b = "
"b, a`` swaps two variables), overlaps *within* the collection of assigned-to "
"variables occur left-to-right, sometimes resulting in confusion.  For "
"instance, the following program prints ``[0, 2]``::"
msgstr ""
"Aunque la definición de asignación implica que las superposiciones entre el "
"lado izquierdo y el lado derecho son ‘simultáneas’ (por ejemplo, ``a, b = b, "
"a`` intercambia dos variables), las superposiciones *dentro* de la colección "
"de las variables asignadas ocurren de izquierda a derecha, lo que a veces "
"genera confusión. Por ejemplo, el siguiente programa imprime ``[0, 2]``::"

#: ../Doc/reference/simple_stmts.rst:255
msgid ":pep:`3132` - Extended Iterable Unpacking"
msgstr ":pep:`3132` - Desembalaje Iterable Extendido"

#: ../Doc/reference/simple_stmts.rst:256
msgid "The specification for the ``*target`` feature."
msgstr "La especificación para la función ``*target``."

#: ../Doc/reference/simple_stmts.rst:262
msgid "Augmented assignment statements"
msgstr "Declaraciones de asignación aumentada"

#: ../Doc/reference/simple_stmts.rst:280
msgid ""
"Augmented assignment is the combination, in a single statement, of a binary "
"operation and an assignment statement:"
msgstr ""
"La asignación aumentada es la combinación, en una sola declaración, de una "
"operación binaria y una declaración de asignación:"

#: ../Doc/reference/simple_stmts.rst:289
msgid ""
"(See section :ref:`primaries` for the syntax definitions of the last three "
"symbols.)"
msgstr ""
"(Ver sección :ref:`primaries` para la definición de la sintaxis de los tres "
"últimos símbolos.)"

#: ../Doc/reference/simple_stmts.rst:292
msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the two "
"operands, and assigns the result to the original target.  The target is only "
"evaluated once."
msgstr ""
"Una asignación aumentada evalúa el destino (que, a diferencia de las "
"declaraciones de asignación normales, no puede ser un desempaquetado) y la "
"lista de expresiones, realiza la operación binaria específica del tipo de "
"asignación en los dos operandos y asigna el resultado al destino original.  "
"El objetivo sólo se evalúa una vez."

#: ../Doc/reference/simple_stmts.rst:297
msgid ""
"An augmented assignment expression like ``x += 1`` can be rewritten as ``x = "
"x + 1`` to achieve a similar, but not exactly equal effect. In the augmented "
"version, ``x`` is only evaluated once. Also, when possible, the actual "
"operation is performed *in-place*, meaning that rather than creating a new "
"object and assigning that to the target, the old object is modified instead."
msgstr ""
"Una declaración de asignación aumentada como ``x += 1`` puede ser reescriba "
"como ``x = x + 1`` para alcanzar un efecto similar pero no exactamente "
"igual. En la versión aumentada, ``x`` es evaluada una única vez. Además, "
"cuando es posible, la operación real se realiza *in-place*, lo que significa "
"que en lugar de crear un nuevo objeto y asignarlo al objetivo, el objeto "
"anterior se modifica."

#: ../Doc/reference/simple_stmts.rst:303
msgid ""
"Unlike normal assignments, augmented assignments evaluate the left-hand side "
"*before* evaluating the right-hand side.  For example, ``a[i] += f(x)`` "
"first looks-up ``a[i]``, then it evaluates ``f(x)`` and performs the "
"addition, and lastly, it writes the result back to ``a[i]``."
msgstr ""
"A diferencia de las asignaciones normales, las asignaciones aumentadas "
"evalúan el lado izquierdo *antes* de evaluar el lado derecho.  Por ejemplo, "
"``a[i] += f(x)`` primero busca ``a[i]``, entonces evalúa ``f(x)`` y realiza "
"la suma, y finalmente, vuelve a escribir el resultado en ``a[i]``."

#: ../Doc/reference/simple_stmts.rst:308
msgid ""
"With the exception of assigning to tuples and multiple targets in a single "
"statement, the assignment done by augmented assignment statements is handled "
"the same way as normal assignments. Similarly, with the exception of the "
"possible *in-place* behavior, the binary operation performed by augmented "
"assignment is the same as the normal binary operations."
msgstr ""
"Con la excepción de la asignación a tuplas y múltiples objetivos en una sola "
"instrucción, la asignación realizada por las instrucciones de asignación "
"aumentada se maneja de la misma manera que las asignaciones normales. De "
"manera similar, con la excepción del posible comportamiento *in situ*, la "
"operación binaria realizada por la asignación aumentada es la misma que las "
"operaciones binarias normales."

#: ../Doc/reference/simple_stmts.rst:314
msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr ""
"Para destinos que son referencias a atributos, lo mismo que :ref:`caveat "
"about class and instance attributes <attr-target-note>` se aplica para "
"asignaciones regulares."

#: ../Doc/reference/simple_stmts.rst:321
msgid "Annotated assignment statements"
msgstr "Declaraciones de asignación anotadas"

#: ../Doc/reference/simple_stmts.rst:328
msgid ""
":term:`Annotation <variable annotation>` assignment is the combination, in a "
"single statement, of a variable or attribute annotation and an optional "
"assignment statement:"
msgstr ""
"Asignación :term:`Annotation <variable annotation>` es la combinación, en "
"una única declaración, de una variable o anotación de atributo y una "
"declaración de asignación opcional:"

#: ../Doc/reference/simple_stmts.rst:335
msgid ""
"The difference from normal :ref:`assignment` is that only single target is "
"allowed."
msgstr ""
"La diferencia respecto a :ref:`assignment` normal es que sólo se permite un "
"único objetivo."

#: ../Doc/reference/simple_stmts.rst:337
msgid ""
"For simple names as assignment targets, if in class or module scope, the "
"annotations are evaluated and stored in a special class or module attribute :"
"attr:`__annotations__` that is a dictionary mapping from variable names "
"(mangled if private) to evaluated annotations. This attribute is writable "
"and is automatically created at the start of class or module body execution, "
"if annotations are found statically."
msgstr ""
"Para nombres simples como destinos de asignación, si están en el ámbito de "
"clase o módulo, las anotaciones se evalúan y almacenan en una clase especial "
"o atributo de módulo :attr:`__annotations__` que es una asignación de "
"diccionario de nombres de variables (alterados si son privados) a "
"anotaciones evaluadas. Este atributo se puede escribir y se crea "
"automáticamente al comienzo de la ejecución del cuerpo del módulo o la "
"clase, si las anotaciones se encuentran estáticamente."

#: ../Doc/reference/simple_stmts.rst:345
msgid ""
"For expressions as assignment targets, the annotations are evaluated if in "
"class or module scope, but not stored."
msgstr ""
"Para expresiones como destinos de asignaciones, las anotaciones se evalúan "
"si están en ámbitos de clase o módulo pero no se almacenan."

#: ../Doc/reference/simple_stmts.rst:348
msgid ""
"If a name is annotated in a function scope, then this name is local for that "
"scope. Annotations are never evaluated and stored in function scopes."
msgstr ""
"Si se anota un nombre en el ámbito de una función, este nombre es local para "
"ese ámbito. Las anotaciones nunca se evalúan y almacenan en ámbitos de "
"función."

#: ../Doc/reference/simple_stmts.rst:351
msgid ""
"If the right hand side is present, an annotated assignment performs the "
"actual assignment before evaluating annotations (where applicable). If the "
"right hand side is not present for an expression target, then the "
"interpreter evaluates the target except for the last :meth:`__setitem__` or :"
"meth:`__setattr__` call."
msgstr ""
"Si el lado derecho está presente, una tarea anotada realiza la tarea real "
"antes de evaluar las anotaciones (cuando corresponda). Si el lado derecho no "
"está presente para un destino de expresión, entonces el intérprete evalúa el "
"destino excepto por la última llamada :meth:`__setitem__` o :meth:"
"`__setattr__`."

#: ../Doc/reference/simple_stmts.rst:362
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - Sintaxis para anotaciones de variable"

#: ../Doc/reference/simple_stmts.rst:360
msgid ""
"The proposal that added syntax for annotating the types of variables "
"(including class variables and instance variables), instead of expressing "
"them through comments."
msgstr ""
"La propuesta que agregó sintaxis para anotar los tipos de variables "
"(incluidas variables de clase y variables de instancia), en lugar de "
"expresarlas a través de comentarios."

#: ../Doc/reference/simple_stmts.rst:366
msgid ":pep:`484` - Type hints"
msgstr ":pep:`484` - Indicadores de tipo"

#: ../Doc/reference/simple_stmts.rst:365
msgid ""
"The proposal that added the :mod:`typing` module to provide a standard "
"syntax for type annotations that can be used in static analysis tools and "
"IDEs."
msgstr ""
"La propuesta que agregó el módulo :mod:`typing` para proporcionar una "
"sintaxis estándar para las anotaciones de tipo para ser utilizadas en "
"herramientas de análisis estático e IDEs."

#: ../Doc/reference/simple_stmts.rst:369
msgid ""
"Now annotated assignments allow same expressions in the right hand side as "
"the regular assignments. Previously, some expressions (like un-parenthesized "
"tuple expressions) caused a syntax error."
msgstr ""
"Ahora, las asignaciones anotadas permiten las mismas expresiones en el lado "
"derecho que las asignaciones regulares. Anteriormente, algunas expresiones "
"(como las expresiones de tupla sin paréntesis) provocaban un error de "
"sintaxis."

#: ../Doc/reference/simple_stmts.rst:378
msgid "The :keyword:`!assert` statement"
msgstr "La declaración :keyword:`!assert`"

#: ../Doc/reference/simple_stmts.rst:385
msgid ""
"Assert statements are a convenient way to insert debugging assertions into a "
"program:"
msgstr ""
"Las declaraciones de afirmación son una forma conveniente de insertar "
"afirmaciones de depuración en un programa:"

#: ../Doc/reference/simple_stmts.rst:391
msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr "La forma simple, ``assert expressionn``, es equivalente a ::"

#: ../Doc/reference/simple_stmts.rst:396
msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr ""
"La forma extendida, ``assert expression1, expression2``, es equivalente a ::"

#: ../Doc/reference/simple_stmts.rst:405
msgid ""
"These equivalences assume that :const:`__debug__` and :exc:`AssertionError` "
"refer to the built-in variables with those names.  In the current "
"implementation, the built-in variable :const:`__debug__` is ``True`` under "
"normal circumstances, ``False`` when optimization is requested (command line "
"option :option:`-O`).  The current code generator emits no code for an "
"assert statement when optimization is requested at compile time.  Note that "
"it is unnecessary to include the source code for the expression that failed "
"in the error message; it will be displayed as part of the stack trace."
msgstr ""
"Estas equivalencias asumen que :const:`__debug__` y :exc:`AssertionError` se "
"refieren a las variables integradas con esos nombres.  En la implementación "
"actual, la variable incorporada :const:`__debug__` es ``True`` en "
"circunstancias normales, ``False`` cuando se solicita la optimización "
"(opción de línea de comando :option:`-O`).  El generador de código actual no "
"emite código para una declaración de aserción cuando se solicita la "
"optimización en tiempo de compilación.  Tenga en cuenta que no es necesario "
"incluir el código fuente de la expresión que falló en el mensaje de error; "
"se mostrará como parte del seguimiento de la pila."

#: ../Doc/reference/simple_stmts.rst:414
msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-in "
"variable is determined when the interpreter starts."
msgstr ""
"Asignaciones a :const:`__debug__` son ilegales.  El valor para la variable "
"se determina cuando arranca el intérprete."

#: ../Doc/reference/simple_stmts.rst:421
msgid "The :keyword:`!pass` statement"
msgstr "La declaración :keyword:`!pass`"

#: ../Doc/reference/simple_stmts.rst:431
msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ""
":keyword:`pass` es una operación nula --- cuando se ejecuta, no sucede nada. "
"Es útil como marcador de posición cuando se requiere una declaración "
"sintácticamente, pero no es necesario ejecutar código, por ejemplo::"

#: ../Doc/reference/simple_stmts.rst:443
msgid "The :keyword:`!del` statement"
msgstr "La declaración :keyword:`!del`"

#: ../Doc/reference/simple_stmts.rst:453
msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some hints."
msgstr ""
"La eliminación se define de forma recursiva de manera muy similar a la forma "
"en que se define la asignación. En lugar de explicarlo con todos los "
"detalles, aquí hay algunas sugerencias."

#: ../Doc/reference/simple_stmts.rst:456
msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr ""
"La eliminación de una lista de objetivos elimina cada objetivo de forma "
"recursiva, de izquierda a derecha."

#: ../Doc/reference/simple_stmts.rst:462
msgid ""
"Deletion of a name removes the binding of that name from the local or global "
"namespace, depending on whether the name occurs in a :keyword:`global` "
"statement in the same code block.  If the name is unbound, a :exc:"
"`NameError` exception will be raised."
msgstr ""
"La eliminación de un nombre elimina la vinculación de ese nombre del espacio "
"de nombres local o global, dependiendo de si el nombre aparece en una "
"declaración :keyword:`global` en el mismo bloque de código.  Si el nombre no "
"está vinculado, se lanzará una excepción :exc:`NameError`."

#: ../Doc/reference/simple_stmts.rst:469
msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to "
"the primary object involved; deletion of a slicing is in general equivalent "
"to assignment of an empty slice of the right type (but even this is "
"determined by the sliced object)."
msgstr ""
"La supresión de referencias de atributo, suscripciones y rebanadas se pasa "
"al objeto primario involucrado; la eliminación de una rebanada es en general "
"equivalente a la asignación de una rebanada vacía del tipo correcto (pero "
"incluso esto está determinado por el objeto rebanado)."

#: ../Doc/reference/simple_stmts.rst:474
msgid ""
"Previously it was illegal to delete a name from the local namespace if it "
"occurs as a free variable in a nested block."
msgstr ""
"Anteriormente era ilegal eliminar un nombre del espacio de nombres local si "
"aparece como una variable libre en un bloque anidado."

#: ../Doc/reference/simple_stmts.rst:482
msgid "The :keyword:`!return` statement"
msgstr "La declaración :keyword:`!return`"

#: ../Doc/reference/simple_stmts.rst:492
msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ""
"El :keyword:`return` sólo puede ocurrir sintácticamente anidado en una "
"definición de función, no dentro de una definición de clase anidada."

#: ../Doc/reference/simple_stmts.rst:495
msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr ""
"Si una lista de expresiones es presente, ésta es evaluada, sino es "
"substituida por ``None`` ."

#: ../Doc/reference/simple_stmts.rst:497
msgid ""
":keyword:`return` leaves the current function call with the expression list "
"(or ``None``) as return value."
msgstr ""
":keyword:`return` deja la llamada a la función actual con la lista de "
"expresiones (o ``None``) como valor de retorno."

#: ../Doc/reference/simple_stmts.rst:502
msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the function."
msgstr ""
"Cuando :keyword:`return` pasa el control de una sentencia :keyword:`try` con "
"una cláusula :keyword:`finally`, esa cláusula :keyword:`!finally` se ejecuta "
"antes de dejar realmente la función."

#: ../Doc/reference/simple_stmts.rst:506
msgid ""
"In a generator function, the :keyword:`return` statement indicates that the "
"generator is done and will cause :exc:`StopIteration` to be raised. The "
"returned value (if any) is used as an argument to construct :exc:"
"`StopIteration` and becomes the :attr:`StopIteration.value` attribute."
msgstr ""
"En una función generadora, la declaración :keyword:`return` indica que el "
"generador ha acabado y hará que :exc:`StopIteration` se lance. El valor "
"retornado (si lo hay) se utiliza como argumento para construir :exc:"
"`StopIteration` y se convierte en el atributo :attr:`StopIteration.value`."

#: ../Doc/reference/simple_stmts.rst:511
msgid ""
"In an asynchronous generator function, an empty :keyword:`return` statement "
"indicates that the asynchronous generator is done and will cause :exc:"
"`StopAsyncIteration` to be raised.  A non-empty :keyword:`!return` statement "
"is a syntax error in an asynchronous generator function."
msgstr ""
"En una función de generador asíncrono, una declaración :keyword:`return` "
"vacía indica que el generador asíncrono ha acabado y va a lanzar un :exc:"
"`StopAsyncIteration`.  Una declaración :keyword:`!return` no vacía es un "
"error de sintaxis en una función generadora asíncrona."

#: ../Doc/reference/simple_stmts.rst:519
msgid "The :keyword:`!yield` statement"
msgstr "La declaración :keyword:`!yield`"

#: ../Doc/reference/simple_stmts.rst:531
msgid ""
"A :keyword:`yield` statement is semantically equivalent to a :ref:`yield "
"expression <yieldexpr>`. The yield statement can be used to omit the "
"parentheses that would otherwise be required in the equivalent yield "
"expression statement. For example, the yield statements ::"
msgstr ""
"La declaración :keyword:`yield` es semánticamente equivalente a :ref:`yield "
"expression <yieldexpr>`. Una declaración de producción se puede utilizar "
"para omitir los paréntesis que de otro modo serían necesarios en la "
"declaración de expresión de producción equivalente. Por ejemplo, las "
"declaraciones de producción ::"

#: ../Doc/reference/simple_stmts.rst:539
msgid "are equivalent to the yield expression statements ::"
msgstr "son equivalentes a las funciones que producen declaraciones ::"

#: ../Doc/reference/simple_stmts.rst:544
msgid ""
"Yield expressions and statements are only used when defining a :term:"
"`generator` function, and are only used in the body of the generator "
"function.  Using yield in a function definition is sufficient to cause that "
"definition to create a generator function instead of a normal function."
msgstr ""
"Expresiones y declaraciones productoras se usan únicamente para definir una "
"función :term:`generator`, y son utilizadas únicamente en el cuerpo de una "
"función generadora.  Usar producción en una definición de función es "
"suficiente para hacer que esa definición cree una función generadora en "
"lugar de una función normal."

#: ../Doc/reference/simple_stmts.rst:549
msgid ""
"For full details of :keyword:`yield` semantics, refer to the :ref:"
"`yieldexpr` section."
msgstr ""
"Para todos los detalles de la semántica de :keyword:`yield`, referirse a la "
"sección :ref:`yieldexpr`."

#: ../Doc/reference/simple_stmts.rst:555
msgid "The :keyword:`!raise` statement"
msgstr "La declaración :keyword:`!raise`"

#: ../Doc/reference/simple_stmts.rst:566
msgid ""
"If no expressions are present, :keyword:`raise` re-raises the last exception "
"that was active in the current scope.  If no exception is active in the "
"current scope, a :exc:`RuntimeError` exception is raised indicating that "
"this is an error."
msgstr ""
"Si no hay expresiones presentes, :keyword:`raise` vuelve a lanzar la última "
"excepción que estaba activa en el ámbito actual.  Si no hay ninguna "
"excepción activa en el alcance actual, se lanza una :exc:`RuntimeError` que "
"indica que se trata de un error."

#: ../Doc/reference/simple_stmts.rst:571
msgid ""
"Otherwise, :keyword:`raise` evaluates the first expression as the exception "
"object.  It must be either a subclass or an instance of :class:"
"`BaseException`. If it is a class, the exception instance will be obtained "
"when needed by instantiating the class with no arguments."
msgstr ""
"De lo contrario, :keyword:`raise` evalúa la primera expresión como el objeto "
"de excepción.  Debe ser una subclase o una instancia de :class:"
"`BaseException`. Si es una clase, la instancia de excepción se obtendrá "
"cuando sea necesario creando una instancia de la clase sin argumentos."

#: ../Doc/reference/simple_stmts.rst:576
msgid ""
"The :dfn:`type` of the exception is the exception instance's class, the :dfn:"
"`value` is the instance itself."
msgstr ""
"El :dfn:`type` de la excepción es la instancia de la clase excepción, el :"
"dfn:`value` es la propia instancia."

#: ../Doc/reference/simple_stmts.rst:581
msgid ""
"A traceback object is normally created automatically when an exception is "
"raised and attached to it as the :attr:`__traceback__` attribute, which is "
"writable. You can create an exception and set your own traceback in one step "
"using the :meth:`with_traceback` exception method (which returns the same "
"exception instance, with its traceback set to its argument), like so::"
msgstr ""
"Normalmente, un objeto de rastreo se crea automáticamente cuando se lanza "
"una excepción y se le adjunta como atributo :attr:`__traceback__`, que se "
"puede escribir. Puede crear una excepción y establecer su propio rastreo en "
"un solo paso utilizando el método de excepción :meth:`with_traceback` (que "
"retorna la misma instancia de excepción, con su rastreo establecido en su "
"argumento), así::"

#: ../Doc/reference/simple_stmts.rst:593
msgid ""
"The ``from`` clause is used for exception chaining: if given, the second "
"*expression* must be another exception class or instance, which will then be "
"attached to the raised exception as the :attr:`__cause__` attribute (which "
"is writable).  If the raised exception is not handled, both exceptions will "
"be printed::"
msgstr ""
"La clausura ``from`` se usa para el encadenamiento de excepciones: si se "
"proporciona, la segunda *expresión* debe ser otra clase o instancia de "
"excepción, que luego se adjuntará a la excepción lanzada como el atributo "
"de :attr:`__cause__` (que se puede escribir).  Si no se maneja la excepción "
"lanzada, se imprimirán ambas excepciones::"

#: ../Doc/reference/simple_stmts.rst:614
msgid ""
"A similar mechanism works implicitly if an exception is raised inside an "
"exception handler or a :keyword:`finally` clause: the previous exception is "
"then attached as the new exception's :attr:`__context__` attribute::"
msgstr ""
"Un mecanismo similar funciona implícitamente si se lanza una excepción "
"dentro de un controlador de excepciones o una cláusula :keyword:`finally`: "
"la excepción anterior se adjunta como el atributo :attr:`__context__` de la "
"nueva excepción::"

#: ../Doc/reference/simple_stmts.rst:633
msgid ""
"Exception chaining can be explicitly suppressed by specifying :const:`None` "
"in the ``from`` clause::"
msgstr ""
"El encadenamiento de excepciones se puede suprimir explícitamente "
"especificando :const:`None` en la cláusula ``from``:"

#: ../Doc/reference/simple_stmts.rst:645
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information about handling exceptions is in section :ref:"
"`try`."
msgstr ""
"Se puede encontrar información adicional sobre excepciones en la sección :"
"ref:`exceptions`, e información sobre manejo de excepciones en la sección :"
"ref:`try`."

#: ../Doc/reference/simple_stmts.rst:648
msgid ":const:`None` is now permitted as ``Y`` in ``raise X from Y``."
msgstr ":const:`None` ahora es permitido como ``Y`` en ``raise X from Y``."

#: ../Doc/reference/simple_stmts.rst:651
msgid ""
"The ``__suppress_context__`` attribute to suppress automatic display of the "
"exception context."
msgstr ""
"El atributo ``__suppress_context__`` para suprimir la visualización "
"automática del contexto de excepción."

#: ../Doc/reference/simple_stmts.rst:658
msgid "The :keyword:`!break` statement"
msgstr "La declaración :keyword:`!break`"

#: ../Doc/reference/simple_stmts.rst:669
msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` or :"
"keyword:`while` loop, but not nested in a function or class definition "
"within that loop."
msgstr ""
":keyword:`break` solo puede ocurrir sintácticamente anidado en un bucle :"
"keyword:`for` o :keyword:`while`, pero no anidado en una función o "
"definición de clase dentro de ese bucle."

#: ../Doc/reference/simple_stmts.rst:676
msgid ""
"It terminates the nearest enclosing loop, skipping the optional :keyword:`!"
"else` clause if the loop has one."
msgstr ""
"Termina el bucle adjunto más cercano, omitiendo la cláusula :keyword:`!else` "
"opcional si el bucle tiene una."

#: ../Doc/reference/simple_stmts.rst:679
msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control "
"target keeps its current value."
msgstr ""
"Si un bucle :keyword:`for` es terminado por :keyword:`break`, el objetivo de "
"control de bucle mantiene su valor actual."

#: ../Doc/reference/simple_stmts.rst:684
msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the loop."
msgstr ""
"Cuando :keyword:`break` pasa el control de una sentencia :keyword:`try` con "
"una cláusula :keyword:`finally`, esa cláusula :keyword:`!finally` se ejecuta "
"antes de dejar realmente el bucle."

#: ../Doc/reference/simple_stmts.rst:692
msgid "The :keyword:`!continue` statement"
msgstr "La declaración :keyword:`!continue`"

#: ../Doc/reference/simple_stmts.rst:704
msgid ""
":keyword:`continue` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class definition "
"within that loop.  It continues with the next cycle of the nearest enclosing "
"loop."
msgstr ""
":keyword:`continue` sólo puede ocurrir sintácticamente anidado en el ciclo :"
"keyword:`for` o :keyword:`while`, pero no anidado en una función o "
"definición de clase dentro de ese ciclo.  Continúa con la siguiente "
"iteración del bucle envolvente más cercano."

#: ../Doc/reference/simple_stmts.rst:708
msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`!finally` clause is "
"executed before really starting the next loop cycle."
msgstr ""
"Cuando :keyword:`continue` pasa el control de una sentencia :keyword:`try` "
"con una cláusula :keyword:`finally`, esa cláusula :keyword:`!finally` se "
"ejecuta antes de empezar realmente el siguiente ciclo del bucle."

#: ../Doc/reference/simple_stmts.rst:717
msgid "The :keyword:`!import` statement"
msgstr "La declaración :keyword:`!import`"

#: ../Doc/reference/simple_stmts.rst:738
msgid ""
"The basic import statement (no :keyword:`from` clause) is executed in two "
"steps:"
msgstr ""
"La declaración básica de importación (sin la cláusula :keyword:`from`) es "
"ejecutada en 2 pasos:"

#: ../Doc/reference/simple_stmts.rst:741
msgid "find a module, loading and initializing it if necessary"
msgstr "encontrar un módulo, cargarlo e inicializarlo en caso de ser necesario"

#: ../Doc/reference/simple_stmts.rst:742
msgid ""
"define a name or names in the local namespace for the scope where the :"
"keyword:`import` statement occurs."
msgstr ""
"define un nombre o nombres en el espacio de nombres local para el alcance "
"donde ocurre la instrucción :keyword:`import`."

#: ../Doc/reference/simple_stmts.rst:745
msgid ""
"When the statement contains multiple clauses (separated by commas) the two "
"steps are carried out separately for each clause, just as though the clauses "
"had been separated out into individual import statements."
msgstr ""
"Cuando la declaración contiene varias cláusulas (separadas por comas), los "
"dos pasos se llevan a cabo por separado para cada cláusula, como si las "
"cláusulas se hubieran separado en declaraciones de importación individuales."

#: ../Doc/reference/simple_stmts.rst:750
msgid ""
"The details of the first step, finding and loading modules are described in "
"greater detail in the section on the :ref:`import system <importsystem>`, "
"which also describes the various types of packages and modules that can be "
"imported, as well as all the hooks that can be used to customize the import "
"system. Note that failures in this step may indicate either that the module "
"could not be located, *or* that an error occurred while initializing the "
"module, which includes execution of the module's code."
msgstr ""
"Los detalles del primer paso, búsqueda y carga de módulos se describen con "
"mayor detalle en la sección sobre el :ref:`import system <importsystem>`, "
"que también describe los distintos tipos de paquetes y módulos que se pueden "
"importar, así como todos los ganchos que se puede utilizar para personalizar "
"el sistema de importación. Tenga en cuenta que las fallas en este paso "
"pueden indicar que el módulo no se pudo ubicar, *o* que ocurrió un error al "
"inicializar el módulo, que incluye la ejecución del código del módulo."

#: ../Doc/reference/simple_stmts.rst:758
msgid ""
"If the requested module is retrieved successfully, it will be made available "
"in the local namespace in one of three ways:"
msgstr ""
"Si el módulo solicitado se recupera correctamente, estará disponible en el "
"espacio de nombres local de una de estas tres formas:"

#: ../Doc/reference/simple_stmts.rst:763
msgid ""
"If the module name is followed by :keyword:`!as`, then the name following :"
"keyword:`!as` is bound directly to the imported module."
msgstr ""
"Si el nombre del módulo va seguido de :keyword:`!as``, entonces el nombre "
"siguiente :keyword:`!as` está vinculado directamente al módulo importado."

#: ../Doc/reference/simple_stmts.rst:765
msgid ""
"If no other name is specified, and the module being imported is a top level "
"module, the module's name is bound in the local namespace as a reference to "
"the imported module"
msgstr ""
"Si no se especifica ningún otro nombre y el módulo que se está importando es "
"un módulo de nivel superior, el nombre del módulo se enlaza en el espacio de "
"nombres local como una referencia al módulo importado"

#: ../Doc/reference/simple_stmts.rst:768
msgid ""
"If the module being imported is *not* a top level module, then the name of "
"the top level package that contains the module is bound in the local "
"namespace as a reference to the top level package. The imported module must "
"be accessed using its full qualified name rather than directly"
msgstr ""
"Si el módulo que se está importando *no* es un módulo de nivel superior, "
"entonces el nombre del paquete de nivel superior que contiene el módulo se "
"enlaza en el espacio de nombres local como una referencia al paquete de "
"nivel superior. Se debe acceder al módulo importado utilizando su nombre "
"calificado completo en lugar de directamente"

#: ../Doc/reference/simple_stmts.rst:778
msgid "The :keyword:`from` form uses a slightly more complex process:"
msgstr "La forma :keyword:`from` usa un complejo un poco más complicado:"

#: ../Doc/reference/simple_stmts.rst:780
msgid ""
"find the module specified in the :keyword:`from` clause, loading and "
"initializing it if necessary;"
msgstr ""
"encuentra el módulo especificado en la cláusula :keyword:`from`, cargando e "
"inicializándolo si es necesario;"

#: ../Doc/reference/simple_stmts.rst:782
msgid "for each of the identifiers specified in the :keyword:`import` clauses:"
msgstr ""
"para cada uno de los identificadores especificados en la cláusula :keyword:"
"`import`:"

#: ../Doc/reference/simple_stmts.rst:784
msgid "check if the imported module has an attribute by that name"
msgstr "compruebe si el módulo importado tiene un atributo con ese nombre"

#: ../Doc/reference/simple_stmts.rst:785
msgid ""
"if not, attempt to import a submodule with that name and then check the "
"imported module again for that attribute"
msgstr ""
"de lo contrario, intente importar un submódulo con ese nombre y luego "
"verifique el módulo importado nuevamente para ese atributo"

#: ../Doc/reference/simple_stmts.rst:787
msgid "if the attribute is not found, :exc:`ImportError` is raised."
msgstr "si el atributo no se encuentra, :exc:`ImportError` es lanzada."

#: ../Doc/reference/simple_stmts.rst:788
msgid ""
"otherwise, a reference to that value is stored in the local namespace, using "
"the name in the :keyword:`!as` clause if it is present, otherwise using the "
"attribute name"
msgstr ""
"de lo contrario, una referencia a ese valor se almacena en el espacio de "
"nombres local, usando el nombre en la cláusula :keyword:`!as` si ésta está "
"presente, de lo contrario usando el nombre del atributo"

#: ../Doc/reference/simple_stmts.rst:792
msgid "Examples::"
msgstr "Ejemplos::"

#: ../Doc/reference/simple_stmts.rst:802
msgid ""
"If the list of identifiers is replaced by a star (``'*'``), all public names "
"defined in the module are bound in the local namespace for the scope where "
"the :keyword:`import` statement occurs."
msgstr ""
"Si la lista de identificadores se reemplaza por una estrella (``’*’``), "
"todos los nombres públicos definidos en el módulo se enlazan en el espacio "
"de nombres local para el ámbito donde ocurre la declaración :keyword:"
"`import`."

#: ../Doc/reference/simple_stmts.rst:808
msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must be "
"a sequence of strings which are names defined or imported by that module.  "
"The names given in ``__all__`` are all considered public and are required to "
"exist.  If ``__all__`` is not defined, the set of public names includes all "
"names found in the module's namespace which do not begin with an underscore "
"character (``'_'``).  ``__all__`` should contain the entire public API. It "
"is intended to avoid accidentally exporting items that are not part of the "
"API (such as library modules which were imported and used within the module)."
msgstr ""
"Los *nombres públicos* definidos por un módulo se determinan al verificar el "
"espacio de nombres del módulo en busca de una variable llamada ``__all__``; "
"si se define, debe ser una secuencia de cadenas que son nombres definidos o "
"importados por ese módulo.  Los nombres dados en ``__all__`` se consideran "
"públicos y se requiere que existan.  Si ``__all__`` no está definido, el "
"conjunto de nombres públicos incluye todos los nombres que se encuentran en "
"el espacio de nombres del módulo que no comienzan con un carácter de "
"subrayado (``’_’``).  ``__all__`` debe contener la API pública completa. Su "
"objetivo es evitar la exportación accidental de elementos que no forman "
"parte de la API (como los módulos de biblioteca que se importaron y "
"utilizaron dentro del módulo)."

#: ../Doc/reference/simple_stmts.rst:818
msgid ""
"The wild card form of import --- ``from module import *`` --- is only "
"allowed at the module level.  Attempting to use it in class or function "
"definitions will raise a :exc:`SyntaxError`."
msgstr ""
"La forma de importación comodín --- ``from module import *`` --- sólo se "
"permite a nivel módulo.  Intentar usarlo en una definición de clase o "
"función lanza una :exc:`SyntaxError`."

#: ../Doc/reference/simple_stmts.rst:825
msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within "
"another package it is possible to make a relative import within the same top "
"package without having to mention the package name. By using leading dots in "
"the specified module or package after :keyword:`from` you can specify how "
"high to traverse up the current package hierarchy without specifying exact "
"names. One leading dot means the current package where the module making the "
"import exists. Two dots means up one package level. Three dots is up two "
"levels, etc. So if you execute ``from . import mod`` from a module in the "
"``pkg`` package then you will end up importing ``pkg.mod``. If you execute "
"``from ..subpkg2 import mod`` from within ``pkg.subpkg1`` you will import "
"``pkg.subpkg2.mod``. The specification for relative imports is contained in "
"the :ref:`relativeimports` section."
msgstr ""
"Al especificar qué módulo importar, no es necesario especificar el nombre "
"absoluto del módulo. Cuando un módulo o paquete está contenido dentro de "
"otro paquete, es posible realizar una importación relativa dentro del mismo "
"paquete superior sin tener que mencionar el nombre del paquete. Al usar "
"puntos iniciales en el módulo o paquete especificado después de :keyword:"
"`from`, puede especificar qué tan alto recorrer la jerarquía actual del "
"paquete sin especificar nombres exactos. Un punto inicial significa el "
"paquete actual donde existe el módulo que realiza la importación. Dos puntos "
"significan un nivel de paquete. Tres puntos son dos niveles, etc. Entonces, "
"si ejecuta ``from . import mod`` de un módulo en el paquete ``pkg`` "
"terminará importando``pkg.mod``. Si ejecuta ``from ..subpkg2 import mod`` "
"desde dentro de ``pkg.subpkg1``, importará ``pkg.subpkg2.mod``. La "
"especificación para las importaciones relativas está contenida en la "
"sección :ref:`relativeimports`."

#: ../Doc/reference/simple_stmts.rst:839
msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine dynamically the modules to be loaded."
msgstr ""
":func:`importlib.import_module` se proporciona para soportar aplicaciones "
"que determinan dinámicamente los módulos a cargar."

#: ../Doc/reference/simple_stmts.rst:842
msgid ""
"Raises an :ref:`auditing event <auditing>` ``import`` with arguments "
"``module``, ``filename``, ``sys.path``, ``sys.meta_path``, ``sys."
"path_hooks``."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``import`` con argumentos "
"``module``, ``filename``, ``sys.path``, ``sys.meta_path``, ``sys."
"path_hooks``."

#: ../Doc/reference/simple_stmts.rst:847
msgid "Future statements"
msgstr "Declaraciones Futuras"

#: ../Doc/reference/simple_stmts.rst:853
msgid ""
"A :dfn:`future statement` is a directive to the compiler that a particular "
"module should be compiled using syntax or semantics that will be available "
"in a specified future release of Python where the feature becomes standard."
msgstr ""
"Una :dfn:`future statement` es una directiva para el compilador para indicar "
"que un módulo en particular debe compilarse usando la sintaxis o semántica "
"que estará disponible en una versión futura específica de Python donde la "
"característica se convierte en estándar."

#: ../Doc/reference/simple_stmts.rst:857
msgid ""
"The future statement is intended to ease migration to future versions of "
"Python that introduce incompatible changes to the language.  It allows use "
"of the new features on a per-module basis before the release in which the "
"feature becomes standard."
msgstr ""
"La declaración futura está destinada a facilitar la migración a futuras "
"versiones de Python que introducen cambios incompatibles en el lenguaje.  "
"Permite el uso de las nuevas funciones por módulo antes del lanzamiento en "
"el que la función se convierte en estándar."

#: ../Doc/reference/simple_stmts.rst:869
msgid ""
"A future statement must appear near the top of the module.  The only lines "
"that can appear before a future statement are:"
msgstr ""
"Una declaración futura debe aparecer cerca de la parte superior del módulo. "
"Las únicas líneas que pueden aparecer antes de una declaración futura son:"

#: ../Doc/reference/simple_stmts.rst:872
msgid "the module docstring (if any),"
msgstr "el docstring del módulo (si hay),"

#: ../Doc/reference/simple_stmts.rst:873
msgid "comments,"
msgstr "comentarios,"

#: ../Doc/reference/simple_stmts.rst:874
msgid "blank lines, and"
msgstr "lineas en blanco, y"

#: ../Doc/reference/simple_stmts.rst:875
msgid "other future statements."
msgstr "otras declaraciones futuras."

#: ../Doc/reference/simple_stmts.rst:877
msgid ""
"The only feature that requires using the future statement is ``annotations`` "
"(see :pep:`563`)."
msgstr ""
"La única característica en Python 3.7 que requiere el uso la declaración "
"futuro es ``annotations``."

#: ../Doc/reference/simple_stmts.rst:880
msgid ""
"All historical features enabled by the future statement are still recognized "
"by Python 3.  The list includes ``absolute_import``, ``division``, "
"``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` and ``with_statement``.  They are all "
"redundant because they are always enabled, and only kept for backwards "
"compatibility."
msgstr ""
"108/5000\n"
"Python 3 aún reconoce todas las características históricas habilitadas por "
"la declaración futura. La lista incluye ``absolute_import``, ``division``, "
"``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` y ``with_statement``. Todos son "
"redundantes porque siempre están habilitados y solo se conservan para "
"compatibilidad con versiones anteriores."

#: ../Doc/reference/simple_stmts.rst:887
msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in which "
"case the compiler may need to parse the module differently.  Such decisions "
"cannot be pushed off until runtime."
msgstr ""
"Una declaración futura se reconoce y se trata especialmente en el momento de "
"la compilación: los cambios en la semántica de las construcciones centrales "
"a menudo se implementan generando código diferente. Incluso puede darse el "
"caso de que una nueva característica introduzca una nueva sintaxis "
"incompatible (como una nueva palabra reservada), en cuyo caso el compilador "
"puede necesitar analizar el módulo de manera diferente. Tales decisiones no "
"pueden postergarse hasta el tiempo de ejecución."

#: ../Doc/reference/simple_stmts.rst:894
msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a "
"feature not known to it."
msgstr ""
"Para cualquier versión dada, el compilador sabe qué nombres de "
"características se han definido y lanza un error en tiempo de compilación si "
"una declaración futura contiene una característica que no conoce."

#: ../Doc/reference/simple_stmts.rst:898
msgid ""
"The direct runtime semantics are the same as for any import statement: there "
"is a standard module :mod:`__future__`, described later, and it will be "
"imported in the usual way at the time the future statement is executed."
msgstr ""
"La semántica del tiempo de ejecución directo es la misma que para cualquier "
"declaración de importación: hay un módulo estándar :mod:`__future__`, que se "
"describe más adelante, y se importará de la forma habitual en el momento en "
"que se ejecute la declaración futura."

#: ../Doc/reference/simple_stmts.rst:902
msgid ""
"The interesting runtime semantics depend on the specific feature enabled by "
"the future statement."
msgstr ""
"La interesante semántica del tiempo de ejecución depende de la "
"característica específica habilitada por la declaración futura."

#: ../Doc/reference/simple_stmts.rst:905
msgid "Note that there is nothing special about the statement::"
msgstr "Notar que no hay nada especial a cerca de la declaración::"

#: ../Doc/reference/simple_stmts.rst:909
msgid ""
"That is not a future statement; it's an ordinary import statement with no "
"special semantics or syntax restrictions."
msgstr ""
"Esa no es una declaración futura; es una declaración de importación "
"ordinaria sin restricciones especiales de semántica o sintaxis."

#: ../Doc/reference/simple_stmts.rst:912
msgid ""
"Code compiled by calls to the built-in functions :func:`exec` and :func:"
"`compile` that occur in a module :mod:`M` containing a future statement "
"will, by default, use the new syntax or semantics associated with the future "
"statement.  This can be controlled by optional arguments to :func:`compile` "
"--- see the documentation of that function for details."
msgstr ""
"El código compilado por llamadas a las funciones integradas :func:`exec` y :"
"func:`compile` que ocurren en un módulo :mod:`M` que contiene una "
"declaración futura usará, por defecto, la nueva sintaxis o semántica "
"asociada con la declaración futura.  Esto se puede controlar mediante "
"argumentos opcionales para :func:`compile` --- consulte la documentación de "
"esa función para obtener más detalles."

#: ../Doc/reference/simple_stmts.rst:918
msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute, "
"and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""
"Una declaración futura escrita en una prompt interactiva del intérprete "
"entrará en vigencia durante el resto de la sesión de dicho intérprete.  Si "
"un intérprete se inicia con la opción :option:`-i`, se le pasa un nombre de "
"script para ejecutar, y el script incluye una declaración futura, ésta "
"estará en efecto en la sesión interactiva iniciada después de que se ejecute "
"el script."

#: ../Doc/reference/simple_stmts.rst:926
msgid ":pep:`236` - Back to the __future__"
msgstr ":pep:`236` - Vuelta al __future__"

#: ../Doc/reference/simple_stmts.rst:927
msgid "The original proposal for the __future__ mechanism."
msgstr "La propuesta original para el mecanismo __future__."

#: ../Doc/reference/simple_stmts.rst:933
msgid "The :keyword:`!global` statement"
msgstr "La declaración :keyword:`!global`"

#: ../Doc/reference/simple_stmts.rst:943
msgid ""
"The :keyword:`global` statement is a declaration which holds for the entire "
"current code block.  It means that the listed identifiers are to be "
"interpreted as globals.  It would be impossible to assign to a global "
"variable without :keyword:`!global`, although free variables may refer to "
"globals without being declared global."
msgstr ""
"La declaración :keyword:`global` es una declaración que se aplica a todo el "
"bloque de código actual. Significa que los identificadores enumerados deben "
"interpretarse como globales.  Sería imposible asignar a una variable global "
"sin :keyword:`!global`, aunque las variables libres pueden referirse a "
"globales sin ser declaradas globales."

#: ../Doc/reference/simple_stmts.rst:949
msgid ""
"Names listed in a :keyword:`global` statement must not be used in the same "
"code block textually preceding that :keyword:`!global` statement."
msgstr ""
"Los nombres enumerados en una declaración :keyword:`global` no deben usarse "
"en el mismo bloque de código que precede textualmente a la declaración :"
"keyword:`!global`."

#: ../Doc/reference/simple_stmts.rst:952
msgid ""
"Names listed in a :keyword:`global` statement must not be defined as formal "
"parameters or in a :keyword:`for` loop control target, :keyword:`class` "
"definition, function definition, :keyword:`import` statement, or variable "
"annotation."
msgstr ""
"Los nombres enumerados en una declaración :keyword:`global` no deben "
"definirse como parámetros formales o en un objetivo de control de bucle :"
"keyword:`for`, definición de :keyword:`class`, definición de función, "
"declaración :keyword:`import` o anotación de variable."

#: ../Doc/reference/simple_stmts.rst:959
msgid ""
"The current implementation does not enforce some of these restrictions, but "
"programs should not abuse this freedom, as future implementations may "
"enforce them or silently change the meaning of the program."
msgstr ""
"La implementación actual no hace cumplir algunas de estas restricciones, "
"pero los programas no deben abusar de esta libertad, ya que las "
"implementaciones futuras pueden imponerlas o cambiar silenciosamente el "
"significado del programa."

#: ../Doc/reference/simple_stmts.rst:968
msgid ""
"**Programmer's note:** :keyword:`global` is a directive to the parser.  It "
"applies only to code parsed at the same time as the :keyword:`!global` "
"statement. In particular, a :keyword:`!global` statement contained in a "
"string or code object supplied to the built-in :func:`exec` function does "
"not affect the code block *containing* the function call, and code contained "
"in such a string is unaffected by :keyword:`!global` statements in the code "
"containing the function call.  The same applies to the :func:`eval` and :"
"func:`compile` functions."
msgstr ""
"** Nota del programador: ** :keyword:`global` es una directiva para el "
"analizador.  Se aplica solo al código analizado al mismo tiempo que la "
"declaración :keyword:`!global`. En particular, una declaración :keyword:`!"
"global` contenida en una cadena u objeto de código suministrado a la función "
"incorporada :func:`exec` no afecta el bloque de código *que contiene* la "
"llamada a la función, y el código contenido en dicha función una cadena no "
"se ve afectada por la declaración keyword:`!global` en el código que "
"contiene la llamada a la función.  Lo mismo se aplica a las funciones :func:"
"`eval` y :func:`compile`."

#: ../Doc/reference/simple_stmts.rst:980
msgid "The :keyword:`!nonlocal` statement"
msgstr "La declaración :keyword:`!nonlocal`"

#: ../Doc/reference/simple_stmts.rst:992
msgid ""
"The :keyword:`nonlocal` statement causes the listed identifiers to refer to "
"previously bound variables in the nearest enclosing scope excluding globals. "
"This is important because the default behavior for binding is to search the "
"local namespace first.  The statement allows encapsulated code to rebind "
"variables outside of the local scope besides the global (module) scope."
msgstr ""
"La declaración :keyword:`nonlocal` hace que los identificadores enumerados "
"se refieran a variables vinculadas previamente en el ámbito circundante más "
"cercano excluyendo globales. Esto es importante porque el comportamiento "
"predeterminado para el enlace es buscar primero en el espacio de nombres "
"local.  La declaración permite que el código encapsulado vuelva a vincular "
"variables fuera del ámbito local además del ámbito global (módulo)."

#: ../Doc/reference/simple_stmts.rst:1002
#, fuzzy
msgid ""
"Names listed in a :keyword:`nonlocal` statement, unlike those listed in a :"
"keyword:`global` statement, must refer to pre-existing bindings in an "
"enclosing scope (the scope in which a new binding should be created cannot "
"be determined unambiguously)."
msgstr ""
"Los nombres enumerados en una declaración :keyword:`nonlocal`, a diferencia "
"de los enumerados en una declaración :keyword:`global`, deben hacer "
"referencia a enlaces preexistentes en un ámbito adjunto (el ámbito en el que "
"se debe crear un nuevo enlace no se puede determinar de forma inequívoca)."

#: ../Doc/reference/simple_stmts.rst:1007
msgid ""
"Names listed in a :keyword:`nonlocal` statement must not collide with pre-"
"existing bindings in the local scope."
msgstr ""
"Los nombres enumerados en la declaración :keyword:`nonlocal` no deben "
"colisionar con las enlaces preexistentes en el ámbito local."

#: ../Doc/reference/simple_stmts.rst:1012
msgid ":pep:`3104` - Access to Names in Outer Scopes"
msgstr ":pep:`3104` - Acceso a Nombres de Ámbitos externos"

#: ../Doc/reference/simple_stmts.rst:1013
msgid "The specification for the :keyword:`nonlocal` statement."
msgstr "La especificación para la declaración :keyword:`nonlocal`."
