# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-05 12:54+0200\n"
"PO-Revision-Date: 2020-07-05 14:52-0300\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: \n"
"Language: es_AR\n"
"X-Generator: Poedit 2.2.1\n"

#: ../Doc/reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr "Sentencias compuestas"

#: ../Doc/reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""
"Las sentencias compuestas contienen (grupos de) otras sentencias; estas "
"afectan o controlan la ejecución de esas otras sentencias de alguna manera. "
"En general, las sentencias compuestas abarcan varias líneas, aunque en "
"representaciones simples una sentencia compuesta completa puede estar "
"contenida en una línea."

#: ../Doc/reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while the :keyword:"
"`with` statement allows the execution of initialization and finalization "
"code around a block of code.  Function and class definitions are also "
"syntactically compound statements."
msgstr ""
"Las sentencias :keyword:`if`, :keyword:`while` y :keyword:`for` implementan "
"construcciones de control de flujo tradicionales. :keyword:`try` especifica "
"gestores de excepción o código de limpieza para un grupo de sentencias, "
"mientras que las sentencias :keyword:`with` permite la ejecución del código "
"de inicialización y finalización alrededor de un bloque de código. Las "
"definiciones de función y clase también son sentencias sintácticamente "
"compuestas."

#: ../Doc/reference/compound_stmts.rst:26
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause consists "
"of a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of a suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be "
"clear to which :keyword:`if` clause a following :keyword:`else` clause would "
"belong::"
msgstr ""
"Una sentencia compuesta consta de una o más 'cláusulas'. Una cláusula consta "
"de un encabezado y una 'suite'. Los encabezados de cláusula de una "
"declaración compuesta particular están todos en el mismo nivel de "
"indentación. Cada encabezado de cláusula comienza con una palabra clave de "
"identificación única y termina con dos puntos. Una suite es un grupo de "
"sentencias controladas por una cláusula. Una suite puede ser una o más "
"sentencias simples separadas por punto y coma en la misma línea como el "
"encabezado, siguiendo los dos puntos del encabezado, o puede ser una o puede "
"ser una o más declaraciones indentadas en líneas posteriores. Solo la última "
"forma de una suite puede contener sentencias compuestas anidadas; lo "
"siguiente es ilegal, principalmente porque no estaría claro a qué cláusula :"
"keyword:`if` seguido de la cláusula :keyword:`else` hace referencia::"

#: ../Doc/reference/compound_stmts.rst:39
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr ""
"También tenga en cuenta que el punto y coma se une más apretado que los dos "
"puntos en este contexto, de modo que en el siguiente ejemplo, todas o "
"ninguna de las llamadas :func:`print` se ejecutan::"

#: ../Doc/reference/compound_stmts.rst:45
msgid "Summarizing:"
msgstr "Resumiendo:"

#: ../Doc/reference/compound_stmts.rst:67
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested :"
"keyword:`if` statements to be indented)."
msgstr ""
"Tenga en cuenta que las sentencias siempre terminan en un ``NEWLINE`` "
"posiblemente seguida de ``DEDENT``. También tenga en cuenta que las "
"cláusulas de continuación opcionales siempre comienzan con una palabra clave "
"que no puede iniciar una sentencia, por lo tanto, no hay ambigüedades (el "
"problema de 'colgado :keyword:`if`' se resuelve en Python al requerir que "
"las sentencias anidadas :keyword:`if` deben estar indentadas)."

#: ../Doc/reference/compound_stmts.rst:73
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr ""
"El formato de las reglas gramaticales en las siguientes secciones coloca "
"cada cláusula en una línea separada para mayor claridad."

#: ../Doc/reference/compound_stmts.rst:82
msgid "The :keyword:`!if` statement"
msgstr "La sentencia :keyword:`!if`"

#: ../Doc/reference/compound_stmts.rst:90
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr "La sentencia :keyword:`if` se usa para la ejecución condicional:"

#: ../Doc/reference/compound_stmts.rst:97
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""
"Selecciona exactamente una de las suites evaluando las expresiones una por "
"una hasta que se encuentre una verdadera (vea la sección :ref:`booleans` "
"para la definición de verdadero y falso); entonces esa suite se ejecuta (y "
"ninguna otra parte de la sentencia :keyword:`if` se ejecuta o evalúa). Si "
"todas las expresiones son falsas, se ejecuta la suite de cláusulas :keyword:"
"`else`, si está presente."

#: ../Doc/reference/compound_stmts.rst:107
msgid "The :keyword:`!while` statement"
msgstr "La sentencia :keyword:`!while`"

#: ../Doc/reference/compound_stmts.rst:115
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ""
"La sentencia :keyword:`while` se usa para la ejecución repetida siempre que "
"una expresión sea verdadera:"

#: ../Doc/reference/compound_stmts.rst:122
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested) "
"the suite of the :keyword:`!else` clause, if present, is executed and the "
"loop terminates."
msgstr ""
"Esto prueba repetidamente la expresión y, si es verdadera, ejecuta la "
"primera suite; si la expresión es falsa (que puede ser la primera vez que se "
"prueba), se ejecuta el conjunto de cláusulas :keyword:`!else`, si está "
"presente, y el bucle termina."

#: ../Doc/reference/compound_stmts.rst:131
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and goes back to testing the expression."
msgstr ""
"La sentencia :keyword:`break` ejecutada en la primer suite termina el bucle "
"sin ejecutar la suite de cláusulas :keyword:`!else`. La sentencia :keyword:"
"`continue` ejecutada en la primera suite omite el resto de la suite y vuelve "
"a probar la expresión."

#: ../Doc/reference/compound_stmts.rst:140
msgid "The :keyword:`!for` statement"
msgstr "La sentencia :keyword:`!for`"

#: ../Doc/reference/compound_stmts.rst:151
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""
"La sentencia :keyword:`for` se usa para iterar sobre los elementos de una "
"secuencia (como una cadena de caracteres, tupla o lista) u otro objeto "
"iterable:"

#: ../Doc/reference/compound_stmts.rst:158
msgid ""
"The expression list is evaluated once; it should yield an iterable object.  "
"An iterator is created for the result of the ``expression_list``.  The suite "
"is then executed once for each item provided by the iterator, in the order "
"returned by the iterator.  Each item in turn is assigned to the target list "
"using the standard rules for assignments (see :ref:`assignment`), and then "
"the suite is executed.  When the items are exhausted (which is immediately "
"when the sequence is empty or an iterator raises a :exc:`StopIteration` "
"exception), the suite in the :keyword:`!else` clause, if present, is "
"executed, and the loop terminates."
msgstr ""
"La lista de expresiones se evalúa una vez; debería producir un objeto "
"iterable. Se crea un iterador para el resultado de la ``expression_list``. "
"La suite se ejecuta una vez para cada elemento proporcionado por el "
"iterador, en el orden retornado por el iterador. Cada elemento a su vez se "
"asigna a la lista utilizando las reglas estándar para las asignaciones (ver :"
"ref:`assignment`), y luego se ejecuta la suite. Cuando los elementos están "
"agotados (que es inmediatamente cuando la secuencia está vacía o un iterador "
"genera una excepción del tipo :exc:`StopIteration`), la suite en la "
"cláusula :keyword:`!else`, si está presente, se ejecuta y el bucle termina."

#: ../Doc/reference/compound_stmts.rst:171
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and continues with the next item, or with the :keyword:`!else` clause if "
"there is no next item."
msgstr ""
"La sentencia :keyword:`break` ejecutada en la primera suite termina el bucle "
"sin ejecutar el conjunto de cláusulas :keyword:`!else`. La sentencia :"
"keyword:`continue` ejecutada en la primera suite omite el resto de las "
"cláusulas y continúa con el siguiente elemento, o con la cláusula :keyword:`!"
"else` si no hay un elemento siguiente."

#: ../Doc/reference/compound_stmts.rst:177
msgid ""
"The for-loop makes assignments to the variables in the target list. This "
"overwrites all previous assignments to those variables including those made "
"in the suite of the for-loop::"
msgstr ""
"El bucle ``for`` realiza asignaciones a las variables en la lista. Esto "
"sobrescribe todas las asignaciones anteriores a esas variables, incluidas "
"las realizadas en la suite del bucle ``for``::"

#: ../Doc/reference/compound_stmts.rst:191
msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, they will not have been assigned to at all by the "
"loop.  Hint: the built-in function :func:`range` returns an iterator of "
"integers suitable to emulate the effect of Pascal's ``for i := a to b do``; "
"e.g., ``list(range(3))`` returns the list ``[0, 1, 2]``."
msgstr ""
"Los nombres en la lista no se eliminan cuando finaliza el bucle, pero si la "
"secuencia está vacía, el bucle no les habrá asignado nada. Sugerencia: la "
"función incorporada :func:`range` retorna un iterador de enteros adecuado "
"para emular el efecto de Pascal ``for i := a to b do``; por ejemplo, "
"``list(range(3))`` retorna la lista ``[0, 1, 2]``."

#: ../Doc/reference/compound_stmts.rst:203
msgid ""
"There is a subtlety when the sequence is being modified by the loop (this "
"can only occur for mutable sequences, e.g. lists).  An internal counter is "
"used to keep track of which item is used next, and this is incremented on "
"each iteration.  When this counter has reached the length of the sequence "
"the loop terminates.  This means that if the suite deletes the current (or a "
"previous) item from the sequence, the next item will be skipped (since it "
"gets the index of the current item which has already been treated).  "
"Likewise, if the suite inserts an item in the sequence before the current "
"item, the current item will be treated again the next time through the loop. "
"This can lead to nasty bugs that can be avoided by making a temporary copy "
"using a slice of the whole sequence, e.g., ::"
msgstr ""
"Hay una sutileza cuando la secuencia está siendo modificada por el bucle "
"(esto solo puede ocurrir para secuencias mutables, por ejemplo, listas). Se "
"utiliza un contador interno para realizar un seguimiento de qué elemento se "
"usa a continuación, y esto se incrementa en cada iteración. Cuando este "
"contador ha alcanzado la longitud de la secuencia, el bucle termina. Esto "
"significa que si la suite elimina el elemento actual (o anterior) de la "
"secuencia, se omitirá el siguiente elemento (ya que obtiene el índice del "
"elemento actual que ya ha sido tratado). Del mismo modo, si la suite inserta "
"un elemento en la secuencia anterior al elemento actual, el elemento actual "
"será tratado nuevamente la próxima vez a través del bucle. Esto puede "
"conducir a errores graves que se pueden evitar haciendo una copia temporal "
"usando una porción de la secuencia completa, por ejemplo, ::"

#: ../Doc/reference/compound_stmts.rst:224
msgid "The :keyword:`!try` statement"
msgstr "La sentencia :keyword:`!try`"

#: ../Doc/reference/compound_stmts.rst:234
msgid ""
"The :keyword:`try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ""
"La sentencia :keyword:`try` es especifica para gestionar excepciones o "
"código de limpieza para un grupo de sentencias:"

#: ../Doc/reference/compound_stmts.rst:247
msgid ""
"The :keyword:`except` clause(s) specify one or more exception handlers. When "
"no exception occurs in the :keyword:`try` clause, no exception handler is "
"executed. When an exception occurs in the :keyword:`!try` suite, a search "
"for an exception handler is started.  This search inspects the except "
"clauses in turn until one is found that matches the exception.  An "
"expression-less except clause, if present, must be last; it matches any "
"exception.  For an except clause with an expression, that expression is "
"evaluated, and the clause matches the exception if the resulting object is "
"\"compatible\" with the exception.  An object is compatible with an "
"exception if it is the class or a base class of the exception object or a "
"tuple containing an item compatible with the exception."
msgstr ""
"La/s cláusula/s :keyword:`except` especifican uno o más gestores de "
"excepciones. Cuando no se produce ninguna excepción en la cláusula :keyword:"
"`try`, no se ejecuta ningún gestor de excepción. Cuando se produce una "
"excepción en la suite :keyword:`!try`, se inicia la búsqueda de un gestor de "
"excepciones. Esta búsqueda inspecciona las cláusulas ``except`` por turno "
"hasta que se encuentre una que coincida con la excepción. Una cláusula "
"excepción sin una expresión, si está presente, debe ser la última; coincide "
"con cualquier excepción. Para una cláusula ``except`` con una expresión, esa "
"expresión se evalúa y la cláusula coincide con la excepción si el objeto "
"resultante es \"compatible\" con la excepción. Un objeto es compatible con "
"una excepción si es la clase o una clase base del objeto de excepción o una "
"tupla que contiene un elemento compatible con la excepción."

#: ../Doc/reference/compound_stmts.rst:258
msgid ""
"If no except clause matches the exception, the search for an exception "
"handler continues in the surrounding code and on the invocation stack.  [#]_"
msgstr ""
"Si ninguna cláusula ``except`` coincide con la excepción, la búsqueda de un "
"gestor de excepciones continúa en el código circundante y en la pila de "
"invocación. [#]_"

#: ../Doc/reference/compound_stmts.rst:261
msgid ""
"If the evaluation of an expression in the header of an except clause raises "
"an exception, the original search for a handler is canceled and a search "
"starts for the new exception in the surrounding code and on the call stack "
"(it is treated as if the entire :keyword:`try` statement raised the "
"exception)."
msgstr ""
"Si la evaluación de una expresión en el encabezado de una cláusula "
"``except`` genera una excepción, la búsqueda original de un gestor se "
"cancela y se inicia la búsqueda de la nueva excepción en el código "
"circundante y en la pila de llamadas (se trata como si toda la sentencia :"
"keyword:`try` provocó la excepción)."

#: ../Doc/reference/compound_stmts.rst:268
msgid ""
"When a matching except clause is found, the exception is assigned to the "
"target specified after the :keyword:`!as` keyword in that except clause, if "
"present, and the except clause's suite is executed.  All except clauses must "
"have an executable block.  When the end of this block is reached, execution "
"continues normally after the entire try statement.  (This means that if two "
"nested handlers exist for the same exception, and the exception occurs in "
"the try clause of the inner handler, the outer handler will not handle the "
"exception.)"
msgstr ""
"Cuando se encuentra una cláusula ``except`` coincidente, la excepción se "
"asigna al destino especificado después de la palabra clave :keyword:`!as` en "
"esa cláusula ``except``, si está presente, y se ejecuta la suite de "
"cláusulas ``except``. Todas las cláusulas ``except`` deben tener un bloque "
"ejecutable. Cuando se alcanza el final de este bloque, la ejecución continúa "
"normalmente después de toda la sentencia try. (Esto significa que si existen "
"dos gestores de errores anidados para la misma excepción, y la excepción "
"ocurre en la cláusula ``try`` del gestor interno, el gestor externo no "
"gestionará la excepción)."

#: ../Doc/reference/compound_stmts.rst:276
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the except clause.  This is as if ::"
msgstr ""
"Cuando se ha asignado una excepción usando ``as target``, se borra al final "
"de la cláusula ``except``. Esto es como si ::"

#: ../Doc/reference/compound_stmts.rst:282
msgid "was translated to ::"
msgstr "fue traducido a ::"

#: ../Doc/reference/compound_stmts.rst:290
msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the except clause.  Exceptions are cleared because with "
"the traceback attached to them, they form a reference cycle with the stack "
"frame, keeping all locals in that frame alive until the next garbage "
"collection occurs."
msgstr ""
"Esto significa que la excepción debe asignarse a un nombre diferente para "
"poder referirse a ella después de la cláusula ``except``. Las excepciones se "
"borran porque con el seguimiento vinculado a ellas, forman un bucle de "
"referencia con el marco de la pila, manteniendo activos todos los locales en "
"esa pila hasta que ocurra la próxima recolección de basura."

#: ../Doc/reference/compound_stmts.rst:299
msgid ""
"Before an except clause's suite is executed, details about the exception are "
"stored in the :mod:`sys` module and can be accessed via :func:`sys."
"exc_info`. :func:`sys.exc_info` returns a 3-tuple consisting of the "
"exception class, the exception instance and a traceback object (see section :"
"ref:`types`) identifying the point in the program where the exception "
"occurred.  :func:`sys.exc_info` values are restored to their previous values "
"(before the call) when returning from a function that handled an exception."
msgstr ""
"Antes de que se ejecute un conjunto de cláusulas ``except``, los detalles "
"sobre la excepción se almacenan en el módulo :mod:`sys` y se puede acceder a "
"través de :func:`sys.exc_info`. :func:`sys.exc_info` retorna 3 tuplas que "
"consisten en la clase de excepción, la instancia de excepción y un objeto de "
"rastreo (ver sección :ref:`types`) que identifica el punto en el programa "
"donde ocurrió la excepción. Lo valores :func:`sys.exc_info` se restauran a "
"sus valores anteriores (antes de la llamada) al regresar de una función que "
"manejó una excepción."

#: ../Doc/reference/compound_stmts.rst:313
msgid ""
"The optional :keyword:`!else` clause is executed if the control flow leaves "
"the :keyword:`try` suite, no exception was raised, and no :keyword:"
"`return`, :keyword:`continue`, or :keyword:`break` statement was executed.  "
"Exceptions in the :keyword:`!else` clause are not handled by the preceding :"
"keyword:`except` clauses."
msgstr ""
"La cláusula opcional :keyword:`!else` se ejecuta si el flujo de control sale "
"de la suite :keyword:`try`, no se produjo ninguna excepción, y no se ejecutó "
"la sentencia :keyword:`return`, :keyword:`continue` o :keyword:`break`. Las "
"excepciones en la cláusula :keyword:`!else` no se gestionaron con las "
"cláusulas precedentes :keyword:`except`."

#: ../Doc/reference/compound_stmts.rst:321
msgid ""
"If :keyword:`finally` is present, it specifies a 'cleanup' handler.  The :"
"keyword:`try` clause is executed, including any :keyword:`except` and :"
"keyword:`!else` clauses.  If an exception occurs in any of the clauses and "
"is not handled, the exception is temporarily saved. The :keyword:`!finally` "
"clause is executed.  If there is a saved exception it is re-raised at the "
"end of the :keyword:`!finally` clause.  If the :keyword:`!finally` clause "
"raises another exception, the saved exception is set as the context of the "
"new exception. If the :keyword:`!finally` clause executes a :keyword:"
"`return`, :keyword:`break` or :keyword:`continue` statement, the saved "
"exception is discarded::"
msgstr ""
"Si está presente :keyword:`finally`, esto especifica un gestor de "
"'limpieza'. La cláusula :keyword:`try` se ejecuta, incluidas las cláusulas :"
"keyword:`except` y :keyword:`!else`. Si se produce una excepción en "
"cualquiera de las cláusulas y no se maneja, la excepción se guarda "
"temporalmente. Se ejecuta la cláusula :keyword:`!finally`. Si hay una "
"excepción guardada, se vuelve a generar al final de la cláusula :keyword:`!"
"finally`. Si la cláusula :keyword:`!finally` genera otra excepción, la "
"excepción guardada se establece como el contexto de la nueva excepción. Si "
"la cláusula :keyword:`!finally` ejecuta una sentencia :keyword:`return`, :"
"keyword:`break` o :keyword:`continue`, la excepción guardada se descarta::"

#: ../Doc/reference/compound_stmts.rst:340
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`finally` clause."
msgstr ""
"La información de excepción no está disponible para el programa durante la "
"ejecución de la cláusula :keyword:`finally`."

#: ../Doc/reference/compound_stmts.rst:348
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`!try`...\\ :keyword:`!"
"finally` statement, the :keyword:`finally` clause is also executed 'on the "
"way out.'"
msgstr ""
"Cuando se ejecuta una sentencia :keyword:`return`, :keyword:`break` o :"
"keyword:`continue` en la suite :keyword:`try` de un :keyword:`!try`...\\ la "
"sentencia :keyword:`!finally`, la cláusula :keyword:`finally` también se "
"ejecuta 'al salir'."

#: ../Doc/reference/compound_stmts.rst:352
msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`finally` clause always executes, a :"
"keyword:`!return` statement executed in the :keyword:`!finally` clause will "
"always be the last one executed::"
msgstr ""
"El valor de retorno de una función está determinado por la última sentencia :"
"keyword:`return` ejecutada. Dado que la cláusula :keyword:`finally` siempre "
"se ejecuta, una sentencia :keyword:`!return` ejecutada en la cláusula :"
"keyword:`!finally` siempre será la última ejecutada::"

#: ../Doc/reference/compound_stmts.rst:366
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information on using the :keyword:`raise` statement to "
"generate exceptions may be found in section :ref:`raise`."
msgstr ""
"Se puede encontrar información adicional sobre las excepciones en la "
"sección :ref:`exceptions`, e información sobre el uso de la sentencia :"
"keyword:`raise`, para generar excepciones se puede encontrar en la sección :"
"ref:`raise`."

#: ../Doc/reference/compound_stmts.rst:370
msgid ""
"Prior to Python 3.8, a :keyword:`continue` statement was illegal in the :"
"keyword:`finally` clause due to a problem with the implementation."
msgstr ""
"Antes de Python 3.8, una sentencia :keyword:`continue` era ilegal en la "
"cláusula :keyword:`finally` debido a un problema con la implementación."

#: ../Doc/reference/compound_stmts.rst:379
msgid "The :keyword:`!with` statement"
msgstr "La sentencia :keyword:`!with`"

#: ../Doc/reference/compound_stmts.rst:388
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ :keyword:"
"`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
"La sentencia :keyword:`with` se usa para ajustar la ejecución de un bloque "
"con métodos definidos por un administrador de contexto (ver sección :ref:"
"`context-managers`). Esto permite que los patrones de uso comunes :keyword:"
"`try`...\\ :keyword:`except`...\\ :keyword:`finally` se encapsulen para una "
"reutilización conveniente."

#: ../Doc/reference/compound_stmts.rst:397
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as "
"follows:"
msgstr ""
"La ejecución de la sentencia :keyword:`with` con un \"item\" se realiza de "
"la siguiente manera:"

#: ../Doc/reference/compound_stmts.rst:399
msgid ""
"The context expression (the expression given in the :token:`with_item`) is "
"evaluated to obtain a context manager."
msgstr ""
"La expresión de contexto (la expresión dada en :token:`with_item`) se evalúa "
"para obtener un administrador de contexto."

#: ../Doc/reference/compound_stmts.rst:402
msgid "The context manager's :meth:`__enter__` is loaded for later use."
msgstr ""
"El administrador de contexto :meth:`__enter__` se carga para su uso "
"posterior."

#: ../Doc/reference/compound_stmts.rst:404
msgid "The context manager's :meth:`__exit__` is loaded for later use."
msgstr ""
"El administrador de contexto :meth:`__exit__` se carga para su uso posterior."

#: ../Doc/reference/compound_stmts.rst:406
msgid "The context manager's :meth:`__enter__` method is invoked."
msgstr "Se invoca el método del administrador de contexto :meth:`__enter__`."

#: ../Doc/reference/compound_stmts.rst:408
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`__enter__` is assigned to it."
msgstr ""
"Si se incluyó el destino en la sentencia :keyword:`with`, se le asigna el "
"valor de retorno de :meth:`__enter__`."

#: ../Doc/reference/compound_stmts.rst:413
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`__enter__` "
"method returns without an error, then :meth:`__exit__` will always be "
"called. Thus, if an error occurs during the assignment to the target list, "
"it will be treated the same as an error occurring within the suite would be. "
"See step 6 below."
msgstr ""
"La sentencia :keyword:`with` garantiza que si el método :meth:`__enter__` "
"regresa sin error, entonces siempre se llamará a :meth:`__exit__`. Por lo "
"tanto, si se produce un error durante la asignación a la lista de destino, "
"se tratará de la misma manera que si se produciría un error dentro de la "
"suite. Vea el paso 6 a continuación."

#: ../Doc/reference/compound_stmts.rst:419
msgid "The suite is executed."
msgstr "La suite se ejecuta."

#: ../Doc/reference/compound_stmts.rst:421
msgid ""
"The context manager's :meth:`__exit__` method is invoked.  If an exception "
"caused the suite to be exited, its type, value, and traceback are passed as "
"arguments to :meth:`__exit__`. Otherwise, three :const:`None` arguments are "
"supplied."
msgstr ""
"Se invoca el método del administrador de contexto :meth:`__exit__`. Si una "
"excepción causó la salida de la suite, su tipo, valor y rastreo se pasan "
"como argumentos a :meth:`__exit__`. De lo contrario, se proporcionan tres "
"argumentos :const:`None`."

#: ../Doc/reference/compound_stmts.rst:426
msgid ""
"If the suite was exited due to an exception, and the return value from the :"
"meth:`__exit__` method was false, the exception is reraised.  If the return "
"value was true, the exception is suppressed, and execution continues with "
"the statement following the :keyword:`with` statement."
msgstr ""
"Si se salió de la suite debido a una excepción, y el valor de retorno del "
"método :meth:`__exit__` fue falso, la excepción se vuelve a plantear. Si el "
"valor de retorno era verdadero, la excepción se suprime y la ejecución "
"continúa con la sentencia que sigue a la sentencia :keyword:`with`."

#: ../Doc/reference/compound_stmts.rst:431
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`__exit__` is ignored, and execution proceeds at the normal "
"location for the kind of exit that was taken."
msgstr ""
"Si se salió de la suite por cualquier motivo que no sea una excepción, el "
"valor de retorno de :meth:`__exit__` se ignora y la ejecución continúa en la "
"ubicación normal para el tipo de salida que se tomó."

#: ../Doc/reference/compound_stmts.rst:435
#: ../Doc/reference/compound_stmts.rst:798
#: ../Doc/reference/compound_stmts.rst:839
msgid "The following code::"
msgstr "El siguiente código::"

#: ../Doc/reference/compound_stmts.rst:440
#: ../Doc/reference/compound_stmts.rst:465
#: ../Doc/reference/compound_stmts.rst:844
msgid "is semantically equivalent to::"
msgstr "es semánticamente equivalente a::"

#: ../Doc/reference/compound_stmts.rst:459
msgid ""
"With more than one item, the context managers are processed as if multiple :"
"keyword:`with` statements were nested::"
msgstr ""
"Con más de un elemento, los administradores de contexto se procesan como si "
"varias sentencias :keyword:`with` estuvieran anidadas::"

#: ../Doc/reference/compound_stmts.rst:471
msgid "Support for multiple context expressions."
msgstr "Soporte para múltiples expresiones de contexto."

#: ../Doc/reference/compound_stmts.rst:477
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - La sentencia \"with\""

#: ../Doc/reference/compound_stmts.rst:477
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""
"La especificación, antecedentes y ejemplos de la sentencia de Python :"
"keyword:`with`."

#: ../Doc/reference/compound_stmts.rst:488
msgid "Function definitions"
msgstr "Definiciones de funciones"

#: ../Doc/reference/compound_stmts.rst:503
msgid ""
"A function definition defines a user-defined function object (see section :"
"ref:`types`):"
msgstr ""
"Una definición de función define una función objeto determinada por el "
"usuario (consulte la sección :ref:`types`):"

#: ../Doc/reference/compound_stmts.rst:523
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper "
"around the executable code for the function).  This function object contains "
"a reference to the current global namespace as the global namespace to be "
"used when the function is called."
msgstr ""
"Una definición de función es una sentencia ejecutable. Su ejecución vincula "
"el nombre de la función en el espacio de nombres local actual a un objeto de "
"función (un contenedor alrededor del código ejecutable para la función). "
"Este objeto de función contiene una referencia al espacio de nombres global "
"actual como el espacio de nombres global que se utilizará cuando se llama a "
"la función."

#: ../Doc/reference/compound_stmts.rst:529
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr ""
"La definición de la función no ejecuta el cuerpo de la función; esto se "
"ejecuta solo cuando se llama a la función. [#]_"

#: ../Doc/reference/compound_stmts.rst:535
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""
"Una definición de función puede estar envuelta por una o más expresiones :"
"term:`decorator`. Las expresiones de decorador se evalúan cuando se define "
"la función, en el ámbito que contiene la definición de la función. El "
"resultado debe ser invocable, la cual se invoca con el objeto de función "
"como único argumento. El valor retornado está vinculado al nombre de la "
"función en lugar del objeto de la función. Se aplican múltiples decoradores "
"de forma anidada. Por ejemplo, el siguiente código ::"

#: ../Doc/reference/compound_stmts.rst:546
#: ../Doc/reference/compound_stmts.rst:712
msgid "is roughly equivalent to ::"
msgstr "es más o menos equivalente a ::"

#: ../Doc/reference/compound_stmts.rst:551
msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr ""
"excepto que la función original no está vinculada temporalmente al nombre "
"``func``."

#: ../Doc/reference/compound_stmts.rst:558
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter values."
"\"  For a parameter with a default value, the corresponding :term:`argument` "
"may be omitted from a call, in which case the parameter's default value is "
"substituted.  If a parameter has a default value, all following parameters "
"up until the \"``*``\" must also have a default value --- this is a "
"syntactic restriction that is not expressed by the grammar."
msgstr ""
"Cuando uno o más :term:`parameters <parameter>` tienen la forma *parameter* "
"``=`` *expression*, se dice que la función tiene \"valores de parámetros "
"predeterminados\". Para un parámetro con un valor predeterminado, el "
"correspondiente :term:`argument` puede omitirse desde una llamada, en cuyo "
"caso se sustituye el valor predeterminado del parámetro. Si un parámetro "
"tiene un valor predeterminado, todos los parámetros siguientes hasta el "
"\"``*``\" también deben tener un valor predeterminado --- esta es una "
"restricción sintáctica que la gramática no expresa."

#: ../Doc/reference/compound_stmts.rst:566
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter is a mutable object, such as a list or a "
"dictionary: if the function modifies the object (e.g. by appending an item "
"to a list), the default value is in effect modified.  This is generally not "
"what was intended.  A way around this is to use ``None`` as the default, and "
"explicitly test for it in the body of the function, e.g.::"
msgstr ""
"**Los valores de los parámetros predeterminados se evalúan de izquierda a "
"derecha cuando se ejecuta la definición de la función.** Esto significa que "
"la expresión se evalúa una vez, cuando se define la función, y que se "
"utiliza el mismo valor \"precalculado\" para cada llamada . Esto es "
"especialmente importante para entender cuando un parámetro predeterminado es "
"un objeto mutable, como una lista o un diccionario: si la función modifica "
"el objeto (por ejemplo, al agregar un elemento a una lista), el valor "
"predeterminado está en efecto modificado. Esto generalmente no es lo que se "
"pretendía. Una forma de evitar esto es usar ``None`` como valor "
"predeterminado y probarlo explícitamente en el cuerpo de la función, por "
"ejemplo:"

#: ../Doc/reference/compound_stmts.rst:586
msgid ""
"Function call semantics are described in more detail in section :ref:"
"`calls`. A function call always assigns values to all parameters mentioned "
"in the parameter list, either from position arguments, from keyword "
"arguments, or from default values.  If the form \"``*identifier``\" is "
"present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple. If the form \"``**identifier``\" "
"is present, it is initialized to a new ordered mapping receiving any excess "
"keyword arguments, defaulting to a new empty mapping of the same type.  "
"Parameters after \"``*``\" or \"``*identifier``\" are keyword-only "
"parameters and may only be passed used keyword arguments."
msgstr ""
"La semántica de llamadas de función se describe con más detalle en la "
"sección :ref:`calls`. Una llamada a la función siempre asigna valores a "
"todos los parámetros mencionados en la lista de parámetros, ya sea desde "
"argumentos de posición, desde argumentos por palabra clave o desde valores "
"predeterminados. Si está presente la forma \"``*identifier``\", se "
"inicializa en una tupla que recibe cualquier parámetro posicional en exceso, "
"por defecto en la tupla vacía. Si el formulario \"``**identifier``\" está "
"presente, se inicializa a una nueva asignación ordenada que recibe cualquier "
"exceso de argumentos por palabra clave, por defecto a una nueva asignación "
"vacía del mismo tipo. Los parámetros después de \"``*``\" o \"``*identifier``"
"\" son parámetros solo por palabra clave y solo pueden pasarse con "
"argumentos de palabras claves usadas."

#: ../Doc/reference/compound_stmts.rst:602
msgid ""
"Parameters may have an :term:`annotation <function annotation>` of the form "
"\"``: expression``\" following the parameter name.  Any parameter may have "
"an annotation, even those of the form ``*identifier`` or ``**identifier``.  "
"Functions may have \"return\" annotation of the form \"``-> expression``\" "
"after the parameter list.  These annotations can be any valid Python "
"expression.  The presence of annotations does not change the semantics of a "
"function.  The annotation values are available as values of a dictionary "
"keyed by the parameters' names in the :attr:`__annotations__` attribute of "
"the function object.  If the ``annotations`` import from :mod:`__future__` "
"is used, annotations are preserved as strings at runtime which enables "
"postponed evaluation.  Otherwise, they are evaluated when the function "
"definition is executed.  In this case annotations may be evaluated in a "
"different order than they appear in the source code."
msgstr ""
"Los parámetros pueden tener :term:`annotation <function annotation>` de la "
"forma \"``: expression``\" que sigue al nombre del parámetro. Cualquier "
"parámetro puede tener una anotación, incluso las de la forma ``*identifier`` "
"o ``** identifier``. Las funciones pueden tener una anotación \"return\" de "
"la forma \"``-> expression``\" después de la lista de parámetros. Estas "
"anotaciones pueden ser cualquier expresión válida de Python. La presencia de "
"anotaciones no cambia la semántica de una función. Los valores de anotación "
"están disponibles como valores de un diccionario con los nombres de los "
"parámetros en el atributo :attr:`__annotations__` del objeto de la función. "
"Si se usa ``annotations`` importada desde :mod:`__future__`, las anotaciones "
"se conservan como cadenas de caracteres en tiempo de ejecución que permiten "
"la evaluación pospuesta. De lo contrario, se evalúan cuando se ejecuta la "
"definición de la función. En este caso, las anotaciones pueden evaluarse en "
"un orden diferente al que aparecen en el código fuente."

#: ../Doc/reference/compound_stmts.rst:617
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The \":"
"keyword:`!def`\" form is actually more powerful since it allows the "
"execution of multiple statements and annotations."
msgstr ""
"También es posible crear funciones anónimas (funciones no vinculadas a un "
"nombre), para uso inmediato en expresiones. Utiliza expresiones lambda, "
"descritas en la sección :ref:`lambda`. Tenga en cuenta que la expresión "
"lambda es simplemente una abreviatura para una definición de función "
"simplificada; una función definida en una sentencia \":keyword:`def`\" puede "
"pasarse o asignarse a otro nombre al igual que una función definida por una "
"expresión lambda. La forma \":keyword:`!def`\" es en realidad más poderosa "
"ya que permite la ejecución de múltiples sentencias y anotaciones."

#: ../Doc/reference/compound_stmts.rst:625
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested "
"function can access the local variables of the function containing the def.  "
"See section :ref:`naming` for details."
msgstr ""
"**Nota del programador:** Las funciones son objetos de la primera-clase. Una "
"sentencia \"``def``\" ejecutada dentro de una definición de función define "
"una función local que se puede devolver o pasar. Las variables libres "
"utilizadas en la función anidada pueden acceder a las variables locales de "
"la función que contiene el def. Vea la sección :ref:`naming` para más "
"detalles."

#: ../Doc/reference/compound_stmts.rst:634
msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` - Anotaciones de funciones"

#: ../Doc/reference/compound_stmts.rst:634
msgid "The original specification for function annotations."
msgstr "La especificación original para anotaciones de funciones."

#: ../Doc/reference/compound_stmts.rst:637
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - Sugerencias de tipo"

#: ../Doc/reference/compound_stmts.rst:637
msgid "Definition of a standard meaning for annotations: type hints."
msgstr ""
"Definición de un significado estándar para anotaciones: sugerencias de tipo."

#: ../Doc/reference/compound_stmts.rst:641
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - Sintaxis para anotaciones variables"

#: ../Doc/reference/compound_stmts.rst:640
msgid ""
"Ability to type hint variable declarations, including class variables and "
"instance variables"
msgstr ""
"Capacidad para escribir declaraciones de variables indirectas, incluidas "
"variables de clase y variables de instancia"

#: ../Doc/reference/compound_stmts.rst:644
msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ":pep:`563` - Evaluación pospuesta de anotaciones"

#: ../Doc/reference/compound_stmts.rst:644
msgid ""
"Support for forward references within annotations by preserving annotations "
"in a string form at runtime instead of eager evaluation."
msgstr ""
"Admite referencias directas dentro de las anotaciones conservando las "
"anotaciones en forma de cadena de caracteres en tiempo de ejecución en lugar "
"de una evaluación apresurada."

#: ../Doc/reference/compound_stmts.rst:651
msgid "Class definitions"
msgstr "Definiciones de clase"

#: ../Doc/reference/compound_stmts.rst:666
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr ""
"Una definición de clase define un objeto de clase (ver sección :ref:`types`):"

#: ../Doc/reference/compound_stmts.rst:673
msgid ""
"A class definition is an executable statement.  The inheritance list usually "
"gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""
"Una definición de clase es una sentencia ejecutable. La lista de herencia "
"generalmente proporciona una lista de clases base (consulte :ref:"
"`metaclasses` para usos más avanzados), por lo que cada elemento de la lista "
"debe evaluar a un objeto de clase que permita la subclasificación. Las "
"clases sin una lista de herencia heredan, por defecto, de la clase base :"
"class:`object`; por lo tanto, ::"

#: ../Doc/reference/compound_stmts.rst:682
msgid "is equivalent to ::"
msgstr "es equivalente a ::"

#: ../Doc/reference/compound_stmts.rst:687
msgid ""
"The class's suite is then executed in a new execution frame (see :ref:"
"`naming`), using a newly created local namespace and the original global "
"namespace. (Usually, the suite contains mostly function definitions.)  When "
"the class's suite finishes execution, its execution frame is discarded but "
"its local namespace is saved. [#]_ A class object is then created using the "
"inheritance list for the base classes and the saved local namespace for the "
"attribute dictionary.  The class name is bound to this class object in the "
"original local namespace."
msgstr ""
"La suite de la clase se ejecuta en un nuevo marco de ejecución (ver :ref:"
"`naming`), usando un espacio de nombres local recién creado y el espacio de "
"nombres global original. (Por lo general, el bloque contiene principalmente "
"definiciones de funciones). Cuando la suite de la clase finaliza la "
"ejecución, su marco de ejecución se descarta pero se guarda su espacio de "
"nombres local. [#]_ Luego se crea un objeto de clase utilizando la lista de "
"herencia para las clases base y el espacio de nombres local guardado para el "
"diccionario de atributos. El nombre de la clase está vinculado a este objeto "
"de clase en el espacio de nombres local original."

#: ../Doc/reference/compound_stmts.rst:696
msgid ""
"The order in which attributes are defined in the class body is preserved in "
"the new class's ``__dict__``.  Note that this is reliable only right after "
"the class is created and only for classes that were defined using the "
"definition syntax."
msgstr ""
"El orden en que se definen los atributos en el cuerpo de la clase se "
"conserva en el ``__dict__`` de la nueva clase. Tenga en cuenta que esto es "
"confiable solo justo después de crear la clase y solo para las clases que se "
"definieron utilizando la sintaxis de definición."

#: ../Doc/reference/compound_stmts.rst:701
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr ""
"La creación de clases se puede personalizar en gran medida usando :ref:"
"`metaclasses <metaclasses>`."

#: ../Doc/reference/compound_stmts.rst:706
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr ""
"Las clases también se pueden decorar: al igual que cuando se decoran "
"funciones, ::"

#: ../Doc/reference/compound_stmts.rst:717
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr ""
"Las reglas de evaluación para las expresiones de decorador son las mismas "
"que para los decoradores de funciones. El resultado se vincula al nombre de "
"la clase."

#: ../Doc/reference/compound_stmts.rst:720
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in "
"a method with ``self.name = value``.  Both class and instance attributes are "
"accessible through the notation \"``self.name``\", and an instance attribute "
"hides a class attribute with the same name when accessed in this way.  Class "
"attributes can be used as defaults for instance attributes, but using "
"mutable values there can lead to unexpected results.  :ref:`Descriptors "
"<descriptors>` can be used to create instance variables with different "
"implementation details."
msgstr ""
"** Nota del programador: ** Las variables definidas en la definición de la "
"clase son atributos de clase; son compartidos por instancias. Los atributos "
"de instancia se pueden establecer en un método con ``self.name = value``. Se "
"puede acceder a los atributos de clase e instancia a través de la notación "
"\"``self.name``\", y un atributo de instancia oculta un atributo de clase "
"con el mismo nombre cuando se accede de esta manera. Los atributos de clase "
"se pueden usar como valores predeterminados para los atributos de instancia, "
"pero el uso de valores mutables puede generar resultados inesperados. :ref:"
"`Descriptors <descriptors>` se puede usar para crear variables de instancia "
"con diferentes detalles de implementación."

#: ../Doc/reference/compound_stmts.rst:735
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Metaclases en Python 3000"

#: ../Doc/reference/compound_stmts.rst:733
msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are constructed."
msgstr ""
"La propuesta que cambió la declaración de metaclases a la sintaxis actual y "
"la semántica de cómo se construyen las clases con metaclases."

#: ../Doc/reference/compound_stmts.rst:738
msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - Decoradores de clase"

#: ../Doc/reference/compound_stmts.rst:738
msgid ""
"The proposal that added class decorators.  Function and method decorators "
"were introduced in :pep:`318`."
msgstr ""
"La propuesta que agregó decoradores de clase. Los decoradores de funciones y "
"métodos se introdujeron en :pep:`318`."

#: ../Doc/reference/compound_stmts.rst:745
msgid "Coroutines"
msgstr "Corrutinas"

#: ../Doc/reference/compound_stmts.rst:753
msgid "Coroutine function definition"
msgstr "Definición de la función corrutina"

#: ../Doc/reference/compound_stmts.rst:763
msgid ""
"Execution of Python coroutines can be suspended and resumed at many points "
"(see :term:`coroutine`).  Inside the body of a coroutine function, ``await`` "
"and ``async`` identifiers become reserved keywords; :keyword:`await` "
"expressions, :keyword:`async for` and :keyword:`async with` can only be used "
"in coroutine function bodies."
msgstr ""
"La ejecución de las corrutinas de Python puede suspenderse y reanudarse en "
"muchos puntos (ver :term:`coroutine`). Dentro del cuerpo de una función de "
"corrutina, los identificadores ``await`` y ``async`` se convierten en "
"palabras claves reservadas; las expresiones :keyword:`await`, :keyword:"
"`async for` y :keyword:`async with` solo se puede usar en los cuerpos de "
"funciones de corrutina."

#: ../Doc/reference/compound_stmts.rst:769
msgid ""
"Functions defined with ``async def`` syntax are always coroutine functions, "
"even if they do not contain ``await`` or ``async`` keywords."
msgstr ""
"Las funciones definidas con la sintaxis ``async def`` siempre son funciones "
"de corrutina, incluso si no contienen palabras claves ``await`` o ``async``."

#: ../Doc/reference/compound_stmts.rst:772
msgid ""
"It is a :exc:`SyntaxError` to use a ``yield from`` expression inside the "
"body of a coroutine function."
msgstr ""
"Es un error del tipo :exc:`SyntaxError` usar una expresión ``yield from`` "
"dentro del cuerpo de una función de corrutina."

#: ../Doc/reference/compound_stmts.rst:775
msgid "An example of a coroutine function::"
msgstr "Un ejemplo de una función corrutina::"

#: ../Doc/reference/compound_stmts.rst:786
msgid "The :keyword:`!async for` statement"
msgstr "La sentencia :keyword:`!async for`"

#: ../Doc/reference/compound_stmts.rst:791
msgid ""
"An :term:`asynchronous iterable` is able to call asynchronous code in its "
"*iter* implementation, and :term:`asynchronous iterator` can call "
"asynchronous code in its *next* method."
msgstr ""
"Un :term:`asynchronous iterable` es capaz de llamar código asincrónico en su "
"implementación *iter*, y :term:`asynchronous iterator` puede llamar a código "
"asincrónico en su método *next*."

#: ../Doc/reference/compound_stmts.rst:795
msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous "
"iterators."
msgstr ""
"La sentencia ``async for`` permite una iteración apropiada sobre iteradores "
"asincrónicos."

#: ../Doc/reference/compound_stmts.rst:805
msgid "Is semantically equivalent to::"
msgstr "Es semánticamente equivalente a::"

#: ../Doc/reference/compound_stmts.rst:821
msgid "See also :meth:`__aiter__` and :meth:`__anext__` for details."
msgstr "Ver también :meth:`__aiter__` y :meth:`__anext__` para más detalles."

#: ../Doc/reference/compound_stmts.rst:823
msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside the "
"body of a coroutine function."
msgstr ""
"Es un error del tipo :exc:`SyntaxError` usar una sentencia ``async for`` "
"fuera del cuerpo de una función de corrutina."

#: ../Doc/reference/compound_stmts.rst:831
msgid "The :keyword:`!async with` statement"
msgstr "La sentencia :keyword:`!async with`"

#: ../Doc/reference/compound_stmts.rst:836
msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that is "
"able to suspend execution in its *enter* and *exit* methods."
msgstr ""
"Un :term:`asynchronous context manager` es un :term:`context manager` que "
"puede suspender la ejecución en sus métodos *enter* y *exit*."

#: ../Doc/reference/compound_stmts.rst:863
msgid "See also :meth:`__aenter__` and :meth:`__aexit__` for details."
msgstr "Ver también :meth:`__aenter__` y :meth:`__aexit__` para más detalles."

#: ../Doc/reference/compound_stmts.rst:865
msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside the "
"body of a coroutine function."
msgstr ""
"Es un error del tipo :exc:`SyntaxError` usar una sentencia ``async with`` "
"fuera del cuerpo de una función de corrutina."

#: ../Doc/reference/compound_stmts.rst:871
msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` - Corrutinas con sintaxis ``async`` y ``await``"

#: ../Doc/reference/compound_stmts.rst:871
msgid ""
"The proposal that made coroutines a proper standalone concept in Python, and "
"added supporting syntax."
msgstr ""
"La propuesta que convirtió a las corrutinas en un concepto independiente "
"adecuado en Python, y agregó una sintaxis de soporte."

#: ../Doc/reference/compound_stmts.rst:876
msgid "Footnotes"
msgstr "Notas al pie"

#: ../Doc/reference/compound_stmts.rst:877
msgid ""
"The exception is propagated to the invocation stack unless there is a :"
"keyword:`finally` clause which happens to raise another exception. That new "
"exception causes the old one to be lost."
msgstr ""
"La excepción se propaga a la pila de invocación a menos que haya una "
"cláusula :keyword:`finally` que provoque otra excepción. Esa nueva excepción "
"hace que se pierda la anterior."

#: ../Doc/reference/compound_stmts.rst:881
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's ``__doc__`` attribute and therefore the "
"function's :term:`docstring`."
msgstr ""
"Una cadena de caracteres literal que aparece como la primera sentencia en el "
"cuerpo de la función se transforma en el atributo ``__doc__`` de la función "
"y, por lo tanto, en funciones :term:`docstring`."

#: ../Doc/reference/compound_stmts.rst:885
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's ``__doc__`` item and therefore the class's :"
"term:`docstring`."
msgstr ""
"Una cadena de caracteres literal que aparece como la primera sentencia en el "
"cuerpo de la clase se transforma en el elemento del espacio de nombre "
"``__doc__`` y, por lo tanto, de la clase :term:`docstring`."
