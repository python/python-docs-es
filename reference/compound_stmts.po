# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-25 19:47+0200\n"
"PO-Revision-Date: 2022-01-06 10:25-0300\n"
"Last-Translator: Carlos A. Crespo <lvccrespo@gmail.com>\n"
"Language-Team: python-doc-es\n"
"Language: es_AR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.10.3\n"

#: ../Doc/reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr "Sentencias compuestas"

#: ../Doc/reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""
"Las sentencias compuestas contienen (grupos de) otras sentencias; estas "
"afectan o controlan la ejecución de esas otras sentencias de alguna manera. "
"En general, las sentencias compuestas abarcan varias líneas, aunque en "
"representaciones simples una sentencia compuesta completa puede estar "
"contenida en una línea."

#: ../Doc/reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while the :keyword:"
"`with` statement allows the execution of initialization and finalization "
"code around a block of code.  Function and class definitions are also "
"syntactically compound statements."
msgstr ""
"Las sentencias :keyword:`if`, :keyword:`while` y :keyword:`for` implementan "
"construcciones de control de flujo tradicionales. :keyword:`try` especifica "
"gestores de excepción o código de limpieza para un grupo de sentencias, "
"mientras que las sentencias :keyword:`with` permite la ejecución del código "
"de inicialización y finalización alrededor de un bloque de código. Las "
"definiciones de función y clase también son sentencias sintácticamente "
"compuestas."

#: ../Doc/reference/compound_stmts.rst:26
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause consists "
"of a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of a suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be "
"clear to which :keyword:`if` clause a following :keyword:`else` clause would "
"belong::"
msgstr ""
"Una sentencia compuesta consta de una o más 'cláusulas'. Una cláusula consta "
"de un encabezado y una 'suite'. Los encabezados de cláusula de una "
"declaración compuesta particular están todos en el mismo nivel de "
"indentación. Cada encabezado de cláusula comienza con una palabra clave de "
"identificación única y termina con dos puntos. Una suite es un grupo de "
"sentencias controladas por una cláusula. Una suite puede ser una o más "
"sentencias simples separadas por punto y coma en la misma línea como el "
"encabezado, siguiendo los dos puntos del encabezado, o puede ser una o puede "
"ser una o más declaraciones indentadas en líneas posteriores. Solo la última "
"forma de una suite puede contener sentencias compuestas anidadas; lo "
"siguiente es ilegal, principalmente porque no estaría claro a qué cláusula :"
"keyword:`if` seguido de la cláusula :keyword:`else` hace referencia::"

#: ../Doc/reference/compound_stmts.rst:39
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr ""
"También tenga en cuenta que el punto y coma se une más apretado que los dos "
"puntos en este contexto, de modo que en el siguiente ejemplo, todas o "
"ninguna de las llamadas :func:`print` se ejecutan::"

#: ../Doc/reference/compound_stmts.rst:45
msgid "Summarizing:"
msgstr "Resumiendo:"

#: ../Doc/reference/compound_stmts.rst:69
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested :"
"keyword:`if` statements to be indented)."
msgstr ""
"Tenga en cuenta que las sentencias siempre terminan en un ``NEWLINE`` "
"posiblemente seguida de ``DEDENT``. También tenga en cuenta que las "
"cláusulas de continuación opcionales siempre comienzan con una palabra clave "
"que no puede iniciar una sentencia, por lo tanto, no hay ambigüedades (el "
"problema de 'colgado :keyword:`if`' se resuelve en Python al requerir que "
"las sentencias anidadas :keyword:`if` deben estar indentadas)."

#: ../Doc/reference/compound_stmts.rst:75
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr ""
"El formato de las reglas gramaticales en las siguientes secciones coloca "
"cada cláusula en una línea separada para mayor claridad."

#: ../Doc/reference/compound_stmts.rst:84
msgid "The :keyword:`!if` statement"
msgstr "La sentencia :keyword:`!if`"

#: ../Doc/reference/compound_stmts.rst:92
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr "La sentencia :keyword:`if` se usa para la ejecución condicional:"

#: ../Doc/reference/compound_stmts.rst:99
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""
"Selecciona exactamente una de las suites evaluando las expresiones una por "
"una hasta que se encuentre una verdadera (vea la sección :ref:`booleans` "
"para la definición de verdadero y falso); entonces esa suite se ejecuta (y "
"ninguna otra parte de la sentencia :keyword:`if` se ejecuta o evalúa). Si "
"todas las expresiones son falsas, se ejecuta la suite de cláusulas :keyword:"
"`else`, si está presente."

#: ../Doc/reference/compound_stmts.rst:109
msgid "The :keyword:`!while` statement"
msgstr "La sentencia :keyword:`!while`"

#: ../Doc/reference/compound_stmts.rst:117
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ""
"La sentencia :keyword:`while` se usa para la ejecución repetida siempre que "
"una expresión sea verdadera:"

#: ../Doc/reference/compound_stmts.rst:124
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested) "
"the suite of the :keyword:`!else` clause, if present, is executed and the "
"loop terminates."
msgstr ""
"Esto prueba repetidamente la expresión y, si es verdadera, ejecuta la "
"primera suite; si la expresión es falsa (que puede ser la primera vez que se "
"prueba), se ejecuta el conjunto de cláusulas :keyword:`!else`, si está "
"presente, y el bucle termina."

#: ../Doc/reference/compound_stmts.rst:133
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and goes back to testing the expression."
msgstr ""
"La sentencia :keyword:`break` ejecutada en la primer suite termina el bucle "
"sin ejecutar la suite de cláusulas :keyword:`!else`. La sentencia :keyword:"
"`continue` ejecutada en la primera suite omite el resto de la suite y vuelve "
"a probar la expresión."

#: ../Doc/reference/compound_stmts.rst:142
msgid "The :keyword:`!for` statement"
msgstr "La sentencia :keyword:`!for`"

#: ../Doc/reference/compound_stmts.rst:153
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""
"La sentencia :keyword:`for` se usa para iterar sobre los elementos de una "
"secuencia (como una cadena de caracteres, tupla o lista) u otro objeto "
"iterable:"

#: ../Doc/reference/compound_stmts.rst:160
msgid ""
"The ``starred_list`` expression is evaluated once; it should yield an :term:"
"`iterable` object.  An :term:`iterator` is created for that iterable. The "
"first item provided by the iterator is then assigned to the target list "
"using the standard rules for assignments (see :ref:`assignment`), and the "
"suite is executed.  This repeats for each item provided by the iterator.  "
"When the iterator is exhausted, the suite in the :keyword:`!else` clause, if "
"present, is executed, and the loop terminates."
msgstr ""
"La expresión ``starred_list`` se evalúa una vez; debería producir un objeto :"
"term:`iterable`. Se crea un :term:`iterator` para ese iterable. A "
"continuación, el primer elemento proporcionado por el iterador se asigna a "
"la lista de destino utilizando las reglas estándar para las asignaciones "
"(consulte :ref:`assignment`) y se ejecuta la suite. Esto se repite para cada "
"elemento proporcionado por el iterador. Cuando se agota el iterador, se "
"ejecuta el conjunto de la cláusula :keyword:`!else`, si está presente, y el "
"ciclo termina."

#: ../Doc/reference/compound_stmts.rst:173
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and continues with the next item, or with the :keyword:`!else` clause if "
"there is no next item."
msgstr ""
"La sentencia :keyword:`break` ejecutada en la primera suite termina el bucle "
"sin ejecutar el conjunto de cláusulas :keyword:`!else`. La sentencia :"
"keyword:`continue` ejecutada en la primera suite omite el resto de las "
"cláusulas y continúa con el siguiente elemento, o con la cláusula :keyword:`!"
"else` si no hay un elemento siguiente."

#: ../Doc/reference/compound_stmts.rst:179
msgid ""
"The for-loop makes assignments to the variables in the target list. This "
"overwrites all previous assignments to those variables including those made "
"in the suite of the for-loop::"
msgstr ""
"El bucle ``for`` realiza asignaciones a las variables en la lista. Esto "
"sobrescribe todas las asignaciones anteriores a esas variables, incluidas "
"las realizadas en la suite del bucle ``for``::"

#: ../Doc/reference/compound_stmts.rst:193
msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, they will not have been assigned to at all by the "
"loop.  Hint: the built-in function :func:`range` returns an iterator of "
"integers suitable to emulate the effect of Pascal's ``for i := a to b do``; "
"e.g., ``list(range(3))`` returns the list ``[0, 1, 2]``."
msgstr ""
"Los nombres en la lista no se eliminan cuando finaliza el bucle, pero si la "
"secuencia está vacía, el bucle no les habrá asignado nada. Sugerencia: la "
"función incorporada :func:`range` retorna un iterador de enteros adecuado "
"para emular el efecto de Pascal ``for i := a to b do``; por ejemplo, "
"``list(range(3))`` retorna la lista ``[0, 1, 2]``."

#: ../Doc/reference/compound_stmts.rst:199
msgid "Starred elements are now allowed in the expression list."
msgstr ""
"Los elementos destacados ahora están permitidos en la lista de expresiones."

#: ../Doc/reference/compound_stmts.rst:206
msgid "The :keyword:`!try` statement"
msgstr "La sentencia :keyword:`!try`"

#: ../Doc/reference/compound_stmts.rst:216
msgid ""
"The :keyword:`!try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ""
"La sentencia :keyword:`!try` especifica controladores de excepciones y/o "
"código de limpieza para un grupo de sentencias:"

#: ../Doc/reference/compound_stmts.rst:232
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information on using the :keyword:`raise` statement to "
"generate exceptions may be found in section :ref:`raise`."
msgstr ""
"Se puede encontrar información adicional sobre las excepciones en la "
"sección :ref:`exceptions`, e información sobre el uso de la sentencia :"
"keyword:`raise`, para lanzar excepciones se puede encontrar en la sección :"
"ref:`raise`."

#: ../Doc/reference/compound_stmts.rst:240
msgid ":keyword:`!except` clause"
msgstr "Cláusula :keyword:`!except`"

#: ../Doc/reference/compound_stmts.rst:242
msgid ""
"The :keyword:`!except` clause(s) specify one or more exception handlers. "
"When no exception occurs in the :keyword:`try` clause, no exception handler "
"is executed. When an exception occurs in the :keyword:`!try` suite, a search "
"for an exception handler is started. This search inspects the :keyword:`!"
"except` clauses in turn until one is found that matches the exception. An "
"expression-less :keyword:`!except` clause, if present, must be last; it "
"matches any exception. For an :keyword:`!except` clause with an expression, "
"that expression is evaluated, and the clause matches the exception if the "
"resulting object is \"compatible\" with the exception.  An object is "
"compatible with an exception if the object is the class or a :term:`non-"
"virtual base class <abstract base class>` of the exception object, or a "
"tuple containing an item that is the class or a non-virtual base class of "
"the exception object."
msgstr ""
"Las cláusulas :keyword:`!except` especifican uno o más controladores de "
"excepciones. Cuando no se produce ninguna excepción en la cláusula :keyword:"
"`try`, no se ejecuta ningún controlador de excepciones. Cuando ocurre una "
"excepción en la suite :keyword:`!try`, se inicia una búsqueda de un "
"controlador de excepciones. Esta búsqueda inspecciona las cláusulas :keyword:"
"`!except` a su vez hasta que se encuentra una que coincida con la excepción. "
"Una cláusula :keyword:`!except` sin expresión, si está presente, debe ser la "
"última; coincide con cualquier excepción. Para una cláusula :keyword:`!"
"except` con una expresión, esa expresión se evalúa y la cláusula coincide "
"con la excepción si el objeto resultante es \"compatible\" con la excepción. "
"Un objeto es compatible con una excepción si el objeto es la clase o un :"
"term:`non-virtual base class <abstract base class>` del objeto de excepción, "
"o una tupla que contiene un elemento que es la clase o una clase base no "
"virtual del objeto de excepción."

#: ../Doc/reference/compound_stmts.rst:257
msgid ""
"If no :keyword:`!except` clause matches the exception, the search for an "
"exception handler continues in the surrounding code and on the invocation "
"stack.  [#]_"
msgstr ""
"Si ninguna cláusula :keyword:`!except` coincide con la excepción, la "
"búsqueda de un controlador de excepciones continúa en el código circundante "
"y en la pila de invocaciones. [#]_"

#: ../Doc/reference/compound_stmts.rst:261
msgid ""
"If the evaluation of an expression in the header of an :keyword:`!except` "
"clause raises an exception, the original search for a handler is canceled "
"and a search starts for the new exception in the surrounding code and on the "
"call stack (it is treated as if the entire :keyword:`try` statement raised "
"the exception)."
msgstr ""
"Si la evaluación de una expresión en el encabezado de una cláusula :keyword:"
"`!except` genera una excepción, la búsqueda original de un controlador se "
"cancela y comienza una búsqueda de la nueva excepción en el código "
"circundante y en la pila de llamadas (se trata como si toda la sentencia :"
"keyword:`try` generara la excepción)."

#: ../Doc/reference/compound_stmts.rst:269
msgid ""
"When a matching :keyword:`!except` clause is found, the exception is "
"assigned to the target specified after the :keyword:`!as` keyword in that :"
"keyword:`!except` clause, if present, and the :keyword:`!except` clause's "
"suite is executed. All :keyword:`!except` clauses must have an executable "
"block. When the end of this block is reached, execution continues normally "
"after the entire :keyword:`try` statement. (This means that if two nested "
"handlers exist for the same exception, and the exception occurs in the :"
"keyword:`!try` clause of the inner handler, the outer handler will not "
"handle the exception.)"
msgstr ""
"Cuando se encuentra una cláusula :keyword:`!except` coincidente, la "
"excepción se asigna al destino especificado después de la palabra clave :"
"keyword:`!as` en esa cláusula :keyword:`!except`, si está presente, y se "
"ejecuta el conjunto de la cláusula :keyword:`!except`. Todas las cláusulas :"
"keyword:`!except` deben tener un bloque ejecutable. Cuando se alcanza el "
"final de este bloque, la ejecución continúa normalmente después de la "
"instrucción :keyword:`try` completa. (Esto significa que si existen dos "
"controladores anidados para la misma excepción y la excepción se produce en "
"la cláusula :keyword:`!try` del controlador interno, el controlador externo "
"no controlará la excepción)."

#: ../Doc/reference/compound_stmts.rst:280
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the :keyword:`!except` clause.  This is as if ::"
msgstr ""
"Cuando se ha asignado una excepción mediante ``as target``, se borra al "
"final de la cláusula :keyword:`!except`. Esto es como si ::"

#: ../Doc/reference/compound_stmts.rst:286
msgid "was translated to ::"
msgstr "fue traducido a ::"

#: ../Doc/reference/compound_stmts.rst:294
msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the :keyword:`!except` clause. Exceptions are cleared "
"because with the traceback attached to them, they form a reference cycle "
"with the stack frame, keeping all locals in that frame alive until the next "
"garbage collection occurs."
msgstr ""
"Esto significa que la excepción debe asignarse a un nombre diferente para "
"poder hacer referencia a ella después de la cláusula :keyword:`!except`. Las "
"excepciones se borran porque con el rastreo adjunto, forman un ciclo de "
"referencia con el marco de la pila, manteniendo todos los locales en ese "
"marco vivos hasta que ocurra la próxima recolección de elementos no "
"utilizados."

#: ../Doc/reference/compound_stmts.rst:304
msgid ""
"Before an :keyword:`!except` clause's suite is executed, details about the "
"exception are stored in the :mod:`sys` module and can be accessed via :func:"
"`sys.exc_info`. :func:`sys.exc_info` returns a 3-tuple consisting of the "
"exception class, the exception instance and a traceback object (see section :"
"ref:`types`) identifying the point in the program where the exception "
"occurred.  The details about the exception accessed via :func:`sys.exc_info` "
"are restored to their previous values when leaving an exception handler::"
msgstr ""
"Antes de que se ejecute un conjunto de cláusulas :keyword:`!except`, los "
"detalles sobre la excepción se almacenan en el módulo :mod:`sys` y se puede "
"acceder a ellos a través de :func:`sys.exc_info`. :func:`sys.exc_info` "
"devuelve una tupla de 3 que consta de la clase de excepción, la instancia de "
"excepción y un objeto de rastreo (consulte la sección :ref:`types`) que "
"identifica el punto del programa donde se produjo la excepción. Los detalles "
"sobre la excepción a la que se accede a través de :func:`sys.exc_info` se "
"restauran a sus valores anteriores cuando se deja un controlador de "
"excepciones:"

#: ../Doc/reference/compound_stmts.rst:338
msgid ":keyword:`!except*` clause"
msgstr "Cláusula :keyword:`!except*`"

#: ../Doc/reference/compound_stmts.rst:340
msgid ""
"The :keyword:`!except*` clause(s) are used for handling :exc:"
"`ExceptionGroup`\\s. The exception type for matching is interpreted as in "
"the case of :keyword:`except`, but in the case of exception groups we can "
"have partial matches when the type matches some of the exceptions in the "
"group. This means that multiple :keyword:`!except*` clauses can execute, "
"each handling part of the exception group. Each clause executes at most once "
"and handles an exception group of all matching exceptions.  Each exception "
"in the group is handled by at most one :keyword:`!except*` clause, the first "
"that matches it. ::"
msgstr ""
"La(s) cláusula(s) :keyword:`!except*` se utilizan para manejar :exc:"
"`ExceptionGroup`\\s. El tipo de excepción para la coincidencia se interpreta "
"como en el caso de :keyword:`except`, pero en el caso de los grupos de "
"excepción podemos tener coincidencias parciales cuando el tipo coincide con "
"algunas de las excepciones del grupo. Esto significa que se pueden ejecutar "
"varias cláusulas :keyword:`!except*`, cada una de las cuales maneja parte "
"del grupo de excepciones. Cada cláusula se ejecuta como máximo una vez y "
"maneja un grupo de excepciones de todas las excepciones coincidentes. Cada "
"excepción en el grupo es manejada por una cláusula :keyword:`!except*` como "
"máximo, la primera que coincida. ::"

#: ../Doc/reference/compound_stmts.rst:368
msgid ""
"Any remaining exceptions that were not handled by any :keyword:`!except*` "
"clause are re-raised at the end, combined into an exception group along with "
"all exceptions that were raised from within :keyword:`!except*` clauses."
msgstr ""
"Cualquier excepción restante que no haya sido manejada por ninguna cláusula :"
"keyword:`!except*` se vuelve a generar al final, se combina en un grupo de "
"excepciones junto con todas las excepciones que se generaron desde dentro de "
"las cláusulas :keyword:`!except*`."

#: ../Doc/reference/compound_stmts.rst:372
msgid ""
"If the raised exception is not an exception group and its type matches one "
"of the :keyword:`!except*` clauses, it is caught and wrapped by an exception "
"group with an empty message string. ::"
msgstr ""
"Si la excepción generada no es un grupo de excepciones y su tipo coincide "
"con una de las cláusulas :keyword:`!except*`, un grupo de excepciones la "
"captura y la encapsula con una cadena de mensaje vacía. ::"

#: ../Doc/reference/compound_stmts.rst:383
msgid ""
"An :keyword:`!except*` clause must have a matching type, and this type "
"cannot be a subclass of :exc:`BaseExceptionGroup`. It is not possible to "
"mix :keyword:`except` and :keyword:`!except*` in the same :keyword:`try`. :"
"keyword:`break`, :keyword:`continue` and :keyword:`return` cannot appear in "
"an :keyword:`!except*` clause."
msgstr ""
"Una cláusula :keyword:`!except*` debe tener un tipo coincidente y este tipo "
"no puede ser una subclase de :exc:`BaseExceptionGroup`. No es posible "
"mezclar :keyword:`except` y :keyword:`!except*` en el mismo :keyword:`try`. :"
"keyword:`break`, :keyword:`continue` y :keyword:`return` no pueden aparecer "
"en una cláusula :keyword:`!except*`."

#: ../Doc/reference/compound_stmts.rst:400
msgid ":keyword:`!else` clause"
msgstr "La sentencia :keyword:`!else`"

#: ../Doc/reference/compound_stmts.rst:402
msgid ""
"The optional :keyword:`!else` clause is executed if the control flow leaves "
"the :keyword:`try` suite, no exception was raised, and no :keyword:"
"`return`, :keyword:`continue`, or :keyword:`break` statement was executed.  "
"Exceptions in the :keyword:`!else` clause are not handled by the preceding :"
"keyword:`except` clauses."
msgstr ""
"La cláusula opcional :keyword:`!else` se ejecuta si el flujo de control sale "
"de la suite :keyword:`try`, no se produjo ninguna excepción, y no se ejecutó "
"la sentencia :keyword:`return`, :keyword:`continue` o :keyword:`break`. Las "
"excepciones en la cláusula :keyword:`!else` no se gestionaron con las "
"cláusulas precedentes :keyword:`except`."

#: ../Doc/reference/compound_stmts.rst:414
msgid ":keyword:`!finally` clause"
msgstr "Cláusula :keyword:`!finally`"

#: ../Doc/reference/compound_stmts.rst:416
msgid ""
"If :keyword:`!finally` is present, it specifies a 'cleanup' handler.  The :"
"keyword:`try` clause is executed, including any :keyword:`except` and :"
"keyword:`else` clauses.  If an exception occurs in any of the clauses and is "
"not handled, the exception is temporarily saved. The :keyword:`!finally` "
"clause is executed.  If there is a saved exception it is re-raised at the "
"end of the :keyword:`!finally` clause.  If the :keyword:`!finally` clause "
"raises another exception, the saved exception is set as the context of the "
"new exception. If the :keyword:`!finally` clause executes a :keyword:"
"`return`, :keyword:`break` or :keyword:`continue` statement, the saved "
"exception is discarded::"
msgstr ""
"Si :keyword:`!finally` está presente, especifica un controlador de "
"'limpieza'. Se ejecuta la cláusula :keyword:`try`, incluidas las cláusulas :"
"keyword:`except` y :keyword:`else`. Si ocurre una excepción en cualquiera de "
"las cláusulas y no se maneja, la excepción se guarda temporalmente. Se "
"ejecuta la cláusula :keyword:`!finally`. Si hay una excepción guardada, se "
"vuelve a generar al final de la cláusula :keyword:`!finally`. Si la "
"cláusula :keyword:`!finally` genera otra excepción, la excepción guardada se "
"establece como el contexto de la nueva excepción. Si la cláusula :keyword:`!"
"finally` ejecuta una sentencia :keyword:`return`, :keyword:`break` o :"
"keyword:`continue`, la excepción guardada se descarta:"

#: ../Doc/reference/compound_stmts.rst:435
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`!finally` clause."
msgstr ""
"La información de excepción no está disponible para el programa durante la "
"ejecución de la cláusula :keyword:`!finally`."

#: ../Doc/reference/compound_stmts.rst:443
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`!try`...\\ :keyword:`!"
"finally` statement, the :keyword:`!finally` clause is also executed 'on the "
"way out.'"
msgstr ""
"Cuando se ejecuta una sentencia :keyword:`return`, :keyword:`break` o :"
"keyword:`continue` en el conjunto :keyword:`try` de una sentencia :keyword:`!"
"try`...\\ :keyword:`!finally`, la cláusula :keyword:`!finally` también se "
"ejecuta 'al salir'."

#: ../Doc/reference/compound_stmts.rst:447
msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`!finally` clause always executes, "
"a :keyword:`!return` statement executed in the :keyword:`!finally` clause "
"will always be the last one executed::"
msgstr ""
"El valor de retorno de una función está determinado por la última "
"instrucción :keyword:`return` ejecutada. Dado que la cláusula :keyword:`!"
"finally` siempre se ejecuta, una sentencia :keyword:`!return` ejecutada en "
"la cláusula :keyword:`!finally` siempre será la última en ejecutarse:"

#: ../Doc/reference/compound_stmts.rst:461
msgid ""
"Prior to Python 3.8, a :keyword:`continue` statement was illegal in the :"
"keyword:`!finally` clause due to a problem with the implementation."
msgstr ""
"Antes de Python 3.8, una declaración :keyword:`continue` era ilegal en la "
"cláusula :keyword:`!finally` debido a un problema con la implementación."

#: ../Doc/reference/compound_stmts.rst:470
msgid "The :keyword:`!with` statement"
msgstr "La sentencia :keyword:`!with`"

#: ../Doc/reference/compound_stmts.rst:479
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ :keyword:"
"`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
"La sentencia :keyword:`with` se usa para ajustar la ejecución de un bloque "
"con métodos definidos por un administrador de contexto (ver sección :ref:"
"`context-managers`). Esto permite que los patrones de uso comunes :keyword:"
"`try`...\\ :keyword:`except`...\\ :keyword:`finally` se encapsulen para una "
"reutilización conveniente."

#: ../Doc/reference/compound_stmts.rst:489
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as "
"follows:"
msgstr ""
"La ejecución de la sentencia :keyword:`with` con un \"item\" se realiza de "
"la siguiente manera:"

#: ../Doc/reference/compound_stmts.rst:491
msgid ""
"The context expression (the expression given in the :token:`~python-grammar:"
"with_item`) is evaluated to obtain a context manager."
msgstr ""
"La expresión de contexto (la expresión dada en :token:`~python-grammar:"
"with_item`) se evalúa para obtener un administrador de contexto."

#: ../Doc/reference/compound_stmts.rst:494
msgid "The context manager's :meth:`__enter__` is loaded for later use."
msgstr ""
"El administrador de contexto :meth:`__enter__` se carga para su uso "
"posterior."

#: ../Doc/reference/compound_stmts.rst:496
msgid "The context manager's :meth:`__exit__` is loaded for later use."
msgstr ""
"El administrador de contexto :meth:`__exit__` se carga para su uso posterior."

#: ../Doc/reference/compound_stmts.rst:498
msgid "The context manager's :meth:`__enter__` method is invoked."
msgstr "Se invoca el método del administrador de contexto :meth:`__enter__`."

#: ../Doc/reference/compound_stmts.rst:500
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`__enter__` is assigned to it."
msgstr ""
"Si se incluyó el destino en la sentencia :keyword:`with`, se le asigna el "
"valor de retorno de :meth:`__enter__`."

#: ../Doc/reference/compound_stmts.rst:505
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`__enter__` "
"method returns without an error, then :meth:`__exit__` will always be "
"called. Thus, if an error occurs during the assignment to the target list, "
"it will be treated the same as an error occurring within the suite would be. "
"See step 6 below."
msgstr ""
"La sentencia :keyword:`with` garantiza que si el método :meth:`__enter__` "
"regresa sin error, entonces siempre se llamará a :meth:`__exit__`. Por lo "
"tanto, si se produce un error durante la asignación a la lista de destino, "
"se tratará de la misma manera que si se produciría un error dentro de la "
"suite. Vea el paso 6 a continuación."

#: ../Doc/reference/compound_stmts.rst:511
msgid "The suite is executed."
msgstr "La suite se ejecuta."

#: ../Doc/reference/compound_stmts.rst:513
msgid ""
"The context manager's :meth:`__exit__` method is invoked.  If an exception "
"caused the suite to be exited, its type, value, and traceback are passed as "
"arguments to :meth:`__exit__`. Otherwise, three :const:`None` arguments are "
"supplied."
msgstr ""
"Se invoca el método del administrador de contexto :meth:`__exit__`. Si una "
"excepción causó la salida de la suite, su tipo, valor y rastreo se pasan "
"como argumentos a :meth:`__exit__`. De lo contrario, se proporcionan tres "
"argumentos :const:`None`."

#: ../Doc/reference/compound_stmts.rst:518
msgid ""
"If the suite was exited due to an exception, and the return value from the :"
"meth:`__exit__` method was false, the exception is reraised.  If the return "
"value was true, the exception is suppressed, and execution continues with "
"the statement following the :keyword:`with` statement."
msgstr ""
"Si se salió de la suite debido a una excepción, y el valor de retorno del "
"método :meth:`__exit__` fue falso, la excepción se vuelve a plantear. Si el "
"valor de retorno era verdadero, la excepción se suprime y la ejecución "
"continúa con la sentencia que sigue a la sentencia :keyword:`with`."

#: ../Doc/reference/compound_stmts.rst:523
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`__exit__` is ignored, and execution proceeds at the normal "
"location for the kind of exit that was taken."
msgstr ""
"Si se salió de la suite por cualquier motivo que no sea una excepción, el "
"valor de retorno de :meth:`__exit__` se ignora y la ejecución continúa en la "
"ubicación normal para el tipo de salida que se tomó."

#: ../Doc/reference/compound_stmts.rst:527
#: ../Doc/reference/compound_stmts.rst:1517
#: ../Doc/reference/compound_stmts.rst:1558
msgid "The following code::"
msgstr "El siguiente código::"

#: ../Doc/reference/compound_stmts.rst:532
#: ../Doc/reference/compound_stmts.rst:557
#: ../Doc/reference/compound_stmts.rst:1563
msgid "is semantically equivalent to::"
msgstr "es semánticamente equivalente a::"

#: ../Doc/reference/compound_stmts.rst:551
msgid ""
"With more than one item, the context managers are processed as if multiple :"
"keyword:`with` statements were nested::"
msgstr ""
"Con más de un elemento, los administradores de contexto se procesan como si "
"varias sentencias :keyword:`with` estuvieran anidadas::"

#: ../Doc/reference/compound_stmts.rst:563
msgid ""
"You can also write multi-item context managers in multiple lines if the "
"items are surrounded by parentheses. For example::"
msgstr ""
"También puedes escribir administradores de contexto de múltiples ítems en "
"múltiples lineas si los ítems están entre paréntesis. Por ejemplo::"

#: ../Doc/reference/compound_stmts.rst:572
msgid "Support for multiple context expressions."
msgstr "Soporte para múltiples expresiones de contexto."

#: ../Doc/reference/compound_stmts.rst:575
msgid ""
"Support for using grouping parentheses to break the statement in multiple "
"lines."
msgstr ""
"Soporte para el uso de paréntesis de agrupación para separar la declaración "
"en múltiples líneas."

#: ../Doc/reference/compound_stmts.rst:581
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - La sentencia \"with\""

#: ../Doc/reference/compound_stmts.rst:581
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""
"La especificación, antecedentes y ejemplos de la sentencia de Python :"
"keyword:`with`."

#: ../Doc/reference/compound_stmts.rst:587
msgid "The :keyword:`!match` statement"
msgstr "La sentencia :keyword:`!match`"

#: ../Doc/reference/compound_stmts.rst:600
msgid "The match statement is used for pattern matching.  Syntax:"
msgstr ""
"La declaración match es usada para coincidencia de patrones.  Sintaxis:"

#: ../Doc/reference/compound_stmts.rst:609
msgid ""
"This section uses single quotes to denote :ref:`soft keywords <soft-"
"keywords>`."
msgstr ""
"Esta sección utiliza comillas simples para denotar las :ref:`palabras clave "
"suaves <soft-keywords>`."

# Se utilizó valor de búsqueda para traducir *subject value* basándose en la
# traducción francesa *champ de recherche*.
#: ../Doc/reference/compound_stmts.rst:612
msgid ""
"Pattern matching takes a pattern as input (following ``case``) and a subject "
"value (following ``match``).  The pattern (which may contain subpatterns) is "
"matched against the subject value.  The outcomes are:"
msgstr ""
"La coincidencia de patrones toma un patrón como entrada (delante de "
"``case``) y un valor de búsqueda (delante de ``match``).  El patrón (que "
"puede contener subpatrones) es comparado con el valor de búsqueda.  Los "
"resultados son:"

#: ../Doc/reference/compound_stmts.rst:616
msgid "A match success or failure (also termed a pattern success or failure)."
msgstr ""
"Una coincidencia exitosa o fallida (también llamada éxito o fracaso de un "
"patrón)."

#: ../Doc/reference/compound_stmts.rst:618
msgid ""
"Possible binding of matched values to a name.  The prerequisites for this "
"are further discussed below."
msgstr ""
"Una posible vinculación de los valores coincidentes con un nombre.  Los "
"requisitos previos para esto se discuten abajo."

#: ../Doc/reference/compound_stmts.rst:621
msgid ""
"The ``match`` and ``case`` keywords are :ref:`soft keywords <soft-keywords>`."
msgstr ""
"Las palabras clave ``match`` y ``case`` son :ref:`palabras clave suaves "
"<soft-keywords>`."

#: ../Doc/reference/compound_stmts.rst:625
#: ../Doc/reference/compound_stmts.rst:1180
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` -- Coincidencia de patrones estructurales: Especificación"

#: ../Doc/reference/compound_stmts.rst:626
#: ../Doc/reference/compound_stmts.rst:1181
msgid ":pep:`636` -- Structural Pattern Matching: Tutorial"
msgstr ":pep:`636` -- Coincidencia de patrones estructurales: Tutorial"

#: ../Doc/reference/compound_stmts.rst:630
msgid "Overview"
msgstr "Resumen"

#: ../Doc/reference/compound_stmts.rst:632
msgid "Here's an overview of the logical flow of a match statement:"
msgstr ""
"A continuación, un resumen del flujo lógico de una declaración de "
"coincidencia:"

#: ../Doc/reference/compound_stmts.rst:635
msgid ""
"The subject expression ``subject_expr`` is evaluated and a resulting subject "
"value obtained. If the subject expression contains a comma, a tuple is "
"constructed using :ref:`the standard rules <typesseq-tuple>`."
msgstr ""
"Se evalúa la expresión ``subject_expr`` y se obtiene un valor sujeto "
"resultante. Si la expresión contiene una coma, se construye una tupla "
"utilizando :ref:`las reglas estándar <typesseq-tuple>`."

#: ../Doc/reference/compound_stmts.rst:639
msgid ""
"Each pattern in a ``case_block`` is attempted to match with the subject "
"value. The specific rules for success or failure are described below. The "
"match attempt can also bind some or all of the standalone names within the "
"pattern. The precise pattern binding rules vary per pattern type and are "
"specified below.  **Name bindings made during a successful pattern match "
"outlive the executed block and can be used after the match statement**."
msgstr ""
"Se intenta coincidir cada patrón en un ``case_block`` con el valor sujeto. "
"Las reglas específicas para el éxito o el fracaso se describen abajo. El "
"intento de coincidencia también puede enlazar algunos o todos los nombres "
"independientes dentro del patrón. Las reglas precisas de enlace de patrones "
"varían según el tipo de patrón y se especifican a continuación.  **Los "
"enlaces de nombre realizados durante una coincidencia de patrones exitosa "
"sobreviven al bloque ejecutado y se pueden usar después de la declaración de "
"coincidencia**."

#: ../Doc/reference/compound_stmts.rst:648
msgid ""
"During failed pattern matches, some subpatterns may succeed.  Do not rely on "
"bindings being made for a failed match.  Conversely, do not rely on "
"variables remaining unchanged after a failed match.  The exact behavior is "
"dependent on implementation and may vary.  This is an intentional decision "
"made to allow different implementations to add optimizations."
msgstr ""
"Durante las coincidencias de patrones fallidas, algunos subpatrones pueden "
"tener éxito.  No confíe en que los enlaces se realicen para una coincidencia "
"fallida.  Por el contrario, no confíe en que las variables permanezcan sin "
"cambios después de una coincidencia fallida.  El comportamiento exacto "
"depende de la implementación y puede variar.  Esta es una decisión "
"intencional para permitir que diferentes implementaciones añadan "
"optimizaciones."

#: ../Doc/reference/compound_stmts.rst:655
msgid ""
"If the pattern succeeds, the corresponding guard (if present) is evaluated. "
"In this case all name bindings are guaranteed to have happened."
msgstr ""
"Si el patrón es exitoso, se evalúa la protección correspondiente (si está "
"presente). En este caso se garantiza que todos los enlaces de nombres han "
"ocurrido."

#: ../Doc/reference/compound_stmts.rst:658
msgid ""
"If the guard evaluates as true or is missing, the ``block`` inside "
"``case_block`` is executed."
msgstr ""
"Si la protección se evalúa como verdadera o no existe, se ejecuta el "
"``block`` dentro de ``case_block``."

#: ../Doc/reference/compound_stmts.rst:661
msgid "Otherwise, the next ``case_block`` is attempted as described above."
msgstr ""
"En caso contrario, se intenta con el siguiente ``case_block`` como se ha "
"descrito anteriormente."

#: ../Doc/reference/compound_stmts.rst:663
msgid "If there are no further case blocks, the match statement is completed."
msgstr ""
"Si no hay más bloques de casos, la declaración de coincidencia se completa."

#: ../Doc/reference/compound_stmts.rst:667
msgid ""
"Users should generally never rely on a pattern being evaluated.  Depending "
"on implementation, the interpreter may cache values or use other "
"optimizations which skip repeated evaluations."
msgstr ""
"Por lo general, los usuarios no deben confiar en que se evalúe un patrón.  "
"Dependiendo de la implementación, el intérprete puede almacenar en caché los "
"valores o utilizar otras optimizaciones que omitan las evaluaciones "
"repetidas."

#: ../Doc/reference/compound_stmts.rst:671
msgid "A sample match statement::"
msgstr "Un ejemplo de declaración de coincidencia::"

#: ../Doc/reference/compound_stmts.rst:687
msgid ""
"In this case, ``if flag`` is a guard.  Read more about that in the next "
"section."
msgstr ""
"En este caso, ``if flag`` es una protección.  Lea más sobre eso en la "
"siguiente sección."

#: ../Doc/reference/compound_stmts.rst:690
msgid "Guards"
msgstr "Protecciones"

#: ../Doc/reference/compound_stmts.rst:697
msgid ""
"A ``guard`` (which is part of the ``case``) must succeed for code inside the "
"``case`` block to execute.  It takes the form: :keyword:`if` followed by an "
"expression."
msgstr ""
"Una ``guard`` (que es parte del ``case``) debe ser exitosa para que el "
"código dentro de ``case`` sea ejecutado.  Toma la forma: :keyword:`if` "
"seguida de una expresión."

#: ../Doc/reference/compound_stmts.rst:702
msgid "The logical flow of a ``case`` block with a ``guard`` follows:"
msgstr ""
"El flujo lógico de un bloque ``case`` con una ``guard`` es el siguiente:"

#: ../Doc/reference/compound_stmts.rst:704
msgid ""
"Check that the pattern in the ``case`` block succeeded.  If the pattern "
"failed, the ``guard`` is not evaluated and the next ``case`` block is "
"checked."
msgstr ""
"Se comprueba que el patrón del bloque ``case`` fue exitoso.  Si el patrón "
"falló, el ``guard`` no se evalúa y se comprueba el siguiente bloque ``case``."

#: ../Doc/reference/compound_stmts.rst:708
msgid "If the pattern succeeded, evaluate the ``guard``."
msgstr "Si el patrón tuvo éxito, se evalúa el ``guard``."

#: ../Doc/reference/compound_stmts.rst:710
msgid ""
"If the ``guard`` condition evaluates as true, the case block is selected."
msgstr ""
"Si la condición del ``guard`` es verdadera, se selecciona el bloque de ese "
"caso."

#: ../Doc/reference/compound_stmts.rst:713
msgid ""
"If the ``guard`` condition evaluates as false, the case block is not "
"selected."
msgstr ""
"Si la condición del ``guard`` es falsa, el bloque de ese caso no es "
"seleccionado."

#: ../Doc/reference/compound_stmts.rst:716
msgid ""
"If the ``guard`` raises an exception during evaluation, the exception "
"bubbles up."
msgstr ""
"Si el ``guard`` lanza una excepción durante la evaluación, se levanta la "
"excepción."

#: ../Doc/reference/compound_stmts.rst:719
msgid ""
"Guards are allowed to have side effects as they are expressions.  Guard "
"evaluation must proceed from the first to the last case block, one at a "
"time, skipping case blocks whose pattern(s) don't all succeed. (I.e., guard "
"evaluation must happen in order.) Guard evaluation must stop once a case "
"block is selected."
msgstr ""
"Se permite que las protecciones tengan efectos secundarios, ya que son "
"expresiones.  La evaluación de la protección debe ir desde el primer al "
"último bloque de casos, uno a la vez, saltando los bloques de casos cuyo(s) "
"patrón(es) no tenga(n) éxito. (Es decir, la evaluación de las protecciones "
"debe realizarse en orden.) La evaluación de las protecciones debe detenerse "
"una vez que se selecciona un bloque de casos."

#: ../Doc/reference/compound_stmts.rst:729
msgid "Irrefutable Case Blocks"
msgstr "Bloques de Casos Irrefutables"

#: ../Doc/reference/compound_stmts.rst:733
msgid ""
"An irrefutable case block is a match-all case block.  A match statement may "
"have at most one irrefutable case block, and it must be last."
msgstr ""
"Un bloque de casos irrefutable es un bloque de casos que coincide con todo.  "
"Una declaración de coincidencia puede tener como máximo un bloque de casos "
"irrefutable, y debe ser el último."

#: ../Doc/reference/compound_stmts.rst:736
msgid ""
"A case block is considered irrefutable if it has no guard and its pattern is "
"irrefutable.  A pattern is considered irrefutable if we can prove from its "
"syntax alone that it will always succeed.  Only the following patterns are "
"irrefutable:"
msgstr ""
"Un bloque de casos se considera irrefutable si no tiene protección y su "
"patrón es irrefutable.  Un patrón se considera irrefutable si podemos "
"demostrar, sólo por su sintaxis, que siempre tendrá éxito.  Sólo los "
"siguientes patrones son irrefutables:"

#: ../Doc/reference/compound_stmts.rst:741
msgid ":ref:`as-patterns` whose left-hand side is irrefutable"
msgstr ":ref:`as-patterns` cuyo lado izquierdo es irrefutable"

#: ../Doc/reference/compound_stmts.rst:743
msgid ":ref:`or-patterns` containing at least one irrefutable pattern"
msgstr ":ref:`or-patterns` que contienen al menos un patrón irrefutable"

#: ../Doc/reference/compound_stmts.rst:745
msgid ":ref:`capture-patterns`"
msgstr ":ref:`capture-patterns`"

#: ../Doc/reference/compound_stmts.rst:747
msgid ":ref:`wildcard-patterns`"
msgstr ":ref:`wildcard-patterns`"

#: ../Doc/reference/compound_stmts.rst:749
msgid "parenthesized irrefutable patterns"
msgstr "patrones irrefutables entre paréntesis"

#: ../Doc/reference/compound_stmts.rst:753
msgid "Patterns"
msgstr "Patrones"

#: ../Doc/reference/compound_stmts.rst:760
msgid "This section uses grammar notations beyond standard EBNF:"
msgstr ""
"Esta sección utiliza notaciones gramaticales más allá del estándar EBNF:"

#: ../Doc/reference/compound_stmts.rst:762
msgid "the notation ``SEP.RULE+`` is shorthand for ``RULE (SEP RULE)*``"
msgstr "la notación ``SEP.RULE+`` es la abreviación de ``RULE (SEP RULE)*``"

#: ../Doc/reference/compound_stmts.rst:764
msgid "the notation ``!RULE`` is shorthand for a negative lookahead assertion"
msgstr ""
"la notación ``!RULE`` es la abreviación de una aserción de anticipación "
"negativa"

#: ../Doc/reference/compound_stmts.rst:767
msgid "The top-level syntax for ``patterns`` is:"
msgstr "La sintaxis de nivel superior para ``patrones`` es:"

#: ../Doc/reference/compound_stmts.rst:781
msgid ""
"The descriptions below will include a description \"in simple terms\" of "
"what a pattern does for illustration purposes (credits to Raymond Hettinger "
"for a document that inspired most of the descriptions). Note that these "
"descriptions are purely for illustration purposes and **may not** reflect "
"the underlying implementation.  Furthermore, they do not cover all valid "
"forms."
msgstr ""
"Las descripciones a continuación incluirán una descripción \"en términos "
"simples\" de lo que hace un patrón con fines ilustrativos (créditos a "
"Raymond Hettinger por un documento que inspiró la mayoría de las "
"descripciones). Tenga en cuenta que estas descripciones tienen únicamente "
"fines ilustrativos y que **may not** refleja la implementación subyacente. "
"Además, no cubren todos los formularios válidos."

#: ../Doc/reference/compound_stmts.rst:791
msgid "OR Patterns"
msgstr "Patrones OR"

#: ../Doc/reference/compound_stmts.rst:793
msgid ""
"An OR pattern is two or more patterns separated by vertical bars ``|``.  "
"Syntax:"
msgstr ""
"Un patrón OR son dos o más patrones separados por barras verticales ``|``. "
"Sintaxis:"

#: ../Doc/reference/compound_stmts.rst:799
msgid ""
"Only the final subpattern may be :ref:`irrefutable <irrefutable_case>`, and "
"each subpattern must bind the same set of names to avoid ambiguity."
msgstr ""
"Solo el subpatrón final puede ser :ref:`irrefutable <irrefutable_case>`, y "
"cada subpatrón debe vincular el mismo conjunto de nombres para evitar "
"ambigüedades."

#: ../Doc/reference/compound_stmts.rst:802
msgid ""
"An OR pattern matches each of its subpatterns in turn to the subject value, "
"until one succeeds.  The OR pattern is then considered successful.  "
"Otherwise, if none of the subpatterns succeed, the OR pattern fails."
msgstr ""
"Un patrón OR hace coincidir cada uno de sus subpatrones a su vez con el "
"valor del sujeto, hasta que uno tiene éxito. Entonces, el patrón OR se "
"considera exitoso. De lo contrario, si ninguno de los subpatrones tiene "
"éxito, el patrón OR falla."

#: ../Doc/reference/compound_stmts.rst:806
msgid ""
"In simple terms, ``P1 | P2 | ...`` will try to match ``P1``, if it fails it "
"will try to match ``P2``, succeeding immediately if any succeeds, failing "
"otherwise."
msgstr ""
"En términos simples, ``P1 | P2 | ...`` intentará igualar ``P1``, si falla, "
"intentará igualar ``P2``, teniendo éxito inmediatamente si alguno tiene "
"éxito, fallando en caso contrario."

#: ../Doc/reference/compound_stmts.rst:812
msgid "AS Patterns"
msgstr "patrones AS"

#: ../Doc/reference/compound_stmts.rst:814
msgid ""
"An AS pattern matches an OR pattern on the left of the :keyword:`as` keyword "
"against a subject.  Syntax:"
msgstr ""
"Un patrón AS coincide con un patrón OR a la izquierda de la palabra clave :"
"keyword:`as` con un sujeto. Sintaxis:"

#: ../Doc/reference/compound_stmts.rst:820
msgid ""
"If the OR pattern fails, the AS pattern fails.  Otherwise, the AS pattern "
"binds the subject to the name on the right of the as keyword and succeeds. "
"``capture_pattern`` cannot be a a ``_``."
msgstr ""
"Si el patrón OR falla, el patrón AS falla. De lo contrario, el patrón AS "
"vincula al sujeto con el nombre a la derecha de la palabra clave as y tiene "
"éxito. ``capture_pattern`` no puede ser un ``_``."

#: ../Doc/reference/compound_stmts.rst:824
msgid ""
"In simple terms ``P as NAME`` will match with ``P``, and on success it will "
"set ``NAME = <subject>``."
msgstr ""
"En términos simples, ``P as NAME`` coincidirá con ``P`` y, en caso de éxito, "
"establecerá ``NAME = <subject>``."

#: ../Doc/reference/compound_stmts.rst:831
msgid "Literal Patterns"
msgstr "Patrones literales"

#: ../Doc/reference/compound_stmts.rst:833
msgid ""
"A literal pattern corresponds to most :ref:`literals <literals>` in Python.  "
"Syntax:"
msgstr ""
"Un patrón literal corresponde a la mayoría de :ref:`literals <literals>` en "
"Python. Sintaxis:"

#: ../Doc/reference/compound_stmts.rst:846
msgid ""
"The rule ``strings`` and the token ``NUMBER`` are defined in the :doc:"
"`standard Python grammar <./grammar>`.  Triple-quoted strings are "
"supported.  Raw strings and byte strings are supported.  :ref:`f-strings` "
"are not supported."
msgstr ""
"La regla ``strings`` y el token ``NUMBER`` se definen en :doc:`standard "
"Python grammar <./grammar>`. Se admiten cadenas entre comillas triples. Se "
"admiten cadenas sin formato y cadenas de bytes. :ref:`f-strings` no es "
"compatible."

#: ../Doc/reference/compound_stmts.rst:851
msgid ""
"The forms ``signed_number '+' NUMBER`` and ``signed_number '-' NUMBER`` are "
"for expressing :ref:`complex numbers <imaginary>`; they require a real "
"number on the left and an imaginary number on the right. E.g. ``3 + 4j``."
msgstr ""
"Los formularios ``signed_number '+' NUMBER`` y ``signed_number '-' NUMBER`` "
"son para expresar :ref:`complex numbers <imaginary>`; requieren un número "
"real a la izquierda y un número imaginario a la derecha. P.ej. ``3 + 4j``."

#: ../Doc/reference/compound_stmts.rst:855
msgid ""
"In simple terms, ``LITERAL`` will succeed only if ``<subject> == LITERAL``. "
"For the singletons ``None``, ``True`` and ``False``, the :keyword:`is` "
"operator is used."
msgstr ""
"En términos simples, ``LITERAL`` solo tendrá éxito si ``<subject> == "
"LITERAL``. Para los singleton ``None``, ``True`` y ``False``, se utiliza el "
"operador :keyword:`is`."

#: ../Doc/reference/compound_stmts.rst:861
msgid "Capture Patterns"
msgstr "Patrones de captura"

#: ../Doc/reference/compound_stmts.rst:863
msgid "A capture pattern binds the subject value to a name. Syntax:"
msgstr ""
"Un patrón de captura vincula el valor del sujeto a un nombre. Sintaxis:"

#: ../Doc/reference/compound_stmts.rst:869
msgid ""
"A single underscore ``_`` is not a capture pattern (this is what ``!'_'`` "
"expresses). It is instead treated as a :token:`~python-grammar:"
"wildcard_pattern`."
msgstr ""
"Un solo guión bajo ``_`` no es un patrón de captura (esto es lo que expresa "
"``!'_'``). En su lugar, se trata como un :token:`~python-grammar:"
"wildcard_pattern`."

#: ../Doc/reference/compound_stmts.rst:873
msgid ""
"In a given pattern, a given name can only be bound once.  E.g. ``case x, "
"x: ...`` is invalid while ``case [x] | x: ...`` is allowed."
msgstr ""
"En un patrón dado, un nombre dado solo se puede vincular una vez. P.ej. "
"``case x, x: ...`` no es válido mientras ``case [x] | x: ...`` está "
"permitido."

#: ../Doc/reference/compound_stmts.rst:876
msgid ""
"Capture patterns always succeed.  The binding follows scoping rules "
"established by the assignment expression operator in :pep:`572`; the name "
"becomes a local variable in the closest containing function scope unless "
"there's an applicable :keyword:`global` or :keyword:`nonlocal` statement."
msgstr ""
"Los patrones de captura siempre tienen éxito. El enlace sigue las reglas de "
"alcance establecidas por el operador de expresión de asignación en :pep:"
"`572`; el nombre se convierte en una variable local en el alcance de la "
"función contenedora más cercana, a menos que haya una declaración :keyword:"
"`global` o :keyword:`nonlocal` aplicable."

#: ../Doc/reference/compound_stmts.rst:881
msgid ""
"In simple terms ``NAME`` will always succeed and it will set ``NAME = "
"<subject>``."
msgstr ""
"En términos simples, ``NAME`` siempre tendrá éxito y establecerá ``NAME = "
"<subject>``."

#: ../Doc/reference/compound_stmts.rst:886
msgid "Wildcard Patterns"
msgstr "Patrones comodín"

#: ../Doc/reference/compound_stmts.rst:888
msgid ""
"A wildcard pattern always succeeds (matches anything) and binds no name.  "
"Syntax:"
msgstr ""
"Un patrón comodín siempre tiene éxito (coincide con cualquier cosa) y no "
"vincula ningún nombre. Sintaxis:"

#: ../Doc/reference/compound_stmts.rst:894
msgid ""
"``_`` is a :ref:`soft keyword <soft-keywords>` within any pattern, but only "
"within patterns.  It is an identifier, as usual, even within ``match`` "
"subject expressions, ``guard``\\ s, and ``case`` blocks."
msgstr ""
"``_`` es un :ref:`soft keyword <soft-keywords>` dentro de cualquier patrón, "
"pero solo dentro de patrones. Es un identificador, como de costumbre, "
"incluso dentro de las expresiones de sujeto ``match``, ``guard`` \\ sy "
"bloques ``case``."

#: ../Doc/reference/compound_stmts.rst:898
msgid "In simple terms, ``_`` will always succeed."
msgstr "En términos simples, ``_`` siempre tendrá éxito."

#: ../Doc/reference/compound_stmts.rst:903
msgid "Value Patterns"
msgstr "Patrones de valor"

#: ../Doc/reference/compound_stmts.rst:905
msgid "A value pattern represents a named value in Python. Syntax:"
msgstr "Un patrón de valor representa un valor con nombre en Python. Sintaxis:"

#: ../Doc/reference/compound_stmts.rst:913
msgid ""
"The dotted name in the pattern is looked up using standard Python :ref:`name "
"resolution rules <resolve_names>`.  The pattern succeeds if the value found "
"compares equal to the subject value (using the ``==`` equality operator)."
msgstr ""
"El nombre con puntos en el patrón se busca usando el estándar Python :ref:"
"`name resolution rules <resolve_names>`. El patrón tiene éxito si el valor "
"encontrado se compara con el valor del sujeto (usando el operador de "
"igualdad ``==``)."

#: ../Doc/reference/compound_stmts.rst:918
msgid ""
"In simple terms ``NAME1.NAME2`` will succeed only if ``<subject> == NAME1."
"NAME2``"
msgstr ""
"En términos simples, ``NAME1.NAME2`` solo tendrá éxito si ``<subject> == "
"NAME1.NAME2``"

#: ../Doc/reference/compound_stmts.rst:922
msgid ""
"If the same value occurs multiple times in the same match statement, the "
"interpreter may cache the first value found and reuse it rather than repeat "
"the same lookup.  This cache is strictly tied to a given execution of a "
"given match statement."
msgstr ""
"Si el mismo valor ocurre varias veces en la misma declaración de "
"coincidencia, el intérprete puede almacenar en caché el primer valor "
"encontrado y reutilizarlo en lugar de repetir la misma búsqueda. Este caché "
"está estrictamente vinculado a una ejecución determinada de una declaración "
"de coincidencia determinada."

#: ../Doc/reference/compound_stmts.rst:930
msgid "Group Patterns"
msgstr "Patrones de grupo"

#: ../Doc/reference/compound_stmts.rst:932
msgid ""
"A group pattern allows users to add parentheses around patterns to emphasize "
"the intended grouping.  Otherwise, it has no additional syntax. Syntax:"
msgstr ""
"Un patrón de grupo permite a los usuarios agregar paréntesis alrededor de "
"los patrones para enfatizar la agrupación deseada. De lo contrario, no tiene "
"sintaxis adicional. Sintaxis:"

#: ../Doc/reference/compound_stmts.rst:939
msgid "In simple terms ``(P)`` has the same effect as ``P``."
msgstr "En términos simples, ``(P)`` tiene el mismo efecto que ``P``."

#: ../Doc/reference/compound_stmts.rst:944
msgid "Sequence Patterns"
msgstr "Patrones de secuencia"

#: ../Doc/reference/compound_stmts.rst:946
msgid ""
"A sequence pattern contains several subpatterns to be matched against "
"sequence elements. The syntax is similar to the unpacking of a list or tuple."
msgstr ""
"Un patrón de secuencia contiene varios subpatrones para hacer coincidir con "
"elementos de secuencia. La sintaxis es similar al desempaquetado de una "
"lista o tupla."

#: ../Doc/reference/compound_stmts.rst:957
msgid ""
"There is no difference if parentheses  or square brackets are used for "
"sequence patterns (i.e. ``(...)`` vs ``[...]`` )."
msgstr ""
"No hay diferencia si se utilizan paréntesis o corchetes para los patrones de "
"secuencia (es decir, ``(...)`` vs ``[...]``)."

#: ../Doc/reference/compound_stmts.rst:961
msgid ""
"A single pattern enclosed in parentheses without a trailing comma (e.g. ``(3 "
"| 4)``) is a :ref:`group pattern <group-patterns>`. While a single pattern "
"enclosed in square brackets (e.g. ``[3 | 4]``) is still a sequence pattern."
msgstr ""
"Un solo patrón encerrado entre paréntesis sin una coma final (por ejemplo, "
"``(3 | 4)``) es un :ref:`group pattern <group-patterns>`. Mientras que un "
"solo patrón encerrado entre corchetes (por ejemplo, ``[3 | 4]``) sigue "
"siendo un patrón de secuencia."

#: ../Doc/reference/compound_stmts.rst:966
msgid ""
"At most one star subpattern may be in a sequence pattern.  The star "
"subpattern may occur in any position. If no star subpattern is present, the "
"sequence pattern is a fixed-length sequence pattern; otherwise it is a "
"variable-length sequence pattern."
msgstr ""
"A lo sumo, un subpatrón de estrella puede estar en un patrón de secuencia. "
"El subpatrón de estrella puede ocurrir en cualquier posición. Si no hay "
"ningún subpatrón de estrella, el patrón de secuencia es un patrón de "
"secuencia de longitud fija; de lo contrario, es un patrón de secuencia de "
"longitud variable."

#: ../Doc/reference/compound_stmts.rst:971
msgid ""
"The following is the logical flow for matching a sequence pattern against a "
"subject value:"
msgstr ""
"El siguiente es el flujo lógico para hacer coincidir un patrón de secuencia "
"con un valor de sujeto:"

#: ../Doc/reference/compound_stmts.rst:974
msgid ""
"If the subject value is not a sequence [#]_, the sequence pattern fails."
msgstr ""
"Si el valor del sujeto no es una secuencia [#]_, el patrón de secuencia "
"falla."

#: ../Doc/reference/compound_stmts.rst:977
msgid ""
"If the subject value is an instance of ``str``, ``bytes`` or ``bytearray`` "
"the sequence pattern fails."
msgstr ""
"Si el valor del sujeto es una instancia de ``str``, ``bytes`` o "
"``bytearray``, el patrón de secuencia falla."

#: ../Doc/reference/compound_stmts.rst:980
msgid ""
"The subsequent steps depend on whether the sequence pattern is fixed or "
"variable-length."
msgstr ""
"Los pasos subsiguientes dependen de si el patrón de secuencia es de longitud "
"fija o variable."

#: ../Doc/reference/compound_stmts.rst:983
msgid "If the sequence pattern is fixed-length:"
msgstr "Si el patrón de secuencia es de longitud fija:"

#: ../Doc/reference/compound_stmts.rst:985
msgid ""
"If the length of the subject sequence is not equal to the number of "
"subpatterns, the sequence pattern fails"
msgstr ""
"Si la longitud de la secuencia del sujeto no es igual al número de "
"subpatrones, el patrón de secuencia falla"

#: ../Doc/reference/compound_stmts.rst:988
msgid ""
"Subpatterns in the sequence pattern are matched to their corresponding items "
"in the subject sequence from left to right.  Matching stops as soon as a "
"subpattern fails.  If all subpatterns succeed in matching their "
"corresponding item, the sequence pattern succeeds."
msgstr ""
"Los subpatrones del patrón de secuencia se hacen coincidir con sus elementos "
"correspondientes en la secuencia del sujeto de izquierda a derecha. El "
"emparejamiento se detiene tan pronto como falla un subpatrón. Si todos los "
"subpatrones tienen éxito en hacer coincidir su elemento correspondiente, el "
"patrón de secuencia tiene éxito."

#: ../Doc/reference/compound_stmts.rst:993
msgid "Otherwise, if the sequence pattern is variable-length:"
msgstr "De lo contrario, si el patrón de secuencia es de longitud variable:"

#: ../Doc/reference/compound_stmts.rst:995
msgid ""
"If the length of the subject sequence is less than the number of non-star "
"subpatterns, the sequence pattern fails."
msgstr ""
"Si la longitud de la secuencia del sujeto es menor que el número de "
"subpatrones sin estrella, el patrón de secuencia falla."

#: ../Doc/reference/compound_stmts.rst:998
msgid ""
"The leading non-star subpatterns are matched to their corresponding items as "
"for fixed-length sequences."
msgstr ""
"Los subpatrones principales no en estrella se emparejan con sus elementos "
"correspondientes como para las secuencias de longitud fija."

#: ../Doc/reference/compound_stmts.rst:1001
msgid ""
"If the previous step succeeds, the star subpattern matches a list formed of "
"the remaining subject items, excluding the remaining items corresponding to "
"non-star subpatterns following the star subpattern."
msgstr ""
"Si el paso anterior tiene éxito, el subpatrón en estrella coincide con una "
"lista formada por los elementos restantes del sujeto, excluyendo los "
"elementos restantes correspondientes a los subpatrones que no son en "
"estrella que siguen el subpatrón en estrella."

#: ../Doc/reference/compound_stmts.rst:1005
msgid ""
"Remaining non-star subpatterns are matched to their corresponding subject "
"items, as for a fixed-length sequence."
msgstr ""
"Los subpatrones restantes que no son estrellas se emparejan con sus "
"elementos temáticos correspondientes, como para una secuencia de longitud "
"fija."

#: ../Doc/reference/compound_stmts.rst:1008
msgid ""
"The length of the subject sequence is obtained via :func:`len` (i.e. via "
"the :meth:`__len__` protocol).  This length may be cached by the interpreter "
"in a similar manner as :ref:`value patterns <value-patterns>`."
msgstr ""
"La longitud de la secuencia del sujeto se obtiene a través de :func:`len` "
"(es decir, a través del protocolo :meth:`__len__`). El intérprete puede "
"almacenar en caché esta longitud de manera similar a :ref:`value patterns "
"<value-patterns>`."

#: ../Doc/reference/compound_stmts.rst:1014
msgid ""
"In simple terms ``[P1, P2, P3,`` ... ``, P<N>]`` matches only if all the "
"following happens:"
msgstr ""
"En términos simples, ``[P1, P2, P3,`` ... ``, P<N>]`` solo coincide si "
"ocurre todo lo siguiente:"

#: ../Doc/reference/compound_stmts.rst:1017
msgid "check ``<subject>`` is a sequence"
msgstr "comprobar que ``<subject>`` es una secuencia"

#: ../Doc/reference/compound_stmts.rst:1018
msgid "``len(subject) == <N>``"
msgstr "``len(subject) == <N>``"

#: ../Doc/reference/compound_stmts.rst:1019
msgid ""
"``P1`` matches ``<subject>[0]`` (note that this match can also bind names)"
msgstr ""
"``P1`` coincide con ``<subject>[0]`` (tenga en cuenta que esta coincidencia "
"también puede vincular nombres)"

#: ../Doc/reference/compound_stmts.rst:1020
msgid ""
"``P2`` matches ``<subject>[1]`` (note that this match can also bind names)"
msgstr ""
"``P2`` coincide con ``<subject>[1]`` (tenga en cuenta que esta coincidencia "
"también puede vincular nombres)"

#: ../Doc/reference/compound_stmts.rst:1021
msgid "... and so on for the corresponding pattern/element."
msgstr "... y así sucesivamente para el patrón/elemento correspondiente."

#: ../Doc/reference/compound_stmts.rst:1026
msgid "Mapping Patterns"
msgstr "Patrones de mapeo"

#: ../Doc/reference/compound_stmts.rst:1028
msgid ""
"A mapping pattern contains one or more key-value patterns.  The syntax is "
"similar to the construction of a dictionary. Syntax:"
msgstr ""
"Un patrón de asignación contiene uno o más patrones clave-valor. La sintaxis "
"es similar a la construcción de un diccionario. Sintaxis:"

#: ../Doc/reference/compound_stmts.rst:1039
msgid ""
"At most one double star pattern may be in a mapping pattern.  The double "
"star pattern must be the last subpattern in the mapping pattern."
msgstr ""
"Como máximo, un patrón de estrella doble puede estar en un patrón de mapeo. "
"El patrón de estrella doble debe ser el último subpatrón del patrón de mapeo."

#: ../Doc/reference/compound_stmts.rst:1042
msgid ""
"Duplicate keys in mapping patterns are disallowed. Duplicate literal keys "
"will raise a :exc:`SyntaxError`. Two keys that otherwise have the same value "
"will raise a :exc:`ValueError` at runtime."
msgstr ""
"No se permiten claves duplicadas en patrones de mapeo. Las claves literales "
"duplicadas lanzarán un :exc:`SyntaxError`. Dos claves que de otro modo "
"tendrían el mismo valor lanzarán un :exc:`ValueError` en tiempo de ejecución."

#: ../Doc/reference/compound_stmts.rst:1046
msgid ""
"The following is the logical flow for matching a mapping pattern against a "
"subject value:"
msgstr ""
"El siguiente es el flujo lógico para hacer coincidir un patrón de mapeo con "
"un valor de sujeto:"

#: ../Doc/reference/compound_stmts.rst:1049
msgid "If the subject value is not a mapping [#]_,the mapping pattern fails."
msgstr ""
"Si el valor del sujeto no es una asignación [#]_, el patrón de asignación "
"falla."

#: ../Doc/reference/compound_stmts.rst:1051
msgid ""
"If every key given in the mapping pattern is present in the subject mapping, "
"and the pattern for each key matches the corresponding item of the subject "
"mapping, the mapping pattern succeeds."
msgstr ""
"Si cada clave dada en el patrón de mapeo está presente en el mapeo del "
"sujeto, y el patrón para cada clave coincide con el elemento correspondiente "
"del mapeo del sujeto, el patrón de mapeo tiene éxito."

#: ../Doc/reference/compound_stmts.rst:1055
msgid ""
"If duplicate keys are detected in the mapping pattern, the pattern is "
"considered invalid. A :exc:`SyntaxError` is raised for duplicate literal "
"values; or a :exc:`ValueError` for named keys of the same value."
msgstr ""
"Si se detectan claves duplicadas en el patrón de mapeo, el patrón se "
"considera inválido. Se lanza un :exc:`SyntaxError` para valores literales "
"duplicados; o un :exc:`ValueError` para claves con nombre del mismo valor."

#: ../Doc/reference/compound_stmts.rst:1059
msgid ""
"Key-value pairs are matched using the two-argument form of the mapping "
"subject's ``get()`` method.  Matched key-value pairs must already be present "
"in the mapping, and not created on-the-fly via :meth:`__missing__` or :meth:"
"`__getitem__`."
msgstr ""
"Los pares clave-valor se hacen coincidir utilizando la forma de dos "
"argumentos del método ``get()`` del sujeto de mapeo. Los pares clave-valor "
"coincidentes ya deben estar presentes en la asignación y no deben crearse "
"sobre la marcha a través de :meth:`__missing__` o :meth:`__getitem__`."

#: ../Doc/reference/compound_stmts.rst:1064
msgid ""
"In simple terms ``{KEY1: P1, KEY2: P2, ... }`` matches only if all the "
"following happens:"
msgstr ""
"En términos simples, ``{KEY1: P1, KEY2: P2, ... }`` solo coincide si ocurre "
"todo lo siguiente:"

#: ../Doc/reference/compound_stmts.rst:1067
msgid "check ``<subject>`` is a mapping"
msgstr "comprobar ``<subject>`` es un mapeo"

#: ../Doc/reference/compound_stmts.rst:1068
msgid "``KEY1 in <subject>``"
msgstr "``KEY1 in <subject>``"

#: ../Doc/reference/compound_stmts.rst:1069
msgid "``P1`` matches ``<subject>[KEY1]``"
msgstr "``P1`` coincide con ``<subject>[KEY1]``"

#: ../Doc/reference/compound_stmts.rst:1070
msgid "... and so on for the corresponding KEY/pattern pair."
msgstr "... y así sucesivamente para el par correspondiente de KEY / patrón."

#: ../Doc/reference/compound_stmts.rst:1076
msgid "Class Patterns"
msgstr "Patrones de clase"

#: ../Doc/reference/compound_stmts.rst:1078
msgid ""
"A class pattern represents a class and its positional and keyword arguments "
"(if any).  Syntax:"
msgstr ""
"Un patrón de clase representa una clase y sus argumentos posicionales y de "
"palabras clave (si los hay). Sintaxis:"

#: ../Doc/reference/compound_stmts.rst:1089
msgid "The same keyword should not be repeated in class patterns."
msgstr "La misma palabra clave no debe repetirse en los patrones de clase."

#: ../Doc/reference/compound_stmts.rst:1091
msgid ""
"The following is the logical flow for matching a class pattern against a "
"subject value:"
msgstr ""
"El siguiente es el flujo lógico para hacer coincidir un patrón de clase con "
"un valor de materia:"

#: ../Doc/reference/compound_stmts.rst:1094
msgid ""
"If ``name_or_attr`` is not an instance of the builtin :class:`type` , raise :"
"exc:`TypeError`."
msgstr ""
"Si ``name_or_attr`` no es una instancia del :class:`type` incorporado, "
"genere :exc:`TypeError`."

#: ../Doc/reference/compound_stmts.rst:1097
msgid ""
"If the subject value is not an instance of ``name_or_attr`` (tested via :"
"func:`isinstance`), the class pattern fails."
msgstr ""
"Si el valor del sujeto no es una instancia de ``name_or_attr`` (probado a "
"través de :func:`isinstance`), el patrón de clase falla."

#: ../Doc/reference/compound_stmts.rst:1100
msgid ""
"If no pattern arguments are present, the pattern succeeds.  Otherwise, the "
"subsequent steps depend on whether keyword or positional argument patterns "
"are present."
msgstr ""
"Si no hay argumentos de patrón, el patrón tiene éxito. De lo contrario, los "
"pasos siguientes dependen de si están presentes patrones de argumentos de "
"posición o de palabras clave."

#: ../Doc/reference/compound_stmts.rst:1104
msgid ""
"For a number of built-in types (specified below), a single positional "
"subpattern is accepted which will match the entire subject; for these types "
"keyword patterns also work as for other types."
msgstr ""
"Para varios tipos integrados (especificados a continuación), se acepta un "
"único subpatrón posicional que coincidirá con todo el tema; para estos "
"tipos, los patrones de palabras clave también funcionan como para otros "
"tipos."

#: ../Doc/reference/compound_stmts.rst:1108
msgid ""
"If only keyword patterns are present, they are processed as follows, one by "
"one:"
msgstr ""
"Si solo hay patrones de palabras clave, se procesan de la siguiente manera, "
"uno por uno:"

#: ../Doc/reference/compound_stmts.rst:1111
msgid "I. The keyword is looked up as an attribute on the subject."
msgstr "I. La palabra clave se busca como un atributo del tema."

#: ../Doc/reference/compound_stmts.rst:1113
msgid ""
"If this raises an exception other than :exc:`AttributeError`, the exception "
"bubbles up."
msgstr ""
"Si esto lanza una excepción distinta de :exc:`AttributeError`, la excepción "
"aparece."

#: ../Doc/reference/compound_stmts.rst:1116
msgid "If this raises :exc:`AttributeError`, the class pattern has failed."
msgstr "Si esto lanza :exc:`AttributeError`, el patrón de clase ha fallado."

#: ../Doc/reference/compound_stmts.rst:1118
msgid ""
"Else, the subpattern associated with the keyword pattern is matched against "
"the subject's attribute value.  If this fails, the class pattern fails; if "
"this succeeds, the match proceeds to the next keyword."
msgstr ""
"De lo contrario, el subpatrón asociado con el patrón de palabra clave se "
"compara con el valor del atributo del sujeto. Si esto falla, el patrón de "
"clase falla; si esto tiene éxito, la coincidencia continúa con la siguiente "
"palabra clave."

#: ../Doc/reference/compound_stmts.rst:1123
msgid "II. If all keyword patterns succeed, the class pattern succeeds."
msgstr ""
"II. Si todos los patrones de palabras clave tienen éxito, el patrón de clase "
"tiene éxito."

#: ../Doc/reference/compound_stmts.rst:1125
msgid ""
"If any positional patterns are present, they are converted to keyword "
"patterns using the :data:`~object.__match_args__` attribute on the class "
"``name_or_attr`` before matching:"
msgstr ""
"Si hay algún patrón posicional presente, se convierte en patrones de "
"palabras clave utilizando el atributo :data:`~object.__match_args__` en la "
"clase ``name_or_attr`` antes de hacer coincidir:"

#: ../Doc/reference/compound_stmts.rst:1129
msgid ""
"I. The equivalent of ``getattr(cls, \"__match_args__\", ())`` is called."
msgstr ""
"I. Se llama el equivalente de ``getattr(cls, \"__match_args__\", ())``."

#: ../Doc/reference/compound_stmts.rst:1131
msgid "If this raises an exception, the exception bubbles up."
msgstr "Si esto lanza una excepción, la excepción surge."

#: ../Doc/reference/compound_stmts.rst:1133
msgid ""
"If the returned value is not a tuple, the conversion fails and :exc:"
"`TypeError` is raised."
msgstr ""
"Si el valor retornado no es una tupla, la conversión falla y se lanza :exc:"
"`TypeError`."

#: ../Doc/reference/compound_stmts.rst:1136
msgid ""
"If there are more positional patterns than ``len(cls.__match_args__)``, :exc:"
"`TypeError` is raised."
msgstr ""
"Si hay más patrones posicionales que ``len(cls.__match_args__)``, se lanza :"
"exc:`TypeError`."

#: ../Doc/reference/compound_stmts.rst:1139
msgid ""
"Otherwise, positional pattern ``i`` is converted to a keyword pattern using "
"``__match_args__[i]`` as the keyword.  ``__match_args__[i]`` must be a "
"string; if not :exc:`TypeError` is raised."
msgstr ""
"De lo contrario, el patrón posicional ``i`` se convierte en un patrón de "
"palabra clave utilizando ``__match_args__[i]`` como palabra clave. "
"``__match_args__[i]`` debe ser una cadena; si no, se lanza :exc:`TypeError`."

#: ../Doc/reference/compound_stmts.rst:1143
msgid "If there are duplicate keywords, :exc:`TypeError` is raised."
msgstr "Si hay palabras clave duplicadas, se lanza :exc:`TypeError`."

#: ../Doc/reference/compound_stmts.rst:1145
msgid ":ref:`class-pattern-matching`"
msgstr ":ref:`class-pattern-matching`"

#: ../Doc/reference/compound_stmts.rst:1148
msgid ""
"II. Once all positional patterns have been converted to keyword patterns,"
msgstr ""
"II. Una vez que todos los patrones posicionales se hayan convertido en "
"patrones de palabras clave,"

#: ../Doc/reference/compound_stmts.rst:1148
msgid "the match proceeds as if there were only keyword patterns."
msgstr ""
"la coincidencia procede como si solo hubiera patrones de palabras clave."

#: ../Doc/reference/compound_stmts.rst:1150
msgid ""
"For the following built-in types the handling of positional subpatterns is "
"different:"
msgstr ""
"Para los siguientes tipos integrados, el manejo de subpatrones posicionales "
"es diferente:"

#: ../Doc/reference/compound_stmts.rst:1153
msgid ":class:`bool`"
msgstr ":class:`bool`"

#: ../Doc/reference/compound_stmts.rst:1154
msgid ":class:`bytearray`"
msgstr ":class:`bytearray`"

#: ../Doc/reference/compound_stmts.rst:1155
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../Doc/reference/compound_stmts.rst:1156
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: ../Doc/reference/compound_stmts.rst:1157
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../Doc/reference/compound_stmts.rst:1158
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: ../Doc/reference/compound_stmts.rst:1159
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../Doc/reference/compound_stmts.rst:1160
#: ../Doc/reference/compound_stmts.rst:1611
msgid ":class:`list`"
msgstr ":class:`list`"

#: ../Doc/reference/compound_stmts.rst:1161
msgid ":class:`set`"
msgstr ":class:`set`"

#: ../Doc/reference/compound_stmts.rst:1162
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../Doc/reference/compound_stmts.rst:1163
#: ../Doc/reference/compound_stmts.rst:1614
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: ../Doc/reference/compound_stmts.rst:1165
msgid ""
"These classes accept a single positional argument, and the pattern there is "
"matched against the whole object rather than an attribute. For example "
"``int(0|1)`` matches the value ``0``, but not the value ``0.0``."
msgstr ""
"Estas clases aceptan un solo argumento posicional, y el patrón allí se "
"compara con el objeto completo en lugar de con un atributo. Por ejemplo, "
"``int(0|1)`` coincide con el valor ``0``, pero no con el valor ``0.0``."

#: ../Doc/reference/compound_stmts.rst:1169
msgid ""
"In simple terms ``CLS(P1, attr=P2)`` matches only if the following happens:"
msgstr ""
"En términos simples, ``CLS(P1, attr=P2)`` solo coincide si ocurre lo "
"siguiente:"

#: ../Doc/reference/compound_stmts.rst:1171
msgid "``isinstance(<subject>, CLS)``"
msgstr "``isinstance(<subject>, CLS)``"

#: ../Doc/reference/compound_stmts.rst:1172
msgid "convert ``P1`` to a keyword pattern using ``CLS.__match_args__``"
msgstr ""
"convierta ``P1`` en un patrón de palabra clave usando ``CLS.__match_args__``"

#: ../Doc/reference/compound_stmts.rst:1174
msgid "For each keyword argument ``attr=P2``:"
msgstr "Para cada argumento de palabra clave ``attr=P2``:"

#: ../Doc/reference/compound_stmts.rst:1174
msgid "``hasattr(<subject>, \"attr\")``"
msgstr "``hasattr(<subject>, \"attr\")``"

#: ../Doc/reference/compound_stmts.rst:1175
msgid "``P2`` matches ``<subject>.attr``"
msgstr "``P2`` coincide con ``<subject>.attr``"

#: ../Doc/reference/compound_stmts.rst:1176
msgid "... and so on for the corresponding keyword argument/pattern pair."
msgstr ""
"... y así sucesivamente para el par de patrón / argumento de palabra clave "
"correspondiente."

#: ../Doc/reference/compound_stmts.rst:1191
msgid "Function definitions"
msgstr "Definiciones de funciones"

#: ../Doc/reference/compound_stmts.rst:1206
msgid ""
"A function definition defines a user-defined function object (see section :"
"ref:`types`):"
msgstr ""
"Una definición de función define una función objeto determinada por el "
"usuario (consulte la sección :ref:`types`):"

#: ../Doc/reference/compound_stmts.rst:1225
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper "
"around the executable code for the function).  This function object contains "
"a reference to the current global namespace as the global namespace to be "
"used when the function is called."
msgstr ""
"Una definición de función es una sentencia ejecutable. Su ejecución vincula "
"el nombre de la función en el espacio de nombres local actual a un objeto de "
"función (un contenedor alrededor del código ejecutable para la función). "
"Este objeto de función contiene una referencia al espacio de nombres global "
"actual como el espacio de nombres global que se utilizará cuando se llama a "
"la función."

#: ../Doc/reference/compound_stmts.rst:1231
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr ""
"La definición de la función no ejecuta el cuerpo de la función; esto se "
"ejecuta solo cuando se llama a la función. [#]_"

#: ../Doc/reference/compound_stmts.rst:1237
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""
"Una definición de función puede estar envuelta por una o más expresiones :"
"term:`decorator`. Las expresiones de decorador se evalúan cuando se define "
"la función, en el ámbito que contiene la definición de la función. El "
"resultado debe ser invocable, la cual se invoca con el objeto de función "
"como único argumento. El valor retornado está vinculado al nombre de la "
"función en lugar del objeto de la función. Se aplican múltiples decoradores "
"de forma anidada. Por ejemplo, el siguiente código ::"

#: ../Doc/reference/compound_stmts.rst:1248
#: ../Doc/reference/compound_stmts.rst:1425
msgid "is roughly equivalent to ::"
msgstr "es más o menos equivalente a ::"

#: ../Doc/reference/compound_stmts.rst:1253
msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr ""
"excepto que la función original no está vinculada temporalmente al nombre "
"``func``."

#: ../Doc/reference/compound_stmts.rst:1255
msgid ""
"Functions may be decorated with any valid :token:`~python-grammar:"
"assignment_expression`. Previously, the grammar was much more restrictive; "
"see :pep:`614` for details."
msgstr ""
"Las funciones se pueden decorar con cualquier :token:`~python-grammar:"
"assignment_expression` válido. Anteriormente, la gramática era mucho más "
"restrictiva; ver :pep:`614` para más detalles."

#: ../Doc/reference/compound_stmts.rst:1265
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter values."
"\"  For a parameter with a default value, the corresponding :term:`argument` "
"may be omitted from a call, in which case the parameter's default value is "
"substituted.  If a parameter has a default value, all following parameters "
"up until the \"``*``\" must also have a default value --- this is a "
"syntactic restriction that is not expressed by the grammar."
msgstr ""
"Cuando uno o más :term:`parameters <parameter>` tienen la forma *parameter* "
"``=`` *expression*, se dice que la función tiene \"valores de parámetros "
"predeterminados\". Para un parámetro con un valor predeterminado, el "
"correspondiente :term:`argument` puede omitirse desde una llamada, en cuyo "
"caso se sustituye el valor predeterminado del parámetro. Si un parámetro "
"tiene un valor predeterminado, todos los parámetros siguientes hasta el "
"\"``*``\" también deben tener un valor predeterminado --- esta es una "
"restricción sintáctica que la gramática no expresa."

#: ../Doc/reference/compound_stmts.rst:1273
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter value is a mutable object, such as a "
"list or a dictionary: if the function modifies the object (e.g. by appending "
"an item to a list), the default parameter value is in effect modified.  This "
"is generally not what was intended.  A way around this is to use ``None`` as "
"the default, and explicitly test for it in the body of the function, e.g.::"
msgstr ""
"**Los valores de los parámetros predeterminados se evalúan de izquierda a "
"derecha cuando se ejecuta la definición de la función.** Esto significa que "
"la expresión se evalúa una vez, cuando se define la función, y que se "
"utiliza el mismo valor \"precalculado\" para cada llamada . Esto es "
"especialmente importante para entender cuando un parámetro predeterminado es "
"un objeto mutable, como una lista o un diccionario: si la función modifica "
"el objeto (por ejemplo, al agregar un elemento a una lista), el valor "
"predeterminado está en efecto modificado. Esto generalmente no es lo que se "
"pretendía. Una forma de evitar esto es usar ``None`` como valor "
"predeterminado y probarlo explícitamente en el cuerpo de la función, por "
"ejemplo::"

#: ../Doc/reference/compound_stmts.rst:1294
msgid ""
"Function call semantics are described in more detail in section :ref:"
"`calls`. A function call always assigns values to all parameters mentioned "
"in the parameter list, either from positional arguments, from keyword "
"arguments, or from default values.  If the form \"``*identifier``\" is "
"present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple. If the form \"``**identifier``\" "
"is present, it is initialized to a new ordered mapping receiving any excess "
"keyword arguments, defaulting to a new empty mapping of the same type.  "
"Parameters after \"``*``\" or \"``*identifier``\" are keyword-only "
"parameters and may only be passed by keyword arguments.  Parameters before "
"\"``/``\" are positional-only parameters and may only be passed by "
"positional arguments."
msgstr ""
"La semántica de llamadas de función se describe con más detalle en la "
"sección :ref:`calls`. Una llamada a la función siempre asigna valores a "
"todos los parámetros mencionados en la lista de parámetros, ya sea desde "
"argumentos de posición, desde argumentos por palabra clave o desde valores "
"predeterminados. Si está presente la forma \"``*identifier``\", se "
"inicializa en una tupla que recibe cualquier parámetro posicional excedente, "
"por defecto en la tupla vacía. Si el formulario \"``**identifier``\" está "
"presente, se inicializa a una nueva asignación ordenada que recibe cualquier "
"exceso de argumentos por palabra clave, por defecto a una nueva asignación "
"vacía del mismo tipo. Los parámetros después de \"``*``\" o "
"\"``*identifier``\" son parámetros solo por palabra clave y solo pueden "
"pasarse con argumentos de palabras claves usadas."

#: ../Doc/reference/compound_stmts.rst:1306
msgid ""
"The ``/`` function parameter syntax may be used to indicate positional-only "
"parameters. See :pep:`570` for details."
msgstr ""
"La sintaxis del parámetro de función ``/`` se puede utilizar para indicar "
"parámetros de posición únicamente. Consulte :pep:`570` para obtener más "
"detalles."

#: ../Doc/reference/compound_stmts.rst:1315
msgid ""
"Parameters may have an :term:`annotation <function annotation>` of the form "
"\"``: expression``\" following the parameter name.  Any parameter may have "
"an annotation, even those of the form ``*identifier`` or ``**identifier``.  "
"Functions may have \"return\" annotation of the form \"``-> expression``\" "
"after the parameter list.  These annotations can be any valid Python "
"expression.  The presence of annotations does not change the semantics of a "
"function.  The annotation values are available as values of a dictionary "
"keyed by the parameters' names in the :attr:`__annotations__` attribute of "
"the function object.  If the ``annotations`` import from :mod:`__future__` "
"is used, annotations are preserved as strings at runtime which enables "
"postponed evaluation.  Otherwise, they are evaluated when the function "
"definition is executed.  In this case annotations may be evaluated in a "
"different order than they appear in the source code."
msgstr ""
"Los parámetros pueden tener :term:`annotation <function annotation>` de la "
"forma \"``: expression``\" que sigue al nombre del parámetro. Cualquier "
"parámetro puede tener una anotación, incluso las de la forma ``*identifier`` "
"o ``** identifier``. Las funciones pueden tener una anotación \"return\" de "
"la forma \"``-> expression``\" después de la lista de parámetros. Estas "
"anotaciones pueden ser cualquier expresión válida de Python. La presencia de "
"anotaciones no cambia la semántica de una función. Los valores de anotación "
"están disponibles como valores de un diccionario con los nombres de los "
"parámetros en el atributo :attr:`__annotations__` del objeto de la función. "
"Si se usa ``annotations`` importada desde :mod:`__future__`, las anotaciones "
"se conservan como cadenas de caracteres en tiempo de ejecución que permiten "
"la evaluación pospuesta. De lo contrario, se evalúan cuando se ejecuta la "
"definición de la función. En este caso, las anotaciones pueden evaluarse en "
"un orden diferente al que aparecen en el código fuente."

#: ../Doc/reference/compound_stmts.rst:1330
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The \":"
"keyword:`!def`\" form is actually more powerful since it allows the "
"execution of multiple statements and annotations."
msgstr ""
"También es posible crear funciones anónimas (funciones no vinculadas a un "
"nombre), para uso inmediato en expresiones. Utiliza expresiones lambda, "
"descritas en la sección :ref:`lambda`. Tenga en cuenta que la expresión "
"lambda es simplemente una abreviatura para una definición de función "
"simplificada; una función definida en una sentencia \":keyword:`def`\" puede "
"pasarse o asignarse a otro nombre al igual que una función definida por una "
"expresión lambda. La forma \":keyword:`!def`\" es en realidad más poderosa "
"ya que permite la ejecución de múltiples sentencias y anotaciones."

#: ../Doc/reference/compound_stmts.rst:1338
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested "
"function can access the local variables of the function containing the def.  "
"See section :ref:`naming` for details."
msgstr ""
"**Nota del programador:** Las funciones son objetos de la primera-clase. Una "
"sentencia \"``def``\" ejecutada dentro de una definición de función define "
"una función local que se puede retornar o pasar. Las variables libres "
"utilizadas en la función anidada pueden acceder a las variables locales de "
"la función que contiene el def. Vea la sección :ref:`naming` para más "
"detalles."

#: ../Doc/reference/compound_stmts.rst:1347
msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` - Anotaciones de funciones"

#: ../Doc/reference/compound_stmts.rst:1347
msgid "The original specification for function annotations."
msgstr "La especificación original para anotaciones de funciones."

#: ../Doc/reference/compound_stmts.rst:1350
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - Sugerencias de tipo"

#: ../Doc/reference/compound_stmts.rst:1350
msgid "Definition of a standard meaning for annotations: type hints."
msgstr ""
"Definición de un significado estándar para anotaciones: sugerencias de tipo."

#: ../Doc/reference/compound_stmts.rst:1354
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - Sintaxis para anotaciones variables"

#: ../Doc/reference/compound_stmts.rst:1353
msgid ""
"Ability to type hint variable declarations, including class variables and "
"instance variables"
msgstr ""
"Capacidad para escribir declaraciones de variables indirectas, incluidas "
"variables de clase y variables de instancia"

#: ../Doc/reference/compound_stmts.rst:1357
msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ":pep:`563` - Evaluación pospuesta de anotaciones"

#: ../Doc/reference/compound_stmts.rst:1357
msgid ""
"Support for forward references within annotations by preserving annotations "
"in a string form at runtime instead of eager evaluation."
msgstr ""
"Admite referencias directas dentro de las anotaciones conservando las "
"anotaciones en forma de cadena de caracteres en tiempo de ejecución en lugar "
"de una evaluación apresurada."

#: ../Doc/reference/compound_stmts.rst:1364
msgid "Class definitions"
msgstr "Definiciones de clase"

#: ../Doc/reference/compound_stmts.rst:1379
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr ""
"Una definición de clase define un objeto de clase (ver sección :ref:`types`):"

#: ../Doc/reference/compound_stmts.rst:1386
msgid ""
"A class definition is an executable statement.  The inheritance list usually "
"gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""
"Una definición de clase es una sentencia ejecutable. La lista de herencia "
"generalmente proporciona una lista de clases base (consulte :ref:"
"`metaclasses` para usos más avanzados), por lo que cada elemento de la lista "
"debe evaluar a un objeto de clase que permita la subclasificación. Las "
"clases sin una lista de herencia heredan, por defecto, de la clase base :"
"class:`object`; por lo tanto, ::"

#: ../Doc/reference/compound_stmts.rst:1395
msgid "is equivalent to ::"
msgstr "es equivalente a ::"

#: ../Doc/reference/compound_stmts.rst:1400
msgid ""
"The class's suite is then executed in a new execution frame (see :ref:"
"`naming`), using a newly created local namespace and the original global "
"namespace. (Usually, the suite contains mostly function definitions.)  When "
"the class's suite finishes execution, its execution frame is discarded but "
"its local namespace is saved. [#]_ A class object is then created using the "
"inheritance list for the base classes and the saved local namespace for the "
"attribute dictionary.  The class name is bound to this class object in the "
"original local namespace."
msgstr ""
"La suite de la clase se ejecuta en un nuevo marco de ejecución (ver :ref:"
"`naming`), usando un espacio de nombres local recién creado y el espacio de "
"nombres global original. (Por lo general, el bloque contiene principalmente "
"definiciones de funciones). Cuando la suite de la clase finaliza la "
"ejecución, su marco de ejecución se descarta pero se guarda su espacio de "
"nombres local. [#]_ Luego se crea un objeto de clase utilizando la lista de "
"herencia para las clases base y el espacio de nombres local guardado para el "
"diccionario de atributos. El nombre de la clase está vinculado a este objeto "
"de clase en el espacio de nombres local original."

#: ../Doc/reference/compound_stmts.rst:1409
msgid ""
"The order in which attributes are defined in the class body is preserved in "
"the new class's ``__dict__``.  Note that this is reliable only right after "
"the class is created and only for classes that were defined using the "
"definition syntax."
msgstr ""
"El orden en que se definen los atributos en el cuerpo de la clase se "
"conserva en el ``__dict__`` de la nueva clase. Tenga en cuenta que esto es "
"confiable solo justo después de crear la clase y solo para las clases que se "
"definieron utilizando la sintaxis de definición."

#: ../Doc/reference/compound_stmts.rst:1414
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr ""
"La creación de clases se puede personalizar en gran medida usando :ref:"
"`metaclasses <metaclasses>`."

#: ../Doc/reference/compound_stmts.rst:1419
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr ""
"Las clases también se pueden decorar: al igual que cuando se decoran "
"funciones, ::"

#: ../Doc/reference/compound_stmts.rst:1430
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr ""
"Las reglas de evaluación para las expresiones de decorador son las mismas "
"que para los decoradores de funciones. El resultado se vincula al nombre de "
"la clase."

#: ../Doc/reference/compound_stmts.rst:1433
msgid ""
"Classes may be decorated with any valid :token:`~python-grammar:"
"assignment_expression`. Previously, the grammar was much more restrictive; "
"see :pep:`614` for details."
msgstr ""
"Las clases se pueden decorar con cualquier :token:`~python-grammar:"
"assignment_expression` válido. Anteriormente, la gramática era mucho más "
"restrictiva; ver :pep:`614` para más detalles."

#: ../Doc/reference/compound_stmts.rst:1438
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in "
"a method with ``self.name = value``.  Both class and instance attributes are "
"accessible through the notation \"``self.name``\", and an instance attribute "
"hides a class attribute with the same name when accessed in this way.  Class "
"attributes can be used as defaults for instance attributes, but using "
"mutable values there can lead to unexpected results.  :ref:`Descriptors "
"<descriptors>` can be used to create instance variables with different "
"implementation details."
msgstr ""
"** Nota del programador: ** Las variables definidas en la definición de la "
"clase son atributos de clase; son compartidos por instancias. Los atributos "
"de instancia se pueden establecer en un método con ``self.name = value``. Se "
"puede acceder a los atributos de clase e instancia a través de la notación "
"\"``self.name``\", y un atributo de instancia oculta un atributo de clase "
"con el mismo nombre cuando se accede de esta manera. Los atributos de clase "
"se pueden usar como valores predeterminados para los atributos de instancia, "
"pero el uso de valores mutables puede generar resultados inesperados. :ref:"
"`Descriptors <descriptors>` se puede usar para crear variables de instancia "
"con diferentes detalles de implementación."

#: ../Doc/reference/compound_stmts.rst:1453
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Metaclases en Python 3000"

#: ../Doc/reference/compound_stmts.rst:1451
msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are constructed."
msgstr ""
"La propuesta que cambió la declaración de metaclases a la sintaxis actual y "
"la semántica de cómo se construyen las clases con metaclases."

#: ../Doc/reference/compound_stmts.rst:1456
msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - Decoradores de clase"

#: ../Doc/reference/compound_stmts.rst:1456
msgid ""
"The proposal that added class decorators.  Function and method decorators "
"were introduced in :pep:`318`."
msgstr ""
"La propuesta que agregó decoradores de clase. Los decoradores de funciones y "
"métodos se introdujeron en :pep:`318`."

#: ../Doc/reference/compound_stmts.rst:1463
msgid "Coroutines"
msgstr "Corrutinas"

#: ../Doc/reference/compound_stmts.rst:1471
msgid "Coroutine function definition"
msgstr "Definición de la función corrutina"

#: ../Doc/reference/compound_stmts.rst:1481
msgid ""
"Execution of Python coroutines can be suspended and resumed at many points "
"(see :term:`coroutine`). :keyword:`await` expressions, :keyword:`async for` "
"and :keyword:`async with` can only be used in the body of a coroutine "
"function."
msgstr ""
"La ejecución de corrutinas de Python se puede suspender y reanudar en muchos "
"puntos (consulte :term:`coroutine`). Las expresiones :keyword:`await`, :"
"keyword:`async for` y :keyword:`async with` solo se pueden utilizar en el "
"cuerpo de una función de corrutina."

#: ../Doc/reference/compound_stmts.rst:1485
msgid ""
"Functions defined with ``async def`` syntax are always coroutine functions, "
"even if they do not contain ``await`` or ``async`` keywords."
msgstr ""
"Las funciones definidas con la sintaxis ``async def`` siempre son funciones "
"de corrutina, incluso si no contienen palabras claves ``await`` o ``async``."

#: ../Doc/reference/compound_stmts.rst:1488
msgid ""
"It is a :exc:`SyntaxError` to use a ``yield from`` expression inside the "
"body of a coroutine function."
msgstr ""
"Es un error del tipo :exc:`SyntaxError` usar una expresión ``yield from`` "
"dentro del cuerpo de una función de corrutina."

#: ../Doc/reference/compound_stmts.rst:1491
msgid "An example of a coroutine function::"
msgstr "Un ejemplo de una función corrutina::"

#: ../Doc/reference/compound_stmts.rst:1497
msgid ""
"``await`` and ``async`` are now keywords; previously they were only treated "
"as such inside the body of a coroutine function."
msgstr ""
"``await`` y ``async`` ahora son palabras clave; anteriormente solo se los "
"trataba como tales dentro del cuerpo de una función de rutina."

#: ../Doc/reference/compound_stmts.rst:1505
msgid "The :keyword:`!async for` statement"
msgstr "La sentencia :keyword:`!async for`"

#: ../Doc/reference/compound_stmts.rst:1510
msgid ""
"An :term:`asynchronous iterable` provides an ``__aiter__`` method that "
"directly returns an :term:`asynchronous iterator`, which can call "
"asynchronous code in its ``__anext__`` method."
msgstr ""
"Un :term:`asynchronous iterable` proporciona un método ``__aiter__`` que "
"retorna directamente un :term:`asynchronous iterator`, que puede llamar a "
"código asincrónico en su método ``__anext__``."

#: ../Doc/reference/compound_stmts.rst:1514
msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous "
"iterables."
msgstr ""
"La sentencia ``async for`` permite una iteración apropiada sobre iteradores "
"asincrónicos."

#: ../Doc/reference/compound_stmts.rst:1524
msgid "Is semantically equivalent to::"
msgstr "Es semánticamente equivalente a::"

#: ../Doc/reference/compound_stmts.rst:1540
msgid ""
"See also :meth:`~object.__aiter__` and :meth:`~object.__anext__` for details."
msgstr ""
"Consulte también :meth:`~object.__aiter__` y :meth:`~object.__anext__` para "
"obtener más detalles."

#: ../Doc/reference/compound_stmts.rst:1542
msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside the "
"body of a coroutine function."
msgstr ""
"Es un error del tipo :exc:`SyntaxError` usar una sentencia ``async for`` "
"fuera del cuerpo de una función de corrutina."

#: ../Doc/reference/compound_stmts.rst:1550
msgid "The :keyword:`!async with` statement"
msgstr "La sentencia :keyword:`!async with`"

#: ../Doc/reference/compound_stmts.rst:1555
msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that is "
"able to suspend execution in its *enter* and *exit* methods."
msgstr ""
"Un :term:`asynchronous context manager` es un :term:`context manager` que "
"puede suspender la ejecución en sus métodos *enter* y *exit*."

#: ../Doc/reference/compound_stmts.rst:1582
msgid ""
"See also :meth:`~object.__aenter__` and :meth:`~object.__aexit__` for "
"details."
msgstr ""
"Consulte también :meth:`~object.__aenter__` y :meth:`~object.__aexit__` para "
"obtener más detalles."

#: ../Doc/reference/compound_stmts.rst:1584
msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside the "
"body of a coroutine function."
msgstr ""
"Es un error del tipo :exc:`SyntaxError` usar una sentencia ``async with`` "
"fuera del cuerpo de una función de corrutina."

#: ../Doc/reference/compound_stmts.rst:1590
msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` - Corrutinas con sintaxis ``async`` y ``await``"

#: ../Doc/reference/compound_stmts.rst:1590
msgid ""
"The proposal that made coroutines a proper standalone concept in Python, and "
"added supporting syntax."
msgstr ""
"La propuesta que convirtió a las corrutinas en un concepto independiente "
"adecuado en Python, y agregó una sintaxis de soporte."

#: ../Doc/reference/compound_stmts.rst:1595
msgid "Footnotes"
msgstr "Notas al pie"

#: ../Doc/reference/compound_stmts.rst:1596
msgid ""
"The exception is propagated to the invocation stack unless there is a :"
"keyword:`finally` clause which happens to raise another exception. That new "
"exception causes the old one to be lost."
msgstr ""
"La excepción se propaga a la pila de invocación a menos que haya una "
"cláusula :keyword:`finally` que provoque otra excepción. Esa nueva excepción "
"hace que se pierda la anterior."

#: ../Doc/reference/compound_stmts.rst:1600
msgid "In pattern matching, a sequence is defined as one of the following:"
msgstr ""
"En la coincidencia de patrones, una secuencia se define como una de las "
"siguientes:"

#: ../Doc/reference/compound_stmts.rst:1602
msgid "a class that inherits from :class:`collections.abc.Sequence`"
msgstr "una clase que hereda de :class:`collections.abc.Sequence`"

#: ../Doc/reference/compound_stmts.rst:1603
msgid ""
"a Python class that has been registered as :class:`collections.abc.Sequence`"
msgstr ""
"una clase de Python que se ha registrado como :class:`collections.abc."
"Sequence`"

#: ../Doc/reference/compound_stmts.rst:1604
msgid ""
"a builtin class that has its (CPython) :data:`Py_TPFLAGS_SEQUENCE` bit set"
msgstr ""
"una clase incorporada que tiene su conjunto de bits (CPython) :data:"
"`Py_TPFLAGS_SEQUENCE`"

#: ../Doc/reference/compound_stmts.rst:1605
#: ../Doc/reference/compound_stmts.rst:1624
msgid "a class that inherits from any of the above"
msgstr "una clase que hereda de cualquiera de los anteriores"

#: ../Doc/reference/compound_stmts.rst:1607
msgid "The following standard library classes are sequences:"
msgstr "Las siguientes clases de biblioteca estándar son secuencias:"

#: ../Doc/reference/compound_stmts.rst:1609
msgid ":class:`array.array`"
msgstr ":class:`array.array`"

#: ../Doc/reference/compound_stmts.rst:1610
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: ../Doc/reference/compound_stmts.rst:1612
msgid ":class:`memoryview`"
msgstr ":class:`memoryview`"

#: ../Doc/reference/compound_stmts.rst:1613
msgid ":class:`range`"
msgstr ":class:`range`"

#: ../Doc/reference/compound_stmts.rst:1616
msgid ""
"Subject values of type ``str``, ``bytes``, and ``bytearray`` do not match "
"sequence patterns."
msgstr ""
"Los valores de sujeto de tipo ``str``, ``bytes`` y ``bytearray`` no "
"coinciden con los patrones de secuencia."

#: ../Doc/reference/compound_stmts.rst:1619
msgid "In pattern matching, a mapping is defined as one of the following:"
msgstr ""
"En la coincidencia de patrones, un mapeo se define como uno de los "
"siguientes:"

#: ../Doc/reference/compound_stmts.rst:1621
msgid "a class that inherits from :class:`collections.abc.Mapping`"
msgstr "una clase que hereda de :class:`collections.abc.Mapping`"

#: ../Doc/reference/compound_stmts.rst:1622
msgid ""
"a Python class that has been registered as :class:`collections.abc.Mapping`"
msgstr ""
"una clase de Python que se ha registrado como :class:`collections.abc."
"Mapping`"

#: ../Doc/reference/compound_stmts.rst:1623
msgid ""
"a builtin class that has its (CPython) :data:`Py_TPFLAGS_MAPPING` bit set"
msgstr ""
"una clase incorporada que tiene su conjunto de bits (CPython) :data:"
"`Py_TPFLAGS_MAPPING`"

#: ../Doc/reference/compound_stmts.rst:1626
msgid ""
"The standard library classes :class:`dict` and :class:`types."
"MappingProxyType` are mappings."
msgstr ""
"Las clases de biblioteca estándar :class:`dict` y :class:`types."
"MappingProxyType` son asignaciones."

#: ../Doc/reference/compound_stmts.rst:1629
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's ``__doc__`` attribute and therefore the "
"function's :term:`docstring`."
msgstr ""
"Una cadena de caracteres literal que aparece como la primera sentencia en el "
"cuerpo de la función se transforma en el atributo ``__doc__`` de la función "
"y, por lo tanto, en funciones :term:`docstring`."

#: ../Doc/reference/compound_stmts.rst:1633
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's ``__doc__`` item and therefore the class's :"
"term:`docstring`."
msgstr ""
"Una cadena de caracteres literal que aparece como la primera sentencia en el "
"cuerpo de la clase se transforma en el elemento del espacio de nombre "
"``__doc__`` y, por lo tanto, de la clase :term:`docstring`."
