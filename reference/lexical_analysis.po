# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-05 12:54+0200\n"
"PO-Revision-Date: 2020-08-15 20:43+0200\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: Miguel Hernandez <jose.miguel.heca@gmail.com>\n"
"Language: es\n"
"X-Generator: Poedit 2.4\n"

#: ../Doc/reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr "Análisis léxico"

#: ../Doc/reference/lexical_analysis.rst:10
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr ""
"Un programa de Python es leído por un *parser* (analizador sintáctico).  Los "
"datos introducidos en el analizador son un flujo de *tokens*, generados por "
"el *analizador léxico*.  Este capítulo describe cómo el analizador léxico "
"desglosa un archivo en tokens."

#: ../Doc/reference/lexical_analysis.rst:14
msgid ""
"Python reads program text as Unicode code points; the encoding of a source "
"file can be given by an encoding declaration and defaults to UTF-8, see :pep:"
"`3120` for details.  If the source file cannot be decoded, a :exc:"
"`SyntaxError` is raised."
msgstr ""
"Python lee el texto del programa como puntos de código Unicode; la "
"codificación de un archivo fuente puede ser dada por una declaración de "
"codificación y por defecto es UTF-8, ver :pep:`3120` para más detalles.  Si "
"el archivo fuente no puede ser decodificado, se genera un :exc:`SyntaxError`."

#: ../Doc/reference/lexical_analysis.rst:23
msgid "Line structure"
msgstr "Estructura de línea"

#: ../Doc/reference/lexical_analysis.rst:27
msgid "A Python program is divided into a number of *logical lines*."
msgstr "Un programa Python se divide en un número de *líneas lógicas*."

#: ../Doc/reference/lexical_analysis.rst:33
msgid "Logical lines"
msgstr "Líneas lógicas"

#: ../Doc/reference/lexical_analysis.rst:37
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr ""
"El final de una línea lógica está representado por el token NEWLINE (nueva "
"línea).  Las declaraciones no pueden cruzar los límites de la línea lógica, "
"excepto cuando la sintaxis permite la utilización de NEWLINE (por ejemplo, "
"entre declaraciones en declaraciones compuestas). Una línea lógica se "
"construye a partir de una o más *líneas físicas* siguiendo las reglas "
"explícitas o implícitas de *unión de líneas*."

#: ../Doc/reference/lexical_analysis.rst:47
msgid "Physical lines"
msgstr "Líneas físicas"

#: ../Doc/reference/lexical_analysis.rst:49
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files and strings, any of the standard platform line "
"termination sequences can be used - the Unix form using ASCII LF (linefeed), "
"the Windows form using the ASCII sequence CR LF (return followed by "
"linefeed), or the old Macintosh form using the ASCII CR (return) character.  "
"All of these forms can be used equally, regardless of platform. The end of "
"input also serves as an implicit terminator for the final physical line."
msgstr ""
"Una línea física es una secuencia de caracteres terminada por una secuencia "
"de final de línea.  En los archivos fuente y las cadenas, se puede utilizar "
"cualquiera de las secuencias de terminación de línea de la plataforma "
"estándar: el formulario Unix que utiliza ASCII LF (salto de línea, por el "
"inglés *linefeed*), el formulario Windows que utiliza la secuencia ASCII CR "
"LF (retorno seguido de salto de línea), o el antiguo formulario Macintosh "
"que utiliza el carácter ASCII CR (retorno).  Todas estas formas pueden ser "
"utilizadas por igual, independientemente de la plataforma. El final de la "
"introducción de datos también sirve como un terminador implícito para la "
"línea física final."

#: ../Doc/reference/lexical_analysis.rst:57
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr ""
"Al incrustar Python, las cadenas de código fuente deben ser pasadas a las "
"APIs de Python usando las convenciones estándar de C para los caracteres de "
"nueva línea (el carácter ``\\n``, que representa ASCII LF, es el terminador "
"de línea)."

#: ../Doc/reference/lexical_analysis.rst:65
msgid "Comments"
msgstr "Comentarios"

#: ../Doc/reference/lexical_analysis.rst:70
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax."
msgstr ""
"Un comentario comienza con un carácter de almohadilla (``#``) que no es "
"parte de un literal de cadena, y termina al final de la línea física.  Un "
"comentario implica el final de la línea lógica, a menos que se invoque la "
"regla implícita de unión de líneas. Los comentarios son ignorados por la "
"sintaxis."

#: ../Doc/reference/lexical_analysis.rst:79
msgid "Encoding declarations"
msgstr "Declaración de Codificación"

#: ../Doc/reference/lexical_analysis.rst:84
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""
"Si un comentario en la primera o segunda línea del script de Python coincide "
"con la expresión regular ``coding[=:]\\s*([-\\w.]+)``, este comentario se "
"procesa como una declaración de codificación; el primer grupo de esta "
"expresión denomina la codificación del archivo de código fuente. La "
"declaración de codificación debe aparecer en una línea propia. Si se trata "
"de la segunda línea, la primera línea debe ser también una línea solamente "
"de comentario. Las formas recomendadas de una expresión de codificación "
"son ::"

#: ../Doc/reference/lexical_analysis.rst:93
msgid "which is recognized also by GNU Emacs, and ::"
msgstr "que también es reconocido por GNU Emacs y ::"

#: ../Doc/reference/lexical_analysis.rst:97
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr "que es reconocido por el VIM de Bram Moolenaar."

#: ../Doc/reference/lexical_analysis.rst:99
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  In "
"addition, if the first bytes of the file are the UTF-8 byte-order mark "
"(``b'\\xef\\xbb\\xbf'``), the declared file encoding is UTF-8 (this is "
"supported, among others, by Microsoft's :program:`notepad`)."
msgstr ""
"Si no se encuentra una declaración de codificación, la codificación por "
"defecto es UTF-8.  Además, si los primeros bytes del archivo son la marca de "
"orden de bytes UTF-8 (``b'\\xef\\xbb\\xbf'``), la codificación declarada del "
"archivo es UTF-8 (esto está soportado, entre otros, por el programa :program:"
"`notepad` de Microsoft)."

#: ../Doc/reference/lexical_analysis.rst:104
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python. "
"The encoding is used for all lexical analysis, including string literals, "
"comments and identifiers."
msgstr ""
"Si se declara una codificación, el nombre de la codificación debe ser "
"reconocido por Python. La codificación se utiliza para todos los análisis "
"léxicos, incluidos los literales de cadena, los comentarios y los "
"identificadores."

#: ../Doc/reference/lexical_analysis.rst:114
msgid "Explicit line joining"
msgstr "Unión explícita de líneas"

#: ../Doc/reference/lexical_analysis.rst:118
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""
"Dos o más líneas físicas pueden unirse en líneas lógicas utilizando "
"caracteres de barra invertida (``\\``), de la siguiente manera: cuando una "
"línea física termina en una barra invertida que no es parte de literal de "
"cadena o de un comentario, se une con la siguiente formando una sola línea "
"lógica, borrando la barra invertida y el siguiente carácter de fin de "
"línea.  Por ejemplo::"

#: ../Doc/reference/lexical_analysis.rst:129
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string "
"literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""
"Una línea que termina en una barra invertida no puede llevar un comentario.  "
"Una barra invertida no continúa un comentario.  Una barra invertida no "
"continúa un token excepto para los literales de la cadena (es decir, los "
"tokens que no sean literales de la cadena no pueden ser divididos a través "
"de líneas físicas usando una barra invertida).  La barra invertida es ilegal "
"en cualquier parte de una línea fuera del literal de la cadena."

#: ../Doc/reference/lexical_analysis.rst:139
msgid "Implicit line joining"
msgstr "Unión implícita de líneas"

#: ../Doc/reference/lexical_analysis.rst:141
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""
"Las expresiones entre paréntesis, entre corchetes o entre rizos pueden "
"dividirse en más de una línea física sin usar barras invertidas. Por "
"ejemplo::"

#: ../Doc/reference/lexical_analysis.rst:149
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""
"Las líneas continuas implícitas pueden llevar comentarios.  La sangría de "
"las líneas de continuación no es importante.  Se permiten líneas de "
"continuación en blanco. No hay ningún token NEWLINE (nueva línea) entre las "
"líneas de continuación implícitas.  Las líneas de continuación implícitas "
"también pueden aparecer dentro de cadenas de triple comilla ( ver más "
"adelante); en ese caso no pueden llevar comentarios."

#: ../Doc/reference/lexical_analysis.rst:159
msgid "Blank lines"
msgstr "Líneas en blanco"

#: ../Doc/reference/lexical_analysis.rst:163
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard interactive interpreter, an entirely blank logical line (i.e. one "
"containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""
"Una línea lógica que contiene sólo espacios, tabulaciones, saltos de página "
"y posiblemente un comentario, es ignorada (es decir, no se genera un símbolo "
"de NEWLINE).  Durante la introducción interactiva de declaraciones, el "
"manejo de una línea en blanco puede variar dependiendo de la implementación "
"del bucle de *read-eval-print* (lectura-evaluación-impresión).  En el "
"intérprete interactivo estándar, una línea lógica completamente en blanco "
"(es decir, una que no contiene ni siquiera un espacio en blanco o un "
"comentario) termina una declaración de varias líneas."

#: ../Doc/reference/lexical_analysis.rst:174
msgid "Indentation"
msgstr "Sangría"

#: ../Doc/reference/lexical_analysis.rst:178
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr ""
"El espacio en blanco ( espacios y tabulaciones) al principio de una línea "
"lógica se utiliza para calcular el nivel de sangría de la línea, que a su "
"vez se utiliza para determinar la agrupación de las declaraciones."

#: ../Doc/reference/lexical_analysis.rst:182
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that the "
"total number of characters up to and including the replacement is a multiple "
"of eight (this is intended to be the same rule as used by Unix).  The total "
"number of spaces preceding the first non-blank character then determines the "
"line's indentation.  Indentation cannot be split over multiple physical "
"lines using backslashes; the whitespace up to the first backslash determines "
"the indentation."
msgstr ""
"Los tabuladores se sustituyen (de izquierda a derecha) por uno a ocho "
"espacios, de manera que el número total de caracteres hasta el reemplazo "
"inclusive es un múltiplo de ocho (se pretende que sea la misma regla que la "
"utilizada por Unix).  El número total de espacios que preceden al primer "
"carácter no en blanco determina entonces la sangría de la línea.  La sangría "
"no puede dividirse en múltiples líneas físicas utilizando barras invertidas; "
"el espacio en blanco hasta la primera barra invertida determina la sangría."

#: ../Doc/reference/lexical_analysis.rst:190
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in "
"spaces; a :exc:`TabError` is raised in that case."
msgstr ""
"La indentación se rechaza como inconsistente si un archivo fuente mezcla "
"tabulaciones y espacios de manera que el significado depende del valor de "
"una tabulación en los espacios; un :exc:`TabError` se produce en ese caso."

#: ../Doc/reference/lexical_analysis.rst:194
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors "
"on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for "
"the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""
"**Nota de compatibilidad entre plataformas:** debido a la naturaleza de los "
"editores de texto en plataformas que no sean UNIX, no es aconsejable "
"utilizar una mezcla de espacios y tabuladores para la sangría en un solo "
"archivo de origen.  También debe tenerse en cuenta que las diferentes "
"plataformas pueden limitar explícitamente el nivel máximo de sangría."

#: ../Doc/reference/lexical_analysis.rst:199
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""
"Un carácter *formfeed* puede estar presente al comienzo de la línea; será "
"ignorado para los cálculos de sangría anteriores.  Los caracteres *formfeed* "
"que aparecen en otras partes del espacio en blanco inicial tienen un efecto "
"indefinido (por ejemplo, pueden poner a cero el recuento de espacio)."

#: ../Doc/reference/lexical_analysis.rst:206
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr ""
"Los niveles de sangría de las líneas consecutivas se utilizan para generar "
"tokens INDENT y DEDENT, utilizando una pila, de la siguiente manera."

#: ../Doc/reference/lexical_analysis.rst:209
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack "
"will always be strictly increasing from bottom to top.  At the beginning of "
"each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on "
"the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr ""
"Antes de que se lea la primera línea del archivo, se empuja un solo cero en "
"la pila; esto no volverá a saltar.  Los números empujados en la pila siempre "
"irán aumentando estrictamente de abajo hacia arriba.  Al principio de cada "
"línea lógica, el nivel de sangría de la línea se compara con la parte "
"superior de la pila. Si es igual, no pasa nada. Si es mayor, se empuja en la "
"pila, y se genera un token INDENT.  Si es más pequeño, *debe* ser uno de los "
"números de la pila; todos los números de la pila que son más grandes se "
"sacan, y por cada número sacado se genera un token DEDENT.  Al final del "
"archivo, se genera un token DEDENT por cada número restante de la pila que "
"sea mayor que cero."

#: ../Doc/reference/lexical_analysis.rst:220
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr ""
"Aquí hay un ejemplo de un código de Python con una correcta (aunque no tan "
"clara) sangría::"

#: ../Doc/reference/lexical_analysis.rst:235
msgid "The following example shows various indentation errors::"
msgstr "El siguiente ejemplo muestra varios errores de sangría::"

#: ../Doc/reference/lexical_analysis.rst:245
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""
"(En realidad, los tres primeros errores son detectados por el analizador; "
"sólo el último error es encontrado por el analizador léxico --- la sangría "
"de ``return r`` no coincide con un nivel sacado de la pila.)"

#: ../Doc/reference/lexical_analysis.rst:253
msgid "Whitespace between tokens"
msgstr "Espacios en blanco entre tokens"

#: ../Doc/reference/lexical_analysis.rst:255
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to "
"separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr ""
"A excepción del comienzo de una línea lógica o en los literales de cadenas, "
"los caracteres de espacio en blanco, tabulación y formfeed pueden utilizarse "
"indistintamente para separar tokens.  Los espacios en blanco se necesitan "
"entre dos tokens sólo si su concatenación podría interpretarse de otra "
"manera como un token diferente (por ejemplo, ab es un token, pero a b "
"corresponde a dos tokens)."

#: ../Doc/reference/lexical_analysis.rst:265
msgid "Other tokens"
msgstr "Otros tokens"

#: ../Doc/reference/lexical_analysis.rst:267
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. "
"Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr ""
"Además de NEWLINE, INDENT y DEDENT, existen las siguientes categorías de "
"fichas: *identifiers* (identificadores), *keywords* (palabras clave), "
"*literals* (literales), *operators* (operadores) y *delimiters* "
"(delimitadores). Los caracteres de espacio en blanco (distintos de los "
"terminadores de línea, discutidos anteriormente) no son tokens, pero sirven "
"para delimitarlos. En los casos en que exista ambigüedad, un token comprende "
"la cadena más larga posible que forma un token legal cuando se lee de "
"izquierda a derecha."

#: ../Doc/reference/lexical_analysis.rst:277
msgid "Identifiers and keywords"
msgstr "Identificadores y palabras clave"

#: ../Doc/reference/lexical_analysis.rst:281
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions."
msgstr ""
"Los identificadores (también denominados *nombres*) se describen mediante "
"las siguientes definiciones léxicas."

#: ../Doc/reference/lexical_analysis.rst:284
msgid ""
"The syntax of identifiers in Python is based on the Unicode standard annex "
"UAX-31, with elaboration and changes as defined below; see also :pep:`3131` "
"for further details."
msgstr ""
"La sintaxis de los identificadores en Python se basa en el anexo estándar de "
"Unicode UAX-31, con la elaboración y los cambios que se definen a "
"continuación; ver también :pep:`3131` para más detalles."

#: ../Doc/reference/lexical_analysis.rst:288
msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for "
"identifiers are the same as in Python 2.x: the uppercase and lowercase "
"letters ``A`` through ``Z``, the underscore ``_`` and, except for the first "
"character, the digits ``0`` through ``9``."
msgstr ""
"Dentro del rango ASCII (U+0001..U+007F), los caracteres válidos para los "
"identificadores son los mismos que en Python 2.x: las letras mayúsculas y "
"minúsculas ``A`` hasta ``Z``, el guión bajo ``_`` y los dígitos ``0`` hasta "
"``9``, salvo el primer carácter."

#: ../Doc/reference/lexical_analysis.rst:293
msgid ""
"Python 3.0 introduces additional characters from outside the ASCII range "
"(see :pep:`3131`).  For these characters, the classification uses the "
"version of the Unicode Character Database as included in the :mod:"
"`unicodedata` module."
msgstr ""
"Python 3.0 introduce caracteres adicionales fuera del rango ASCII (ver :pep:"
"`3131`).  Para estos caracteres, la clasificación utiliza la versión de la "
"base de datos de caracteres Unicode incluida en el módulo :mod:`unicodedata`."

#: ../Doc/reference/lexical_analysis.rst:297
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr ""
"Los identificadores son de extensión ilimitada.  Las mayúsculas y minúsculas "
"son significativas."

#: ../Doc/reference/lexical_analysis.rst:306
msgid "The Unicode category codes mentioned above stand for:"
msgstr ""
"Los códigos de la categoría Unicode mencionados anteriormente representan:"

#: ../Doc/reference/lexical_analysis.rst:308
msgid "*Lu* - uppercase letters"
msgstr "*Lu* - letras mayúsculas"

#: ../Doc/reference/lexical_analysis.rst:309
msgid "*Ll* - lowercase letters"
msgstr "*Ll* - letras minúsculas"

#: ../Doc/reference/lexical_analysis.rst:310
msgid "*Lt* - titlecase letters"
msgstr "*Lt* - letras de *titlecase*"

#: ../Doc/reference/lexical_analysis.rst:311
msgid "*Lm* - modifier letters"
msgstr "*Lm* - letras modificadoras"

#: ../Doc/reference/lexical_analysis.rst:312
msgid "*Lo* - other letters"
msgstr "*Lo* - otras letras"

#: ../Doc/reference/lexical_analysis.rst:313
msgid "*Nl* - letter numbers"
msgstr "*Nl* - números de letra"

#: ../Doc/reference/lexical_analysis.rst:314
msgid "*Mn* - nonspacing marks"
msgstr "*Mn* - marcas sin separación"

#: ../Doc/reference/lexical_analysis.rst:315
msgid "*Mc* - spacing combining marks"
msgstr "*Mc* - marcas de combinación de separación"

#: ../Doc/reference/lexical_analysis.rst:316
msgid "*Nd* - decimal numbers"
msgstr "*Nd* - números decimales"

#: ../Doc/reference/lexical_analysis.rst:317
msgid "*Pc* - connector punctuations"
msgstr "*Pc* - puntuaciones conectoras"

#: ../Doc/reference/lexical_analysis.rst:318
msgid ""
"*Other_ID_Start* - explicit list of characters in `PropList.txt <http://www."
"unicode.org/Public/12.1.0/ucd/PropList.txt>`_ to support backwards "
"compatibility"
msgstr ""
"*Other_ID_Start* - lista explícita de caracteres en `PropList.txt <http://"
"www.unicode.org/Public/12.1.0/ucd/PropList.txt>`_ para apoyar la "
"compatibilidad hacia atrás"

#: ../Doc/reference/lexical_analysis.rst:321
msgid "*Other_ID_Continue* - likewise"
msgstr "*Other_ID_Continue* - Así mismo"

#: ../Doc/reference/lexical_analysis.rst:323
msgid ""
"All identifiers are converted into the normal form NFKC while parsing; "
"comparison of identifiers is based on NFKC."
msgstr ""
"Todos los identificadores se convierten en la forma normal NFKC mientras se "
"analizan; la comparación de los identificadores se basa en NFKC."

#: ../Doc/reference/lexical_analysis.rst:326
msgid ""
"A non-normative HTML file listing all valid identifier characters for "
"Unicode 4.1 can be found at https://www.dcl.hpi.uni-potsdam.de/home/loewis/"
"table-3131.html."
msgstr ""
"En https://www.dcl.hpi.uni-potsdam.de/home/loewis/table-3131.html se puede "
"encontrar un archivo HTML no normativo que enumera todos los caracteres de "
"identificación válidos para Unicode 4.1."

#: ../Doc/reference/lexical_analysis.rst:334
msgid "Keywords"
msgstr "Palabras clave"

#: ../Doc/reference/lexical_analysis.rst:340
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr ""
"Los siguientes identificadores se utilizan como palabras reservadas, o "
"*palabras clave* del idioma, y no pueden utilizarse como identificadores "
"ordinarios.  Deben escribirse exactamente como están escritas aquí:"

#: ../Doc/reference/lexical_analysis.rst:360
msgid "Reserved classes of identifiers"
msgstr "Clases reservadas de identificadores"

#: ../Doc/reference/lexical_analysis.rst:362
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""
"Ciertas clases de identificadores (además de las palabras clave) tienen "
"significados especiales.  Estas clases se identifican por los patrones de "
"los caracteres de guión bajo que van delante y detrás:"

#: ../Doc/reference/lexical_analysis.rst:376
msgid "``_*``"
msgstr "``_*``"

#: ../Doc/reference/lexical_analysis.rst:367
msgid ""
"Not imported by ``from module import *``.  The special identifier ``_`` is "
"used in the interactive interpreter to store the result of the last "
"evaluation; it is stored in the :mod:`builtins` module.  When not in "
"interactive mode, ``_`` has no special meaning and is not defined. See "
"section :ref:`import`."
msgstr ""
"No importado por ``from module import *``.  El identificador especial ``_`` "
"se utiliza en el intérprete interactivo para almacenar el resultado de la "
"última evaluación; se almacena en el módulo :mod:`builtins`.  Cuando no está "
"en modo interactivo, ``_`` no tiene un significado especial y no está "
"definido. Ver la sección :ref:`import`."

#: ../Doc/reference/lexical_analysis.rst:374
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer "
"to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr ""
"El nombre ``_`` se usa a menudo en conjunción con la internacionalización; "
"consultar la documentación del módulo :mod:`gettext`` para más información "
"sobre esta convención."

#: ../Doc/reference/lexical_analysis.rst:384
msgid "``__*__``"
msgstr "``__*__``"

#: ../Doc/reference/lexical_analysis.rst:379
msgid ""
"System-defined names, informally known as \"dunder\" names. These names are "
"defined by the interpreter and its implementation (including the standard "
"library). Current system names are discussed in the :ref:`specialnames` "
"section and elsewhere. More will likely be defined in future versions of "
"Python.  *Any* use of ``__*__`` names, in any context, that does not follow "
"explicitly documented use, is subject to breakage without warning."
msgstr ""
"Nombres definidos por el sistema, conocidos informalmente como nombres "
"\"*dunder*\". Estos nombres son definidos por el intérprete y su aplicación "
"(incluida la biblioteca estándar). Los nombres actuales del sistema se "
"discuten en la sección :ref:`specialnames` y en otros lugares. Es probable "
"que se definan más en futuras versiones de Python.  *Cualquier* uso de "
"nombres ``__*__``, en cualquier contexto, que no siga un uso explícitamente "
"documentado, está sujeto a que se rompa sin previo aviso."

#: ../Doc/reference/lexical_analysis.rst:391
msgid "``__*``"
msgstr "``__*``"

#: ../Doc/reference/lexical_analysis.rst:387
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See "
"section :ref:`atom-identifiers`."
msgstr ""
"Nombres de clase privada.  Los nombres de esta categoría, cuando se utilizan "
"en el contexto de una definición de clase, se reescriben para utilizar una "
"forma desfigurada que ayude a evitar conflictos de nombres entre los "
"atributos \"privados\" de las clases base y derivadas. Ver la sección :ref:"
"`atom-identifiers`."

#: ../Doc/reference/lexical_analysis.rst:396
msgid "Literals"
msgstr "Literales"

#: ../Doc/reference/lexical_analysis.rst:400
msgid "Literals are notations for constant values of some built-in types."
msgstr ""
"Los literales son notaciones para los valores constantes de algunos tipos "
"incorporados."

#: ../Doc/reference/lexical_analysis.rst:411
msgid "String and Bytes literals"
msgstr "Literales de cadenas y bytes"

#: ../Doc/reference/lexical_analysis.rst:413
msgid "String literals are described by the following lexical definitions:"
msgstr ""
"Los literales de cadena se describen mediante las siguientes definiciones "
"léxicas:"

#: ../Doc/reference/lexical_analysis.rst:438
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`stringprefix` or :token:"
"`bytesprefix` and the rest of the literal. The source character set is "
"defined by the encoding declaration; it is UTF-8 if no encoding declaration "
"is given in the source file; see section :ref:`encodings`."
msgstr ""
"Una restricción sintáctica que no se indica en estas producciones es que no "
"se permiten espacios en blanco entre el :token:`stringprefix` o :token:"
"`bytesprefix` y el resto del literal. El conjunto de caracteres fuente está "
"definido por la declaración de codificación; es UTF-8 si no se da una "
"declaración de codificación en el archivo fuente; ver la sección :ref:"
"`encodings`."

#: ../Doc/reference/lexical_analysis.rst:448
msgid ""
"In plain English: Both types of literals can be enclosed in matching single "
"quotes (``'``) or double quotes (``\"``).  They can also be enclosed in "
"matching groups of three single or double quotes (these are generally "
"referred to as *triple-quoted strings*).  The backslash (``\\``) character "
"is used to escape characters that otherwise have a special meaning, such as "
"newline, backslash itself, or the quote character."
msgstr ""
"En lenguaje claro y sencillo: ambos tipos de literales pueden ser encerrados "
"entre comillas simples (``'``) o dobles (``\"``).  También pueden estar "
"encerrados en grupos de tres comillas simples o dobles (a las que "
"generalmente se les llama *cadenas de tres comillas*).  El carácter de la "
"barra inversa (``\\``) se utiliza para escapar de los caracteres que de otra "
"manera tienen un significado especial, como la línea nueva, la barra inversa "
"en sí misma, o el carácter de comillas."

#: ../Doc/reference/lexical_analysis.rst:459
msgid ""
"Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an "
"instance of the :class:`bytes` type instead of the :class:`str` type.  They "
"may only contain ASCII characters; bytes with a numeric value of 128 or "
"greater must be expressed with escapes."
msgstr ""
"Los literales de bytes siempre se prefijan con ``'b'`` o ``'B'``; producen "
"una instancia del tipo :class:`bytes` en lugar del tipo :class:`str`.  Sólo "
"pueden contener caracteres ASCII; los bytes con un valor numérico de 128 o "
"mayor deben ser expresados con escapes."

#: ../Doc/reference/lexical_analysis.rst:468
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat "
"backslashes as literal characters.  As a result, in string literals, "
"``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated specially. "
"Given that Python 2.x's raw unicode literals behave differently than Python "
"3.x's the ``'ur'`` syntax is not supported."
msgstr ""
"Tanto los literales de cadena como de bytes pueden ser prefijados con una "
"letra ``'r'`` o ``'R'``; tales cadenas se llaman :dfn:`raw strings` y "
"consideran las barras inversas como caracteres literales.  Como resultado, "
"en las cadenas literales, los escapes de ``'\\U'`` y ``'\\u'`` en las "
"cadenas sin procesar no son tratados de manera especial. Dado que los "
"literales *raw* de unicode de Python 2.x se comportan de manera diferente a "
"los de Python 3.x, la sintaxis de ``'ur'`` no está soportada."

#: ../Doc/reference/lexical_analysis.rst:475
msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr ""
"El prefijo ``'rb'`` de literales de bytes raw se ha añadido como sinónimo de "
"``'br'``."

#: ../Doc/reference/lexical_analysis.rst:479
msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to "
"simplify the maintenance of dual Python 2.x and 3.x codebases. See :pep:"
"`414` for more information."
msgstr ""
"Se reintrodujo el soporte para el legado unicode literal (``u'value'``) para "
"simplificar el mantenimiento de las bases de código dual Python 2.x y 3.x. "
"Ver :pep:`414` para más información."

#: ../Doc/reference/lexical_analysis.rst:488
msgid ""
"A string literal with ``'f'`` or ``'F'`` in its prefix is a :dfn:`formatted "
"string literal`; see :ref:`f-strings`.  The ``'f'`` may be combined with "
"``'r'``, but not with ``'b'`` or ``'u'``, therefore raw formatted strings "
"are possible, but formatted bytes literals are not."
msgstr ""
"Un literal de cadena con ``'f'`` o ``'F'`` en su prefijo es un :dfn:"
"`formatted string literal`; ver :ref:`f-strings`.  La ``'f'`` puede "
"combinarse con la ``'r'``, pero no con la ``'b'`` o ``'u'``, por lo que las "
"cadenas *raw* formateadas son posibles, pero los literales de bytes "
"formateados no lo son."

#: ../Doc/reference/lexical_analysis.rst:493
msgid ""
"In triple-quoted literals, unescaped newlines and quotes are allowed (and "
"are retained), except that three unescaped quotes in a row terminate the "
"literal.  (A \"quote\" is the character used to open the literal, i.e. "
"either ``'`` or ``\"``.)"
msgstr ""
"En los literales de triple cita, se permiten (y se retienen) nuevas líneas y "
"citas no escapadas, excepto cuando tres citas no escapadas seguidas "
"finalizan el literal.  (Una \"cita\" es el carácter utilizado para abrir el "
"literal, es decir, ya sea ``'`` o ``\"``.)"

#: ../Doc/reference/lexical_analysis.rst:512
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in string "
"and bytes literals are interpreted according to rules similar to those used "
"by Standard C.  The recognized escape sequences are:"
msgstr ""
"A menos que un prefijo ``'r'`` o ``'R'`` esté presente, las secuencias de "
"escape en literales de cadena y bytes se interpretan según reglas similares "
"a las usadas por C estándar. Las secuencias de escape reconocidas son:"

#: ../Doc/reference/lexical_analysis.rst:517
#: ../Doc/reference/lexical_analysis.rst:550
msgid "Escape Sequence"
msgstr "Secuencia de escape"

#: ../Doc/reference/lexical_analysis.rst:517
#: ../Doc/reference/lexical_analysis.rst:550
msgid "Meaning"
msgstr "Significado"

#: ../Doc/reference/lexical_analysis.rst:517
#: ../Doc/reference/lexical_analysis.rst:550
msgid "Notes"
msgstr "Notas"

#: ../Doc/reference/lexical_analysis.rst:519
msgid "``\\newline``"
msgstr "``\\newline``"

#: ../Doc/reference/lexical_analysis.rst:519
msgid "Backslash and newline ignored"
msgstr "Barra inversa y línea nueva ignoradas"

#: ../Doc/reference/lexical_analysis.rst:521
msgid "``\\\\``"
msgstr "``\\\\``"

#: ../Doc/reference/lexical_analysis.rst:521
msgid "Backslash (``\\``)"
msgstr "Barra inversa (``\\``)"

#: ../Doc/reference/lexical_analysis.rst:523
msgid "``\\'``"
msgstr "``\\'``"

#: ../Doc/reference/lexical_analysis.rst:523
msgid "Single quote (``'``)"
msgstr "Comilla simple (``'``)"

#: ../Doc/reference/lexical_analysis.rst:525
msgid "``\\\"``"
msgstr "``\\\"``"

#: ../Doc/reference/lexical_analysis.rst:525
msgid "Double quote (``\"``)"
msgstr "Comilla doble (``\"``)"

#: ../Doc/reference/lexical_analysis.rst:527
msgid "``\\a``"
msgstr "``\\a``"

#: ../Doc/reference/lexical_analysis.rst:527
msgid "ASCII Bell (BEL)"
msgstr "ASCII Bell (BEL)"

#: ../Doc/reference/lexical_analysis.rst:529
msgid "``\\b``"
msgstr "``\\b``"

#: ../Doc/reference/lexical_analysis.rst:529
msgid "ASCII Backspace (BS)"
msgstr "ASCII Retroceso (BS)"

#: ../Doc/reference/lexical_analysis.rst:531
msgid "``\\f``"
msgstr "``\\f``"

#: ../Doc/reference/lexical_analysis.rst:531
msgid "ASCII Formfeed (FF)"
msgstr "ASCII Formfeed (FF)"

#: ../Doc/reference/lexical_analysis.rst:533
msgid "``\\n``"
msgstr "``\\n``"

#: ../Doc/reference/lexical_analysis.rst:533
msgid "ASCII Linefeed (LF)"
msgstr "ASCII Linefeed (LF)"

#: ../Doc/reference/lexical_analysis.rst:535
msgid "``\\r``"
msgstr "``\\r``"

#: ../Doc/reference/lexical_analysis.rst:535
msgid "ASCII Carriage Return (CR)"
msgstr "ASCII Retorno de carro (CR)"

#: ../Doc/reference/lexical_analysis.rst:537
msgid "``\\t``"
msgstr "``\\t``"

#: ../Doc/reference/lexical_analysis.rst:537
msgid "ASCII Horizontal Tab (TAB)"
msgstr "ASCII Sangría horizontal (TAB)"

#: ../Doc/reference/lexical_analysis.rst:539
msgid "``\\v``"
msgstr "``\\v``"

#: ../Doc/reference/lexical_analysis.rst:539
msgid "ASCII Vertical Tab (VT)"
msgstr "ASCII Sangría vertical (VT)"

#: ../Doc/reference/lexical_analysis.rst:541
msgid "``\\ooo``"
msgstr "``\\ooo``"

#: ../Doc/reference/lexical_analysis.rst:541
msgid "Character with octal value *ooo*"
msgstr "Carácter con valor octal *ooo*"

#: ../Doc/reference/lexical_analysis.rst:541
msgid "(1,3)"
msgstr "(1,3)"

#: ../Doc/reference/lexical_analysis.rst:544
msgid "``\\xhh``"
msgstr "``\\xhh``"

#: ../Doc/reference/lexical_analysis.rst:544
msgid "Character with hex value *hh*"
msgstr "Carácter con valor hexadecimal *hh*"

#: ../Doc/reference/lexical_analysis.rst:544
msgid "(2,3)"
msgstr "(2,3)"

#: ../Doc/reference/lexical_analysis.rst:547
msgid "Escape sequences only recognized in string literals are:"
msgstr ""
"Las secuencias de escape que sólo se reconocen en los literales de cadena "
"son:"

#: ../Doc/reference/lexical_analysis.rst:552
msgid "``\\N{name}``"
msgstr "``\\N{name}``"

#: ../Doc/reference/lexical_analysis.rst:552
msgid "Character named *name* in the Unicode database"
msgstr "El carácter llamado *name* en la base de datos de Unicode"

#: ../Doc/reference/lexical_analysis.rst:552
msgid "\\(4)"
msgstr "\\(4)"

#: ../Doc/reference/lexical_analysis.rst:555
msgid "``\\uxxxx``"
msgstr "``\\uxxxx``"

#: ../Doc/reference/lexical_analysis.rst:555
msgid "Character with 16-bit hex value *xxxx*"
msgstr "Carácter con valor hexadecimal de 16 bits *xxxx*"

#: ../Doc/reference/lexical_analysis.rst:555
msgid "\\(5)"
msgstr "\\(5)"

#: ../Doc/reference/lexical_analysis.rst:558
msgid "``\\Uxxxxxxxx``"
msgstr "``\\Uxxxxxxxx``"

#: ../Doc/reference/lexical_analysis.rst:558
msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr "Carácter con valor hexadecimal de 32 bits *xxxxxxxx*"

#: ../Doc/reference/lexical_analysis.rst:558
msgid "\\(6)"
msgstr "\\(6)"

#: ../Doc/reference/lexical_analysis.rst:562
msgid "Notes:"
msgstr "Notas:"

#: ../Doc/reference/lexical_analysis.rst:565
msgid "As in Standard C, up to three octal digits are accepted."
msgstr "Como en C estándar, se aceptan hasta tres dígitos octales."

#: ../Doc/reference/lexical_analysis.rst:568
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr ""
"A diferencia de C estándar, se requieren exactamente dos dígitos "
"hexadecimales."

#: ../Doc/reference/lexical_analysis.rst:571
msgid ""
"In a bytes literal, hexadecimal and octal escapes denote the byte with the "
"given value. In a string literal, these escapes denote a Unicode character "
"with the given value."
msgstr ""
"En un literal de bytes, los escapes hexadecimal y octal denotan el byte con "
"el valor dado. En un literal de cadena, estos escapes denotan un carácter "
"Unicode con el valor dado."

#: ../Doc/reference/lexical_analysis.rst:576
msgid "Support for name aliases [#]_ has been added."
msgstr "Se ha añadido el soporte para los alias de nombres [#]_."

#: ../Doc/reference/lexical_analysis.rst:580
msgid "Exactly four hex digits are required."
msgstr "Se requieren exactamente cuatro dígitos hexadecimales."

#: ../Doc/reference/lexical_analysis.rst:583
msgid ""
"Any Unicode character can be encoded this way.  Exactly eight hex digits are "
"required."
msgstr ""
"Cualquier carácter Unicode puede ser codificado de esta manera.  Se "
"requieren exactamente ocho dígitos hexadecimales."

#: ../Doc/reference/lexical_analysis.rst:589
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the result*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences only recognized in string literals fall into the "
"category of unrecognized escapes for bytes literals."
msgstr ""
"A diferencia de C estándar, todas las secuencias de escape no reconocidas se "
"dejan en la cadena sin cambios, es decir, *la barra invertida se deja en el "
"resultado*.  (Este comportamiento es útil para la depuración: si una "
"secuencia de escape se escribe mal, la salida resultante se reconoce más "
"fácilmente como rota).  También es importante señalar que las secuencias de "
"escape sólo reconocidas en los literales de cadena caen en la categoría de "
"escapes no reconocidos para los literales de bytes."

#: ../Doc/reference/lexical_analysis.rst:596
msgid ""
"Unrecognized escape sequences produce a :exc:`DeprecationWarning`.  In a "
"future Python version they will be a :exc:`SyntaxWarning` and eventually a :"
"exc:`SyntaxError`."
msgstr ""
"Las secuencias de escape no reconocidas producen un :exc:"
"`DeprecationWarning`.  En una futura versión de Python serán un :exc:"
"`SyntaxWarning` y eventualmente un :exc:`SyntaxError`."

#: ../Doc/reference/lexical_analysis.rst:601
msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double quote; "
"``r\"\\\"`` is not a valid string literal (even a raw string cannot end in "
"an odd number of backslashes).  Specifically, *a raw literal cannot end in a "
"single backslash* (since the backslash would escape the following quote "
"character).  Note also that a single backslash followed by a newline is "
"interpreted as those two characters as part of the literal, *not* as a line "
"continuation."
msgstr ""
"Incluso en un literal *raw*, las comillas se pueden escapar con una barra "
"inversa, pero la barra inversa permanece en el resultado; por ejemplo, ``r"
"\"\\\"\"`` es un literal de cadena válido que consiste en dos caracteres: "
"una barra inversa y una comilla doble; ``r\"\\\"`` no es un literal de "
"cadena válido (incluso una cadena en bruto no puede terminar en un número "
"impar de barras inversas).  Específicamente, *un literal raw no puede "
"terminar en una sola barra inversa* (ya que la barra inversa se escaparía "
"del siguiente carácter de comillas). Nótese también que una sola barra "
"inversa seguida de una nueva línea se interpreta como esos dos caracteres "
"como parte del literal, *no* como una continuación de línea."

#: ../Doc/reference/lexical_analysis.rst:614
msgid "String literal concatenation"
msgstr "Concatenación de literales de cadena"

#: ../Doc/reference/lexical_analysis.rst:616
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their meaning "
"is the same as their concatenation.  Thus, ``\"hello\" 'world'`` is "
"equivalent to ``\"helloworld\"``.  This feature can be used to reduce the "
"number of backslashes needed, to split long strings conveniently across long "
"lines, or even to add comments to parts of strings, for example::"
msgstr ""
"Se permiten múltiples literales de cadenas o bytes adyacentes (delimitados "
"por espacios en blanco), posiblemente utilizando diferentes convenciones de "
"citas, y su significado es el mismo que su concatenación.  Por lo tanto, ``"
"\"hola\" 'mundo'`` es equivalente a ``\"holamundo\"``.  Esta característica "
"puede ser utilizada para reducir el número de barras inversas necesarias, "
"para dividir largas cadenas convenientemente a través de largas líneas, o "
"incluso para añadir comentarios a partes de las cadenas, por ejemplo::"

#: ../Doc/reference/lexical_analysis.rst:627
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings), and formatted string literals may be concatenated "
"with plain string literals."
msgstr ""
"Téngase en cuenta que esta característica se define a nivel sintáctico, pero "
"se implementa en el momento de la compilación.  El operador '+' debe ser "
"usado para concatenar expresiones de cadena al momento de la ejecución.  "
"Observar también que la concatenación de literales puede utilizar diferentes "
"estilos de citas para cada componente (incluso mezclando cadenas *raw* y "
"cadenas de triple comillado), y los literales de cadena formateados pueden "
"ser concatenados con los literales de cadena simples."

#: ../Doc/reference/lexical_analysis.rst:646
msgid "Formatted string literals"
msgstr "Literales de cadena formateados"

#: ../Doc/reference/lexical_analysis.rst:650
msgid ""
"A :dfn:`formatted string literal` or :dfn:`f-string` is a string literal "
"that is prefixed with ``'f'`` or ``'F'``.  These strings may contain "
"replacement fields, which are expressions delimited by curly braces ``{}``. "
"While other string literals always have a constant value, formatted strings "
"are really expressions evaluated at run time."
msgstr ""
"Un :dfn:`formatted string literal` o :dfn:`f-string` es un literal de cadena "
"que se prefija con ``'f'`` o ``'F'``.  Estas cadenas pueden contener campos "
"de reemplazo, que son expresiones delimitadas por llaves ``{}``. Mientras "
"que otros literales de cadena siempre tienen un valor constante, las cadenas "
"formateadas son realmente expresiones evaluadas en tiempo de ejecución."

#: ../Doc/reference/lexical_analysis.rst:656
msgid ""
"Escape sequences are decoded like in ordinary string literals (except when a "
"literal is also marked as a raw string).  After decoding, the grammar for "
"the contents of the string is:"
msgstr ""
"Las secuencias de escape se decodifican como en los literales de cadena "
"ordinarios (excepto cuando un literal también se marca como cadena *raw*).  "
"Después de la decodificación, la gramática para el contenido de la cadena es:"

#: ../Doc/reference/lexical_analysis.rst:670
msgid ""
"The parts of the string outside curly braces are treated literally, except "
"that any doubled curly braces ``'{{'`` or ``'}}'`` are replaced with the "
"corresponding single curly brace.  A single opening curly bracket ``'{'`` "
"marks a replacement field, which starts with a Python expression.  After the "
"expression, there may be a conversion field, introduced by an exclamation "
"point ``'!'``.  A format specifier may also be appended, introduced by a "
"colon ``':'``.  A replacement field ends with a closing curly bracket "
"``'}'``."
msgstr ""
"Las partes de la cadena fuera de llaves se tratan literalmente, excepto que "
"cualquier llave doble ``'{{'`` o ``'}}'`` se reemplaza con la llave simple "
"correspondiente.  Una llave de apertura simple ``'{'``` marca un campo de "
"reemplazo, que comienza con una expresión de Python.  Después de la "
"expresión, puede haber un campo de conversión, introducido por un signo de "
"exclamación ``'!'``.  También se puede añadir un especificador de formato, "
"introducido por dos puntos ``':'``.  Un campo de reemplazo termina con una "
"llave de cierre ``'}'``."

#: ../Doc/reference/lexical_analysis.rst:679
msgid ""
"Expressions in formatted string literals are treated like regular Python "
"expressions surrounded by parentheses, with a few exceptions. An empty "
"expression is not allowed, and both :keyword:`lambda`  and assignment "
"expressions ``:=`` must be surrounded by explicit parentheses. Replacement "
"expressions can contain line breaks (e.g. in triple-quoted strings), but "
"they cannot contain comments.  Each expression is evaluated in the context "
"where the formatted string literal appears, in order from left to right."
msgstr ""
"Las expresiones en literales de cadena formateados se tratan como "
"expresiones regulares de Python rodeadas de paréntesis, con algunas "
"excepciones. Una expresión vacía no está permitida, y tanto :keyword:"
"`lambda` como las expresiones de asignación ``:=`` deben estar rodeadas de "
"paréntesis explícitos. Las expresiones de sustitución pueden contener saltos "
"de línea (por ejemplo, en cadenas de tres comillas), pero no pueden contener "
"comentarios.  Cada expresión se evalúa en el contexto en el que aparece el "
"literal de cadena formateado, en orden de izquierda a derecha."

#: ../Doc/reference/lexical_analysis.rst:688
msgid ""
"Prior to Python 3.7, an :keyword:`await` expression and comprehensions "
"containing an :keyword:`async for` clause were illegal in the expressions in "
"formatted string literals due to a problem with the implementation."
msgstr ""
"Antes de Python 3.7, una expresión :keyword:`await` y comprensiones que "
"contenían una cláusula :keyword:`async for` eran ilegales en las expresiones "
"en literales de cadenas formateadas debido a un problema con la "
"implementación."

#: ../Doc/reference/lexical_analysis.rst:693
msgid ""
"If a conversion is specified, the result of evaluating the expression is "
"converted before formatting.  Conversion ``'!s'`` calls :func:`str` on the "
"result, ``'!r'`` calls :func:`repr`, and ``'!a'`` calls :func:`ascii`."
msgstr ""
"Si se especifica una conversión, el resultado de la evaluación de la "
"expresión se convierte antes del formateo.  La conversión ```!s'`` llama :"
"func:`str` al resultado, ```!r'`` llama :func:`repr`, y ```!a'`` llama :func:"
"`ascii`."

#: ../Doc/reference/lexical_analysis.rst:697
msgid ""
"The result is then formatted using the :func:`format` protocol.  The format "
"specifier is passed to the :meth:`__format__` method of the expression or "
"conversion result.  An empty string is passed when the format specifier is "
"omitted.  The formatted result is then included in the final value of the "
"whole string."
msgstr ""
"El resultado es entonces formateado usando el protocolo :func:`format`.  El "
"especificador de formato se pasa al método :meth:`__format__` del resultado "
"de la expresión o conversión.  Se pasa una cadena vacía cuando se omite el "
"especificador de formato.  El resultado formateado se incluye entonces en el "
"valor final de toda la cadena."

#: ../Doc/reference/lexical_analysis.rst:703
msgid ""
"Top-level format specifiers may include nested replacement fields. These "
"nested fields may include their own conversion fields and :ref:`format "
"specifiers <formatspec>`, but may not include more deeply-nested replacement "
"fields. The :ref:`format specifier mini-language <formatspec>` is the same "
"as that used by the string .format() method."
msgstr ""
"Los especificadores de formato de nivel superior pueden incluir campos de "
"reemplazo anidados. Estos campos anidados pueden incluir sus propios campos "
"de conversión y :ref:`especificadores de formato <formatspec>`, pero no "
"pueden incluir campos de reemplazo con nidos más profundos. El :ref:`mini-"
"lenguaje de especificadores de formato  <formatspec>` es el mismo que el "
"utilizado por el método de *string* `.format()`."

#: ../Doc/reference/lexical_analysis.rst:709
msgid ""
"Formatted string literals may be concatenated, but replacement fields cannot "
"be split across literals."
msgstr ""
"Los literales de cadena formateados pueden ser concatenados, pero los campos "
"de reemplazo no pueden ser divididos entre los literales."

#: ../Doc/reference/lexical_analysis.rst:712
msgid "Some examples of formatted string literals::"
msgstr "Algunos ejemplos de literales de cadena formateados::"

#: ../Doc/reference/lexical_analysis.rst:731
msgid ""
"A consequence of sharing the same syntax as regular string literals is that "
"characters in the replacement fields must not conflict with the quoting used "
"in the outer formatted string literal::"
msgstr ""
"Una consecuencia de compartir la misma sintaxis que los literales de cadena "
"regulares es que los caracteres en los campos de reemplazo no deben entrar "
"en conflicto con la comilla usada en el literal de cadena formateado "
"exterior::"

#: ../Doc/reference/lexical_analysis.rst:738
msgid ""
"Backslashes are not allowed in format expressions and will raise an error::"
msgstr ""
"Las barras inversas no están permitidas en las expresiones de formato y "
"generarán un error::"

#: ../Doc/reference/lexical_analysis.rst:743
msgid ""
"To include a value in which a backslash escape is required, create a "
"temporary variable."
msgstr ""
"Para incluir un valor en el que se requiere un escape de barra inversa, hay "
"que crear una variable temporal."

#: ../Doc/reference/lexical_analysis.rst:750
msgid ""
"Formatted string literals cannot be used as docstrings, even if they do not "
"include expressions."
msgstr ""
"Los literales de cadena formateados no pueden ser usados como cadenas de "
"documentos (*docstrings*), aunque no incluyan expresiones."

#: ../Doc/reference/lexical_analysis.rst:761
msgid ""
"See also :pep:`498` for the proposal that added formatted string literals, "
"and :meth:`str.format`, which uses a related format string mechanism."
msgstr ""
"Ver también :pep:`498` para la propuesta que añadió literales de cadenas "
"formateados, y :meth:`str.format`, que utiliza un mecanismo de cadenas "
"formateadas relacionado."

#: ../Doc/reference/lexical_analysis.rst:768
msgid "Numeric literals"
msgstr "Literales numéricos"

#: ../Doc/reference/lexical_analysis.rst:774
msgid ""
"There are three types of numeric literals: integers, floating point numbers, "
"and imaginary numbers.  There are no complex literals (complex numbers can "
"be formed by adding a real number and an imaginary number)."
msgstr ""
"Hay tres tipos de literales numéricos: números enteros, números de punto "
"flotante y números imaginarios.  No hay literales complejos (los números "
"complejos pueden formarse sumando un número real y un número imaginario)."

#: ../Doc/reference/lexical_analysis.rst:778
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr ""
"Nótese que los literales numéricos no incluyen un signo; una frase como "
"``-1`` es en realidad una expresión compuesta por el operador unario '``-``' "
"y el literal ``1``."

#: ../Doc/reference/lexical_analysis.rst:792
msgid "Integer literals"
msgstr "Literales enteros"

#: ../Doc/reference/lexical_analysis.rst:794
msgid "Integer literals are described by the following lexical definitions:"
msgstr ""
"Los literales enteros se describen mediante las siguientes definiciones "
"léxicas:"

#: ../Doc/reference/lexical_analysis.rst:808
msgid ""
"There is no limit for the length of integer literals apart from what can be "
"stored in available memory."
msgstr ""
"No hay límite para la longitud de los literales enteros aparte de lo que se "
"puede almacenar en la memoria disponible."

#: ../Doc/reference/lexical_analysis.rst:811
msgid ""
"Underscores are ignored for determining the numeric value of the literal.  "
"They can be used to group digits for enhanced readability.  One underscore "
"can occur between digits, and after base specifiers like ``0x``."
msgstr ""
"Los guiones bajos se ignoran para determinar el valor numérico del literal.  "
"Se pueden utilizar para agrupar los dígitos para mejorar la legibilidad.  Un "
"guión bajo puede ocurrir entre dígitos y después de especificadores de base "
"como ``0x``."

#: ../Doc/reference/lexical_analysis.rst:815
msgid ""
"Note that leading zeros in a non-zero decimal number are not allowed. This "
"is for disambiguation with C-style octal literals, which Python used before "
"version 3.0."
msgstr ""
"Nótese que no se permiten los ceros a la izquierda en un número decimal que "
"no sea cero. Esto es para desambiguar con los literales octales de estilo C, "
"que Python usaba antes de la versión 3.0."

#: ../Doc/reference/lexical_analysis.rst:819
msgid "Some examples of integer literals::"
msgstr "Algunos ejemplos de literales enteros::"

#: ../Doc/reference/lexical_analysis.rst:825
#: ../Doc/reference/lexical_analysis.rst:857
msgid "Underscores are now allowed for grouping purposes in literals."
msgstr "Los guiones bajos están ahora permitidos para agrupar en literales."

#: ../Doc/reference/lexical_analysis.rst:836
msgid "Floating point literals"
msgstr "Literales de punto flotante"

#: ../Doc/reference/lexical_analysis.rst:838
msgid ""
"Floating point literals are described by the following lexical definitions:"
msgstr ""
"Los literales de punto flotante se describen en las siguientes definiciones "
"léxicas:"

#: ../Doc/reference/lexical_analysis.rst:848
msgid ""
"Note that the integer and exponent parts are always interpreted using radix "
"10. For example, ``077e010`` is legal, and denotes the same number as "
"``77e10``. The allowed range of floating point literals is implementation-"
"dependent.  As in integer literals, underscores are supported for digit "
"grouping."
msgstr ""
"Nótese que las partes enteras y exponentes siempre se interpretan usando el "
"radix 10. Por ejemplo, ``077e010`` es legal, y denota el mismo número que "
"``77e10``. El rango permitido de los literales de punto flotante depende de "
"la implementación.  Al igual que en los literales enteros, se admiten "
"guiones bajos para la agrupación de dígitos."

#: ../Doc/reference/lexical_analysis.rst:853
msgid "Some examples of floating point literals::"
msgstr "Algunos ejemplos de literales de punto flotante::"

#: ../Doc/reference/lexical_analysis.rst:866
msgid "Imaginary literals"
msgstr "Literales imaginarios"

#: ../Doc/reference/lexical_analysis.rst:868
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr ""
"Los literales imaginarios se describen en las siguientes definiciones "
"léxicas:"

#: ../Doc/reference/lexical_analysis.rst:873
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and have "
"the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr ""
"Un literal imaginario da un número complejo con una parte real de 0.0.  Los "
"números complejos se representan como un par de números de punto flotante y "
"tienen las mismas restricciones en su rango.  Para crear un número complejo "
"con una parte real distinta de cero, añada un número de punto flotante, por "
"ejemplo, ``(3+4j)``.  Algunos ejemplos de literales imaginarios::"

#: ../Doc/reference/lexical_analysis.rst:885
msgid "Operators"
msgstr "Operadores"

#: ../Doc/reference/lexical_analysis.rst:889
msgid "The following tokens are operators:"
msgstr "Los siguientes tokens son operadores:"

#: ../Doc/reference/lexical_analysis.rst:902
msgid "Delimiters"
msgstr "Delimitadores"

#: ../Doc/reference/lexical_analysis.rst:906
msgid "The following tokens serve as delimiters in the grammar:"
msgstr "Los siguientes tokens sirven como delimitadores en la gramática:"

#: ../Doc/reference/lexical_analysis.rst:915
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis literal. The "
"second half of the list, the augmented assignment operators, serve lexically "
"as delimiters, but also perform an operation."
msgstr ""
"El punto también puede ocurrir en los literales de punto flotante e "
"imaginarios.  Una secuencia de tres períodos tiene un significado especial "
"como un literal de elipsis. La segunda mitad de la lista, los operadores de "
"asignación aumentada, sirven léxicamente como delimitadores, pero también "
"realizan una operación."

#: ../Doc/reference/lexical_analysis.rst:920
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr ""
"Los siguientes caracteres ASCII de impresión tienen un significado especial "
"como parte de otros tokens o son de alguna manera significativos para el "
"analizador léxico:"

#: ../Doc/reference/lexical_analysis.rst:927
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error:"
msgstr ""
"Los siguientes caracteres ASCII de impresión no se utilizan en Python.  Su "
"presencia fuera de las cadenas de caracteres y comentarios es un error "
"incondicional:"

#: ../Doc/reference/lexical_analysis.rst:936
msgid "Footnotes"
msgstr "Notas al pie de página"

#: ../Doc/reference/lexical_analysis.rst:937
msgid "http://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
msgstr "http://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
