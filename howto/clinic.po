# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2023-04-11 17:45-0400\n"
"Last-Translator: Francisco Mora <fr.morac@duocuc.cl>\n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.0\n"

#: ../Doc/howto/clinic.rst:7
msgid "Argument Clinic How-To"
msgstr "Argument Clinic Cómo Hacerlo"

#: ../Doc/howto/clinic.rst
msgid "author"
msgstr "autor"

#: ../Doc/howto/clinic.rst:9
msgid "Larry Hastings"
msgstr "Larry Hastings"

#: ../Doc/howto/clinic.rst:11
msgid "**Source code:** :source:`Tools/clinic/clinic.py`."
msgstr ""

#: ../Doc/howto/clinic.rst:7
msgid "Abstract"
msgstr "Resumen"

#: ../Doc/howto/clinic.rst:15
msgid ""
"Argument Clinic is a preprocessor for CPython C files. It was introduced in "
"Python 3.4 with :pep:`436`, in order to provide introspection signatures, "
"and to generate performant and tailor-made boilerplate code for argument "
"parsing in CPython builtins, module level functions, and class methods. This "
"document is divided in four major sections:"
msgstr ""

#: ../Doc/howto/clinic.rst:23
msgid ""
":ref:`clinic-background` talks about the basic concepts and goals of "
"Argument Clinic."
msgstr ""

#: ../Doc/howto/clinic.rst:25
msgid ""
":ref:`clinic-reference` describes the command-line interface and Argument "
"Clinic terminology."
msgstr ""

#: ../Doc/howto/clinic.rst:27
msgid ""
":ref:`clinic-tutorial` guides you through all the steps required to adapt an "
"existing C function to Argument Clinic."
msgstr ""

#: ../Doc/howto/clinic.rst:29
msgid ":ref:`clinic-howtos` details how to handle specific tasks."
msgstr ""

#: ../Doc/howto/clinic.rst:34
#, fuzzy
msgid ""
"Argument Clinic is considered internal-only for CPython.  Its use is not "
"supported for files outside CPython, and no guarantees are made regarding "
"backwards compatibility for future versions.  In other words: if you "
"maintain an external C extension for CPython, you're welcome to experiment "
"with Argument Clinic in your own code.  But the version of Argument Clinic "
"that ships with the next version of CPython *could* be totally incompatible "
"and break all your code."
msgstr ""
"Actualmente, Argument Clinic se considera solo interno para CPython. Su uso "
"no es compatible con archivos fuera de CPython y no se ofrecen garantías con "
"respecto a la compatibilidad con versiones anteriores. En otras palabras: si "
"mantiene una extensión C externa para CPython, puede experimentar con "
"Argument Clinic en su propio código. Pero la versión de Argument Clinic que "
"se envía con la próxima versión de CPython *podría* ser totalmente "
"incompatible y romper todo su código."

#: ../Doc/howto/clinic.rst:47
msgid "Background"
msgstr ""

#: ../Doc/howto/clinic.rst:50
#, fuzzy
msgid "Basic concepts"
msgstr "Conceptos básicos y uso"

#: ../Doc/howto/clinic.rst:52
msgid ""
"When Argument Clinic is run on a file, either via the :ref:`clinic-cli` or "
"via ``make clinic``, it will scan over the input files looking for :term:"
"`start lines <start line>`:"
msgstr ""

#: ../Doc/howto/clinic.rst:60
#, fuzzy
msgid "When it finds one, it reads everything up to the :term:`end line`:"
msgstr ""
"Cuando encuentra uno, lee todo hasta una línea que se ve exactamente así:"

#: ../Doc/howto/clinic.rst:66
msgid ""
"Everything in between these two lines is Argument Clinic :term:`input`. When "
"Argument Clinic parses input, it generates :term:`output`. The output is "
"rewritten into the C file immediately after the input, followed by a :term:"
"`checksum line`. All of these lines, including the :term:`start line` and :"
"term:`checksum line`, are collectively called an Argument Clinic :term:"
"`block`:"
msgstr ""

#: ../Doc/howto/clinic.rst:81
#, fuzzy
msgid ""
"If you run Argument Clinic on the same file a second time, Argument Clinic "
"will discard the old :term:`output` and write out the new output with a "
"fresh :term:`checksum line`. If the :term:`input` hasn't changed, the output "
"won't change either."
msgstr ""
"Si ejecuta Argument Clinic en el mismo archivo por segunda vez, Argument "
"Clinic descartará la salida anterior y escribirá la nueva salida con una "
"nueva línea de suma de comprobación. Sin embargo, si la entrada no ha "
"cambiado, la salida tampoco cambiará."

#: ../Doc/howto/clinic.rst:88
msgid ""
"You should never modify the output of an Argument Clinic block, as any "
"change will be lost in future Argument Clinic runs; Argument Clinic will "
"detect an output checksum mismatch and regenerate the correct output. If you "
"are not happy with the generated output, you should instead change the input "
"until it produces the output you want."
msgstr ""

#: ../Doc/howto/clinic.rst:99
#, fuzzy
msgid "Reference"
msgstr "``impl_by_reference``"

#: ../Doc/howto/clinic.rst:105
msgid "Terminology"
msgstr ""

#: ../Doc/howto/clinic.rst:108
msgid "start line"
msgstr ""

#: ../Doc/howto/clinic.rst:110
msgid ""
"The line ``/*[clinic input]``. This line marks the beginning of Argument "
"Clinic input. Note that the *start line* opens a C block comment."
msgstr ""

#: ../Doc/howto/clinic.rst:113
msgid "end line"
msgstr ""

#: ../Doc/howto/clinic.rst:115
msgid ""
"The line ``[clinic start generated code]*/``. The *end line* marks the _end_ "
"of Argument Clinic :term:`input`, but at the same time marks the _start_ of "
"Argument Clinic :term:`output`, thus the text *\"clinic start start "
"generated code\"* Note that the *end line* closes the C block comment opened "
"by the *start line*."
msgstr ""

#: ../Doc/howto/clinic.rst:121
msgid "checksum"
msgstr ""

#: ../Doc/howto/clinic.rst:123
msgid ""
"A hash to distinguish unique :term:`inputs <input>` and :term:`outputs "
"<output>`."
msgstr ""

#: ../Doc/howto/clinic.rst:125
msgid "checksum line"
msgstr ""

#: ../Doc/howto/clinic.rst:127
msgid ""
"A line that looks like ``/*[clinic end generated code: ...]*/``. The three "
"dots will be replaced by a :term:`checksum` generated from the :term:"
"`input`, and a :term:`checksum` generated from the :term:`output`. The "
"checksum line marks the end of Argument Clinic generated code, and is used "
"by Argument Clinic to determine if it needs to regenerate output."
msgstr ""

#: ../Doc/howto/clinic.rst:133
msgid "input"
msgstr ""

#: ../Doc/howto/clinic.rst:135
msgid ""
"The text between the :term:`start line` and the :term:`end line`. Note that "
"the start and end lines open and close a C block comment; the *input* is "
"thus a part of that same C block comment."
msgstr ""

#: ../Doc/howto/clinic.rst:138
msgid "output"
msgstr ""

#: ../Doc/howto/clinic.rst:140
#, fuzzy
msgid "The text between the :term:`end line` and the :term:`checksum line`."
msgstr ""
"Entre la línea final y la línea de suma de comprobación se encuentra la "
"*output*."

#: ../Doc/howto/clinic.rst:141
#, fuzzy
msgid "block"
msgstr "``block``"

#: ../Doc/howto/clinic.rst:143
msgid ""
"All text from the :term:`start line` to the :term:`checksum line` "
"inclusively."
msgstr ""

#: ../Doc/howto/clinic.rst:149
msgid "Command-line interface"
msgstr ""

#: ../Doc/howto/clinic.rst:151
msgid ""
"The Argument Clinic :abbr:`CLI (Command-Line Interface)` is typically used "
"to process a single source file, like this:"
msgstr ""

#: ../Doc/howto/clinic.rst:158
msgid "The CLI supports the following options:"
msgstr ""

#: ../Doc/howto/clinic.rst:165
msgid "Print CLI usage."
msgstr ""

#: ../Doc/howto/clinic.rst:169
msgid "Force output regeneration."
msgstr ""

#: ../Doc/howto/clinic.rst:173
msgid "Redirect file output to OUTPUT"
msgstr ""

#: ../Doc/howto/clinic.rst:177
msgid "Enable verbose mode."
msgstr ""

#: ../Doc/howto/clinic.rst:181
msgid "Print a list of all supported converters and return converters."
msgstr ""

#: ../Doc/howto/clinic.rst:185
msgid "Walk :option:`--srcdir` to run over all relevant files."
msgstr ""

#: ../Doc/howto/clinic.rst:189
msgid "The directory tree to walk in :option:`--make` mode."
msgstr ""

#: ../Doc/howto/clinic.rst:193
msgid "The list of files to process."
msgstr ""

#: ../Doc/howto/clinic.rst:199
#, fuzzy
msgid "Classes for extending Argument Clinic"
msgstr "Los objetivos del Argument Clinic"

#: ../Doc/howto/clinic.rst:205
msgid ""
"The base class for all converters. See :ref:`clinic-howto-custom-converter` "
"for how to subclass this class."
msgstr ""

#: ../Doc/howto/clinic.rst:210
#, fuzzy
msgid ""
"The C type to use for this variable. :attr:`!type` should be a Python string "
"specifying the type, e.g. ``'int'``. If this is a pointer type, the type "
"string should end with ``' *'``."
msgstr ""
"El tipo C que se utilizará para esta variable. ``type`` debe ser una cadena "
"de Python que especifique el tipo, por ejemplo ``int``. Si se trata de un "
"tipo de puntero, la cadena de tipo debe terminar con ``'*'``."

#: ../Doc/howto/clinic.rst:217
msgid ""
"The Python default value for this parameter, as a Python value. Or the magic "
"value ``unspecified`` if there is no default."
msgstr ""
"El valor predeterminado de Python para este parámetro, como un valor de "
"Python. O el valor mágico ``unspecified`` si no hay ningún valor "
"predeterminado."

#: ../Doc/howto/clinic.rst:222
#, fuzzy
msgid ""
":attr:`!default` as it should appear in Python code, as a string. Or "
"``None`` if there is no default."
msgstr ""
"``default`` como debería aparecer en el código Python, como una cadena. O "
"``None`` si no hay un valor predeterminado."

#: ../Doc/howto/clinic.rst:228
#, fuzzy
msgid ""
":attr:`!default` as it should appear in C code, as a string. Or ``None`` if "
"there is no default."
msgstr ""
"``default`` como debería aparecer en el código C, como una cadena de "
"caracteres. O ``None`` si no hay un valor predeterminado."

#: ../Doc/howto/clinic.rst:234
msgid ""
"The default value used to initialize the C variable when there is no "
"default, but not specifying a default may result in an \"uninitialized "
"variable\" warning.  This can easily happen when using option groups—"
"although properly written code will never actually use this value, the "
"variable does get passed in to the impl, and the C compiler will complain "
"about the \"use\" of the uninitialized value.  This value should always be a "
"non-empty string."
msgstr ""
"El valor por defecto utilizado para inicializar la variable C cuando no hay "
"un valor por defecto, pero no especificar un valor por defecto puede dar "
"lugar a una advertencia de \"variable no inicializada\". Esto puede ocurrir "
"fácilmente cuando se utilizan grupos de opciones—aunque un código bien "
"escrito nunca utilizará este valor, la variable se pasa a la impl, y el "
"compilador de C se quejará del \"uso\" del valor no inicializado. Este valor "
"debe ser siempre una cadena no vacía."

#: ../Doc/howto/clinic.rst:246
msgid "The name of the C converter function, as a string."
msgstr ""
"El nombre de la función de conversión de C, como una cadena de caracteres."

#: ../Doc/howto/clinic.rst:250
msgid ""
"A boolean value.  If true, Argument Clinic will add a ``&`` in front of the "
"name of the variable when passing it into the impl function."
msgstr ""
"Un valor booleano. Si es verdadero, Argument Clinic agregará un ``&`` "
"delante del nombre de la variable al pasarlo a la función impl."

#: ../Doc/howto/clinic.rst:256
msgid ""
"A boolean value.  If true, Argument Clinic will add a ``&`` in front of the "
"name of the variable when passing it into :c:func:`PyArg_ParseTuple`."
msgstr ""
"Un valor booleano. Si es verdadero, Argument Clinic agregará un ``&`` "
"delante del nombre de la variable al pasarlo a :c:func:`PyArg_ParseTuple`."

#: ../Doc/howto/clinic.rst:264
msgid "Tutorial"
msgstr ""

#: ../Doc/howto/clinic.rst:266
#, fuzzy
msgid ""
"The best way to get a sense of how Argument Clinic works is to convert a "
"function to work with it.  Here, then, are the bare minimum steps you'd need "
"to follow to convert a function to work with Argument Clinic.  Note that for "
"code you plan to check in to CPython, you really should take the conversion "
"farther, using some of the :ref:`advanced concepts <clinic-howtos>` you'll "
"see later on in the document, like :ref:`clinic-howto-return-converters` "
"and :ref:`clinic-howto-self-converter`. But we'll keep it simple for this "
"walkthrough so you can learn."
msgstr ""
"La mejor manera de tener una idea de cómo funciona Argument Clinic es "
"convertir una función para que funcione con ella. Aquí, entonces, están los "
"pasos mínimos que debe seguir para convertir una función para que funcione "
"con Argument Clinic. Tenga en cuenta que para el código que planea registrar "
"en CPython, realmente debería llevar la conversión más lejos, utilizando "
"algunos de los conceptos avanzados que verá más adelante en el documento "
"(como \"convertidores de retorno\" y \"convertidores automáticos\"). Pero lo "
"haremos simple para este tutorial para que pueda aprender."

#: ../Doc/howto/clinic.rst:277
#, fuzzy
msgid ""
"First, make sure you're working with a freshly updated checkout of the "
"CPython trunk."
msgstr ""
"Asegúrese de estar trabajando con una versión recién actualizada de CPython."

#: ../Doc/howto/clinic.rst:280
#, fuzzy
msgid ""
"Next, find a Python builtin that calls either :c:func:`PyArg_ParseTuple` or :"
"c:func:`PyArg_ParseTupleAndKeywords`, and hasn't been converted to work with "
"Argument Clinic yet. For this tutorial, we'll be using :py:meth:`_pickle."
"Pickler.dump <pickle.Pickler.dump>`."
msgstr ""
"Busca un incorporado de Python que llame a :c:func:`PyArg_ParseTuple` o :c:"
"func:`PyArg_ParseTupleAndKeywords`, y que aún no se haya convertido para "
"funcionar con Argument Clinic. Para mi ejemplo, estoy usando ``_pickle."
"Pickler.dump()``."

#: ../Doc/howto/clinic.rst:286
#, fuzzy
msgid ""
"If the call to the :c:func:`!PyArg_Parse*` function uses any of the "
"following format units...:"
msgstr ""
"Si la llamada a la función ``PyArg_Parse`` usa cualquiera de las siguientes "
"unidades de formato:"

#: ../Doc/howto/clinic.rst:298
#, fuzzy
msgid ""
"... or if it has multiple calls to :c:func:`PyArg_ParseTuple`, you should "
"choose a different function. (See :ref:`clinic-howto-advanced-converters` "
"for those scenarios.)"
msgstr ""
"o si tiene múltiples llamadas a :c:func:`PyArg_ParseTuple`, debes elegir una "
"función diferente. Argument Clinic *sí* admite todos estos escenarios. Pero "
"estos son temas avanzados; hagamos algo más simple para su primera función."

#: ../Doc/howto/clinic.rst:302
#, fuzzy
msgid ""
"Also, if the function has multiple calls to :c:func:`!PyArg_ParseTuple` or :"
"c:func:`PyArg_ParseTupleAndKeywords` where it supports different types for "
"the same argument, or if the function uses something besides :c:func:`!"
"PyArg_Parse*` functions to parse its arguments, it probably isn't suitable "
"for conversion to Argument Clinic.  Argument Clinic doesn't support generic "
"functions or polymorphic parameters."
msgstr ""
"Además, si la función tiene múltiples llamadas a :c:func:`PyArg_ParseTuple` "
"o :c:func:`PyArg_ParseTupleAndKeywords` donde admite diferentes tipos para "
"el mismo argumento, o si la función usa algo además de las funciones "
"PyArg_Parse para analizar sus argumentos, probablemente no sea adecuado para "
"la conversión a Argument Clinic. Argument Clinic no admite funciones "
"genéricas ni parámetros polimórficos."

#: ../Doc/howto/clinic.rst:309
#, fuzzy
msgid ""
"Next, add the following boilerplate above the function, creating our input "
"block::"
msgstr ""
"Agrega la siguiente plantilla sobre la función, creando nuestro bloque::"

#: ../Doc/howto/clinic.rst:315
#, fuzzy
msgid ""
"Cut the docstring and paste it in between the ``[clinic]`` lines, removing "
"all the junk that makes it a properly quoted C string. When you're done you "
"should have just the text, based at the left margin, with no line wider than "
"80 characters. Argument Clinic will preserve indents inside the docstring."
msgstr ""
"Corta el docstring y lo pega entre las líneas ``[clinic]``, eliminando toda "
"la basura que la convierte en una cadena C entre comillas. Cuando haya "
"terminado, debería tener solo el texto, basado en el margen izquierdo, sin "
"una línea de más de 80 caracteres. (Argument Clinic conservará las sangrías "
"dentro del docstring)."

#: ../Doc/howto/clinic.rst:321
#, fuzzy
msgid ""
"If the old docstring had a first line that looked like a function signature, "
"throw that line away; The docstring doesn't need it anymore --- when you "
"use :py:func:`help` on your builtin in the future, the first line will be "
"built automatically based on the function's signature."
msgstr ""
"Si el docstring antiguo tenía una primera línea que parecía una firma de "
"función, elimine esa línea. (El docstring ya no la necesita; cuando use "
"``help()`` en su incorporado en el futuro, la primera línea se creará "
"automáticamente en función de la firma de la función)."

#: ../Doc/howto/clinic.rst:326
msgid "Example docstring summary line::"
msgstr ""

#: ../Doc/howto/clinic.rst:332
#, fuzzy
msgid ""
"If your docstring doesn't have a \"summary\" line, Argument Clinic will "
"complain, so let's make sure it has one.  The \"summary\" line should be a "
"paragraph consisting of a single 80-column line at the beginning of the "
"docstring. (See :pep:`257` regarding docstring conventions.)"
msgstr ""
"Si su cadena de documentos no tiene una línea de \"resumen\", Argument "
"Clinic se quejará. Así que asegurémonos de que tenga uno. La línea de "
"\"resumen\" debe ser un párrafo que consta de una sola línea de 80 columnas "
"al comienzo de la cadena de documentos."

#: ../Doc/howto/clinic.rst:338
#, fuzzy
msgid ""
"Our example docstring consists solely of a summary line, so the sample code "
"doesn't have to change for this step."
msgstr ""
"(Nuestro docstring de ejemplo consiste únicamente en una línea de resumen, "
"por lo que el código de muestra no tiene que cambiar para este paso.)"

#: ../Doc/howto/clinic.rst:341
#, fuzzy
msgid ""
"Now, above the docstring, enter the name of the function, followed by a "
"blank line.  This should be the Python name of the function, and should be "
"the full dotted path to the function --- it should start with the name of "
"the module, include any sub-modules, and if the function is a method on a "
"class it should include the class name too."
msgstr ""
"Sobre el docstring, ingrese el nombre de la función, seguido de una línea en "
"blanco. Este debería ser el nombre de Python de la función, y debería ser la "
"ruta de puntos completa a la función—debería comenzar con el nombre del "
"módulo, incluir cualquier submódulo y, si la función es un método en una "
"clase, debe incluir el nombre de la clase también."

#: ../Doc/howto/clinic.rst:348
msgid ""
"In our example, :mod:`!_pickle` is the module, :py:class:`!Pickler` is the "
"class, and :py:meth:`!dump` is the method, so the name becomes :py:meth:`!"
"_pickle.Pickler.dump`::"
msgstr ""

#: ../Doc/howto/clinic.rst:358
#, fuzzy
msgid ""
"If this is the first time that module or class has been used with Argument "
"Clinic in this C file, you must declare the module and/or class.  Proper "
"Argument Clinic hygiene prefers declaring these in a separate block "
"somewhere near the top of the C file, in the same way that include files and "
"statics go at the top. In our sample code we'll just show the two blocks "
"next to each other."
msgstr ""
"Si es la primera vez que ese módulo o clase se utiliza con Argument Clinic "
"en este archivo C, debe declarar el módulo o la clase. La higiene de la "
"clínica de argumentos apropiados prefiere declararlos en un bloque separado "
"en algún lugar cerca de la parte superior del archivo C, de la misma manera "
"que los archivos de inclusión y las estadísticas van en la parte superior. "
"(En nuestro código de muestra, solo mostraremos los dos bloques uno al lado "
"del otro)."

#: ../Doc/howto/clinic.rst:366
msgid ""
"The name of the class and module should be the same as the one seen by "
"Python.  Check the name defined in the :c:type:`PyModuleDef` or :c:type:"
"`PyTypeObject` as appropriate."
msgstr ""
"El nombre de la clase y el módulo debe ser el mismo que el visto por Python. "
"Compruebe el nombre definido en :c:type:`PyModuleDef` o :c:type:"
"`PyTypeObject` según corresponda."

#: ../Doc/howto/clinic.rst:370
#, fuzzy
msgid ""
"When you declare a class, you must also specify two aspects of its type in "
"C: the type declaration you'd use for a pointer to an instance of this "
"class, and a pointer to the :c:type:`!PyTypeObject` for this class::"
msgstr ""
"Cuando declaras una clase, también debes especificar dos aspectos de su tipo "
"en C: la declaración de tipo que usarías para un puntero a una instancia de "
"esta clase y un puntero a :c:type:`PyTypeObject` para esto clase."

#: ../Doc/howto/clinic.rst:385
#, fuzzy
msgid ""
"Declare each of the parameters to the function.  Each parameter should get "
"its own line.  All the parameter lines should be indented from the function "
"name and the docstring. The general form of these parameter lines is as "
"follows:"
msgstr ""
"Declare cada uno de los parámetros a la función. Cada parámetro debe tener "
"su propia línea. Todas las líneas de parámetros deben tener sangría del "
"nombre de la función y el docstring."

#: ../Doc/howto/clinic.rst:394
msgid "If the parameter has a default value, add that after the converter:"
msgstr ""
"Si el parámetro tiene un valor predeterminado, agréguelo después del "
"convertidor:"

#: ../Doc/howto/clinic.rst:401
#, fuzzy
msgid ""
"Argument Clinic's support for \"default values\" is quite sophisticated; "
"see :ref:`clinic-howto-default-values` for more information."
msgstr ""
"El soporte de Argument Clinic para \"valores predeterminados\" es bastante "
"sofisticado; por favor vea :ref:`la sección a continuación sobre valores "
"predeterminados <default_values>` para más información."

#: ../Doc/howto/clinic.rst:404
#, fuzzy
msgid "Next, add a blank line below the parameters."
msgstr "Agrega una línea en blanco debajo de los parámetros."

#: ../Doc/howto/clinic.rst:406
#, fuzzy
msgid ""
"What's a \"converter\"? It establishes both the type of the variable used in "
"C, and the method to convert the Python value into a C value at runtime. For "
"now you're going to use what's called a \"legacy converter\" --- a "
"convenience syntax intended to make porting old code into Argument Clinic "
"easier."
msgstr ""
"¿Qué es un \"convertidor\"? Establece tanto el tipo de variable utilizada en "
"C como el método para convertir el valor de Python en un valor de C en "
"tiempo de ejecución. Por ahora, va a utilizar lo que se llama un "
"\"convertidor heredado\", una sintaxis conveniente destinada a facilitar la "
"migración del código antiguo a Argument Clinic."

#: ../Doc/howto/clinic.rst:413
#, fuzzy
msgid ""
"For each parameter, copy the \"format unit\" for that parameter from the :c:"
"func:`PyArg_Parse` format argument and specify *that* as its converter, as a "
"quoted string. The \"format unit\" is the formal name for the one-to-three "
"character substring of the *format* parameter that tells the argument "
"parsing function what the type of the variable is and how to convert it. For "
"more on format units please see :ref:`arg-parsing`."
msgstr ""
"Para cada parámetro, copie la \"unidad de formato\" para ese parámetro del "
"argumento de formato ``PyArg_Parse()`` y especifique *eso* como su "
"convertidor, como una cadena entre comillas. (\"unidad de formato\" es el "
"nombre formal de la subcadena de caracteres de uno a tres caracteres del "
"parámetro ``format`` que le dice a la función de análisis de argumentos cuál "
"es el tipo de variable y cómo convertirla. Para más información sobre las "
"unidades de formato por favor vea :ref:`arg-parsing`.)"

#: ../Doc/howto/clinic.rst:422
msgid ""
"For multicharacter format units like ``z#``, use the entire two-or-three "
"character string."
msgstr ""
"Para unidades de formato de caracteres múltiples como ``z#``, use la cadena "
"completa de dos o tres caracteres."

#: ../Doc/howto/clinic.rst:425 ../Doc/howto/clinic.rst:460
#: ../Doc/howto/clinic.rst:488 ../Doc/howto/clinic.rst:594
#: ../Doc/howto/clinic.rst:647
msgid "Sample::"
msgstr "Muestra::"

#: ../Doc/howto/clinic.rst:440
#, fuzzy
msgid ""
"If your function has ``|`` in the format string, meaning some parameters "
"have default values, you can ignore it. Argument Clinic infers which "
"parameters are optional based on whether or not they have default values."
msgstr ""
"Si su función tiene ``|`` en la cadena de formato, lo que significa que "
"algunos parámetros tienen valores predeterminados, puede ignorarlo. Argument "
"Clinic infiere qué parámetros son opcionales en función de si tienen o no "
"valores predeterminados."

#: ../Doc/howto/clinic.rst:445
msgid ""
"If your function has ``$`` in the format string, meaning it takes keyword-"
"only arguments, specify ``*`` on a line by itself before the first keyword-"
"only argument, indented the same as the parameter lines."
msgstr ""
"Si su función tiene ``$`` en la cadena de caracteres de formato, lo que "
"significa que toma argumentos de solo palabras clave, especifique ``*`` en "
"una línea antes del primer argumento de solo palabras clave, con la misma "
"indentación que las líneas de parámetros."

#: ../Doc/howto/clinic.rst:450
#, fuzzy
msgid ""
":py:meth:`!_pickle.Pickler.dump` has neither, so our sample is unchanged."
msgstr ""
"(``_pickle.Pickler.dump`` no tiene ninguno, por lo que nuestro ejemplo no ha "
"cambiado.)"

#: ../Doc/howto/clinic.rst:452
#, fuzzy
msgid ""
"Next, if the existing C function calls :c:func:`PyArg_ParseTuple` (as "
"opposed to :c:func:`PyArg_ParseTupleAndKeywords`), then all its arguments "
"are positional-only."
msgstr ""
"Si la función C existente llama a :c:func:`PyArg_ParseTuple` (a diferencia "
"de :c:func:`PyArg_ParseTupleAndKeywords`), entonces todos sus argumentos son "
"solo posicionales."

#: ../Doc/howto/clinic.rst:456
#, fuzzy
msgid ""
"To mark parameters as positional-only in Argument Clinic, add a ``/`` on a "
"line by itself after the last positional-only parameter, indented the same "
"as the parameter lines."
msgstr ""
"Para marcar todos los parámetros como solo posicionales en Argument Clinic, "
"agregue un ``/`` en una línea después del último parámetro, con la misma "
"sangría que las líneas de parámetros."

#: ../Doc/howto/clinic.rst:476
#, fuzzy
msgid ""
"It can be helpful to write a per-parameter docstring for each parameter. "
"Since per-parameter docstrings are optional, you can skip this step if you "
"prefer."
msgstr ""
"Es útil escribir una cadena de documentos por parámetro para cada parámetro. "
"Pero los docstrings por parámetro son opcionales; puede omitir este paso si "
"lo prefiere."

#: ../Doc/howto/clinic.rst:480
#, fuzzy
msgid ""
"Nevertheless, here's how to add a per-parameter docstring. The first line of "
"the per-parameter docstring must be indented further than the parameter "
"definition. The left margin of this first line establishes the left margin "
"for the whole per-parameter docstring; all the text you write will be "
"outdented by this amount. You can write as much text as you like, across "
"multiple lines if you wish."
msgstr ""
"A continuación, se explica cómo agregar un docstring por parámetro. La "
"primera línea del docstring por parámetro debe tener más sangría que la "
"definición del parámetro. El margen izquierdo de esta primera línea "
"establece el margen izquierdo para todo el docstring por parámetro; todo el "
"texto que escriba se verá afectado por esta cantidad. Puede escribir todo el "
"texto que desee, en varias líneas si lo desea."

#: ../Doc/howto/clinic.rst:505
#, fuzzy
msgid ""
"Save and close the file, then run ``Tools/clinic/clinic.py`` on it. With "
"luck everything worked---your block now has output, and a :file:`.c.h` file "
"has been generated! Reload the file in your text editor to see the generated "
"code::"
msgstr ""
"Guarde y cierre el archivo, luego ejecute ``Tools/clinic/clinic.py`` en él. "
"¡Con suerte, todo funcionó --- su bloque ahora tiene salida y se ha generado "
"un archivo ``.c.h`` ! Vuelva a abrir el archivo en su editor de texto para "
"ver::"

#: ../Doc/howto/clinic.rst:524
#, fuzzy
msgid ""
"Obviously, if Argument Clinic didn't produce any output, it's because it "
"found an error in your input. Keep fixing your errors and retrying until "
"Argument Clinic processes your file without complaint."
msgstr ""
"Obviamente, si Argument Clinic no produjo ningún resultado, es porque "
"encontró un error en su entrada. Siga corrigiendo sus errores y vuelva a "
"intentarlo hasta que Argument Clinic procese su archivo sin quejas."

#: ../Doc/howto/clinic.rst:529
#, fuzzy
msgid ""
"For readability, most of the glue code has been generated to a :file:`.c.h` "
"file.  You'll need to include that in your original :file:`.c` file, "
"typically right after the clinic module block::"
msgstr ""
"Para facilitar la lectura, la mayor parte del código de pegamento se ha "
"generado en un archivo ``.c.h``. Deberá incluir eso en su archivo ``.c`` "
"original, generalmente justo después del bloque del módulo de la clínica::"

#: ../Doc/howto/clinic.rst:535
msgid ""
"Double-check that the argument-parsing code Argument Clinic generated looks "
"basically the same as the existing code."
msgstr ""
"Vuelva a verificar que el código de análisis de argumentos generado por "
"Argument Clinic se ve básicamente igual al código existente."

#: ../Doc/howto/clinic.rst:538
msgid ""
"First, ensure both places use the same argument-parsing function. The "
"existing code must call either :c:func:`PyArg_ParseTuple` or :c:func:"
"`PyArg_ParseTupleAndKeywords`; ensure that the code generated by Argument "
"Clinic calls the *exact* same function."
msgstr ""
"Primero, asegúrese de que ambos lugares usen la misma función de análisis de "
"argumentos. El código existente debe llamar a :c:func:`PyArg_ParseTuple` o :"
"c:func:`PyArg_ParseTupleAndKeywords`; asegúrese de que el código generado "
"por Argument Clinic llame a la misma *exacta* función."

#: ../Doc/howto/clinic.rst:544
#, fuzzy
msgid ""
"Second, the format string passed in to :c:func:`!PyArg_ParseTuple` or :c:"
"func:`!PyArg_ParseTupleAndKeywords` should be *exactly* the same as the hand-"
"written one in the existing function, up to the colon or semi-colon."
msgstr ""
"En segundo lugar, la cadena de formato pasada a :c:func:`PyArg_ParseTuple` "
"o :c:func:`PyArg_ParseTupleAndKeywords` debe ser *exactamente* la misma que "
"la escrita a mano en la función existente, hasta los dos puntos o punto y "
"coma."

#: ../Doc/howto/clinic.rst:549
#, fuzzy
msgid ""
"Argument Clinic always generates its format strings with a ``:`` followed by "
"the name of the function. If the existing code's format string ends with ``;"
"``, to provide usage help, this change is harmless --- don't worry about it."
msgstr ""
"(Argument Clinic siempre genera sus cadenas de caracteres de formato con un "
"``:`` seguido del nombre de la función. Si la cadena de caracteres de "
"formato del código existente termina con ``;``, para proporcionar ayuda de "
"uso, este cambio es inofensivo; no se preocupe)"

#: ../Doc/howto/clinic.rst:554
#, fuzzy
msgid ""
"Third, for parameters whose format units require two arguments, like a "
"length variable, an encoding string, or a pointer to a conversion function, "
"ensure that the second argument is *exactly* the same between the two "
"invocations."
msgstr ""
"En tercer lugar, para los parámetros cuyas unidades de formato requieren dos "
"argumentos (como una variable de longitud, una cadena de codificación o un "
"puntero a una función de conversión), asegúrese de que el segundo argumento "
"sea *exactamente* el mismo entre las dos invocaciones."

#: ../Doc/howto/clinic.rst:559
#, fuzzy
msgid ""
"Fourth, inside the output portion of the block, you'll find a preprocessor "
"macro defining the appropriate static :c:type:`PyMethodDef` structure for "
"this builtin::"
msgstr ""
"En cuarto lugar, dentro de la parte de salida del bloque, encontrará una "
"macro de preprocesador que define la estructura static :c:type:`PyMethodDef` "
"apropiada para este incorporado::"

#: ../Doc/howto/clinic.rst:566
#, fuzzy
msgid ""
"This static structure should be *exactly* the same as the existing static :c:"
"type:`!PyMethodDef` structure for this builtin."
msgstr ""
"Esta estructura estática debe ser *exactamente* la misma que la estructura "
"estática existente :c:type:`PyMethodDef` para este incorporado."

#: ../Doc/howto/clinic.rst:569
msgid ""
"If any of these items differ in *any way*, adjust your Argument Clinic "
"function specification and rerun ``Tools/clinic/clinic.py`` until they *are* "
"the same."
msgstr ""
"Si alguno de estos elementos difiere *de alguna manera*, ajuste la "
"especificación de la función de Argument Clinic y vuelva a ejecutar ``Tools/"
"clinic/clinic.py`` hasta que *sean* iguales."

#: ../Doc/howto/clinic.rst:573
msgid ""
"Notice that the last line of its output is the declaration of your \"impl\" "
"function.  This is where the builtin's implementation goes. Delete the "
"existing prototype of the function you're modifying, but leave the opening "
"curly brace.  Now delete its argument parsing code and the declarations of "
"all the variables it dumps the arguments into. Notice how the Python "
"arguments are now arguments to this impl function; if the implementation "
"used different names for these variables, fix it."
msgstr ""
"Observe que la última línea de su salida es la declaración de su función "
"\"impl\". Aquí es donde va la implementación incorporada. Elimine el "
"prototipo existente de la función que está modificando, pero deje la llave "
"de apertura. Ahora elimine su código de análisis de argumentos y las "
"declaraciones de todas las variables en las que vierte los argumentos. "
"Observe cómo los argumentos de Python ahora son argumentos para esta función "
"implícita; si la implementación usó nombres diferentes para estas variables, "
"corríjalo."

#: ../Doc/howto/clinic.rst:581
#, fuzzy
msgid ""
"Let's reiterate, just because it's kind of weird. Your code should now look "
"like this::"
msgstr ""
"Reiteremos, solo porque es un poco extraño. Su código ahora debería verse "
"así::"

#: ../Doc/howto/clinic.rst:590
#, fuzzy
msgid ""
"Argument Clinic generated the checksum line and the function prototype just "
"above it.  You should write the opening and closing curly braces for the "
"function, and the implementation inside."
msgstr ""
"Argument Clinic generó la línea de suma de comprobación y el prototipo de "
"función justo encima de ella. Debe escribir las llaves de apertura (y "
"cierre) para la función y la implementación en el interior."

#: ../Doc/howto/clinic.rst:636
#, fuzzy
msgid ""
"Remember the macro with the :c:type:`PyMethodDef` structure for this "
"function? Find the existing :c:type:`!PyMethodDef` structure for this "
"function and replace it with a reference to the macro.  If the builtin is at "
"module scope, this will probably be very near the end of the file; if the "
"builtin is a class method, this will probably be below but relatively near "
"to the implementation."
msgstr ""
"¿Recuerda la macro con la estructura :c:type:`PyMethodDef` para esta "
"función? Busque la estructura existente :c:type:`PyMethodDef` para esta "
"función y la reemplaza con una referencia a la macro. (Si el incorporado "
"está en el alcance del módulo, esto probablemente estará muy cerca del final "
"del archivo; si el incorporado es un método de clase, probablemente estará "
"debajo pero relativamente cerca de la implementación)."

#: ../Doc/howto/clinic.rst:643
#, fuzzy
msgid ""
"Note that the body of the macro contains a trailing comma; when you replace "
"the existing static :c:type:`!PyMethodDef` structure with the macro, *don't* "
"add a comma to the end."
msgstr ""
"Tenga en cuenta que el cuerpo de la macro contiene una coma al final. "
"Entonces, cuando reemplace la estructura static :c:type:`PyMethodDef` "
"existente con la macro, *no* agregue una coma al final."

#: ../Doc/howto/clinic.rst:655
msgid "Argument Clinic may generate new instances of ``_Py_ID``. For example::"
msgstr ""

#: ../Doc/howto/clinic.rst:659
msgid ""
"If it does, you'll have to run ``make regen-global-objects`` to regenerate "
"the list of precompiled identifiers at this point."
msgstr ""

#: ../Doc/howto/clinic.rst:662
#, fuzzy
msgid ""
"Finally, compile, then run the relevant portions of the regression-test "
"suite. This change should not introduce any new compile-time warnings or "
"errors, and there should be no externally visible change to Python's "
"behavior, except for one difference: :py:func:`inspect.signature` run on "
"your function should now provide a valid signature!"
msgstr ""
"Compile y luego ejecute las partes relevantes del conjunto de pruebas de "
"regresión. Este cambio no debería introducir nuevas advertencias o errores "
"en tiempo de compilación, y no debería haber ningún cambio visible desde el "
"exterior en el comportamiento de Python."

#: ../Doc/howto/clinic.rst:668
msgid ""
"Congratulations, you've ported your first function to work with Argument "
"Clinic!"
msgstr ""
"¡Felicitaciones, ha adaptado su primera función para trabajar con Argument "
"Clinic!"

#: ../Doc/howto/clinic.rst:674
msgid "How-to guides"
msgstr ""

#: ../Doc/howto/clinic.rst:678
#, fuzzy
msgid "How to rename C functions and variables generated by Argument Clinic"
msgstr ""
"Cambiar el nombre de las funciones y variables C generadas por Argument "
"Clinic"

#: ../Doc/howto/clinic.rst:680
msgid ""
"Argument Clinic automatically names the functions it generates for you. "
"Occasionally this may cause a problem, if the generated name collides with "
"the name of an existing C function.  There's an easy solution: override the "
"names used for the C functions.  Just add the keyword ``\"as\"`` to your "
"function declaration line, followed by the function name you wish to use. "
"Argument Clinic will use that function name for the base (generated) "
"function, then add ``\"_impl\"`` to the end and use that for the name of the "
"impl function."
msgstr ""
"Argument Clinic nombra automáticamente las funciones que genera para usted. "
"Ocasionalmente, esto puede causar un problema, si el nombre generado choca "
"con el nombre de una función C existente. Hay una solución sencilla: anule "
"los nombres utilizados para las funciones de C. Simplemente agregue la "
"palabra clave ``\"as\"`` a la línea de declaración de su función, seguida "
"del nombre de la función que desea usar. Argument Clinic usará ese nombre de "
"función para la función base (generada), luego agregará ``\"_impl\"`` al "
"final y lo usará para el nombre de la función impl."

#: ../Doc/howto/clinic.rst:688
#, fuzzy
msgid ""
"For example, if we wanted to rename the C function names generated for :py:"
"meth:`pickle.Pickler.dump`, it'd look like this::"
msgstr ""
"Por ejemplo, si quisiéramos cambiar el nombre de las funciones de C "
"generadas para ``pickle.Pickler.dump``, se vería así::"

#: ../Doc/howto/clinic.rst:696
#, fuzzy
msgid ""
"The base function would now be named :c:func:`!pickler_dumper`, and the impl "
"function would now be named :c:func:`!pickler_dumper_impl`."
msgstr ""
"La función base ahora se llamaría ``pickler_dumper()``, y la función "
"implícita ahora se llamaría ``pickler_dumper_impl()``."

#: ../Doc/howto/clinic.rst:700
msgid ""
"Similarly, you may have a problem where you want to give a parameter a "
"specific Python name, but that name may be inconvenient in C.  Argument "
"Clinic allows you to give a parameter different names in Python and in C, "
"using the same ``\"as\"`` syntax::"
msgstr ""
"De manera similar, es posible que tenga un problema en el que desee asignar "
"un nombre específico de Python a un parámetro, pero ese nombre puede ser "
"inconveniente en C. Argument Clinic le permite asignar nombres diferentes a "
"un parámetro en Python y en C, usando el mismo ``\"as\"`` como sintaxis::"

#: ../Doc/howto/clinic.rst:714
#, fuzzy
msgid ""
"Here, the name used in Python (in the signature and the ``keywords`` array) "
"would be *file*, but the C variable would be named ``file_obj``."
msgstr ""
"Aquí, el nombre usado en Python (en la firma y el arreglo de ``keywords``) "
"sería ``file``, pero la variable C se llamaría ``file_obj``."

#: ../Doc/howto/clinic.rst:717
#, fuzzy
msgid "You can use this to rename the *self* parameter too!"
msgstr ""
"¡También puede usar esto para cambiar el nombre del parámetro ``self``!"

#: ../Doc/howto/clinic.rst:721
#, fuzzy
msgid "How to convert functions using ``PyArg_UnpackTuple``"
msgstr "Convirtiendo funciones usando PyArg_UnpackTuple"

#: ../Doc/howto/clinic.rst:723
#, fuzzy
msgid ""
"To convert a function parsing its arguments with :c:func:"
"`PyArg_UnpackTuple`, simply write out all the arguments, specifying each as "
"an ``object``.  You may specify the *type* argument to cast the type as "
"appropriate.  All arguments should be marked positional-only (add a ``/`` on "
"a line by itself after the last argument)."
msgstr ""
"Para convertir una función que analiza sus argumentos con :c:func:"
"`PyArg_UnpackTuple`, simplemente escribe todos los argumentos, especificando "
"cada uno como un ``object``. Puede especificar el argumento ``type`` para "
"convertir el tipo según corresponda. Todos los argumentos deben estar "
"marcados como solo posicionales (agregue un ``/`` en una línea después del "
"último argumento)."

#: ../Doc/howto/clinic.rst:729
msgid ""
"Currently the generated code will use :c:func:`PyArg_ParseTuple`, but this "
"will change soon."
msgstr ""
"Actualmente, el código generado usará :c:func:`PyArg_ParseTuple`, pero esto "
"cambiará pronto."

#: ../Doc/howto/clinic.rst:734
#, fuzzy
msgid "How to use optional groups"
msgstr "Grupos opcionales"

#: ../Doc/howto/clinic.rst:736
msgid ""
"Some legacy functions have a tricky approach to parsing their arguments: "
"they count the number of positional arguments, then use a ``switch`` "
"statement to call one of several different :c:func:`PyArg_ParseTuple` calls "
"depending on how many positional arguments there are.  (These functions "
"cannot accept keyword-only arguments.)  This approach was used to simulate "
"optional arguments back before :c:func:`PyArg_ParseTupleAndKeywords` was "
"created."
msgstr ""
"Algunas funciones heredadas tienen un enfoque complicado para analizar sus "
"argumentos: cuentan el número de argumentos posicionales, luego usan una "
"instrucción ``switch`` para llamar a una de varias llamadas diferentes :c:"
"func:`PyArg_ParseTuple` dependiendo de cuántos argumentos posicionales "
"existen. (Estas funciones no pueden aceptar argumentos de solo palabras "
"clave). Este enfoque se usó para simular argumentos opcionales antes de que "
"se creara :c:func:`PyArg_ParseTupleAndKeywords`."

#: ../Doc/howto/clinic.rst:743
#, fuzzy
msgid ""
"While functions using this approach can often be converted to use :c:func:`!"
"PyArg_ParseTupleAndKeywords`, optional arguments, and default values, it's "
"not always possible.  Some of these legacy functions have behaviors :c:func:"
"`!PyArg_ParseTupleAndKeywords` doesn't directly support. The most obvious "
"example is the builtin function :py:func:`range`, which has an optional "
"argument on the *left* side of its required argument! Another example is :py:"
"meth:`curses.window.addch`, which has a group of two arguments that must "
"always be specified together.  (The arguments are called *x* and *y*; if you "
"call the function passing in *x*, you must also pass in *y* — and if you "
"don't pass in *x* you may not pass in *y* either.)"
msgstr ""
"Si bien las funciones que utilizan este enfoque a menudo se pueden convertir "
"para usar :c:func:`PyArg_ParseTupleAndKeywords`, argumentos opcionales y "
"valores predeterminados, no siempre es posible. Algunas de estas funciones "
"heredadas tienen comportamientos :c:func:`PyArg_ParseTupleAndKeywords` no "
"admite directamente. El ejemplo más obvio es la función incorporada "
"``range()``, que tiene un argumento opcional en el lado *izquierdo* de su "
"argumento requerido. Otro ejemplo es ``curses.window.addch()``, que tiene un "
"grupo de dos argumentos que siempre deben especificarse juntos. (Los "
"argumentos se denominan ``x`` e ``y``; si llama a la función pasando ``x``, "
"también debe pasar ``y``, y si no pasa ``x`` tampoco puede pasar ``y``.)"

#: ../Doc/howto/clinic.rst:755
msgid ""
"In any case, the goal of Argument Clinic is to support argument parsing for "
"all existing CPython builtins without changing their semantics. Therefore "
"Argument Clinic supports this alternate approach to parsing, using what are "
"called *optional groups*. Optional groups are groups of arguments that must "
"all be passed in together. They can be to the left or the right of the "
"required arguments.  They can *only* be used with positional-only parameters."
msgstr ""
"En cualquier caso, el objetivo de Argument Clinic es admitir el análisis de "
"argumentos para todas las incorporaciones CPython existentes sin cambiar su "
"semántica. Por lo tanto, Argument Clinic admite este enfoque alternativo de "
"análisis, utilizando lo que se denominan *grupos opcionales*. Los grupos "
"opcionales son grupos de argumentos que deben pasarse todos juntos. Pueden "
"estar a la izquierda o la derecha de los argumentos requeridos. *Solo* se "
"pueden usar con parámetros de solo posición."

#: ../Doc/howto/clinic.rst:763
msgid ""
"Optional groups are *only* intended for use when converting functions that "
"make multiple calls to :c:func:`PyArg_ParseTuple`! Functions that use *any* "
"other approach for parsing arguments should *almost never* be converted to "
"Argument Clinic using optional groups.  Functions using optional groups "
"currently cannot have accurate signatures in Python, because Python just "
"doesn't understand the concept.  Please avoid using optional groups wherever "
"possible."
msgstr ""
"Los grupos opcionales *solo* están pensados para su uso al convertir "
"funciones que realizan múltiples llamadas a :c:func:`PyArg_ParseTuple`! Las "
"funciones que usan *cualquier* otro enfoque para analizar argumentos deben "
"*casi nunca* convertirse a Argument Clinic usando grupos opcionales. Las "
"funciones que utilizan grupos opcionales actualmente no pueden tener firmas "
"precisas en Python, porque Python simplemente no comprende el concepto. "
"Evite el uso de grupos opcionales siempre que sea posible."

#: ../Doc/howto/clinic.rst:772
#, fuzzy
msgid ""
"To specify an optional group, add a ``[`` on a line by itself before the "
"parameters you wish to group together, and a ``]`` on a line by itself after "
"these parameters.  As an example, here's how :py:meth:`curses.window.addch` "
"uses optional groups to make the first two parameters and the last parameter "
"optional::"
msgstr ""
"Para especificar un grupo opcional, agregue un ``[`` en una línea antes de "
"los parámetros que desea agrupar y un ``]`` en una línea después de estos "
"parámetros. Como ejemplo, así es como ``curses.window.addch`` usa grupos "
"opcionales para hacer que los primeros dos parámetros y el último parámetro "
"sean opcionales::"

#: ../Doc/howto/clinic.rst:801
msgid "Notes:"
msgstr "Notas:"

#: ../Doc/howto/clinic.rst:803
msgid ""
"For every optional group, one additional parameter will be passed into the "
"impl function representing the group.  The parameter will be an int named "
"``group_{direction}_{number}``, where ``{direction}`` is either ``right`` or "
"``left`` depending on whether the group is before or after the required "
"parameters, and ``{number}`` is a monotonically increasing number (starting "
"at 1) indicating how far away the group is from the required parameters.  "
"When the impl is called, this parameter will be set to zero if this group "
"was unused, and set to non-zero if this group was used. (By used or unused, "
"I mean whether or not the parameters received arguments in this invocation.)"
msgstr ""
"Para cada grupo opcional, se pasará un parámetro adicional a la función "
"*impl* que representa al grupo. El parámetro será un int llamado "
"``grupo_{direction}_{number}``, donde ``{direction}`` es ``right`` o "
"``left`` dependiendo de si el grupo está antes o después los parámetros "
"requeridos, y ``{number}`` es un número que aumenta monótonamente "
"(comenzando en 1) que indica qué tan lejos está el grupo de los parámetros "
"requeridos. Cuando se llama a impl, este parámetro se establecerá en cero si "
"este grupo no se usó, y se establecerá en un valor distinto de cero si se "
"usó este grupo. (Por usado o no usado, me refiero a si los parámetros "
"recibieron argumentos en esta invocación)."

#: ../Doc/howto/clinic.rst:814
msgid ""
"If there are no required arguments, the optional groups will behave as if "
"they're to the right of the required arguments."
msgstr ""
"Si no hay argumentos requeridos, los grupos opcionales se comportarán como "
"si estuvieran a la derecha de los argumentos requeridos."

#: ../Doc/howto/clinic.rst:817
msgid ""
"In the case of ambiguity, the argument parsing code favors parameters on the "
"left (before the required parameters)."
msgstr ""
"En el caso de ambigüedad, el código de análisis de argumentos favorece los "
"parámetros de la izquierda (antes de los parámetros requeridos)."

#: ../Doc/howto/clinic.rst:820
msgid "Optional groups can only contain positional-only parameters."
msgstr "Los grupos opcionales solo pueden contener parámetros posicionales."

#: ../Doc/howto/clinic.rst:822
msgid ""
"Optional groups are *only* intended for legacy code.  Please do not use "
"optional groups for new code."
msgstr ""
"Los grupos opcionales son *solo* destinados al código heredado. No utilice "
"grupos opcionales para el código nuevo."

#: ../Doc/howto/clinic.rst:827
#, fuzzy
msgid ""
"How to use real Argument Clinic converters, instead of \"legacy converters\""
msgstr ""
"Usar convertidores de Argument Clinic reales, en lugar de \"convertidores "
"heredados\""

#: ../Doc/howto/clinic.rst:829
msgid ""
"To save time, and to minimize how much you need to learn to achieve your "
"first port to Argument Clinic, the walkthrough above tells you to use "
"\"legacy converters\".  \"Legacy converters\" are a convenience, designed "
"explicitly to make porting existing code to Argument Clinic easier.  And to "
"be clear, their use is acceptable when porting code for Python 3.4."
msgstr ""
"Para ahorrar tiempo y minimizar cuánto necesita aprender para lograr su "
"primer puerto a Argument Clinic, el tutorial anterior le indica que use "
"\"convertidores heredados\". Los \"convertidores heredados\" son una "
"conveniencia, diseñados explícitamente para facilitar la migración del "
"código existente a Argument Clinic. Y para ser claros, su uso es aceptable "
"al portar código para Python 3.4."

#: ../Doc/howto/clinic.rst:836
msgid ""
"However, in the long term we probably want all our blocks to use Argument "
"Clinic's real syntax for converters.  Why?  A couple reasons:"
msgstr ""
"Sin embargo, a largo plazo probablemente queramos que todos nuestros bloques "
"utilicen la sintaxis real de Argument Clinic para los convertidores. ¿Por "
"qué? Un par de razones:"

#: ../Doc/howto/clinic.rst:840
msgid ""
"The proper converters are far easier to read and clearer in their intent."
msgstr ""
"Los convertidores adecuados son mucho más fáciles de leer y más claros en su "
"intención."

#: ../Doc/howto/clinic.rst:841
msgid ""
"There are some format units that are unsupported as \"legacy converters\", "
"because they require arguments, and the legacy converter syntax doesn't "
"support specifying arguments."
msgstr ""
"Hay algunas unidades de formato que no se admiten como \"convertidores "
"heredados\", porque requieren argumentos y la sintaxis del convertidor "
"heredado no admite la especificación de argumentos."

#: ../Doc/howto/clinic.rst:844
msgid ""
"In the future we may have a new argument parsing library that isn't "
"restricted to what :c:func:`PyArg_ParseTuple` supports; this flexibility "
"won't be available to parameters using legacy converters."
msgstr ""
"En el futuro, es posible que tengamos una nueva biblioteca de análisis de "
"argumentos que no esté restringida a lo que :c:func:`PyArg_ParseTuple` "
"admite; esta flexibilidad no estará disponible para los parámetros que "
"utilizan convertidores heredados."

#: ../Doc/howto/clinic.rst:848
msgid ""
"Therefore, if you don't mind a little extra effort, please use the normal "
"converters instead of legacy converters."
msgstr ""
"Por lo tanto, si no le importa un poco de esfuerzo adicional, utilice los "
"convertidores normales en lugar de los convertidores heredados."

#: ../Doc/howto/clinic.rst:851
msgid ""
"In a nutshell, the syntax for Argument Clinic (non-legacy) converters looks "
"like a Python function call.  However, if there are no explicit arguments to "
"the function (all functions take their default values), you may omit the "
"parentheses.  Thus ``bool`` and ``bool()`` are exactly the same converters."
msgstr ""
"En pocas palabras, la sintaxis de los convertidores de Argument Clinic (no "
"heredados) parece una llamada a una función de Python. Sin embargo, si no "
"hay argumentos explícitos para la función (todas las funciones toman sus "
"valores predeterminados), puede omitir los paréntesis. Por tanto, ``bool`` y "
"``bool()`` son exactamente los mismos convertidores."

#: ../Doc/howto/clinic.rst:857
msgid ""
"All arguments to Argument Clinic converters are keyword-only. All Argument "
"Clinic converters accept the following arguments:"
msgstr ""
"Todos los argumentos para los convertidores de Argument Clinic son solo de "
"palabras clave. Todos los convertidores de Argument Clinic aceptan los "
"siguientes argumentos:"

#: ../Doc/howto/clinic.rst:865
#, fuzzy
msgid "*c_default*"
msgstr "``c_default``"

#: ../Doc/howto/clinic.rst:861
msgid ""
"The default value for this parameter when defined in C. Specifically, this "
"will be the initializer for the variable declared in the \"parse "
"function\".  See :ref:`the section on default values <default_values>` for "
"how to use this. Specified as a string."
msgstr ""
"El valor predeterminado para este parámetro cuando se define en C. "
"Específicamente, será el inicializador de la variable declarada en la "
"\"función de análisis\". Consulte :ref:`la sección sobre valores "
"predeterminados <default_values>` para saber cómo usar esto. Especificado "
"como una cadena de caracteres."

#: ../Doc/howto/clinic.rst:870
#, fuzzy
msgid "*annotation*"
msgstr "``annotation``"

#: ../Doc/howto/clinic.rst:868
msgid ""
"The annotation value for this parameter.  Not currently supported, because :"
"pep:`8` mandates that the Python library may not use annotations."
msgstr ""
"El valor de anotación para este parámetro. Actualmente no es compatible, "
"porque :pep:`8` exige que la biblioteca de Python no use anotaciones."

#: ../Doc/howto/clinic.rst:873
msgid "*unused*"
msgstr ""

#: ../Doc/howto/clinic.rst:873
msgid ""
"Wrap the argument with :c:macro:`Py_UNUSED` in the impl function signature."
msgstr ""

#: ../Doc/howto/clinic.rst:875
msgid ""
"In addition, some converters accept additional arguments.  Here is a list of "
"these arguments, along with their meanings:"
msgstr ""
"Además, algunos convertidores aceptan argumentos adicionales. Aquí hay una "
"lista de estos argumentos, junto con sus significados:"

#: ../Doc/howto/clinic.rst:884
#, fuzzy
msgid "*accept*"
msgstr "``accept``"

#: ../Doc/howto/clinic.rst:879
msgid ""
"A set of Python types (and possibly pseudo-types); this restricts the "
"allowable Python argument to values of these types. (This is not a general-"
"purpose facility; as a rule it only supports specific lists of types as "
"shown in the legacy converter table.)"
msgstr ""
"Un conjunto de tipos de Python (y posiblemente pseudo-tipos); esto restringe "
"el argumento permitido de Python a valores de estos tipos. (Esta no es una "
"infraestructura de propósito general; por regla general, solo admite listas "
"específicas de tipos como se muestra en la tabla de convertidores heredados)."

#: ../Doc/howto/clinic.rst:884
msgid "To accept ``None``, add ``NoneType`` to this set."
msgstr "Para aceptar ``None``, agregue ``NoneType`` a este conjunto."

#: ../Doc/howto/clinic.rst:889
#, fuzzy
msgid "*bitwise*"
msgstr "``bitwise``"

#: ../Doc/howto/clinic.rst:887
msgid ""
"Only supported for unsigned integers.  The native integer value of this "
"Python argument will be written to the parameter without any range checking, "
"even for negative values."
msgstr ""
"Solo se admite para enteros sin signo. El valor entero nativo de este "
"argumento de Python se escribirá en el parámetro sin ninguna verificación de "
"rango, incluso para valores negativos."

#: ../Doc/howto/clinic.rst:894
#, fuzzy
msgid "*converter*"
msgstr "``converter``"

#: ../Doc/howto/clinic.rst:892
msgid ""
"Only supported by the ``object`` converter.  Specifies the name of a :ref:`C "
"\"converter function\" <o_ampersand>` to use to convert this object to a "
"native type."
msgstr ""
"Solo compatible con el convertidor de ``objetos``. Especifica el nombre de "
"una :ref:`\"función de conversión\" C <o_ampersand>` para convertir este "
"objeto en un tipo nativo."

#: ../Doc/howto/clinic.rst:899
#, fuzzy
msgid "*encoding*"
msgstr "``encoding``"

#: ../Doc/howto/clinic.rst:897
msgid ""
"Only supported for strings.  Specifies the encoding to use when converting "
"this string from a Python str (Unicode) value into a C ``char *`` value."
msgstr ""
"Solo compatible con cadenas de caracteres. Especifica la codificación que se "
"utilizará al convertir esta cadena de un valor Python str (Unicode) en un "
"valor ``char *`` de C."

#: ../Doc/howto/clinic.rst:903
#, fuzzy
msgid "*subclass_of*"
msgstr "``subclass_of``"

#: ../Doc/howto/clinic.rst:902
msgid ""
"Only supported for the ``object`` converter.  Requires that the Python value "
"be a subclass of a Python type, as expressed in C."
msgstr ""
"Solo compatible con el convertidor de ``objetos``. Requiere que el valor de "
"Python sea una subclase de un tipo de Python, como se expresa en C."

#: ../Doc/howto/clinic.rst:908
msgid "*type*"
msgstr ""

#: ../Doc/howto/clinic.rst:906
msgid ""
"Only supported for the ``object`` and ``self`` converters.  Specifies the C "
"type that will be used to declare the variable.  Default value is "
"``\"PyObject *\"``."
msgstr ""
"Solo compatible con los convertidores de ``object`` y ``self``. Especifica "
"el tipo C que se utilizará para declarar la variable. El valor "
"predeterminado es ``\"PyObject *\"``."

#: ../Doc/howto/clinic.rst:914
#, fuzzy
msgid "*zeroes*"
msgstr "``zeroes``"

#: ../Doc/howto/clinic.rst:911
msgid ""
"Only supported for strings.  If true, embedded NUL bytes (``'\\\\0'``) are "
"permitted inside the value.  The length of the string will be passed in to "
"the impl function, just after the string parameter, as a parameter named "
"``<parameter_name>_length``."
msgstr ""
"Solo compatible con cadenas. Si es verdadero, se permiten bytes NUL "
"incrustados (``'\\\\0'``) dentro del valor. La longitud de la cadena se "
"pasará a la función impl, justo después del parámetro de cadena, como un "
"parámetro llamado ``<parameter_name>_length``."

#: ../Doc/howto/clinic.rst:916
#, fuzzy
msgid ""
"Please note, not every possible combination of arguments will work. Usually "
"these arguments are implemented by specific :c:func:`PyArg_ParseTuple` "
"*format units*, with specific behavior.  For example, currently you cannot "
"call ``unsigned_short`` without also specifying ``bitwise=True``. Although "
"it's perfectly reasonable to think this would work, these semantics don't "
"map to any existing format unit.  So Argument Clinic doesn't support it.  "
"(Or, at least, not yet.)"
msgstr ""
"Tenga en cuenta que no todas las combinaciones posibles de argumentos "
"funcionarán. Por lo general, estos argumentos se implementan mediante "
"*unidades de formato* ``PyArg_ParseTuple`` específicas, con un "
"comportamiento específico. Por ejemplo, actualmente no puede llamar a "
"``unsigned_short`` sin especificar también ``bitwise=True``. Aunque es "
"perfectamente razonable pensar que esto funcionaría, esta semántica no se "
"asigna a ninguna unidad de formato existente. Entonces, Argument Clinic no "
"lo admite. (O, al menos, todavía no)."

#: ../Doc/howto/clinic.rst:924
msgid ""
"Below is a table showing the mapping of legacy converters into real Argument "
"Clinic converters.  On the left is the legacy converter, on the right is the "
"text you'd replace it with."
msgstr ""
"A continuación se muestra una tabla que muestra el mapeo de convertidores "
"heredados en convertidores de Argument Clinic reales. A la izquierda está el "
"convertidor heredado, a la derecha está el texto con el que lo reemplazaría."

#: ../Doc/howto/clinic.rst:929
msgid "``'B'``"
msgstr "``'B'``"

#: ../Doc/howto/clinic.rst:929
msgid "``unsigned_char(bitwise=True)``"
msgstr "``unsigned_char(bitwise=True)``"

#: ../Doc/howto/clinic.rst:930
msgid "``'b'``"
msgstr "``'b'``"

#: ../Doc/howto/clinic.rst:930
msgid "``unsigned_char``"
msgstr "``unsigned_char``"

#: ../Doc/howto/clinic.rst:931
msgid "``'c'``"
msgstr "``'c'``"

#: ../Doc/howto/clinic.rst:931
msgid "``char``"
msgstr "``char``"

#: ../Doc/howto/clinic.rst:932
msgid "``'C'``"
msgstr "``'C'``"

#: ../Doc/howto/clinic.rst:932
msgid "``int(accept={str})``"
msgstr "``int(accept={str})``"

#: ../Doc/howto/clinic.rst:933
msgid "``'d'``"
msgstr "``'d'``"

#: ../Doc/howto/clinic.rst:933
msgid "``double``"
msgstr "``double``"

#: ../Doc/howto/clinic.rst:934
msgid "``'D'``"
msgstr "``'D'``"

#: ../Doc/howto/clinic.rst:934
msgid "``Py_complex``"
msgstr "``Py_complex``"

#: ../Doc/howto/clinic.rst:935
msgid "``'es'``"
msgstr "``'es'``"

#: ../Doc/howto/clinic.rst:935
msgid "``str(encoding='name_of_encoding')``"
msgstr "``str(encoding='name_of_encoding')``"

#: ../Doc/howto/clinic.rst:936
msgid "``'es#'``"
msgstr "``'es#'``"

#: ../Doc/howto/clinic.rst:936
msgid "``str(encoding='name_of_encoding', zeroes=True)``"
msgstr "``str(encoding='name_of_encoding', zeroes=True)``"

#: ../Doc/howto/clinic.rst:937
msgid "``'et'``"
msgstr "``'et'``"

#: ../Doc/howto/clinic.rst:937
msgid "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"
msgstr "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"

#: ../Doc/howto/clinic.rst:938
msgid "``'et#'``"
msgstr "``'et#'``"

#: ../Doc/howto/clinic.rst:938
msgid ""
"``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
"zeroes=True)``"
msgstr ""
"``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
"zeroes=True)``"

#: ../Doc/howto/clinic.rst:939
msgid "``'f'``"
msgstr "``'f'``"

#: ../Doc/howto/clinic.rst:939
msgid "``float``"
msgstr "``float``"

#: ../Doc/howto/clinic.rst:940
msgid "``'h'``"
msgstr "``'h'``"

#: ../Doc/howto/clinic.rst:940
msgid "``short``"
msgstr "``short``"

#: ../Doc/howto/clinic.rst:941
msgid "``'H'``"
msgstr "``'H'``"

#: ../Doc/howto/clinic.rst:941
msgid "``unsigned_short(bitwise=True)``"
msgstr "``unsigned_short(bitwise=True)``"

#: ../Doc/howto/clinic.rst:942
msgid "``'i'``"
msgstr "``'i'``"

#: ../Doc/howto/clinic.rst:942
msgid "``int``"
msgstr "``int``"

#: ../Doc/howto/clinic.rst:943
msgid "``'I'``"
msgstr "``'I'``"

#: ../Doc/howto/clinic.rst:943
msgid "``unsigned_int(bitwise=True)``"
msgstr "``unsigned_int(bitwise=True)``"

#: ../Doc/howto/clinic.rst:944
msgid "``'k'``"
msgstr "``'k'``"

#: ../Doc/howto/clinic.rst:944
msgid "``unsigned_long(bitwise=True)``"
msgstr "``unsigned_long(bitwise=True)``"

#: ../Doc/howto/clinic.rst:945
msgid "``'K'``"
msgstr "``'K'``"

#: ../Doc/howto/clinic.rst:945
msgid "``unsigned_long_long(bitwise=True)``"
msgstr "``unsigned_long_long(bitwise=True)``"

#: ../Doc/howto/clinic.rst:946
msgid "``'l'``"
msgstr "``'l'``"

#: ../Doc/howto/clinic.rst:946
msgid "``long``"
msgstr "``long``"

#: ../Doc/howto/clinic.rst:947
msgid "``'L'``"
msgstr "``'L'``"

#: ../Doc/howto/clinic.rst:947
msgid "``long long``"
msgstr "``long long``"

#: ../Doc/howto/clinic.rst:948
msgid "``'n'``"
msgstr "``'n'``"

#: ../Doc/howto/clinic.rst:948
msgid "``Py_ssize_t``"
msgstr "``Py_ssize_t``"

#: ../Doc/howto/clinic.rst:949
msgid "``'O'``"
msgstr "``'O'``"

#: ../Doc/howto/clinic.rst:949
msgid "``object``"
msgstr "``object``"

#: ../Doc/howto/clinic.rst:950
msgid "``'O!'``"
msgstr "``'O!'``"

#: ../Doc/howto/clinic.rst:950
msgid "``object(subclass_of='&PySomething_Type')``"
msgstr "``object(subclass_of='&PySomething_Type')``"

#: ../Doc/howto/clinic.rst:951
msgid "``'O&'``"
msgstr "``'O&'``"

#: ../Doc/howto/clinic.rst:951
msgid "``object(converter='name_of_c_function')``"
msgstr "``object(converter='name_of_c_function')``"

#: ../Doc/howto/clinic.rst:952
msgid "``'p'``"
msgstr "``'p'``"

#: ../Doc/howto/clinic.rst:952
msgid "``bool``"
msgstr "``bool``"

#: ../Doc/howto/clinic.rst:953
msgid "``'S'``"
msgstr "``'S'``"

#: ../Doc/howto/clinic.rst:953
msgid "``PyBytesObject``"
msgstr "``PyBytesObject``"

#: ../Doc/howto/clinic.rst:954
msgid "``'s'``"
msgstr "``'s'``"

#: ../Doc/howto/clinic.rst:954
msgid "``str``"
msgstr "``str``"

#: ../Doc/howto/clinic.rst:955
msgid "``'s#'``"
msgstr "``'s#'``"

#: ../Doc/howto/clinic.rst:955
msgid "``str(zeroes=True)``"
msgstr "``str(zeroes=True)``"

#: ../Doc/howto/clinic.rst:956
msgid "``'s*'``"
msgstr "``'s*'``"

#: ../Doc/howto/clinic.rst:956
msgid "``Py_buffer(accept={buffer, str})``"
msgstr "``Py_buffer(accept={buffer, str})``"

#: ../Doc/howto/clinic.rst:957
msgid "``'U'``"
msgstr "``'U'``"

#: ../Doc/howto/clinic.rst:957
msgid "``unicode``"
msgstr "``unicode``"

#: ../Doc/howto/clinic.rst:958
msgid "``'u'``"
msgstr "``'u'``"

#: ../Doc/howto/clinic.rst:958
#, fuzzy
msgid "``wchar_t``"
msgstr "``char``"

#: ../Doc/howto/clinic.rst:959
msgid "``'u#'``"
msgstr "``'u#'``"

#: ../Doc/howto/clinic.rst:959
#, fuzzy
msgid "``wchar_t(zeroes=True)``"
msgstr "``str(zeroes=True)``"

#: ../Doc/howto/clinic.rst:960
msgid "``'w*'``"
msgstr "``'w*'``"

#: ../Doc/howto/clinic.rst:960
msgid "``Py_buffer(accept={rwbuffer})``"
msgstr "``Py_buffer(accept={rwbuffer})``"

#: ../Doc/howto/clinic.rst:961
msgid "``'Y'``"
msgstr "``'Y'``"

#: ../Doc/howto/clinic.rst:961
msgid "``PyByteArrayObject``"
msgstr "``PyByteArrayObject``"

#: ../Doc/howto/clinic.rst:962
msgid "``'y'``"
msgstr "``'y'``"

#: ../Doc/howto/clinic.rst:962
msgid "``str(accept={bytes})``"
msgstr "``str(accept={bytes})``"

#: ../Doc/howto/clinic.rst:963
msgid "``'y#'``"
msgstr "``'y#'``"

#: ../Doc/howto/clinic.rst:963
msgid "``str(accept={robuffer}, zeroes=True)``"
msgstr "``str(accept={robuffer}, zeroes=True)``"

#: ../Doc/howto/clinic.rst:964
msgid "``'y*'``"
msgstr "``'y*'``"

#: ../Doc/howto/clinic.rst:964
msgid "``Py_buffer``"
msgstr "``Py_buffer``"

#: ../Doc/howto/clinic.rst:965
msgid "``'Z'``"
msgstr "``'Z'``"

#: ../Doc/howto/clinic.rst:965
#, fuzzy
msgid "``wchar_t(accept={str, NoneType})``"
msgstr "``str(accept={str, NoneType})``"

#: ../Doc/howto/clinic.rst:966
msgid "``'Z#'``"
msgstr "``'Z#'``"

#: ../Doc/howto/clinic.rst:966
#, fuzzy
msgid "``wchar_t(accept={str, NoneType}, zeroes=True)``"
msgstr "``str(accept={str, NoneType}, zeroes=True)``"

#: ../Doc/howto/clinic.rst:967
msgid "``'z'``"
msgstr "``'z'``"

#: ../Doc/howto/clinic.rst:967
msgid "``str(accept={str, NoneType})``"
msgstr "``str(accept={str, NoneType})``"

#: ../Doc/howto/clinic.rst:968
msgid "``'z#'``"
msgstr "``'z#'``"

#: ../Doc/howto/clinic.rst:968
msgid "``str(accept={str, NoneType}, zeroes=True)``"
msgstr "``str(accept={str, NoneType}, zeroes=True)``"

#: ../Doc/howto/clinic.rst:969
msgid "``'z*'``"
msgstr "``'z*'``"

#: ../Doc/howto/clinic.rst:969
msgid "``Py_buffer(accept={buffer, str, NoneType})``"
msgstr "``Py_buffer(accept={buffer, str, NoneType})``"

#: ../Doc/howto/clinic.rst:972
msgid ""
"As an example, here's our sample ``pickle.Pickler.dump`` using the proper "
"converter::"
msgstr ""
"Como ejemplo, aquí está nuestra muestra ``pickle.Pickler.dump`` usando el "
"convertidor adecuado::"

#: ../Doc/howto/clinic.rst:985
msgid ""
"One advantage of real converters is that they're more flexible than legacy "
"converters.  For example, the ``unsigned_int`` converter (and all the "
"``unsigned_`` converters) can be specified without ``bitwise=True``.  Their "
"default behavior performs range checking on the value, and they won't accept "
"negative numbers.  You just can't do that with a legacy converter!"
msgstr ""
"Una ventaja de los convertidores reales es que son más flexibles que los "
"convertidores heredados. Por ejemplo, el convertidor ``unsigned_int`` (y "
"todos los convertidores ``unsigned_``) se pueden especificar sin "
"``bitwise=True``. Su comportamiento predeterminado realiza una verificación "
"de rango en el valor y no aceptarán números negativos. ¡No puedes hacer eso "
"con un convertidor heredado!"

#: ../Doc/howto/clinic.rst:991
msgid ""
"Argument Clinic will show you all the converters it has available.  For each "
"converter it'll show you all the parameters it accepts, along with the "
"default value for each parameter. Just run ``Tools/clinic/clinic.py --"
"converters`` to see the full list."
msgstr ""
"Argument Clinic le mostrará todos los convertidores que tiene disponibles. "
"Para cada convertidor, le mostrará todos los parámetros que acepta, junto "
"con el valor predeterminado para cada parámetro. Simplemente ejecute ``Tools/"
"clinic/clinic.py --converters`` para ver la lista completa."

#: ../Doc/howto/clinic.rst:998
msgid "How to use the ``Py_buffer`` converter"
msgstr ""

#: ../Doc/howto/clinic.rst:1000
msgid ""
"When using the ``Py_buffer`` converter (or the ``'s*'``, ``'w*'``, ``'*y'``, "
"or ``'z*'`` legacy converters), you *must* not call :c:func:"
"`PyBuffer_Release` on the provided buffer. Argument Clinic generates code "
"that does it for you (in the parsing function)."
msgstr ""
"Cuando se utiliza el convertidor ``Py_buffer`` (o los convertidores "
"heredados ``'s*'``, ``'w*'``, ``'*y'`` o ``'z*'`` ), *no* debes llamar a :c:"
"func:`PyBuffer_Release` en el búfer provisto. Argument Clinic genera código "
"que lo hace por usted (en la función de análisis)."

#: ../Doc/howto/clinic.rst:1009
#, fuzzy
msgid "How to use advanced converters"
msgstr "Convertidores avanzados"

#: ../Doc/howto/clinic.rst:1011
msgid ""
"Remember those format units you skipped for your first time because they "
"were advanced?  Here's how to handle those too."
msgstr ""
"¿Recuerda esas unidades de formato que omitió por primera vez porque eran "
"avanzadas? Aquí le mostramos cómo manejarlas también."

#: ../Doc/howto/clinic.rst:1014
#, fuzzy
msgid ""
"The trick is, all those format units take arguments—either conversion "
"functions, or types, or strings specifying an encoding. (But \"legacy "
"converters\" don't support arguments.  That's why we skipped them for your "
"first function.)  The argument you specified to the format unit is now an "
"argument to the converter; this argument is either *converter* (for ``O&``), "
"*subclass_of* (for ``O!``), or *encoding* (for all the format units that "
"start with ``e``)."
msgstr ""
"El truco es que todas esas unidades de formato toman argumentos, ya sean "
"funciones de conversión o tipos, o cadenas que especifican una codificación. "
"(Pero los \"convertidores heredados\" no admiten argumentos. Por eso los "
"omitimos para su primera función). El argumento que especificó para la "
"unidad de formato ahora es un argumento para el convertidor; este argumento "
"es ``converter`` (para ``O&``), ``subclass_of`` (para ``O!``) o ``encoding`` "
"(para todas las unidades de formato que comienzan con ``e``)."

#: ../Doc/howto/clinic.rst:1022
#, fuzzy
msgid ""
"When using *subclass_of*, you may also want to use the other custom argument "
"for ``object()``: *type*, which lets you set the type actually used for the "
"parameter.  For example, if you want to ensure that the object is a subclass "
"of :c:var:`PyUnicode_Type`, you probably want to use the converter "
"``object(type='PyUnicodeObject *', subclass_of='&PyUnicode_Type')``."
msgstr ""
"Al usar ``subclass_of``, es posible que también desee usar el otro argumento "
"personalizado para ``object()``: ``type``, que le permite establecer el tipo "
"que realmente se usa para el parámetro. Por ejemplo, si desea asegurarse de "
"que el objeto es una subclase de ``PyUnicode_Type``, probablemente desee "
"utilizar el convertidor ``object(type='PyUnicodeObject *', "
"subclass_of='&PyUnicode_Type')``."

#: ../Doc/howto/clinic.rst:1028
#, fuzzy
msgid ""
"One possible problem with using Argument Clinic: it takes away some possible "
"flexibility for the format units starting with ``e``.  When writing a :c:"
"func:`!PyArg_Parse*` call by hand, you could theoretically decide at runtime "
"what encoding string to pass to that call.   But now this string must be "
"hard-coded at Argument-Clinic-preprocessing-time.  This limitation is "
"deliberate; it made supporting this format unit much easier, and may allow "
"for future optimizations. This restriction doesn't seem unreasonable; "
"CPython itself always passes in static hard-coded encoding strings for "
"parameters whose format units start with ``e``."
msgstr ""
"Un posible problema con el uso de Argument Clinic: elimina cierta "
"flexibilidad posible para las unidades de formato que comienzan con ``e``. "
"Al escribir una llamada ``PyArg_Parse`` a mano, teóricamente podrías decidir "
"en tiempo de ejecución qué cadena de codificación pasar a :c:func:"
"`PyArg_ParseTuple`. Pero ahora esta cadena debe estar codificada en tiempo "
"de preprocesamiento de Argument-Clinic. Esta limitación es deliberada; hizo "
"que el soporte de esta unidad de formato fuera mucho más fácil y puede "
"permitir futuras optimizaciones. Esta restricción no parece irrazonable; el "
"propio CPython siempre pasa cadenas de codificación estáticas codificadas "
"para parámetros cuyas unidades de formato comienzan con ``e``."

#: ../Doc/howto/clinic.rst:1042
msgid "How to assign default values to parameter"
msgstr ""

#: ../Doc/howto/clinic.rst:1044
msgid ""
"Default values for parameters can be any of a number of values. At their "
"simplest, they can be string, int, or float literals:"
msgstr ""
"Los valores predeterminados de los parámetros pueden ser cualquiera de "
"varios valores. En su forma más simple, pueden ser literales string, int o "
"float:"

#: ../Doc/howto/clinic.rst:1053
msgid "They can also use any of Python's built-in constants:"
msgstr ""
"También pueden usar cualquiera de las constantes incorporadas de Python:"

#: ../Doc/howto/clinic.rst:1061
msgid ""
"There's also special support for a default value of ``NULL``, and for simple "
"expressions, documented in the following sections."
msgstr ""
"También hay soporte especial para un valor predeterminado de ``NULL`` y para "
"expresiones simples, documentadas en las siguientes secciones."

#: ../Doc/howto/clinic.rst:1066
msgid "The ``NULL`` default value"
msgstr "El valor predeterminado ``NULL``"

#: ../Doc/howto/clinic.rst:1068
msgid ""
"For string and object parameters, you can set them to ``None`` to indicate "
"that there's no default.  However, that means the C variable will be "
"initialized to ``Py_None``.  For convenience's sakes, there's a special "
"value called ``NULL`` for just this reason: from Python's perspective it "
"behaves like a default value of ``None``, but the C variable is initialized "
"with ``NULL``."
msgstr ""
"Para los parámetros de cadena de caracteres y objeto, puede establecerlos en "
"``None`` para indicar que no hay ningún valor predeterminado. Sin embargo, "
"eso significa que la variable C se inicializará en ``Py_None``. Por "
"conveniencia, hay un valor especial llamado ``NULL`` solo por esta razón: "
"desde la perspectiva de Python se comporta como un valor predeterminado de "
"``None``, pero la variable C se inicializa con ``NULL``."

#: ../Doc/howto/clinic.rst:1077
msgid "Symbolic default values"
msgstr "Valores predeterminados simbólicos"

#: ../Doc/howto/clinic.rst:1079
msgid ""
"The default value you provide for a parameter can't be any arbitrary "
"expression.  Currently the following are explicitly supported:"
msgstr ""
"El valor predeterminado que proporcione para un parámetro no puede ser una "
"expresión arbitraria. Actualmente, lo siguiente se admite explícitamente:"

#: ../Doc/howto/clinic.rst:1082
msgid "Numeric constants (integer and float)"
msgstr "Constantes numéricas (enteros y flotantes)"

#: ../Doc/howto/clinic.rst:1083
msgid "String constants"
msgstr "Constantes de cadena de caracteres"

#: ../Doc/howto/clinic.rst:1084
msgid "``True``, ``False``, and ``None``"
msgstr "``True``, ``False``, y ``None``"

#: ../Doc/howto/clinic.rst:1085
#, fuzzy
msgid ""
"Simple symbolic constants like :py:data:`sys.maxsize`, which must start with "
"the name of the module"
msgstr ""
"Constantes simbólicas simples como ``sys.maxsize``, que debe comenzar con el "
"nombre del módulo"

#: ../Doc/howto/clinic.rst:1088
msgid ""
"(In the future, this may need to get even more elaborate, to allow full "
"expressions like ``CONSTANT - 1``.)"
msgstr ""
"(En el futuro, esto puede necesitar ser aún más elaborado, para permitir "
"expresiones completas como ``CONSTANT - 1``.)"

#: ../Doc/howto/clinic.rst:1093
#, fuzzy
msgid "Expressions as default values"
msgstr "Expresiones especificadas como valores por defecto"

#: ../Doc/howto/clinic.rst:1095
msgid ""
"The default value for a parameter can be more than just a literal value. It "
"can be an entire expression, using math operators and looking up attributes "
"on objects.  However, this support isn't exactly simple, because of some non-"
"obvious semantics."
msgstr ""
"El valor predeterminado de un parámetro puede ser más que un valor literal. "
"Puede ser una expresión completa, utilizando operadores matemáticos y "
"buscando atributos en objetos. Sin embargo, este soporte no es exactamente "
"simple, debido a una semántica no obvia."

#: ../Doc/howto/clinic.rst:1100
msgid "Consider the following example:"
msgstr "Considere el siguiente ejemplo:"

#: ../Doc/howto/clinic.rst:1106
#, fuzzy
msgid ""
":py:data:`sys.maxsize` can have different values on different platforms.  "
"Therefore Argument Clinic can't simply evaluate that expression locally and "
"hard-code it in C.  So it stores the default in such a way that it will get "
"evaluated at runtime, when the user asks for the function's signature."
msgstr ""
"``sys.maxsize`` puede tener diferentes valores en diferentes plataformas. "
"Por lo tanto, Argument Clinic no puede simplemente evaluar esa expresión "
"localmente y codificarla en C. Por lo tanto, almacena el valor "
"predeterminado de tal manera que se evaluará en tiempo de ejecución, cuando "
"el usuario solicite la firma de la función."

#: ../Doc/howto/clinic.rst:1111
#, fuzzy
msgid ""
"What namespace is available when the expression is evaluated?  It's "
"evaluated in the context of the module the builtin came from.  So, if your "
"module has an attribute called :py:attr:`!max_widgets`, you may simply use "
"it:"
msgstr ""
"¿Qué espacio de nombres está disponible cuando se evalúa la expresión? Se "
"evalúa en el contexto del módulo del que procede el incorporado. Entonces, "
"si su módulo tiene un atributo llamado \"``max_widgets``\", simplemente "
"puede usarlo:"

#: ../Doc/howto/clinic.rst:1119
#, fuzzy
msgid ""
"If the symbol isn't found in the current module, it fails over to looking "
"in :py:data:`sys.modules`.  That's how it can find :py:data:`sys.maxsize` "
"for example. (Since you don't know in advance what modules the user will "
"load into their interpreter, it's best to restrict yourself to modules that "
"are preloaded by Python itself.)"
msgstr ""
"Si el símbolo no se encuentra en el módulo actual, falla para buscar en "
"``sys.modules``. Así es como puede encontrar ``sys.maxsize``, por ejemplo. "
"(Dado que no sabe de antemano qué módulos cargará el usuario en su "
"intérprete, es mejor limitarse a los módulos que están precargados por el "
"propio Python)."

#: ../Doc/howto/clinic.rst:1124
#, fuzzy
msgid ""
"Evaluating default values only at runtime means Argument Clinic can't "
"compute the correct equivalent C default value.  So you need to tell it "
"explicitly. When you use an expression, you must also specify the equivalent "
"expression in C, using the *c_default* parameter to the converter:"
msgstr ""
"La evaluación de los valores predeterminados solo en tiempo de ejecución "
"significa que Argument Clinic no puede calcular el valor predeterminado de C "
"equivalente correcto. Entonces necesita decirlo explícitamente. Cuando usa "
"una expresión, también debe especificar la expresión equivalente en C, "
"usando el parámetro ``c_default`` para el convertidor:"

#: ../Doc/howto/clinic.rst:1133
msgid ""
"Another complication: Argument Clinic can't know in advance whether or not "
"the expression you supply is valid.  It parses it to make sure it looks "
"legal, but it can't *actually* know.  You must be very careful when using "
"expressions to specify values that are guaranteed to be valid at runtime!"
msgstr ""
"Otra complicación: Argument Clinic no puede saber de antemano si la "
"expresión que proporciona es válida o no. Lo analiza para asegurarse de que "
"parece legal, pero no puede *realmente* saberlo. ¡Debe tener mucho cuidado "
"al usar expresiones para especificar valores que están garantizados para ser "
"válidos en tiempo de ejecución!"

#: ../Doc/howto/clinic.rst:1138
msgid ""
"Finally, because expressions must be representable as static C values, there "
"are many restrictions on legal expressions.  Here's a list of Python "
"features you're not permitted to use:"
msgstr ""
"Finalmente, dado que las expresiones deben ser representables como valores C "
"estáticos, existen muchas restricciones sobre las expresiones legales. Aquí "
"hay una lista de funciones de Python que no está autorizado a usar:"

#: ../Doc/howto/clinic.rst:1142
msgid "Function calls."
msgstr "Llamadas a funciones."

#: ../Doc/howto/clinic.rst:1143
msgid "Inline if statements (``3 if foo else 5``)."
msgstr "Declaraciones if en línea (``3 if foo else 5``)."

#: ../Doc/howto/clinic.rst:1144
msgid "Automatic sequence unpacking (``*[1, 2, 3]``)."
msgstr "Desempaque automático de secuencia (``*[1, 2, 3]``)."

#: ../Doc/howto/clinic.rst:1145
msgid "List/set/dict comprehensions and generator expressions."
msgstr "Comprensiones de list/set/dict y expresiones generadoras."

#: ../Doc/howto/clinic.rst:1146
msgid "Tuple/list/set/dict literals."
msgstr "Literales tuple/list/set/dict."

#: ../Doc/howto/clinic.rst:1152
#, fuzzy
msgid "How to use return converters"
msgstr "su convertidor de retorno."

#: ../Doc/howto/clinic.rst:1154
#, fuzzy
msgid ""
"By default, the impl function Argument Clinic generates for you returns :c:"
"type:`PyObject * <PyObject>`. But your C function often computes some C "
"type, then converts it into the :c:type:`!PyObject *` at the last moment.  "
"Argument Clinic handles converting your inputs from Python types into native "
"C types—why not have it convert your return value from a native C type into "
"a Python type too?"
msgstr ""
"De forma predeterminada, la función implícita Argument Clinic genera para "
"usted retorna ``PyObject *``. Pero su función C a menudo calcula algún tipo "
"de C, luego lo convierte en el ``PyObject *`` en el último momento. Argument "
"Clinic se encarga de convertir sus entradas de tipos de Python en tipos C "
"nativos; ¿por qué no convertir su valor de retorno de un tipo C nativo en un "
"tipo Python también?"

#: ../Doc/howto/clinic.rst:1162
#, fuzzy
msgid ""
"That's what a \"return converter\" does.  It changes your impl function to "
"return some C type, then adds code to the generated (non-impl) function to "
"handle converting that value into the appropriate :c:type:`!PyObject *`."
msgstr ""
"Eso es lo que hace un \"convertidor de retorno\". Cambia su función *impl* "
"para retornar algún tipo de C, luego agrega código a la función generada (no "
"implícita) para manejar la conversión de ese valor en el ``PyObject *`` "
"apropiado."

#: ../Doc/howto/clinic.rst:1166
#, fuzzy
msgid ""
"The syntax for return converters is similar to that of parameter converters. "
"You specify the return converter like it was a return annotation on the "
"function itself, using ``->`` notation."
msgstr ""
"La sintaxis de los convertidores de retorno es similar a la de los "
"convertidores de parámetros. Especifica el convertidor de retorno como si "
"fuera una anotación de retorno en la función en sí. Los convertidores de "
"retorno se comportan de la misma manera que los convertidores de parámetros; "
"aceptan argumentos, todos los argumentos son solo palabras clave y, si no "
"está cambiando ninguno de los argumentos predeterminados, puede omitir los "
"paréntesis."

#: ../Doc/howto/clinic.rst:1170
#, fuzzy
msgid "For example:"
msgstr "Muestra::"

#: ../Doc/howto/clinic.rst:1183
#, fuzzy
msgid ""
"Return converters behave much the same as parameter converters; they take "
"arguments, the arguments are all keyword-only, and if you're not changing "
"any of the default arguments you can omit the parentheses."
msgstr ""
"La sintaxis de los convertidores de retorno es similar a la de los "
"convertidores de parámetros. Especifica el convertidor de retorno como si "
"fuera una anotación de retorno en la función en sí. Los convertidores de "
"retorno se comportan de la misma manera que los convertidores de parámetros; "
"aceptan argumentos, todos los argumentos son solo palabras clave y, si no "
"está cambiando ninguno de los argumentos predeterminados, puede omitir los "
"paréntesis."

#: ../Doc/howto/clinic.rst:1187
msgid ""
"(If you use both ``\"as\"`` *and* a return converter for your function, the "
"``\"as\"`` should come before the return converter.)"
msgstr ""
"(Si utiliza tanto ``\"as\"`` *y* un convertidor de retorno para su función, "
"el ``\"as\"`` debe aparecer antes del convertidor de retorno.)"

#: ../Doc/howto/clinic.rst:1190
#, fuzzy
msgid ""
"There's one additional complication when using return converters: how do you "
"indicate an error has occurred?  Normally, a function returns a valid (non-"
"``NULL``) pointer for success, and ``NULL`` for failure.  But if you use an "
"integer return converter, all integers are valid.  How can Argument Clinic "
"detect an error?  Its solution: each return converter implicitly looks for a "
"special value that indicates an error.  If you return that value, and an "
"error has been set (c:func:`PyErr_Occurred` returns a true value), then the "
"generated code will propagate the error.  Otherwise it will encode the value "
"you return like normal."
msgstr ""
"Hay una complicación adicional al usar convertidores de retorno: ¿cómo "
"indica que se ha producido un error? Normalmente, una función retorna un "
"puntero válido (no ``NULL``) para el éxito y ``NULL`` para el error. Pero si "
"usa un convertidor de retorno de enteros, todos los enteros son válidos. "
"¿Cómo puede Argument Clinic detectar un error? Su solución: cada convertidor "
"de retorno busca implícitamente un valor especial que indica un error. Si "
"retorna ese valor y se ha establecido un error (``PyErr_Occurred()`` retorna "
"un valor verdadero), el código generado propagará el error. De lo contrario, "
"codificará el valor que retorna como de costumbre."

#: ../Doc/howto/clinic.rst:1199
msgid "Currently Argument Clinic supports only a few return converters:"
msgstr ""
"Actualmente, Argument Clinic solo admite unos pocos convertidores de retorno:"

#: ../Doc/howto/clinic.rst:1213
msgid ""
"None of these take parameters. For all of these, return ``-1`` to indicate "
"error."
msgstr ""

#: ../Doc/howto/clinic.rst:1216
msgid ""
"To see all the return converters Argument Clinic supports, along with their "
"parameters (if any), just run ``Tools/clinic/clinic.py --converters`` for "
"the full list."
msgstr ""
"Para ver todos los convertidores retornados que admite Argument Clinic, "
"junto con sus parámetros (si los hay), simplemente ejecute ``Tools/clinic/"
"clinic.py --converters`` para ver la lista completa."

#: ../Doc/howto/clinic.rst:1222
#, fuzzy
msgid "How to clone existing functions"
msgstr "Clonando funciones existentes"

#: ../Doc/howto/clinic.rst:1224
msgid ""
"If you have a number of functions that look similar, you may be able to use "
"Clinic's \"clone\" feature.  When you clone an existing function, you reuse:"
msgstr ""
"Si tiene varias funciones que parecen similares, es posible que pueda "
"utilizar la función \"clone\" de Clinic. Cuando clona una función existente, "
"reutiliza:"

#: ../Doc/howto/clinic.rst:1228
msgid "its parameters, including"
msgstr "sus parámetros, incluyendo"

#: ../Doc/howto/clinic.rst:1230
msgid "their names,"
msgstr "sus nombres,"

#: ../Doc/howto/clinic.rst:1232
msgid "their converters, with all parameters,"
msgstr "sus convertidores, con todos los parámetros,"

#: ../Doc/howto/clinic.rst:1234
msgid "their default values,"
msgstr "sus valores predeterminados,"

#: ../Doc/howto/clinic.rst:1236
msgid "their per-parameter docstrings,"
msgstr "sus docstrings por parámetro,"

#: ../Doc/howto/clinic.rst:1238
msgid ""
"their *kind* (whether they're positional only, positional or keyword, or "
"keyword only), and"
msgstr ""
"su *kind* (ya sea solo posicional, posicional o por palabra clave, o solo "
"por palabra clave), y"

#: ../Doc/howto/clinic.rst:1241
msgid "its return converter."
msgstr "su convertidor de retorno."

#: ../Doc/howto/clinic.rst:1243
msgid ""
"The only thing not copied from the original function is its docstring; the "
"syntax allows you to specify a new docstring."
msgstr ""
"Lo único que no se ha copiado de la función original es su docstring; la "
"sintaxis le permite especificar un nuevo docstring."

#: ../Doc/howto/clinic.rst:1246
msgid "Here's the syntax for cloning a function::"
msgstr "Aquí está la sintaxis para clonar una función::"

#: ../Doc/howto/clinic.rst:1254
msgid ""
"(The functions can be in different modules or classes.  I wrote ``module."
"class`` in the sample just to illustrate that you must use the full path to "
"*both* functions.)"
msgstr ""
"(Las funciones pueden estar en diferentes módulos o clases. Escribí ``module."
"class`` en la muestra solo para ilustrar que debe usar la ruta completa a "
"*ambas* funciones.)"

#: ../Doc/howto/clinic.rst:1258
#, fuzzy
msgid ""
"Sorry, there's no syntax for partially cloning a function, or cloning a "
"function then modifying it.  Cloning is an all-or nothing proposition."
msgstr ""
"Lo sentimos, no hay sintaxis para clonar parcialmente una función o clonar "
"una función y luego modificarla. La clonación es una propuesta de todo o "
"nada."

#: ../Doc/howto/clinic.rst:1261
msgid ""
"Also, the function you are cloning from must have been previously defined in "
"the current file."
msgstr ""
"Además, la función desde la que está clonando debe haberse definido "
"previamente en el archivo actual."

#: ../Doc/howto/clinic.rst:1266
#, fuzzy
msgid "How to call Python code"
msgstr "Llamando código Python"

#: ../Doc/howto/clinic.rst:1268
msgid ""
"The rest of the advanced topics require you to write Python code which lives "
"inside your C file and modifies Argument Clinic's runtime state.  This is "
"simple: you simply define a Python block."
msgstr ""
"El resto de los temas avanzados requieren que escriba código Python que vive "
"dentro de su archivo C y modifica el estado de ejecución de Argument Clinic. "
"Esto es simple: simplemente define un bloque de Python."

#: ../Doc/howto/clinic.rst:1272
msgid ""
"A Python block uses different delimiter lines than an Argument Clinic "
"function block.  It looks like this::"
msgstr ""
"Un bloque Python utiliza diferentes líneas delimitadoras que un bloque de "
"función de la Argument Clinic. Se parece a esto::"

#: ../Doc/howto/clinic.rst:1279
msgid ""
"All the code inside the Python block is executed at the time it's parsed.  "
"All text written to stdout inside the block is redirected into the "
"\"output\" after the block."
msgstr ""
"Todo el código dentro del bloque de Python se ejecuta en el momento en que "
"se analiza. Todo el texto escrito en stdout dentro del bloque se redirige a "
"la \"salida\" después del bloque."

#: ../Doc/howto/clinic.rst:1283
msgid ""
"As an example, here's a Python block that adds a static integer variable to "
"the C code::"
msgstr ""
"Como ejemplo, aquí hay un bloque de Python que agrega una variable entera "
"estática al código C::"

#: ../Doc/howto/clinic.rst:1296
#, fuzzy
msgid "How to use the \"self converter\""
msgstr "Usando un \"auto convertidor\""

#: ../Doc/howto/clinic.rst:1298
#, fuzzy
msgid ""
"Argument Clinic automatically adds a \"self\" parameter for you using a "
"default converter.  It automatically sets the ``type`` of this parameter to "
"the \"pointer to an instance\" you specified when you declared the type.  "
"However, you can override Argument Clinic's converter and specify one "
"yourself. Just add your own *self* parameter as the first parameter in a "
"block, and ensure that its converter is an instance of :class:`!"
"self_converter` or a subclass thereof."
msgstr ""
"Argument Clinic agrega automáticamente un parámetro \"self\" para usted "
"usando un convertidor predeterminado. Establece automáticamente el ``tipo`` "
"de este parámetro en el \"puntero a una instancia\" que especificó cuando "
"declaró el tipo. Sin embargo, puede anular el convertidor de Argument Clinic "
"y especificar uno usted mismo. Simplemente agregue su propio parámetro "
"``self`` como el primer parámetro en un bloque y asegúrese de que su "
"convertidor sea una instancia de ``self_converter`` o una subclase del mismo."

#: ../Doc/howto/clinic.rst:1307
msgid ""
"What's the point?  This lets you override the type of ``self``, or give it a "
"different default name."
msgstr ""
"¿Qué sentido tiene ? Esto le permite anular el tipo de ``self`` o darle un "
"nombre predeterminado diferente."

#: ../Doc/howto/clinic.rst:1310
#, fuzzy
msgid ""
"How do you specify the custom type you want to cast ``self`` to? If you only "
"have one or two functions with the same type for ``self``, you can directly "
"use Argument Clinic's existing ``self`` converter, passing in the type you "
"want to use as the *type* parameter::"
msgstr ""
"¿Cómo especifica el tipo personalizado al que desea transmitir ``self``? Si "
"solo tiene una o dos funciones con el mismo tipo para ``self``, puede usar "
"directamente el convertidor ``self`` existente de Argument Clinic, pasando "
"el tipo que desea usar como parámetro de ``type``::"

#: ../Doc/howto/clinic.rst:1326
#, fuzzy
msgid ""
"On the other hand, if you have a lot of functions that will use the same "
"type for ``self``, it's best to create your own converter, subclassing :"
"class:`!self_converter` but overwriting the :py:attr:`!type` member::"
msgstr ""
"Por otro lado, si tiene muchas funciones que usarán el mismo tipo para "
"``self``, es mejor crear su propio convertidor, subclasificando "
"``self_converter`` pero sobrescribiendo el miembro ``type``::"

#: ../Doc/howto/clinic.rst:1348
#, fuzzy
msgid "How to use the \"defining class\" converter"
msgstr "Usando un convertidor de \"clase definitoria\" (*defining class*)"

#: ../Doc/howto/clinic.rst:1350
msgid ""
"Argument Clinic facilitates gaining access to the defining class of a "
"method. This is useful for :ref:`heap type <heap-types>` methods that need "
"to fetch module level state.  Use :c:func:`PyType_FromModuleAndSpec` to "
"associate a new heap type with a module.  You can now use :c:func:"
"`PyType_GetModuleState` on the defining class to fetch the module state, for "
"example from a module method."
msgstr ""
"Argument Clinic facilita el acceso a la clase definitoria de un método. Esto "
"es útil para método de tipo heap (:ref:`heap type <heap-types>`) que "
"necesitan obtener el estado del nivel del módulo. Utilice :c:func:"
"`PyType_FromModuleAndSpec` para asociar un nuevo tipo de pila con un módulo. "
"Ahora puede usar :c:func:`PyType_GetModuleState` en la clase de definición "
"para obtener el estado del módulo, por ejemplo, de un método de módulo."

#: ../Doc/howto/clinic.rst:1356
#, fuzzy
msgid ""
"Example from :source:`Modules/zlibmodule.c`. First, ``defining_class`` is "
"added to the clinic input::"
msgstr ""
"Ejemplo de ``Modules/zlibmodule.c``. Primero, se agrega ``definition_class`` "
"a la entrada de la clínica::"

#: ../Doc/howto/clinic.rst:1368
msgid ""
"After running the Argument Clinic tool, the following function signature is "
"generated::"
msgstr ""
"Después de ejecutar la herramienta Argument Clinic, se genera la siguiente "
"firma de función::"

#: ../Doc/howto/clinic.rst:1378
msgid ""
"The following code can now use ``PyType_GetModuleState(cls)`` to fetch the "
"module state::"
msgstr ""
"El siguiente código ahora puede usar ``PyType_GetModuleState(cls)`` para "
"obtener el estado del módulo::"

#: ../Doc/howto/clinic.rst:1384
#, fuzzy
msgid ""
"Each method may only have one argument using this converter, and it must "
"appear after ``self``, or, if ``self`` is not used, as the first argument.  "
"The argument will be of type ``PyTypeObject *``.  The argument will not "
"appear in the :py:attr:`!__text_signature__`."
msgstr ""
"Cada método solo puede tener un argumento usando este convertidor, y debe "
"aparecer después de ``self`` o, si no se usa ``self``, como primer "
"argumento. El argumento será de tipo ``PyTypeObject *``. El argumento no "
"aparecerá en el ``__text_signature__``."

#: ../Doc/howto/clinic.rst:1389
#, fuzzy
msgid ""
"The ``defining_class`` converter is not compatible with :py:meth:`!__init__` "
"and :py:meth:`!__new__` methods, which cannot use the :c:macro:`METH_METHOD` "
"convention."
msgstr ""
"El convertidor ``definition_class`` no es compatible con los métodos "
"``__init__`` y ``__new__``, que no pueden usar la convención ``METH_METHOD``."

#: ../Doc/howto/clinic.rst:1393
#, fuzzy
msgid ""
"It is not possible to use ``defining_class`` with slot methods.  In order to "
"fetch the module state from such methods, use :c:func:"
"`PyType_GetModuleByDef` to look up the module and then :c:func:"
"`PyModule_GetState` to fetch the module state.  Example from the "
"``setattro`` slot method in :source:`Modules/_threadmodule.c`::"
msgstr ""
"No es posible usar ``defining_class`` con métodos de ranura. Para obtener el "
"estado del módulo de dichos métodos, use :c:func:`PyType_GetModuleByDef` "
"para buscar el módulo y luego :c:func:`PyModule_GetState` para buscar el "
"estado del módulo. Ejemplo del método de ranura ``setattro`` en ``Modules/"
"_threadmodule.c``::"

#: ../Doc/howto/clinic.rst:1408
msgid "See also :pep:`573`."
msgstr "Vea también :pep:`573`."

#: ../Doc/howto/clinic.rst:1414
#, fuzzy
msgid "How to write a custom converter"
msgstr "Escribiendo un convertidor personalizado"

#: ../Doc/howto/clinic.rst:1416
#, fuzzy
msgid ""
"A converter is a Python class that inherits from :py:class:`CConverter`. The "
"main purpose of a custom converter, is for parameters parsed with the ``O&`` "
"format unit --- parsing such a parameter means calling a :c:func:"
"`PyArg_ParseTuple` \"converter function\"."
msgstr ""
"Como dijimos en la sección anterior... ¡puedes escribir tus propios "
"convertidores! Un convertidor es simplemente una clase de Python que hereda "
"de ``CConverter``. El propósito principal de un convertidor personalizado es "
"si tiene un parámetro que usa la unidad de formato ``O&``; analizar este "
"parámetro significa llamar a :c:func:`PyArg_ParseTuple` \"función de "
"conversión\"."

#: ../Doc/howto/clinic.rst:1421
#, fuzzy
msgid ""
"Your converter class should be named :samp:`{ConverterName}_converter`. By "
"following this convention, your converter class will be automatically "
"registered with Argument Clinic, with its *converter name* being the name of "
"your converter class with the ``_converter`` suffix stripped off."
msgstr ""
"Su clase de convertidor debe llamarse ``*something*_converter``. Si el "
"nombre sigue esta convención, entonces su clase de convertidor se registrará "
"automáticamente con Argument Clinic; su nombre será el nombre de su clase "
"con el sufijo ``_converter`` eliminado. (Esto se logra con una metaclase)."

#: ../Doc/howto/clinic.rst:1426
#, fuzzy
msgid ""
"Instead of subclassing :py:meth:`!CConverter.__init__`, write a :py:meth:`!"
"converter_init` method. :py:meth:`!converter_init` always accepts a *self* "
"parameter. After *self*, all additional parameters **must** be keyword-only. "
"Any arguments passed to the converter in Argument Clinic will be passed "
"along to your :py:meth:`!converter_init` method. See :py:class:`CConverter` "
"for a list of members you may wish to specify in your subclass."
msgstr ""
"No debe subclasificar ``CConverter.__init__``. En su lugar, debe escribir "
"una función ``converter_init()``. ``converter_init()`` siempre acepta un "
"parámetro ``self``; después de eso, todos los parámetros adicionales *deben* "
"ser solo palabras clave. Cualquier argumento que se pase al convertidor en "
"Argument Clinic se pasará a su ``converter_init()``."

#: ../Doc/howto/clinic.rst:1435
#, fuzzy
msgid ""
"Here's the simplest example of a custom converter, from :source:`Modules/"
"zlibmodule.c`::"
msgstr ""
"Aquí está el ejemplo más simple de un convertidor personalizado, de "
"``Modules/zlibmodule.c``::"

#: ../Doc/howto/clinic.rst:1446
#, fuzzy
msgid ""
"This block adds a converter named ``ssize_t`` to Argument Clinic. Parameters "
"declared as ``ssize_t`` will be declared with type :c:type:`Py_ssize_t`, and "
"will be parsed by the ``'O&'`` format unit, which will call the :c:func:`!"
"ssize_t_converter` converter C function. ``ssize_t`` variables automatically "
"support default values."
msgstr ""
"Este bloque agrega un convertidor a Argument Clinic llamado ``ssize_t``. Los "
"parámetros declarados como ``ssize_t`` se declararán como tipo :c:type:"
"`Py_ssize_t`, y serán analizados por la unidad de formato ``'O&'``, que "
"llamará a la función de conversión ``ssize_t_converter``. Las variables "
"``ssize_t`` admiten automáticamente los valores predeterminados."

#: ../Doc/howto/clinic.rst:1452
msgid ""
"More sophisticated custom converters can insert custom C code to handle "
"initialization and cleanup. You can see more examples of custom converters "
"in the CPython source tree; grep the C files for the string ``CConverter``."
msgstr ""
"Los convertidores personalizados más sofisticados pueden insertar código C "
"personalizado para manejar la inicialización y la limpieza. Puede ver más "
"ejemplos de convertidores personalizados en el árbol de fuentes de CPython; "
"grep los archivos C para la cadena ``CConverter``."

#: ../Doc/howto/clinic.rst:1459
#, fuzzy
msgid "How to write a custom return converter"
msgstr "Escribiendo un convertidor de retorno personalizado"

#: ../Doc/howto/clinic.rst:1461
msgid ""
"Writing a custom return converter is much like writing a custom converter.  "
"Except it's somewhat simpler, because return converters are themselves much "
"simpler."
msgstr ""
"Escribir un convertidor de retorno personalizado es muy parecido a escribir "
"un convertidor personalizado. Excepto que es algo más simple, porque los "
"convertidores de retorno son en sí mismos mucho más simples."

#: ../Doc/howto/clinic.rst:1465
#, fuzzy
msgid ""
"Return converters must subclass :py:class:`!CReturnConverter`. There are no "
"examples yet of custom return converters, because they are not widely used "
"yet.  If you wish to write your own return converter, please read :source:"
"`Tools/clinic/clinic.py`, specifically the implementation of :py:class:`!"
"CReturnConverter` and all its subclasses."
msgstr ""
"Los convertidores de retorno deben tener una subclase de "
"``CReturnConverter``. Todavía no hay ejemplos de convertidores de retorno "
"personalizados, porque todavía no se utilizan ampliamente. Si desea escribir "
"su propio convertidor de retorno, lea ``Tools/clinic/clinic.py``, "
"específicamente la implementación de ``CReturnConverter`` y todas sus "
"subclases."

#: ../Doc/howto/clinic.rst:1474
msgid "How to convert ``METH_O`` and ``METH_NOARGS`` functions"
msgstr ""

#: ../Doc/howto/clinic.rst:1476
#, fuzzy
msgid ""
"To convert a function using :c:macro:`METH_O`, make sure the function's "
"single argument is using the ``object`` converter, and mark the arguments as "
"positional-only::"
msgstr ""
"Para convertir una función usando ``METH_O``, asegúrese de que el único "
"argumento de la función esté usando el convertidor de ``object`` y marque "
"los argumentos como solo posicional::"

#: ../Doc/howto/clinic.rst:1488
#, fuzzy
msgid ""
"To convert a function using :c:macro:`METH_NOARGS`, just don't specify any "
"arguments."
msgstr ""
"Para convertir una función usando ``METH_NOARGS``, simplemente no "
"especifique ningún argumento."

#: ../Doc/howto/clinic.rst:1491
#, fuzzy
msgid ""
"You can still use a self converter, a return converter, and specify a *type* "
"argument to the object converter for :c:macro:`METH_O`."
msgstr ""
"Aún puede usar un autoconversor, un convertidor de retorno y especificar un "
"argumento de ``tipo`` para el convertidor de objetos para ``METH_O``."

#: ../Doc/howto/clinic.rst:1496
#, fuzzy
msgid "How to convert ``tp_new`` and ``tp_init`` functions"
msgstr "funciones tp_new y tp_init"

#: ../Doc/howto/clinic.rst:1498
#, fuzzy
msgid ""
"You can convert :c:member:`~PyTypeObject.tp_new` and :c:member:"
"`~PyTypeObject.tp_init` functions. Just name them ``__new__`` or "
"``__init__`` as appropriate.  Notes:"
msgstr ""
"Puede convertir las funciones ``tp_new`` y ``tp_init``. Simplemente "
"nómbrelas ``__new__`` o ``__init__`` según corresponda. Notas:"

#: ../Doc/howto/clinic.rst:1502
msgid ""
"The function name generated for ``__new__`` doesn't end in ``__new__`` like "
"it would by default.  It's just the name of the class, converted into a "
"valid C identifier."
msgstr ""
"El nombre de la función generado para ``__new__`` no termina en ``__new__`` "
"como lo haría por defecto. Es solo el nombre de la clase, convertido en un "
"identificador C válido."

#: ../Doc/howto/clinic.rst:1506
#, fuzzy
msgid "No :c:type:`PyMethodDef` ``#define`` is generated for these functions."
msgstr "No se genera ningún ``PyMethodDef`` ``#define`` para estas funciones."

#: ../Doc/howto/clinic.rst:1508
msgid "``__init__`` functions return ``int``, not ``PyObject *``."
msgstr "funciones ``__init__`` retornan ``int``, no ``PyObject *``."

#: ../Doc/howto/clinic.rst:1510
msgid "Use the docstring as the class docstring."
msgstr "Utilice docstring como la clase de documentación."

#: ../Doc/howto/clinic.rst:1512
msgid ""
"Although ``__new__`` and ``__init__`` functions must always accept both the "
"``args`` and ``kwargs`` objects, when converting you may specify any "
"signature for these functions that you like. (If your function doesn't "
"support keywords, the parsing function generated will throw an exception if "
"it receives any.)"
msgstr ""
"Aunque las funciones ``__new__`` y ``__init__`` siempre deben aceptar tanto "
"los objetos ``args`` como los ``kwargs``, al realizar la conversión puede "
"especificar cualquier firma para estas funciones que desee. (Si su función "
"no admite palabras clave, la función de análisis generada lanzará una "
"excepción si recibe alguna)."

#: ../Doc/howto/clinic.rst:1520
#, fuzzy
msgid "How to change and redirect Clinic's output"
msgstr "Cambiar y redirigir la salida de Clinic"

#: ../Doc/howto/clinic.rst:1522
msgid ""
"It can be inconvenient to have Clinic's output interspersed with your "
"conventional hand-edited C code.  Luckily, Clinic is configurable: you can "
"buffer up its output for printing later (or earlier!), or write its output "
"to a separate file.  You can also add a prefix or suffix to every line of "
"Clinic's generated output."
msgstr ""
"Puede ser inconveniente tener la salida de Clinic intercalada con su código "
"C convencional editado a mano. Afortunadamente, Clinic es configurable: "
"puede almacenar en búfer su salida para imprimir más tarde (¡o antes!), O "
"escribir su salida en un archivo separado. También puede agregar un prefijo "
"o sufijo a cada línea del resultado generado por Clinic."

#: ../Doc/howto/clinic.rst:1528
msgid ""
"While changing Clinic's output in this manner can be a boon to readability, "
"it may result in Clinic code using types before they are defined, or your "
"code attempting to use Clinic-generated code before it is defined. These "
"problems can be easily solved by rearranging the declarations in your file, "
"or moving where Clinic's generated code goes.  (This is why the default "
"behavior of Clinic is to output everything into the current block; while "
"many people consider this hampers readability, it will never require "
"rearranging your code to fix definition-before-use problems.)"
msgstr ""
"Si bien cambiar la salida de la Clínica de esta manera puede ser una "
"bendición para la legibilidad, puede resultar en que el código de la Clínica "
"utilice tipos antes de que se definan, o que su código intente utilizar el "
"código generado por la Clínica antes de que se defina. Estos problemas "
"pueden resolverse fácilmente reorganizando las declaraciones en su archivo o "
"moviendo el código generado por Clinic a donde va. (Esta es la razón por la "
"que el comportamiento predeterminado de Clinic es enviar todo al bloque "
"actual; aunque muchas personas consideran que esto dificulta la legibilidad, "
"nunca será necesario reorganizar su código para solucionar problemas de "
"definición antes de su uso)."

#: ../Doc/howto/clinic.rst:1537
msgid "Let's start with defining some terminology:"
msgstr "Comencemos por definir alguna terminología:"

#: ../Doc/howto/clinic.rst:1564
msgid "*field*"
msgstr "*field*"

#: ../Doc/howto/clinic.rst:1540
#, fuzzy
msgid ""
"A field, in this context, is a subsection of Clinic's output. For example, "
"the ``#define`` for the :c:type:`PyMethodDef` structure is a field, called "
"``methoddef_define``.  Clinic has seven different fields it can output per "
"function definition:"
msgstr ""
"Un campo, en este contexto, es una subsección del resultado de la Clínica. "
"Por ejemplo, el ``#define`` para la estructura ``PyMethodDef`` es un campo, "
"llamado ``methoddef_define``. La clínica tiene siete campos diferentes que "
"puede generar por definición de función:"

#: ../Doc/howto/clinic.rst:1555
msgid ""
"All the names are of the form ``\"<a>_<b>\"``, where ``\"<a>\"`` is the "
"semantic object represented (the parsing function, the impl function, the "
"docstring, or the methoddef structure) and ``\"<b>\"`` represents what kind "
"of statement the field is.  Field names that end in ``\"_prototype\"`` "
"represent forward declarations of that thing, without the actual body/data "
"of the thing; field names that end in ``\"_definition\"`` represent the "
"actual definition of the thing, with the body/data of the thing.  "
"(``\"methoddef\"`` is special, it's the only one that ends with "
"``\"_define\"``, representing that it's a preprocessor #define.)"
msgstr ""
"Todos los nombres tienen la forma ``\"<a>_<b>\"``, donde ``\"<a>\"`` es el "
"objeto semántico representado (la función de análisis, la función impl, el "
"docstring o la estructura methoddef) y ``\"<b>\"`` representa qué tipo de "
"declaración es el campo. Los nombres de campo que terminan en "
"``\"_prototype\"`` representan declaraciones hacia adelante de esa cosa, sin "
"el cuerpo/datos reales de la cosa; los nombres de campo que terminan en "
"``\"_definition\"`` representan la definición real de la cosa, con el cuerpo/"
"datos de la cosa. (``\"methoddef\"`` es especial, es el único que termina "
"con ``\"_define\"``, lo que representa que es un preprocesador #define)."

#: ../Doc/howto/clinic.rst:1598
msgid "*destination*"
msgstr "*destination*"

#: ../Doc/howto/clinic.rst:1567
msgid ""
"A destination is a place Clinic can write output to.  There are five built-"
"in destinations:"
msgstr ""
"Un destino es un lugar en el que la Clínica puede escribir resultados. Hay "
"cinco destinos incorporados:"

#: ../Doc/howto/clinic.rst:1572 ../Doc/howto/clinic.rst:1647
#: ../Doc/howto/clinic.rst:1725
msgid "``block``"
msgstr "``block``"

#: ../Doc/howto/clinic.rst:1571
msgid ""
"The default destination: printed in the output section of the current Clinic "
"block."
msgstr ""
"El destino predeterminado: impreso en la sección de salida del bloque "
"Clínico actual."

#: ../Doc/howto/clinic.rst:1578 ../Doc/howto/clinic.rst:1674
#: ../Doc/howto/clinic.rst:1728
msgid "``buffer``"
msgstr "``buffer``"

#: ../Doc/howto/clinic.rst:1575
msgid ""
"A text buffer where you can save text for later.  Text sent here is appended "
"to the end of any existing text.  It's an error to have any text left in the "
"buffer when Clinic finishes processing a file."
msgstr ""
"Un búfer de texto donde puede guardar texto para más tarde. El texto enviado "
"aquí se agrega al final de cualquier texto existente. Es un error dejar "
"texto en el búfer cuando Clinic termina de procesar un archivo."

#: ../Doc/howto/clinic.rst:1589 ../Doc/howto/clinic.rst:1660
#: ../Doc/howto/clinic.rst:1754
msgid "``file``"
msgstr "``file``"

#: ../Doc/howto/clinic.rst:1581
#, fuzzy
msgid ""
"A separate \"clinic file\" that will be created automatically by Clinic. The "
"filename chosen for the file is ``{basename}.clinic{extension}``, where "
"``basename`` and ``extension`` were assigned the output from ``os.path."
"splitext()`` run on the current file.  (Example: the ``file`` destination "
"for :file:`_pickle.c` would be written to :file:`_pickle.clinic.c`.)"
msgstr ""
"Un \"archivo clínico\" separado que Clinic creará automáticamente. El nombre "
"de archivo elegido para el archivo es ``{basename}.clinic{extension}``, "
"donde a ``basename`` y ``extension`` se les asignó la salida de ``os.path."
"splitext()`` ejecutar en El archivo actual. (Ejemplo: el destino del "
"``file`` para ``_pickle.c`` se escribiría en ``_pickle.clinic.c``.)"

#: ../Doc/howto/clinic.rst:1588
msgid ""
"**Important: When using a** ``file`` **destination, you** *must check in* "
"**the generated file!**"
msgstr ""
"**Importante: Al usar un destino **``file``**, *debe registrar* **el archivo "
"generado!**"

#: ../Doc/howto/clinic.rst:1594 ../Doc/howto/clinic.rst:1687
#: ../Doc/howto/clinic.rst:1758
msgid "``two-pass``"
msgstr "``two-pass``"

#: ../Doc/howto/clinic.rst:1592
msgid ""
"A buffer like ``buffer``.  However, a two-pass buffer can only be dumped "
"once, and it prints out all text sent to it during all processing, even from "
"Clinic blocks *after* the dumping point."
msgstr ""
"Un búfer como ``buffer``. Sin embargo, un búfer de dos pasadas solo se puede "
"volcar una vez, e imprime todo el texto que se le envía durante todo el "
"procesamiento, incluso desde los bloques de la Clínica *después* del punto "
"de descarga."

#: ../Doc/howto/clinic.rst:1598 ../Doc/howto/clinic.rst:1721
msgid "``suppress``"
msgstr "``suppress``"

#: ../Doc/howto/clinic.rst:1597
msgid "The text is suppressed—thrown away."
msgstr "El texto se suprime --- se tira."

#: ../Doc/howto/clinic.rst:1600
msgid "Clinic defines five new directives that let you reconfigure its output."
msgstr ""
"Clinic define cinco nuevas directivas que le permiten reconfigurar su salida."

#: ../Doc/howto/clinic.rst:1602
msgid "The first new directive is ``dump``:"
msgstr "La primera nueva directiva es ``dump``:"

#: ../Doc/howto/clinic.rst:1608
msgid ""
"This dumps the current contents of the named destination into the output of "
"the current block, and empties it.  This only works with ``buffer`` and "
"``two-pass`` destinations."
msgstr ""
"Esto vuelca el contenido actual del destino nombrado en la salida del bloque "
"actual y lo vacía. Esto solo funciona con destinos de ``búfer`` y de ``dos "
"pasadas``."

#: ../Doc/howto/clinic.rst:1612
msgid ""
"The second new directive is ``output``.  The most basic form of ``output`` "
"is like this:"
msgstr ""
"La segunda nueva directiva es ``output``. La forma más básica de ``output`` "
"es así:"

#: ../Doc/howto/clinic.rst:1619
msgid ""
"This tells Clinic to output *field* to *destination*.  ``output`` also "
"supports a special meta-destination, called ``everything``, which tells "
"Clinic to output *all* fields to that *destination*."
msgstr ""
"Esto le dice a la Clínica que envíe *field* a *destination*. ``output`` "
"también admite un metadestino especial, llamado ``everything``, que le dice "
"a Clinic que envíe *todos* los campos a ese *destination*."

#: ../Doc/howto/clinic.rst:1623
msgid "``output`` has a number of other functions:"
msgstr "``output`` tiene una serie de otras funciones:"

#: ../Doc/howto/clinic.rst:1632
msgid ""
"``output push`` and ``output pop`` allow you to push and pop configurations "
"on an internal configuration stack, so that you can temporarily modify the "
"output configuration, then easily restore the previous configuration.  "
"Simply push before your change to save the current configuration, then pop "
"when you wish to restore the previous configuration."
msgstr ""
"``output push`` y ``output pop`` le permiten agregar y quitar "
"configuraciones en una pila de configuración interna, para que pueda "
"modificar temporalmente la configuración de salida, y luego restaurar "
"fácilmente la configuración anterior. Simplemente presione antes de su "
"cambio para guardar la configuración actual, luego haga estallar cuando "
"desee restaurar la configuración anterior."

#: ../Doc/howto/clinic.rst:1639
msgid ""
"``output preset`` sets Clinic's output to one of several built-in preset "
"configurations, as follows:"
msgstr ""
"``output preset`` configura la salida de Clinic en una de varias "
"configuraciones preestablecidas incorporadas, de la siguiente manera:"

#: ../Doc/howto/clinic.rst:1643
msgid ""
"Clinic's original starting configuration.  Writes everything immediately "
"after the input block."
msgstr ""
"Configuración inicial original de la clínica. Escribe todo inmediatamente "
"después del bloque de entrada."

#: ../Doc/howto/clinic.rst:1646
msgid ""
"Suppress the ``parser_prototype`` and ``docstring_prototype``, write "
"everything else to ``block``."
msgstr ""
"Suprime el ``parser_prototype`` y ``docstring_prototype``, escribe todo lo "
"demás en ``block``."

#: ../Doc/howto/clinic.rst:1650
msgid ""
"Designed to write everything to the \"clinic file\" that it can. You then "
"``#include`` this file near the top of your file. You may need to rearrange "
"your file to make this work, though usually this just means creating forward "
"declarations for various ``typedef`` and ``PyTypeObject`` definitions."
msgstr ""
"Diseñado para escribir todo lo que pueda en el \"archivo clínico\". Luego, "
"``#include`` este archivo cerca de la parte superior de su archivo. Es "
"posible que deba reorganizar su archivo para que esto funcione, aunque "
"generalmente esto solo significa crear declaraciones hacia adelante para "
"varias definiciones de ``typedef`` y ``PyTypeObject``."

#: ../Doc/howto/clinic.rst:1656
msgid ""
"Suppress the ``parser_prototype`` and ``docstring_prototype``, write the "
"``impl_definition`` to ``block``, and write everything else to ``file``."
msgstr ""
"Suprima ``parser_prototype`` y ``docstring_prototype``, escriba la "
"``impl_definition`` en ``block`` y escriba todo lo demás en ``file``."

#: ../Doc/howto/clinic.rst:1660
msgid "The default filename is ``\"{dirname}/clinic/{basename}.h\"``."
msgstr ""
"El nombre de archivo predeterminado es ``\"{dirname}/clinic/{basename}.h\"``."

#: ../Doc/howto/clinic.rst:1663
msgid ""
"Save up most of the output from Clinic, to be written into your file near "
"the end.  For Python files implementing modules or builtin types, it's "
"recommended that you dump the buffer just above the static structures for "
"your module or builtin type; these are normally very near the end.  Using "
"``buffer`` may require even more editing than ``file``, if your file has "
"static ``PyMethodDef`` arrays defined in the middle of the file."
msgstr ""
"Guarde la mayor parte del resultado de Clinic para escribirlo en su archivo "
"cerca del final. Para los archivos Python que implementan módulos o tipos "
"incorporado, se recomienda que descargue el búfer justo encima de las "
"estructuras estáticas para su módulo o tipo incorporado; estos suelen estar "
"muy cerca del final. El uso de ``buffer`` puede requerir incluso más edición "
"que ``file``, si su archivo tiene arreglos estáticos ``PyMethodDef`` "
"definidos en el medio del archivo."

#: ../Doc/howto/clinic.rst:1672
msgid ""
"Suppress the ``parser_prototype``, ``impl_prototype``, and "
"``docstring_prototype``, write the ``impl_definition`` to ``block``, and "
"write everything else to ``file``."
msgstr ""
"Suprima el ``parser_prototype``, ``impl_prototype`` y "
"``docstring_prototype``, escriba ``impl_definition`` en ``block`` y escriba "
"todo lo demás en ``file``."

#: ../Doc/howto/clinic.rst:1677
msgid ""
"Similar to the ``buffer`` preset, but writes forward declarations to the "
"``two-pass`` buffer, and definitions to the ``buffer``. This is similar to "
"the ``buffer`` preset, but may require less editing than ``buffer``.  Dump "
"the ``two-pass`` buffer near the top of your file, and dump the ``buffer`` "
"near the end just like you would when using the ``buffer`` preset."
msgstr ""
"Similar al ajuste preestablecido de ``buffer``, pero escribe declaraciones "
"hacia adelante en el búfer de ``dos pasadas`` y definiciones en el "
"``buffer``. Esto es similar al ajuste preestablecido de ``buffer``, pero "
"puede requerir menos edición que ``buffer``. Vierta el búfer de ``dos "
"pasadas`` cerca de la parte superior de su archivo y descargue el ``buffer`` "
"cerca del final como lo haría cuando usa el ajuste preestablecido de "
"``buffer``."

#: ../Doc/howto/clinic.rst:1684
msgid ""
"Suppresses the ``impl_prototype``, write the ``impl_definition`` to "
"``block``, write ``docstring_prototype``, ``methoddef_define``, and "
"``parser_prototype`` to ``two-pass``, write everything else to ``buffer``."
msgstr ""
"Suprime el ``impl_prototype``, escribe ``impl_definition`` en ``block``, "
"escribe ``docstring_prototype``, ``methoddef_define`` y ``parser_prototype`` "
"en ``two-pass``, escribe todo lo demás en ``buffer``."

#: ../Doc/howto/clinic.rst:1698
msgid "``partial-buffer``"
msgstr "``partial-buffer``"

#: ../Doc/howto/clinic.rst:1690
msgid ""
"Similar to the ``buffer`` preset, but writes more things to ``block``, only "
"writing the really big chunks of generated code to ``buffer``. This avoids "
"the definition-before-use problem of ``buffer`` completely, at the small "
"cost of having slightly more stuff in the block's output. Dump the "
"``buffer`` near the end, just like you would when using the ``buffer`` "
"preset."
msgstr ""
"Similar al ajuste preestablecido de ``buffer``, pero escribe más cosas en "
"``block``, solo escribe los trozos realmente grandes de código generado en "
"``buffer``. Esto evita el problema de definición antes del uso de ``buffer`` "
"por completo, con el pequeño costo de tener un poco más de material en la "
"salida del bloque. Vierta el ``buffer`` cerca del final, tal como lo haría "
"cuando usa el ajuste predeterminado de ``buffer``."

#: ../Doc/howto/clinic.rst:1697
msgid ""
"Suppresses the ``impl_prototype``, write the ``docstring_definition`` and "
"``parser_definition`` to ``buffer``, write everything else to ``block``."
msgstr ""
"Suprime el ``impl_prototype``, escribe ``docstring_definition`` y "
"``parser_definition`` en ``buffer``, escribe todo lo demás en ``block``."

#: ../Doc/howto/clinic.rst:1700
msgid "The third new directive is ``destination``:"
msgstr "La tercera nueva directiva es ``destino``:"

#: ../Doc/howto/clinic.rst:1706
msgid "This performs an operation on the destination named ``name``."
msgstr "Esto realiza una operación en el destino llamado ``name``."

#: ../Doc/howto/clinic.rst:1708
msgid "There are two defined subcommands: ``new`` and ``clear``."
msgstr "Hay dos subcomandos definidos: ``new`` y ``clear``."

#: ../Doc/howto/clinic.rst:1710
msgid "The ``new`` subcommand works like this:"
msgstr "El subcomando ``new`` funciona así:"

#: ../Doc/howto/clinic.rst:1716
msgid ""
"This creates a new destination with name ``<name>`` and type ``<type>``."
msgstr ""
"Esto crea un nuevo destino con el nombre ``<nombre>`` y escribe ``<tipo>``."

#: ../Doc/howto/clinic.rst:1718
msgid "There are five destination types:"
msgstr "Hay cinco tipos de destinos:"

#: ../Doc/howto/clinic.rst:1721
msgid "Throws the text away."
msgstr "Tira el texto."

#: ../Doc/howto/clinic.rst:1724
msgid ""
"Writes the text to the current block.  This is what Clinic originally did."
msgstr ""
"Escribe el texto en el bloque actual. Esto es lo que hizo Clinic "
"originalmente."

#: ../Doc/howto/clinic.rst:1728
msgid "A simple text buffer, like the \"buffer\" builtin destination above."
msgstr ""
"Un búfer de texto simple, como el destino incorporado \"búfer\" anterior."

#: ../Doc/howto/clinic.rst:1731
msgid ""
"A text file.  The file destination takes an extra argument, a template to "
"use for building the filename, like so:"
msgstr ""
"Un archivo de texto. El destino del archivo toma un argumento adicional, una "
"plantilla para usar para construir el nombre de archivo, así:"

#: ../Doc/howto/clinic.rst:1734
msgid "destination <name> new <type> <file_template>"
msgstr "destino <name> nuevo <type> <file_template>"

#: ../Doc/howto/clinic.rst:1736
msgid ""
"The template can use three strings internally that will be replaced by bits "
"of the filename:"
msgstr ""
"La plantilla puede usar tres cadenas internamente que serán reemplazadas por "
"bits del nombre del archivo:"

#: ../Doc/howto/clinic.rst:1739
msgid "{path}"
msgstr "{path}"

#: ../Doc/howto/clinic.rst:1740
msgid "The full path to the file, including directory and full filename."
msgstr ""
"La ruta completa al archivo, incluido el directorio y el nombre de archivo "
"completo."

#: ../Doc/howto/clinic.rst:1741
msgid "{dirname}"
msgstr "{dirname}"

#: ../Doc/howto/clinic.rst:1742
msgid "The name of the directory the file is in."
msgstr "El nombre del directorio en el que se encuentra el archivo."

#: ../Doc/howto/clinic.rst:1743
msgid "{basename}"
msgstr "{basename}"

#: ../Doc/howto/clinic.rst:1744
msgid "Just the name of the file, not including the directory."
msgstr "Solo el nombre del archivo, sin incluir el directorio."

#: ../Doc/howto/clinic.rst:1746
msgid "{basename_root}"
msgstr "{basename_root}"

#: ../Doc/howto/clinic.rst:1746
msgid ""
"Basename with the extension clipped off (everything up to but not including "
"the last '.')."
msgstr ""
"Nombre de base con la extensión recortada (todo hasta pero sin incluir el "
"último '.')."

#: ../Doc/howto/clinic.rst:1750
msgid "{basename_extension}"
msgstr "{basename_extension}"

#: ../Doc/howto/clinic.rst:1749
msgid ""
"The last '.' and everything after it.  If the basename does not contain a "
"period, this will be the empty string."
msgstr ""
"El último '.' y todo lo que sigue. Si el nombre base no contiene un punto, "
"esta será la cadena de caracteres vacía."

#: ../Doc/howto/clinic.rst:1752
msgid ""
"If there are no periods in the filename, {basename} and {filename} are the "
"same, and {extension} is empty.  \"{basename}{extension}\" is always exactly "
"the same as \"{filename}\".\""
msgstr ""
"Si no hay puntos en el nombre del archivo, {basename} y {filename} son "
"iguales, y {extension} está vacía. \"{basename}{extension}\" es siempre "
"exactamente igual que \"{filename}\". \""

#: ../Doc/howto/clinic.rst:1757
msgid "A two-pass buffer, like the \"two-pass\" builtin destination above."
msgstr ""
"Un búfer de dos pasadas (*two-pass*), como el destino incorporado de \"dos "
"pasadas\" anterior."

#: ../Doc/howto/clinic.rst:1760
msgid "The ``clear`` subcommand works like this:"
msgstr "El subcomando ``clear`` funciona así:"

#: ../Doc/howto/clinic.rst:1766
msgid ""
"It removes all the accumulated text up to this point in the destination. (I "
"don't know what you'd need this for, but I thought maybe it'd be useful "
"while someone's experimenting.)"
msgstr ""
"Elimina todo el texto acumulado hasta este punto en el destino. (No sé para "
"qué necesitarías esto, pero pensé que tal vez sería útil mientras alguien "
"está experimentando)."

#: ../Doc/howto/clinic.rst:1770
msgid "The fourth new directive is ``set``:"
msgstr "La cuarta nueva directiva está ``set``:"

#: ../Doc/howto/clinic.rst:1777
msgid ""
"``set`` lets you set two internal variables in Clinic. ``line_prefix`` is a "
"string that will be prepended to every line of Clinic's output; "
"``line_suffix`` is a string that will be appended to every line of Clinic's "
"output."
msgstr ""
"``set`` le permite configurar dos variables internas en la Clínica. "
"``line_prefix`` es una cadena que se antepondrá a cada línea de salida de la "
"Clínica; ``line_suffix`` es una cadena de caracteres que se agregará a cada "
"línea de salida de la Clínica."

#: ../Doc/howto/clinic.rst:1781
msgid "Both of these support two format strings:"
msgstr "Ambos admiten dos cadenas de caracteres de formato:"

#: ../Doc/howto/clinic.rst:1784
msgid "``{block comment start}``"
msgstr "``{block comment start}``"

#: ../Doc/howto/clinic.rst:1784
msgid ""
"Turns into the string ``/*``, the start-comment text sequence for C files."
msgstr ""
"Se convierte en la cadena de caracteres ``/*``, la secuencia de texto de "
"inicio de comentario para archivos C."

#: ../Doc/howto/clinic.rst:1787
msgid "``{block comment end}``"
msgstr "``{block comment end}``"

#: ../Doc/howto/clinic.rst:1787
msgid ""
"Turns into the string ``*/``, the end-comment text sequence for C files."
msgstr ""
"Se convierte en la cadena ``*/``, la secuencia de texto del comentario final "
"para los archivos C."

#: ../Doc/howto/clinic.rst:1789
msgid ""
"The final new directive is one you shouldn't need to use directly, called "
"``preserve``:"
msgstr ""
"La nueva directiva final es una que no debería necesitar usar directamente, "
"llamada ``preserve``:"

#: ../Doc/howto/clinic.rst:1796
msgid ""
"This tells Clinic that the current contents of the output should be kept, "
"unmodified. This is used internally by Clinic when dumping output into "
"``file`` files; wrapping it in a Clinic block lets Clinic use its existing "
"checksum functionality to ensure the file was not modified by hand before it "
"gets overwritten."
msgstr ""
"Esto le dice a Clinic que el contenido actual de la salida debe mantenerse, "
"sin modificaciones. La Clínica lo usa internamente cuando se descarga la "
"salida en archivos de ``file``; envolverlo en un bloque Clinic permite que "
"Clinic use su funcionalidad de suma de comprobación existente para "
"garantizar que el archivo no se modificó a mano antes de sobrescribirlo."

#: ../Doc/howto/clinic.rst:1803
#, fuzzy
msgid "How to use the ``#ifdef`` trick"
msgstr "El truco #ifdef"

#: ../Doc/howto/clinic.rst:1805
msgid ""
"If you're converting a function that isn't available on all platforms, "
"there's a trick you can use to make life a little easier.  The existing code "
"probably looks like this::"
msgstr ""
"Si está convirtiendo una función que no está disponible en todas las "
"plataformas, hay un truco que puede usar para hacer la vida un poco más "
"fácil. El código existente probablemente se ve así::"

#: ../Doc/howto/clinic.rst:1816
msgid ""
"And then in the ``PyMethodDef`` structure at the bottom the existing code "
"will have:"
msgstr ""
"Y luego, en la estructura ``PyMethodDef`` en la parte inferior, el código "
"existente tendrá:"

#: ../Doc/howto/clinic.rst:1825
msgid ""
"In this scenario, you should enclose the body of your impl function inside "
"the ``#ifdef``, like so::"
msgstr ""
"En este escenario, debe encerrar el cuerpo de su función *impl* dentro de "
"``#ifdef``, así::"

#: ../Doc/howto/clinic.rst:1839
#, fuzzy
msgid ""
"Then, remove those three lines from the :c:type:`PyMethodDef` structure, "
"replacing them with the macro Argument Clinic generated:"
msgstr ""
"Luego, elimine esas tres líneas de la estructura ``PyMethodDef``, "
"reemplazándolas con la macro Argument Clinic generada:"

#: ../Doc/howto/clinic.rst:1846
msgid ""
"(You can find the real name for this macro inside the generated code. Or you "
"can calculate it yourself: it's the name of your function as defined on the "
"first line of your block, but with periods changed to underscores, "
"uppercased, and ``\"_METHODDEF\"`` added to the end.)"
msgstr ""
"(Puede encontrar el nombre real de esta macro dentro del código generado. O "
"puede calcularlo usted mismo: es el nombre de su función tal como se define "
"en la primera línea de su bloque, pero con puntos cambiados a guiones bajos, "
"mayúsculas y ``\"_METHODDEF\"`` agregado al final.)"

#: ../Doc/howto/clinic.rst:1851
msgid ""
"Perhaps you're wondering: what if ``HAVE_FUNCTIONNAME`` isn't defined? The "
"``MODULE_FUNCTIONNAME_METHODDEF`` macro won't be defined either!"
msgstr ""
"Quizás se esté preguntando: ¿qué pasa si ``HAVE_FUNCTIONNAME`` no está "
"definido? ¡La macro ``MODULE_FUNCTIONNAME_METHODDEF`` tampoco se definirá!"

#: ../Doc/howto/clinic.rst:1854
msgid ""
"Here's where Argument Clinic gets very clever.  It actually detects that the "
"Argument Clinic block might be deactivated by the ``#ifdef``.  When that "
"happens, it generates a little extra code that looks like this::"
msgstr ""
"Aquí es donde Argument Clinic se vuelve muy inteligente. De hecho, detecta "
"que el bloqueo de Argument Clinic podría estar desactivado por el "
"``#ifdef``. Cuando eso sucede, genera un pequeño código adicional que se ve "
"así::"

#: ../Doc/howto/clinic.rst:1862
msgid ""
"That means the macro always works.  If the function is defined, this turns "
"into the correct structure, including the trailing comma.  If the function "
"is undefined, this turns into nothing."
msgstr ""
"Eso significa que la macro siempre funciona. Si la función está definida, se "
"convierte en la estructura correcta, incluida la coma al final. Si la "
"función no está definida, esto se convierte en nada."

#: ../Doc/howto/clinic.rst:1866
msgid ""
"However, this causes one ticklish problem: where should Argument Clinic put "
"this extra code when using the \"block\" output preset?  It can't go in the "
"output block, because that could be deactivated by the ``#ifdef``.  (That's "
"the whole point!)"
msgstr ""
"Sin embargo, esto causa un problema delicado: ¿dónde debería poner Argument "
"Clinic este código adicional cuando se usa el ajuste preestablecido de "
"salida \"bloque\"? No puede entrar en el bloque de salida, porque podría "
"desactivarse con ``#ifdef``. (¡Ese es todo el punto!)"

#: ../Doc/howto/clinic.rst:1870
msgid ""
"In this situation, Argument Clinic writes the extra code to the \"buffer\" "
"destination. This may mean that you get a complaint from Argument Clinic:"
msgstr ""
"En esta situación, Argument Clinic escribe el código adicional en el destino "
"del \"búfer\". Esto puede significar que recibe una queja de Argument Clinic:"

#: ../Doc/howto/clinic.rst:1878
#, fuzzy
msgid ""
"When this happens, just open your file, find the ``dump buffer`` block that "
"Argument Clinic added to your file (it'll be at the very bottom), then move "
"it above the :c:type:`PyMethodDef` structure where that macro is used."
msgstr ""
"Cuando esto suceda, simplemente abra su archivo, busque el bloque ``dump "
"buffer`` que Argument Clinic agregó a su archivo (estará en la parte "
"inferior), luego muévalo arriba de la estructura ``PyMethodDef`` donde esa "
"macro se utiliza."

#: ../Doc/howto/clinic.rst:1884
#, fuzzy
msgid "How to use Argument Clinic in Python files"
msgstr "Usando Argument Clinic en archivos Python"

#: ../Doc/howto/clinic.rst:1886
msgid ""
"It's actually possible to use Argument Clinic to preprocess Python files. "
"There's no point to using Argument Clinic blocks, of course, as the output "
"wouldn't make any sense to the Python interpreter.  But using Argument "
"Clinic to run Python blocks lets you use Python as a Python preprocessor!"
msgstr ""
"De hecho, es posible utilizar Argument Clinic para preprocesar archivos "
"Python. Por supuesto, no tiene sentido usar bloques de Argument Clinic, ya "
"que la salida no tendría ningún sentido para el intérprete de Python. ¡Pero "
"usar Argument Clinic para ejecutar bloques de Python le permite usar Python "
"como un preprocesador de Python!"

#: ../Doc/howto/clinic.rst:1891
msgid ""
"Since Python comments are different from C comments, Argument Clinic blocks "
"embedded in Python files look slightly different.  They look like this:"
msgstr ""
"Dado que los comentarios de Python son diferentes de los comentarios de C, "
"los bloques de Argument Clinic incrustados en archivos de Python tienen un "
"aspecto ligeramente diferente. Se ven así:"

#~ msgid ""
#~ "Argument Clinic is a preprocessor for CPython C files. Its purpose is to "
#~ "automate all the boilerplate involved with writing argument parsing code "
#~ "for \"builtins\". This document shows you how to convert your first C "
#~ "function to work with Argument Clinic, and then introduces some advanced "
#~ "topics on Argument Clinic usage."
#~ msgstr ""
#~ "Argument Clinic es un preprocesador para archivos CPython C. Su propósito "
#~ "es automatizar todo el texto estándar involucrado con la escritura de "
#~ "código de análisis de argumentos para \"incorporados\". Este documento le "
#~ "muestra cómo convertir su primera función C para que funcione con "
#~ "Argument Clinic y luego presenta algunos temas avanzados sobre el uso de "
#~ "Argument Clinic."

#~ msgid ""
#~ "Argument Clinic's primary goal is to take over responsibility for all "
#~ "argument parsing code inside CPython.  This means that, when you convert "
#~ "a function to work with Argument Clinic, that function should no longer "
#~ "do any of its own argument parsing—the code generated by Argument Clinic "
#~ "should be a \"black box\" to you, where CPython calls in at the top, and "
#~ "your code gets called at the bottom, with ``PyObject *args`` (and maybe "
#~ "``PyObject *kwargs``) magically converted into the C variables and types "
#~ "you need."
#~ msgstr ""
#~ "El objetivo principal de Argument Clinic es asumir la responsabilidad de "
#~ "todo el código de análisis de argumentos dentro de CPython. Esto "
#~ "significa que, cuando convierte una función para que funcione con "
#~ "Argument Clinic, esa función ya no debería realizar ninguno de sus "
#~ "propios análisis de argumentos; el código generado por Argument Clinic "
#~ "debería ser una \"caja negra\" para usted, donde CPython llama al top, y "
#~ "su código se llama en la parte inferior, con ``PyObject *args`` (y tal "
#~ "vez ``PyObject *kwargs``) convertido mágicamente en las variables y tipos "
#~ "C que necesita."

#~ msgid ""
#~ "In order for Argument Clinic to accomplish its primary goal, it must be "
#~ "easy to use.  Currently, working with CPython's argument parsing library "
#~ "is a chore, requiring maintaining redundant information in a surprising "
#~ "number of places. When you use Argument Clinic, you don't have to repeat "
#~ "yourself."
#~ msgstr ""
#~ "Para que Argument Clinic logre su objetivo principal, debe ser fácil de "
#~ "usar. Actualmente, trabajar con la biblioteca de análisis de argumentos "
#~ "de CPython es una tarea ardua que requiere mantener información "
#~ "redundante en un número sorprendente de lugares. Cuando usa Argument "
#~ "Clinic, no tiene que repetirse."

#~ msgid ""
#~ "Obviously, no one would want to use Argument Clinic unless it's solving "
#~ "their problem—and without creating new problems of its own. So it's "
#~ "paramount that Argument Clinic generate correct code. It'd be nice if the "
#~ "code was faster, too, but at the very least it should not introduce a "
#~ "major speed regression.  (Eventually Argument Clinic *should* make a "
#~ "major speedup possible—we could rewrite its code generator to produce "
#~ "tailor-made argument parsing code, rather than calling the general-"
#~ "purpose CPython argument parsing library.  That would make for the "
#~ "fastest argument parsing possible!)"
#~ msgstr ""
#~ "Obviamente, si Argument Clinic no produjo ningún resultado, es porque "
#~ "encontró un error en su entrada. Siga corrigiendo sus errores y vuelva a "
#~ "intentarlo hasta que Argument Clinic procese su archivo sin quejas."

#~ msgid ""
#~ "Additionally, Argument Clinic must be flexible enough to work with any "
#~ "approach to argument parsing.  Python has some functions with some very "
#~ "strange parsing behaviors; Argument Clinic's goal is to support all of "
#~ "them."
#~ msgstr ""
#~ "Además, Argument Clinic debe ser lo suficientemente flexible como para "
#~ "trabajar con cualquier enfoque de análisis de argumentos. Python tiene "
#~ "algunas funciones con algunos comportamientos de análisis muy extraños; "
#~ "el objetivo de Argument Clinic es apoyarlos a todos."

#~ msgid ""
#~ "Finally, the original motivation for Argument Clinic was to provide "
#~ "introspection \"signatures\" for CPython builtins. It used to be, the "
#~ "introspection query functions would throw an exception if you passed in a "
#~ "builtin.  With Argument Clinic, that's a thing of the past!"
#~ msgstr ""
#~ "Finalmente, la motivación original de Argument Clinic era proporcionar "
#~ "\"firmas\" de introspección para las incorporaciones de CPython. Solía "
#~ "ser, las funciones de consulta de introspección lanzarían una excepción "
#~ "si pasaba un archivo incorporado. ¡Con Argument Clinic, eso es cosa del "
#~ "pasado!"

#~ msgid ""
#~ "One idea you should keep in mind, as you work with Argument Clinic: the "
#~ "more information you give it, the better job it'll be able to do. "
#~ "Argument Clinic is admittedly relatively simple right now.  But as it "
#~ "evolves it will get more sophisticated, and it should be able to do many "
#~ "interesting and smart things with all the information you give it."
#~ msgstr ""
#~ "Una idea que debe tener en cuenta al trabajar con Argument Clinic: cuanta "
#~ "más información le dé, mejor será su trabajo. Argument Clinic es "
#~ "ciertamente relativamente simple en este momento. Pero a medida que "
#~ "evolucione, se volverá más sofisticado y debería poder hacer muchas cosas "
#~ "interesantes e inteligentes con toda la información que le proporcione."

#~ msgid ""
#~ "Argument Clinic ships with CPython; you'll find it in ``Tools/clinic/"
#~ "clinic.py``. If you run that script, specifying a C file as an argument:"
#~ msgstr ""
#~ "Argument Clinic se envía con CPython; lo encontrará en ``Tools/clinic/"
#~ "clinic.py``. Si ejecuta ese script, especificando un archivo C como "
#~ "argumento:"

#~ msgid ""
#~ "Argument Clinic will scan over the file looking for lines that look "
#~ "exactly like this:"
#~ msgstr ""
#~ "Argument Clinic escaneará el archivo buscando líneas que se vean "
#~ "exactamente así:"

#~ msgid ""
#~ "Everything in between these two lines is input for Argument Clinic. All "
#~ "of these lines, including the beginning and ending comment lines, are "
#~ "collectively called an Argument Clinic \"block\"."
#~ msgstr ""
#~ "Todo lo que se encuentra entre estas dos líneas es entrada para Argument "
#~ "Clinic. Todas estas líneas, incluidas las líneas de comentarios iniciales "
#~ "y finales, se denominan colectivamente un \"bloque\" de Argument Clinic."

#~ msgid ""
#~ "When Argument Clinic parses one of these blocks, it generates output.  "
#~ "This output is rewritten into the C file immediately after the block, "
#~ "followed by a comment containing a checksum. The Argument Clinic block "
#~ "now looks like this:"
#~ msgstr ""
#~ "Cuando Argument Clinic analiza uno de estos bloques, genera una salida. "
#~ "Esta salida se reescribe en el archivo C inmediatamente después del "
#~ "bloque, seguida de un comentario que contiene una suma de comprobación. "
#~ "El bloque Argument Clinic ahora tiene este aspecto:"

#~ msgid ""
#~ "You should never modify the output portion of an Argument Clinic block.  "
#~ "Instead, change the input until it produces the output you want.  (That's "
#~ "the purpose of the checksum—to detect if someone changed the output, as "
#~ "these edits would be lost the next time Argument Clinic writes out fresh "
#~ "output.)"
#~ msgstr ""
#~ "Nunca debe modificar la parte de salida de un bloque de Argument Clinic. "
#~ "En su lugar, cambie la entrada hasta que produzca la salida que desea. "
#~ "(Ese es el propósito de la suma de comprobación: detectar si alguien "
#~ "cambió la salida, ya que estas ediciones se perderían la próxima vez que "
#~ "Argument Clinic escriba una salida nueva)."

#~ msgid ""
#~ "For the sake of clarity, here's the terminology we'll use with Argument "
#~ "Clinic:"
#~ msgstr ""
#~ "En aras de la claridad, esta es la terminología que usaremos con Argument "
#~ "Clinic:"

#~ msgid ""
#~ "The first line of the comment (``/*[clinic input]``) is the *start line*."
#~ msgstr ""
#~ "La primera línea del comentario (``/*[clinic input]``) es la *línea de "
#~ "inicio*."

#~ msgid ""
#~ "The last line of the initial comment (``[clinic start generated code]*/"
#~ "``) is the *end line*."
#~ msgstr ""
#~ "La última línea del comentario inicial (``[clinic start generated code]*/"
#~ "``) es la *línea final*."

#~ msgid ""
#~ "The last line (``/*[clinic end generated code: checksum=...]*/``) is the "
#~ "*checksum line*."
#~ msgstr ""
#~ "La última línea (``/*[clinic end generated code: checksum=...]*/``) es la "
#~ "*línea de suma de comprobación* (*checksum line*)."

#~ msgid "In between the start line and the end line is the *input*."
#~ msgstr "Entre la línea de inicio y la línea final está el *input*."

#~ msgid ""
#~ "All the text collectively, from the start line to the checksum line "
#~ "inclusively, is the *block*.  (A block that hasn't been successfully "
#~ "processed by Argument Clinic yet doesn't have output or a checksum line, "
#~ "but it's still considered a block.)"
#~ msgstr ""
#~ "Todo el texto colectivamente, desde la línea de inicio hasta la línea de "
#~ "suma de verificación inclusive, es el *bloque*. (Un bloque que no ha sido "
#~ "procesado con éxito por Argument Clinic todavía no tiene salida o una "
#~ "línea de suma de verificación, pero aún se considera un bloque)."

#~ msgid "Converting Your First Function"
#~ msgstr "Convirtiendo su primera función"

#~ msgid "Let's dive in!"
#~ msgstr "¡Vamos a sumergirnos!"

#~ msgid "The general form of these parameter lines is as follows:"
#~ msgstr "La forma general de estas líneas de parámetros es la siguiente:"

#~ msgid ""
#~ "Currently this is all-or-nothing; either all parameters are positional-"
#~ "only, or none of them are.  (In the future Argument Clinic may relax this "
#~ "restriction.)"
#~ msgstr ""
#~ "Actualmente esto es todo o nada; o todos los parámetros son solo "
#~ "posicionales o ninguno de ellos lo es. (En el futuro, Argument Clinic "
#~ "puede relajar esta restricción)."

#~ msgid ""
#~ "Well, except for one difference: ``inspect.signature()`` run on your "
#~ "function should now provide a valid signature!"
#~ msgstr ""
#~ "Bueno, excepto por una diferencia: ``inspect.signature()`` ejecutar en su "
#~ "función ahora debería proporcionar una firma válida!"

#~ msgid "Advanced Topics"
#~ msgstr "Temas avanzados"

#~ msgid ""
#~ "Now that you've had some experience working with Argument Clinic, it's "
#~ "time for some advanced topics."
#~ msgstr ""
#~ "Ahora que ha tenido algo de experiencia trabajando con Argument Clinic, "
#~ "es hora de algunos temas avanzados."

#~ msgid "``type``"
#~ msgstr "``type``"

#~ msgid "``Py_UNICODE``"
#~ msgstr "``Py_UNICODE``"

#~ msgid "``Py_UNICODE(zeroes=True)``"
#~ msgstr "``Py_UNICODE(zeroes=True)``"

#~ msgid "``Py_UNICODE(accept={str, NoneType})``"
#~ msgstr "``Py_UNICODE(accept={str, NoneType})``"

#~ msgid "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"
#~ msgstr "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"

#~ msgid "Py_buffer"
#~ msgstr "Py_buffer"

#~ msgid "Parameter default values"
#~ msgstr "Valores predeterminados de los parámetros"

#~ msgid "Using a return converter"
#~ msgstr "Usando un convertidor de retorno"

#~ msgid ""
#~ "None of these take parameters.  For the first three, return -1 to "
#~ "indicate error.  For ``DecodeFSDefault``, the return type is ``const char "
#~ "*``; return a ``NULL`` pointer to indicate an error."
#~ msgstr ""
#~ "Ninguno de estos toma parámetros. Para los tres primeros, retorna -1 para "
#~ "indicar error. Para ``DecodeFSDefault``, el tipo de retorno es ``const "
#~ "char *``; retorna un puntero ``NULL`` para indicar un error."

#~ msgid ""
#~ "(There's also an experimental ``NoneType`` converter, which lets you "
#~ "return ``Py_None`` on success or ``NULL`` on failure, without having to "
#~ "increment the reference count on ``Py_None``.  I'm not sure it adds "
#~ "enough clarity to be worth using.)"
#~ msgstr ""
#~ "(También hay un convertidor experimental ``NoneType``, que le permite "
#~ "retornar ``Py_None`` en caso de éxito o ``NULL`` en caso de falla, sin "
#~ "tener que incrementar el recuento de referencias en ``Py_None``. seguro "
#~ "que agrega suficiente claridad para que valga la pena usarlo)"

#~ msgid ""
#~ "There are some additional members of ``CConverter`` you may wish to "
#~ "specify in your subclass.  Here's the current list:"
#~ msgstr ""
#~ "Hay algunos miembros adicionales de ``CConverter`` que tal vez desee "
#~ "especificar en su subclase. Aquí está la lista actual:"

#~ msgid "``default``"
#~ msgstr "``default``"

#~ msgid "``py_default``"
#~ msgstr "``py_default``"

#~ msgid "``c_ignored_default``"
#~ msgstr "``c_ignored_default``"

#~ msgid "``parse_by_reference``"
#~ msgstr "``parse_by_reference``"

#~ msgid "METH_O and METH_NOARGS"
#~ msgstr "METH_O y METH_NOARGS"
