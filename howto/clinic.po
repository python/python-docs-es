# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/PyCampES/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-05 12:54+0200\n"
"PO-Revision-Date: 2020-08-15 22:56+0200\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: Cristián Maureira-Fredes <cmaureirafredes@gmail.com>\n"
"Language: es\n"
"X-Generator: Poedit 2.3.1\n"

#: ../Doc/howto/clinic.rst:5
msgid "Argument Clinic How-To"
msgstr "*How-To* Argument Clinic"

#: ../Doc/howto/clinic.rst
msgid "author"
msgstr "autor"

#: ../Doc/howto/clinic.rst:7
msgid "Larry Hastings"
msgstr "*Larry Hastings*"

msgid "Abstract"
msgstr "Resumen"

#: ../Doc/howto/clinic.rst:12
msgid ""
"Argument Clinic is a preprocessor for CPython C files. Its purpose is to "
"automate all the boilerplate involved with writing argument parsing code for "
"\"builtins\". This document shows you how to convert your first C function "
"to work with Argument Clinic, and then introduces some advanced topics on "
"Argument Clinic usage."
msgstr ""
"Argument Clinic es un preprocesador para archivos CPython C. Su propósito es "
"automatizar todo el texto estándar involucrado con la escritura de código de "
"análisis de argumentos para \"incorporados\". Este documento le muestra cómo "
"convertir su primera función C para que funcione con Argument Clinic y luego "
"presenta algunos temas avanzados sobre el uso de Argument Clinic."

#: ../Doc/howto/clinic.rst:19
msgid ""
"Currently Argument Clinic is considered internal-only for CPython.  Its use "
"is not supported for files outside CPython, and no guarantees are made "
"regarding backwards compatibility for future versions.  In other words: if "
"you maintain an external C extension for CPython, you're welcome to "
"experiment with Argument Clinic in your own code.  But the version of "
"Argument Clinic that ships with the next version of CPython *could* be "
"totally incompatible and break all your code."
msgstr ""
"Actualmente, Argument Clinic se considera solo interno para CPython. Su uso "
"no es compatible con archivos fuera de CPython y no se ofrecen garantías con "
"respecto a la compatibilidad con versiones anteriores. En otras palabras: si "
"mantiene una extensión C externa para CPython, puede experimentar con "
"Argument Clinic en su propio código. Pero la versión de Argument Clinic que "
"se envía con la próxima versión de CPython *podría* ser totalmente "
"incompatible y romper todo su código."

#: ../Doc/howto/clinic.rst:29
msgid "The Goals Of Argument Clinic"
msgstr "Los objetivos del Argument Clinic"

#: ../Doc/howto/clinic.rst:31
msgid ""
"Argument Clinic's primary goal is to take over responsibility for all "
"argument parsing code inside CPython.  This means that, when you convert a "
"function to work with Argument Clinic, that function should no longer do any "
"of its own argument parsing—the code generated by Argument Clinic should be "
"a \"black box\" to you, where CPython calls in at the top, and your code "
"gets called at the bottom, with ``PyObject *args`` (and maybe ``PyObject "
"*kwargs``) magically converted into the C variables and types you need."
msgstr ""
"El objetivo principal de Argument Clinic es asumir la responsabilidad de "
"todo el código de análisis de argumentos dentro de CPython. Esto significa "
"que, cuando convierte una función para que funcione con Argument Clinic, esa "
"función ya no debería realizar ninguno de sus propios análisis de "
"argumentos; el código generado por Argument Clinic debería ser una \"caja "
"negra\" para usted, donde CPython llama al top, y su código se llama en la "
"parte inferior, con ``PyObject *args`` (y tal vez ``PyObject *kwargs``) "
"convertido mágicamente en las variables y tipos C que necesita."

#: ../Doc/howto/clinic.rst:41
msgid ""
"In order for Argument Clinic to accomplish its primary goal, it must be easy "
"to use.  Currently, working with CPython's argument parsing library is a "
"chore, requiring maintaining redundant information in a surprising number of "
"places. When you use Argument Clinic, you don't have to repeat yourself."
msgstr ""
"Para que Argument Clinic logre su objetivo principal, debe ser fácil de "
"usar. Actualmente, trabajar con la biblioteca de análisis de argumentos de "
"CPython es una tarea ardua que requiere mantener información redundante en "
"un número sorprendente de lugares. Cuando usa Argument Clinic, no tiene que "
"repetirse."

#: ../Doc/howto/clinic.rst:47
msgid ""
"Obviously, no one would want to use Argument Clinic unless it's solving "
"their problem—and without creating new problems of its own. So it's "
"paramount that Argument Clinic generate correct code. It'd be nice if the "
"code was faster, too, but at the very least it should not introduce a major "
"speed regression.  (Eventually Argument Clinic *should* make a major speedup "
"possible—we could rewrite its code generator to produce tailor-made argument "
"parsing code, rather than calling the general-purpose CPython argument "
"parsing library.  That would make for the fastest argument parsing possible!)"
msgstr ""
"Obviamente, si Argument Clinic no produjo ningún resultado, es porque "
"encontró un error en su entrada. Siga corrigiendo sus errores y vuelva a "
"intentarlo hasta que Argument Clinic procese su archivo sin quejas."

#: ../Doc/howto/clinic.rst:59
msgid ""
"Additionally, Argument Clinic must be flexible enough to work with any "
"approach to argument parsing.  Python has some functions with some very "
"strange parsing behaviors; Argument Clinic's goal is to support all of them."
msgstr ""
"Además, Argument Clinic debe ser lo suficientemente flexible como para "
"trabajar con cualquier enfoque de análisis de argumentos. Python tiene "
"algunas funciones con algunos comportamientos de análisis muy extraños; El "
"objetivo de Argument Clinic es apoyarlos a todos."

#: ../Doc/howto/clinic.rst:64
msgid ""
"Finally, the original motivation for Argument Clinic was to provide "
"introspection \"signatures\" for CPython builtins. It used to be, the "
"introspection query functions would throw an exception if you passed in a "
"builtin.  With Argument Clinic, that's a thing of the past!"
msgstr ""
"Finalmente, la motivación original de Argument Clinic era proporcionar "
"\"firmas\" de introspección para las incorporaciones de CPython. Solía ser, "
"las funciones de consulta de introspección lanzarían una excepción si pasaba "
"un archivo incorporado. ¡Con Argument Clinic, eso es cosa del pasado!"

#: ../Doc/howto/clinic.rst:70
msgid ""
"One idea you should keep in mind, as you work with Argument Clinic: the more "
"information you give it, the better job it'll be able to do. Argument Clinic "
"is admittedly relatively simple right now.  But as it evolves it will get "
"more sophisticated, and it should be able to do many interesting and smart "
"things with all the information you give it."
msgstr ""
"Una idea que debe tener en cuenta al trabajar con Argument Clinic: cuanta "
"más información le dé, mejor será su trabajo. Argument Clinic es ciertamente "
"relativamente simple en este momento. Pero a medida que evolucione, se "
"volverá más sofisticado y debería poder hacer muchas cosas interesantes e "
"inteligentes con toda la información que le proporcione."

#: ../Doc/howto/clinic.rst:80
msgid "Basic Concepts And Usage"
msgstr "Conceptos básicos y uso"

#: ../Doc/howto/clinic.rst:82
msgid ""
"Argument Clinic ships with CPython; you'll find it in ``Tools/clinic/clinic."
"py``. If you run that script, specifying a C file as an argument:"
msgstr ""
"Argument Clinic se envía con CPython; lo encontrará en ``Tools/clinic/clinic."
"py``. Si ejecuta ese script, especificando un archivo C como argumento:"

#: ../Doc/howto/clinic.rst:89
msgid ""
"Argument Clinic will scan over the file looking for lines that look exactly "
"like this:"
msgstr ""
"Argument Clinic escaneará el archivo buscando líneas que se vean exactamente "
"así:"

#: ../Doc/howto/clinic.rst:96
msgid ""
"When it finds one, it reads everything up to a line that looks exactly like "
"this:"
msgstr ""
"Cuando encuentra uno, lee todo hasta una línea que se ve exactamente así:"

#: ../Doc/howto/clinic.rst:103
msgid ""
"Everything in between these two lines is input for Argument Clinic. All of "
"these lines, including the beginning and ending comment lines, are "
"collectively called an Argument Clinic \"block\"."
msgstr ""
"Todo lo que se encuentra entre estas dos líneas es entrada para Argument "
"Clinic. Todas estas líneas, incluidas las líneas de comentarios iniciales y "
"finales, se denominan colectivamente un \"bloque\" de Argument Clinic."

#: ../Doc/howto/clinic.rst:107
msgid ""
"When Argument Clinic parses one of these blocks, it generates output.  This "
"output is rewritten into the C file immediately after the block, followed by "
"a comment containing a checksum. The Argument Clinic block now looks like "
"this:"
msgstr ""
"Cuando Argument Clinic analiza uno de estos bloques, genera una salida. Esta "
"salida se reescribe en el archivo C inmediatamente después del bloque, "
"seguida de un comentario que contiene una suma de comprobación. El bloque "
"Argument Clinic ahora tiene este aspecto:"

#: ../Doc/howto/clinic.rst:120
msgid ""
"If you run Argument Clinic on the same file a second time, Argument Clinic "
"will discard the old output and write out the new output with a fresh "
"checksum line.  However, if the input hasn't changed, the output won't "
"change either."
msgstr ""
"Si ejecuta Argument Clinic en el mismo archivo por segunda vez, Argument "
"Clinic descartará la salida anterior y escribirá la nueva salida con una "
"nueva línea de suma de comprobación. Sin embargo, si la entrada no ha "
"cambiado, la salida tampoco cambiará."

#: ../Doc/howto/clinic.rst:124
msgid ""
"You should never modify the output portion of an Argument Clinic block.  "
"Instead, change the input until it produces the output you want.  (That's "
"the purpose of the checksum—to detect if someone changed the output, as "
"these edits would be lost the next time Argument Clinic writes out fresh "
"output.)"
msgstr ""
"Nunca debe modificar la parte de salida de un bloque de Argument Clinic. En "
"su lugar, cambie la entrada hasta que produzca la salida que desea. (Ese es "
"el propósito de la suma de comprobación: detectar si alguien cambió la "
"salida, ya que estas ediciones se perderían la próxima vez que Argument "
"Clinic escriba una salida nueva)."

#: ../Doc/howto/clinic.rst:129
msgid ""
"For the sake of clarity, here's the terminology we'll use with Argument "
"Clinic:"
msgstr ""
"En aras de la claridad, esta es la terminología que usaremos con Argument "
"Clinic:"

#: ../Doc/howto/clinic.rst:131
msgid ""
"The first line of the comment (``/*[clinic input]``) is the *start line*."
msgstr ""
"La primera línea del comentario (``/*[clinic input]``) es la *línea de "
"inicio*."

#: ../Doc/howto/clinic.rst:132
msgid ""
"The last line of the initial comment (``[clinic start generated code]*/``) "
"is the *end line*."
msgstr ""
"La última línea del comentario inicial (``[clinic start generated code]*/``) "
"es la *línea final*."

#: ../Doc/howto/clinic.rst:133
msgid ""
"The last line (``/*[clinic end generated code: checksum=...]*/``) is the "
"*checksum line*."
msgstr ""
"La última línea (``/*[clinic end generated code: checksum=...]*/``) es la "
"*línea de suma de comprobación* (*chemsum line*)."

#: ../Doc/howto/clinic.rst:134
msgid "In between the start line and the end line is the *input*."
msgstr "Entre la línea de inicio y la línea final está el *input*."

#: ../Doc/howto/clinic.rst:135
msgid "In between the end line and the checksum line is the *output*."
msgstr ""
"Entre la línea final y la línea de suma de comprobación se encuentra la "
"*output*."

#: ../Doc/howto/clinic.rst:136
msgid ""
"All the text collectively, from the start line to the checksum line "
"inclusively, is the *block*.  (A block that hasn't been successfully "
"processed by Argument Clinic yet doesn't have output or a checksum line, but "
"it's still considered a block.)"
msgstr ""
"Todo el texto colectivamente, desde la línea de inicio hasta la línea de "
"suma de verificación inclusive, es el *bloque*. (Un bloque que no ha sido "
"procesado con éxito por Argument Clinic todavía no tiene salida o una línea "
"de suma de verificación, pero aún se considera un bloque)."

#: ../Doc/howto/clinic.rst:143
msgid "Converting Your First Function"
msgstr "Convirtiendo su primera función"

#: ../Doc/howto/clinic.rst:145
msgid ""
"The best way to get a sense of how Argument Clinic works is to convert a "
"function to work with it.  Here, then, are the bare minimum steps you'd need "
"to follow to convert a function to work with Argument Clinic.  Note that for "
"code you plan to check in to CPython, you really should take the conversion "
"farther, using some of the advanced concepts you'll see later on in the "
"document (like \"return converters\" and \"self converters\"). But we'll "
"keep it simple for this walkthrough so you can learn."
msgstr ""
"La mejor manera de tener una idea de cómo funciona Argument Clinic es "
"convertir una función para que funcione con ella. Aquí, entonces, están los "
"pasos mínimos que debe seguir para convertir una función para que funcione "
"con Argument Clinic. Tenga en cuenta que para el código que planea registrar "
"en CPython, realmente debería llevar la conversión más lejos, utilizando "
"algunos de los conceptos avanzados que verá más adelante en el documento "
"(como \"convertidores de retorno\" y \"convertidores automáticos\"). Pero lo "
"haremos simple para este tutorial para que pueda aprender."

#: ../Doc/howto/clinic.rst:154
msgid "Let's dive in!"
msgstr "¡Vamos a sumergirnos!"

#: ../Doc/howto/clinic.rst:156
msgid ""
"Make sure you're working with a freshly updated checkout of the CPython "
"trunk."
msgstr ""
"Asegúrese de estar trabajando con una versión recién actualizada de CPython."

#: ../Doc/howto/clinic.rst:159
msgid ""
"Find a Python builtin that calls either :c:func:`PyArg_ParseTuple` or :c:"
"func:`PyArg_ParseTupleAndKeywords`, and hasn't been converted to work with "
"Argument Clinic yet. For my example I'm using ``_pickle.Pickler.dump()``."
msgstr ""
"Busca un incorporado de Python que llame a :c:func:`PyArg_ParseTuple` o :c:"
"func:`PyArg_ParseTupleAndKeywords`, y que aún no se haya convertido para "
"funcionar con Argument Clinic. Para mi ejemplo, estoy usando ``_pickle."
"Pickler.dump()``."

#: ../Doc/howto/clinic.rst:164
msgid ""
"If the call to the ``PyArg_Parse`` function uses any of the following format "
"units:"
msgstr ""
"Si la llamada a la función ``PyArg_Parse`` usa cualquiera de las siguientes "
"unidades de formato:"

#: ../Doc/howto/clinic.rst:176
msgid ""
"or if it has multiple calls to :c:func:`PyArg_ParseTuple`, you should choose "
"a different function.  Argument Clinic *does* support all of these "
"scenarios.  But these are advanced topics—let's do something simpler for "
"your first function."
msgstr ""
"o si tiene múltiples llamadas a :c:func:`PyArg_ParseTuple`, debes elegir una "
"función diferente. Argument Clinic *sí* admite todos estos escenarios. Pero "
"estos son temas avanzados; hagamos algo más simple para su primera función."

#: ../Doc/howto/clinic.rst:181
msgid ""
"Also, if the function has multiple calls to :c:func:`PyArg_ParseTuple` or :c:"
"func:`PyArg_ParseTupleAndKeywords` where it supports different types for the "
"same argument, or if the function uses something besides PyArg_Parse "
"functions to parse its arguments, it probably isn't suitable for conversion "
"to Argument Clinic.  Argument Clinic doesn't support generic functions or "
"polymorphic parameters."
msgstr ""
"Además, si la función tiene múltiples llamadas a :c:func:`PyArg_ParseTuple` "
"o :c:func:`PyArg_ParseTupleAndKeywords` donde admite diferentes tipos para "
"el mismo argumento, o si la función usa algo además de las funciones "
"PyArg_Parse para analizar sus argumentos, probablemente no sea adecuado para "
"la conversión a Argument Clinic. Argument Clinic no admite funciones "
"genéricas ni parámetros polimórficos."

#: ../Doc/howto/clinic.rst:188
msgid "Add the following boilerplate above the function, creating our block::"
msgstr ""
"Agrega la siguiente plantilla sobre la función, creando nuestro bloque ::"

#: ../Doc/howto/clinic.rst:193
msgid ""
"Cut the docstring and paste it in between the ``[clinic]`` lines, removing "
"all the junk that makes it a properly quoted C string. When you're done you "
"should have just the text, based at the left margin, with no line wider than "
"80 characters. (Argument Clinic will preserve indents inside the docstring.)"
msgstr ""
"Corta el docstring y lo pega entre las líneas ``[clinic]``, eliminando toda "
"la basura que la convierte en una cadena C entre comillas. Cuando haya "
"terminado, debería tener solo el texto, basado en el margen izquierdo, sin "
"una línea de más de 80 caracteres. (Argument Clinic conservará las sangrías "
"dentro del docstring)."

#: ../Doc/howto/clinic.rst:199
msgid ""
"If the old docstring had a first line that looked like a function signature, "
"throw that line away.  (The docstring doesn't need it anymore—when you use "
"``help()`` on your builtin in the future, the first line will be built "
"automatically based on the function's signature.)"
msgstr ""
"Si el docstring antiguo tenía una primera línea que parecía una firma de "
"función, elimine esa línea. (El docstring ya no la necesita; cuando use "
"``help()`` en su incorporado en el futuro, la primera línea se creará "
"automáticamente en función de la firma de la función)."

#: ../Doc/howto/clinic.rst:205 ../Doc/howto/clinic.rst:226
#: ../Doc/howto/clinic.rst:250 ../Doc/howto/clinic.rst:308
#: ../Doc/howto/clinic.rst:348 ../Doc/howto/clinic.rst:375
#: ../Doc/howto/clinic.rst:481 ../Doc/howto/clinic.rst:533
msgid "Sample::"
msgstr "Muestra::"

#: ../Doc/howto/clinic.rst:211
msgid ""
"If your docstring doesn't have a \"summary\" line, Argument Clinic will "
"complain.  So let's make sure it has one.  The \"summary\" line should be a "
"paragraph consisting of a single 80-column line at the beginning of the "
"docstring."
msgstr ""
"Si su cadena de documentos no tiene una línea de \"resumen\", Argument "
"Clinic se quejará. Así que asegurémonos de que tenga uno. La línea de "
"\"resumen\" debe ser un párrafo que consta de una sola línea de 80 columnas "
"al comienzo de la cadena de documentos."

#: ../Doc/howto/clinic.rst:216
msgid ""
"(Our example docstring consists solely of a summary line, so the sample code "
"doesn't have to change for this step.)"
msgstr ""
"(Nuestro docstring de ejemplo consiste únicamente en una línea de resumen, "
"por lo que el código de muestra no tiene que cambiar para este paso.)"

#: ../Doc/howto/clinic.rst:219
msgid ""
"Above the docstring, enter the name of the function, followed by a blank "
"line.  This should be the Python name of the function, and should be the "
"full dotted path to the function—it should start with the name of the "
"module, include any sub-modules, and if the function is a method on a class "
"it should include the class name too."
msgstr ""
"Sobre el docstring, ingrese el nombre de la función, seguido de una línea en "
"blanco. Este debería ser el nombre de Python de la función, y debería ser la "
"ruta de puntos completa a la función; debería comenzar con el nombre del "
"módulo, incluir cualquier submódulo y, si la función es un método en una "
"clase, debe incluir el nombre de la clase también."

#: ../Doc/howto/clinic.rst:234
msgid ""
"If this is the first time that module or class has been used with Argument "
"Clinic in this C file, you must declare the module and/or class.  Proper "
"Argument Clinic hygiene prefers declaring these in a separate block "
"somewhere near the top of the C file, in the same way that include files and "
"statics go at the top.  (In our sample code we'll just show the two blocks "
"next to each other.)"
msgstr ""
"Si es la primera vez que ese módulo o clase se utiliza con Argument Clinic "
"en este archivo C, debe declarar el módulo o la clase. La higiene de la "
"clínica de argumentos apropiados prefiere declararlos en un bloque separado "
"en algún lugar cerca de la parte superior del archivo C, de la misma manera "
"que los archivos de inclusión y las estadísticas van en la parte superior. "
"(En nuestro código de muestra, solo mostraremos los dos bloques uno al lado "
"del otro)."

#: ../Doc/howto/clinic.rst:242
msgid ""
"The name of the class and module should be the same as the one seen by "
"Python.  Check the name defined in the :c:type:`PyModuleDef` or :c:type:"
"`PyTypeObject` as appropriate."
msgstr ""
"El nombre de la clase y el módulo debe ser el mismo que el visto por Python. "
"Compruebe el nombre definido en :c:type:`PyModuleDef` o :c:type:"
"`PyTypeObject` según corresponda."

#: ../Doc/howto/clinic.rst:246
msgid ""
"When you declare a class, you must also specify two aspects of its type in "
"C: the type declaration you'd use for a pointer to an instance of this "
"class, and a pointer to the :c:type:`PyTypeObject` for this class."
msgstr ""
"Cuando declaras una clase, también debes especificar dos aspectos de su tipo "
"en C: la declaración de tipo que usarías para un puntero a una instancia de "
"esta clase y un puntero a :c:type:`PyTypeObject` para esto clase."

#: ../Doc/howto/clinic.rst:266
msgid ""
"Declare each of the parameters to the function.  Each parameter should get "
"its own line.  All the parameter lines should be indented from the function "
"name and the docstring."
msgstr ""
"Declare cada uno de los parámetros a la función. Cada parámetro debe tener "
"su propia línea. Todas las líneas de parámetros deben tener sangría del "
"nombre de la función y el docstring."

#: ../Doc/howto/clinic.rst:270
msgid "The general form of these parameter lines is as follows:"
msgstr "La forma general de estas líneas de parámetros es la siguiente:"

#: ../Doc/howto/clinic.rst:276
msgid "If the parameter has a default value, add that after the converter:"
msgstr ""
"Si el parámetro tiene un valor predeterminado, agréguelo después del "
"convertidor:"

#: ../Doc/howto/clinic.rst:283
msgid ""
"Argument Clinic's support for \"default values\" is quite sophisticated; "
"please see :ref:`the section below on default values <default_values>` for "
"more information."
msgstr ""
"El soporte de Argument Clinic para \"valores predeterminados\" es bastante "
"sofisticado; por favor vea :ref:`la sección a continuación sobre valores "
"predeterminados <default_values>` para más información."

#: ../Doc/howto/clinic.rst:287
msgid "Add a blank line below the parameters."
msgstr "Agrega una línea en blanco debajo de los parámetros."

#: ../Doc/howto/clinic.rst:289
msgid ""
"What's a \"converter\"?  It establishes both the type of the variable used "
"in C, and the method to convert the Python value into a C value at runtime. "
"For now you're going to use what's called a \"legacy converter\"—a "
"convenience syntax intended to make porting old code into Argument Clinic "
"easier."
msgstr ""
"¿Qué es un \"convertidor\"? Establece tanto el tipo de variable utilizada en "
"C como el método para convertir el valor de Python en un valor de C en "
"tiempo de ejecución. Por ahora, va a utilizar lo que se llama un "
"\"convertidor heredado\", una sintaxis conveniente destinada a facilitar la "
"migración del código antiguo a Argument Clinic."

#: ../Doc/howto/clinic.rst:296
msgid ""
"For each parameter, copy the \"format unit\" for that parameter from the "
"``PyArg_Parse()`` format argument and specify *that* as its converter, as a "
"quoted string.  (\"format unit\" is the formal name for the one-to-three "
"character substring of the ``format`` parameter that tells the argument "
"parsing function what the type of the variable is and how to convert it.  "
"For more on format units please see :ref:`arg-parsing`.)"
msgstr ""
"Para cada parámetro, copie la \"unidad de formato\" para ese parámetro del "
"argumento de formato ``PyArg_Parse()`` y especifique *eso* como su "
"convertidor, como una cadena entre comillas. (\"unidad de formato\" es el "
"nombre formal de la subcadena de caracteres de uno a tres caracteres del "
"parámetro ``format`` que le dice a la función de análisis de argumentos cuál "
"es el tipo de variable y cómo convertirla. Para más información sobre las "
"unidades de formato por favor vea :ref:`arg-parsing`.)"

#: ../Doc/howto/clinic.rst:305
msgid ""
"For multicharacter format units like ``z#``, use the entire two-or-three "
"character string."
msgstr ""
"Para unidades de formato de caracteres múltiples como ``z#``, use la cadena "
"completa de dos o tres caracteres."

#: ../Doc/howto/clinic.rst:323
msgid ""
"If your function has ``|`` in the format string, meaning some parameters "
"have default values, you can ignore it.  Argument Clinic infers which "
"parameters are optional based on whether or not they have default values."
msgstr ""
"Si su función tiene ``|`` en la cadena de formato, lo que significa que "
"algunos parámetros tienen valores predeterminados, puede ignorarlo. Argument "
"Clinic infiere qué parámetros son opcionales en función de si tienen o no "
"valores predeterminados."

#: ../Doc/howto/clinic.rst:328
msgid ""
"If your function has ``$`` in the format string, meaning it takes keyword-"
"only arguments, specify ``*`` on a line by itself before the first keyword-"
"only argument, indented the same as the parameter lines."
msgstr ""
"Si su función tiene ``$`` en la cadena de caracteres de formato, lo que "
"significa que toma argumentos de solo palabras clave, especifique ``*`` en "
"una línea antes del primer argumento de solo palabras clave, con la misma "
"indentación que las líneas de parámetros."

#: ../Doc/howto/clinic.rst:333
msgid "(``_pickle.Pickler.dump`` has neither, so our sample is unchanged.)"
msgstr ""
"(``_pickle.Pickler.dump`` no tiene ninguno, por lo que nuestro ejemplo no ha "
"cambiado.)"

#: ../Doc/howto/clinic.rst:336
msgid ""
"If the existing C function calls :c:func:`PyArg_ParseTuple` (as opposed to :"
"c:func:`PyArg_ParseTupleAndKeywords`), then all its arguments are positional-"
"only."
msgstr ""
"Si la función C existente llama a :c:func:`PyArg_ParseTuple` (a diferencia "
"de :c:func:`PyArg_ParseTupleAndKeywords`), entonces todos sus argumentos son "
"solo posicionales."

#: ../Doc/howto/clinic.rst:340
msgid ""
"To mark all parameters as positional-only in Argument Clinic, add a ``/`` on "
"a line by itself after the last parameter, indented the same as the "
"parameter lines."
msgstr ""
"Para marcar todos los parámetros como solo posicionales en Argument Clinic, "
"agregue un ``/`` en una línea después del último parámetro, con la misma "
"sangría que las líneas de parámetros."

#: ../Doc/howto/clinic.rst:344
msgid ""
"Currently this is all-or-nothing; either all parameters are positional-only, "
"or none of them are.  (In the future Argument Clinic may relax this "
"restriction.)"
msgstr ""
"Actualmente esto es todo o nada; o todos los parámetros son solo "
"posicionales o ninguno de ellos lo es. (En el futuro, Argument Clinic puede "
"relajar esta restricción)."

#: ../Doc/howto/clinic.rst:364
msgid ""
"It's helpful to write a per-parameter docstring for each parameter. But per-"
"parameter docstrings are optional; you can skip this step if you prefer."
msgstr ""
"Es útil escribir una cadena de documentos por parámetro para cada parámetro. "
"Pero los docstrings por parámetro son opcionales; puede omitir este paso si "
"lo prefiere."

#: ../Doc/howto/clinic.rst:368
msgid ""
"Here's how to add a per-parameter docstring.  The first line of the per-"
"parameter docstring must be indented further than the parameter definition.  "
"The left margin of this first line establishes the left margin for the whole "
"per-parameter docstring; all the text you write will be outdented by this "
"amount.  You can write as much text as you like, across multiple lines if "
"you wish."
msgstr ""
"A continuación, se explica cómo agregar un docstring por parámetro. La "
"primera línea del docstring por parámetro debe tener más sangría que la "
"definición del parámetro. El margen izquierdo de esta primera línea "
"establece el margen izquierdo para todo el docstring por parámetro; todo el "
"texto que escriba se verá afectado por esta cantidad. Puede escribir todo el "
"texto que desee, en varias líneas si lo desea."

#: ../Doc/howto/clinic.rst:392
msgid ""
"Save and close the file, then run ``Tools/clinic/clinic.py`` on it.  With "
"luck everything worked---your block now has output, and a ``.c.h`` file has "
"been generated! Reopen the file in your text editor to see::"
msgstr ""
"Guarde y cierre el archivo, luego ejecute ``Tools/clinic/clinic.py`` en él. "
"¡Con suerte, todo funcionó --- su bloque ahora tiene salida y se ha generado "
"un archivo ``.c.h`` ! Vuelva a abrir el archivo en su editor de texto para "
"ver:"

#: ../Doc/howto/clinic.rst:411
msgid ""
"Obviously, if Argument Clinic didn't produce any output, it's because it "
"found an error in your input.  Keep fixing your errors and retrying until "
"Argument Clinic processes your file without complaint."
msgstr ""
"Obviamente, si Argument Clinic no produjo ningún resultado, es porque "
"encontró un error en su entrada. Siga corrigiendo sus errores y vuelva a "
"intentarlo hasta que Argument Clinic procese su archivo sin quejas."

#: ../Doc/howto/clinic.rst:415
msgid ""
"For readability, most of the glue code has been generated to a ``.c.h`` "
"file.  You'll need to include that in your original ``.c`` file, typically "
"right after the clinic module block::"
msgstr ""
"Para facilitar la lectura, la mayor parte del código de pegamento se ha "
"generado en un archivo ``.c.h``. Deberá incluir eso en su archivo ``.c`` "
"original, generalmente justo después del bloque del módulo de la clínica:"

#: ../Doc/howto/clinic.rst:421
msgid ""
"Double-check that the argument-parsing code Argument Clinic generated looks "
"basically the same as the existing code."
msgstr ""
"Vuelva a verificar que el código de análisis de argumentos generado por "
"Argument Clinic se ve básicamente igual al código existente."

#: ../Doc/howto/clinic.rst:424
msgid ""
"First, ensure both places use the same argument-parsing function. The "
"existing code must call either :c:func:`PyArg_ParseTuple` or :c:func:"
"`PyArg_ParseTupleAndKeywords`; ensure that the code generated by Argument "
"Clinic calls the *exact* same function."
msgstr ""
"Primero, asegúrese de que ambos lugares usen la misma función de análisis de "
"argumentos. El código existente debe llamar a :c:func:`PyArg_ParseTuple` o :"
"c:func:`PyArg_ParseTupleAndKeywords`; asegúrese de que el código generado "
"por Argument Clinic llame a la misma *exacta* función."

#: ../Doc/howto/clinic.rst:430
msgid ""
"Second, the format string passed in to :c:func:`PyArg_ParseTuple` or :c:func:"
"`PyArg_ParseTupleAndKeywords` should be *exactly* the same as the hand-"
"written one in the existing function, up to the colon or semi-colon."
msgstr ""
"En segundo lugar, la cadena de formato pasada a :c:func:`PyArg_ParseTuple` "
"o :c:func:`PyArg_ParseTupleAndKeywords` debe ser *exactamente* la misma que "
"la escrita a mano en la función existente, hasta los dos puntos o punto y "
"coma."

#: ../Doc/howto/clinic.rst:435
msgid ""
"(Argument Clinic always generates its format strings with a ``:`` followed "
"by the name of the function.  If the existing code's format string ends with "
"``;``, to provide usage help, this change is harmless—don't worry about it.)"
msgstr ""
"(Argument Clinic siempre genera sus cadenas de caracteres de formato con un "
"``:`` seguido del nombre de la función. Si la cadena de caracteres de "
"formato del código existente termina con ``;``, para proporcionar ayuda de "
"uso, este cambio es inofensivo; no se preocupe)"

#: ../Doc/howto/clinic.rst:440
msgid ""
"Third, for parameters whose format units require two arguments (like a "
"length variable, or an encoding string, or a pointer to a conversion "
"function), ensure that the second argument is *exactly* the same between the "
"two invocations."
msgstr ""
"En tercer lugar, para los parámetros cuyas unidades de formato requieren dos "
"argumentos (como una variable de longitud, una cadena de codificación o un "
"puntero a una función de conversión), asegúrese de que el segundo argumento "
"sea *exactamente* el mismo entre las dos invocaciones."

#: ../Doc/howto/clinic.rst:445
msgid ""
"Fourth, inside the output portion of the block you'll find a preprocessor "
"macro defining the appropriate static :c:type:`PyMethodDef` structure for "
"this builtin::"
msgstr ""
"En cuarto lugar, dentro de la parte de salida del bloque, encontrará una "
"macro de preprocesador que define la estructura static :c:type:`PyMethodDef` "
"apropiada para este incorporado::"

#: ../Doc/howto/clinic.rst:452
msgid ""
"This static structure should be *exactly* the same as the existing static :c:"
"type:`PyMethodDef` structure for this builtin."
msgstr ""
"Esta estructura estática debe ser *exactamente* la misma que la estructura "
"estática existente :c:type:`PyMethodDef` para este incorporado."

#: ../Doc/howto/clinic.rst:455
msgid ""
"If any of these items differ in *any way*, adjust your Argument Clinic "
"function specification and rerun ``Tools/clinic/clinic.py`` until they *are* "
"the same."
msgstr ""
"Si alguno de estos elementos difiere *de alguna manera*, ajuste la "
"especificación de la función de Argument Clinic y vuelva a ejecutar ``Tools/"
"clinic/clinic.py`` hasta que *sean* iguales."

#: ../Doc/howto/clinic.rst:460
msgid ""
"Notice that the last line of its output is the declaration of your \"impl\" "
"function.  This is where the builtin's implementation goes. Delete the "
"existing prototype of the function you're modifying, but leave the opening "
"curly brace.  Now delete its argument parsing code and the declarations of "
"all the variables it dumps the arguments into. Notice how the Python "
"arguments are now arguments to this impl function; if the implementation "
"used different names for these variables, fix it."
msgstr ""
"Observe que la última línea de su salida es la declaración de su función "
"\"impl\". Aquí es donde va la implementación incorporada. Elimine el "
"prototipo existente de la función que está modificando, pero deje la llave "
"de apertura. Ahora elimine su código de análisis de argumentos y las "
"declaraciones de todas las variables en las que vierte los argumentos. "
"Observe cómo los argumentos de Python ahora son argumentos para esta función "
"implícita; si la implementación usó nombres diferentes para estas variables, "
"corríjalo."

#: ../Doc/howto/clinic.rst:468
msgid ""
"Let's reiterate, just because it's kind of weird.  Your code should now look "
"like this::"
msgstr ""
"Reiteremos, solo porque es un poco extraño. Su código ahora debería verse "
"así:"

#: ../Doc/howto/clinic.rst:477
msgid ""
"Argument Clinic generated the checksum line and the function prototype just "
"above it.  You should write the opening (and closing) curly braces for the "
"function, and the implementation inside."
msgstr ""
"Argument Clinic generó la línea de suma de comprobación y el prototipo de "
"función justo encima de ella. Debe escribir las llaves de apertura (y "
"cierre) para la función y la implementación en el interior."

#: ../Doc/howto/clinic.rst:522
msgid ""
"Remember the macro with the :c:type:`PyMethodDef` structure for this "
"function?  Find the existing :c:type:`PyMethodDef` structure for this "
"function and replace it with a reference to the macro.  (If the builtin is "
"at module scope, this will probably be very near the end of the file; if the "
"builtin is a class method, this will probably be below but relatively near "
"to the implementation.)"
msgstr ""
"¿Recuerda la macro con la estructura :c:type:`PyMethodDef` para esta "
"función? Busque la estructura existente :c:type:`PyMethodDef` para esta "
"función y la reemplaza con una referencia a la macro. (Si el incorporado "
"está en el alcance del módulo, esto probablemente estará muy cerca del final "
"del archivo; si el incorporado es un método de clase, probablemente estará "
"debajo pero relativamente cerca de la implementación)."

#: ../Doc/howto/clinic.rst:529
msgid ""
"Note that the body of the macro contains a trailing comma.  So when you "
"replace the existing static :c:type:`PyMethodDef` structure with the macro, "
"*don't* add a comma to the end."
msgstr ""
"Tenga en cuenta que el cuerpo de la macro contiene una coma al final. "
"Entonces, cuando reemplace la estructura static :c:type:`PyMethodDef` "
"existente con la macro, *no* agregue una coma al final."

#: ../Doc/howto/clinic.rst:542
msgid ""
"Compile, then run the relevant portions of the regression-test suite. This "
"change should not introduce any new compile-time warnings or errors, and "
"there should be no externally-visible change to Python's behavior."
msgstr ""
"Compile y luego ejecute las partes relevantes del conjunto de pruebas de "
"regresión. Este cambio no debería introducir nuevas advertencias o errores "
"en tiempo de compilación, y no debería haber ningún cambio visible desde el "
"exterior en el comportamiento de Python."

#: ../Doc/howto/clinic.rst:546
msgid ""
"Well, except for one difference: ``inspect.signature()`` run on your "
"function should now provide a valid signature!"
msgstr ""
"Bueno, excepto por una diferencia: ``inspect.signature()`` ejecutar en su "
"función ahora debería proporcionar una firma válida!"

#: ../Doc/howto/clinic.rst:549
msgid ""
"Congratulations, you've ported your first function to work with Argument "
"Clinic!"
msgstr ""
"¡Felicitaciones, ha adaptado su primera función para trabajar con Argument "
"Clinic!"

#: ../Doc/howto/clinic.rst:552
msgid "Advanced Topics"
msgstr "Temas avanzados"

#: ../Doc/howto/clinic.rst:554
msgid ""
"Now that you've had some experience working with Argument Clinic, it's time "
"for some advanced topics."
msgstr ""
"Ahora que ha tenido algo de experiencia trabajando con Argument Clinic, es "
"hora de algunos temas avanzados."

#: ../Doc/howto/clinic.rst:559
msgid "Symbolic default values"
msgstr "Valores predeterminados simbólicos"

#: ../Doc/howto/clinic.rst:561
msgid ""
"The default value you provide for a parameter can't be any arbitrary "
"expression.  Currently the following are explicitly supported:"
msgstr ""
"El valor predeterminado que proporcione para un parámetro no puede ser una "
"expresión arbitraria. Actualmente, lo siguiente se admite explícitamente:"

#: ../Doc/howto/clinic.rst:564
msgid "Numeric constants (integer and float)"
msgstr "Constantes numéricas (enteros y flotantes)"

#: ../Doc/howto/clinic.rst:565
msgid "String constants"
msgstr "Constantes de cadena de caracteres"

#: ../Doc/howto/clinic.rst:566
msgid "``True``, ``False``, and ``None``"
msgstr "``True``, ``False``, y ``None``"

#: ../Doc/howto/clinic.rst:567
msgid ""
"Simple symbolic constants like ``sys.maxsize``, which must start with the "
"name of the module"
msgstr ""
"Constantes simbólicas simples como ``sys.maxsize``, que debe comenzar con el "
"nombre del módulo"

#: ../Doc/howto/clinic.rst:570
msgid ""
"In case you're curious, this is implemented in  ``from_builtin()`` in ``Lib/"
"inspect.py``."
msgstr ""
"En caso de que tenga curiosidad, esto se implementa en ``from_builtin()`` en "
"``Lib/inspect.py``."

#: ../Doc/howto/clinic.rst:573
msgid ""
"(In the future, this may need to get even more elaborate, to allow full "
"expressions like ``CONSTANT - 1``.)"
msgstr ""
"(En el futuro, esto puede necesitar ser aún más elaborado, para permitir "
"expresiones completas como ``CONSTANT - 1``.)"

#: ../Doc/howto/clinic.rst:578
msgid "Renaming the C functions and variables generated by Argument Clinic"
msgstr ""
"Cambiar el nombre de las funciones y variables C generadas por Argument "
"Clinic"

#: ../Doc/howto/clinic.rst:580
msgid ""
"Argument Clinic automatically names the functions it generates for you. "
"Occasionally this may cause a problem, if the generated name collides with "
"the name of an existing C function.  There's an easy solution: override the "
"names used for the C functions.  Just add the keyword ``\"as\"`` to your "
"function declaration line, followed by the function name you wish to use. "
"Argument Clinic will use that function name for the base (generated) "
"function, then add ``\"_impl\"`` to the end and use that for the name of the "
"impl function."
msgstr ""
"Argument Clinic nombra automáticamente las funciones que genera para usted. "
"Ocasionalmente, esto puede causar un problema, si el nombre generado choca "
"con el nombre de una función C existente. Hay una solución sencilla: anule "
"los nombres utilizados para las funciones de C. Simplemente agregue la "
"palabra clave ``\"as\"`` a la línea de declaración de su función, seguida "
"del nombre de la función que desea usar. Argument Clinic usará ese nombre de "
"función para la función base (generada), luego agregará ``\"_impl\"`` al "
"final y lo usará para el nombre de la función impl."

#: ../Doc/howto/clinic.rst:588
msgid ""
"For example, if we wanted to rename the C function names generated for "
"``pickle.Pickler.dump``, it'd look like this::"
msgstr ""
"Por ejemplo, si quisiéramos cambiar el nombre de las funciones de C "
"generadas para ``pickle.Pickler.dump``, se vería así:"

#: ../Doc/howto/clinic.rst:596
msgid ""
"The base function would now be named ``pickler_dumper()``, and the impl "
"function would now be named ``pickler_dumper_impl()``."
msgstr ""
"La función base ahora se llamaría ``pickler_dumper()``, y la función "
"implícita ahora se llamaría ``pickler_dumper_impl()``."

#: ../Doc/howto/clinic.rst:600
msgid ""
"Similarly, you may have a problem where you want to give a parameter a "
"specific Python name, but that name may be inconvenient in C.  Argument "
"Clinic allows you to give a parameter different names in Python and in C, "
"using the same ``\"as\"`` syntax::"
msgstr ""
"De manera similar, es posible que tenga un problema en el que desee asignar "
"un nombre específico de Python a un parámetro, pero ese nombre puede ser "
"inconveniente en C. Argument Clinic le permite asignar nombres diferentes a "
"un parámetro en Python y en C, usando el mismo ``\"as\"`` como sintaxis::"

#: ../Doc/howto/clinic.rst:614
msgid ""
"Here, the name used in Python (in the signature and the ``keywords`` array) "
"would be ``file``, but the C variable would be named ``file_obj``."
msgstr ""
"Aquí, el nombre usado en Python (en la firma y el arreglo de ``keywords``) "
"sería ``file``, pero la variable C se llamaría ``file_obj``."

#: ../Doc/howto/clinic.rst:617
msgid "You can use this to rename the ``self`` parameter too!"
msgstr ""
"¡También puede usar esto para cambiar el nombre del parámetro ``self``!"

#: ../Doc/howto/clinic.rst:621
msgid "Converting functions using PyArg_UnpackTuple"
msgstr "Convirtiendo funciones usando PyArg_UnpackTuple"

#: ../Doc/howto/clinic.rst:623
msgid ""
"To convert a function parsing its arguments with :c:func:"
"`PyArg_UnpackTuple`, simply write out all the arguments, specifying each as "
"an ``object``.  You may specify the ``type`` argument to cast the type as "
"appropriate.  All arguments should be marked positional-only (add a ``/`` on "
"a line by itself after the last argument)."
msgstr ""
"Para convertir una función que analiza sus argumentos con :c:func:"
"`PyArg_UnpackTuple`, simplemente escribe todos los argumentos, especificando "
"cada uno como un ``object``. Puede especificar el argumento ``type`` para "
"convertir el tipo según corresponda. Todos los argumentos deben estar "
"marcados como solo posicionales (agregue un ``/`` en una línea después del "
"último argumento)."

#: ../Doc/howto/clinic.rst:629
msgid ""
"Currently the generated code will use :c:func:`PyArg_ParseTuple`, but this "
"will change soon."
msgstr ""
"Actualmente, el código generado usará :c:func:`PyArg_ParseTuple`, pero esto "
"cambiará pronto."

#: ../Doc/howto/clinic.rst:633
msgid "Optional Groups"
msgstr "Grupos opcionales"

#: ../Doc/howto/clinic.rst:635
msgid ""
"Some legacy functions have a tricky approach to parsing their arguments: "
"they count the number of positional arguments, then use a ``switch`` "
"statement to call one of several different :c:func:`PyArg_ParseTuple` calls "
"depending on how many positional arguments there are.  (These functions "
"cannot accept keyword-only arguments.)  This approach was used to simulate "
"optional arguments back before :c:func:`PyArg_ParseTupleAndKeywords` was "
"created."
msgstr ""
"Algunas funciones heredadas tienen un enfoque complicado para analizar sus "
"argumentos: cuentan el número de argumentos posicionales, luego usan una "
"instrucción ``switch`` para llamar a una de varias llamadas diferentes :c:"
"func:`PyArg_ParseTuple` dependiendo de cuántos argumentos posicionales "
"existen. (Estas funciones no pueden aceptar argumentos de solo palabras "
"clave). Este enfoque se usó para simular argumentos opcionales antes de que "
"se creara :c:func:`PyArg_ParseTupleAndKeywords`."

#: ../Doc/howto/clinic.rst:642
msgid ""
"While functions using this approach can often be converted to use :c:func:"
"`PyArg_ParseTupleAndKeywords`, optional arguments, and default values, it's "
"not always possible.  Some of these legacy functions have behaviors :c:func:"
"`PyArg_ParseTupleAndKeywords` doesn't directly support. The most obvious "
"example is the builtin function ``range()``, which has an optional argument "
"on the *left* side of its required argument! Another example is ``curses."
"window.addch()``, which has a group of two arguments that must always be "
"specified together.  (The arguments are called ``x`` and ``y``; if you call "
"the function passing in ``x``, you must also pass in ``y``—and if you don't "
"pass in ``x`` you may not pass in ``y`` either.)"
msgstr ""
"Si bien las funciones que utilizan este enfoque a menudo se pueden convertir "
"para usar :c:func:`PyArg_ParseTupleAndKeywords`, argumentos opcionales y "
"valores predeterminados, no siempre es posible. Algunas de estas funciones "
"heredadas tienen comportamientos :c:func:`PyArg_ParseTupleAndKeywords` no "
"admite directamente. El ejemplo más obvio es la función incorporada "
"``range()``, que tiene un argumento opcional en el lado *izquierdo* de su "
"argumento requerido. Otro ejemplo es ``curses.window.addch()``, que tiene un "
"grupo de dos argumentos que siempre deben especificarse juntos. (Los "
"argumentos se denominan ``x`` e ``y``; si llama a la función pasando ``x``, "
"también debe pasar ``y``, y si no pasa ``x`` tampoco puede pasar ``y``.)"

#: ../Doc/howto/clinic.rst:654
msgid ""
"In any case, the goal of Argument Clinic is to support argument parsing for "
"all existing CPython builtins without changing their semantics. Therefore "
"Argument Clinic supports this alternate approach to parsing, using what are "
"called *optional groups*. Optional groups are groups of arguments that must "
"all be passed in together. They can be to the left or the right of the "
"required arguments.  They can *only* be used with positional-only parameters."
msgstr ""
"En cualquier caso, el objetivo de Argument Clinic es admitir el análisis de "
"argumentos para todas las incorporaciones CPython existentes sin cambiar su "
"semántica. Por lo tanto, Argument Clinic admite este enfoque alternativo de "
"análisis, utilizando lo que se denominan *grupos opcionales*. Los grupos "
"opcionales son grupos de argumentos que deben pasarse todos juntos. Pueden "
"estar a la izquierda o la derecha de los argumentos requeridos. *Solo* se "
"pueden usar con parámetros de solo posición."

#: ../Doc/howto/clinic.rst:662
msgid ""
"Optional groups are *only* intended for use when converting functions that "
"make multiple calls to :c:func:`PyArg_ParseTuple`! Functions that use *any* "
"other approach for parsing arguments should *almost never* be converted to "
"Argument Clinic using optional groups.  Functions using optional groups "
"currently cannot have accurate signatures in Python, because Python just "
"doesn't understand the concept.  Please avoid using optional groups wherever "
"possible."
msgstr ""
"Los grupos opcionales *solo* están pensados para su uso al convertir "
"funciones que realizan múltiples llamadas a :c:func:`PyArg_ParseTuple`! Las "
"funciones que usan *cualquier* otro enfoque para analizar argumentos deben "
"*casi nunca* convertirse a Argument Clinic usando grupos opcionales. Las "
"funciones que utilizan grupos opcionales actualmente no pueden tener firmas "
"precisas en Python, porque Python simplemente no comprende el concepto. "
"Evite el uso de grupos opcionales siempre que sea posible."

#: ../Doc/howto/clinic.rst:671
msgid ""
"To specify an optional group, add a ``[`` on a line by itself before the "
"parameters you wish to group together, and a ``]`` on a line by itself after "
"these parameters.  As an example, here's how ``curses.window.addch`` uses "
"optional groups to make the first two parameters and the last parameter "
"optional::"
msgstr ""
"Para especificar un grupo opcional, agregue un ``[`` en una línea antes de "
"los parámetros que desea agrupar y un ``]`` en una línea después de estos "
"parámetros. Como ejemplo, así es como ``curses.window.addch`` usa grupos "
"opcionales para hacer que los primeros dos parámetros y el último parámetro "
"sean opcionales:"

#: ../Doc/howto/clinic.rst:700
msgid "Notes:"
msgstr "Notas:"

#: ../Doc/howto/clinic.rst:702
msgid ""
"For every optional group, one additional parameter will be passed into the "
"impl function representing the group.  The parameter will be an int named "
"``group_{direction}_{number}``, where ``{direction}`` is either ``right`` or "
"``left`` depending on whether the group is before or after the required "
"parameters, and ``{number}`` is a monotonically increasing number (starting "
"at 1) indicating how far away the group is from the required parameters.  "
"When the impl is called, this parameter will be set to zero if this group "
"was unused, and set to non-zero if this group was used. (By used or unused, "
"I mean whether or not the parameters received arguments in this invocation.)"
msgstr ""
"Para cada grupo opcional, se pasará un parámetro adicional a la función "
"*impl* que representa al grupo. El parámetro será un int llamado "
"``grupo_{direction}_{number}``, donde ``{direction}`` es ``right`` o "
"``left`` dependiendo de si el grupo está antes o después los parámetros "
"requeridos, y ``{number}`` es un número que aumenta monótonamente "
"(comenzando en 1) que indica qué tan lejos está el grupo de los parámetros "
"requeridos. Cuando se llama a impl, este parámetro se establecerá en cero si "
"este grupo no se usó, y se establecerá en un valor distinto de cero si se "
"usó este grupo. (Por usado o no usado, me refiero a si los parámetros "
"recibieron argumentos en esta invocación)."

#: ../Doc/howto/clinic.rst:713
msgid ""
"If there are no required arguments, the optional groups will behave as if "
"they're to the right of the required arguments."
msgstr ""
"Si no hay argumentos requeridos, los grupos opcionales se comportarán como "
"si estuvieran a la derecha de los argumentos requeridos."

#: ../Doc/howto/clinic.rst:716
msgid ""
"In the case of ambiguity, the argument parsing code favors parameters on the "
"left (before the required parameters)."
msgstr ""
"En el caso de ambigüedad, el código de análisis de argumentos favorece los "
"parámetros de la izquierda (antes de los parámetros requeridos)."

#: ../Doc/howto/clinic.rst:719
msgid "Optional groups can only contain positional-only parameters."
msgstr "Los grupos opcionales solo pueden contener parámetros posicionales."

#: ../Doc/howto/clinic.rst:721
msgid ""
"Optional groups are *only* intended for legacy code.  Please do not use "
"optional groups for new code."
msgstr ""
"Los grupos opcionales son *solo* destinados al código heredado. No utilice "
"grupos opcionales para el código nuevo."

#: ../Doc/howto/clinic.rst:726
msgid "Using real Argument Clinic converters, instead of \"legacy converters\""
msgstr ""
"Usar convertidores de Argument Clinic reales, en lugar de \"convertidores "
"heredados\""

#: ../Doc/howto/clinic.rst:728
msgid ""
"To save time, and to minimize how much you need to learn to achieve your "
"first port to Argument Clinic, the walkthrough above tells you to use "
"\"legacy converters\".  \"Legacy converters\" are a convenience, designed "
"explicitly to make porting existing code to Argument Clinic easier.  And to "
"be clear, their use is acceptable when porting code for Python 3.4."
msgstr ""
"Para ahorrar tiempo y minimizar cuánto necesita aprender para lograr su "
"primer puerto a Argument Clinic, el tutorial anterior le indica que use "
"\"convertidores heredados\". Los \"convertidores heredados\" son una "
"conveniencia, diseñados explícitamente para facilitar la migración del "
"código existente a Argument Clinic. Y para ser claros, su uso es aceptable "
"al portar código para Python 3.4."

#: ../Doc/howto/clinic.rst:735
msgid ""
"However, in the long term we probably want all our blocks to use Argument "
"Clinic's real syntax for converters.  Why?  A couple reasons:"
msgstr ""
"Sin embargo, a largo plazo probablemente queramos que todos nuestros bloques "
"utilicen la sintaxis real de Argument Clinic para los convertidores. ¿Por "
"qué? Un par de razones:"

#: ../Doc/howto/clinic.rst:739
msgid ""
"The proper converters are far easier to read and clearer in their intent."
msgstr ""
"Los convertidores adecuados son mucho más fáciles de leer y más claros en su "
"intención."

#: ../Doc/howto/clinic.rst:740
msgid ""
"There are some format units that are unsupported as \"legacy converters\", "
"because they require arguments, and the legacy converter syntax doesn't "
"support specifying arguments."
msgstr ""
"Hay algunas unidades de formato que no se admiten como \"convertidores "
"heredados\", porque requieren argumentos y la sintaxis del convertidor "
"heredado no admite la especificación de argumentos."

#: ../Doc/howto/clinic.rst:743
msgid ""
"In the future we may have a new argument parsing library that isn't "
"restricted to what :c:func:`PyArg_ParseTuple` supports; this flexibility "
"won't be available to parameters using legacy converters."
msgstr ""
"En el futuro, es posible que tengamos una nueva biblioteca de análisis de "
"argumentos que no esté restringida a lo que :c:func:`PyArg_ParseTuple` "
"admite; esta flexibilidad no estará disponible para los parámetros que "
"utilizan convertidores heredados."

#: ../Doc/howto/clinic.rst:747
msgid ""
"Therefore, if you don't mind a little extra effort, please use the normal "
"converters instead of legacy converters."
msgstr ""
"Por lo tanto, si no le importa un poco de esfuerzo adicional, utilice los "
"convertidores normales en lugar de los convertidores heredados."

#: ../Doc/howto/clinic.rst:750
msgid ""
"In a nutshell, the syntax for Argument Clinic (non-legacy) converters looks "
"like a Python function call.  However, if there are no explicit arguments to "
"the function (all functions take their default values), you may omit the "
"parentheses.  Thus ``bool`` and ``bool()`` are exactly the same converters."
msgstr ""
"En pocas palabras, la sintaxis de los convertidores de Argument Clinic (no "
"heredados) parece una llamada a una función de Python. Sin embargo, si no "
"hay argumentos explícitos para la función (todas las funciones toman sus "
"valores predeterminados), puede omitir los paréntesis. Por tanto, ``bool`` y "
"``bool()`` son exactamente los mismos convertidores."

#: ../Doc/howto/clinic.rst:756
msgid ""
"All arguments to Argument Clinic converters are keyword-only. All Argument "
"Clinic converters accept the following arguments:"
msgstr ""
"Todos los argumentos para los convertidores de Argument Clinic son solo de "
"palabras clave. Todos los convertidores de Argument Clinic aceptan los "
"siguientes argumentos:"

#: ../Doc/howto/clinic.rst:764 ../Doc/howto/clinic.rst:1252
msgid "``c_default``"
msgstr "``c_default``"

#: ../Doc/howto/clinic.rst:760
msgid ""
"The default value for this parameter when defined in C. Specifically, this "
"will be the initializer for the variable declared in the \"parse function"
"\".  See :ref:`the section on default values <default_values>` for how to "
"use this. Specified as a string."
msgstr ""
"El valor predeterminado para este parámetro cuando se define en C. "
"Específicamente, será el inicializador de la variable declarada en la "
"\"función de análisis\". Consulte :ref:`la sección sobre valores "
"predeterminados <default_values>` para saber cómo usar esto. Especificado "
"como una cadena de caracteres."

#: ../Doc/howto/clinic.rst:769
msgid "``annotation``"
msgstr "``annotation``"

#: ../Doc/howto/clinic.rst:767
msgid ""
"The annotation value for this parameter.  Not currently supported, because :"
"pep:`8` mandates that the Python library may not use annotations."
msgstr ""
"El valor de anotación para este parámetro. Actualmente no es compatible, "
"porque :pep:`8` exige que la biblioteca de Python no use anotaciones."

#: ../Doc/howto/clinic.rst:771
msgid ""
"In addition, some converters accept additional arguments.  Here is a list of "
"these arguments, along with their meanings:"
msgstr ""
"Además, algunos convertidores aceptan argumentos adicionales. Aquí hay una "
"lista de estos argumentos, junto con sus significados:"

#: ../Doc/howto/clinic.rst:780
msgid "``accept``"
msgstr "``accept``"

#: ../Doc/howto/clinic.rst:775
msgid ""
"A set of Python types (and possibly pseudo-types); this restricts the "
"allowable Python argument to values of these types. (This is not a general-"
"purpose facility; as a rule it only supports specific lists of types as "
"shown in the legacy converter table.)"
msgstr ""
"Un conjunto de tipos de Python (y posiblemente pseudo-tipos); esto restringe "
"el argumento permitido de Python a valores de estos tipos. (Esta no es una "
"infraestructura de propósito general; por regla general, solo admite listas "
"específicas de tipos como se muestra en la tabla de convertidores heredados)."

#: ../Doc/howto/clinic.rst:780
msgid "To accept ``None``, add ``NoneType`` to this set."
msgstr "Para aceptar ``None``, agregue ``NoneType`` a este conjunto."

#: ../Doc/howto/clinic.rst:785
msgid "``bitwise``"
msgstr "``bitwise``"

#: ../Doc/howto/clinic.rst:783
msgid ""
"Only supported for unsigned integers.  The native integer value of this "
"Python argument will be written to the parameter without any range checking, "
"even for negative values."
msgstr ""
"Solo se admite para enteros sin signo. El valor entero nativo de este "
"argumento de Python se escribirá en el parámetro sin ninguna verificación de "
"rango, incluso para valores negativos."

#: ../Doc/howto/clinic.rst:790 ../Doc/howto/clinic.rst:1266
msgid "``converter``"
msgstr "``converter``"

#: ../Doc/howto/clinic.rst:788
msgid ""
"Only supported by the ``object`` converter.  Specifies the name of a :ref:`C "
"\"converter function\" <o_ampersand>` to use to convert this object to a "
"native type."
msgstr ""
"Solo compatible con el convertidor de ``objetos``. Especifica el nombre de "
"una :ref:`\"función de conversión\" C <o_ampersand>` para convertir este "
"objeto en un tipo nativo."

#: ../Doc/howto/clinic.rst:795
msgid "``encoding``"
msgstr "``encoding``"

#: ../Doc/howto/clinic.rst:793
msgid ""
"Only supported for strings.  Specifies the encoding to use when converting "
"this string from a Python str (Unicode) value into a C ``char *`` value."
msgstr ""
"Solo compatible con cadenas de caracteres. Especifica la codificación que se "
"utilizará al convertir esta cadena de un valor Python str (Unicode) en un "
"valor ``char *`` de C."

#: ../Doc/howto/clinic.rst:799
msgid "``subclass_of``"
msgstr "``subclass_of``"

#: ../Doc/howto/clinic.rst:798
msgid ""
"Only supported for the ``object`` converter.  Requires that the Python value "
"be a subclass of a Python type, as expressed in C."
msgstr ""
"Solo compatible con el convertidor de ``objetos``. Requiere que el valor de "
"Python sea una subclase de un tipo de Python, como se expresa en C."

#: ../Doc/howto/clinic.rst:804 ../Doc/howto/clinic.rst:1238
msgid "``type``"
msgstr "``type``"

#: ../Doc/howto/clinic.rst:802
msgid ""
"Only supported for the ``object`` and ``self`` converters.  Specifies the C "
"type that will be used to declare the variable.  Default value is ``"
"\"PyObject *\"``."
msgstr ""
"Solo compatible con los convertidores de ``object`` y ``self``. Especifica "
"el tipo C que se utilizará para declarar la variable. El valor "
"predeterminado es ``\"PyObject *\"``."

#: ../Doc/howto/clinic.rst:810
msgid "``zeroes``"
msgstr "``zeroes``"

#: ../Doc/howto/clinic.rst:807
msgid ""
"Only supported for strings.  If true, embedded NUL bytes (``'\\\\0'``) are "
"permitted inside the value.  The length of the string will be passed in to "
"the impl function, just after the string parameter, as a parameter named "
"``<parameter_name>_length``."
msgstr ""
"Solo compatible con cadenas. Si es verdadero, se permiten bytes NUL "
"incrustados (``'\\\\0'``) dentro del valor. La longitud de la cadena se "
"pasará a la función impl, justo después del parámetro de cadena, como un "
"parámetro llamado ``<parameter_name>_length``."

#: ../Doc/howto/clinic.rst:812
msgid ""
"Please note, not every possible combination of arguments will work. Usually "
"these arguments are implemented by specific ``PyArg_ParseTuple`` *format "
"units*, with specific behavior.  For example, currently you cannot call "
"``unsigned_short`` without also specifying ``bitwise=True``. Although it's "
"perfectly reasonable to think this would work, these semantics don't map to "
"any existing format unit.  So Argument Clinic doesn't support it.  (Or, at "
"least, not yet.)"
msgstr ""
"Tenga en cuenta que no todas las combinaciones posibles de argumentos "
"funcionarán. Por lo general, estos argumentos se implementan mediante "
"*unidades de formato* ``PyArg_ParseTuple`` específicas, con un "
"comportamiento específico. Por ejemplo, actualmente no puede llamar a "
"``unsigned_short`` sin especificar también ``bitwise=True``. Aunque es "
"perfectamente razonable pensar que esto funcionaría, esta semántica no se "
"asigna a ninguna unidad de formato existente. Entonces, Argument Clinic no "
"lo admite. (O, al menos, todavía no)."

#: ../Doc/howto/clinic.rst:820
msgid ""
"Below is a table showing the mapping of legacy converters into real Argument "
"Clinic converters.  On the left is the legacy converter, on the right is the "
"text you'd replace it with."
msgstr ""
"A continuación se muestra una tabla que muestra el mapeo de convertidores "
"heredados en convertidores de Argument Clinic reales. A la izquierda está el "
"convertidor heredado, a la derecha está el texto con el que lo reemplazaría."

#: ../Doc/howto/clinic.rst:825
msgid "``'B'``"
msgstr "``'B'``"

#: ../Doc/howto/clinic.rst:825
msgid "``unsigned_char(bitwise=True)``"
msgstr "``unsigned_char(bitwise=True)``"

#: ../Doc/howto/clinic.rst:826
msgid "``'b'``"
msgstr "``'b'``"

#: ../Doc/howto/clinic.rst:826
msgid "``unsigned_char``"
msgstr "``unsigned_char``"

#: ../Doc/howto/clinic.rst:827
msgid "``'c'``"
msgstr "``'c'``"

#: ../Doc/howto/clinic.rst:827
msgid "``char``"
msgstr "``char``"

#: ../Doc/howto/clinic.rst:828
msgid "``'C'``"
msgstr "``'C'``"

#: ../Doc/howto/clinic.rst:828
msgid "``int(accept={str})``"
msgstr "``int(accept={str})``"

#: ../Doc/howto/clinic.rst:829
msgid "``'d'``"
msgstr "``'d'``"

#: ../Doc/howto/clinic.rst:829
msgid "``double``"
msgstr "``double``"

#: ../Doc/howto/clinic.rst:830
msgid "``'D'``"
msgstr "``'D'``"

#: ../Doc/howto/clinic.rst:830
msgid "``Py_complex``"
msgstr "``Py_complex``"

#: ../Doc/howto/clinic.rst:831
msgid "``'es'``"
msgstr "``'es'``"

#: ../Doc/howto/clinic.rst:831
msgid "``str(encoding='name_of_encoding')``"
msgstr "``str(encoding='name_of_encoding')``"

#: ../Doc/howto/clinic.rst:832
msgid "``'es#'``"
msgstr "``'es#'``"

#: ../Doc/howto/clinic.rst:832
msgid "``str(encoding='name_of_encoding', zeroes=True)``"
msgstr "``str(encoding='name_of_encoding', zeroes=True)``"

#: ../Doc/howto/clinic.rst:833
msgid "``'et'``"
msgstr "``'et'``"

#: ../Doc/howto/clinic.rst:833
msgid "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"
msgstr "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"

#: ../Doc/howto/clinic.rst:834
msgid "``'et#'``"
msgstr "``'et#'``"

#: ../Doc/howto/clinic.rst:834
msgid ""
"``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
"zeroes=True)``"
msgstr ""
"``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
"zeroes=True)``"

#: ../Doc/howto/clinic.rst:835
msgid "``'f'``"
msgstr "``'f'``"

#: ../Doc/howto/clinic.rst:835
msgid "``float``"
msgstr "``float``"

#: ../Doc/howto/clinic.rst:836
msgid "``'h'``"
msgstr "``'h'``"

#: ../Doc/howto/clinic.rst:836
msgid "``short``"
msgstr "``short``"

#: ../Doc/howto/clinic.rst:837
msgid "``'H'``"
msgstr "``'H'``"

#: ../Doc/howto/clinic.rst:837
msgid "``unsigned_short(bitwise=True)``"
msgstr "``unsigned_short(bitwise=True)``"

#: ../Doc/howto/clinic.rst:838
msgid "``'i'``"
msgstr "``'i'``"

#: ../Doc/howto/clinic.rst:838
msgid "``int``"
msgstr "``int``"

#: ../Doc/howto/clinic.rst:839
msgid "``'I'``"
msgstr "``'I'``"

#: ../Doc/howto/clinic.rst:839
msgid "``unsigned_int(bitwise=True)``"
msgstr "``unsigned_int(bitwise=True)``"

#: ../Doc/howto/clinic.rst:840
msgid "``'k'``"
msgstr "``'k'``"

#: ../Doc/howto/clinic.rst:840
msgid "``unsigned_long(bitwise=True)``"
msgstr "``unsigned_long(bitwise=True)``"

#: ../Doc/howto/clinic.rst:841
msgid "``'K'``"
msgstr "``'K'``"

#: ../Doc/howto/clinic.rst:841
msgid "``unsigned_long_long(bitwise=True)``"
msgstr "``unsigned_long_long(bitwise=True)``"

#: ../Doc/howto/clinic.rst:842
msgid "``'l'``"
msgstr "``'l'``"

#: ../Doc/howto/clinic.rst:842
msgid "``long``"
msgstr "``long``"

#: ../Doc/howto/clinic.rst:843
msgid "``'L'``"
msgstr "``'L'``"

#: ../Doc/howto/clinic.rst:843
msgid "``long long``"
msgstr "``long long``"

#: ../Doc/howto/clinic.rst:844
msgid "``'n'``"
msgstr "``'n'``"

#: ../Doc/howto/clinic.rst:844
msgid "``Py_ssize_t``"
msgstr "``Py_ssize_t``"

#: ../Doc/howto/clinic.rst:845
msgid "``'O'``"
msgstr "``'O'``"

#: ../Doc/howto/clinic.rst:845
msgid "``object``"
msgstr "``object``"

#: ../Doc/howto/clinic.rst:846
msgid "``'O!'``"
msgstr "``'O!'``"

#: ../Doc/howto/clinic.rst:846
msgid "``object(subclass_of='&PySomething_Type')``"
msgstr "``object(subclass_of='&PySomething_Type')``"

#: ../Doc/howto/clinic.rst:847
msgid "``'O&'``"
msgstr "``'O&'``"

#: ../Doc/howto/clinic.rst:847
msgid "``object(converter='name_of_c_function')``"
msgstr "``object(converter='name_of_c_function')``"

#: ../Doc/howto/clinic.rst:848
msgid "``'p'``"
msgstr "``'p'``"

#: ../Doc/howto/clinic.rst:848
msgid "``bool``"
msgstr "``bool``"

#: ../Doc/howto/clinic.rst:849
msgid "``'S'``"
msgstr "``'S'``"

#: ../Doc/howto/clinic.rst:849
msgid "``PyBytesObject``"
msgstr "``PyBytesObject``"

#: ../Doc/howto/clinic.rst:850
msgid "``'s'``"
msgstr "``'s'``"

#: ../Doc/howto/clinic.rst:850
msgid "``str``"
msgstr "``str``"

#: ../Doc/howto/clinic.rst:851
msgid "``'s#'``"
msgstr "``'s#'``"

#: ../Doc/howto/clinic.rst:851
msgid "``str(zeroes=True)``"
msgstr "``str(zeroes=True)``"

#: ../Doc/howto/clinic.rst:852
msgid "``'s*'``"
msgstr "``'s*'``"

#: ../Doc/howto/clinic.rst:852
msgid "``Py_buffer(accept={buffer, str})``"
msgstr "``Py_buffer(accept={buffer, str})``"

#: ../Doc/howto/clinic.rst:853
msgid "``'U'``"
msgstr "``'U'``"

#: ../Doc/howto/clinic.rst:853
msgid "``unicode``"
msgstr "``unicode``"

#: ../Doc/howto/clinic.rst:854
msgid "``'u'``"
msgstr "``'u'``"

#: ../Doc/howto/clinic.rst:854
msgid "``Py_UNICODE``"
msgstr "``Py_UNICODE``"

#: ../Doc/howto/clinic.rst:855
msgid "``'u#'``"
msgstr "``'u#'``"

#: ../Doc/howto/clinic.rst:855
msgid "``Py_UNICODE(zeroes=True)``"
msgstr "``Py_UNICODE(zeroes=True)``"

#: ../Doc/howto/clinic.rst:856
msgid "``'w*'``"
msgstr "``'w*'``"

#: ../Doc/howto/clinic.rst:856
msgid "``Py_buffer(accept={rwbuffer})``"
msgstr "``Py_buffer(accept={rwbuffer})``"

#: ../Doc/howto/clinic.rst:857
msgid "``'Y'``"
msgstr "``'Y'``"

#: ../Doc/howto/clinic.rst:857
msgid "``PyByteArrayObject``"
msgstr "``PyByteArrayObject``"

#: ../Doc/howto/clinic.rst:858
msgid "``'y'``"
msgstr "``'y'``"

#: ../Doc/howto/clinic.rst:858
msgid "``str(accept={bytes})``"
msgstr "``str(accept={bytes})``"

#: ../Doc/howto/clinic.rst:859
msgid "``'y#'``"
msgstr "``'y#'``"

#: ../Doc/howto/clinic.rst:859
msgid "``str(accept={robuffer}, zeroes=True)``"
msgstr "``str(accept={robuffer}, zeroes=True)``"

#: ../Doc/howto/clinic.rst:860
msgid "``'y*'``"
msgstr "``'y*'``"

#: ../Doc/howto/clinic.rst:860
msgid "``Py_buffer``"
msgstr "``Py_buffer``"

#: ../Doc/howto/clinic.rst:861
msgid "``'Z'``"
msgstr "``'Z'``"

#: ../Doc/howto/clinic.rst:861
msgid "``Py_UNICODE(accept={str, NoneType})``"
msgstr "``Py_UNICODE(accept={str, NoneType})``"

#: ../Doc/howto/clinic.rst:862
msgid "``'Z#'``"
msgstr "``'Z#'``"

#: ../Doc/howto/clinic.rst:862
msgid "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"
msgstr "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"

#: ../Doc/howto/clinic.rst:863
msgid "``'z'``"
msgstr "``'z'``"

#: ../Doc/howto/clinic.rst:863
msgid "``str(accept={str, NoneType})``"
msgstr "``str(accept={str, NoneType})``"

#: ../Doc/howto/clinic.rst:864
msgid "``'z#'``"
msgstr "``'z#'``"

#: ../Doc/howto/clinic.rst:864
msgid "``str(accept={str, NoneType}, zeroes=True)``"
msgstr "``str(accept={str, NoneType}, zeroes=True)``"

#: ../Doc/howto/clinic.rst:865
msgid "``'z*'``"
msgstr "``'z*'``"

#: ../Doc/howto/clinic.rst:865
msgid "``Py_buffer(accept={buffer, str, NoneType})``"
msgstr "``Py_buffer(accept={buffer, str, NoneType})``"

#: ../Doc/howto/clinic.rst:868
msgid ""
"As an example, here's our sample ``pickle.Pickler.dump`` using the proper "
"converter::"
msgstr ""
"Como ejemplo, aquí está nuestro ejemplo ``pickle.Pickler.dump`` usando el "
"convertidor adecuado:"

#: ../Doc/howto/clinic.rst:881
msgid ""
"One advantage of real converters is that they're more flexible than legacy "
"converters.  For example, the ``unsigned_int`` converter (and all the "
"``unsigned_`` converters) can be specified without ``bitwise=True``.  Their "
"default behavior performs range checking on the value, and they won't accept "
"negative numbers.  You just can't do that with a legacy converter!"
msgstr ""
"Una ventaja de los convertidores reales es que son más flexibles que los "
"convertidores heredados. Por ejemplo, el convertidor ``unsigned_int`` (y "
"todos los convertidores ``unsigned_``) se pueden especificar sin "
"``bitwise=True``. Su comportamiento predeterminado realiza una verificación "
"de rango en el valor y no aceptarán números negativos. ¡No puedes hacer eso "
"con un convertidor heredado!"

#: ../Doc/howto/clinic.rst:887
msgid ""
"Argument Clinic will show you all the converters it has available.  For each "
"converter it'll show you all the parameters it accepts, along with the "
"default value for each parameter. Just run ``Tools/clinic/clinic.py --"
"converters`` to see the full list."
msgstr ""
"Argument Clinic le mostrará todos los convertidores que tiene disponibles. "
"Para cada convertidor, le mostrará todos los parámetros que acepta, junto "
"con el valor predeterminado para cada parámetro. Simplemente ejecute ``Tools/"
"clinic/clinic.py --converters`` para ver la lista completa."

#: ../Doc/howto/clinic.rst:893
msgid "Py_buffer"
msgstr "Py_buffer"

#: ../Doc/howto/clinic.rst:895
msgid ""
"When using the ``Py_buffer`` converter (or the ``'s*'``, ``'w*'``, ``'*y'``, "
"or ``'z*'`` legacy converters), you *must* not call :c:func:"
"`PyBuffer_Release` on the provided buffer. Argument Clinic generates code "
"that does it for you (in the parsing function)."
msgstr ""
"Cuando se utiliza el convertidor ``Py_buffer`` (o los convertidores "
"heredados ``'s*'``, ``'w*'``, ``'*y'`` o ``'z*'`` ), *no* debes llamar a :c: "
"func:`PyBuffer_Release` en el búfer provisto. Argument Clinic genera código "
"que lo hace por usted (en la función de análisis)."

#: ../Doc/howto/clinic.rst:903
msgid "Advanced converters"
msgstr "Convertidores avanzados"

#: ../Doc/howto/clinic.rst:905
msgid ""
"Remember those format units you skipped for your first time because they "
"were advanced?  Here's how to handle those too."
msgstr ""
"¿Recuerda esas unidades de formato que omitió por primera vez porque eran "
"avanzadas? Aquí le mostramos cómo manejarlos también."

#: ../Doc/howto/clinic.rst:908
msgid ""
"The trick is, all those format units take arguments—either conversion "
"functions, or types, or strings specifying an encoding. (But \"legacy "
"converters\" don't support arguments.  That's why we skipped them for your "
"first function.)  The argument you specified to the format unit is now an "
"argument to the converter; this argument is either ``converter`` (for "
"``O&``), ``subclass_of`` (for ``O!``), or ``encoding`` (for all the format "
"units that start with ``e``)."
msgstr ""
"El truco es que todas esas unidades de formato toman argumentos, ya sean "
"funciones de conversión o tipos, o cadenas que especifican una codificación. "
"(Pero los \"convertidores heredados\" no admiten argumentos. Por eso los "
"omitimos para su primera función). El argumento que especificó para la "
"unidad de formato ahora es un argumento para el convertidor; este argumento "
"es ``converter`` (para ``O&``), ``subclass_of`` (para ``O!``) o ``encoding`` "
"(para todas las unidades de formato que comienzan con ``e``)."

#: ../Doc/howto/clinic.rst:916
msgid ""
"When using ``subclass_of``, you may also want to use the other custom "
"argument for ``object()``: ``type``, which lets you set the type actually "
"used for the parameter.  For example, if you want to ensure that the object "
"is a subclass of ``PyUnicode_Type``, you probably want to use the converter "
"``object(type='PyUnicodeObject *', subclass_of='&PyUnicode_Type')``."
msgstr ""
"Al usar ``subclass_of``, es posible que también desee usar el otro argumento "
"personalizado para ``object()``: ``type``, que le permite establecer el tipo "
"que realmente se usa para el parámetro. Por ejemplo, si desea asegurarse de "
"que el objeto es una subclase de ``PyUnicode_Type``, probablemente desee "
"utilizar el convertidor ``object(type='PyUnicodeObject *', "
"subclass_of='&PyUnicode_Type')``."

#: ../Doc/howto/clinic.rst:922
msgid ""
"One possible problem with using Argument Clinic: it takes away some possible "
"flexibility for the format units starting with ``e``.  When writing a "
"``PyArg_Parse`` call by hand, you could theoretically decide at runtime what "
"encoding string to pass in to :c:func:`PyArg_ParseTuple`.   But now this "
"string must be hard-coded at Argument-Clinic-preprocessing-time.  This "
"limitation is deliberate; it made supporting this format unit much easier, "
"and may allow for future optimizations. This restriction doesn't seem "
"unreasonable; CPython itself always passes in static hard-coded encoding "
"strings for parameters whose format units start with ``e``."
msgstr ""
"Un posible problema con el uso de Argument Clinic: elimina cierta "
"flexibilidad posible para las unidades de formato que comienzan con ``e``. "
"Al escribir una llamada ``PyArg_Parse`` a mano, teóricamente podrías decidir "
"en tiempo de ejecución qué cadena de codificación pasar a :c:func:"
"`PyArg_ParseTuple`. Pero ahora esta cadena debe estar codificada en tiempo "
"de preprocesamiento de Argument-Clinic. Esta limitación es deliberada; hizo "
"que el soporte de esta unidad de formato fuera mucho más fácil y puede "
"permitir futuras optimizaciones. Esta restricción no parece irrazonable; el "
"propio CPython siempre pasa cadenas de codificación estáticas codificadas "
"para parámetros cuyas unidades de formato comienzan con ``e``."

#: ../Doc/howto/clinic.rst:935
msgid "Parameter default values"
msgstr "Valores predeterminados de los parámetros"

#: ../Doc/howto/clinic.rst:937
msgid ""
"Default values for parameters can be any of a number of values. At their "
"simplest, they can be string, int, or float literals:"
msgstr ""
"Los valores predeterminados de los parámetros pueden ser cualquiera de "
"varios valores. En su forma más simple, pueden ser literales string, int o "
"float:"

#: ../Doc/howto/clinic.rst:946
msgid "They can also use any of Python's built-in constants:"
msgstr ""
"También pueden usar cualquiera de las constantes incorporadas de Python:"

#: ../Doc/howto/clinic.rst:954
msgid ""
"There's also special support for a default value of ``NULL``, and for simple "
"expressions, documented in the following sections."
msgstr ""
"También hay soporte especial para un valor predeterminado de ``NULL`` y para "
"expresiones simples, documentadas en las siguientes secciones."

#: ../Doc/howto/clinic.rst:959
msgid "The ``NULL`` default value"
msgstr "El valor predeterminado ``NULL``"

#: ../Doc/howto/clinic.rst:961
msgid ""
"For string and object parameters, you can set them to ``None`` to indicate "
"that there's no default.  However, that means the C variable will be "
"initialized to ``Py_None``.  For convenience's sakes, there's a special "
"value called ``NULL`` for just this reason: from Python's perspective it "
"behaves like a default value of ``None``, but the C variable is initialized "
"with ``NULL``."
msgstr ""
"Para los parámetros de cadena de caracteres y objeto, puede establecerlos en "
"``None`` para indicar que no hay ningún valor predeterminado. Sin embargo, "
"eso significa que la variable C se inicializará en ``Py_None``. Por "
"conveniencia, hay un valor especial llamado ``NULL`` solo por esta razón: "
"desde la perspectiva de Python se comporta como un valor predeterminado de "
"``None``, pero la variable C se inicializa con ``NULL``."

#: ../Doc/howto/clinic.rst:969
msgid "Expressions specified as default values"
msgstr "Expresiones especificadas como valores predeterminados"

#: ../Doc/howto/clinic.rst:971
msgid ""
"The default value for a parameter can be more than just a literal value. It "
"can be an entire expression, using math operators and looking up attributes "
"on objects.  However, this support isn't exactly simple, because of some non-"
"obvious semantics."
msgstr ""
"El valor predeterminado de un parámetro puede ser más que un valor literal. "
"Puede ser una expresión completa, utilizando operadores matemáticos y "
"buscando atributos en objetos. Sin embargo, este soporte no es exactamente "
"simple, debido a una semántica no obvia."

#: ../Doc/howto/clinic.rst:976
msgid "Consider the following example:"
msgstr "Considere el siguiente ejemplo:"

#: ../Doc/howto/clinic.rst:982
msgid ""
"``sys.maxsize`` can have different values on different platforms.  Therefore "
"Argument Clinic can't simply evaluate that expression locally and hard-code "
"it in C.  So it stores the default in such a way that it will get evaluated "
"at runtime, when the user asks for the function's signature."
msgstr ""
"``sys.maxsize`` puede tener diferentes valores en diferentes plataformas. "
"Por lo tanto, Argument Clinic no puede simplemente evaluar esa expresión "
"localmente y codificarla en C. Por lo tanto, almacena el valor "
"predeterminado de tal manera que se evaluará en tiempo de ejecución, cuando "
"el usuario solicite la firma de la función."

#: ../Doc/howto/clinic.rst:987
msgid ""
"What namespace is available when the expression is evaluated?  It's "
"evaluated in the context of the module the builtin came from.  So, if your "
"module has an attribute called \"``max_widgets``\", you may simply use it:"
msgstr ""
"¿Qué espacio de nombres está disponible cuando se evalúa la expresión? Se "
"evalúa en el contexto del módulo del que procede el incorporado. Entonces, "
"si su módulo tiene un atributo llamado \"``max_widgets``\", simplemente "
"puede usarlo:"

#: ../Doc/howto/clinic.rst:995
msgid ""
"If the symbol isn't found in the current module, it fails over to looking in "
"``sys.modules``.  That's how it can find ``sys.maxsize`` for example.  "
"(Since you don't know in advance what modules the user will load into their "
"interpreter, it's best to restrict yourself to modules that are preloaded by "
"Python itself.)"
msgstr ""
"Si el símbolo no se encuentra en el módulo actual, falla para buscar en "
"``sys.modules``. Así es como puede encontrar ``sys.maxsize``, por ejemplo. "
"(Dado que no sabe de antemano qué módulos cargará el usuario en su "
"intérprete, es mejor limitarse a los módulos que están precargados por el "
"propio Python)."

#: ../Doc/howto/clinic.rst:1000
msgid ""
"Evaluating default values only at runtime means Argument Clinic can't "
"compute the correct equivalent C default value.  So you need to tell it "
"explicitly. When you use an expression, you must also specify the equivalent "
"expression in C, using the ``c_default`` parameter to the converter:"
msgstr ""
"La evaluación de los valores predeterminados solo en tiempo de ejecución "
"significa que Argument Clinic no puede calcular el valor predeterminado de C "
"equivalente correcto. Entonces necesitas decirlo explícitamente. Cuando usa "
"una expresión, también debe especificar la expresión equivalente en C, "
"usando el parámetro ``c_default`` para el convertidor:"

#: ../Doc/howto/clinic.rst:1009
msgid ""
"Another complication: Argument Clinic can't know in advance whether or not "
"the expression you supply is valid.  It parses it to make sure it looks "
"legal, but it can't *actually* know.  You must be very careful when using "
"expressions to specify values that are guaranteed to be valid at runtime!"
msgstr ""
"Otra complicación: Argument Clinic no puede saber de antemano si la "
"expresión que proporciona es válida o no. Lo analiza para asegurarse de que "
"parece legal, pero no puede *realmente* saberlo. ¡Debe tener mucho cuidado "
"al usar expresiones para especificar valores que están garantizados para ser "
"válidos en tiempo de ejecución!"

#: ../Doc/howto/clinic.rst:1014
msgid ""
"Finally, because expressions must be representable as static C values, there "
"are many restrictions on legal expressions.  Here's a list of Python "
"features you're not permitted to use:"
msgstr ""
"Finalmente, dado que las expresiones deben ser representables como valores C "
"estáticos, existen muchas restricciones sobre las expresiones legales. Aquí "
"hay una lista de funciones de Python que no está autorizado a usar:"

#: ../Doc/howto/clinic.rst:1018
msgid "Function calls."
msgstr "Llamadas a funciones."

#: ../Doc/howto/clinic.rst:1019
msgid "Inline if statements (``3 if foo else 5``)."
msgstr "Declaraciones if en línea (``3 if foo else 5``)."

#: ../Doc/howto/clinic.rst:1020
msgid "Automatic sequence unpacking (``*[1, 2, 3]``)."
msgstr "Desempaque automático de secuencia (``*[1, 2, 3]``)."

#: ../Doc/howto/clinic.rst:1021
msgid "List/set/dict comprehensions and generator expressions."
msgstr "Comprensiones de list/set/dict y expresiones generadoras."

#: ../Doc/howto/clinic.rst:1022
msgid "Tuple/list/set/dict literals."
msgstr "Literales tuple/list/set/dict."

#: ../Doc/howto/clinic.rst:1027
msgid "Using a return converter"
msgstr "Usando un convertidor de retorno"

#: ../Doc/howto/clinic.rst:1029
msgid ""
"By default the impl function Argument Clinic generates for you returns "
"``PyObject *``. But your C function often computes some C type, then "
"converts it into the ``PyObject *`` at the last moment.  Argument Clinic "
"handles converting your inputs from Python types into native C types—why not "
"have it convert your return value from a native C type into a Python type "
"too?"
msgstr ""
"De forma predeterminada, la función implícita Argument Clinic genera para "
"usted devuelve ``PyObject *``. Pero su función C a menudo calcula algún tipo "
"de C, luego lo convierte en el ``PyObject *`` en el último momento. Argument "
"Clinic se encarga de convertir sus entradas de tipos de Python en tipos C "
"nativos; ¿por qué no convertir su valor de retorno de un tipo C nativo en un "
"tipo Python también?"

#: ../Doc/howto/clinic.rst:1035
msgid ""
"That's what a \"return converter\" does.  It changes your impl function to "
"return some C type, then adds code to the generated (non-impl) function to "
"handle converting that value into the appropriate ``PyObject *``."
msgstr ""
"Eso es lo que hace un \"convertidor de retorno\". Cambia su función *impl* "
"para devolver algún tipo de C, luego agrega código a la función generada (no "
"implícita) para manejar la conversión de ese valor en el ``PyObject *`` "
"apropiado."

#: ../Doc/howto/clinic.rst:1039
msgid ""
"The syntax for return converters is similar to that of parameter converters. "
"You specify the return converter like it was a return annotation on the "
"function itself.  Return converters behave much the same as parameter "
"converters; they take arguments, the arguments are all keyword-only, and if "
"you're not changing any of the default arguments you can omit the "
"parentheses."
msgstr ""
"La sintaxis de los convertidores de retorno es similar a la de los "
"convertidores de parámetros. Especifica el convertidor de retorno como si "
"fuera una anotación de retorno en la función en sí. Los convertidores de "
"retorno se comportan de la misma manera que los convertidores de parámetros; "
"aceptan argumentos, todos los argumentos son solo palabras clave y, si no "
"está cambiando ninguno de los argumentos predeterminados, puede omitir los "
"paréntesis."

#: ../Doc/howto/clinic.rst:1045
msgid ""
"(If you use both ``\"as\"`` *and* a return converter for your function, the "
"``\"as\"`` should come before the return converter.)"
msgstr ""
"(Si utiliza tanto ``\"as\" `` *y* un convertidor de retorno para su función, "
"el ``\"as\"`` debe aparecer antes del convertidor de retorno.)"

#: ../Doc/howto/clinic.rst:1048
msgid ""
"There's one additional complication when using return converters: how do you "
"indicate an error has occurred?  Normally, a function returns a valid (non-"
"``NULL``) pointer for success, and ``NULL`` for failure.  But if you use an "
"integer return converter, all integers are valid.  How can Argument Clinic "
"detect an error?  Its solution: each return converter implicitly looks for a "
"special value that indicates an error.  If you return that value, and an "
"error has been set (``PyErr_Occurred()`` returns a true value), then the "
"generated code will propagate the error.  Otherwise it will encode the value "
"you return like normal."
msgstr ""
"Hay una complicación adicional al usar convertidores de retorno: ¿cómo "
"indica que se ha producido un error? Normalmente, una función devuelve un "
"puntero válido (no ``NULL``) para el éxito y ``NULL`` para el error. Pero si "
"usa un convertidor de retorno de enteros, todos los enteros son válidos. "
"¿Cómo puede Argument Clinic detectar un error? Su solución: cada convertidor "
"de retorno busca implícitamente un valor especial que indica un error. Si "
"devuelve ese valor y se ha establecido un error (``PyErr_Occurred()`` "
"retorna un valor verdadero), el código generado propagará el error. De lo "
"contrario, codificará el valor que devuelva como de costumbre."

#: ../Doc/howto/clinic.rst:1057
msgid "Currently Argument Clinic supports only a few return converters:"
msgstr ""
"Actualmente, Argument Clinic solo admite unos pocos convertidores de retorno:"

#: ../Doc/howto/clinic.rst:1072
msgid ""
"None of these take parameters.  For the first three, return -1 to indicate "
"error.  For ``DecodeFSDefault``, the return type is ``const char *``; return "
"a ``NULL`` pointer to indicate an error."
msgstr ""
"Ninguno de estos toma parámetros. Para los tres primeros, retorna -1 para "
"indicar error. Para ``DecodeFSDefault``, el tipo de retorno es ``const char "
"*``; retorna un puntero ``NULL`` para indicar un error."

#: ../Doc/howto/clinic.rst:1076
msgid ""
"(There's also an experimental ``NoneType`` converter, which lets you return "
"``Py_None`` on success or ``NULL`` on failure, without having to increment "
"the reference count on ``Py_None``.  I'm not sure it adds enough clarity to "
"be worth using.)"
msgstr ""
"(También hay un convertidor experimental ``NoneType``, que le permite "
"devolver ``Py_None`` en caso de éxito o ``NULL`` en caso de falla, sin tener "
"que incrementar el recuento de referencias en ``Py_None``. seguro que agrega "
"suficiente claridad para que valga la pena usarlo)"

#: ../Doc/howto/clinic.rst:1081
msgid ""
"To see all the return converters Argument Clinic supports, along with their "
"parameters (if any), just run ``Tools/clinic/clinic.py --converters`` for "
"the full list."
msgstr ""
"Para ver todos los convertidores devueltos que admite Argument Clinic, junto "
"con sus parámetros (si los hay), simplemente ejecute ``Tools/clinic/clinic."
"py --converters`` para ver la lista completa."

#: ../Doc/howto/clinic.rst:1087
msgid "Cloning existing functions"
msgstr "Clonando funciones existentes"

#: ../Doc/howto/clinic.rst:1089
msgid ""
"If you have a number of functions that look similar, you may be able to use "
"Clinic's \"clone\" feature.  When you clone an existing function, you reuse:"
msgstr ""
"Si tiene varias funciones que parecen similares, es posible que pueda "
"utilizar la función \"clone\" de Clinic. Cuando clona una función existente, "
"reutiliza:"

#: ../Doc/howto/clinic.rst:1093
msgid "its parameters, including"
msgstr "sus parámetros, incluyendo"

#: ../Doc/howto/clinic.rst:1095
msgid "their names,"
msgstr "sus nombres,"

#: ../Doc/howto/clinic.rst:1097
msgid "their converters, with all parameters,"
msgstr "sus convertidores, con todos los parámetros,"

#: ../Doc/howto/clinic.rst:1099
msgid "their default values,"
msgstr "sus valores predeterminados,"

#: ../Doc/howto/clinic.rst:1101
msgid "their per-parameter docstrings,"
msgstr "sus docstrings por parámetro,"

#: ../Doc/howto/clinic.rst:1103
msgid ""
"their *kind* (whether they're positional only, positional or keyword, or "
"keyword only), and"
msgstr ""
"su *kind* (ya sea solo posicional, posicional o por palabra clave, o solo "
"por palabra clave), y"

#: ../Doc/howto/clinic.rst:1106
msgid "its return converter."
msgstr "su convertidor de retorno."

#: ../Doc/howto/clinic.rst:1108
msgid ""
"The only thing not copied from the original function is its docstring; the "
"syntax allows you to specify a new docstring."
msgstr ""
"Lo único que no se ha copiado de la función original es su docstring; la "
"sintaxis le permite especificar un nuevo docstring."

#: ../Doc/howto/clinic.rst:1111
msgid "Here's the syntax for cloning a function::"
msgstr "Aquí está la sintaxis para clonar una función::"

#: ../Doc/howto/clinic.rst:1119
msgid ""
"(The functions can be in different modules or classes.  I wrote ``module."
"class`` in the sample just to illustrate that you must use the full path to "
"*both* functions.)"
msgstr ""
"(Las funciones pueden estar en diferentes módulos o clases. Escribí ``module."
"class`` en la muestra solo para ilustrar que debe usar la ruta completa a "
"*ambas* funciones.)"

#: ../Doc/howto/clinic.rst:1123
msgid ""
"Sorry, there's no syntax for partially-cloning a function, or cloning a "
"function then modifying it.  Cloning is an all-or nothing proposition."
msgstr ""
"Lo sentimos, no hay sintaxis para clonar parcialmente una función o clonar "
"una función y luego modificarla. La clonación es una propuesta de todo o "
"nada."

#: ../Doc/howto/clinic.rst:1126
msgid ""
"Also, the function you are cloning from must have been previously defined in "
"the current file."
msgstr ""
"Además, la función desde la que está clonando debe haberse definido "
"previamente en el archivo actual."

#: ../Doc/howto/clinic.rst:1130
msgid "Calling Python code"
msgstr "Llamando código Python"

#: ../Doc/howto/clinic.rst:1132
msgid ""
"The rest of the advanced topics require you to write Python code which lives "
"inside your C file and modifies Argument Clinic's runtime state.  This is "
"simple: you simply define a Python block."
msgstr ""
"El resto de los temas avanzados requieren que escriba código Python que vive "
"dentro de su archivo C y modifica el estado de ejecución de Argument Clinic. "
"Esto es simple: simplemente define un bloque de Python."

#: ../Doc/howto/clinic.rst:1136
msgid ""
"A Python block uses different delimiter lines than an Argument Clinic "
"function block.  It looks like this::"
msgstr ""
"Un bloque Python utiliza diferentes líneas delimitadoras que un bloque de "
"función de la Argument Clinic. Se parece a esto::"

#: ../Doc/howto/clinic.rst:1143
msgid ""
"All the code inside the Python block is executed at the time it's parsed.  "
"All text written to stdout inside the block is redirected into the \"output"
"\" after the block."
msgstr ""
"Todo el código dentro del bloque de Python se ejecuta en el momento en que "
"se analiza. Todo el texto escrito en stdout dentro del bloque se redirige a "
"la \"salida\" después del bloque."

#: ../Doc/howto/clinic.rst:1147
msgid ""
"As an example, here's a Python block that adds a static integer variable to "
"the C code::"
msgstr ""
"Como ejemplo, aquí hay un bloque de Python que agrega una variable entera "
"estática al código C ::"

#: ../Doc/howto/clinic.rst:1158
msgid "Using a \"self converter\""
msgstr "Usando un \"auto convertidor\""

#: ../Doc/howto/clinic.rst:1160
msgid ""
"Argument Clinic automatically adds a \"self\" parameter for you using a "
"default converter.  It automatically sets the ``type`` of this parameter to "
"the \"pointer to an instance\" you specified when you declared the type.  "
"However, you can override Argument Clinic's converter and specify one "
"yourself. Just add your own ``self`` parameter as the first parameter in a "
"block, and ensure that its converter is an instance of ``self_converter`` or "
"a subclass thereof."
msgstr ""
"Argument Clinic agrega automáticamente un parámetro \"self\" para usted "
"usando un convertidor predeterminado. Establece automáticamente el ``tipo`` "
"de este parámetro en el \"puntero a una instancia\" que especificó cuando "
"declaró el tipo. Sin embargo, puede anular el convertidor de Argument Clinic "
"y especificar uno usted mismo. Simplemente agregue su propio parámetro "
"``self`` como el primer parámetro en un bloque y asegúrese de que su "
"convertidor sea una instancia de ``self_converter`` o una subclase del mismo."

#: ../Doc/howto/clinic.rst:1169
msgid ""
"What's the point?  This lets you override the type of ``self``, or give it a "
"different default name."
msgstr ""
"¿Cuál es el punto de? Esto le permite anular el tipo de ``self`` o darle un "
"nombre predeterminado diferente."

#: ../Doc/howto/clinic.rst:1172
msgid ""
"How do you specify the custom type you want to cast ``self`` to? If you only "
"have one or two functions with the same type for ``self``, you can directly "
"use Argument Clinic's existing ``self`` converter, passing in the type you "
"want to use as the ``type`` parameter::"
msgstr ""
"¿Cómo especifica el tipo personalizado al que desea transmitir ``self``? Si "
"solo tiene una o dos funciones con el mismo tipo para ``self``, puede usar "
"directamente el convertidor ``self`` existente de Argument Clinic, pasando "
"el tipo que desea usar como parámetro de ``type``::"

#: ../Doc/howto/clinic.rst:1188
msgid ""
"On the other hand, if you have a lot of functions that will use the same "
"type for ``self``, it's best to create your own converter, subclassing "
"``self_converter`` but overwriting the ``type`` member::"
msgstr ""
"Por otro lado, si tiene muchas funciones que usarán el mismo tipo para "
"``self``, es mejor crear su propio convertidor, subclasificando "
"``self_converter`` pero sobrescribiendo el miembro `` type``:"

#: ../Doc/howto/clinic.rst:1211
msgid "Writing a custom converter"
msgstr "Escribiendo un convertidor personalizado"

#: ../Doc/howto/clinic.rst:1213
msgid ""
"As we hinted at in the previous section... you can write your own "
"converters! A converter is simply a Python class that inherits from "
"``CConverter``. The main purpose of a custom converter is if you have a "
"parameter using the ``O&`` format unit—parsing this parameter means calling "
"a :c:func:`PyArg_ParseTuple` \"converter function\"."
msgstr ""
"Como dijimos en la sección anterior... ¡puedes escribir tus propios "
"convertidores! Un convertidor es simplemente una clase de Python que hereda "
"de ``CConverter``. El propósito principal de un convertidor personalizado es "
"si tiene un parámetro que usa la unidad de formato ``O&``; analizar este "
"parámetro significa llamar a :c:func:`PyArg_ParseTuple` \"función de "
"conversión\"."

#: ../Doc/howto/clinic.rst:1219
msgid ""
"Your converter class should be named ``*something*_converter``. If the name "
"follows this convention, then your converter class will be automatically "
"registered with Argument Clinic; its name will be the name of your class "
"with the ``_converter`` suffix stripped off.  (This is accomplished with a "
"metaclass.)"
msgstr ""
"Su clase de convertidor debe llamarse ``*something*_converter``. Si el "
"nombre sigue esta convención, entonces su clase de convertidor se registrará "
"automáticamente con Argument Clinic; su nombre será el nombre de su clase "
"con el sufijo ``_converter`` eliminado. (Esto se logra con una metaclase)."

#: ../Doc/howto/clinic.rst:1225
msgid ""
"You shouldn't subclass ``CConverter.__init__``.  Instead, you should write a "
"``converter_init()`` function.  ``converter_init()`` always accepts a "
"``self`` parameter; after that, all additional parameters *must* be keyword-"
"only.  Any arguments passed in to the converter in Argument Clinic will be "
"passed along to your ``converter_init()``."
msgstr ""
"No debe subclasificar ``CConverter.__init__``. En su lugar, debe escribir "
"una función ``converter_init()``. ``converter_init()`` siempre acepta un "
"parámetro ``self``; después de eso, todos los parámetros adicionales *deben* "
"ser solo palabras clave. Cualquier argumento que se pase al convertidor en "
"Argument Clinic se pasará a su ``converter_init()``."

#: ../Doc/howto/clinic.rst:1232
msgid ""
"There are some additional members of ``CConverter`` you may wish to specify "
"in your subclass.  Here's the current list:"
msgstr ""
"Hay algunos miembros adicionales de ``CConverter`` que tal vez desee "
"especificar en su subclase. Aquí está la lista actual:"

#: ../Doc/howto/clinic.rst:1236
msgid ""
"The C type to use for this variable. ``type`` should be a Python string "
"specifying the type, e.g. ``int``. If this is a pointer type, the type "
"string should end with ``' *'``."
msgstr ""
"El tipo C que se utilizará para esta variable. ``type`` debe ser una cadena "
"de Python que especifique el tipo, por ejemplo ``int``. Si se trata de un "
"tipo de puntero, la cadena de tipo debe terminar con ``'*'``."

#: ../Doc/howto/clinic.rst:1242
msgid "``default``"
msgstr "``default``"

#: ../Doc/howto/clinic.rst:1241
msgid ""
"The Python default value for this parameter, as a Python value. Or the magic "
"value ``unspecified`` if there is no default."
msgstr ""
"El valor predeterminado de Python para este parámetro, como un valor de "
"Python. O el valor mágico ``unspecified`` si no hay ningún valor "
"predeterminado."

#: ../Doc/howto/clinic.rst:1247
msgid "``py_default``"
msgstr "``py_default``"

#: ../Doc/howto/clinic.rst:1245
msgid ""
"``default`` as it should appear in Python code, as a string. Or ``None`` if "
"there is no default."
msgstr ""
"``default`` como debería aparecer en el código Python, como una cadena. O "
"``None`` si no hay un valor predeterminado."

#: ../Doc/howto/clinic.rst:1250
msgid ""
"``default`` as it should appear in C code, as a string. Or ``None`` if there "
"is no default."
msgstr ""
"``default`` como debería aparecer en el código C, como una cadena de "
"caracteres. O ``None`` si no hay un valor predeterminado."

#: ../Doc/howto/clinic.rst:1263
msgid "``c_ignored_default``"
msgstr "``c_ignored_default``"

#: ../Doc/howto/clinic.rst:1255
msgid ""
"The default value used to initialize the C variable when there is no "
"default, but not specifying a default may result in an \"uninitialized "
"variable\" warning.  This can easily happen when using option groups—"
"although properly-written code will never actually use this value, the "
"variable does get passed in to the impl, and the C compiler will complain "
"about the \"use\" of the uninitialized value.  This value should always be a "
"non-empty string."
msgstr ""
"El valor predeterminado utilizado para inicializar la variable C cuando no "
"hay ningún valor predeterminado, pero no especificar un valor predeterminado "
"puede resultar en una advertencia de \"variable no inicializada\". Esto "
"puede suceder fácilmente cuando se utilizan grupos de opciones, aunque el "
"código escrito correctamente nunca utilizará este valor, la variable se pasa "
"al impl, y el compilador de C se quejará del \"uso\" del valor no "
"inicializado. Este valor siempre debe ser una cadena de caracteres no vacía."

#: ../Doc/howto/clinic.rst:1266
msgid "The name of the C converter function, as a string."
msgstr ""
"El nombre de la función de conversión de C, como una cadena de caracteres."

#: ../Doc/howto/clinic.rst:1271
msgid "``impl_by_reference``"
msgstr "``impl_by_reference``"

#: ../Doc/howto/clinic.rst:1269
msgid ""
"A boolean value.  If true, Argument Clinic will add a ``&`` in front of the "
"name of the variable when passing it into the impl function."
msgstr ""
"Un valor booleano. Si es verdadero, Argument Clinic agregará un ``&`` "
"delante del nombre de la variable al pasarlo a la función *impl*."

#: ../Doc/howto/clinic.rst:1277
msgid "``parse_by_reference``"
msgstr "``parse_by_reference``"

#: ../Doc/howto/clinic.rst:1274
msgid ""
"A boolean value.  If true, Argument Clinic will add a ``&`` in front of the "
"name of the variable when passing it into :c:func:`PyArg_ParseTuple`."
msgstr ""
"Un valor booleano. Si es verdadero, Argument Clinic agregará un ``&`` "
"delante del nombre de la variable al pasarlo a :c:func:`PyArg_ParseTuple`."

#: ../Doc/howto/clinic.rst:1279
msgid ""
"Here's the simplest example of a custom converter, from ``Modules/zlibmodule."
"c``::"
msgstr ""
"Aquí está el ejemplo más simple de un convertidor personalizado, de "
"``Modules/zlibmodule.c``:"

#: ../Doc/howto/clinic.rst:1290
msgid ""
"This block adds a converter to Argument Clinic named ``ssize_t``.  "
"Parameters declared as ``ssize_t`` will be declared as type ``Py_ssize_t``, "
"and will be parsed by the ``'O&'`` format unit, which will call the "
"``ssize_t_converter`` converter function.  ``ssize_t`` variables "
"automatically support default values."
msgstr ""
"Este bloque agrega un convertidor a Argument Clinic llamado ``ssize_t``. Los "
"parámetros declarados como ``ssize_t`` se declararán como tipo "
"``Py_ssize_t`` y serán analizados por la unidad de formato ``'O&'``, que "
"llamará a la función de conversión ``ssize_t_converter``. Las variables "
"``ssize_t`` admiten automáticamente los valores predeterminados."

#: ../Doc/howto/clinic.rst:1296
msgid ""
"More sophisticated custom converters can insert custom C code to handle "
"initialization and cleanup. You can see more examples of custom converters "
"in the CPython source tree; grep the C files for the string ``CConverter``."
msgstr ""
"Los convertidores personalizados más sofisticados pueden insertar código C "
"personalizado para manejar la inicialización y la limpieza. Puede ver más "
"ejemplos de convertidores personalizados en el árbol de fuentes de CPython; "
"grep los archivos C para la cadena ``CConverter``."

#: ../Doc/howto/clinic.rst:1302
msgid "Writing a custom return converter"
msgstr "Escribiendo un convertidor de retorno personalizado"

#: ../Doc/howto/clinic.rst:1304
msgid ""
"Writing a custom return converter is much like writing a custom converter.  "
"Except it's somewhat simpler, because return converters are themselves much "
"simpler."
msgstr ""
"Escribir un convertidor de retorno personalizado es muy parecido a escribir "
"un convertidor personalizado. Excepto que es algo más simple, porque los "
"convertidores de retorno son en sí mismos mucho más simples."

#: ../Doc/howto/clinic.rst:1308
msgid ""
"Return converters must subclass ``CReturnConverter``. There are no examples "
"yet of custom return converters, because they are not widely used yet.  If "
"you wish to write your own return converter, please read ``Tools/clinic/"
"clinic.py``, specifically the implementation of ``CReturnConverter`` and all "
"its subclasses."
msgstr ""
"Los convertidores de retorno deben tener una subclase de "
"``CReturnConverter``. Todavía no hay ejemplos de convertidores de "
"devoluciones personalizados, porque todavía no se utilizan ampliamente. Si "
"desea escribir su propio convertidor de retorno, lea ``Tools/clinic/clinic."
"py``, específicamente la implementación de ``CReturnConverter`` y todas sus "
"subclases."

#: ../Doc/howto/clinic.rst:1316
msgid "METH_O and METH_NOARGS"
msgstr "METH_O y METH_NOARGS"

#: ../Doc/howto/clinic.rst:1318
msgid ""
"To convert a function using ``METH_O``, make sure the function's single "
"argument is using the ``object`` converter, and mark the arguments as "
"positional-only::"
msgstr ""
"Para convertir una función usando ``METH_O``, asegúrese de que el único "
"argumento de la función esté usando el convertidor de ``object`` y marque "
"los argumentos como solo posicional:"

#: ../Doc/howto/clinic.rst:1330
msgid ""
"To convert a function using ``METH_NOARGS``, just don't specify any "
"arguments."
msgstr ""
"Para convertir una función usando ``METH_NOARGS``, simplemente no "
"especifique ningún argumento."

#: ../Doc/howto/clinic.rst:1333
msgid ""
"You can still use a self converter, a return converter, and specify a "
"``type`` argument to the object converter for ``METH_O``."
msgstr ""
"Aún puede usar un autoconvertidor, un convertidor de retorno y especificar "
"un argumento de ``tipo`` para el convertidor de objetos para ``METH_O``."

#: ../Doc/howto/clinic.rst:1337
msgid "tp_new and tp_init functions"
msgstr "funciones tp_new y tp_init"

#: ../Doc/howto/clinic.rst:1339
msgid ""
"You can convert ``tp_new`` and ``tp_init`` functions.  Just name them "
"``__new__`` or ``__init__`` as appropriate.  Notes:"
msgstr ""
"Puede convertir las funciones ``tp_new`` y ``tp_init``. Simplemente "
"nómbrelos ``__new__`` o ``__init__`` según corresponda. Notas:"

#: ../Doc/howto/clinic.rst:1342
msgid ""
"The function name generated for ``__new__`` doesn't end in ``__new__`` like "
"it would by default.  It's just the name of the class, converted into a "
"valid C identifier."
msgstr ""
"El nombre de la función generado para ``__new__`` no termina en ``__new__`` "
"como lo haría por defecto. Es solo el nombre de la clase, convertido en un "
"identificador C válido."

#: ../Doc/howto/clinic.rst:1346
msgid "No ``PyMethodDef`` ``#define`` is generated for these functions."
msgstr "No se genera ningún ``PyMethodDef`` ``#define`` para estas funciones."

#: ../Doc/howto/clinic.rst:1348
msgid "``__init__`` functions return ``int``, not ``PyObject *``."
msgstr "funciones ``__init__`` retornan ``int``, no ``PyObject *``."

#: ../Doc/howto/clinic.rst:1350
msgid "Use the docstring as the class docstring."
msgstr "Utilice docstring como la clase de documentación."

#: ../Doc/howto/clinic.rst:1352
msgid ""
"Although ``__new__`` and ``__init__`` functions must always accept both the "
"``args`` and ``kwargs`` objects, when converting you may specify any "
"signature for these functions that you like. (If your function doesn't "
"support keywords, the parsing function generated will throw an exception if "
"it receives any.)"
msgstr ""
"Aunque las funciones ``__new__ `` y ``__init__`` siempre deben aceptar tanto "
"los objetos ``args`` como los ``kwargs``, al realizar la conversión puede "
"especificar cualquier firma para estas funciones que desee. (Si su función "
"no admite palabras clave, la función de análisis generada generará una "
"excepción si recibe alguna)."

#: ../Doc/howto/clinic.rst:1359
msgid "Changing and redirecting Clinic's output"
msgstr "Cambiar y redirigir la salida de Clinic"

#: ../Doc/howto/clinic.rst:1361
msgid ""
"It can be inconvenient to have Clinic's output interspersed with your "
"conventional hand-edited C code.  Luckily, Clinic is configurable: you can "
"buffer up its output for printing later (or earlier!), or write its output "
"to a separate file.  You can also add a prefix or suffix to every line of "
"Clinic's generated output."
msgstr ""
"Puede ser inconveniente tener la salida de Clinic intercalada con su código "
"C convencional editado a mano. Afortunadamente, Clinic es configurable: "
"puede almacenar en búfer su salida para imprimir más tarde (¡o antes!), O "
"escribir su salida en un archivo separado. También puede agregar un prefijo "
"o sufijo a cada línea del resultado generado por Clinic."

#: ../Doc/howto/clinic.rst:1367
msgid ""
"While changing Clinic's output in this manner can be a boon to readability, "
"it may result in Clinic code using types before they are defined, or your "
"code attempting to use Clinic-generated code before it is defined. These "
"problems can be easily solved by rearranging the declarations in your file, "
"or moving where Clinic's generated code goes.  (This is why the default "
"behavior of Clinic is to output everything into the current block; while "
"many people consider this hampers readability, it will never require "
"rearranging your code to fix definition-before-use problems.)"
msgstr ""
"Si bien cambiar la salida de la Clínica de esta manera puede ser una "
"bendición para la legibilidad, puede resultar en que el código de la Clínica "
"utilice tipos antes de que se definan, o que su código intente utilizar el "
"código generado por la Clínica antes de que se defina. Estos problemas "
"pueden resolverse fácilmente reorganizando las declaraciones en su archivo o "
"moviendo el código generado por Clinic a donde va. (Esta es la razón por la "
"que el comportamiento predeterminado de Clinic es enviar todo al bloque "
"actual; aunque muchas personas consideran que esto dificulta la legibilidad, "
"nunca será necesario reorganizar su código para solucionar problemas de "
"definición antes de su uso)."

#: ../Doc/howto/clinic.rst:1376
msgid "Let's start with defining some terminology:"
msgstr "Comencemos por definir alguna terminología:"

#: ../Doc/howto/clinic.rst:1403
msgid "*field*"
msgstr "*field*"

#: ../Doc/howto/clinic.rst:1379
msgid ""
"A field, in this context, is a subsection of Clinic's output. For example, "
"the ``#define`` for the ``PyMethodDef`` structure is a field, called "
"``methoddef_define``.  Clinic has seven different fields it can output per "
"function definition:"
msgstr ""
"Un campo, en este contexto, es una subsección del resultado de la Clínica. "
"Por ejemplo, el ``#define`` para la estructura ``PyMethodDef`` es un campo, "
"llamado ``methoddef_define``. La clínica tiene siete campos diferentes que "
"puede generar por definición de función:"

#: ../Doc/howto/clinic.rst:1394
msgid ""
"All the names are of the form ``\"<a>_<b>\"``, where ``\"<a>\"`` is the "
"semantic object represented (the parsing function, the impl function, the "
"docstring, or the methoddef structure) and ``\"<b>\"`` represents what kind "
"of statement the field is.  Field names that end in ``\"_prototype\"`` "
"represent forward declarations of that thing, without the actual body/data "
"of the thing; field names that end in ``\"_definition\"`` represent the "
"actual definition of the thing, with the body/data of the thing.  (``"
"\"methoddef\"`` is special, it's the only one that ends with ``\"_define"
"\"``, representing that it's a preprocessor #define.)"
msgstr ""
"Todos los nombres tienen la forma ``\"<a>_<b>\"``, donde ``\"<a>\"`` es el "
"objeto semántico representado (la función de análisis, la función impl, el "
"docstring o la estructura methoddef) y ``\"<b>\"`` representa qué tipo de "
"declaración es el campo. Los nombres de campo que terminan en ``\"_prototype"
"\"`` representan declaraciones hacia adelante de esa cosa, sin el cuerpo/"
"datos reales de la cosa; los nombres de campo que terminan en ``\"_definition"
"\"`` representan la definición real de la cosa, con el cuerpo/datos de la "
"cosa. (``\"methoddef\"`` es especial, es el único que termina con ``\"_define"
"\"``, lo que representa que es un preprocesador #define)."

#: ../Doc/howto/clinic.rst:1437
msgid "*destination*"
msgstr "*destination*"

#: ../Doc/howto/clinic.rst:1406
msgid ""
"A destination is a place Clinic can write output to.  There are five built-"
"in destinations:"
msgstr ""
"Un destino es un lugar en el que la Clínica puede escribir resultados. Hay "
"cinco destinos incorporados:"

#: ../Doc/howto/clinic.rst:1411 ../Doc/howto/clinic.rst:1486
#: ../Doc/howto/clinic.rst:1564
msgid "``block``"
msgstr "``block``"

#: ../Doc/howto/clinic.rst:1410
msgid ""
"The default destination: printed in the output section of the current Clinic "
"block."
msgstr ""
"El destino predeterminado: impreso en la sección de salida del bloque "
"Clínico actual."

#: ../Doc/howto/clinic.rst:1417 ../Doc/howto/clinic.rst:1513
#: ../Doc/howto/clinic.rst:1567
msgid "``buffer``"
msgstr "``buffer``"

#: ../Doc/howto/clinic.rst:1414
msgid ""
"A text buffer where you can save text for later.  Text sent here is appended "
"to the end of any existing text.  It's an error to have any text left in the "
"buffer when Clinic finishes processing a file."
msgstr ""
"Un búfer de texto donde puede guardar texto para más tarde. El texto enviado "
"aquí se agrega al final de cualquier texto existente. Es un error dejar "
"texto en el búfer cuando Clinic termina de procesar un archivo."

#: ../Doc/howto/clinic.rst:1428 ../Doc/howto/clinic.rst:1499
#: ../Doc/howto/clinic.rst:1593
msgid "``file``"
msgstr "``file``"

#: ../Doc/howto/clinic.rst:1420
msgid ""
"A separate \"clinic file\" that will be created automatically by Clinic. The "
"filename chosen for the file is ``{basename}.clinic{extension}``, where "
"``basename`` and ``extension`` were assigned the output from ``os.path."
"splitext()`` run on the current file.  (Example: the ``file`` destination "
"for ``_pickle.c`` would be written to ``_pickle.clinic.c``.)"
msgstr ""
"Un \"archivo clínico\" separado que Clinic creará automáticamente. El nombre "
"de archivo elegido para el archivo es ``{basename}.clinic{extension}``, "
"donde a ``basename`` y ``extension`` se les asignó la salida de ``os.path."
"splitext()`` ejecutar en El archivo actual. (Ejemplo: el destino del "
"``file`` para ``_pickle.c`` se escribiría en ``_pickle.clinic.c``.)"

#: ../Doc/howto/clinic.rst:1427
msgid ""
"**Important: When using a** ``file`` **destination, you** *must check in* "
"**the generated file!**"
msgstr ""
"**Importante: Al usar un destino **``file``**, *debe registrar* **el archivo "
"generado!**"

#: ../Doc/howto/clinic.rst:1433 ../Doc/howto/clinic.rst:1526
#: ../Doc/howto/clinic.rst:1597
msgid "``two-pass``"
msgstr "``two-pass``"

#: ../Doc/howto/clinic.rst:1431
msgid ""
"A buffer like ``buffer``.  However, a two-pass buffer can only be dumped "
"once, and it prints out all text sent to it during all processing, even from "
"Clinic blocks *after* the dumping point."
msgstr ""
"Un búfer como ``buffer``. Sin embargo, un búfer de dos pasadas solo se puede "
"volcar una vez, e imprime todo el texto que se le envía durante todo el "
"procesamiento, incluso desde los bloques de la Clínica *después* del punto "
"de descarga."

#: ../Doc/howto/clinic.rst:1437 ../Doc/howto/clinic.rst:1560
msgid "``suppress``"
msgstr "``suppress``"

#: ../Doc/howto/clinic.rst:1436
msgid "The text is suppressed—thrown away."
msgstr "El texto se suprime --- se tira."

#: ../Doc/howto/clinic.rst:1439
msgid "Clinic defines five new directives that let you reconfigure its output."
msgstr ""
"Clinic define cinco nuevas directivas que le permiten reconfigurar su salida."

#: ../Doc/howto/clinic.rst:1441
msgid "The first new directive is ``dump``:"
msgstr "La primera nueva directiva es ``dump``:"

#: ../Doc/howto/clinic.rst:1447
msgid ""
"This dumps the current contents of the named destination into the output of "
"the current block, and empties it.  This only works with ``buffer`` and "
"``two-pass`` destinations."
msgstr ""
"Esto vuelca el contenido actual del destino nombrado en la salida del bloque "
"actual y lo vacía. Esto solo funciona con destinos de ``búfer`` y de ``dos "
"pasadas``."

#: ../Doc/howto/clinic.rst:1451
msgid ""
"The second new directive is ``output``.  The most basic form of ``output`` "
"is like this:"
msgstr ""
"La segunda nueva directiva es ``output``. La forma más básica de ``output`` "
"es así:"

#: ../Doc/howto/clinic.rst:1458
msgid ""
"This tells Clinic to output *field* to *destination*.  ``output`` also "
"supports a special meta-destination, called ``everything``, which tells "
"Clinic to output *all* fields to that *destination*."
msgstr ""
"Esto le dice a la Clínica que envíe *field* a *destination*. ``output`` "
"también admite un metadestino especial, llamado ``everything``, que le dice "
"a Clinic que envíe *todos* los campos a ese *destination*."

#: ../Doc/howto/clinic.rst:1462
msgid "``output`` has a number of other functions:"
msgstr "``output`` tiene una serie de otras funciones:"

#: ../Doc/howto/clinic.rst:1471
msgid ""
"``output push`` and ``output pop`` allow you to push and pop configurations "
"on an internal configuration stack, so that you can temporarily modify the "
"output configuration, then easily restore the previous configuration.  "
"Simply push before your change to save the current configuration, then pop "
"when you wish to restore the previous configuration."
msgstr ""
"``output push`` y ``output pop`` le permiten agregar y quitar "
"configuraciones en una pila de configuración interna, para que pueda "
"modificar temporalmente la configuración de salida, y luego restaurar "
"fácilmente la configuración anterior. Simplemente presione antes de su "
"cambio para guardar la configuración actual, luego haga estallar cuando "
"desee restaurar la configuración anterior."

#: ../Doc/howto/clinic.rst:1478
msgid ""
"``output preset`` sets Clinic's output to one of several built-in preset "
"configurations, as follows:"
msgstr ""
"``output preset`` configura la salida de Clinic en una de varias "
"configuraciones preestablecidas incorporadas, de la siguiente manera:"

#: ../Doc/howto/clinic.rst:1482
msgid ""
"Clinic's original starting configuration.  Writes everything immediately "
"after the input block."
msgstr ""
"Configuración inicial original de la clínica. Escribe todo inmediatamente "
"después del bloque de entrada."

#: ../Doc/howto/clinic.rst:1485
msgid ""
"Suppress the ``parser_prototype`` and ``docstring_prototype``, write "
"everything else to ``block``."
msgstr ""
"Suprime el ``parser_prototype`` y ``docstring_prototype``, escribe todo lo "
"demás en ``block``."

#: ../Doc/howto/clinic.rst:1489
msgid ""
"Designed to write everything to the \"clinic file\" that it can. You then "
"``#include`` this file near the top of your file. You may need to rearrange "
"your file to make this work, though usually this just means creating forward "
"declarations for various ``typedef`` and ``PyTypeObject`` definitions."
msgstr ""
"Diseñado para escribir todo lo que pueda en el \"archivo clínico\". Luego, "
"``#include`` este archivo cerca de la parte superior de su archivo. Es "
"posible que deba reorganizar su archivo para que esto funcione, aunque "
"generalmente esto solo significa crear declaraciones hacia adelante para "
"varias definiciones de ``typedef`` y ``PyTypeObject``."

#: ../Doc/howto/clinic.rst:1495
msgid ""
"Suppress the ``parser_prototype`` and ``docstring_prototype``, write the "
"``impl_definition`` to ``block``, and write everything else to ``file``."
msgstr ""
"Suprima ``parser_prototype`` y ``docstring_prototype``, escriba la "
"``impl_definition`` en ``block`` y escriba todo lo demás en ``file``."

#: ../Doc/howto/clinic.rst:1499
msgid "The default filename is ``\"{dirname}/clinic/{basename}.h\"``."
msgstr ""
"El nombre de archivo predeterminado es ``\"{dirname}/clinic/{basename}.h\"``."

#: ../Doc/howto/clinic.rst:1502
msgid ""
"Save up most of the output from Clinic, to be written into your file near "
"the end.  For Python files implementing modules or builtin types, it's "
"recommended that you dump the buffer just above the static structures for "
"your module or builtin type; these are normally very near the end.  Using "
"``buffer`` may require even more editing than ``file``, if your file has "
"static ``PyMethodDef`` arrays defined in the middle of the file."
msgstr ""
"Guarde la mayor parte del resultado de Clinic para escribirlo en su archivo "
"cerca del final. Para los archivos Python que implementan módulos o tipos "
"incorporado, se recomienda que descargue el búfer justo encima de las "
"estructuras estáticas para su módulo o tipo incorporado; estos suelen estar "
"muy cerca del final. El uso de ``buffer`` puede requerir incluso más edición "
"que ``file``, si su archivo tiene arreglos estáticos ``PyMethodDef`` "
"definidos en el medio del archivo."

#: ../Doc/howto/clinic.rst:1511
msgid ""
"Suppress the ``parser_prototype``, ``impl_prototype``, and "
"``docstring_prototype``, write the ``impl_definition`` to ``block``, and "
"write everything else to ``file``."
msgstr ""
"Suprima el ``parser_prototype``, ``impl_prototype`` y "
"``docstring_prototype``, escriba ``impl_definition`` en ``block`` y escriba "
"todo lo demás en ``file``."

#: ../Doc/howto/clinic.rst:1516
msgid ""
"Similar to the ``buffer`` preset, but writes forward declarations to the "
"``two-pass`` buffer, and definitions to the ``buffer``. This is similar to "
"the ``buffer`` preset, but may require less editing than ``buffer``.  Dump "
"the ``two-pass`` buffer near the top of your file, and dump the ``buffer`` "
"near the end just like you would when using the ``buffer`` preset."
msgstr ""
"Similar al ajuste preestablecido de ``buffer``, pero escribe declaraciones "
"hacia adelante en el búfer de ``dos pasadas`` y definiciones en el "
"``buffer``. Esto es similar al ajuste preestablecido de ``buffer``, pero "
"puede requerir menos edición que ``buffer``. Vierta el búfer de ``dos "
"pasadas`` cerca de la parte superior de su archivo y descargue el ``buffer`` "
"cerca del final como lo haría cuando usa el ajuste preestablecido de "
"``buffer``."

#: ../Doc/howto/clinic.rst:1523
msgid ""
"Suppresses the ``impl_prototype``, write the ``impl_definition`` to "
"``block``, write ``docstring_prototype``, ``methoddef_define``, and "
"``parser_prototype`` to ``two-pass``, write everything else to ``buffer``."
msgstr ""
"Suprime el ``impl_prototype``, escribe ``impl_definition`` en ``block``, "
"escribe ``docstring_prototype``, ``methoddef_define`` y ``parser_prototype`` "
"en ``two-pass``, escribe todo lo demás en ``buffer``."

#: ../Doc/howto/clinic.rst:1537
msgid "``partial-buffer``"
msgstr "``partial-buffer``"

#: ../Doc/howto/clinic.rst:1529
msgid ""
"Similar to the ``buffer`` preset, but writes more things to ``block``, only "
"writing the really big chunks of generated code to ``buffer``. This avoids "
"the definition-before-use problem of ``buffer`` completely, at the small "
"cost of having slightly more stuff in the block's output. Dump the "
"``buffer`` near the end, just like you would when using the ``buffer`` "
"preset."
msgstr ""
"Similar al ajuste preestablecido de ``buffer``, pero escribe más cosas en "
"``block``, solo escribe los trozos realmente grandes de código generado en "
"``buffer``. Esto evita el problema de definición antes del uso de ``buffer`` "
"por completo, con el pequeño costo de tener un poco más de material en la "
"salida del bloque. Vierta el ``buffer`` cerca del final, tal como lo haría "
"cuando usa el ajuste predeterminado de ``buffer``."

#: ../Doc/howto/clinic.rst:1536
msgid ""
"Suppresses the ``impl_prototype``, write the ``docstring_definition`` and "
"``parser_definition`` to ``buffer``, write everything else to ``block``."
msgstr ""
"Suprime el ``impl_prototype``, escribe ``docstring_definition`` y "
"``parser_definition`` en ``buffer``, escribe todo lo demás en ``block``."

#: ../Doc/howto/clinic.rst:1539
msgid "The third new directive is ``destination``:"
msgstr "La tercera nueva directiva es ``destino``:"

#: ../Doc/howto/clinic.rst:1545
msgid "This performs an operation on the destination named ``name``."
msgstr "Esto realiza una operación en el destino llamado ``name``."

#: ../Doc/howto/clinic.rst:1547
msgid "There are two defined subcommands: ``new`` and ``clear``."
msgstr "Hay dos subcomandos definidos: ``new`` y ``clear``."

#: ../Doc/howto/clinic.rst:1549
msgid "The ``new`` subcommand works like this:"
msgstr "El subcomando ``new`` funciona así:"

#: ../Doc/howto/clinic.rst:1555
msgid ""
"This creates a new destination with name ``<name>`` and type ``<type>``."
msgstr ""
"Esto crea un nuevo destino con el nombre ``<nombre>`` y escribe ``<tipo>``."

#: ../Doc/howto/clinic.rst:1557
msgid "There are five destination types:"
msgstr "Hay cinco tipos de destinos:"

#: ../Doc/howto/clinic.rst:1560
msgid "Throws the text away."
msgstr "Tira el texto."

#: ../Doc/howto/clinic.rst:1563
msgid ""
"Writes the text to the current block.  This is what Clinic originally did."
msgstr ""
"Escribe el texto en el bloque actual. Esto es lo que hizo Clinic "
"originalmente."

#: ../Doc/howto/clinic.rst:1567
msgid "A simple text buffer, like the \"buffer\" builtin destination above."
msgstr ""
"Un búfer de texto simple, como el destino incorporado \"búfer\" anterior."

#: ../Doc/howto/clinic.rst:1570
msgid ""
"A text file.  The file destination takes an extra argument, a template to "
"use for building the filename, like so:"
msgstr ""
"Un archivo de texto. El destino del archivo toma un argumento adicional, una "
"plantilla para usar para construir el nombre de archivo, así:"

#: ../Doc/howto/clinic.rst:1573
msgid "destination <name> new <type> <file_template>"
msgstr "destino <name> nuevo <type> <file_template>"

#: ../Doc/howto/clinic.rst:1575
msgid ""
"The template can use three strings internally that will be replaced by bits "
"of the filename:"
msgstr ""
"La plantilla puede usar tres cadenas internamente que serán reemplazadas por "
"bits del nombre del archivo:"

#: ../Doc/howto/clinic.rst:1578
msgid "{path}"
msgstr "{path}"

#: ../Doc/howto/clinic.rst:1579
msgid "The full path to the file, including directory and full filename."
msgstr ""
"La ruta completa al archivo, incluido el directorio y el nombre de archivo "
"completo."

#: ../Doc/howto/clinic.rst:1580
msgid "{dirname}"
msgstr "{dirname}"

#: ../Doc/howto/clinic.rst:1581
msgid "The name of the directory the file is in."
msgstr "El nombre del directorio en el que se encuentra el archivo."

#: ../Doc/howto/clinic.rst:1582
msgid "{basename}"
msgstr "{basename}"

#: ../Doc/howto/clinic.rst:1583
msgid "Just the name of the file, not including the directory."
msgstr "Solo el nombre del archivo, sin incluir el directorio."

#: ../Doc/howto/clinic.rst:1585
msgid "{basename_root}"
msgstr "{basename_root}"

#: ../Doc/howto/clinic.rst:1585
msgid ""
"Basename with the extension clipped off (everything up to but not including "
"the last '.')."
msgstr ""
"Nombre de base con la extensión recortada (todo hasta pero sin incluir el "
"último '.')."

#: ../Doc/howto/clinic.rst:1589
msgid "{basename_extension}"
msgstr "{basename_extension}"

#: ../Doc/howto/clinic.rst:1588
msgid ""
"The last '.' and everything after it.  If the basename does not contain a "
"period, this will be the empty string."
msgstr ""
"El último '.' y todo lo que sigue. Si el nombre base no contiene un punto, "
"esta será la cadena de caracteres vacía."

#: ../Doc/howto/clinic.rst:1591
msgid ""
"If there are no periods in the filename, {basename} and {filename} are the "
"same, and {extension} is empty.  \"{basename}{extension}\" is always exactly "
"the same as \"{filename}\".\""
msgstr ""
"Si no hay puntos en el nombre del archivo, {basename} y {filename} son "
"iguales, y {extension} está vacía. \"{basename}{extension}\" es siempre "
"exactamente igual que \"{filename}\". \""

#: ../Doc/howto/clinic.rst:1596
msgid "A two-pass buffer, like the \"two-pass\" builtin destination above."
msgstr ""
"Un búfer de dos pasadas (*two-pass*), como el destino incorporado de \"dos "
"pasadas\" anterior."

#: ../Doc/howto/clinic.rst:1599
msgid "The ``clear`` subcommand works like this:"
msgstr "El subcomando ``clear`` funciona así:"

#: ../Doc/howto/clinic.rst:1605
msgid ""
"It removes all the accumulated text up to this point in the destination. (I "
"don't know what you'd need this for, but I thought maybe it'd be useful "
"while someone's experimenting.)"
msgstr ""
"Elimina todo el texto acumulado hasta este punto en el destino. (No sé para "
"qué necesitarías esto, pero pensé que tal vez sería útil mientras alguien "
"está experimentando)."

#: ../Doc/howto/clinic.rst:1609
msgid "The fourth new directive is ``set``:"
msgstr "La cuarta nueva directiva está ``set``:"

#: ../Doc/howto/clinic.rst:1616
msgid ""
"``set`` lets you set two internal variables in Clinic. ``line_prefix`` is a "
"string that will be prepended to every line of Clinic's output; "
"``line_suffix`` is a string that will be appended to every line of Clinic's "
"output."
msgstr ""
"``set`` le permite configurar dos variables internas en la Clínica. "
"``line_prefix`` es una cadena que se antepondrá a cada línea de salida de la "
"Clínica; ``line_suffix`` es una cadena de caracteres que se agregará a cada "
"línea de salida de la Clínica."

#: ../Doc/howto/clinic.rst:1620
msgid "Both of these support two format strings:"
msgstr "Ambos admiten dos cadenas de caracteres de formato:"

#: ../Doc/howto/clinic.rst:1623
msgid "``{block comment start}``"
msgstr "``{block comment start}``"

#: ../Doc/howto/clinic.rst:1623
msgid ""
"Turns into the string ``/*``, the start-comment text sequence for C files."
msgstr ""
"Se convierte en la cadena de caracteres ``/*``, la secuencia de texto de "
"inicio de comentario para archivos C."

#: ../Doc/howto/clinic.rst:1626
msgid "``{block comment end}``"
msgstr "``{block comment end}``"

#: ../Doc/howto/clinic.rst:1626
msgid ""
"Turns into the string ``*/``, the end-comment text sequence for C files."
msgstr ""
"Se convierte en la cadena ``*/``, la secuencia de texto del comentario final "
"para los archivos C."

#: ../Doc/howto/clinic.rst:1628
msgid ""
"The final new directive is one you shouldn't need to use directly, called "
"``preserve``:"
msgstr ""
"La nueva directiva final es una que no debería necesitar usar directamente, "
"llamada ``preserve``:"

#: ../Doc/howto/clinic.rst:1635
msgid ""
"This tells Clinic that the current contents of the output should be kept, "
"unmodified. This is used internally by Clinic when dumping output into "
"``file`` files; wrapping it in a Clinic block lets Clinic use its existing "
"checksum functionality to ensure the file was not modified by hand before it "
"gets overwritten."
msgstr ""
"Esto le dice a Clinic que el contenido actual de la salida debe mantenerse, "
"sin modificaciones. La Clínica lo usa internamente cuando se descarga la "
"salida en archivos de ``file``; envolverlo en un bloque Clinic permite que "
"Clinic use su funcionalidad de suma de comprobación existente para "
"garantizar que el archivo no se modificó a mano antes de sobrescribirlo."

#: ../Doc/howto/clinic.rst:1642
msgid "The #ifdef trick"
msgstr "El truco #ifdef"

#: ../Doc/howto/clinic.rst:1644
msgid ""
"If you're converting a function that isn't available on all platforms, "
"there's a trick you can use to make life a little easier.  The existing code "
"probably looks like this::"
msgstr ""
"Si está convirtiendo una función que no está disponible en todas las "
"plataformas, hay un truco que puede usar para hacer la vida un poco más "
"fácil. El código existente probablemente se ve así:"

#: ../Doc/howto/clinic.rst:1655
msgid ""
"And then in the ``PyMethodDef`` structure at the bottom the existing code "
"will have:"
msgstr ""
"Y luego, en la estructura ``PyMethodDef`` en la parte inferior, el código "
"existente tendrá:"

#: ../Doc/howto/clinic.rst:1664
msgid ""
"In this scenario, you should enclose the body of your impl function inside "
"the ``#ifdef``, like so::"
msgstr ""
"En este escenario, debe encerrar el cuerpo de su función *impl* dentro de "
"``#ifdef``, así:"

#: ../Doc/howto/clinic.rst:1678
msgid ""
"Then, remove those three lines from the ``PyMethodDef`` structure, replacing "
"them with the macro Argument Clinic generated:"
msgstr ""
"Luego, elimine esas tres líneas de la estructura ``PyMethodDef``, "
"reemplazándolas con la macro Argument Clinic generada:"

#: ../Doc/howto/clinic.rst:1685
msgid ""
"(You can find the real name for this macro inside the generated code. Or you "
"can calculate it yourself: it's the name of your function as defined on the "
"first line of your block, but with periods changed to underscores, "
"uppercased, and ``\"_METHODDEF\"`` added to the end.)"
msgstr ""
"(Puede encontrar el nombre real de esta macro dentro del código generado. O "
"puede calcularlo usted mismo: es el nombre de su función tal como se define "
"en la primera línea de su bloque, pero con puntos cambiados a guiones bajos, "
"mayúsculas y ``\"_METHODDEF\"`` agregado al final.)"

#: ../Doc/howto/clinic.rst:1690
msgid ""
"Perhaps you're wondering: what if ``HAVE_FUNCTIONNAME`` isn't defined? The "
"``MODULE_FUNCTIONNAME_METHODDEF`` macro won't be defined either!"
msgstr ""
"Quizás se esté preguntando: ¿qué pasa si ``HAVE_FUNCTIONNAME`` no está "
"definido? ¡La macro ``MODULE_FUNCTIONNAME_METHODDEF`` tampoco se definirá!"

#: ../Doc/howto/clinic.rst:1693
msgid ""
"Here's where Argument Clinic gets very clever.  It actually detects that the "
"Argument Clinic block might be deactivated by the ``#ifdef``.  When that "
"happens, it generates a little extra code that looks like this::"
msgstr ""
"Aquí es donde Argument Clinic se vuelve muy inteligente. De hecho, detecta "
"que el bloqueo de Argument Clinic podría estar desactivado por el "
"``#ifdef``. Cuando eso sucede, genera un pequeño código adicional que se ve "
"así:"

#: ../Doc/howto/clinic.rst:1701
msgid ""
"That means the macro always works.  If the function is defined, this turns "
"into the correct structure, including the trailing comma.  If the function "
"is undefined, this turns into nothing."
msgstr ""
"Eso significa que la macro siempre funciona. Si la función está definida, se "
"convierte en la estructura correcta, incluida la coma al final. Si la "
"función no está definida, esto se convierte en nada."

#: ../Doc/howto/clinic.rst:1705
msgid ""
"However, this causes one ticklish problem: where should Argument Clinic put "
"this extra code when using the \"block\" output preset?  It can't go in the "
"output block, because that could be deactivated by the ``#ifdef``.  (That's "
"the whole point!)"
msgstr ""
"Sin embargo, esto causa un problema delicado: ¿dónde debería poner Argument "
"Clinic este código adicional cuando se usa el ajuste preestablecido de "
"salida \"bloque\"? No puede entrar en el bloque de salida, porque podría "
"desactivarse con ``#ifdef``. (¡Ese es todo el punto!)"

#: ../Doc/howto/clinic.rst:1709
msgid ""
"In this situation, Argument Clinic writes the extra code to the \"buffer\" "
"destination. This may mean that you get a complaint from Argument Clinic:"
msgstr ""
"En esta situación, Argument Clinic escribe el código adicional en el destino "
"del \"búfer\". Esto puede significar que recibe una queja de Argument Clinic:"

#: ../Doc/howto/clinic.rst:1717
msgid ""
"When this happens, just open your file, find the ``dump buffer`` block that "
"Argument Clinic added to your file (it'll be at the very bottom), then move "
"it above the ``PyMethodDef`` structure where that macro is used."
msgstr ""
"Cuando esto suceda, simplemente abra su archivo, busque el bloque ``dump "
"buffer`` que Argument Clinic agregó a su archivo (estará en la parte "
"inferior), luego muévalo arriba de la estructura ``PyMethodDef`` donde esa "
"macro se utiliza."

#: ../Doc/howto/clinic.rst:1724
msgid "Using Argument Clinic in Python files"
msgstr "Usando Argument Clinic en archivos Python"

#: ../Doc/howto/clinic.rst:1726
msgid ""
"It's actually possible to use Argument Clinic to preprocess Python files. "
"There's no point to using Argument Clinic blocks, of course, as the output "
"wouldn't make any sense to the Python interpreter.  But using Argument "
"Clinic to run Python blocks lets you use Python as a Python preprocessor!"
msgstr ""
"De hecho, es posible utilizar Argument Clinic para preprocesar archivos "
"Python. Por supuesto, no tiene sentido usar bloques de Argument Clinic, ya "
"que la salida no tendría ningún sentido para el intérprete de Python. ¡Pero "
"usar Argument Clinic para ejecutar bloques de Python le permite usar Python "
"como un preprocesador de Python!"

#: ../Doc/howto/clinic.rst:1731
msgid ""
"Since Python comments are different from C comments, Argument Clinic blocks "
"embedded in Python files look slightly different.  They look like this:"
msgstr ""
"Dado que los comentarios de Python son diferentes de los comentarios de C, "
"los bloques de Argument Clinic incrustados en archivos de Python tienen un "
"aspecto ligeramente diferente. Se ven así:"
