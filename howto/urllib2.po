# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to get
# the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2023-03-09 08:37-0300\n"
"Last-Translator: Francisco Mora <fr.morac@duocuc.cl>\n"
"Language: es_AR\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.0\n"

#: ../Doc/howto/urllib2.rst:5
msgid "HOWTO Fetch Internet Resources Using The urllib Package"
msgstr "HOWTO - Cómo obtener recursos de Internet con el paquete urllib"

#: ../Doc/howto/urllib2.rst
msgid "Author"
msgstr "Autor"

#: ../Doc/howto/urllib2.rst:7
msgid "`Michael Foord <https://agileabstractions.com/>`_"
msgstr "`Michael Foord <https://agileabstractions.com/>`_"

#: ../Doc/howto/urllib2.rst:11
msgid "Introduction"
msgstr "Introducción"

#: ../Doc/howto/urllib2.rst:15
msgid ""
"You may also find useful the following article on fetching web resources "
"with Python:"
msgstr ""
"También puedes encontrar útil el siguiente artículo sobre la obtención de "
"recursos web con Python:"

#: ../Doc/howto/urllib2.rst:18
msgid ""
"`Basic Authentication <https://web.archive.org/web/20201215133350/http://www."
"voidspace.org.uk/python/articles/authentication.shtml>`_"
msgstr ""
"`Basic Authentication <http://www.voidspace.org.uk/python/articles/"
"authentication.shtml>`_"

#: ../Doc/howto/urllib2.rst:20
msgid "A tutorial on *Basic Authentication*, with examples in Python."
msgstr "Un tutorial sobre *Autenticación Básica*, con ejemplos en Python."

#: ../Doc/howto/urllib2.rst:22
msgid ""
"**urllib.request** is a Python module for fetching URLs (Uniform Resource "
"Locators). It offers a very simple interface, in the form of the *urlopen* "
"function. This is capable of fetching URLs using a variety of different "
"protocols. It also offers a slightly more complex interface for handling "
"common situations - like basic authentication, cookies, proxies and so on. "
"These are provided by objects called handlers and openers."
msgstr ""
"**urllib.request** es un módulo Python para acceder y utilizar recursos de "
"internet identificados por URLs (*Uniform Resource Locators*). Ofrece una "
"interfaz muy simple, a través de la función *urlopen*. Esta función es capaz "
"de acceder a URLs usando una variedad de protocolos diferentes. También "
"ofrece una interfaz un poco más compleja para manejar situaciones comunes - "
"como la autenticación básica, cookies y proxies, entre otros. Estos son "
"proporcionados por los llamados objetos de apertura y gestores."

#: ../Doc/howto/urllib2.rst:29
msgid ""
"urllib.request supports fetching URLs for many \"URL schemes\" (identified "
"by the string before the ``\":\"`` in URL - for example ``\"ftp\"`` is the "
"URL scheme of ``\"ftp://python.org/\"``) using their associated network "
"protocols (e.g. FTP, HTTP). This tutorial focuses on the most common case, "
"HTTP."
msgstr ""
"urllib.request soporta la obtención de recursos identificados por URLs para "
"muchos \"esquemas de URL\" (identificados por la cadena de texto ubicada "
"antes del ``\":\"`` en el URL - por ejemplo ``\"ftp\"`` es el esquema de URL "
"de ``\"ftp://python.org/\"``) usando sus protocolos de red asociados (por "
"ejemplo FTP, HTTP). Este tutorial se centra en el caso más común, HTTP."

#: ../Doc/howto/urllib2.rst:34
msgid ""
"For straightforward situations *urlopen* is very easy to use. But as soon as "
"you encounter errors or non-trivial cases when opening HTTP URLs, you will "
"need some understanding of the HyperText Transfer Protocol. The most "
"comprehensive and authoritative reference to HTTP is :rfc:`2616`. This is a "
"technical document and not intended to be easy to read. This HOWTO aims to "
"illustrate using *urllib*, with enough detail about HTTP to help you "
"through. It is not intended to replace the :mod:`urllib.request` docs, but "
"is supplementary to them."
msgstr ""
"Para situaciones sencillas *urlopen* es muy fácil de usar. Pero tan pronto "
"como encuentres errores o casos no triviales al abrir URLs HTTP, necesitarás "
"entender el Protocolo de Transferencia de Hipertexto. La referencia más "
"completa y autorizada para HTTP es :rfc:`2616`. Este es un documento técnico "
"y no pretende ser fácil de leer. Este HOWTO tiene como objetivo ilustrar el "
"uso de la *urllib*, con suficientes detalles sobre HTTP para ayudarte a "
"entenderlo. No pretende reemplazar los documentos :mod:`urllib.request`, "
"pero es complementario a ellos."

#: ../Doc/howto/urllib2.rst:44
msgid "Fetching URLs"
msgstr "Obtención de URLs"

#: ../Doc/howto/urllib2.rst:46
msgid "The simplest way to use urllib.request is as follows::"
msgstr "La forma más simple de usar urllib.request es la siguiente::"

#: ../Doc/howto/urllib2.rst:52
msgid ""
"If you wish to retrieve a resource via URL and store it in a temporary "
"location, you can do so via the :func:`shutil.copyfileobj` and :func:"
"`tempfile.NamedTemporaryFile` functions::"
msgstr ""
"Si deseas recuperar un recurso a partir de la URL y almacenarlo en una "
"ubicación temporal, puede hacerlo a través de las funciones :func:`shutil."
"copyfileobj` y :func:`tempfile.NamedTemporaryFile`::"

#: ../Doc/howto/urllib2.rst:67
msgid ""
"Many uses of urllib will be that simple (note that instead of an 'http:' URL "
"we could have used a URL starting with 'ftp:', 'file:', etc.).  However, "
"it's the purpose of this tutorial to explain the more complicated cases, "
"concentrating on HTTP."
msgstr ""
"Muchos usos de urllib serán así de sencillos (nótese que en lugar de una URL "
"'http:' podríamos haber usado una URL que empezara por 'ftp:', 'file:', "
"etc.).  Sin embargo, el propósito de este tutorial es explicar los casos más "
"complicados, concentrándose en el HTTP."

#: ../Doc/howto/urllib2.rst:72
msgid ""
"HTTP is based on requests and responses - the client makes requests and "
"servers send responses. urllib.request mirrors this with a ``Request`` "
"object which represents the HTTP request you are making. In its simplest "
"form you create a Request object that specifies the URL you want to fetch. "
"Calling ``urlopen`` with this Request object returns a response object for "
"the URL requested. This response is a file-like object, which means you can "
"for example call ``.read()`` on the response::"
msgstr ""
"HTTP se basa en peticiones y respuestas - el cliente hace peticiones y los "
"servidores envían respuestas. urllib.request refleja esto con un objeto "
"``Request`` que representa la petición HTTP que estás haciendo. En su forma "
"más simple se crea un objeto Request que especifica la URL que se quiere "
"obtener. Llamar a ``urlopen`` con este objeto Request retorna un objeto "
"respuesta para la URL solicitada. Esta respuesta es un objeto tipo archivo, "
"lo que significa que puedes por ejemplo llamar a ``.read()`` en la "
"respuesta::"

#: ../Doc/howto/urllib2.rst:86
msgid ""
"Note that urllib.request makes use of the same Request interface to handle "
"all URL schemes.  For example, you can make an FTP request like so::"
msgstr ""
"Tenga en cuenta que urllib.request utiliza la misma interfaz de Request para "
"gestionar todos los esquemas de URL.  Por ejemplo, puedes hacer una petición "
"FTP de la siguiente manera::"

#: ../Doc/howto/urllib2.rst:91
msgid ""
"In the case of HTTP, there are two extra things that Request objects allow "
"you to do: First, you can pass data to be sent to the server.  Second, you "
"can pass extra information (\"metadata\") *about* the data or about the "
"request itself, to the server - this information is sent as HTTP "
"\"headers\".  Let's look at each of these in turn."
msgstr ""
"En el caso de HTTP, hay dos cosas adicionales que los objetos Request le "
"permiten hacer: Primero, puede pasar datos para enviarlos al servidor. En "
"segundo lugar, puede pasar información adicional (\"metadatos\") *about* los "
"datos o sobre la solicitud en sí, al servidor; esta información se envía "
"como \"encabezados\" HTTP. Veamos cada uno de estos por turno."

#: ../Doc/howto/urllib2.rst:98
msgid "Data"
msgstr "Datos"

#: ../Doc/howto/urllib2.rst:100
msgid ""
"Sometimes you want to send data to a URL (often the URL will refer to a CGI "
"(Common Gateway Interface) script or other web application). With HTTP, this "
"is often done using what's known as a **POST** request. This is often what "
"your browser does when you submit a HTML form that you filled in on the web. "
"Not all POSTs have to come from forms: you can use a POST to transmit "
"arbitrary data to your own application. In the common case of HTML forms, "
"the data needs to be encoded in a standard way, and then passed to the "
"Request object as the ``data`` argument. The encoding is done using a "
"function from the :mod:`urllib.parse` library. ::"
msgstr ""
"A veces quieres enviar datos a una URL (a menudo la URL se referirá a un "
"script CGI (Common Gateway Interface) u otra aplicación web). Con HTTP, esto "
"se hace a menudo usando lo que se conoce como una petición **POST**. Esto es "
"a menudo lo que su navegador hace cuando envías un formulario HTML que has "
"rellenado en la web. No todos los POSTs tienen que provenir de formularios: "
"puedes usar un POST para transmitir datos arbitrarios a tu propia "
"aplicación. En el caso común de los formularios HTML, los datos tienen que "
"ser codificados de forma estándar, y luego pasados al objeto Request como el "
"argumento ``data``. La codificación se hace usando una función de la "
"biblioteca :mod:`urllib.parse``. ::"

#: ../Doc/howto/urllib2.rst:124
msgid ""
"Note that other encodings are sometimes required (e.g. for file upload from "
"HTML forms - see `HTML Specification, Form Submission <https://www.w3.org/TR/"
"REC-html40/interact/forms.html#h-17.13>`_ for more details)."
msgstr ""
"Ten en cuenta que a veces se requieren otras codificaciones (por ejemplo, "
"para la carga de archivos desde formularios HTML - ver `HTML Specification, "
"Form Submission <https://www.w3.org/TR/REC-html40/interact/forms."
"html#h-17.13>`_ para más detalles)."

#: ../Doc/howto/urllib2.rst:129
msgid ""
"If you do not pass the ``data`` argument, urllib uses a **GET** request. One "
"way in which GET and POST requests differ is that POST requests often have "
"\"side-effects\": they change the state of the system in some way (for "
"example by placing an order with the website for a hundredweight of tinned "
"spam to be delivered to your door).  Though the HTTP standard makes it clear "
"that POSTs are intended to *always* cause side-effects, and GET requests "
"*never* to cause side-effects, nothing prevents a GET request from having "
"side-effects, nor a POST requests from having no side-effects. Data can also "
"be passed in an HTTP GET request by encoding it in the URL itself."
msgstr ""
"Si no pasas el argumento ``data``, urllib usa una petición **GET**. Una de "
"las formas en la que las peticiones GET y POST difieren entre sí es que las "
"peticiones POST a menudo tienen \"efectos secundarios\": cambian el estado "
"del sistema de alguna manera (por ejemplo, haciendo una petición al sitio "
"para que un centenar de spam chatarra sea entregado a tu dirección).  Aunque "
"el estándar HTTP deja claro que las solicitudes POST están *siempre* "
"destinadas a causar efectos secundarios, y las solicitudes GET a *nunca* "
"causar efectos secundarios, nada impide que una solicitud GET tenga efectos "
"secundarios, ni que una solicitud POST no tenga efectos secundarios. Los "
"datos también pueden ser pasados en una solicitud GET HTTP codificándolos en "
"la propia URL."

#: ../Doc/howto/urllib2.rst:139
msgid "This is done as follows::"
msgstr "Esto se hace de la siguiente manera::"

#: ../Doc/howto/urllib2.rst:154
msgid ""
"Notice that the full URL is created by adding a ``?`` to the URL, followed "
"by the encoded values."
msgstr ""
"Nota que la URL completa se crea añadiendo un ``?`` a la URL, seguido de los "
"valores codificados."

#: ../Doc/howto/urllib2.rst:158
msgid "Headers"
msgstr "Encabezados (Headers)"

#: ../Doc/howto/urllib2.rst:160
msgid ""
"We'll discuss here one particular HTTP header, to illustrate how to add "
"headers to your HTTP request."
msgstr ""
"Discutiremos aquí un encabezado HTTP en particular, para ilustrar cómo "
"agregar encabezados a su solicitud HTTP."

#: ../Doc/howto/urllib2.rst:163
msgid ""
"Some websites [#]_ dislike being browsed by programs, or send different "
"versions to different browsers [#]_. By default urllib identifies itself as "
"``Python-urllib/x.y`` (where ``x`` and ``y`` are the major and minor version "
"numbers of the Python release, e.g. ``Python-urllib/2.5``), which may "
"confuse the site, or just plain not work. The way a browser identifies "
"itself is through the ``User-Agent`` header [#]_. When you create a Request "
"object you can pass a dictionary of headers in. The following example makes "
"the same request as above, but identifies itself as a version of Internet "
"Explorer [#]_. ::"
msgstr ""
"A algunos sitios web [#]_ no les gusta ser navegados por programas, o envían "
"diferentes versiones a diferentes navegadores [#]_. Por defecto urllib se "
"identifica como ``Python-urllib/x.y`` (donde ``x`` y ``y`` son los números "
"mayor y menor de la versión de Python, por ejemplo ``Python-urllib/2.5``), "
"lo que puede confundir el sitio, o simplemente no funcionar. La forma en que "
"un navegador se identifica a sí mismo es a través del encabezado ``User-"
"Agent`` [#]_. Cuando creas un objeto Request puedes pasarle un diccionario "
"de encabezados. El siguiente ejemplo hace la misma petición que arriba, pero "
"se identifica como una versión de Internet Explorer [#]_. ::"

#: ../Doc/howto/urllib2.rst:190
msgid ""
"The response also has two useful methods. See the section on `info and "
"geturl`_ which comes after we have a look at what happens when things go "
"wrong."
msgstr ""
"La respuesta también tiene dos métodos útiles. Ver la sección de `info y "
"geturl`_ que viene después de que echemos un vistazo a lo que pasa cuando "
"las cosas van mal."

#: ../Doc/howto/urllib2.rst:195
msgid "Handling Exceptions"
msgstr "Gestión de excepciones"

#: ../Doc/howto/urllib2.rst:197
#, fuzzy
msgid ""
"*urlopen* raises :exc:`~urllib.error.URLError` when it cannot handle a "
"response (though as usual with Python APIs, built-in exceptions such as :exc:"
"`ValueError`, :exc:`TypeError` etc. may also be raised)."
msgstr ""
"*urlopen* genera :exc:`URLError` cuando no puede gestionar una respuesta "
"(aunque como es habitual en las APIs de Python, también se pueden generar "
"excepciones predefinidas tales como :exc:`ValueError`, :exc:`TypeError` "
"etc.)."

#: ../Doc/howto/urllib2.rst:201
#, fuzzy
msgid ""
":exc:`~urllib.error.HTTPError` is the subclass of :exc:`~urllib.error."
"URLError` raised in the specific case of HTTP URLs."
msgstr ""
":exc:`HTTPError` es la subclase de :exc:`URLError` generada en el caso "
"específico de las URLs HTTP."

#: ../Doc/howto/urllib2.rst:204
msgid "The exception classes are exported from the :mod:`urllib.error` module."
msgstr ""
"Las clases de excepción se exportan desde el módulo :mod:`urllib.error`."

#: ../Doc/howto/urllib2.rst:207
msgid "URLError"
msgstr "URLError"

#: ../Doc/howto/urllib2.rst:209
msgid ""
"Often, URLError is raised because there is no network connection (no route "
"to the specified server), or the specified server doesn't exist.  In this "
"case, the exception raised will have a 'reason' attribute, which is a tuple "
"containing an error code and a text error message."
msgstr ""
"A menudo, URLError se genera porque no hay conexión de red (no se encuentra "
"ruta al servidor especificado), o el servidor especificado no existe.  En "
"este caso, la excepción generada tendrá un atributo \"reason\", que es una "
"tupla que contiene un código de error y un mensaje de error de texto."

#: ../Doc/howto/urllib2.rst:214
msgid "e.g. ::"
msgstr "por ejemplo ::"

#: ../Doc/howto/urllib2.rst:225
msgid "HTTPError"
msgstr "HTTPError"

#: ../Doc/howto/urllib2.rst:227
#, fuzzy
msgid ""
"Every HTTP response from the server contains a numeric \"status code\". "
"Sometimes the status code indicates that the server is unable to fulfil the "
"request. The default handlers will handle some of these responses for you "
"(for example, if the response is a \"redirection\" that requests the client "
"fetch the document from a different URL, urllib will handle that for you). "
"For those it can't handle, urlopen will raise an :exc:`~urllib.error."
"HTTPError`. Typical errors include '404' (page not found), '403' (request "
"forbidden), and '401' (authentication required)."
msgstr ""
"Cada respuesta HTTP del servidor contiene un \"código de estado\" numérico. "
"A veces el código de estado indica que el servidor es incapaz de satisfacer "
"la petición. Los gestores predeterminados se encargarán de algunas de estas "
"respuestas automáticamente (por ejemplo, si la respuesta es una "
"\"redirección\" que solicita que el cliente obtenga el documento desde una "
"URL diferente, urllib se encargará de eso por ti). Para aquellas respuestas "
"que no puede manejar, urlopen lanzará un :exc:`HTTPError`. Los errores "
"típicos incluyen '404' (página no encontrada), '403' (petición prohibida), y "
"'401' (autenticación requerida)."

#: ../Doc/howto/urllib2.rst:235
msgid ""
"See section 10 of :rfc:`2616` for a reference on all the HTTP error codes."
msgstr ""
"Vea la sección 10 de :rfc:`2616` para una referencia sobre todos los códigos "
"de error HTTP."

#: ../Doc/howto/urllib2.rst:237
#, fuzzy
msgid ""
"The :exc:`~urllib.error.HTTPError` instance raised will have an integer "
"'code' attribute, which corresponds to the error sent by the server."
msgstr ""
"La instancia :exc:`HTTPError` generada tendrá un atributo de 'código' "
"numérico de tipo entero, que corresponde al error enviado por el servidor."

#: ../Doc/howto/urllib2.rst:241
msgid "Error Codes"
msgstr "Códigos de error"

#: ../Doc/howto/urllib2.rst:243
msgid ""
"Because the default handlers handle redirects (codes in the 300 range), and "
"codes in the 100--299 range indicate success, you will usually only see "
"error codes in the 400--599 range."
msgstr ""
"Debido a que los gestores por defecto gestionan redirecciones (códigos en el "
"rango de 300), y que los códigos en el rango de 100--299 indican éxito, "
"normalmente sólo verás códigos de error en el rango de 400--599."

#: ../Doc/howto/urllib2.rst:247
msgid ""
":attr:`http.server.BaseHTTPRequestHandler.responses` is a useful dictionary "
"of response codes in that shows all the response codes used by :rfc:`2616`. "
"The dictionary is reproduced here for convenience ::"
msgstr ""
":attr:`http.server.BaseHTTPRequestHandler.responses` es un diccionario útil "
"de códigos de respuesta en el que se muestran todos los códigos de respuesta "
"utilizados por :rfc:`2616`. El diccionario se reproduce aquí por "
"conveniencia ::"

#: ../Doc/howto/urllib2.rst:319
#, fuzzy
msgid ""
"When an error is raised the server responds by returning an HTTP error code "
"*and* an error page. You can use the :exc:`~urllib.error.HTTPError` instance "
"as a response on the page returned. This means that as well as the code "
"attribute, it also has read, geturl, and info, methods as returned by the "
"``urllib.response`` module::"
msgstr ""
"Cuando se genera un error, el servidor responde retornando un código de "
"error HTTP *y* una página de error. Puedes usar la instancia :exc:"
"`HTTPError` como respuesta en la página retornada. Esto significa que además "
"del atributo de código, también tiene los métodos read, geturl, e info, tal "
"y como son retornados por el módulo ``urllib.response``::"

#: ../Doc/howto/urllib2.rst:339
msgid "Wrapping it Up"
msgstr "Resumiéndolo"

#: ../Doc/howto/urllib2.rst:341
#, fuzzy
msgid ""
"So if you want to be prepared for :exc:`~urllib.error.HTTPError` *or* :exc:"
"`~urllib.error.URLError` there are two basic approaches. I prefer the second "
"approach."
msgstr ""
"Si quieres estar preparado para :exc:`HTTPError` *o* :exc:`URLError` hay dos "
"enfoques básicos. Prefiero el segundo enfoque."

#: ../Doc/howto/urllib2.rst:345
msgid "Number 1"
msgstr "Número 1"

#: ../Doc/howto/urllib2.rst:367
#, fuzzy
msgid ""
"The ``except HTTPError`` *must* come first, otherwise ``except URLError`` "
"will *also* catch an :exc:`~urllib.error.HTTPError`."
msgstr ""
"El error ``except HTTPError`` *debe* ser lo primero en venir, de lo "
"contrario el ``except URLError`` *también* capturará un :exc:`HTTPError`."

#: ../Doc/howto/urllib2.rst:371
msgid "Number 2"
msgstr "Número 2"

#: ../Doc/howto/urllib2.rst:392
msgid "info and geturl"
msgstr "info y geturl"

#: ../Doc/howto/urllib2.rst:394
#, fuzzy
msgid ""
"The response returned by urlopen (or the :exc:`~urllib.error.HTTPError` "
"instance) has two useful methods :meth:`info` and :meth:`geturl` and is "
"defined in the module :mod:`urllib.response`.."
msgstr ""
"La respuesta retornada por urlopen (o la instancia de :exc:`HTTPError`) "
"tiene dos métodos útiles :meth:`info` y :meth:`geturl` y está definida en el "
"módulo :mod:`urllib.response`.."

#: ../Doc/howto/urllib2.rst:398
msgid ""
"**geturl** - this returns the real URL of the page fetched. This is useful "
"because ``urlopen`` (or the opener object used) may have followed a "
"redirect. The URL of the page fetched may not be the same as the URL "
"requested."
msgstr ""
"**geturl** - retorna la verdadera URL de la página obtenida. Esto es útil "
"porque ``urlopen`` (o el objeto de apertura utilizado) puede haber seguido "
"una redirección. El URL de la página obtenida puede no ser el mismo que el "
"URL solicitado."

#: ../Doc/howto/urllib2.rst:402
msgid ""
"**info** - this returns a dictionary-like object that describes the page "
"fetched, particularly the headers sent by the server. It is currently an :"
"class:`http.client.HTTPMessage` instance."
msgstr ""
"**info** - retorna un objeto parecido a un diccionario que describe la "
"página consultada, particularmente los encabezados enviados por el servidor. "
"Actualmente es una instancia :class:`http.client.HTTPMessage`."

#: ../Doc/howto/urllib2.rst:406
msgid ""
"Typical headers include 'Content-length', 'Content-type', and so on. See the "
"`Quick Reference to HTTP Headers <https://jkorpela.fi/http.html>`_ for a "
"useful listing of HTTP headers with brief explanations of their meaning and "
"use."
msgstr ""
"Los encabezados típicos incluyen 'Content-length', 'Content-type' y así "
"sucesivamente. Mira la `Quick Reference to HTTP Headers <https://jkorpela.fi/"
"http.html>`_ para un listado útil de encabezados de HTTP con breves "
"explicaciones de su significado y uso."

#: ../Doc/howto/urllib2.rst:413
msgid "Openers and Handlers"
msgstr "Objetos de Apertura (Openers) y Gestores (Handlers)"

#: ../Doc/howto/urllib2.rst:415
msgid ""
"When you fetch a URL you use an opener (an instance of the perhaps "
"confusingly named :class:`urllib.request.OpenerDirector`). Normally we have "
"been using the default opener - via ``urlopen`` - but you can create custom "
"openers. Openers use handlers. All the \"heavy lifting\" is done by the "
"handlers. Each handler knows how to open URLs for a particular URL scheme "
"(http, ftp, etc.), or how to handle an aspect of URL opening, for example "
"HTTP redirections or HTTP cookies."
msgstr ""
"Cuando obtienes una URL utilizas una apertura (una instancia de la quizás "
"confusamente llamada :class:`urllib.request.OpenerDirector`). Normalmente "
"hemos estado usando la apertura por defecto - a través de ``urlopen`` - pero "
"puedes crear aperturas personalizadas. Las aperturas utilizan manejadores. "
"Todo el \"trabajo pesado\" lo hacen los manejadores. Cada manejador sabe "
"cómo abrir URLs para un esquema de URL particular (http, ftp, etc.), o cómo "
"manejar un aspecto de la apertura de URLs, por ejemplo redirecciones HTTP o "
"cookies HTTP."

#: ../Doc/howto/urllib2.rst:423
msgid ""
"You will want to create openers if you want to fetch URLs with specific "
"handlers installed, for example to get an opener that handles cookies, or to "
"get an opener that does not handle redirections."
msgstr ""
"Desearás crear objetos de apertura si deseas consultar URLs con gestores "
"específicos instalados, por ejemplo para obtener un objeto de apertura que "
"gestione cookies, o para obtener un objeto de apertura que no gestione "
"redireccionamientos."

#: ../Doc/howto/urllib2.rst:427
msgid ""
"To create an opener, instantiate an ``OpenerDirector``, and then call ``."
"add_handler(some_handler_instance)`` repeatedly."
msgstr ""
"Para crear un objeto de apertura, debes instanciar un ``OpenerDirector``, y "
"luego llamar ``.add_handler(some_handler_instance)`` repetidamente."

#: ../Doc/howto/urllib2.rst:430
msgid ""
"Alternatively, you can use ``build_opener``, which is a convenience function "
"for creating opener objects with a single function call.  ``build_opener`` "
"adds several handlers by default, but provides a quick way to add more and/"
"or override the default handlers."
msgstr ""
"Alternativamente, puedes usar ``build_opener``, que es una función "
"conveniente para crear objetos de apertura con una sola llamada a la "
"función.  ``build_opener`` añade varios gestores por defecto, pero "
"proporciona una forma rápida de añadir más y/o sobrescribir los gestores por "
"defecto."

#: ../Doc/howto/urllib2.rst:435
msgid ""
"Other sorts of handlers you might want to can handle proxies, "
"authentication, and other common but slightly specialised situations."
msgstr ""
"Otros tipos de gestores que puedes querer permiten manejar proxies, "
"autenticación, y otras situaciones comunes pero ligeramente especializadas."

#: ../Doc/howto/urllib2.rst:438
msgid ""
"``install_opener`` can be used to make an ``opener`` object the (global) "
"default opener. This means that calls to ``urlopen`` will use the opener you "
"have installed."
msgstr ""
"``install_opener`` puede ser usado para hacer que un objeto ``opener`` sea "
"el objeto de apertura (global) por defecto. Esto significa que las llamadas "
"a ``urlopen`` usarán el objeto de apertura que has instalado."

#: ../Doc/howto/urllib2.rst:442
msgid ""
"Opener objects have an ``open`` method, which can be called directly to "
"fetch urls in the same way as the ``urlopen`` function: there's no need to "
"call ``install_opener``, except as a convenience."
msgstr ""
"Los objetos de apertura tienen un método ``open``, que puede ser llamado "
"directamente para consultar urls de la misma manera que la función "
"\"urlopen\": no hay necesidad de llamar ``install_opener``, excepto por "
"conveniencia."

#: ../Doc/howto/urllib2.rst:448
msgid "Basic Authentication"
msgstr "Autenticación básica"

#: ../Doc/howto/urllib2.rst:450
#, fuzzy
msgid ""
"To illustrate creating and installing a handler we will use the "
"``HTTPBasicAuthHandler``. For a more detailed discussion of this subject -- "
"including an explanation of how Basic Authentication works - see the `Basic "
"Authentication Tutorial <https://web.archive.org/web/20201215133350/http://"
"www.voidspace.org.uk/python/articles/authentication.shtml>`__."
msgstr ""
"Para ilustrar la creación e instalación de un gestor usaremos "
"``HTTPBasicAuthHandler``. Para una discusión más detallada de este tema -- "
"incluyendo una explicación de cómo funciona la Autenticación Básica - ver "
"`Basic Authentication Tutorial <http://www.voidspace.org.uk/python/articles/"
"authentication.shtml>`_."

#: ../Doc/howto/urllib2.rst:456
msgid ""
"When authentication is required, the server sends a header (as well as the "
"401 error code) requesting authentication.  This specifies the "
"authentication scheme and a 'realm'. The header looks like: ``WWW-"
"Authenticate: SCHEME realm=\"REALM\"``."
msgstr ""
"Cuando se requiere la autenticación, el servidor envía un encabezado (así "
"como el código de error 401) solicitando la autenticación.  Esto especifica "
"el esquema de autenticación y un 'realm'. El encabezado tiene el siguiente "
"aspecto: ``WWW-Authenticate: SCHEME realm=\"REALM\"``."

#: ../Doc/howto/urllib2.rst:461
msgid "e.g."
msgstr "por ejemplo."

#: ../Doc/howto/urllib2.rst:468
msgid ""
"The client should then retry the request with the appropriate name and "
"password for the realm included as a header in the request. This is 'basic "
"authentication'. In order to simplify this process we can create an instance "
"of ``HTTPBasicAuthHandler`` and an opener to use this handler."
msgstr ""
"El cliente debe entonces volver a intentar la solicitud con el nombre y la "
"contraseña apropiados para el realm incluido como encabezamiento en la "
"solicitud. Esto es 'autenticación básica'. Para simplificar este proceso "
"podemos crear una instancia de ``HTTPBasicAuthHandler`` y un objeto de "
"apertura para usar este manejador."

#: ../Doc/howto/urllib2.rst:473
msgid ""
"The ``HTTPBasicAuthHandler`` uses an object called a password manager to "
"handle the mapping of URLs and realms to passwords and usernames. If you "
"know what the realm is (from the authentication header sent by the server), "
"then you can use a ``HTTPPasswordMgr``. Frequently one doesn't care what the "
"realm is. In that case, it is convenient to use "
"``HTTPPasswordMgrWithDefaultRealm``. This allows you to specify a default "
"username and password for a URL. This will be supplied in the absence of you "
"providing an alternative combination for a specific realm. We indicate this "
"by providing ``None`` as the realm argument to the ``add_password`` method."
msgstr ""
"El ``HTTPBasicAuthHandler`` utiliza un objeto llamado administrador de "
"contraseñas para gestionar el mapeo de URLs y realms con contraseñas y "
"nombres de usuario. Si sabes cuál es el realm (por el encabezado de "
"autenticación enviado por el servidor), entonces puedes usar un "
"``HTTPPasswordMgr``. Frecuentemente a uno no le importa cuál es el realm. En "
"ese caso, es conveniente usar \"HTTPPasswordMgrWithDefaultRealm\". Esto te "
"permite especificar un nombre de usuario y una contraseña por defecto para "
"una URL. Esto será suministrado en caso de que no proporciones una "
"combinación alternativa para un realm específico. Lo indicamos "
"proporcionando ``None`` como el argumento del realm al método "
"``add_password``."

#: ../Doc/howto/urllib2.rst:483
msgid ""
"The top-level URL is the first URL that requires authentication. URLs "
"\"deeper\" than the URL you pass to .add_password() will also match. ::"
msgstr ""
"La URL de primer nivel es la primera URL que requiere autenticación. Las "
"URLs \"más profundas\" que la URL que pasas a .add_password() también "
"coincidirán. ::"

#: ../Doc/howto/urllib2.rst:508
msgid ""
"In the above example we only supplied our ``HTTPBasicAuthHandler`` to "
"``build_opener``. By default openers have the handlers for normal situations "
"-- ``ProxyHandler`` (if a proxy setting such as an :envvar:`http_proxy` "
"environment variable is set), ``UnknownHandler``, ``HTTPHandler``, "
"``HTTPDefaultErrorHandler``, ``HTTPRedirectHandler``, ``FTPHandler``, "
"``FileHandler``, ``DataHandler``, ``HTTPErrorProcessor``."
msgstr ""
"En el ejemplo anterior sólo suministramos nuestro ``HTTPBasicAuthHandler`` a "
"``build_opener``. Por defecto, los objetos de apertura tienen los gestores "
"para situaciones normales -- ``ProxyHandler`` (si un ajuste de proxy tal "
"como una variable de entorno :envvar:`http_proxy` está establecida), "
"``UnknownHandler``, ``HTTPHandler``, ``HTTPDefaultErrorHandler``, "
"``HTTPRedirectHandler``, ``FTPHandler``, ``FileHandler``, ``DataHandler``, "
"``HTTPErrorProcessor``."

#: ../Doc/howto/urllib2.rst:515
msgid ""
"``top_level_url`` is in fact *either* a full URL (including the 'http:' "
"scheme component and the hostname and optionally the port number) e.g. "
"``\"http://example.com/\"`` *or* an \"authority\" (i.e. the hostname, "
"optionally including the port number) e.g. ``\"example.com\"`` or "
"``\"example.com:8080\"`` (the latter example includes a port number).  The "
"authority, if present, must NOT contain the \"userinfo\" component - for "
"example ``\"joe:password@example.com\"`` is not correct."
msgstr ""
"``top_level_url`` es de hecho *o* una URL completa (incluyendo el componente "
"del esquema 'http:' y el nombre del host y opcionalmente el número de "
"puerto) p.ej. ``\"http://example.com/\"`` *o* una \"autoridad\" (esto es, el "
"nombre del host, incluyendo opcionalmente el número de puerto) por ejemplo "
"``\"example.com\"`` o ``\"example.com:8080\"`` (este último ejemplo incluye "
"un número de puerto).  La autoridad, si está presente, NO debe contener el "
"componente \"userinfo\" - por ejemplo ``\"joe:password@example.com\"`` no es "
"correcto."

#: ../Doc/howto/urllib2.rst:525
msgid "Proxies"
msgstr "Proxies"

#: ../Doc/howto/urllib2.rst:527
msgid ""
"**urllib** will auto-detect your proxy settings and use those. This is "
"through the ``ProxyHandler``, which is part of the normal handler chain when "
"a proxy setting is detected.  Normally that's a good thing, but there are "
"occasions when it may not be helpful [#]_. One way to do this is to setup "
"our own ``ProxyHandler``, with no proxies defined. This is done using "
"similar steps to setting up a `Basic Authentication`_ handler: ::"
msgstr ""
"**urllib** detectará automáticamente tu configuración de proxy y la "
"utilizará. Esto es a través de ``ProxyHandler``, que es parte de la cadena "
"de gestores normales cuando se detecta un ajuste de proxy.  Normalmente esto "
"es algo bueno, pero hay ocasiones en las que puede no ser útil [#]_. Una "
"forma de hacerlo es configurar nuestro propio ``ProxyHandler``, sin proxies "
"definidos. Esto se hace usando pasos similares a la configuración de un "
"gestor `Basic Authentication`_: ::"

#: ../Doc/howto/urllib2.rst:540
msgid ""
"Currently ``urllib.request`` *does not* support fetching of ``https`` "
"locations through a proxy.  However, this can be enabled by extending urllib."
"request as shown in the recipe [#]_."
msgstr ""
"Actualmente ``urllib.request`` *no* soporta la consulta de ubicaciones "
"``https`` a través de un proxy.  Sin embargo, esto puede ser habilitado "
"extendiendo urllib.request como se muestra en la receta [#]_."

#: ../Doc/howto/urllib2.rst:546
msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; see "
"the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"``HTTP_PROXY`` será ignorado si se establece una variable "
"``REQUEST_METHOD``; ver la documentación en :func:`~urllib.request."
"getproxies``."

#: ../Doc/howto/urllib2.rst:551
msgid "Sockets and Layers"
msgstr "Sockets y capas"

#: ../Doc/howto/urllib2.rst:553
msgid ""
"The Python support for fetching resources from the web is layered.  urllib "
"uses the :mod:`http.client` library, which in turn uses the socket library."
msgstr ""
"El soporte de Python para obtener recursos de la web funciona en capas. "
"urllib utiliza la biblioteca :mod:`http.client`, que a su vez utiliza la "
"biblioteca de sockets."

#: ../Doc/howto/urllib2.rst:556
msgid ""
"As of Python 2.3 you can specify how long a socket should wait for a "
"response before timing out. This can be useful in applications which have to "
"fetch web pages. By default the socket module has *no timeout* and can hang. "
"Currently, the socket timeout is not exposed at the http.client or urllib."
"request levels. However, you can set the default timeout globally for all "
"sockets using ::"
msgstr ""
"A partir de Python 2.3 se puede especificar cuánto tiempo debe esperar un "
"socket para obtener una respuesta antes de que se agote el tiempo de espera. "
"Esto puede ser útil en aplicaciones que tienen que consultar páginas web. "
"Por defecto, el módulo socket no tiene *tiempo de espera* y puede colgarse. "
"Actualmente, el tiempo de espera de la conexión no se expone en los niveles "
"http.client o urllib.request. Sin embargo, puede establecerse el tiempo de "
"espera por defecto de forma global para todas los sockets usando ::"

#: ../Doc/howto/urllib2.rst:579
msgid "Footnotes"
msgstr "Notas a pie de página"

#: ../Doc/howto/urllib2.rst:581
msgid "This document was reviewed and revised by John Lee."
msgstr "Este documento fue examinado y revisado por John Lee."

#: ../Doc/howto/urllib2.rst:583
msgid "Google for example."
msgstr "Google por ejemplo."

#: ../Doc/howto/urllib2.rst:584
msgid ""
"Browser sniffing is a very bad practice for website design - building sites "
"using web standards is much more sensible. Unfortunately a lot of sites "
"still send different versions to different browsers."
msgstr ""
"El rastreo de navegadores es una práctica muy mala para el diseño de sitios "
"web - construir sitios usando estándares web es mucho más sensato. "
"Desafortunadamente muchos sitios siguen enviando versiones diferentes a "
"diferentes navegadores."

#: ../Doc/howto/urllib2.rst:587
msgid ""
"The user agent for MSIE 6 is *'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT "
"5.1; SV1; .NET CLR 1.1.4322)'*"
msgstr ""
"El agente de usuario para MSIE 6 es *'Mozilla/4.0 (compatible; MSIE 6.0; "
"Windows NT 5.1; SV1; .NET CLR 1.1.4322)'*"

#: ../Doc/howto/urllib2.rst:589
msgid ""
"For details of more HTTP request headers, see `Quick Reference to HTTP "
"Headers`_."
msgstr ""
"Para detalles de más encabezados de peticiones HTTP, ver `Quick Reference to "
"HTTP Headers`_."

#: ../Doc/howto/urllib2.rst:591
msgid ""
"In my case I have to use a proxy to access the internet at work. If you "
"attempt to fetch *localhost* URLs through this proxy it blocks them. IE is "
"set to use the proxy, which urllib picks up on. In order to test scripts "
"with a localhost server, I have to prevent urllib from using the proxy."
msgstr ""
"En mi caso tengo que usar un proxy para acceder a internet en el trabajo. Si "
"intentas consultar URLs de *localhost* a través de este proxy, las bloquea. "
"IE está configurado para usar el proxy, que urllib recoge. Para poder probar "
"los scripts con un servidor localhost, tengo que evitar que urllib use el "
"proxy."

#: ../Doc/howto/urllib2.rst:596
msgid ""
"urllib opener for SSL proxy (CONNECT method): `ASPN Cookbook Recipe <https://"
"code.activestate.com/recipes/456195/>`_."
msgstr ""
"objeto de apertura de urllib para proxy SSL (método CONNECT): `ASPN Cookbook "
"Recipe <https://code.activestate.com/recipes/456195/>`_."

#~ msgid ""
#~ "There is a French translation of an earlier revision of this HOWTO, "
#~ "available at `urllib2 - Le Manuel manquant <https://web.archive.org/"
#~ "web/20200910051922/http://www.voidspace.org.uk/python/articles/"
#~ "urllib2_francais.shtml>`_."
#~ msgstr ""
#~ "Hay una traducción al francés de una revisión anterior de este HOWTO, "
#~ "disponible en `urllib2 - Le Manuel manquant <https://web.archive.org/"
#~ "web/20200910051922/http://www.voidspace.org.uk/python/articles/"
#~ "urllib2_francais.shtml>`_."
