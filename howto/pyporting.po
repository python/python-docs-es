# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-12 19:43+0200\n"
"PO-Revision-Date: 2024-01-31 09:58+0100\n"
"Last-Translator: Cristián Maureira-Fredes <cmaureirafredes@gmail.com>\n"
"Language-Team: python-doc-es\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.13.0\n"
"X-Generator: Poedit 3.4.2\n"

#: ../Doc/howto/pyporting.rst:5
#, fuzzy
msgid "How to port Python 2 Code to Python 3"
msgstr "Portando código de Python 2 a Python 3"

#: ../Doc/howto/pyporting.rst
msgid "author"
msgstr "autor"

#: ../Doc/howto/pyporting.rst:7
msgid "Brett Cannon"
msgstr "Brett Cannon"

msgid "Abstract"
msgstr "Resumen"

#: ../Doc/howto/pyporting.rst:11
msgid ""
"Python 2 reached its official end-of-life at the start of 2020. This means "
"that no new bug reports, fixes, or changes will be made to Python 2 - it's "
"no longer supported."
msgstr ""

#: ../Doc/howto/pyporting.rst:15
msgid ""
"This guide is intended to provide you with a path to Python 3 for your code, "
"that includes compatibility with Python 2 as a first step."
msgstr ""

#: ../Doc/howto/pyporting.rst:18
msgid ""
"If you are looking to port an extension module instead of pure Python code, "
"please see :ref:`cporting-howto`."
msgstr ""
"Si está buscando portar un módulo de extensión en lugar de código Python "
"puro, consulte :ref:`cporting-howto`."

#: ../Doc/howto/pyporting.rst:21
msgid ""
"The archived python-porting_ mailing list may contain some useful guidance."
msgstr ""

#: ../Doc/howto/pyporting.rst:25
msgid "The Short Explanation"
msgstr "La breve explicación"

#: ../Doc/howto/pyporting.rst:27
#, fuzzy
msgid ""
"To achieve Python 2/3 compatibility in a single code base, the basic steps "
"are:"
msgstr ""
"Para que su proyecto sea compatible con Python 2/3 de una sola fuente, los "
"pasos básicos son:"

#: ../Doc/howto/pyporting.rst:30
msgid "Only worry about supporting Python 2.7"
msgstr "Sólo preocúpate por admitir Python 2.7"

#: ../Doc/howto/pyporting.rst:31
msgid ""
"Make sure you have good test coverage (coverage.py_ can help; ``python -m "
"pip install coverage``)"
msgstr ""
"Asegúrese de tener una buena cobertura de prueba (coberturas.py_ puede "
"ayudar; ``python -m pip install coverage``)"

#: ../Doc/howto/pyporting.rst:33
#, fuzzy
msgid "Learn the differences between Python 2 and 3"
msgstr "Aprende las diferencias entre Python 2 & 3"

#: ../Doc/howto/pyporting.rst:34
msgid ""
"Use Futurize_ (or Modernize_) to update your code (e.g. ``python -m pip "
"install future``)"
msgstr ""
"Utilice Futurize_ (o Modernize_) para actualizar su código (por ejemplo, "
"``python -m pip install future``)"

#: ../Doc/howto/pyporting.rst:35
msgid ""
"Use Pylint_ to help make sure you don't regress on your Python 3 support "
"(``python -m pip install pylint``)"
msgstr ""
"Use Pylint_ para asegurarse de que no retrocede en su compatibilidad con "
"Python 3 (``python -m pip install pylint``)"

#: ../Doc/howto/pyporting.rst:37
msgid ""
"Use caniusepython3_ to find out which of your dependencies are blocking your "
"use of Python 3 (``python -m pip install caniusepython3``)"
msgstr ""
"Use caniusepython3_ para averiguar cuáles de sus dependencias están "
"bloqueando el uso de Python 3 (``python -m pip install caniusepython3``)"

#: ../Doc/howto/pyporting.rst:39
#, fuzzy
msgid ""
"Once your dependencies are no longer blocking you, use continuous "
"integration to make sure you stay compatible with Python 2 and 3 (tox_ can "
"help test against multiple versions of Python; ``python -m pip install tox``)"
msgstr ""
"Una vez que sus dependencias ya no lo bloqueen, use la integración continua "
"para asegurarse de que sigue siendo compatible con Python 2 y 3 (tox_ puede "
"ayudar a probar contra múltiples versiones de Python; ``python -m pip "
"install tox``)"

#: ../Doc/howto/pyporting.rst:42
#, fuzzy
msgid ""
"Consider using optional static type checking to make sure your type usage "
"works in both Python 2 and 3 (e.g. use mypy_ to check your typing under both "
"Python 2 and Python 3; ``python -m pip install mypy``)."
msgstr ""
"Considere usar la verificación de tipo estática opcional para asegurarse de "
"que su uso de tipo funcione tanto en Python 2 como en 3 (por ejemplo, use "
"mypy_ para verificar su escritura en Python 2 y Python 3; ``python -m pip "
"install mypy``)."

#: ../Doc/howto/pyporting.rst:48
msgid ""
"Note: Using ``python -m pip install`` guarantees that the ``pip`` you invoke "
"is the one installed for the Python currently in use, whether it be a system-"
"wide ``pip`` or one installed within a :ref:`virtual environment <tut-venv>`."
msgstr ""
"Nota: El uso de ``python -m pip install`` garantiza que el ``pip`` que "
"invoca es el que está instalado para el Python actualmente en uso, ya sea un "
"``pip`` de todo el sistema o uno instalado dentro de un :ref:`entorno "
"virtual <tut-venv>`."

#: ../Doc/howto/pyporting.rst:54
msgid "Details"
msgstr "Detalles"

#: ../Doc/howto/pyporting.rst:56
msgid ""
"Even if other factors - say, dependencies over which you have no control - "
"still require you to support Python 2, that does not prevent you taking the "
"step of including Python 3 support."
msgstr ""

#: ../Doc/howto/pyporting.rst:60
msgid ""
"Most changes required to support Python 3 lead to cleaner code using newer "
"practices even in Python 2 code."
msgstr ""

#: ../Doc/howto/pyporting.rst:65
msgid "Different versions of Python 2"
msgstr ""

#: ../Doc/howto/pyporting.rst:67
msgid ""
"Ideally, your code should be compatible with Python 2.7, which was the last "
"supported version of Python 2."
msgstr ""

#: ../Doc/howto/pyporting.rst:70
msgid ""
"Some of the tools mentioned in this guide will not work with Python 2.6."
msgstr ""

#: ../Doc/howto/pyporting.rst:72
#, fuzzy
msgid ""
"If absolutely necessary, the six_ project can help you support Python 2.5 "
"and 3 simultaneously. Do realize, though, that nearly all the projects "
"listed in this guide will not be available to you."
msgstr ""
"Si bien puede hacer que Python 2.5 funcione con Python 3, es **mucho** más "
"fácil si solo tiene que trabajar con Python 2.7. Si eliminar Python 2.5 no "
"es una opción, entonces el proyecto six_ puede ayudarlo a admitir Python 2.5 "
"y 3 simultáneamente (``python -m pip install six``). Sin embargo, tenga en "
"cuenta que casi todos los proyectos enumerados en este COMO no estarán "
"disponibles para usted."

#: ../Doc/howto/pyporting.rst:76
#, fuzzy
msgid ""
"If you are able to skip Python 2.5 and older, the required changes to your "
"code will be minimal. At worst you will have to use a function instead of a "
"method in some instances or have to import a function instead of using a "
"built-in one."
msgstr ""
"Si puede omitir Python 2.5 y versiones anteriores, los cambios necesarios en "
"el código deben seguir pareciendo código Python idiomático. En el peor de "
"los casos tendrá que utilizar una función en lugar de un método en algunos "
"casos o tendrá que importar una función en lugar de usar una integrada, pero "
"de lo contrario la transformación general no debería sentirse ajena a usted."

#: ../Doc/howto/pyporting.rst:83
msgid ""
"Make sure you specify the proper version support in your ``setup.py`` file"
msgstr ""
"Asegúrese de especificar el soporte de versión adecuado en su archivo "
"``setup.py``"

#: ../Doc/howto/pyporting.rst:85
msgid ""
"In your ``setup.py`` file you should have the proper `trove classifier`_ "
"specifying what versions of Python you support. As your project does not "
"support Python 3 yet you should at least have ``Programming Language :: "
"Python :: 2 :: Only`` specified. Ideally you should also specify each major/"
"minor version of Python that you do support, e.g. ``Programming Language :: "
"Python :: 2.7``."
msgstr ""
"En su archivo ``setup.py`` debe tener el `trove classifier`_ adecuado "
"especificando qué versiones de Python admite. Como su proyecto no es "
"compatible con Python 3, al menos debe tener ``Programming Language :: "
"Python :: 2 :: Only`` especificado. Idealmente también debe especificar cada "
"versión principal/menor de Python que admita, por ejemplo, ``Programming "
"Language :: Python :: 2.7``."

#: ../Doc/howto/pyporting.rst:94
msgid "Have good test coverage"
msgstr "Tener una buena cobertura de prueba"

#: ../Doc/howto/pyporting.rst:96
#, python-format
msgid ""
"Once you have your code supporting the oldest version of Python 2 you want "
"it to, you will want to make sure your test suite has good coverage. A good "
"rule of thumb is that if you want to be confident enough in your test suite "
"that any failures that appear after having tools rewrite your code are "
"actual bugs in the tools and not in your code. If you want a number to aim "
"for, try to get over 80% coverage (and don't feel bad if you find it hard to "
"get better than 90% coverage). If you don't already have a tool to measure "
"test coverage then coverage.py_ is recommended."
msgstr ""
"Una vez que tenga su código compatible con la versión más antigua de Python "
"2 que desee, querrá asegurarse de que su conjunto de pruebas tenga una buena "
"cobertura. Una buena regla general es que si desea tener la suficiente "
"confianza en su conjunto de pruebas, cualquier falla que aparezca después de "
"que las herramientas reescriban su código son errores reales en las "
"herramientas y no en su código. Si desea un número al que apuntar, intente "
"obtener una cobertura superior al 80% (y no se sienta mal si le resulta "
"difícil obtener una cobertura superior al 90%). Si aún no tiene una "
"herramienta para medir la cobertura de la prueba, se recomienda cover.py_."

#: ../Doc/howto/pyporting.rst:107
#, fuzzy
msgid "Be aware of the differences between Python 2 and 3"
msgstr "Aprende las diferencias entre Python 2 & 3"

#: ../Doc/howto/pyporting.rst:109
#, fuzzy
msgid ""
"Once you have your code well-tested you are ready to begin porting your code "
"to Python 3! But to fully understand how your code is going to change and "
"what you want to look out for while you code, you will want to learn what "
"changes Python 3 makes in terms of Python 2."
msgstr ""
"Una vez que tenga su código bien probado, ¡está listo para comenzar a migrar "
"su código a Python 3! Pero para comprender completamente cómo va a cambiar "
"el código y qué desea tener en cuenta mientras codifica, querrá aprender qué "
"cambios produce Python 3 en términos de Python 2. Típicamente las dos "
"mejores maneras de hacer eso es leer la documentación :ref:`\"What's New\" "
"<whatsnew-index>` para cada versión de Python 3 y el libro `Porting to "
"Python 3`_ (que es gratis en línea). También hay una práctica `cheat sheet`_ "
"del proyecto Python-Future.</whatsnew-index>."

#: ../Doc/howto/pyporting.rst:114
msgid ""
"Some resources for understanding the differences and their implications for "
"you code:"
msgstr ""

#: ../Doc/howto/pyporting.rst:117
msgid ""
"the :ref:`\"What's New\" <whatsnew-index>` doc for each release of Python 3"
msgstr ""

#: ../Doc/howto/pyporting.rst:118
msgid "the `Porting to Python 3`_ book (which is free online)"
msgstr ""

#: ../Doc/howto/pyporting.rst:119
msgid "the handy `cheat sheet`_ from the Python-Future project."
msgstr ""

#: ../Doc/howto/pyporting.rst:123
msgid "Update your code"
msgstr "Actualiza tu código"

#: ../Doc/howto/pyporting.rst:125
msgid "There are tools available that can port your code automatically."
msgstr ""

#: ../Doc/howto/pyporting.rst:127
msgid ""
"Futurize_ does its best to make Python 3 idioms and practices exist in "
"Python 2, e.g. backporting the ``bytes`` type from Python 3 so that you have "
"semantic parity between the major versions of Python. This is the better "
"approach for most cases."
msgstr ""

#: ../Doc/howto/pyporting.rst:132
msgid ""
"Modernize_, on the other hand, is more conservative and targets a Python 2/3 "
"subset of Python, directly relying on six_ to help provide compatibility."
msgstr ""

#: ../Doc/howto/pyporting.rst:135
#, fuzzy
msgid ""
"A good approach is to run the tool over your test suite first and visually "
"inspect the diff to make sure the transformation is accurate. After you have "
"transformed your test suite and verified that all the tests still pass as "
"expected, then you can transform your application code knowing that any "
"tests which fail is a translation failure."
msgstr ""
"Independientemente de la herramienta que elija, actualizarán el código para "
"que se ejecute en Python 3 mientras se mantienen compatibles con la versión "
"de Python 2 con la que comenzó. Dependiendo de lo conservador que desee ser, "
"es posible que desee ejecutar la herramienta sobre el conjunto de pruebas "
"primero e inspeccionar visualmente la diferencia para asegurarse de que la "
"transformación es precisa. Después de transformar el conjunto de pruebas y "
"comprobar que todas las pruebas siguen pasando según lo esperado, puede "
"transformar el código de la aplicación sabiendo que cualquier prueba que "
"falle es un error de traducción."

#: ../Doc/howto/pyporting.rst:141
msgid ""
"Unfortunately the tools can't automate everything to make your code work "
"under Python 3, and you will also need to read the tools' documentation in "
"case some options you need are turned off by default."
msgstr ""

#: ../Doc/howto/pyporting.rst:145
msgid "Key issues to be aware of and check for:"
msgstr ""

#: ../Doc/howto/pyporting.rst:148
msgid "Division"
msgstr "División"

#: ../Doc/howto/pyporting.rst:150
#, fuzzy
msgid ""
"In Python 3, ``5 / 2 == 2.5`` and not ``2`` as it was in Python 2; all "
"division between ``int`` values result in a ``float``. This change has "
"actually been planned since Python 2.2 which was released in 2002. Since "
"then users have been encouraged to add ``from __future__ import division`` "
"to any and all files which use the ``/`` and ``//`` operators or to be "
"running the interpreter with the ``-Q`` flag. If you have not been doing "
"this then you will need to go through your code and do two things:"
msgstr ""
"En Python 3, ``5 / 2 == 2.5`` y no ``2``; toda división entre los valores "
"``int`` da lugar a un ``float``. Este cambio ha sido planeado desde Python "
"2.2, que fue lanzado en 2002. Desde entonces, se ha alentado a los usuarios "
"a añadir ``from __future__ import division`` a todos y cada uno de los "
"archivos que utilizan los operadores ``/`` y ``//`` o que ejecuten el "
"intérprete con el indicador ``-Q``. Si no ha estado haciendo esto, entonces "
"tendrá que ir a través de su código y hacer dos cosas:"

#: ../Doc/howto/pyporting.rst:158
msgid "Add ``from __future__ import division`` to your files"
msgstr "Añadir ``from __future__ import division`` a sus archivos"

#: ../Doc/howto/pyporting.rst:159
msgid ""
"Update any division operator as necessary to either use ``//`` to use floor "
"division or continue using ``/`` and expect a float"
msgstr ""
"Actualice cualquier operador de división según sea necesario para utilizar "
"``//`` para usar la división entera a la baja o continuar usando ``/`` y "
"esperar un número flotante"

#: ../Doc/howto/pyporting.rst:162
msgid ""
"The reason that ``/`` isn't simply translated to ``//`` automatically is "
"that if an object defines a ``__truediv__`` method but not ``__floordiv__`` "
"then your code would begin to fail (e.g. a user-defined class that uses ``/"
"`` to signify some operation but not ``//`` for the same thing or at all)."
msgstr ""
"La razón por la que ``/`` no se traduce simplemente a ``//`` automáticamente "
"es que si un objeto define un método ``__truediv__`` pero no "
"``__floordiv__`` entonces su código comenzaría a fallar (por ejemplo, una "
"clase definida por el usuario que utiliza ``/`` para significar alguna "
"operación pero no ``//`` para la misma cosa o en absoluto)."

#: ../Doc/howto/pyporting.rst:169
msgid "Text versus binary data"
msgstr "Texto frente a datos binarios"

#: ../Doc/howto/pyporting.rst:171
msgid ""
"In Python 2 you could use the ``str`` type for both text and binary data. "
"Unfortunately this confluence of two different concepts could lead to "
"brittle code which sometimes worked for either kind of data, sometimes not. "
"It also could lead to confusing APIs if people didn't explicitly state that "
"something that accepted ``str`` accepted either text or binary data instead "
"of one specific type. This complicated the situation especially for anyone "
"supporting multiple languages as APIs wouldn't bother explicitly supporting "
"``unicode`` when they claimed text data support."
msgstr ""
"En Python 2 puede usar el tipo ``str`` tanto para texto como para datos "
"binarios. Desafortunadamente, esta confluencia de dos conceptos diferentes "
"podría conducir a código frágil que a veces funcionaba para cualquier tipo "
"de datos, a veces no. También podría dar lugar a API confusas si las "
"personas no declaraban explícitamente que algo que aceptaba ``str`` aceptaba "
"datos binarios o de texto en lugar de un tipo específico. Esto complicó la "
"situación especialmente para cualquier persona que admita varios idiomas, ya "
"que las API no se molestarían explícitamente en admitir explícitamente "
"``Unicode`` cuando reclamaban compatibilidad con datos de texto."

#: ../Doc/howto/pyporting.rst:180
#, fuzzy
msgid ""
"Python 3 made text and binary data distinct types that cannot simply be "
"mixed together. For any code that deals only with text or only binary data, "
"this separation doesn't pose an issue. But for code that has to deal with "
"both, it does mean you might have to now care about when you are using text "
"compared to binary data, which is why this cannot be entirely automated."
msgstr ""
"Para hacer la distinción entre texto y datos binarios más claros y "
"pronunciados, Python 3 hizo lo que la mayoría de los lenguajes creados en la "
"era de Internet han hecho y ha hecho texto y datos binarios distintos tipos "
"que no se pueden mezclar ciegamente (Python es anterior al acceso "
"generalizado a Internet). Para cualquier código que se ocupe solo de texto o "
"solo de datos binarios, esta separación no plantea un problema. Pero para el "
"código que tiene que lidiar con ambos, significa que es posible que tenga "
"que preocuparse ahora cuando está utilizando texto en comparación con los "
"datos binarios, por lo que esto no se puede automatizar por completo."

#: ../Doc/howto/pyporting.rst:186
#, fuzzy
msgid ""
"Decide which APIs take text and which take binary (it is **highly** "
"recommended you don't design APIs that can take both due to the difficulty "
"of keeping the code working; as stated earlier it is difficult to do well). "
"In Python 2 this means making sure the APIs that take text can work with "
"``unicode`` and those that work with binary data work with the ``bytes`` "
"type from Python 3 (which is a subset of ``str`` in Python 2 and acts as an "
"alias for ``bytes`` type in Python 2). Usually the biggest issue is "
"realizing which methods exist on which types in Python 2 and 3 "
"simultaneously (for text that's ``unicode`` in Python 2 and ``str`` in "
"Python 3, for binary that's ``str``/``bytes`` in Python 2 and ``bytes`` in "
"Python 3)."
msgstr ""
"Para empezar, tendrá que decidir qué API toman texto y cuáles toman binario "
"(es **altamente** recomendado no diseñar API que pueden tomar ambos debido a "
"la dificultad de mantener el código funcionando; como se indicó "
"anteriormente es difícil hacerlo bien). En Python 2 esto significa "
"asegurarse de que las API que toman texto pueden trabajar con ``unicode`` y "
"las que funcionan con datos binarios funcionan con el tipo ``bytes`` de "
"Python 3 (que es un subconjunto de ``str`` en Python 2 y actúa como un alias "
"para ``bytes`` tipo en Python 2). Por lo general, el mayor problema es darse "
"cuenta de qué métodos existen en qué tipos en Python 2 y 3 simultáneamente "
"(para el texto que es ``Unicode`` en Python 2 y ``str`` en Python 3, para "
"binario que es ``str``/``bytes`` en Python 2 y ``bytes`` en Python 3). En la "
"tabla siguiente se enumeran los métodos **unicos** de cada tipo de datos en "
"Python 2 y 3 (por ejemplo, el método ``decode()`` se puede utilizar en el "
"tipo de datos binarios equivalente en Python 2 o 3, pero no puede ser "
"utilizado por el tipo de datos textuales consistentemente entre Python 2 y 3 "
"porque ``str`` en Python 3 no tiene el método). Tenga en cuenta que a partir "
"de Python 3.5 se agregó el método ``__mod__`` al tipo bytes."

#: ../Doc/howto/pyporting.rst:197
msgid ""
"The following table lists the **unique** methods of each data type across "
"Python 2 and 3 (e.g., the ``decode()`` method is usable on the equivalent "
"binary data type in either Python 2 or 3, but it can't be used by the "
"textual data type consistently between Python 2 and 3 because ``str`` in "
"Python 3 doesn't have the method). Do note that as of Python 3.5 the "
"``__mod__`` method was added to the bytes type."
msgstr ""

#: ../Doc/howto/pyporting.rst:205
msgid "**Text data**"
msgstr "**Datos de texto**"

#: ../Doc/howto/pyporting.rst:205
msgid "**Binary data**"
msgstr "**Datos binarios**"

#: ../Doc/howto/pyporting.rst:207
msgid "\\"
msgstr "\\"

#: ../Doc/howto/pyporting.rst:207
msgid "decode"
msgstr "decode"

#: ../Doc/howto/pyporting.rst:209
msgid "encode"
msgstr "encode"

#: ../Doc/howto/pyporting.rst:211
msgid "format"
msgstr "format"

#: ../Doc/howto/pyporting.rst:213
msgid "isdecimal"
msgstr "isdecimal"

#: ../Doc/howto/pyporting.rst:215
msgid "isnumeric"
msgstr "isnumeric"

#: ../Doc/howto/pyporting.rst:218
msgid ""
"Making the distinction easier to handle can be accomplished by encoding and "
"decoding between binary data and text at the edge of your code. This means "
"that when you receive text in binary data, you should immediately decode it. "
"And if your code needs to send text as binary data then encode it as late as "
"possible. This allows your code to work with only text internally and thus "
"eliminates having to keep track of what type of data you are working with."
msgstr ""
"La creación de la distinción más fácil de controlar se puede realizar "
"mediante la codificación y descodificación entre datos binarios y texto en "
"el borde del código. Esto significa que cuando reciba texto en datos "
"binarios, debe descodificarlo inmediatamente. Y si el código necesita enviar "
"texto como datos binarios, codificarlo lo más tarde posible. Esto permite "
"que el código funcione solo con texto internamente y, por lo tanto, elimina "
"tener que realizar un seguimiento del tipo de datos con los que está "
"trabajando."

#: ../Doc/howto/pyporting.rst:225
#, fuzzy
msgid ""
"The next issue is making sure you know whether the string literals in your "
"code represent text or binary data. You should add a ``b`` prefix to any "
"literal that presents binary data. For text you should add a ``u`` prefix to "
"the text literal. (There is a :mod:`__future__` import to force all "
"unspecified literals to be Unicode, but usage has shown it isn't as "
"effective as adding a ``b`` or ``u`` prefix to all literals explicitly)"
msgstr ""
"El siguiente problema es asegurarse de saber si los literales de cadena en "
"el código representan texto o datos binarios. Debe agregar un prefijo ``b`` "
"a cualquier literal que presente datos binarios. Para el texto debe agregar "
"un prefijo ``u`` al literal de texto. (hay una importación :mod:`__future__` "
"para forzar que todos los literales no especificados sean Unicode, pero el "
"uso ha demostrado que no es tan eficaz como agregar un prefijo ``b`` o ``u`` "
"a todos los literales explícitamente)"

#: ../Doc/howto/pyporting.rst:232
#, fuzzy
msgid ""
"You also need to be careful about opening files. Possibly you have not "
"always bothered to add the ``b`` mode when opening a binary file (e.g., "
"``rb`` for binary reading).  Under Python 3, binary files and text files are "
"clearly distinct and mutually incompatible; see the :mod:`io` module for "
"details. Therefore, you **must** make a decision of whether a file will be "
"used for binary access (allowing binary data to be read and/or written) or "
"textual access (allowing text data to be read and/or written). You should "
"also use :func:`io.open` for opening files instead of the built-in :func:"
"`open` function as the :mod:`io` module is consistent from Python 2 to 3 "
"while the built-in :func:`open` function is not (in Python 3 it's actually :"
"func:`io.open`). Do not bother with the outdated practice of using :func:"
"`codecs.open` as that's only necessary for keeping compatibility with Python "
"2.5."
msgstr ""
"Como parte de esta dicotomía también hay que tener cuidado con la apertura "
"de archivos. A menos que haya estado trabajando en Windows, existe la "
"posibilidad de que no siempre se haya molestado en agregar el modo ``b`` al "
"abrir un archivo binario (por ejemplo, ``rb`` para la lectura binaria).  En "
"Python 3, los archivos binarios y los archivos de texto son claramente "
"distintos y mutuamente incompatibles; ver el módulo :mod:`io` para más "
"detalles. Por lo tanto, **debe** tomar una decisión de si un archivo se "
"utilizará para el acceso binario (permitiendo que los datos binarios se lean "
"y/o escriban) o el acceso textual (permitiendo que los datos de texto sean "
"leídos y/o escritos). También debe utilizar :func:`io.open` para abrir "
"archivos en lugar de la función incorporada :func:`open` como el módulo :mod:"
"`io` es consistente de Python 2 a 3, mientras que la función incorporada :"
"func:`open` no es (en Python 3 es en realidad :func:`io.open`). No se "
"moleste con la práctica obsoleta de usar :func:`codecs.open` ya que sólo es "
"necesario para mantener la compatibilidad con Python 2.5."

#: ../Doc/howto/pyporting.rst:245
#, fuzzy
msgid ""
"The constructors of both ``str`` and ``bytes`` have different semantics for "
"the same arguments between Python 2 and 3. Passing an integer to ``bytes`` "
"in Python 2 will give you the string representation of the integer: "
"``bytes(3) == '3'``. But in Python 3, an integer argument to ``bytes`` will "
"give you a bytes object as long as the integer specified, filled with null "
"bytes: ``bytes(3) == b'\\x00\\x00\\x00'``. A similar worry is necessary when "
"passing a bytes object to ``str``. In Python 2 you just get the bytes object "
"back: ``str(b'3') == b'3'``. But in Python 3 you get the string "
"representation of the bytes object: ``str(b'3') == \"b'3'\"``."
msgstr ""
"Los constructores de ``str`` y ``bytes`` tienen una semántica diferente para "
"los mismos argumentos entre Python 2 y 3. Pasar un entero a ``bytes`` en "
"Python 2 le dará la representación de cadena de texto del entero: ``bytes(3) "
"== '3'``. Pero en Python 3, un argumento entero para ''bytes'' le dará un "
"objeto bytes siempre y cuando el entero especificado, lleno de bytes nulos: "
"``bytes(3) == b'\\x00\\x00\\x00'``. Una preocupación similar es necesaria "
"cuando se pasa un objeto bytes a ``str``. En Python 2, solo se obtiene el "
"objeto bytes: ``str(b'3') == b'3'``. Pero en Python 3 se obtiene la "
"representación de cadena de texto del objeto bytes: ``str(b'3') == "
"\"b'3'\"``."

#: ../Doc/howto/pyporting.rst:255
msgid ""
"Finally, the indexing of binary data requires careful handling (slicing does "
"**not** require any special handling). In Python 2, ``b'123'[1] == b'2'`` "
"while in Python 3 ``b'123'[1] == 50``. Because binary data is simply a "
"collection of binary numbers, Python 3 returns the integer value for the "
"byte you index on. But in Python 2 because ``bytes == str``, indexing "
"returns a one-item slice of bytes. The six_ project has a function named "
"``six.indexbytes()`` which will return an integer like in Python 3: ``six."
"indexbytes(b'123', 1)``."
msgstr ""
"Por último, la indexación de datos binarios requiere un control cuidadoso "
"(el corte **no** requiere ningún control especial). En Python 2, ``b'123'[1] "
"== b'2'`` mientras que en Python 3 ``b'123'[1] == 50``. Dado que los datos "
"binarios son simplemente una colección de números binarios, Python 3 retorna "
"el valor entero para el byte en el que indexa. Pero en Python 2, ya que "
"``bytes == str``, la indexación retorna un segmento de bytes de un solo "
"elemento. El proyecto six_ tiene una función denominada ``six.indexbytes()`` "
"que devolverá un entero como en Python 3: ``six.indexbytes(b'123', 1)``."

#: ../Doc/howto/pyporting.rst:264
msgid "To summarize:"
msgstr "Para resumir:"

#: ../Doc/howto/pyporting.rst:266
msgid "Decide which of your APIs take text and which take binary data"
msgstr "Decida cuál de sus API toma texto y cuáles toman datos binarios"

#: ../Doc/howto/pyporting.rst:267
msgid ""
"Make sure that your code that works with text also works with ``unicode`` "
"and code for binary data works with ``bytes`` in Python 2 (see the table "
"above for what methods you cannot use for each type)"
msgstr ""
"Asegúrese de que el código que funciona con texto también funciona con "
"``unicode`` y el código para datos binarios funciona con ``bytes`` en Python "
"2 (consulte la tabla anterior para los métodos que no puede usar para cada "
"tipo)"

#: ../Doc/howto/pyporting.rst:270
msgid ""
"Mark all binary literals with a ``b`` prefix, textual literals with a ``u`` "
"prefix"
msgstr ""
"Marque todos los literales binarios con un prefijo ``b``, literales "
"textuales con un prefijo ``u``"

#: ../Doc/howto/pyporting.rst:272
msgid ""
"Decode binary data to text as soon as possible, encode text as binary data "
"as late as possible"
msgstr ""
"Descodificar datos binarios en texto tan pronto como sea posible, codificar "
"texto como datos binarios tan tarde como sea posible"

#: ../Doc/howto/pyporting.rst:274
msgid ""
"Open files using :func:`io.open` and make sure to specify the ``b`` mode "
"when appropriate"
msgstr ""
"Abra los archivos con :func:`io.open` y asegúrese de especificar el modo "
"``b`` cuando sea apropiado"

#: ../Doc/howto/pyporting.rst:276
msgid "Be careful when indexing into binary data"
msgstr "Tenga cuidado al indexar en datos binarios"

#: ../Doc/howto/pyporting.rst:280
msgid "Use feature detection instead of version detection"
msgstr ""
"Utilice la detección de funciones en lugar de la detección de versiones"

#: ../Doc/howto/pyporting.rst:282
msgid ""
"Inevitably you will have code that has to choose what to do based on what "
"version of Python is running. The best way to do this is with feature "
"detection of whether the version of Python you're running under supports "
"what you need. If for some reason that doesn't work then you should make the "
"version check be against Python 2 and not Python 3. To help explain this, "
"let's look at an example."
msgstr ""
"Inevitablemente tendrá código que tiene que elegir qué hacer en función de "
"qué versión de Python se está ejecutando. La mejor manera de hacerlo es con "
"la detección de características de si la versión de Python en la que se "
"ejecuta es compatible con lo que necesita. Si por alguna razón eso no "
"funciona, entonces usted debe hacer que la comprobación de la versión sea "
"contra Python 2 y no Python 3. Para ayudar a explicar esto, veamos un "
"ejemplo."

#: ../Doc/howto/pyporting.rst:289
msgid ""
"Let's pretend that you need access to a feature of :mod:`importlib` that is "
"available in Python's standard library since Python 3.3 and available for "
"Python 2 through importlib2_ on PyPI. You might be tempted to write code to "
"access e.g. the :mod:`importlib.abc` module by doing the following::"
msgstr ""
"Supongamos que necesita acceso a una característica de :mod:`importlib` que "
"está disponible en la biblioteca estándar de Python desde Python 3.3 y "
"disponible para Python 2 a través de importlib2_ en PyPI. Es posible que "
"tenga la tentación de escribir código para acceder, por ejemplo, al módulo :"
"mod:`importlib.abc` haciendo lo siguiente:"

#: ../Doc/howto/pyporting.rst:301
msgid ""
"The problem with this code is what happens when Python 4 comes out? It would "
"be better to treat Python 2 as the exceptional case instead of Python 3 and "
"assume that future Python versions will be more compatible with Python 3 "
"than Python 2::"
msgstr ""
"El problema con este código es ¿qué sucede cuando sale Python 4? Sería mejor "
"tratar Python 2 como el caso excepcional en lugar de Python 3 y asumir que "
"las futuras versiones de Python serán más compatibles con Python 3 que "
"Python 2::"

#: ../Doc/howto/pyporting.rst:313
msgid ""
"The best solution, though, is to do no version detection at all and instead "
"rely on feature detection. That avoids any potential issues of getting the "
"version detection wrong and helps keep you future-compatible::"
msgstr ""
"La mejor solución, sin embargo, es no hacer ninguna detección de versiones "
"en absoluto y en su lugar confiar en la detección de características. Esto "
"evita cualquier problema potencial de conseguir la detección de la versión "
"incorrecta y le ayuda a mantenerse compatible con el futuro:"

#: ../Doc/howto/pyporting.rst:324
msgid "Prevent compatibility regressions"
msgstr "Evitar regresiones de compatibilidad"

#: ../Doc/howto/pyporting.rst:326
msgid ""
"Once you have fully translated your code to be compatible with Python 3, you "
"will want to make sure your code doesn't regress and stop working under "
"Python 3. This is especially true if you have a dependency which is blocking "
"you from actually running under Python 3 at the moment."
msgstr ""
"Una vez que haya traducido completamente el código para que sea compatible "
"con Python 3, querrá asegurarse de que el código no retroceda y deje de "
"funcionar bajo Python 3. Esto es especialmente cierto si tiene una "
"dependencia que le está bloqueando para que no se ejecute realmente en "
"Python 3 en este momento."

#: ../Doc/howto/pyporting.rst:331
msgid ""
"To help with staying compatible, any new modules you create should have at "
"least the following block of code at the top of it::"
msgstr ""
"Para ayudar a mantenerse compatible, los módulos nuevos que cree deben tener "
"al menos el siguiente bloque de código en la parte superior del misma::"

#: ../Doc/howto/pyporting.rst:338
msgid ""
"You can also run Python 2 with the ``-3`` flag to be warned about various "
"compatibility issues your code triggers during execution. If you turn "
"warnings into errors with ``-Werror`` then you can make sure that you don't "
"accidentally miss a warning."
msgstr ""
"También puede ejecutar Python 2 con el indicador ``-3`` para recibir una "
"advertencia sobre varios problemas de compatibilidad que el código "
"desencadena durante la ejecución. Si convierte las advertencias en errores "
"con ``-Werror``, puede asegurarse de que no se pierda accidentalmente una "
"advertencia."

#: ../Doc/howto/pyporting.rst:343
msgid ""
"You can also use the Pylint_ project and its ``--py3k`` flag to lint your "
"code to receive warnings when your code begins to deviate from Python 3 "
"compatibility. This also prevents you from having to run Modernize_ or "
"Futurize_ over your code regularly to catch compatibility regressions. This "
"does require you only support Python 2.7 and Python 3.4 or newer as that is "
"Pylint's minimum Python version support."
msgstr ""
"También puede usar el proyecto de Pylint_ y su indicador ``--py3k`` para "
"lintar el código para recibir advertencias cuando el código comienza a "
"desviarse de la compatibilidad con Python 3. Esto también evita que tenga "
"que ejecutar Modernize_ o Futurize_ sobre el código con regularidad para "
"detectar las regresiones de compatibilidad. Esto requiere que solo admita "
"Python 2.7 y Python 3.4 o posterior, ya que es la compatibilidad mínima de "
"la versión mínima de Python de Pylint."

#: ../Doc/howto/pyporting.rst:352
msgid "Check which dependencies block your transition"
msgstr "Compruebe qué dependencias bloquean la transición"

#: ../Doc/howto/pyporting.rst:354
msgid ""
"**After** you have made your code compatible with Python 3 you should begin "
"to care about whether your dependencies have also been ported. The "
"caniusepython3_ project was created to help you determine which projects -- "
"directly or indirectly -- are blocking you from supporting Python 3. There "
"is both a command-line tool as well as a web interface at https://"
"caniusepython3.com."
msgstr ""
"**Después** de que haya hecho que su código sea compatible con Python 3, "
"debe empezar a preocuparse por si sus dependencias también se han portado. "
"El proyecto caniusepython3_ se creó para ayudarle a determinar qué proyectos "
"-- directa o indirectamente -- le impiden admitir Python 3. Hay una "
"herramienta de línea de comandos, así como una interfaz web en https://"
"caniusepython3.com."

#: ../Doc/howto/pyporting.rst:361
msgid ""
"The project also provides code which you can integrate into your test suite "
"so that you will have a failing test when you no longer have dependencies "
"blocking you from using Python 3. This allows you to avoid having to "
"manually check your dependencies and to be notified quickly when you can "
"start running on Python 3."
msgstr ""
"El proyecto también proporciona código que puede integrar en el conjunto de "
"pruebas para que tenga una prueba con errores cuando ya no tenga "
"dependencias que le impidan usar Python 3. Esto le permite evitar tener que "
"comprobar manualmente sus dependencias y recibir notificaciones rápidamente "
"cuando puede empezar a ejecutarse en Python 3."

#: ../Doc/howto/pyporting.rst:368
msgid "Update your ``setup.py`` file to denote Python 3 compatibility"
msgstr ""
"Actualice su archivo ``setup.py`` para denotar compatibilidad con Python 3"

#: ../Doc/howto/pyporting.rst:370
msgid ""
"Once your code works under Python 3, you should update the classifiers in "
"your ``setup.py`` to contain ``Programming Language :: Python :: 3`` and to "
"not specify sole Python 2 support. This will tell anyone using your code "
"that you support Python 2 **and** 3. Ideally you will also want to add "
"classifiers for each major/minor version of Python you now support."
msgstr ""
"Una vez que el código funciona en Python 3, debe actualizar los "
"clasificadores en su ``setup.py`` para que contenga ``Programming "
"Language :: Python :: 3`` y no especificar solo compatibilidad con Python 2. "
"Esto le dirá a cualquier persona que use su código que admite Python 2 **y** "
"3. Lo ideal es que también desee agregar clasificadores para cada versión "
"principal/menor de Python que ahora admita."

#: ../Doc/howto/pyporting.rst:378
msgid "Use continuous integration to stay compatible"
msgstr "Utilice la integración continua para seguir siendo compatible"

#: ../Doc/howto/pyporting.rst:380
#, fuzzy
msgid ""
"Once you are able to fully run under Python 3 you will want to make sure "
"your code always works under both Python 2 and 3. Probably the best tool for "
"running your tests under multiple Python interpreters is tox_. You can then "
"integrate tox with your continuous integration system so that you never "
"accidentally break Python 2 or 3 support."
msgstr ""
"Una vez que pueda ejecutar completamente bajo Python 3, querrá asegurarse de "
"que el código siempre funciona en Python 2 y 3. Probablemente la mejor "
"herramienta para ejecutar las pruebas en varios intérpretes de Python es "
"tox_. A continuación, puede integrar tox con su sistema de integración "
"continua para que nunca interrumpa accidentalmente la compatibilidad con "
"Python 2 o 3."

#: ../Doc/howto/pyporting.rst:386
msgid ""
"You may also want to use the ``-bb`` flag with the Python 3 interpreter to "
"trigger an exception when you are comparing bytes to strings or bytes to an "
"int (the latter is available starting in Python 3.5). By default type-"
"differing comparisons simply return ``False``, but if you made a mistake in "
"your separation of text/binary data handling or indexing on bytes you "
"wouldn't easily find the mistake. This flag will raise an exception when "
"these kinds of comparisons occur, making the mistake much easier to track "
"down."
msgstr ""
"También es posible que desee utilizar el indicador ``-bb`` con el intérprete "
"de Python 3 para desencadenar una excepción cuando se comparan bytes con "
"cadenas o bytes con un int (este último está disponible a partir de Python "
"3.5). De forma predeterminada, las comparaciones de tipos diferentes "
"simplemente retornan ``False``, pero si cometió un error en la separación "
"del control de datos de texto/binario o la indexación en bytes, no "
"encontraría fácilmente el error. Esta marca lanzará una excepción cuando se "
"produzcan este tipo de comparaciones, lo que hace que el error sea mucho más "
"fácil de rastrear."

#: ../Doc/howto/pyporting.rst:396
msgid "Consider using optional static type checking"
msgstr ""
"Considere la posibilidad de usar la comprobación de tipos estáticos "
"opcionales"

#: ../Doc/howto/pyporting.rst:398
msgid ""
"Another way to help port your code is to use a static type checker like "
"mypy_ or pytype_ on your code. These tools can be used to analyze your code "
"as if it's being run under Python 2, then you can run the tool a second time "
"as if your code is running under Python 3. By running a static type checker "
"twice like this you can discover if you're e.g. misusing binary data type in "
"one version of Python compared to another. If you add optional type hints to "
"your code you can also explicitly state whether your APIs use textual or "
"binary data, helping to make sure everything functions as expected in both "
"versions of Python."
msgstr ""
"Otra forma de ayudar a transferir el código es usar un comprobador de tipos "
"estáticos como mypy_ o pytype_ en el código. Estas herramientas se pueden "
"utilizar para analizar el código como si se estuviera ejecutando en Python "
"2, puede ejecutar la herramienta por segunda vez como si el código se "
"ejecutara en Python 3. Al ejecutar un comprobador de tipos estáticos dos "
"veces como este, puede descubrir si, por ejemplo, está usando "
"incorrectamente el tipo de datos binarios en una versión de Python en "
"comparación con otra. Si agrega sugerencias de tipo opcionales al código, "
"también puede indicar explícitamente si las API usan datos textuales o "
"binarios, lo que ayuda a asegurarse de que todo funciona según lo esperado "
"en ambas versiones de Python."

#~ msgid ""
#~ "With Python 3 being the future of Python while Python 2 is still in "
#~ "active use, it is good to have your project available for both major "
#~ "releases of Python. This guide is meant to help you figure out how best "
#~ "to support both Python 2 & 3 simultaneously."
#~ msgstr ""
#~ "Dado que Python 3 es el futuro de Python mientras Python 2 todavía está "
#~ "en uso activo, es bueno tener su proyecto disponible para ambas versiones "
#~ "principales de Python. Esta guía está diseñada para ayudarle a averiguar "
#~ "la mejor manera de admitir Python 2 y 3 simultáneamente."

#~ msgid ""
#~ "If you would like to read one core Python developer's take on why Python "
#~ "3 came into existence, you can read Nick Coghlan's `Python 3 Q & A`_ or "
#~ "Brett Cannon's `Why Python 3 exists`_."
#~ msgstr ""
#~ "Si desea leer la opinión de un desarrollador central de Python sobre por "
#~ "qué Python 3 nació, puede leer las `Python 3 Q & A`_ de Nick Coghlan o el "
#~ "artículo de Brett Cannon `Why Python 3 exists`_."

#~ msgid ""
#~ "For help with porting, you can view the archived python-porting_ mailing "
#~ "list."
#~ msgstr ""
#~ "Para obtener ayuda con la portabilidad, puede ver la lista de correo "
#~ "archivada de python-porting_."

#~ msgid ""
#~ "A key point about supporting Python 2 & 3 simultaneously is that you can "
#~ "start **today**! Even if your dependencies are not supporting Python 3 "
#~ "yet that does not mean you can't modernize your code **now** to support "
#~ "Python 3. Most changes required to support Python 3 lead to cleaner code "
#~ "using newer practices even in Python 2 code."
#~ msgstr ""
#~ "Un punto clave sobre el soporte de Python 2 & 3 simultáneamente es que se "
#~ "puede empezar **hoy**! Incluso si sus dependencias no son compatibles con "
#~ "Python 3 todavía eso no significa que no puede modernizar el código "
#~ "**ahora** para admitir Python 3. La mayoría de los cambios necesarios "
#~ "para admitir Python 3 conducen a código más limpio utilizando prácticas "
#~ "más recientes incluso en código Python 2."

#~ msgid ""
#~ "Another key point is that modernizing your Python 2 code to also support "
#~ "Python 3 is largely automated for you. While you might have to make some "
#~ "API decisions thanks to Python 3 clarifying text data versus binary data, "
#~ "the lower-level work is now mostly done for you and thus can at least "
#~ "benefit from the automated changes immediately."
#~ msgstr ""
#~ "Otro punto clave es que la modernización del código de Python 2 para que "
#~ "también admita Python 3 está en gran medida automatizada para usted. Si "
#~ "bien es posible que tenga que tomar algunas decisiones de API gracias a "
#~ "python 3 aclarando los datos de texto frente a los datos binarios, el "
#~ "trabajo de nivel inferior ahora se realiza principalmente por usted y, "
#~ "por lo tanto, al menos puede beneficiarse de los cambios automatizados "
#~ "inmediatamente."

#~ msgid ""
#~ "Keep those key points in mind while you read on about the details of "
#~ "porting your code to support Python 2 & 3 simultaneously."
#~ msgstr ""
#~ "Tenga en cuenta esos puntos clave mientras lee sobre los detalles de la "
#~ "migración del código para admitir Python 2 & 3 simultáneamente."

#~ msgid "Drop support for Python 2.6 and older"
#~ msgstr "Compatibilidad con Python 2.6 y versiones anteriores"

#~ msgid ""
#~ "But you should aim for only supporting Python 2.7. Python 2.6 is no "
#~ "longer freely supported and thus is not receiving bugfixes. This means "
#~ "**you** will have to work around any issues you come across with Python "
#~ "2.6. There are also some tools mentioned in this HOWTO which do not "
#~ "support Python 2.6 (e.g., Pylint_), and this will become more commonplace "
#~ "as time goes on. It will simply be easier for you if you only support the "
#~ "versions of Python that you have to support."
#~ msgstr ""
#~ "Pero usted debe apuntar a sólo apoyar Python 2.7. Python 2.6 ya no se "
#~ "admite libremente y, por lo tanto, no recibe correcciones de errores. "
#~ "Esto significa que **usted** tendrá que solucionar cualquier problema que "
#~ "encuentre con Python 2.6. También hay algunas herramientas mencionadas en "
#~ "este HOWTO que no son compatibles con Python 2.6 (por ejemplo, Pylint_), "
#~ "y esto se volverá más común a medida que pasa el tiempo. Simplemente será "
#~ "más fácil para usted si sólo admite las versiones de Python que tiene que "
#~ "admitir."

#~ msgid ""
#~ "Once you feel like you know what is different in Python 3 compared to "
#~ "Python 2, it's time to update your code! You have a choice between two "
#~ "tools in porting your code automatically: Futurize_ and Modernize_. Which "
#~ "tool you choose will depend on how much like Python 3 you want your code "
#~ "to be. Futurize_ does its best to make Python 3 idioms and practices "
#~ "exist in Python 2, e.g. backporting the ``bytes`` type from Python 3 so "
#~ "that you have semantic parity between the major versions of Python. "
#~ "Modernize_, on the other hand, is more conservative and targets a Python "
#~ "2/3 subset of Python, directly relying on six_ to help provide "
#~ "compatibility. As Python 3 is the future, it might be best to consider "
#~ "Futurize to begin adjusting to any new practices that Python 3 introduces "
#~ "which you are not accustomed to yet."
#~ msgstr ""
#~ "Una vez que sientas que sabes lo que es diferente en Python 3 en "
#~ "comparación con Python 2, ¡es hora de actualizar tu código! Puede elegir "
#~ "entre dos herramientas para migrar el código automáticamente: Futurize_ y "
#~ "Modernize_. La herramienta que elija dependerá de la cantidad similar a "
#~ "Python 3 que desea que sea el código. Futurize_ hace todo lo posible para "
#~ "que Python 3 modismos y prácticas existan en Python 2, por ejemplo, "
#~ "backporting el tipo ``bytes`` de Python 3 para que tenga paridad "
#~ "semántica entre las versiones principales de Python. Modernize_, por otro "
#~ "lado, es más conservador y se dirige a un subconjunto de Python 2/3 de "
#~ "Python, basándose directamente en six_ para ayudar a proporcionar "
#~ "compatibilidad. Como Python 3 es el futuro, podría ser mejor considerar "
#~ "Futurize para comenzar a adaptarse a cualquier nueva práctica que Python "
#~ "3 introduce a la que aún no está acostumbrado."

#~ msgid ""
#~ "Unfortunately the tools can't automate everything to make your code work "
#~ "under Python 3 and so there are a handful of things you will need to "
#~ "update manually to get full Python 3 support (which of these steps are "
#~ "necessary vary between the tools). Read the documentation for the tool "
#~ "you choose to use to see what it fixes by default and what it can do "
#~ "optionally to know what will (not) be fixed for you and what you may have "
#~ "to fix on your own (e.g. using ``io.open()`` over the built-in ``open()`` "
#~ "function is off by default in Modernize). Luckily, though, there are only "
#~ "a couple of things to watch out for which can be considered large issues "
#~ "that may be hard to debug if not watched for."
#~ msgstr ""
#~ "Desafortunadamente, las herramientas no pueden automatizar todo para que "
#~ "su código funcione bajo Python 3 y por lo que hay un puñado de cosas que "
#~ "tendrá que actualizar manualmente para obtener soporte completo de Python "
#~ "3 (cuáles de estos pasos son necesarios varían entre las herramientas). "
#~ "Lea la documentación de la herramienta que elige utilizar para ver lo que "
#~ "corrige de forma predeterminada y lo que puede hacer opcionalmente para "
#~ "saber lo que (no) se fijará para usted y lo que puede tener que corregir "
#~ "por su cuenta (por ejemplo, usando ``io.open()`` sobre la función "
#~ "incorporada ``open()`` está desactivada por defecto en Modernizar). "
#~ "Afortunadamente, sin embargo, sólo hay un par de cosas a tener en cuenta "
#~ "por las cuales se pueden considerar grandes problemas que pueden ser "
#~ "difíciles de depurar si no se observan."

#~ msgid ""
#~ "And that's mostly it! At this point your code base is compatible with "
#~ "both Python 2 and 3 simultaneously. Your testing will also be set up so "
#~ "that you don't accidentally break Python 2 or 3 compatibility regardless "
#~ "of which version you typically run your tests under while developing."
#~ msgstr ""
#~ "¡Y eso es sobre todo! En este punto, la base de código es compatible con "
#~ "Python 2 y 3 simultáneamente. Las pruebas también se configurarán para "
#~ "que no interrumpa accidentalmente la compatibilidad de Python 2 o 3, "
#~ "independientemente de la versión en la que ejecute normalmente las "
#~ "pruebas durante el desarrollo."
